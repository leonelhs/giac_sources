<HTML>
<HEAD>
  <TITLE>
    Catalogue of GP/PARI Functions: Transcendental functions
  </TITLE>

  <META NAME="author"       CONTENT="Nils-Peter Skoruppa">
  <META NAME="created"      CONTENT="Thu Apr 27 10:11:36 2006">
  <META NAME="author-email" CONTENT="skoruppa@math.uni-siegen.de">
  <META NAME="keywords"     CONTENT="PARI, GP, DOC">
</HEAD>
<BODY bgcolor="#FFFFFF">



<h3 align=center>Transcendental functions</h3>

<a name="^"></a>
<h4><b>^</b></h4>
<p></p>
<p> The expression x{<font color=#a3682a><tt>
^</tt></font>}n is powering.
If the exponent is an integer, then exact operations are performed using
binary (left-shift) powering techniques. In particular, in this case x
cannot be a vector or matrix unless it is a square matrix (invertible
if the exponent is negative). If x is a p-adic number, its
precision will increase if v_p(n) &#62; 0. Powering a binary quadratic form
(types <font color=#a3682a><tt>
t_QFI</tt></font> and <font color=#a3682a><tt>
t_QFR</tt></font>) returns a reduced representative of the
class, provided the input is reduced. In particular, x{<font color=#a3682a><tt>
^</tt></font>}1 is
identical to x.</p>
<p>PARI is able to rewrite the multiplication x * x of two <u>identical</u>
objects as x^2, or <font color=#a3682a><tt>
sqr</tt></font>(x). Here, identical means the operands are
two different labels referencing the same chunk of memory; no equality test
is performed. This is no longer true when more than two arguments are
involved.</p>
<p>If the exponent is not of type integer, this is treated as a transcendental
function (see Section [<b>Label: se:trans</b>]), and in particular has the effect of
componentwise powering on vector or matrices.</p>
<p>As an exception, if the exponent is a rational number p/q and x an
integer modulo a prime or a p-adic number, return a solution y of
y^q = x^p if it exists. Currently, q must not have large prime factors.
Beware that</p>
<p><pre><font color=#a3682a><tt>    ? Mod(7,19)^(1/2)
&nbsp;    %1 = Mod(11, 19) /* is any square root */
&nbsp;    ? sqrt(Mod(7,19))
&nbsp;    %2 = Mod(8, 19)  /* is the smallest square root */
&nbsp;    ? Mod(7,19)^(3/5)
&nbsp;    %3 = Mod(1, 19)
&nbsp;    ? %3^(5/3)
&nbsp;    %4 = Mod(1, 19)  /* Mod(7,19) is just another cubic root */
</tt></font></pre></p>
<p>
If the exponent is a negative integer, an inverse must be computed.
For non-invertible <font color=#a3682a><tt>
t_INTMOD</tt></font>, this will fail and implicitly exhibit a
non trivial factor of the modulus:</p>
<p><pre><font color=#a3682a><tt>    ? Mod(4,6)^(-1)
&nbsp;      ***   impossible inverse modulo: Mod(2, 6).
</tt></font></pre></p>
<p>(Here, a factor 2 is obtained directly. In general, take the gcd of the
representative and the modulus.) This is most useful when performing
complicated operations modulo an integer N whose factorization is
unknown. Either the computation succeeds and all is well, or a factor d
is discovered and the computation may be restarted modulo d or N/d.</p>
<p>For non-invertible <font color=#a3682a><tt>
t_POLMOD</tt></font>, this will fail without exhibiting a
factor.</p>
<p><pre><font color=#a3682a><tt>    ? Mod(x^2, x^3-x)^(-1)
&nbsp;      ***   non-invertible polynomial in RgXQ_inv.
&nbsp;
&nbsp;    ? a = Mod(3,4)*y^3 + Mod(1,4); b = y^6+y^5+y^4+y^3+y^2+y+1;
&nbsp;    ? Mod(a, b)^(-1);
&nbsp;      ***   non-invertible polynomial in RgXQ_inv.
</tt></font></pre></p>
<p>In fact the latter polynomial is invertible, but the algorithm used
(subresultant) assumes the base ring is a domain. If it is not the case,
as here for <b>Z</b>/4<b>Z</b>, a result will be correct but chances are an error
will occur first. In this specific case, one should work with 2-adics.
In general, one can try the following approach</p>
<p><pre><font color=#a3682a><tt>    ? inversemod(a, b) =
&nbsp;    { local(m);
&nbsp;      m = polsylvestermatrix(polrecip(a), polrecip(b));
&nbsp;      m = matinverseimage(m, matid(#m)[,1]);
&nbsp;      Polrev( vecextract(m, Str("..", poldegree(b))), variable(b) )
&nbsp;    }
&nbsp;    ? inversemod(a,b)
&nbsp;    %2 = Mod(2,4)*y^5 + Mod(3,4)*y^3 + Mod(1,4)*y^2 + Mod(3,4)*y + Mod(2,4)
&nbsp;
</tt></font></pre></p>
<p>This is not guaranteed to work either since it must invert pivots. See
Section [<b>Label: se:linear_algebra</b>].</p>
<p>The library syntax is <b>gpow</b>(x,n,<u>prec</u>) for x{<font color=#a3682a><tt>
^</tt></font>}n.</p>

<br>
<hr></hr><br>

<a name="Euler"></a>
<h4><b>Euler</b></h4>
<p></p>
<p> Euler's constant <font color=#FF0000>gamma</font> = 0.57721.... Note that
<font color=#a3682a><tt>
Euler</tt></font> is one of the few special reserved names which cannot be used for
variables (the others are <font color=#a3682a><tt>
I</tt></font> and <font color=#a3682a><tt>
Pi</tt></font>, as well as all function
names). </p>
<p>The library syntax is <b>mpeuler</b>(<u>prec</u>) where <u>prec</u> <u>must</u> be given. Note that
this creates <font color=#FF0000>gamma</font> on the PARI stack, but a copy is also created on the
heap for quicker computations next time the function is called.</p>

<br>
<hr></hr><br>

<a name="I"></a>
<h4><b>I</b></h4>
<p></p>
<p> the complex number sqrt{-1}.</p>
<p>The library syntax is the global variable <font color=#a3682a><tt>
gi</tt></font> (of type <font color=#a3682a><tt>
GEN</tt></font>).</p>

<br>
<hr></hr><br>

<a name="Pi"></a>
<h4><b>Pi</b></h4>
<p></p>
<p> the constant <font color=#FF0000>Pi</font> (3.14159...).</p>
<p>The library syntax is <b>mppi</b>(<u>prec</u>) where <u>prec</u> <u>must</u> be given. Note that
this creates <font color=#FF0000>Pi</font> on the PARI stack, but a copy is also created on the heap
for quicker computations next time the function is called.</p>

<br>
<hr></hr><br>

<a name="abs"></a>
<h4><b>abs</b>(x)</h4>
<p></p>
<p> absolute value of x (modulus if x is complex).
Rational functions are not allowed. Contrary to most transcendental
functions, an exact argument is <u>not</u> converted to a real number before
applying <font color=#a3682a><tt>
abs</tt></font> and an exact result is returned if possible.</p>
<p><pre><font color=#a3682a><tt>? abs(-1)
&nbsp;%1 = 1
&nbsp;? abs(3/7 + 4/7*I)
&nbsp;%2 = 5/7
&nbsp;? abs(1 + I)
&nbsp;%3 = 1.414213562373095048801688724
</tt></font></pre></p>
<p>If x is a polynomial, returns -x if the leading coefficient is
real and negative else returns x. For a power series, the constant
coefficient is considered instead.</p>
<p>The library syntax is <b>gabs</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="acos"></a>
<h4><b>acos</b>(x)</h4>
<p></p>
<p> principal branch of {cos}^{-1}(x),
i.e.such that {Re(acos}(x)) belongs to [0,<font color=#FF0000>Pi</font>]. If
x belongs to <b>R</b> and |x| &#62; 1, then {acos}(x) is complex.</p>
<p>The library syntax is <b>gacos</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="acosh"></a>
<h4><b>acosh</b>(x)</h4>
<p></p>
<p> principal branch of {cosh}^{-1}(x),
i.e.such that {Im(acosh}(x)) belongs to [0,<font color=#FF0000>Pi</font>]. If
x belongs to <b>R</b> and x &#60; 1, then {acosh}(x) is complex.</p>
<p>The library syntax is <b>gach</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="agm"></a>
<h4><b>agm</b>(x,y)</h4>
<p></p>
<p> arithmetic-geometric mean of x and y. In the
case of complex or negative numbers, the principal square root is always
chosen. p-adic or power series arguments are also allowed. Note that
a p-adic agm exists only if x/y is congruent to 1 modulo p (modulo
16 for p = 2). x and y cannot both be vectors or matrices.</p>
<p>The library syntax is <b>agm</b>(x,y,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="arg"></a>
<h4><b>arg</b>(x)</h4>
<p></p>
<p> argument of the complex number x, such that
-<font color=#FF0000>Pi</font> &#60; {arg}(x) <font color=#a3682a><tt>
&#60;=</tt></font> <font color=#FF0000>Pi</font>.</p>
<p>The library syntax is <b>garg</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="asin"></a>
<h4><b>asin</b>(x)</h4>
<p></p>
<p> principal branch of {sin}^{-1}(x), i.e.such
that {Re(asin}(x)) belongs to [-<font color=#FF0000>Pi</font>/2,<font color=#FF0000>Pi</font>/2]. If x belongs to <b>R</b> and |x| &#62; 1 then
{asin}(x) is complex.</p>
<p>The library syntax is <b>gasin</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="asinh"></a>
<h4><b>asinh</b>(x)</h4>
<p></p>
<p> principal branch of {sinh}^{-1}(x), i.e.such
that {Im(asinh}(x)) belongs to [-<font color=#FF0000>Pi</font>/2,<font color=#FF0000>Pi</font>/2].</p>
<p>The library syntax is <b>gash</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="atan"></a>
<h4><b>atan</b>(x)</h4>
<p></p>
<p> principal branch of {tan}^{-1}(x), i.e.such
that {Re(atan}(x)) belongs to  ]-<font color=#FF0000>Pi</font>/2,<font color=#FF0000>Pi</font>/2[.</p>
<p>The library syntax is <b>gatan</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="atanh"></a>
<h4><b>atanh</b>(x)</h4>
<p></p>
<p> principal branch of {tanh}^{-1}(x), i.e.such
that {Im(atanh}(x)) belongs to  ]-<font color=#FF0000>Pi</font>/2,<font color=#FF0000>Pi</font>/2]. If x belongs to <b>R</b> and |x| &#62; 1 then
{atanh}(x) is complex.</p>
<p>The library syntax is <b>gath</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="bernfrac"></a>
<h4><b>bernfrac</b>(x)</h4>
<p></p>
<p> Bernoulli number B_x,
where B_0 = 1, B_1 = -1/2, B_2 = 1/6,..., expressed as a rational number.
The argument x should be of type integer.</p>
<p>The library syntax is <b>bernfrac</b>(x).</p>

<br>
<hr></hr><br>

<a name="bernreal"></a>
<h4><b>bernreal</b>(x)</h4>
<p></p>
<p> Bernoulli number
B_x, as <font color=#a3682a><tt>
bernfrac</tt></font>, but B_x is returned as a real number
(with the current precision).</p>
<p>The library syntax is <b>bernreal</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="bernvec"></a>
<h4><b>bernvec</b>(x)</h4>
<p></p>
<p> creates a vector containing, as rational numbers,
the Bernoulli numbers B_0, B_2,..., B_{2x}.
This routine is obsolete. Use <font color=#a3682a><tt>
bernfrac</tt></font> instead each time you need a
Bernoulli number in exact form.</p>
<p><b>Note:</b> this routine is implemented using repeated independent
calls to <font color=#a3682a><tt>
bernfrac</tt></font>, which is faster than the standard recursion in exact
arithmetic. It is only kept for backward compatibility: it is not faster than
individual calls to <font color=#a3682a><tt>
bernfrac</tt></font>, its output uses a lot of memory space,
and coping with the index shift is awkward.</p>
<p>The library syntax is <b>bernvec</b>(x).</p>

<br>
<hr></hr><br>

<a name="besselh1"></a>
<h4><b>besselh1</b>(<u>nu</u>,x)</h4>
<p></p>
<p> H^1-Bessel function of index <u>nu</u>
and argument x.</p>
<p>The library syntax is <b>hbessel1</b>(<u>nu</u>,x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="besselh2"></a>
<h4><b>besselh2</b>(<u>nu</u>,x)</h4>
<p></p>
<p> H^2-Bessel function of index <u>nu</u>
and argument x.</p>
<p>The library syntax is <b>hbessel2</b>(<u>nu</u>,x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="besseli"></a>
<h4><b>besseli</b>(<u>nu</u>,x)</h4>
<p></p>
<p> I-Bessel function of index <u>nu</u> and
argument x. If x converts to a power series, the initial factor
(x/2)^<font color=#FF0000>nu</font>/<font color=#FF0000>Gamma</font>(<font color=#FF0000>nu</font>+1) is omitted (since it cannot be represented in PARI
when <font color=#FF0000>nu</font> is not integral).</p>
<p>The library syntax is <b>ibessel</b>(<u>nu</u>,x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="besselj"></a>
<h4><b>besselj</b>(<u>nu</u>,x)</h4>
<p></p>
<p> J-Bessel function of index <u>nu</u> and
argument x. If x converts to a power series, the initial factor
(x/2)^<font color=#FF0000>nu</font>/<font color=#FF0000>Gamma</font>(<font color=#FF0000>nu</font>+1) is omitted (since it cannot be represented in PARI
when <font color=#FF0000>nu</font> is not integral).</p>
<p>The library syntax is <b>jbessel</b>(<u>nu</u>,x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="besseljh"></a>
<h4><b>besseljh</b>(n,x)</h4>
<p></p>
<p> J-Bessel function of half integral index.
More precisely, <font color=#a3682a><tt>
besseljh</tt></font>(n,x) computes J_{n+1/2}(x) where n
must be of type integer, and x is any element of <b>C</b>. In the
present version <b>2.2.13</b>, this function is not very accurate when x is
small.</p>
<p>The library syntax is <b>jbesselh</b>(n,x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="besselk"></a>
<h4><b>besselk</b>(<u>nu</u>,x,{<u>flag</u> = 0})</h4>
<p></p>
<p> K-Bessel function of index
<u>nu</u> (which can be complex) and argument x. Only real and positive
arguments x are allowed in the present version <b>2.2.13</b>. If <u>flag</u> is equal to
1, uses another implementation of this function which is faster when x <font color=#a3682a><tt>
&#62;&#62;</tt></font> 1.</p>
<p>The library syntax is <b>kbessel</b>(<u>nu</u>,x,<u>prec</u>) and
<font color=#a3682a><tt>
 <b>kbessel2</b>(<u>nu</u>,x,<u>prec</u>)</tt></font> respectively.</p>

<br>
<hr></hr><br>

<a name="besseln"></a>
<h4><b>besseln</b>(<u>nu</u>,x)</h4>
<p></p>
<p> N-Bessel function of index <u>nu</u>
and argument x.</p>
<p>The library syntax is <b>nbessel</b>(<u>nu</u>,x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="cos"></a>
<h4><b>cos</b>(x)</h4>
<p></p>
<p> cosine of x.</p>
<p>The library syntax is <b>gcos</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="cosh"></a>
<h4><b>cosh</b>(x)</h4>
<p></p>
<p> hyperbolic cosine of x.</p>
<p>The library syntax is <b>gch</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="cotan"></a>
<h4><b>cotan</b>(x)</h4>
<p></p>
<p> cotangent of x.</p>
<p>The library syntax is <b>gcotan</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="dilog"></a>
<h4><b>dilog</b>(x)</h4>
<p></p>
<p> principal branch of the dilogarithm of x,
i.e.analytic continuation of the power series log_2(x) = <font color=#FF0000>sum</font>_{n <font color=#a3682a><tt>
&#62;=</tt></font> 1}x^n/n^2.</p>
<p>The library syntax is <b>dilog</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="eint1"></a>
<h4><b>eint1</b>(x,{n})</h4>
<p></p>
<p> exponential integral
<font color=#FF0000>int</font>_x^ oo (e^{-t})/(t)dt (x belongs to <b>R</b>)</p>
<p>If n is present, outputs the n-dimensional vector
[<font color=#a3682a><tt>
eint1</tt></font>(x),...,<font color=#a3682a><tt>
eint1</tt></font>(nx)] (x <font color=#a3682a><tt>
&#62;=</tt></font> 0). This is faster than
repeatedly calling <font color=#a3682a><tt>
eint1(i * x)</tt></font>.</p>
<p>The library syntax is <b>veceint1</b>(x,n,prec). Also available is <font color=#a3682a><tt>
 <b>eint1</b>(x,prec)</tt></font>.</p>

<br>
<hr></hr><br>

<a name="erfc"></a>
<h4><b>erfc</b>(x)</h4>
<p></p>
<p> complementary error function
(2/sqrt<font color=#FF0000>Pi</font>)<font color=#FF0000>int</font>_x^ oo e^{-t^2}dt (x belongs to <b>R</b>).</p>
<p>The library syntax is <b>erfc</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="eta"></a>
<h4><b>eta</b>(x,{<u>flag</u> = 0})</h4>
<p></p>
<p> Dedekind's <font color=#FF0000>eta</font> function, without the
q^{1/24}. This means the following: if x is a complex number with positive
imaginary part, the result is <font color=#FF0000>prod</font>_{n = 1}^ oo (1-q^n), where
q = e^{2i<font color=#FF0000>Pi</font> x}. If x is a power series (or can be converted to a power
series) with positive valuation, the result is <font color=#FF0000>prod</font>_{n = 1}^ oo (1-x^n).</p>
<p>If <u>flag</u> = 1 and x can be converted to a complex number (i.e.is not a power
series), computes the true <font color=#FF0000>eta</font> function, including the leading q^{1/24}.</p>
<p>The library syntax is <b>eta</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="exp"></a>
<h4><b>exp</b>(x)</h4>
<p></p>
<p> exponential of x.
p-adic arguments with positive valuation are accepted.</p>
<p>The library syntax is <b>gexp</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="gammah"></a>
<h4><b>gammah</b>(x)</h4>
<p></p>
<p> gamma function evaluated at the argument x+1/2.</p>
<p>The library syntax is <b>ggamd</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="gamma"></a>
<h4><b>gamma</b>(x)</h4>
<p></p>
<p> gamma function of x. In the present version
<b>2.2.13</b> the p-adic gamma function is not implemented.</p>
<p>The library syntax is <b>ggamma</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="hyperu"></a>
<h4><b>hyperu</b>(a,b,x)</h4>
<p></p>
<p> U-confluent hypergeometric function with
parameters a and b. The parameters a and b can be complex but
the present implementation requires x to be positive.</p>
<p>The library syntax is <b>hyperu</b>(a,b,x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="incgam"></a>
<h4><b>incgam</b>(s,x,{y})</h4>
<p></p>
<p> incomplete gamma function. The argument x
and s are complex numbers (x must be a positive real number if s = 0).
The result returned is <font color=#FF0000>int</font>_x^ oo e^{-t}t^{s-1}dt. When y is given,
assume (of course without checking!) that y = <font color=#FF0000>Gamma</font>(s). For small x, this
will speed up the computation.</p>
<p>The library syntax is <b>incgam</b>(s,x,<u>prec</u>) and <font color=#a3682a><tt>
 <b>incgam0</b>(s,x,y,prec)</tt></font>,
respectively (an omitted y is coded as <font color=#a3682a><tt>
NULL</tt></font>).</p>

<br>
<hr></hr><br>

<a name="incgamc"></a>
<h4><b>incgamc</b>(s,x)</h4>
<p></p>
<p> complementary incomplete gamma function.
The arguments x and s are complex numbers such that s is not a pole of
<font color=#FF0000>Gamma</font> and |x|/(|s|+1) is not much larger than 1 (otherwise the
convergence is very slow). The result returned is <font color=#FF0000>int</font>_0^x
e^{-t}t^{s-1}dt.</p>
<p>The library syntax is <b>incgamc</b>(s,x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="log"></a>
<h4><b>log</b>(x)</h4>
<p></p>
<p> principal branch of the natural logarithm of
x, i.e.such that {Im(log}(x)) belongs to  ]-<font color=#FF0000>Pi</font>,<font color=#FF0000>Pi</font>]. The result is complex
(with imaginary part equal to <font color=#FF0000>Pi</font>) if x belongs to <b>R</b> and x &#60; 0. In general,
the algorithm uses the formula
log(x)  ~  (<font color=#FF0000>Pi</font>)/(2{agm}(1, 4/s)) - m log 2, 
if s = x 2^m is large enough. (The result is exact to B bits provided
s &#62; 2^{B/2}.) At low accuracies, the series expansion near 1 is used.</p>
<p>p-adic arguments are also accepted for x, with the convention that
log(p) = 0. Hence in particular exp(log(x))/x is not in general equal to
1 but to a (p-1)-th root of unity (or &#177;1 if p = 2) times a power of
p.</p>
<p>The library syntax is <b>glog</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="lngamma"></a>
<h4><b>lngamma</b>(x)</h4>
<p></p>
<p> principal branch of the logarithm of the gamma
function of x. This function is analytic on the complex plane with
non-positive integers removed. Can have much larger arguments than <font color=#a3682a><tt>
gamma</tt></font>
itself. The p-adic <font color=#a3682a><tt>
lngamma</tt></font> function is not implemented.</p>
<p>The library syntax is <b>glngamma</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="polylog"></a>
<h4><b>polylog</b>(m,x,{<u>flag</u> = 0})</h4>
<p></p>
<p> one of the different polylogarithms,
depending on <u>flag</u>:</p>
<p>If <u>flag</u> = 0 or is omitted: m^{th} polylogarithm of x, i.e.analytic
continuation of the power series {Li}_m(x) = <font color=#FF0000>sum</font>_{n <font color=#a3682a><tt>
&#62;=</tt></font> 1}x^n/n^m
(x &#60; 1). Uses the functional equation linking the values at x and 1/x
to restrict to the case |x| <font color=#a3682a><tt>
&#60;=</tt></font> 1, then the power series when
|x|^2 <font color=#a3682a><tt>
&#60;=</tt></font> 1/2, and the power series expansion in log(x) otherwise.</p>
<p>Using <u>flag</u>, computes a modified m^{th} polylogarithm of x.
We use Zagier's notations; let Re_m denotes Re or Im depending
whether m is odd or even:</p>
<p>If <u>flag</u> = 1: compute ~ D_m(x), defined for |x| <font color=#a3682a><tt>
&#60;=</tt></font> 1 by
Re_m(<font color=#FF0000>sum</font>_{k = 0}^{m-1} ((-log|x|)^k)/(k!){Li}_{m-k}(x)
+((-log|x|)^{m-1})/(m!)log|1-x|).</p>
<p>If <u>flag</u> = 2: compute D_m(x), defined for |x| <font color=#a3682a><tt>
&#60;=</tt></font> 1 by
Re_m(<font color=#FF0000>sum</font>_{k = 0}^{m-1}((-log|x|)^k)/(k!){Li}_{m-k}(x)
-(1)/(2)((-log|x|)^m)/(m!)).</p>
<p>If <u>flag</u> = 3: compute P_m(x), defined for |x| <font color=#a3682a><tt>
&#60;=</tt></font> 1 by
Re_m(<font color=#FF0000>sum</font>_{k = 0}^{m-1}(2^kB_k)/(k!)(log|x|)^k{Li}_{m-k}(x)
-(2^{m-1}B_m)/(m!)(log|x|)^m).</p>
<p>These three functions satisfy the functional equation
f_m(1/x) = (-1)^{m-1}f_m(x).</p>
<p>The library syntax is <b>polylog0</b>(m,x,<u>flag</u>,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="psi"></a>
<h4><b>psi</b>(x)</h4>
<p></p>
<p> the <font color=#FF0000>psi</font>-function of x, i.e.the
logarithmic derivative <font color=#FF0000>Gamma</font>'(x)/<font color=#FF0000>Gamma</font>(x).</p>
<p>The library syntax is <b>gpsi</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="sin"></a>
<h4><b>sin</b>(x)</h4>
<p></p>
<p> sine of x.</p>
<p>The library syntax is <b>gsin</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="sinh"></a>
<h4><b>sinh</b>(x)</h4>
<p></p>
<p> hyperbolic sine of x.</p>
<p>The library syntax is <b>gsh</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="sqr"></a>
<h4><b>sqr</b>(x)</h4>
<p></p>
<p> square of x. This operation is not completely
straightforward, i.e.identical to x * x, since it can usually be
computed more efficiently (roughly one-half of the elementary
multiplications can be saved). Also, squaring a 2-adic number increases
its precision. For example,</p>
<p><pre><font color=#a3682a><tt>? (1 + O(2^4))^2
&nbsp;%1 = 1 + O(2^5)
&nbsp;? (1 + O(2^4)) * (1 + O(2^4))
&nbsp;%2 = 1 + O(2^4)
</tt></font></pre></p>
<p>Note that this function is also called whenever one multiplies two objects
which are known to be <u>identical</u>, e.g.they are the value of the same
variable, or we are computing a power.</p>
<p><pre><font color=#a3682a><tt>? x = (1 + O(2^4)); x * x
&nbsp;%3 = 1 + O(2^5)
&nbsp;? (1 + O(2^4))^4
&nbsp;%4 = 1 + O(2^6)
</tt></font></pre></p>
<p>(note the difference between <font color=#a3682a><tt>
%2</tt></font> and <font color=#a3682a><tt>
%3</tt></font> above).</p>
<p>The library syntax is <b>gsqr</b>(x).</p>

<br>
<hr></hr><br>

<a name="sqrt"></a>
<h4><b>sqrt</b>(x)</h4>
<p></p>
<p> principal branch of the square root of x,
i.e.such that {Arg}({sqrt}(x)) belongs to  ]-<font color=#FF0000>Pi</font>/2, <font color=#FF0000>Pi</font>/2], or in other
words such that Re({sqrt}(x)) &#62; 0 or Re({sqrt}(x)) = 0 and
Im({sqrt}(x)) <font color=#a3682a><tt>
&#62;=</tt></font> 0. If x belongs to <b>R</b> and x &#60; 0, then the result is
complex with positive imaginary part.</p>
<p>Intmod a prime and p-adics are allowed as arguments. In that case,
the square root (if it exists) which is returned is the one whose
first p-adic digit (or its unique p-adic digit in the case of
intmods) is in the interval [0,p/2]. When the argument is an
intmod a non-prime (or a non-prime-adic), the result is undefined.</p>
<p>The library syntax is <b>gsqrt</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="sqrtn"></a>
<h4><b>sqrtn</b>(x,n,{&amp;z})</h4>
<p></p>
<p> principal branch of the nth root of x,
i.e.such that {Arg}({sqrt}(x)) belongs to  ]-<font color=#FF0000>Pi</font>/n, <font color=#FF0000>Pi</font>/n]. Intmod
a prime and p-adics are allowed as arguments.</p>
<p>If z is present, it is set to a suitable root of unity allowing to
recover all the other roots. If it was not possible, z is
set to zero. In the case this argument is present and no square root exist,
0 is returned instead or raising an error.</p>
<p><pre><font color=#a3682a><tt>? sqrtn(Mod(2,7), 2)
&nbsp;%1 = Mod(4, 7)
&nbsp;? sqrtn(Mod(2,7), 2, &amp;z); z
&nbsp;%2 = Mod(6, 7)
&nbsp;? sqrtn(Mod(2,7), 3)
&nbsp;  *** sqrtn: nth-root does not exist in gsqrtn.
&nbsp;? sqrtn(Mod(2,7), 3,  &amp;z)
&nbsp;%2 = 0
&nbsp;? z
&nbsp;%3 = 0
</tt></font></pre></p>
<p>
The following script computes all roots in all possible cases:</p>
<p><pre><font color=#a3682a><tt>sqrtnall(x,n)=
&nbsp;{
&nbsp;  local(V,r,z,r2);
&nbsp;  r = sqrtn(x,n, &amp;z);
&nbsp;  if (!z, error("Impossible case in sqrtn"));
&nbsp;  if (type(x) == "t_INTMOD" || type(x)=="t_PADIC" ,
&nbsp;    r2 = r*z; n = 1;
&nbsp;    while (r2!=r, r2*=z;n++));
&nbsp;  V = vector(n); V[1] = r;
&nbsp;  for(i=2, n, V[i] = V[i-1]*z);
&nbsp;  V
&nbsp;}
&nbsp;addhelp(sqrtnall,"sqrtnall(x,n):compute the vector of nth-roots of x");
</tt></font></pre></p>
<p>
The library syntax is <b>gsqrtn</b>(x,n,&amp;z,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="tan"></a>
<h4><b>tan</b>(x)</h4>
<p></p>
<p> tangent of x.</p>
<p>The library syntax is <b>gtan</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="tanh"></a>
<h4><b>tanh</b>(x)</h4>
<p></p>
<p> hyperbolic tangent of x.</p>
<p>The library syntax is <b>gth</b>(x,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="teichmuller"></a>
<h4><b>teichmuller</b>(x)</h4>
<p></p>
<p> Teichm&uuml;ller character of the p-adic number
x, i.e. the unique (p-1)-th root of unity congruent to x / p^{v_p(x)}
modulo p.</p>
<p>The library syntax is <b>teich</b>(x).</p>

<br>
<hr></hr><br>

<a name="theta"></a>
<h4><b>theta</b>(q,z)</h4>
<p></p>
<p> Jacobi sine theta-function.</p>
<p>The library syntax is <b>theta</b>(q,z,<u>prec</u>).</p>

<br>
<hr></hr><br>

<a name="thetanullk"></a>
<h4><b>thetanullk</b>(q,k)</h4>
<p></p>
<p> k-th derivative at z = 0 of
<font color=#a3682a><tt>
theta</tt></font>(q,z).</p>
<p>The library syntax is <b>thetanullk</b>(q,k,<u>prec</u>), where k is a <font color=#a3682a><tt>
long</tt></font>.</p>

<br>
<hr></hr><br>

<a name="weber"></a>
<h4><b>weber</b>(x,{<u>flag</u> = 0})</h4>
<p></p>
<p> one of Weber's three f functions.
If <u>flag</u> = 0, returns
f(x) = exp(-i<font color=#FF0000>Pi</font>/24).<font color=#FF0000>eta</font>((x+1)/2)/<font color=#FF0000>eta</font>(x)   {such that}  
j = (f^{24}-16)^3/f^{24},
where j is the elliptic j-invariant  (see the function <font color=#a3682a><tt>
ellj</tt></font>).
If <u>flag</u> = 1, returns
f_1(x) = <font color=#FF0000>eta</font>(x/2)/<font color=#FF0000>eta</font>(x)  {such that}  
j = (f_1^{24}+16)^3/f_1^{24}.
Finally, if <u>flag</u> = 2, returns
f_2(x) = sqrt{2}<font color=#FF0000>eta</font>(2x)/<font color=#FF0000>eta</font>(x)  {such that}  
j = (f_2^{24}+16)^3/f_2^{24}.
Note the identities f^8 = f_1^8+f_2^8 and ff_1f_2 = sqrt2.</p>
<p>The library syntax is <b>weber0</b>(x,<u>flag</u>,prec). Associated to the various values of <u>flag</u>, the
following functions are also available: <font color=#a3682a><tt>
 <b>werberf</b>(x,prec)</tt></font>,
<font color=#a3682a><tt>
 <b>werberf1</b>(x,prec)</tt></font> or <font color=#a3682a><tt>
 <b>werberf2</b>(x,prec)</tt></font>.</p>

<br>
<hr></hr><br>

<a name="zeta"></a>
<h4><b>zeta</b>(s)</h4>
<p></p>
<p> For s a complex number, Riemann's zeta
function  <font color=#FF0000>zeta</font>(s) = <font color=#FF0000>sum</font>_{n <font color=#a3682a><tt>
&#62;=</tt></font> 1}n^{-s},
computed using the Euler-Maclaurin summation formula, except
when s is of type integer, in which case it is computed using
Bernoulli numbers for s <font color=#a3682a><tt>
&#60;=</tt></font> 0 or s &#62; 0 and
even, and using modular forms for s &#62; 0 and odd.</p>
<p>For s a p-adic number, Kubota-Leopoldt zeta function at s, that
is the unique continuous p-adic function on the p-adic integers
that interpolates the values of (1 - p^{-k}) <font color=#FF0000>zeta</font>(k) at negative
integers k such that k = 1 (mod p-1) (resp. k is odd) if
p is odd (resp. p = 2).</p>
<p>The library syntax is <b>gzeta</b>(s,<u>prec</u>).</p>

<br>
<hr></hr><br>



</BODY>
</HTML>