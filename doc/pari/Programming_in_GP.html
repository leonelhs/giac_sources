<HTML>
<HEAD>
  <TITLE>
    Catalogue of GP/PARI Functions: Programming in GP
  </TITLE>

  <META NAME="author"       CONTENT="Nils-Peter Skoruppa">
  <META NAME="created"      CONTENT="Fri Oct  8 17:54:47 2010">
  <META NAME="author-email" CONTENT="skoruppa@math.uni-siegen.de">
  <META NAME="keywords"     CONTENT="PARI, GP, DOC">
</HEAD>
<BODY bgcolor="#FFFFFF">



<h3 align=center>Programming in GP</h3>

<a name="break"></a>
<h4><b>break</b>({n = 1})</h4>
<p></p>
<p> interrupts execution of current <u>seq</u>, and
immediately exits from the n innermost enclosing loops, within the
current function call (or the top level loop). n must be bigger than 1.
If n is greater than the number of enclosing loops, all enclosing loops
are exited.</p>

<br>
<hr></hr><br>

<a name="for"></a>
<h4><b>for</b>(X = a,b,<u>seq</u>)</h4>
<p></p>
<p> evaluates <u>seq</u>, where 
the formal variable X goes from a to b. Nothing is done if a &#62; b.
a and b must be in <b>R</b>.</p>

<br>
<hr></hr><br>

<a name="fordiv"></a>
<h4><b>fordiv</b>(n,X,<u>seq</u>)</h4>
<p></p>
<p> evaluates <u>seq</u>, where
the formal variable X ranges through the divisors of n
(see <font color=#a3682a><tt>
divisors</tt></font>, which is used as a subroutine). It is assumed that
<font color=#a3682a><tt>
factor</tt></font> can handle n, without negative exponents. Instead of n,
it is possible to input a factorization matrix, i.e. the output of
<font color=#a3682a><tt>
factor(n)</tt></font>.</p>
<p>This routine uses <font color=#a3682a><tt>
divisors</tt></font> as a subroutine, then loops over the
divisors. In particular, if n is an integer, divisors are sorted by
increasing size.</p>
<p>To avoid storing all divisors, possibly using a lot of memory, the following
(much slower) routine loops over the divisors using essentially constant
space:</p>
<p><pre><font color=#a3682a><tt>    FORDIV(N)=
&nbsp;    { local(P, E);
&nbsp;   
&nbsp;      P = factor(N); E = P[,2]; P = P[,1]; 
&nbsp;      forvec( v = vector(#E, i, [0,E[i]]),
&nbsp;        X = factorback(P, v)
&nbsp;        \\ ...
&nbsp;      );
&nbsp;    }
&nbsp;    ? for(i=1,10^5, FORDIV(i))
&nbsp;    time = 3,445 ms.
&nbsp;    ? for(i=1,10^5, fordiv(i, d, ))
&nbsp;    time = 490 ms.
</tt></font></pre></p>

<br>
<hr></hr><br>

<a name="forell"></a>
<h4><b>forell</b>(E,a,b,<u>seq</u>)</h4>
<p></p>
<p> evaluates <u>seq</u>, where 
the formal variable E ranges through all elliptic curves of conductors from
a to b. Th <font color=#a3682a><tt>
elldata</tt></font> database must be installed and contain data for
the specified conductors.</p>

<br>
<hr></hr><br>

<a name="forprime"></a>
<h4><b>forprime</b>(X = a,b,<u>seq</u>)</h4>
<p></p>
<p> evaluates <u>seq</u>,
where the formal variable X ranges over the prime numbers between a to
b (including a and b if they are prime). More precisely, the value of
X is incremented to the smallest prime strictly larger than X at the end
of each iteration. Nothing is done if a &#62; b. Note that a and b must be in
<b>R</b>.</p>
<p>
<pre><font color=#a3682a><tt>? { forprime(p = 2, 12,
&nbsp;      print(p);
&nbsp;      if (p == 3, p = 6);
&nbsp;    )
&nbsp;  }
&nbsp;2
&nbsp;3
&nbsp;7
&nbsp;11
</tt></font></pre></p>

<br>
<hr></hr><br>

<a name="forstep"></a>
<h4><b>forstep</b>(X = a,b,s,<u>seq</u>)</h4>
<p></p>
<p> evaluates <u>seq</u>,
where the formal variable X goes from a to b, in increments of s.
Nothing is done if s &#62; 0 and a &#62; b or if s &#60; 0 and a &#60; b. s must be in
<b>R</b>^* or a vector of steps [s_1,...,s_n]. In the latter case, the
successive steps are used in the order they appear in s.</p>
<p>
<pre><font color=#a3682a><tt>? forstep(x=5, 20, [2,4], print(x))
&nbsp;5
&nbsp;7
&nbsp;11
&nbsp;13
&nbsp;17
&nbsp;19
</tt></font></pre></p>

<br>
<hr></hr><br>

<a name="forsubgroup"></a>
<h4><b>forsubgroup</b>(H = G,{B},<u>seq</u>)</h4>
<p></p>
<p> evaluates <u>seq</u> for
each subgroup H of the <u>abelian</u> group G (given in
SNF form or as a vector of elementary divisors),
whose index is bounded by B. The subgroups are not ordered in any
obvious way, unless G is a p-group in which case Birkhoff's algorithm
produces them by decreasing index. A subgroup is given as a matrix
whose columns give its generators on the implicit generators of G. For
example, the following prints all subgroups of index less than 2 in G = 
<b>Z</b>/2<b>Z</b> g_1  x <b>Z</b>/2<b>Z</b> g_2:</p>
<p>
<pre><font color=#a3682a><tt>? G = [2,2]; forsubgroup(H=G, 2, print(H))
&nbsp;[1; 1]
&nbsp;[1; 2]
&nbsp;[2; 1]
&nbsp;[1, 0; 1, 1]
</tt></font></pre></p>
<p>The last one, for instance is generated by (g_1, g_1 + g_2). This
routine is intended to treat huge groups, when <font color=#a3682a><tt>
subgrouplist</tt></font> is not an
option due to the sheer size of the output.</p>
<p>For maximal speed the subgroups have been left as produced by the algorithm.
To print them in canonical form (as left divisors of G in HNF form), one
can for instance use</p>
<p><pre><font color=#a3682a><tt>? G = matdiagonal([2,2]); forsubgroup(H=G, 2, print(mathnf(concat(G,H))))
&nbsp;[2, 1; 0, 1]
&nbsp;[1, 0; 0, 2]
&nbsp;[2, 0; 0, 1]
&nbsp;[1, 0; 0, 1]
</tt></font></pre></p>
<p>Note that in this last representation, the index [G:H] is given by the
determinant. See <font color=#a3682a><tt>
galoissubcyclo</tt></font> and <font color=#a3682a><tt>
galoisfixedfield</tt></font> for
<font color=#a3682a><tt>
nfsubfields</tt></font> applications to Galois theory.</p>
<p><b>Warning:</b> the present implementation cannot treat a group G, if
one of its p-Sylow subgroups has a cyclic factor with more than 2^{31},
resp.2^{63} elements on a 32-bit, resp.64-bit architecture.</p>

<br>
<hr></hr><br>

<a name="forvec"></a>
<h4><b>forvec</b>(X = v,<u>seq</u>,{<u>flag</u> = 0})</h4>
<p></p>
<p> Let v be an n-component
vector (where n is arbitrary) of two-component vectors [a_i,b_i]
for 1 <font color=#a3682a><tt>
&#60;=</tt></font> i <font color=#a3682a><tt>
&#60;=</tt></font> n. This routine evaluates <u>seq</u>, where the formal
variables X[1],..., X[n] go from a_1 to b_1,..., from a_n to
b_n, i.e.X goes from [a_1,...,a_n] to [b_1,...,b_n] with respect
to the lexicographic ordering. (The formal variable with the highest index
moves the fastest.) If <u>flag</u> = 1, generate only nondecreasing vectors X, and
if <u>flag</u> = 2, generate only strictly increasing vectors X.</p>

<br>
<hr></hr><br>

<a name="if"></a>
<h4><b>if</b>(a,{<u>seq1</u>},{<u>seq2</u>})</h4>
<p></p>
<p>
evaluates the expression sequence <u>seq1</u> if a is non-zero, otherwise
the expression <u>seq2</u>. Of course, <u>seq1</u> or <u>seq2</u> may be empty:</p>
<p><font color=#a3682a><tt>
if (a,<u>seq</u>)</tt></font> evaluates <u>seq</u> if a is not equal to zero
(you don't have to write the second comma), and does nothing otherwise,</p>
<p><font color=#a3682a><tt>
if (a,,<u>seq</u>)</tt></font> evaluates <u>seq</u> if a is equal to zero, and
does nothing otherwise. You could get the same result using the <font color=#a3682a><tt>
!</tt></font>
(<font color=#a3682a><tt>
not</tt></font>) operator: <font color=#a3682a><tt>
if (!a,<u>seq</u>)</tt></font>.</p>
<p>Note that the boolean operators <font color=#a3682a><tt>
&amp;&amp;</tt></font> and <font color=#a3682a><tt>
||</tt></font> are evaluated
according to operator precedence as explained in Section [<b>Label: se:operators</b>], but
that, contrary to other operators, the evaluation of the arguments is stopped
as soon as the final truth value has been determined. For instance</p>
<p><pre><font color=#a3682a><tt>    if (reallydoit &amp;&amp; longcomplicatedfunction(), ...)%
</tt></font></pre></p>
<p>is a perfectly safe statement.</p>
<p>Recall that functions such as <font color=#a3682a><tt>
break</tt></font> and <font color=#a3682a><tt>
next</tt></font> operate on
<u>loops</u> (such as <font color=#a3682a><tt>
forxxx</tt></font>, <font color=#a3682a><tt>
while</tt></font>, <font color=#a3682a><tt>
until</tt></font>). The <font color=#a3682a><tt>
if</tt></font>
statement is <u>not</u> a loop (obviously!).</p>

<br>
<hr></hr><br>

<a name="next"></a>
<h4><b>next</b>({n = 1})</h4>
<p></p>
<p> interrupts execution of current seq,
resume the next iteration of the innermost enclosing loop, within the
current function call (or top level loop). If n is specified, resume at
the n-th enclosing loop. If n is bigger than the number of enclosing
loops, all enclosing loops are exited.</p>

<br>
<hr></hr><br>

<a name="return"></a>
<h4><b>return</b>({x = 0})</h4>
<p></p>
<p> returns from current subroutine, with
result x. If x is omitted, return the <font color=#a3682a><tt>
(void)</tt></font> value (return no
result, like <font color=#a3682a><tt>
print</tt></font>).</p>

<br>
<hr></hr><br>

<a name="until"></a>
<h4><b>until</b>(a,<u>seq</u>)</h4>
<p></p>
<p> evaluates <u>seq</u> until a is not
equal to 0 (i.e.until a is true). If a is initially not equal to 0,
<u>seq</u> is evaluated once (more generally, the condition on a is tested
<u>after</u> execution of the <u>seq</u>, not before as in <font color=#a3682a><tt>
while</tt></font>).</p>

<br>
<hr></hr><br>

<a name="while"></a>
<h4><b>while</b>(a,<u>seq</u>)</h4>
<p></p>
<p> while a is non-zero, evaluates the
expression sequence <u>seq</u>. The test is made <u>before</u> evaluating
the seq, hence in particular if a is initially equal to zero the
<u>seq</u> will not be evaluated at all.</p>

<br>
<hr></hr><br>

<a name="addhelp"></a>
<h4><b>addhelp</b>(S,<u>str</u>)</h4>
<p></p>
<p> changes the help
message for the symbol S. The string <u>str</u> is expanded on the spot
and stored as the online help for S. If S is a function <u>you</u> have
defined, its definition will still be printed before the message <u>str</u>.
It is recommended that you document global variables and user functions in
this way. Of course <font color=#a3682a><tt>
gp</tt></font> will not protest if you skip this.</p>
<p>Nothing prevents you from modifying the help of built-in PARI
functions. (But if you do, we would like to hear why you needed to do it!)</p>

<br>
<hr></hr><br>

<a name="alias"></a>
<h4><b>alias</b>(<u>newkey</u>,<u>key</u>)</h4>
<p></p>
<p> defines the keyword
<u>newkey</u> as an alias for keyword <u>key</u>. <u>key</u> must correspond
to an existing <u>function</u> name. This is different from the general user
macros in that alias expansion takes place immediately upon execution,
without having to look up any function code, and is thus much faster. A
sample alias file <font color=#a3682a><tt>
misc/gpalias</tt></font> is provided with the standard
distribution. Alias commands are meant to be read upon startup from the
<font color=#a3682a><tt>
.gprc</tt></font> file, to cope with function names you are dissatisfied with, and
should be useless in interactive usage.</p>

<br>
<hr></hr><br>

<a name="allocatemem"></a>
<h4><b>allocatemem</b>({x = 0})</h4>
<p></p>
<p> this is a very special operation which
allows the user to change the stack size <u>after</u> initialization. x
must be a non-negative integer. If x != 0, a new stack of size
16*ceil{x/16} bytes is allocated, all the PARI data on the old stack is
moved to the new one, and the old stack is discarded. If x = 0, the size of
the new stack is twice the size of the old one.</p>
<p>Although it is a function, <font color=#a3682a><tt>
allocatemem</tt></font> cannot be used in loop-like
constructs, or as part of a larger expression, e.g <font color=#a3682a><tt>
2 + allocatemem()</tt></font>.
Such an attempt will raise an error. The technical reason is that this
routine usually moves the stack, so objects from the current expression may
not be correct anymore, e.g. loop indexes.</p>
<p>The library syntax is <b>allocatemoremem</b>(x), where x is an unsigned long, and the return type
is void. <font color=#a3682a><tt>
gp</tt></font> uses a variant which makes sure it was not called within a
loop.</p>

<br>
<hr></hr><br>

<a name="default"></a>
<h4><b>default</b>({<u>key</u>},{<u>val</u>})</h4>
<p></p>
<p> returns
the default corresponding to keyword <u>key</u>. If <u>val</u> is present,
sets the default to <u>val</u> first (which is subject to string expansion
first). Typing <font color=#a3682a><tt>
default()</tt></font> (or <font color=#a3682a><tt>
\d</tt></font>) yields the complete default
list as well as their current values.
See Section [<b>Label: se:defaults</b>] for a list of available defaults, and
Section [<b>Label: se:meta</b>] for some shortcut alternatives. Note that the shortcut
are meant for interactive use and usually display more information than
<font color=#a3682a><tt>
default</tt></font>.</p>
<p>The library syntax is <b>gp_default</b>(key, val), where <u>key</u> and <u>val</u> are
<font color=#a3682a><tt>
char *</tt></font>.</p>

<br>
<hr></hr><br>

<a name="error"></a>
<h4><b>error</b>({<u>str</u>}*)</h4>
<p></p>
<p> outputs its argument list (each of
them interpreted as a string), then interrupts the running <font color=#a3682a><tt>
gp</tt></font> program,
returning to the input prompt. For instance</p>
<p><pre><font color=#a3682a><tt>error("n = ", n, " is not squarefree !")
</tt></font></pre></p>

<br>
<hr></hr><br>

<a name="extern"></a>
<h4><b>extern</b>(<u>str</u>)</h4>
<p></p>
<p> the string <u>str</u> is the name
of an external command (i.e.one you would type from your UNIX shell prompt).
This command is immediately run and its input fed into <font color=#a3682a><tt>
gp</tt></font>, just as if read
from a file.</p>
<p>The library syntax is <b>extern0</b>(str), where <u>str</u> is a <font color=#a3682a><tt>
char *</tt></font>.</p>

<br>
<hr></hr><br>

<a name="getheap"></a>
<h4><b>getheap</b>()</h4>
<p></p>
<p> returns a two-component row vector giving the
number of objects on the heap and the amount of memory they occupy in long
words. Useful mainly for debugging purposes.</p>
<p>The library syntax is <b>getheap</b>().</p>

<br>
<hr></hr><br>

<a name="getrand"></a>
<h4><b>getrand</b>()</h4>
<p></p>
<p> returns the current value of the random number
seed. Useful mainly for debugging purposes.</p>
<p>The library syntax is <b>getrand</b>(), returns a C long.</p>

<br>
<hr></hr><br>

<a name="getstack"></a>
<h4><b>getstack</b>()</h4>
<p></p>
<p> returns the current value of
<font color=#a3682a><tt>
top</tt></font>-<font color=#a3682a><tt>
avma</tt></font>, i.e.the number of bytes used up to now on the stack.
Should be equal to 0 in between commands. Useful mainly for debugging
purposes.</p>
<p>The library syntax is <b>getstack</b>(), returns a C long.</p>

<br>
<hr></hr><br>

<a name="gettime"></a>
<h4><b>gettime</b>()</h4>
<p></p>
<p> returns the time (in milliseconds) elapsed since
either the last call to <font color=#a3682a><tt>
gettime</tt></font>, or to the beginning of the containing
GP instruction (if inside <font color=#a3682a><tt>
gp</tt></font>), whichever came last.</p>
<p>The library syntax is <b>gettime</b>(), returns a C long.</p>

<br>
<hr></hr><br>

<a name="global"></a>
<h4><b>global</b>(<u>list of variables</u>)</h4>
<p></p>
<p> 
declares the corresponding variables to be global. From now on, you will be
forbidden to use them as formal parameters for function definitions or as
loop indexes. This is especially useful when patching together various
scripts, possibly written with different naming conventions. For instance the
following situation is dangerous:</p>
<p>
<pre><font color=#a3682a><tt>p = 3   \\</tt></font> fix characteristic<font color=#a3682a><tt></p>
<p>&nbsp;...
&nbsp;forprime(p = 2, N, ...)
&nbsp;f(p) = ...
</tt></font></pre></p>
<p>since within the loop or within the function's body (even worse: in the
subroutines called in that scope), the true global value of <font color=#a3682a><tt>
p</tt></font> will be
hidden. If the statement <font color=#a3682a><tt>
global(p = 3)</tt></font> appears at the beginning of
the script, then both expressions will trigger syntax errors.</p>
<p>Calling <font color=#a3682a><tt>
global</tt></font> without arguments prints the list of global variables in
use. In particular, <font color=#a3682a><tt>
eval(global)</tt></font> will output the values of all global
variables.</p>

<br>
<hr></hr><br>

<a name="input"></a>
<h4><b>input</b>()</h4>
<p></p>
<p> reads a string, interpreted as a GP expression,
from the input file, usually standard input (i.e.the keyboard). If a
sequence of expressions is given, the result is the result of the last
expression of the sequence. When using this instruction, it is useful to
prompt for the string by using the <font color=#a3682a><tt>
print1</tt></font> function. Note that in the
present version 2.19 of <font color=#a3682a><tt>
pari.el</tt></font>, when using <font color=#a3682a><tt>
gp</tt></font> under GNU Emacs (see
Section [<b>Label: se:emacs</b>]) one <u>must</u> prompt for the string, with a string
which ends with the same prompt as any of the previous ones (a <font color=#a3682a><tt>
"? "</tt></font>
will do for instance).</p>

<br>
<hr></hr><br>

<a name="install"></a>
<h4><b>install</b>(<u>name</u>,<u>code</u>,{<u>gpname</u>},{<u>lib</u>})</h4>
<p></p>
<p>
loads from dynamic library <u>lib</u> the function <u>name</u>. Assigns to it
the name <u>gpname</u> in this <font color=#a3682a><tt>
gp</tt></font> session, with argument code <u>code</u>
(see the Libpari Manual for an explanation of those). If <u>lib</u> is
omitted, uses <font color=#a3682a><tt>
libpari.so</tt></font>. If <u>gpname</u> is omitted, uses
<u>name</u>.</p>
<p>This function is useful for adding custom functions to the <font color=#a3682a><tt>
gp</tt></font> interpreter,
or picking useful functions from unrelated libraries. For instance, it
makes the function <font color=#a3682a><tt>
system</tt></font> obsolete:</p>
<p>
<pre><font color=#a3682a><tt>? install(system, vs, sys, "libc.so")
&nbsp;? sys("ls gp*")
&nbsp;gp.c            gp.h            gp_rl.c
</tt></font></pre></p>
<p>
But it also gives you access to all (non static) functions defined in the
PARI library. For instance, the function <font color=#a3682a><tt>
GEN addii(GEN x, GEN y)</tt></font> adds
two PARI integers, and is not directly accessible under <font color=#a3682a><tt>
gp</tt></font> (it's eventually
called by the <font color=#a3682a><tt>
+</tt></font> operator of course):</p>
<p>
<pre><font color=#a3682a><tt>? install("addii", "GG")
&nbsp;? addii(1, 2)
&nbsp;%1 = 3
</tt></font></pre></p>
<p>Re-installing a function will print a Warning, and update the prototype code
if needed, but will reload a symbol from the library, even it the latter has
been recompiled.</p>
<p><b>Caution:</b> This function may not work on all systems, especially
when <font color=#a3682a><tt>
gp</tt></font> has been compiled statically. In that case, the first use of an
installed function will provoke a Segmentation Fault, i.e.a major internal
blunder (this should never happen with a dynamically linked executable).
Hence, if you intend to use this function, please check first on some
harmless example such as the ones above that it works properly on your
machine.</p>

<br>
<hr></hr><br>

<a name="kill"></a>
<h4><b>kill</b>(s)</h4>
<p></p>
<p> kills the present value of the
variable, alias or user-defined function s. The corresponding identifier
can now be used to name any GP object (variable or function). This is the
only way to replace a variable by a function having the same name (or the
other way round), as in the following example:</p>
<p>
<pre><font color=#a3682a><tt>? f = 1
&nbsp;%1 = 1
&nbsp;? f(x) = 0
&nbsp;  ***   unused characters: f(x)=0
&nbsp;                            ^----
&nbsp;? kill(f)
&nbsp;? f(x) = 0
&nbsp;? f()
&nbsp;%2 = 0
</tt></font></pre></p>
<p>
  When you kill a variable, all objects that used it become invalid. You
can still display them, even though the killed variable will be printed in a
funny way. For example:</p>
<p>
<pre><font color=#a3682a><tt>? a^2 + 1
&nbsp;%1 = a^2 + 1
&nbsp;? kill(a)
&nbsp;? %1
&nbsp;%2 = #&#60;1&#62;^2 + 1
</tt></font></pre></p>
<p>
If you simply want to restore a variable to its "undefined" value
(monomial of degree one), use the quote operator: <font color=#a3682a><tt>
a = 'a</tt></font>.
Predefined symbols (<font color=#a3682a><tt>
x</tt></font> and GP function names) cannot be killed.</p>

<br>
<hr></hr><br>

<a name="print"></a>
<h4><b>print</b>({<u>str</u>}*)</h4>
<p></p>
<p> outputs its (string) arguments in raw
format, ending with a newline.</p>

<br>
<hr></hr><br>

<a name="print1"></a>
<h4><b>print1</b>({<u>str</u>}*)</h4>
<p></p>
<p> outputs its (string) arguments in raw
format, without ending with a newline (note that you can still embed newlines
within your strings, using the <font color=#a3682a><tt>
\n</tt></font> notation!).</p>

<br>
<hr></hr><br>

<a name="printp"></a>
<h4><b>printp</b>({<u>str</u>}*)</h4>
<p></p>
<p> outputs its (string) arguments in
prettyprint (beautified) format, ending with a newline.</p>

<br>
<hr></hr><br>

<a name="printp1"></a>
<h4><b>printp1</b>({<u>str</u>}*)</h4>
<p></p>
<p> outputs its (string) arguments in
prettyprint (beautified) format, without ending with a newline.</p>

<br>
<hr></hr><br>

<a name="printtex"></a>
<h4><b>printtex</b>({<u>str</u>}*)</h4>
<p></p>
<p> outputs its (string) arguments in
TeX format. This output can then be used in a TeX manuscript.
The printing is done on the standard output. If you want to print it to a
file you should use <font color=#a3682a><tt>
writetex</tt></font> (see there).</p>
<p>Another possibility is to enable the <font color=#a3682a><tt>
log</tt></font> default
(seeSection [<b>Label: se:defaults</b>]).
You could for instance do:</p>
<p>
<pre><font color=#a3682a><tt>default(logfile, "new.tex");
&nbsp;default(log, 1);
&nbsp;printtex(result);
</tt></font></pre></p>

<br>
<hr></hr><br>

<a name="quit"></a>
<h4><b>quit</b>()</h4>
<p></p>
<p> exits <font color=#a3682a><tt>
gp</tt></font>.</p>

<br>
<hr></hr><br>

<a name="read"></a>
<h4><b>read</b>({<u>filename</u>})</h4>
<p></p>
<p> reads in the file
<u>filename</u> (subject to string expansion). If <u>filename</u> is
omitted, re-reads the last file that was fed into <font color=#a3682a><tt>
gp</tt></font>. The return
value is the result of the last expression evaluated.</p>
<p>If a GP <font color=#a3682a><tt>
binary file</tt></font> is read using this command (see
Section [<b>Label: se:writebin</b>]), the file is loaded and the last object in the file
is returned.</p>

<br>
<hr></hr><br>

<a name="readvec"></a>
<h4><b>readvec</b>({<u>str</u>})</h4>
<p></p>
<p>  reads in the file
<u>filename</u> (subject to string expansion). If <u>filename</u> is
omitted, re-reads the last file that was fed into <font color=#a3682a><tt>
gp</tt></font>. The return
value is a vector whose components are the evaluation of all sequences
of instructions contained in the file. For instance, if <u>file</u> contains</p>
<p><pre><font color=#a3682a><tt>  1
&nbsp;  2
&nbsp;  3
</tt></font></pre></p>
<p>then we will get:</p>
<p><pre><font color=#a3682a><tt>  ? \r a
&nbsp;  %1 = 1
&nbsp;  %2 = 2
&nbsp;  %3 = 3
&nbsp;  ? read(a)
&nbsp;  %4 = 3
&nbsp;  ? readvec(a)
&nbsp;  %5 = [1, 2, 3]
</tt></font></pre></p>
<p>In general a sequence is just a single line, but as usual braces and
<font color=#a3682a><tt>
\\</tt></font> may be used to enter multiline sequences.</p>

<br>
<hr></hr><br>

<a name="reorder"></a>
<h4><b>reorder</b>({x = []})</h4>
<p></p>
<p> x must be a vector. If x is the
empty vector, this gives the vector whose components are the existing
variables in increasing order (i.e.in decreasing importance). Killed
variables (see <font color=#a3682a><tt>
kill</tt></font>) will be shown as <font color=#a3682a><tt>
0</tt></font>. If x is
non-empty, it must be a permutation of variable names, and this permutation
gives a new order of importance of the variables, <u>for output only</u>. For
example, if the existing order is <font color=#a3682a><tt>
[x,y,z]</tt></font>, then after
<font color=#a3682a><tt>
reorder([z,x])</tt></font> the order of importance of the variables, with respect
to output, will be <font color=#a3682a><tt>
[z,y,x]</tt></font>. The internal representation is unaffected.</p>

<br>
<hr></hr><br>

<a name="setrand"></a>
<h4><b>setrand</b>(n)</h4>
<p></p>
<p> reseeds the random number generator to the value
n. The initial seed is n = 1.</p>
<p>The library syntax is <b>setrand</b>(n), where n is a <font color=#a3682a><tt>
long</tt></font>. Returns n.</p>

<br>
<hr></hr><br>

<a name="system"></a>
<h4><b>system</b>(<u>str</u>)</h4>
<p></p>
<p> <u>str</u> is a string representing
a system command. This command is executed, its output written to the
standard output (this won't get into your logfile), and control returns
to the PARI system. This simply calls the C <font color=#a3682a><tt>
system</tt></font> command.</p>

<br>
<hr></hr><br>

<a name="trap"></a>
<h4><b>trap</b>({e}, {<u>rec</u>}, {<u>seq</u>})</h4>
<p></p>
<p> tries to
evaluate <u>seq</u>, trapping error e, that is effectively preventing it
from aborting computations in the usual way; the recovery sequence
<u>rec</u> is executed if the error occurs and the evaluation of <u>rec</u>
becomes the result of the command. If e is omitted, all exceptions are
trapped. Note in particular that hitting <font color=#a3682a><tt>
^C</tt></font> (Control-C) raises an
exception. See Section [<b>Label: se:errorrec</b>] for an introduction to error recovery
under <font color=#a3682a><tt>
gp</tt></font>.</p>
<p>
<pre><font color=#a3682a><tt>? \\</tt></font> trap division by 0<font color=#a3682a><tt></p>
<p>&nbsp;? inv(x) = trap (gdiver, INFINITY, 1/x)
&nbsp;? inv(2)
&nbsp;%1 = 1/2
&nbsp;? inv(0)
&nbsp;%2 = INFINITY
</tt></font></pre></p>
<p>
If <u>seq</u> is omitted, defines <u>rec</u> as a default action when
catching exception e, provided no other trap as above intercepts it first.
The error message is printed, as well as the result of the evaluation of
<u>rec</u>, and control is given back to the <font color=#a3682a><tt>
gp</tt></font> prompt. In particular, current
computation is then lost.</p>
<p>The following error handler prints the list of all user variables, then
stores in a file their name and their values:</p>
<p><pre><font color=#a3682a><tt>? { trap( ,
&nbsp;      print(reorder);
&nbsp;      writebin("crash")) }
</tt></font></pre></p>
<p>
If no recovery code is given (<u>rec</u> is omitted) a <u>break loop</u> will
be started (see Section [<b>Label: se:breakloop</b>]). In particular</p>
<p><pre><font color=#a3682a><tt>? trap()
</tt></font></pre></p>
<p>by itself installs a default error handler, that will start a break
loop whenever an exception is raised.</p>
<p>If <u>rec</u> is the empty string <font color=#a3682a><tt>
""</tt></font> the default handler (for that error
if e is present) is disabled.</p>
<p><b>Note:</b> The interface is currently not adequate for trapping
individual exceptions. In the current version <b>2.3.5</b>, the following keywords
are recognized, but the name list will be expanded and changed in the
future (all library mode errors can be trapped: it's a matter of defining
the keywords to <font color=#a3682a><tt>
gp</tt></font>, and there are currently far too many useless ones):</p>
<p><font color=#a3682a><tt>
accurer</tt></font>: accuracy problem</p>
<p><font color=#a3682a><tt>
archer</tt></font>: not available on this architecture or operating system</p>
<p><font color=#a3682a><tt>
errpile</tt></font>: the PARI stack overflows</p>
<p><font color=#a3682a><tt>
gdiver</tt></font>: division by 0</p>
<p><font color=#a3682a><tt>
invmoder</tt></font>: impossible inverse modulo</p>
<p><font color=#a3682a><tt>
siginter</tt></font>: SIGINT received (usually from Control-C)</p>
<p><font color=#a3682a><tt>
talker</tt></font>: miscellaneous error</p>
<p><font color=#a3682a><tt>
typeer</tt></font>: wrong type</p>
<p><font color=#a3682a><tt>
user</tt></font>: user error (from the <font color=#a3682a><tt>
error</tt></font> function)</p>

<br>
<hr></hr><br>

<a name="type"></a>
<h4><b>type</b>(x)</h4>
<p></p>
<p> this is useful only under <font color=#a3682a><tt>
gp</tt></font>. Returns the
internal type name of the PARI object x as a  string. Check out
existing type names with the metacommand <font color=#a3682a><tt>
\t</tt></font>.
For example <font color=#a3682a><tt>
type(1)</tt></font> will return "<font color=#a3682a><tt>
t_INT</tt></font>".</p>
<p>The library syntax is <b>type0</b>(<u>x</u>), though the macro <font color=#a3682a><tt>
typ</tt></font> is usually simpler to use
since it return an integer that can easily be matched with the symbols <font color=#a3682a><tt>
t_*</tt></font>.
The name <font color=#a3682a><tt>
type</tt></font> was avoided due to the fact that <font color=#a3682a><tt>
type</tt></font> is a reserved identifier for some C(++) compilers.</p>

<br>
<hr></hr><br>

<a name="version"></a>
<h4><b>version</b>()</h4>
<p></p>
<p> Returns the current version number as a <font color=#a3682a><tt>
t_VEC</tt></font>
with three integer components: major version number, minor version number and
patchlevel. To check against a particular version number, you can use:</p>
<p><pre><font color=#a3682a><tt>   if (lex(version(), [2,2,0]) &#62;= 0,
&nbsp;     \\ code to be executed if we are running 2.2.0 or more recent.
&nbsp;   ,
&nbsp;     \\ compatibility code
&nbsp;   );
</tt></font></pre></p>

<br>
<hr></hr><br>

<a name="whatnow"></a>
<h4><b>whatnow</b>(<u>key</u>)</h4>
<p></p>
<p> if keyword <u>key</u> is the name
of a function that was present in GP version 1.39.15 or lower, outputs
the new function name and syntax, if it changed at all (387 out of 560
did).</p>

<br>
<hr></hr><br>

<a name="write"></a>
<h4><b>write</b>(<u>filename</u>,{<u>str</u>}*)</h4>
<p></p>
<p> writes (appends)
to <u>filename</u> the remaining arguments, and appends a newline (same output
as <font color=#a3682a><tt>
print</tt></font>).</p>

<br>
<hr></hr><br>

<a name="write1"></a>
<h4><b>write1</b>(<u>filename</u>,{<u>str</u>}*)</h4>
<p></p>
<p> writes (appends) to
<u>filename</u> the remaining arguments without a trailing newline
(same output as <font color=#a3682a><tt>
print1</tt></font>).</p>

<br>
<hr></hr><br>

<a name="writebin"></a>
<h4><b>writebin</b>(<u>filename</u>,{x})</h4>
<p></p>
<p> writes (appends) to
<u>filename</u> the object x in binary format. This format is not human
readable, but contains the exact internal structure of x, and is much
faster to save/load than a string expression, as would be produced by
<font color=#a3682a><tt>
write</tt></font>. The binary file format includes a magic number, so that such a
file can be recognized and correctly input by the regular <font color=#a3682a><tt>
read</tt></font> or <font color=#a3682a><tt>
\r</tt></font>
function. If saved objects refer to (polynomial) variables that are not
defined in the new session, they will be displayed in a funny way (see
Section [<b>Label: se:kill</b>]).</p>
<p>If x is omitted, saves all user variables from the session, together with
their names. Reading such a "named object" back in a <font color=#a3682a><tt>
gp</tt></font> session will set
the corresponding user variable to the saved value. E.g after</p>
<p><pre><font color=#a3682a><tt>x = 1; writebin("log")
</tt></font></pre></p>
<p>reading <font color=#a3682a><tt>
log</tt></font> into a clean session will set <font color=#a3682a><tt>
x</tt></font> to 1.
The relative variables priorities (see Section [<b>Label: se:priority</b>]) of new variables
set in this way remain the same (preset variables retain their former
priority, but are set to the new value). In particular, reading such a
session log into a clean session will restore all variables exactly as they
were in the original one.</p>
<p>User functions, installed functions and history objects can not be saved via
this function. Just as a regular input file, a binary file can be compressed
using <font color=#a3682a><tt>
gzip</tt></font>, provided the file name has the standard <font color=#a3682a><tt>
.gz</tt></font>
extension. </p>
<p>In the present implementation, the binary files are architecture dependent
and compatibility with future versions of <font color=#a3682a><tt>
gp</tt></font> is not guaranteed. Hence
binary files should not be used for long term storage (also, they are
larger and harder to compress than text files).</p>

<br>
<hr></hr><br>

<a name="writetex"></a>
<h4><b>writetex</b>(<u>filename</u>,{<u>str</u>}*)</h4>
<p></p>
<p> as <font color=#a3682a><tt>
write</tt></font>,
in TeX format.</p>

<br>
<hr></hr><br>



</BODY>
</HTML>