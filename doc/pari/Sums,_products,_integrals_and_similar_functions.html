<HTML>
<HEAD>
  <TITLE>
    Catalogue of GP/PARI Functions: Sums, products, integrals and similar functions
  </TITLE>

  <META NAME="author"       CONTENT="Nils-Peter Skoruppa">
  <META NAME="created"      CONTENT="Thu Apr 27 10:11:36 2006">
  <META NAME="author-email" CONTENT="skoruppa@math.uni-siegen.de">
  <META NAME="keywords"     CONTENT="PARI, GP, DOC">
</HEAD>
<BODY bgcolor="#FFFFFF">



<h3 align=center>Sums, products, integrals and similar functions</h3>

<a name="intcirc"></a>
<h4><b>intcirc</b>(X = a,R,<u>expr</u>, {<u>tab</u>})</h4>
<p></p>
<p> numerical
integration of <u>expr</u> with respect to X on the circle |X-a |= R,
divided by 2i<font color=#FF0000>Pi</font>. In other words, when <u>expr</u> is a meromorphic
function, sum of the residues in the corresponding disk. <u>tab</u> is as in
<font color=#a3682a><tt>
intnum</tt></font>, except that if computed with <font color=#a3682a><tt>
intnuminit</tt></font> it should be with
the endpoints <font color=#a3682a><tt>
[-1, 1]</tt></font>.</p>
<p>
<pre><font color=#a3682a><tt>? \p105
&nbsp;? intcirc(s=1, 0.5, zeta(s)) - 1
&nbsp;time = 3,460 ms.
&nbsp;%1 = -2.40... E-104 - 2.7... E-106*I
</tt></font></pre></p>
<p>
The library syntax is <b>intcirc</b>(void *E, GEN (*eval)(GEN,void*), GEN a,GEN R,GEN tab, long prec).</p>

<br>
<hr></hr><br>

<a name="intfouriercos"></a>
<h4><b>intfouriercos</b>(X = a,b,z,<u>expr</u>,{<u>tab</u>})</h4>
<p></p>
<p> numerical
integration of <u>expr</u>(X)cos(2<font color=#FF0000>Pi</font> zX) from a to b, in other words
Fourier cosine transform (from a to b) of the function represented by
<u>expr</u>. a and b are coded as in <font color=#a3682a><tt>
intnum</tt></font>, and are not necessarily
at infinity, but if they are, oscillations (i.e. [[&#177;1],<font color=#FF0000>alpha</font> I]) are
forbidden.</p>
<p>The library syntax is <b>intfouriercos</b>(void *E, GEN (*eval)(GEN,void*), GEN a, GEN b, GEN z, GEN tab, long prec).</p>

<br>
<hr></hr><br>

<a name="intfourierexp"></a>
<h4><b>intfourierexp</b>(X = a,b,z,<u>expr</u>,{<u>tab</u>})</h4>
<p></p>
<p> numerical
integration of <u>expr</u>(X)exp(-2<font color=#FF0000>Pi</font> zX) from a to b, in other words
Fourier transform (from a to b) of the function represented by
<u>expr</u>. Note the minus sign. a and b are coded as in <font color=#a3682a><tt>
intnum</tt></font>,
and are not necessarily at infinity but if they are, oscillations (i.e.
[[&#177;1],<font color=#FF0000>alpha</font> I]) are forbidden.</p>
<p>The library syntax is <b>intfourierexp</b>(void *E, GEN (*eval)(GEN,void*), GEN a, GEN b, GEN z, GEN tab, long prec).</p>

<br>
<hr></hr><br>

<a name="intfouriersin"></a>
<h4><b>intfouriersin</b>(X = a,b,z,<u>expr</u>,{<u>tab</u>})</h4>
<p></p>
<p> numerical
integration of <u>expr</u>(X)sin(2<font color=#FF0000>Pi</font> zX) from a to b, in other words
Fourier sine transform (from a to b) of the function represented by
<u>expr</u>. a and b are coded as in <font color=#a3682a><tt>
intnum</tt></font>, and are not necessarily
at infinity but if they are, oscillations (i.e. [[&#177;1],<font color=#FF0000>alpha</font> I]) are
forbidden.</p>
<p>The library syntax is <b>intfouriersin</b>(void *E, GEN (*eval)(GEN,void*), GEN a, GEN b, GEN z, GEN tab, long prec).</p>

<br>
<hr></hr><br>

<a name="intfuncinit"></a>
<h4><b>intfuncinit</b>(X = a,b,<u>expr</u>,{<u>flag</u> = 0},{m = 0})</h4>
<p></p>
<p>
initalize tables for use with integral transforms such as <font color=#a3682a><tt>
intmellininv</tt></font>,
etc., where a and b are coded as in <font color=#a3682a><tt>
intnum</tt></font>, <u>expr</u> is the
function s(X) to which the integral transform is to be applied (which will
multiply the weights of integration) and m is as in <font color=#a3682a><tt>
intnuminit</tt></font>. If
<u>flag</u> is nonzero, assumes that s(-X) = \overline{s(X)}, which makes the
computation twice as fast. See <font color=#a3682a><tt>
intmellininvshort</tt></font> for examples of the
use of this function, which is particularly useful when the function s(X)
is lengthy to compute, such as a gamma product.</p>
<p>The library syntax is <b>intfuncinit</b>(void *E, GEN (*eval)(GEN,void*), GEN a,GEN b,long m, long flag, long prec).
Note that the order of m and <u>flag</u> are reversed compared to the <font color=#a3682a><tt>
GP</tt></font>
syntax.</p>

<br>
<hr></hr><br>

<a name="intlaplaceinv"></a>
<h4><b>intlaplaceinv</b>(X = sig,z,<u>expr</u>,{<u>tab</u>})</h4>
<p></p>
<p>
numerical integration of <u>expr</u>(X)e^{Xz} with respect to X on the line
Re(X) = sig, divided by 2i<font color=#FF0000>Pi</font>, in other words, inverse Laplace transform
of the function corresponding to <u>expr</u> at the value z.</p>
<p>sig is coded as follows. Either it is a real number <font color=#FF0000>sigma</font>, equal to the
abcissa of integration, and then the function to be integrated is assumed to
be slowly decreasing when the imaginary part of the variable tends to
&#177; oo . Or it is a two component vector [<font color=#FF0000>sigma</font>,<font color=#FF0000>alpha</font>], where
<font color=#FF0000>sigma</font> is as before, and either <font color=#FF0000>alpha</font> = 0 for slowly decreasing functions,
or <font color=#FF0000>alpha</font> &#62; 0 for functions decreasing like exp(-<font color=#FF0000>alpha</font> t). Note that it
is not necessary to choose the exact value of <font color=#FF0000>alpha</font>. <u>tab</u> is as in
<font color=#a3682a><tt>
intnum</tt></font>.</p>
<p>It is often a good idea to use this function with a value of m one or two
higher than the one chosen by default (which can be viewed thanks to the
function <font color=#a3682a><tt>
intnumstep</tt></font>), or to increase the abcissa of integration
<font color=#FF0000>sigma</font>. For example:</p>
<p>
<pre><font color=#a3682a><tt>? \p 105
&nbsp;? intlaplaceinv(x=2, 1, 1/x) - 1
&nbsp;time = 350 ms.
&nbsp;%1 = 7.37... E-55 + 1.72... E-54*I \\</tt></font> not so good<font color=#a3682a><tt></p>
<p>&nbsp;? m = intnumstep()
&nbsp;%2 = 7
&nbsp;? intlaplaceinv(x=2, 1, 1/x, m+1) - 1
&nbsp;time = 700 ms.
&nbsp;%3 = 3.95... E-97 + 4.76... E-98*I \\</tt></font> better<font color=#a3682a><tt></p>
<p>&nbsp;? intlaplaceinv(x=2, 1, 1/x, m+2) - 1
&nbsp;time = 1400 ms.
&nbsp;%4 = 0.E-105 + 0.E-106*I \\</tt></font> perfect but slow.<font color=#a3682a><tt></p>
<p>&nbsp;? intlaplaceinv(x=5, 1, 1/x) - 1
&nbsp;time = 340 ms.
&nbsp;%5 = -5.98... E-85 + 8.08... E-85*I \\</tt></font> better than %1<font color=#a3682a><tt></p>
<p>&nbsp;? intlaplaceinv(x=5, 1, 1/x, m+1) - 1
&nbsp;time = 680 ms.
&nbsp;%6 = -1.09... E-106 + 0.E-104*I \\</tt></font> perfect, fast.<font color=#a3682a><tt></p>
<p>&nbsp;? intlaplaceinv(x=10, 1, 1/x) - 1
&nbsp;time = 340 ms.
&nbsp;%7 = -4.36... E-106 + 0.E-102*I \\</tt></font> perfect, fastest, but why sig = 10?<font color=#a3682a><tt></p>
<p>&nbsp;? intlaplaceinv(x=100, 1, 1/x) - 1
&nbsp;time = 330 ms.
&nbsp;%7 = 1.07... E-72 + 3.2... E-72*I \\</tt></font> too far now...<font color=#a3682a><tt></p>
<p></tt></font></pre></p>
<p>
The library syntax is <b>intlaplaceinv</b>(void *E, GEN (*eval)(GEN,void*), GEN sig,GEN z, GEN tab, long prec).</p>

<br>
<hr></hr><br>

<a name="intmellininv"></a>
<h4><b>intmellininv</b>(X = sig,z,<u>expr</u>,{<u>tab</u>})</h4>
<p></p>
<p> numerical
integration of <u>expr</u>(X)z^{-X} with respect to X on the line
Re(X) = sig, divided by 2i<font color=#FF0000>Pi</font>, in other words, inverse Mellin transform of
the function corresponding to <u>expr</u> at the value z.</p>
<p>sig is coded as follows. Either it is a real number <font color=#FF0000>sigma</font>, equal to the
abcissa of integration, and then the function to be integrated is assumed to
decrease exponentially fast, of the order of exp(-t) when the imaginary
part of the variable tends to &#177; oo . Or it is a two component vector
[<font color=#FF0000>sigma</font>,<font color=#FF0000>alpha</font>], where <font color=#FF0000>sigma</font> is as before, and either <font color=#FF0000>alpha</font> = 0 for
slowly decreasing functions, or <font color=#FF0000>alpha</font> &#62; 0 for functions decreasing like
exp(-<font color=#FF0000>alpha</font> t), such as gamma products. Note that it is not necessary to
choose the exact value of <font color=#FF0000>alpha</font>, and that <font color=#FF0000>alpha</font> = 1 (equivalent to sig
alone) is usually sufficient. <u>tab</u> is as in <font color=#a3682a><tt>
intnum</tt></font>.</p>
<p>As all similar functions, this function is provided for the convenience of
the user, who could use <font color=#a3682a><tt>
intnum</tt></font> directly. However it is in general
better to use <font color=#a3682a><tt>
intmellininvshort</tt></font>.</p>
<p>
<pre><font color=#a3682a><tt>? \p 105
&nbsp;? intmellininv(s=2,4, gamma(s)^3);
&nbsp;time = 1,190 ms. \\</tt></font> reasonable.<font color=#a3682a><tt></p>
<p>&nbsp;? \p 308
&nbsp;? intmellininv(s=2,4, gamma(s)^3);
&nbsp;time = 51,300 ms. \\</tt></font> slow because of <font color=#FF0000>Gamma</font>(s)^3.<font color=#a3682a><tt></p>
<p></tt></font></pre></p>
<p>
The library syntax is <b>intmellininv</b>(void *E, GEN (*eval)(GEN,void*), GEN sig, GEN z, GEN tab, long prec).</p>

<br>
<hr></hr><br>

<a name="intmellininvshort"></a>
<h4><b>intmellininvshort</b>(sig,z,tab)</h4>
<p></p>
<p> numerical integration
of s(X)z^{-X} with respect to X on the line Re(X) = sig, divided by
2i<font color=#FF0000>Pi</font>, in other words, inverse Mellin transform of s(X) at the value z.
Here s(X) is implicitly contained in <u>tab</u> in <font color=#a3682a><tt>
intfuncinit</tt></font> format,
typically</p>
<p><pre><font color=#a3682a><tt>  tab = intfuncinit(T = [-1], [1], s(sig + I*T))
</tt></font></pre></p>
<p>or similar commands. Take the example of the inverse Mellin transform of
<font color=#FF0000>Gamma</font>(s)^3 given in <font color=#a3682a><tt>
intmellininv</tt></font>:</p>
<p>
<pre><font color=#a3682a><tt>? \p 105
&nbsp;? oo = [1]; \\</tt></font> for clarity<font color=#a3682a><tt></p>
<p>&nbsp;? A = intmellininv(s=2,4, gamma(s)^3);
&nbsp;time = 2,500 ms. \\</tt></font> not too fast because of <font color=#FF0000>Gamma</font>(s)^3.<font color=#a3682a><tt></p>
<p>&nbsp;\\ </tt></font> function of real type, decreasing as exp(-3<font color=#FF0000>Pi</font>/2.|t|)<font color=#a3682a><tt></p>
<p>&nbsp;? tab = intfuncinit(t=[-oo, 3*Pi/2],[oo, 3*Pi/2], gamma(2+I*t)^3, 1);
&nbsp;time = 1,370 ms.
&nbsp;? intmellininvshort(2,4, tab) - A
&nbsp;time = 50 ms.
&nbsp;%4 = -1.26... - 3.25...E-109*I \\</tt></font> 50 times faster than <font color=#a3682a><tt>
A</tt></font> and perfect.<font color=#a3682a><tt></p>
<p>&nbsp;? tab2 = intfuncinit(t=-oo, oo, gamma(2+I*t)^3, 1);
&nbsp;? intmellininvshort(2,4, tab2)
&nbsp;%6 = -1.2...E-42 - 3.2...E-109*I  \\</tt></font> 63 digits lost<font color=#a3682a><tt></p>
<p></tt></font></pre></p>
<p>In the computation of <u>tab</u>, it was not essential to include the
<u>exact</u> exponential decrease of <font color=#FF0000>Gamma</font>(2+it)^3. But as the last
example shows, a rough indication <u>must</u> be given, otherwise slow
decrease is assumed, resulting in catastrophic loss of accuracy.</p>
<p>The library syntax is <b>intmellininvshort</b>(GEN sig, GEN z, GEN tab, long prec).</p>

<br>
<hr></hr><br>

<a name="intnum"></a>
<h4><b>intnum</b>(X = a,b,<u>expr</u>,{<u>tab</u>})</h4>
<p></p>
<p> numerical integration
of <u>expr</u> on [a,b] (possibly infinite interval) with respect to X,
where a and b are coded as explained below. The integrand may have values
belonging to a vector space over the real numbers; in particular, it can be
complex-valued or vector-valued.</p>
<p>If <u>tab</u> is omitted, necessary integration tables are computed using
<font color=#a3682a><tt>
intnuminit</tt></font> according to the current precision. It may be a positive
integer m, and tables are computed assuming the integration step is
1/2^m. Finally <u>tab</u> can be a table output by <font color=#a3682a><tt>
intnuminit</tt></font>, in
which case it is used directly. This is important if several integrations of
the same type are performed (on the same kind of interval and functions, and
the same accuracy), since it saves expensive precomputations.</p>
<p>If <u>tab</u> is omitted the algorithm guesses a reasonable value for m
depending on the current precision. That value may be obtained as</p>
<p><pre><font color=#a3682a><tt>  intnumstep()
</tt></font></pre></p>
<p>However this value may be off from the optimal one, and this is important
since the integration time is roughly proportional to 2^m. One may try
consecutive values of m until they give the same value up to an accepted
error.</p>
<p>The endpoints a and b are coded as follows. If a is not at &#177; oo ,
it is either coded as a scalar (real or complex), or as a two component vector
[a,<font color=#FF0000>alpha</font>], where the function is assumed to have a singularity of the
form (x-a)^{<font color=#FF0000>alpha</font>+<font color=#FF0000>epsilon</font>} at a, where <font color=#FF0000>epsilon</font> indicates that powers
of logarithms are neglected. In particular, [a,<font color=#FF0000>alpha</font>] with <font color=#FF0000>alpha</font> <font color=#a3682a><tt>
&#62;=</tt></font> 0
is equivalent to a. If a wrong singularity exponent is used, the result
will lose a catastrophic number of decimals, for instance approximately half
the number of digits will be correct if <font color=#FF0000>alpha</font> = -1/2 is omitted.</p>
<p>The endpoints of integration can be &#177; oo , which is coded as
[&#177; 1] or as [[&#177;1],<font color=#FF0000>alpha</font>]. Here <font color=#FF0000>alpha</font> codes the behaviour of the
function at &#177; oo  as follows.</p>
<p><b>*</b> <font color=#FF0000>alpha</font> = 0 (or no <font color=#FF0000>alpha</font> at all, i.e. simply [&#177;1]) assumes that the
function to be integrated tends to zero, but not exponentially fast, and not
oscillating such as sin(x)/x.</p>
<p><b>*</b> <font color=#FF0000>alpha</font> &#62; 0 assumes that the function tends to zero exponentially fast
approximately as exp(-<font color=#FF0000>alpha</font> x), including reasonably oscillating
functions such as exp(-x)sin(x). The precise choice of <font color=#FF0000>alpha</font>, while
useful in extreme cases, is not critical, and may be off by a <u>factor</u>
of 10 or more from the correct value.</p>
<p><b>*</b> <font color=#FF0000>alpha</font> &#60; -1 assumes that the function tends to 0 slowly, like
x^{<font color=#FF0000>alpha</font>}. Here it is essential to give the correct <font color=#FF0000>alpha</font>, if possible,
but on the other hand <font color=#FF0000>alpha</font> <font color=#a3682a><tt>
&#60;=</tt></font> -2 is equivalent to <font color=#FF0000>alpha</font> = 0, in other
words to no <font color=#FF0000>alpha</font> at all.</p>
<p>The last two codes are reserved for oscillating functions.
Let k &#62; 0 real, and g(x) a nonoscillating function tending to 0, then</p>
<p><b>*</b> <font color=#FF0000>alpha</font> = k I assumes that the function behaves like cos(kx)g(x).</p>
<p><b>*</b> <font color=#FF0000>alpha</font> = -kI assumes that the function behaves like sin(kx)g(x).</p>
<p>Here it is critical to give the exact value of k. If the
oscillating part is not a pure sine or cosine, one must expand it into a
Fourier series, use the above codings, and sum the resulting contributions.
Otherwise you will get nonsense. Note that cos(kx) (and similarly
sin(kx)) means that very function, and not a translated version such as
cos(kx+a).</p>
<p>If for instance f(x) = cos(kx)g(x) where g(x) tends to zero exponentially
fast as exp(-<font color=#FF0000>alpha</font> x), it is up to the user to choose between
[[&#177;1],<font color=#FF0000>alpha</font>] and [[&#177;1],kI], but a good rule of thumb is that if the
oscillations are much weaker than the exponential decrease, choose
[[&#177;1],<font color=#FF0000>alpha</font>], otherwise choose [[&#177;1],kI], although the latter can
reasonably be used in all cases, while the former cannot. To take a specific
example, in the inverse Mellin transform, the function to be integrated is
almost always exponentially decreasing times oscillating. If we choose the
oscillating type of integral we perhaps obtain the best results, at the
expense of having to recompute our functions for a different value of the
variable z giving the transform, preventing us to use a function such as
<font color=#a3682a><tt>
intmellininvshort</tt></font>. On the other hand using the exponential type of
integral, we obtain less accurate results, but we skip expensive
recomputations. See <font color=#a3682a><tt>
intmellininvshort</tt></font> and <font color=#a3682a><tt>
intfuncinit</tt></font> for more
explanations.</p>
<p>
<b>Note.</b> If you do not like the code [&#177;1] for &#177; oo , you
are welcome to set, e.g <font color=#a3682a><tt>
oo = [1]</tt></font> or <font color=#a3682a><tt>
INFINITY = [1]</tt></font>, then
using <font color=#a3682a><tt>
+oo</tt></font>, <font color=#a3682a><tt>
-oo</tt></font>, <font color=#a3682a><tt>
-INFINITY</tt></font>, etc. will have the expected
behaviour.</p>
<p>We shall now see many examples to get a feeling for what the various
parameters achieve. All examples below assume precision is set to 105
decimal digits. We first type</p>
<p><pre><font color=#a3682a><tt>? \p 105
&nbsp;? oo = [1]  \\</tt></font> for clarity<font color=#a3682a><tt></p>
<p></tt></font></pre></p>
<p>
<b>Apparent singularities.</b> Even if the function f(x) represented
by <u>expr</u> has no singularities, it may be important to define the
function differently near special points. For instance, if f(x) = 1
/(exp(x)-1) - exp(-x)/x, then <font color=#FF0000>int</font>_0^ oo f(x)dx = <font color=#FF0000>gamma</font>, Euler's
constant <font color=#a3682a><tt>
Euler</tt></font>. But</p>
<p>
<pre><font color=#a3682a><tt>? f(x) = 1/(exp(x)-1) - exp(-x)/x
&nbsp;? intnum(x = 0, [oo,1],  f(x)) - Euler
&nbsp;%1 = 6.00... E-67
</tt></font></pre></p>
<p>thus only correct to 76 decimal digits. This is because close to 0 the
function f is computed with an enormous loss of accuracy.
 A better solution is</p>
<p>
<pre><font color=#a3682a><tt>? f(x) = 1/(exp(x)-1)-exp(-x)/x
&nbsp;? F = truncate( f(t + O(t^7)) ); \\</tt></font> expansion around t = 0<font color=#a3682a><tt></p>
<p>&nbsp;? g(x) = if (x &#62; 1e-18, f(x), subst(F,t,x))  \\</tt></font> note that 6.18 &#62; 105<font color=#a3682a><tt></p>
<p>&nbsp;? intnum(x = 0, [oo,1],  g(x)) - Euler
&nbsp;%2 = 0.E-106 \\</tt></font> perfect<font color=#a3682a><tt></p>
<p></tt></font></pre></p>
<p>It is up to the user to determine constants such as the 10^{-18} and 7
used above.</p>
<p><b>True singularities.</b> With true singularities the result is much
worse. For instance</p>
<p>
<pre><font color=#a3682a><tt>? intnum(x = 0, 1,  1/sqrt(x)) - 2
&nbsp;%1 = -1.92... E-59 \\</tt></font> only 59 correct decimals<font color=#a3682a><tt></p>
<p>&nbsp;
&nbsp;? intnum(x = [0,-1/2], 1,  1/sqrt(x)) - 2
&nbsp;%2 = 0.E-105 \\</tt></font> better<font color=#a3682a><tt></p>
<p></tt></font></pre></p>
<p>
<b>Oscillating functions.</b></p>
<p>
<pre><font color=#a3682a><tt>? intnum(x = 0, oo, sin(x) / x) - Pi/2
&nbsp;%1 = 20.78.. \\</tt></font> nonsense<font color=#a3682a><tt></p>
<p>&nbsp;? intnum(x = 0, [oo,1], sin(x)/x) - Pi/2
&nbsp;%2 = 0.004.. \\</tt></font> bad<font color=#a3682a><tt></p>
<p>&nbsp;? intnum(x = 0, [oo,-I], sin(x)/x) - Pi/2
&nbsp;%3 = 0.E-105 \\</tt></font> perfect<font color=#a3682a><tt></p>
<p>&nbsp;? intnum(x = 0, [oo,-I], sin(2*x)/x) - Pi/2  \\</tt></font> oops, wrong k<font color=#a3682a><tt></p>
<p>&nbsp;%4 = 0.07...
&nbsp;? intnum(x = 0, [oo,-2*I], sin(2*x)/x) - Pi/2
&nbsp;%5 = 0.E-105 \\</tt></font> perfect<font color=#a3682a><tt></p>
<p>&nbsp;
&nbsp;? intnum(x = 0, [oo,-I], sin(x)^3/x) - Pi/4
&nbsp;%6 = 0.0092... \\</tt></font> bad<font color=#a3682a><tt></p>
<p>&nbsp;? sin(x)^3 - (3*sin(x)-sin(3*x))/4
&nbsp;%7 = O(x^17)
</tt></font></pre></p>
<p>We may use the above linearization and compute two oscillating integrals with
"infinite endpoints" <font color=#a3682a><tt>
[oo, -I]</tt></font> and <font color=#a3682a><tt>
[oo, -3*I]</tt></font> respectively, or
notice the obvious change of variable, and reduce to the single integral
(1/2)<font color=#FF0000>int</font>_0^ oo sin(x)/xdx. We finish with some more complicated
examples:</p>
<p>
<pre><font color=#a3682a><tt>? intnum(x = 0, [oo,-I], (1-cos(x))/x^2) - Pi/2
&nbsp;%1 = -0.0004... \\</tt></font> bad<font color=#a3682a><tt></p>
<p>&nbsp;? intnum(x = 0, 1, (1-cos(x))/x^2) \
&nbsp;+ intnum(x = 1, oo, 1/x^2) - intnum(x = 1, [oo,I], cos(x)/x^2) - Pi/2
&nbsp;%2 = -2.18... E-106 \\</tt></font> OK<font color=#a3682a><tt></p>
<p>&nbsp;
&nbsp;? intnum(x = 0, [oo, 1], sin(x)^3*exp(-x)) - 0.3
&nbsp;%3 = 5.45... E-107 \\</tt></font> OK<font color=#a3682a><tt></p>
<p>&nbsp;? intnum(x = 0, [oo,-I], sin(x)^3*exp(-x)) - 0.3
&nbsp;%4 = -1.33... E-89 \\</tt></font> lost 16 decimals. Try higher m:<font color=#a3682a><tt></p>
<p>&nbsp;? m = intnumstep()
&nbsp;%5 = 7 \\</tt></font> the value of m actually used above.<font color=#a3682a><tt></p>
<p>&nbsp;? tab = intnuminit(0,[oo,-I], m+1); \\</tt></font> try m one higher.<font color=#a3682a><tt></p>
<p>&nbsp;? intnum(x = 0, oo, sin(x)^3*exp(-x), tab) - 0.3
&nbsp;%6 = 5.45... E-107 \\</tt></font> OK this time.<font color=#a3682a><tt></p>
<p></tt></font></pre></p>
<p>
<b>Warning.</b> Like <font color=#a3682a><tt>
sumalt</tt></font>, <font color=#a3682a><tt>
intnum</tt></font> often assigns a
reasonable value to diverging integrals. Use these values at your own risk!
For example:</p>
<p>
<pre><font color=#a3682a><tt>? intnum(x = 0, [oo, -I], x^2*sin(x))
&nbsp;%1 = -2.0000000000...
</tt></font></pre></p>
<p>Note the formula
 <font color=#FF0000>int</font>_0^ oo sin(x)/x^sdx = cos(<font color=#FF0000>Pi</font> s/2) <font color=#FF0000>Gamma</font>(1-s) , 
a priori valid only for 0 &#60; Re(s) &#60; 2, but the right hand side provides an
analytic continuation which may be evaluated at s = -2...</p>
<p><b>Multivariate integration.</b>
Using successive univariate integration with respect to different formal
parameters, it is immediate to do naive multivariate integration. But it is
important to use a suitable <font color=#a3682a><tt>
intnuminit</tt></font> to precompute data for the
<u>internal</u> integrations at least!</p>
<p>For example, to compute the double integral on the unit disc x^2+y^2 <font color=#a3682a><tt>
&#60;=</tt></font> 1
of the function x^2+y^2, we can write</p>
<p><pre><font color=#a3682a><tt>? tab = intnuminit(-1,1);
&nbsp;? intnum(x=-1,1, intnum(y=-sqrt(1-x^2),sqrt(1-x^2), x^2+y^2, tab), tab)
</tt></font></pre></p>
<p>The first <u>tab</u> is essential, the second optional. Compare:</p>
<p>
<pre><font color=#a3682a><tt>? tab = intnuminit(-1,1);
&nbsp;time = 30 ms.
&nbsp;? intnum(x=-1,1, intnum(y=-sqrt(1-x^2),sqrt(1-x^2), x^2+y^2));
&nbsp;time = 54,410 ms. \\</tt></font> slow<font color=#a3682a><tt></p>
<p>&nbsp;? intnum(x=-1,1, intnum(y=-sqrt(1-x^2),sqrt(1-x^2), x^2+y^2, tab), tab);
&nbsp;time = 7,210 ms.  \\</tt></font> faster<font color=#a3682a><tt></p>
<p></tt></font></pre></p>
<p>However, the <font color=#a3682a><tt>
intnuminit</tt></font> program is usually pessimistic when it comes to
choosing the integration step 2^{-m}. It is often possible to improve the
speed by trial and error. Continuing the above example:</p>
<p><pre><font color=#a3682a><tt>? test(M) =
&nbsp;{
&nbsp;  tab = intnuminit(-1,1, M);
&nbsp;  intnum(x=-1,1, intnum(y=-sqrt(1-x^2),sqrt(1-x^2), x^2+y^2,tab), tab) - Pi/2
&nbsp;}
&nbsp;? m = intnumstep() \\</tt></font> what value of m did it take ?<font color=#a3682a><tt></p>
<p>&nbsp;%1 = 7
&nbsp;? test(m - 1)
&nbsp;time = 1,790 ms.
&nbsp;%2 = -2.05... E-104 \\</tt></font> 4 = 2^2 times faster and still OK.<font color=#a3682a><tt></p>
<p>&nbsp;? test(m - 2)
&nbsp;time = 430 ms.
&nbsp;%3 = -1.11... E-104 \\</tt></font> 16 = 2^4 times faster and still OK.<font color=#a3682a><tt></p>
<p>&nbsp;? test(m - 3)
&nbsp;time = 120 ms.
&nbsp;%3 = -7.23... E-60 \\</tt></font> 64 = 2^6 times faster, lost 45 decimals.<font color=#a3682a><tt></p>
<p></tt></font></pre></p>
<p>
The library syntax is <b>intnum</b>(void *E, GEN (*eval)(GEN,void*), GEN a,GEN b,GEN tab, long prec),
where an omitted <u>tab</u> is coded as <font color=#a3682a><tt>
NULL</tt></font>.</p>

<br>
<hr></hr><br>

<a name="intnuminit"></a>
<h4><b>intnuminit</b>(a,b,{m = 0})</h4>
<p></p>
<p> initialize tables for integration from
a to b, where a and b are coded as in <font color=#a3682a><tt>
intnum</tt></font>. Only the
compactness, the possible existence of singularities, the speed of decrease
or the oscillations at infinity are taken into account, and not the values.
For instance intnuminit(-1,1) is equivalent to intnuminit(0,Pi),
and intnuminit([0,-1/2],[1]) is equivalent to {\tt
intnuminit([-1],[-1,-1/2])}. If m is not given, it is computed according to
the current precision. Otherwise the integration step is 1/2^m. Reasonable
values of m are m = 6 or m = 7 for 100 decimal digits, and m = 9 for
1000 decimal digits.</p>
<p>The result is technical, but in some cases it is useful to know the output.
Let x = <font color=#FF0000>phi</font>(t) be the change of variable which is used. <u>tab</u>[1] contains
the integer m as above, either given by the user or computed from the default
precision, and can be recomputed directly using the function <font color=#a3682a><tt>
intnumstep</tt></font>.
<u>tab</u>[2] and <u>tab</u>[3] contain respectively the abcissa and weight
corresponding to t = 0 (<font color=#FF0000>phi</font>(0) and <font color=#FF0000>phi</font>'(0)). <u>tab</u>[4] and
<u>tab</u>[5] contain the abcissas and weights corresponding to positive
t = nh for 1 <font color=#a3682a><tt>
&#60;=</tt></font> n <font color=#a3682a><tt>
&#60;=</tt></font> N and h = 1/2^m (<font color=#FF0000>phi</font>(nh) and <font color=#FF0000>phi</font>'(nh)). Finally
<u>tab</u>[6] and <u>tab</u>[7] contain either the abcissas and weights
corresponding to negative t = nh for -N <font color=#a3682a><tt>
&#60;=</tt></font> n <font color=#a3682a><tt>
&#60;=</tt></font> -1, or may be empty (but
not always) if <font color=#FF0000>phi</font>(t) is an odd function (implicitly we would have
<u>tab</u>[6] = -<u>tab</u>[4] and <u>tab</u>[7] = <u>tab</u>[5]).</p>
<p>The library syntax is <b>intnuminit</b>(GEN a, GEN b, long m, long prec).</p>

<br>
<hr></hr><br>

<a name="intnumromb"></a>
<h4><b>intnumromb</b>(X = a,b,<u>expr</u>,{<u>flag</u> = 0})</h4>
<p></p>
<p> numerical integration of
<u>expr</u> (smooth in ]a,b[), with respect to X. This function is
deprecated, use <font color=#a3682a><tt>
intnum</tt></font> instead.</p>
<p>Set <u>flag</u> = 0 (or omit it altogether) when a and b are not too large, the
function is smooth, and can be evaluated exactly everywhere on the interval
[a,b].</p>
<p>If <u>flag</u> = 1, uses a general driver routine for doing numerical integration,
making no particular assumption (slow).</p>
<p><u>flag</u> = 2 is tailored for being used when a or b are infinite. One
<u>must</u> have ab &#62; 0, and in fact if for example b = + oo , then it is
preferable to have a as large as possible, at least a <font color=#a3682a><tt>
&#62;=</tt></font> 1.</p>
<p>If <u>flag</u> = 3, the function is allowed to be undefined (but continuous) at a
or b, for example the function sin(x)/x at x = 0.</p>
<p>The user should not require too much accuracy: 18 or 28 decimal digits is OK,
but not much more. In addition, analytical cleanup of the integral must have
been done: there must be no singularities in the interval or at the
boundaries. In practice this can be accomplished with a simple change of
variable. Furthermore, for improper integrals, where one or both of the
limits of integration are plus or minus infinity, the function must decrease
sufficiently rapidly at infinity. This can often be accomplished through
integration by parts. Finally, the function to be integrated should not be
very small (compared to the current precision) on the entire interval. This
can of course be accomplished by just multiplying by an appropriate constant.</p>
<p>Note that infinity can be represented with essentially no loss of
accuracy by 1e1000. However beware of real underflow when dealing with
rapidly decreasing functions. For example, if one wants to compute the
<font color=#FF0000>int</font>_0^ oo e^{-x^2}dx to 28 decimal digits, then one should set
infinity equal to 10 for example, and certainly not to 1e1000.</p>
<p>The library syntax is <b>intnumromb</b>(void *E, GEN (*eval)(GEN,void*), GEN a, GEN b, long flag, long prec),
where <font color=#a3682a><tt>
eval</tt></font>(x, E) returns the value of the function at x.
You may store any additional information required by <font color=#a3682a><tt>
eval</tt></font> in E, or set
it to <font color=#a3682a><tt>
NULL</tt></font>.</p>

<br>
<hr></hr><br>

<a name="intnumstep"></a>
<h4><b>intnumstep</b>()</h4>
<p></p>
<p> give the value of m used in all the
<font color=#a3682a><tt>
intnum</tt></font> and <font color=#a3682a><tt>
sumnum</tt></font> programs, hence such that the integration
step is equal to 1/2^m.</p>
<p>The library syntax is <b>intnumstep</b>(long prec).</p>

<br>
<hr></hr><br>

<a name="prod"></a>
<h4><b>prod</b>(X = a,b,<u>expr</u>,{x = 1})</h4>
<p></p>
<p> product of expression
<u>expr</u>, initialized at x, the formal parameter X going from a to
b. As for <font color=#a3682a><tt>
sum</tt></font>, the main purpose of the initialization parameter x
is to force the type of the operations being performed. For example if it is
set equal to the integer 1, operations will start being done exactly. If it
is set equal to the real 1., they will be done using real numbers having
the default precision. If it is set equal to the power series 1+O(X^k) for
a certain k, they will be done using power series of precision at most k.
These are the three most common initializations.</p>
<p>As an extreme example, compare</p>
<p>
<pre><font color=#a3682a><tt>? prod(i=1, 100, 1 - X^i);  \\</tt></font> this has degree 5050 !!<font color=#a3682a><tt></p>
<p>&nbsp;time = 3,335 ms.
&nbsp;? prod(i=1, 100, 1 - X^i, 1 + O(X^101))
&nbsp;time = 43 ms.
&nbsp;%2 = 1 - X - X^2 + X^5 + X^7 - X^12 - X^15 + X^22 + X^26 - X^35 - X^40 + \
&nbsp;  X^51 + X^57 - X^70 - X^77 + X^92 + X^100 + O(X^101)
</tt></font></pre></p>
<p>
The library syntax is <b>produit</b>(entree *ep, GEN a, GEN b, char *expr, GEN x).</p>

<br>
<hr></hr><br>

<a name="prodeuler"></a>
<h4><b>prodeuler</b>(X = a,b,<u>expr</u>)</h4>
<p></p>
<p> product of expression <u>expr</u>,
initialized at 1. (i.e.to a <u>real</u> number equal to 1 to the current
<font color=#a3682a><tt>
realprecision</tt></font>), the formal parameter X ranging over the prime numbers
between a and b.</p>
<p>The library syntax is <b>prodeuler</b>(void *E, GEN (*eval)(GEN,void*), GEN a,GEN b, long prec).</p>

<br>
<hr></hr><br>

<a name="prodinf"></a>
<h4><b>prodinf</b>(X = a,<u>expr</u>,{<u>flag</u> = 0})</h4>
<p></p>
<p> infinite product of
expression <u>expr</u>, the formal parameter X starting at a. The evaluation
stops when the relative error of the expression minus 1 is less than the
default precision. The expressions must always evaluate to an element of
<b>C</b>.</p>
<p>If <u>flag</u> = 1, do the product of the (1+<u>expr</u>) instead.</p>
<p>The library syntax is <b>prodinf</b>(void *E, GEN (*eval)(GEN, void*), GEN a, long prec)
(<u>flag</u> = 0), or <b>prodinf1</b> with the same arguments (<u>flag</u> = 1).</p>

<br>
<hr></hr><br>

<a name="solve"></a>
<h4><b>solve</b>(X = a,b,<u>expr</u>)</h4>
<p></p>
<p> find a real root of expression
<u>expr</u> between a and b, under the condition
<u>expr</u>(X = a) * <u>expr</u>(X = b) <font color=#a3682a><tt>
&#60;=</tt></font> 0.
This routine uses Brent's method and can fail miserably if <u>expr</u> is
not defined in the whole of [a,b] (try <font color=#a3682a><tt>
solve(x = 1, 2, tan(x)</tt></font>).</p>
<p>The library syntax is <b>zbrent</b>(void *E,GEN (*eval)(GEN,void*),GEN a,GEN b,long prec).</p>

<br>
<hr></hr><br>

<a name="sum"></a>
<h4><b>sum</b>(X = a,b,<u>expr</u>,{x = 0})</h4>
<p></p>
<p> sum of expression <u>expr</u>,
initialized at x, the formal parameter going from a to b. As for
<font color=#a3682a><tt>
prod</tt></font>, the initialization parameter x may be given to force the type
of the operations being performed.</p>
<p>As an extreme example, compare</p>
<p>
<pre><font color=#a3682a><tt>? sum(i=1, 5000, 1/i); \\</tt></font> rational number: denominator has 2166 digits.<font color=#a3682a><tt></p>
<p>&nbsp;time = 1,241 ms.
&nbsp;? sum(i=1, 5000, 1/i, 0.)
&nbsp;time = 158 ms.
&nbsp;%2 = 9.094508852984436967261245533
</tt></font></pre></p>
<p>
The library syntax is <b>somme</b>(entree *ep, GEN a, GEN b, char *expr, GEN x). This is to be
used as follows: <font color=#a3682a><tt>
ep</tt></font> represents the dummy variable used in the
expression <font color=#a3682a><tt>
expr</tt></font></p>
<p><pre><font color=#a3682a><tt>/* compute a^2 + ... + b^2 */
&nbsp;{
&nbsp;  /* define the dummy variable "i" */
&nbsp;  entree *ep = is_entry("i");
&nbsp;  /* sum for a &#60;= i &#60;= b */
&nbsp;  return somme(ep, a, b, "i^2", gen_0);
&nbsp;}
</tt></font></pre></p>

<br>
<hr></hr><br>

<a name="sumalt"></a>
<h4><b>sumalt</b>(X = a,<u>expr</u>,{<u>flag</u> = 0})</h4>
<p></p>
<p> numerical summation of the
series <u>expr</u>, which should be an alternating series, the formal
variable X starting at a. Use an algorithm of F.Villegas as modified by
D.Zagier (improves on Euler-Van Wijngaarden method).</p>
<p>If <u>flag</u> = 1, use a variant with slightly different polynomials. Sometimes
faster.</p>
<p>Divergent alternating series can sometimes be summed by this method, as well
as series which are not exactly alternating (see for example
Section [<b>Label: se:user_defined</b>]). If the series already converges geometrically,
<font color=#a3682a><tt>
suminf</tt></font> is often a better choice:</p>
<p><pre><font color=#a3682a><tt>? \p28
&nbsp;? sumalt(i = 1, -(-1)^i / i)  - log(2)
&nbsp;time = 0 ms.
&nbsp;%1 = -2.524354897 E-29
&nbsp;? suminf(i = 1, -(-1)^i / i)
&nbsp;  *** suminf: user interrupt after 10min, 20,100 ms.
&nbsp;? \p1000
&nbsp;? sumalt(i = 1, -(-1)^i / i)  - log(2)
&nbsp;time = 90 ms.
&nbsp;%2 = 4.459597722 E-1002
&nbsp;
&nbsp;? sumalt(i = 0, (-1)^i / i!) - exp(-1)
&nbsp;time = 670 ms.
&nbsp;%3 = -4.03698781490633483156497361352190615794353338591897830587 E-944
&nbsp;? suminf(i = 0, (-1)^i / i!) - exp(-1)
&nbsp;time = 110 ms.
&nbsp;%4 = -8.39147638 E-1000   \\ </tt></font> faster and more accurate<font color=#a3682a><tt></p>
<p></tt></font></pre></p>
<p>
The library syntax is <b>sumalt</b>(void *E, GEN (*eval)(GEN,void*),GEN a,long prec). Also
available is <font color=#a3682a><tt>
sumalt2</tt></font> with the same arguments (<u>flag</u> = 1).</p>

<br>
<hr></hr><br>

<a name="sumdiv"></a>
<h4><b>sumdiv</b>(n,X,<u>expr</u>)</h4>
<p></p>
<p> sum of expression <u>expr</u> over
the positive divisors of n.</p>
<p>Arithmetic functions like <font color=#a3682a><tt>
sigma</tt></font> use the multiplicativity of the
underlying expression to speed up the computation. In the present version
<b>2.2.13</b>, there is no way to indicate that <u>expr</u> is multiplicative in
n, hence specialized functions should be preferred whenever possible.</p>
<p>The library syntax is <b>divsum</b>(entree *ep, GEN num, char *expr).</p>

<br>
<hr></hr><br>

<a name="suminf"></a>
<h4><b>suminf</b>(X = a,<u>expr</u>)</h4>
<p></p>
<p> infinite sum of expression
<u>expr</u>, the formal parameter X starting at a. The evaluation stops
when the relative error of the expression is less than the default precision
for 3 consecutive evaluations. The expressions must always evaluate to a
complex number.</p>
<p>If the series converges slowly, make sure <font color=#a3682a><tt>
realprecision</tt></font> is low (even 28
digits may be too much). In this case, if the series is alternating or the
terms have a constant sign, <font color=#a3682a><tt>
sumalt</tt></font> and <font color=#a3682a><tt>
sumpos</tt></font> should be used
instead.</p>
<p>
<pre><font color=#a3682a><tt>? \p28
&nbsp;? suminf(i = 1, -(-1)^i / i)
&nbsp;  *** suminf: user interrupt after 10min, 20,100 ms.
&nbsp;? sumalt(i = 1, -(-1)^i / i) - log(2)
&nbsp;time = 0 ms.
&nbsp;%1 = -2.524354897 E-29
</tt></font></pre></p>
<p>
The library syntax is <b>suminf</b>(void *E, GEN (*eval)(GEN,void*), GEN a, long prec).</p>

<br>
<hr></hr><br>

<a name="sumnum"></a>
<h4><b>sumnum</b>(X = a,sig,<u>expr</u>,{<u>tab</u>}),{<u>flag</u> = 0}</h4>
<p></p>
<p> numerical
summation of <u>expr</u>, the variable X taking integer values from ceiling
of a to + oo , where <u>expr</u> is assumed to be a holomorphic function
f(X) for Re(X) <font color=#a3682a><tt>
&#62;=</tt></font> <font color=#FF0000>sigma</font>.</p>
<p>The parameter <font color=#FF0000>sigma</font> belongs to <b>R</b> is coded in the argument <font color=#a3682a><tt>
sig</tt></font> as follows: it
is either</p>
<p><b>*</b> a real number <font color=#FF0000>sigma</font>. Then the function f is assumed to
decrease at least as 1/X^2 at infinity, but not exponentially;</p>
<p><b>*</b> a two-component vector [<font color=#FF0000>sigma</font>,<font color=#FF0000>alpha</font>], where <font color=#FF0000>sigma</font> is as
before, <font color=#FF0000>alpha</font> &#60; -1. The function f is assumed to decrease like
X^{<font color=#FF0000>alpha</font>}. In particular, <font color=#FF0000>alpha</font> <font color=#a3682a><tt>
&#60;=</tt></font> -2 is equivalent to no <font color=#FF0000>alpha</font> at all.</p>
<p><b>*</b> a two-component vector [<font color=#FF0000>sigma</font>,<font color=#FF0000>alpha</font>], where <font color=#FF0000>sigma</font> is as
before, <font color=#FF0000>alpha</font> &#62; 0. The function f is assumed to decrease like
exp(-<font color=#FF0000>alpha</font> X). In this case it is essential that <font color=#FF0000>alpha</font> be exactly the
rate of exponential decrease, and it is usually a good idea to increase
the default value of m used for the integration step. In practice, if
the function is exponentially decreasing <font color=#a3682a><tt>
sumnum</tt></font> is slower and less
accurate than <font color=#a3682a><tt>
sumpos</tt></font> or <font color=#a3682a><tt>
suminf</tt></font>, so should not be used.</p>
<p>The function uses the <font color=#a3682a><tt>
intnum</tt></font> routines and integration on the line
Re(s) = <font color=#FF0000>sigma</font>. The optional argument <u>tab</u> is as in intnum, except it
must be initialized with <font color=#a3682a><tt>
sumnuminit</tt></font> instead of <font color=#a3682a><tt>
intnuminit</tt></font>.</p>
<p>When <u>tab</u> is not precomputed, <font color=#a3682a><tt>
sumnum</tt></font> can be slower than
<font color=#a3682a><tt>
sumpos</tt></font>, when the latter is applicable. It is in general faster for
slowly decreasing functions.</p>
<p>
Finally, if <u>flag</u> is nonzero, we assume that the function f to be summed is
of real type, i.e. satisfies \overline{f(z)} = f(\overline{z}), which
speeds up the computation.</p>
<p>
<pre><font color=#a3682a><tt>? \p 308
&nbsp;? a = sumpos(n=1, 1/(n^3+n+1));
&nbsp;time = 1,410 ms.
&nbsp;? tab = sumnuminit(2);
&nbsp;time = 1,620 ms. \\</tt></font> slower but done once and for all.<font color=#a3682a><tt></p>
<p>&nbsp;? b = sumnum(n=1, 2, 1/(n^3+n+1), tab);
&nbsp;time = 460 ms. \\</tt></font> 3 times as fast as <font color=#a3682a><tt>
sumpos</tt></font><font color=#a3682a><tt></p>
<p>&nbsp;? a - b
&nbsp;%4 = -1.0... E-306 + 0.E-320*I \\</tt></font> perfect.<font color=#a3682a><tt></p>
<p>&nbsp;? sumnum(n=1, 2, 1/(n^3+n+1), tab, 1) - a; \\</tt></font> function of real type<font color=#a3682a><tt></p>
<p>&nbsp;time = 240 ms.
&nbsp;%2 = -1.0... E-306 \\</tt></font> twice as fast, no imaginary part.<font color=#a3682a><tt></p>
<p>&nbsp;? c = sumnum(n=1, 2, 1/(n^2+1), tab, 1);
&nbsp;time = 170 ms. \\</tt></font> fast<font color=#a3682a><tt></p>
<p>&nbsp;? d = sumpos(n=1, 1 / (n^2+1));
&nbsp;time = 2,700 ms. \\</tt></font> slow.<font color=#a3682a><tt></p>
<p>&nbsp;? d - c
&nbsp;time = 0 ms.
&nbsp;%5 = 1.97... E-306 \\</tt></font> perfect.<font color=#a3682a><tt></p>
<p></tt></font></pre></p>
<p>
For slowly decreasing function, we must indicate singularities:</p>
<p><pre><font color=#a3682a><tt>? \p 308
&nbsp;? a = sumnum(n=1, 2, n^(-4/3));
&nbsp;time = 9,930 ms. \\</tt></font> slow because of the computation of n^{-4/3}.<font color=#a3682a><tt></p>
<p>&nbsp;? a - zeta(4/3)
&nbsp;time = 110 ms.
&nbsp;%1 = -2.42... E-107 \\</tt></font> lost 200 decimals because of singularity at  oo <font color=#a3682a><tt></p>
<p>&nbsp;? b = sumnum(n=1, [2,-4/3], n^(-4/3), /*omitted*/, 1); \\</tt></font> of real type<font color=#a3682a><tt></p>
<p>&nbsp;time = 12,210 ms.
&nbsp;? b - zeta(4/3)
&nbsp;%3 = 1.05... E-300 \\</tt></font> better<font color=#a3682a><tt></p>
<p></tt></font></pre></p>
<p>
Since the <u>complex</u> values of the function are used, beware of
determination problems. For instance:</p>
<p><pre><font color=#a3682a><tt>? \p 308
&nbsp;? tab = sumnuminit([2,-3/2]);
&nbsp;time = 1,870 ms.
&nbsp;? sumnum(n=1,[2,-3/2], 1/(n*sqrt(n)), tab,1) - zeta(3/2)
&nbsp;time = 690 ms.
&nbsp;%1 = -1.19... E-305 \\</tt></font> fast and correct<font color=#a3682a><tt></p>
<p>&nbsp;? sumnum(n=1,[2,-3/2], 1/sqrt(n^3), tab,1) - zeta(3/2)
&nbsp;time = 730 ms.
&nbsp;%2 = -1.55... \\</tt></font> nonsense. However<font color=#a3682a><tt></p>
<p>&nbsp;? sumnum(n=1,[2,-3/2], 1/n^(3/2), tab,1) - zeta(3/2)
&nbsp;time = 8,990 ms.
&nbsp;%3 = -1.19... E-305 \\</tt></font> perfect, as 1/(n*sqrt{n}) above but much slower<font color=#a3682a><tt></p>
<p></tt></font></pre></p>
<p>
For exponentially decreasing functions, <font color=#a3682a><tt>
sumnum</tt></font> is given for
completeness, but one of <font color=#a3682a><tt>
suminf</tt></font> or <font color=#a3682a><tt>
sumpos</tt></font> should always be
preferred. If you experiment with such functions and <font color=#a3682a><tt>
sumnum</tt></font> anyway,
indicate the exact rate of decrease and increase m by 1 or 2:</p>
<p>
<pre><font color=#a3682a><tt>? suminf(n=1, 2^(-n)) - 1
&nbsp;time = 10 ms.
&nbsp;%1 = -1.11... E-308 \\</tt></font> fast and perfect<font color=#a3682a><tt></p>
<p>&nbsp;? sumpos(n=1, 2^(-n)) - 1
&nbsp;time = 10 ms.
&nbsp;%2 = -2.78... E-308 \\</tt></font> also fast and perfect<font color=#a3682a><tt></p>
<p>&nbsp;? sumnum(n=1,2, 2^(-n)) - 1
&nbsp;   *** sumnum: precision too low in mpsc1 \\</tt></font> nonsense<font color=#a3682a><tt></p>
<p>&nbsp;? sumnum(n=1, [2,log(2)], 2^(-n), /*omitted*/, 1) - 1 \\</tt></font> of real type<font color=#a3682a><tt></p>
<p>&nbsp;time = 5,860 ms.
&nbsp;%3 = -1.5... E-236 \\</tt></font> slow and lost 70 decimals<font color=#a3682a><tt></p>
<p>&nbsp;? m = intnumstep()
&nbsp;%4 = 9
&nbsp;? sumnum(n=1,[2,log(2)], 2^(-n), m+1, 1) - 1
&nbsp;time = 11,770 ms.
&nbsp;%5 = -1.9... E-305 \\</tt></font> now perfect, but slow.<font color=#a3682a><tt></p>
<p></tt></font></pre></p>
<p>
The library syntax is <b>sumnum</b>(void *E, GEN (*eval)(GEN,void*), GEN a,GEN sig,GEN tab,long flag, long prec).</p>

<br>
<hr></hr><br>

<a name="sumnumalt"></a>
<h4><b>sumnumalt</b>(X = a,sig,<u>expr</u>,{<u>tab</u>},{<u>flag</u> = 0})</h4>
<p></p>
<p> numerical
summation of (-1)^X<u>expr</u>(X), the variable X taking integer values from
ceiling of a to + oo , where <u>expr</u> is assumed to be a holomorphic
function for Re(X) <font color=#a3682a><tt>
&#62;=</tt></font> sig (or sig[1]).</p>
<p><b>Warning.</b> This function uses the <font color=#a3682a><tt>
intnum</tt></font> routines and is
orders of magnitude slower than <font color=#a3682a><tt>
sumalt</tt></font>. It is only given for
completeness and should not be used in practice.</p>
<p><b>Warning2.</b> The expression <u>expr</u> must <u>not</u> include the
(-1)^X coefficient. Thus <font color=#a3682a><tt>
sumalt</tt></font>(n = a,(-1)^nf(n)) is (approximately)
equal to <font color=#a3682a><tt>
sumnumalt</tt></font>(n = a,sig,f(n)).</p>
<p>sig is coded as in <font color=#a3682a><tt>
sumnum</tt></font>. However for slowly decreasing functions
(where sig is coded as [<font color=#FF0000>sigma</font>,<font color=#FF0000>alpha</font>] with <font color=#FF0000>alpha</font> &#60; -1), it is not
really important to indicate <font color=#FF0000>alpha</font>. In fact, as for <font color=#a3682a><tt>
sumalt</tt></font>, the
program will often give meaningful results (usually analytic continuations)
even for divergent series. On the other hand the exponential decrease must be
indicated.</p>
<p><u>tab</u> is as in <font color=#a3682a><tt>
intnum</tt></font>, but if used must be initialized with
<font color=#a3682a><tt>
sumnuminit</tt></font>. If <u>flag</u> is nonzero, assumes that the function f to be
summed is of real type, i.e. satisfies \overline{f(z)} = f(\overline{z}), and
then twice faster when <u>tab</u> is precomputed.</p>
<p>
<pre><font color=#a3682a><tt>? \p 308
&nbsp;? tab = sumnuminit(2, /*omitted*/, -1); \\</tt></font> abcissa <font color=#FF0000>sigma</font> = 2, alternating sums.<font color=#a3682a><tt></p>
<p>&nbsp;time = 1,620 ms. \\</tt></font> slow, but done once and for all.<font color=#a3682a><tt></p>
<p>&nbsp;? a = sumnumalt(n=1, 2, 1/(n^3+n+1), tab, 1);
&nbsp;time = 230 ms. \\</tt></font> similar speed to <font color=#a3682a><tt>
sumnum</tt></font><font color=#a3682a><tt></p>
<p>&nbsp;? b = sumalt(n=1, (-1)^n/(n^3+n+1));
&nbsp;time = 0 ms. \\</tt></font> infinitely faster!<font color=#a3682a><tt></p>
<p>&nbsp;? a - b
&nbsp;time = 0 ms.
&nbsp;%1 = -1.66... E-308 \\</tt></font> perfect<font color=#a3682a><tt></p>
<p></tt></font></pre></p>
<p>
The library syntax is <b>sumnumalt</b>(void *E, GEN (*eval)(GEN,void*), GEN a, GEN sig, GEN tab, long flag, long prec).</p>

<br>
<hr></hr><br>

<a name="sumnuminit"></a>
<h4><b>sumnuminit</b>(sig,{m = 0},{sgn = 1})</h4>
<p></p>
<p> initialize tables for numerical
summation using <font color=#a3682a><tt>
sumnum</tt></font> (with <u>sgn</u> = 1) or <font color=#a3682a><tt>
sumnumalt</tt></font> (with
<u>sgn</u> = -1), sig is the abcissa of integration coded as in <font color=#a3682a><tt>
sumnum</tt></font>,
and m is as in <font color=#a3682a><tt>
intnuminit</tt></font>.</p>
<p>The library syntax is <b>sumnuminit</b>(GEN sig, long m, long sgn, long prec).</p>

<br>
<hr></hr><br>

<a name="sumpos"></a>
<h4><b>sumpos</b>(X = a,<u>expr</u>,{<u>flag</u> = 0})</h4>
<p></p>
<p> numerical summation of the
series <u>expr</u>, which must be a series of terms having the same sign,
the formal
variable X starting at a. The algorithm used is Van Wijngaarden's trick
for converting such a series into an alternating one, and is quite slow. For
regular functions, the function <font color=#a3682a><tt>
sumnum</tt></font> is in general much faster once the
initializations have been made using <font color=#a3682a><tt>
sumnuminit</tt></font>.</p>
<p>If <u>flag</u> = 1, use slightly different polynomials. Sometimes faster.</p>
<p>The library syntax is <b>sumpos</b>(void *E, GEN (*eval)(GEN,void*),GEN a,long prec). Also
available is <font color=#a3682a><tt>
sumpos2</tt></font> with the same arguments (<u>flag</u> = 1).</p>

<br>
<hr></hr><br>



</BODY>
</HTML>