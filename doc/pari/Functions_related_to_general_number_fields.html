<HTML>
<HEAD>
  <TITLE>
    Catalogue of GP/PARI Functions: Functions related to general number fields
  </TITLE>

  <META NAME="author"       CONTENT="Nils-Peter Skoruppa">
  <META NAME="created"      CONTENT="Sat Mar 22 18:13:28 2014">
  <META NAME="author-email" CONTENT="skoruppa@math.uni-siegen.de">
  <META NAME="keywords"     CONTENT="PARI, GP, DOC">
  <link rel="stylesheet" href="/pari.css">
</HEAD>
<BODY bgcolor="#FFFFFF">

<h3 align=center>Functions related to general number fields</h3>

<a name="Number field structures"></a>
<h4>Number field structures</h4>
<p></p>
<p></p>
<p>Let K = <b>Q</b>[X] / (T) a number field, <b>Z</b>_K its ring of integers, T belongs to <b>Z</b>[X]
is monic. Three basic number field structures can be associated to K in
GP:</p>
<p>
<b>*</b> <em>nf</em> denotes a number field, i.e.&nbsp;a data structure output by
<code>nfinit</code>. This contains the basic arithmetic data associated to the
number field: signature, maximal order (given by a basis <code>nf.zk</code>),
discriminant, defining polynomial T, etc.</p>
<p>
<b>*</b> <em>bnf</em> denotes a "Buchmann's number field", i.e.&nbsp;a
data structure output by <code>bnfinit</code>. This contains
<em>nf</em> and the deeper invariants of the field: units U(K), class group
Cl(K), as well as technical data required to solve the two associated
discrete logarithm problems.</p>
<p>
<b>*</b> <em>bnr</em> denotes a "ray number field", i.e.&nbsp;a data structure
output by <code>bnrinit</code>, corresponding to the ray class group structure of
the field, for some modulus f. It contains a <em>bnf</em>, the modulus
f, the ray class group Cl_f(K) and data associated to
the discrete logarithm problem therein.</p>

<hr></hr>
<a name="Algebraic numbers and ideals"></a>
<h4>Algebraic numbers and ideals</h4>
<p></p>
<p></p>
<p>An <em>algebraic number</em> belonging to K = <b>Q</b>[X]/(T) is given as</p>
<p>
<b>*</b> a <code>t_INT</code>, <code>t_FRAC</code> or <code>t_POL</code> (implicitly modulo T), or</p>
<p>
<b>*</b> a <code>t_POLMOD</code> (modulo T), or</p>
<p>
<b>*</b> a <code>t_COL</code>&nbsp;<code>v</code> of dimension N = [K:<b>Q</b>], representing
the element in terms of the computed integral basis, as
<code>sum(i = 1, N,&nbsp;v[i] * nf.zk[i])</code>. Note that a <code>t_VEC</code>
will not be recognized.</p>
<p></p>
<p>
An <em>ideal</em> is given in any of the following ways:</p>
<p>
<b>*</b> an algebraic number in one of the above forms, defining a principal ideal.</p>
<p>
<b>*</b> a prime ideal, i.e.&nbsp;a 5-component vector in the format output by
<code>idealprimedec</code> or <code>idealfactor</code>.</p>
<p>
<b>*</b> a <code>t_MAT</code>, square and in Hermite Normal Form (or at least
upper triangular with non-negative coefficients), whose columns represent a
<b>Z</b>-basis of the ideal.</p>
<p>
One may use <code>idealhnf</code> to convert any ideal to the last (preferred) format.</p>
<p>
<b>*</b> an <em>extended ideal</em>  is a 2-component
vector [I, t], where I is an ideal as above and t is an algebraic
number, representing the ideal (t)I. This is useful whenever <code>idealred</code>
is involved, implicitly working in the ideal class group, while keeping track
of principal ideals. Ideal operations suitably update the principal part
when it makes sense (in a multiplicative context), e.g.&nbsp;using <code>idealmul</code>
on [I,t], [J,u], we obtain [IJ, tu]. When it does not make sense, the
extended part is silently discarded, e.g.&nbsp;using <code>idealadd</code> with the above
input produces I+J.</p>
<p>
The "principal part" t in an extended ideal may be
represented in any of the above forms, and <em>also</em> as a factorization
matrix (in terms of number field elements, not ideals!), possibly the empty
matrix <code>[;]</code> representing 1. In the latter case, elements stay in
factored form, or <em>famat</em> for <em>fa</em>ctorization <em>mat</em>rix, which
is a convenient way to avoid coefficient explosion. To recover the
conventional expanded form, try <code>nffactorback</code>; but many functions
already accept <em>famat</em>s as input, for instance <code>ideallog</code>, so
expanding huge elements should never be necessary.</p>

<hr></hr>
<a name="Finite abelian groups"></a>
<h4>Finite abelian groups</h4>
<p></p>
<p></p>
<p>A finite abelian group G in user-readable format is given by its Smith
Normal Form as a pair [h,d] or triple [h,d,g].
Here h is the cardinality of G, (d_i) is the vector of elementary
divisors, and (g_i) is a vector of generators. In short,
G = oplus_{i <code>&#60;=</code> n} (<b>Z</b>/d_i<b>Z</b>) g_i, with d_n | ... | d_2 | d_1
and <font color=#FF0000>prod</font> d_i = h. This information can also be retrieved as
G.<code>no</code>, G.<code>cyc</code> and G.<code>gen</code>.</p>
<p>
<b>*</b> a <em>character</em> on the abelian group
oplus (<b>Z</b>/d_i<b>Z</b>) g_i
is given by a row vector <font color=#FF0000>chi</font> = [a_1,...,a_n] such that
<font color=#FF0000>chi</font>(<font color=#FF0000>prod</font> g_i^{n_i}) = exp(2i<font color=#FF0000>Pi</font><font color=#FF0000>sum</font> a_i n_i / d_i).</p>
<p>
<b>*</b> given such a structure, a <em>subgroup</em> H is input as a square
matrix in HNF, whose columns express generators of H on the given generators
g_i. Note that the determinant of that matrix is equal to the index (G:H).</p>

<hr></hr>
<a name="Relative extensions"></a>
<h4>Relative extensions</h4>
<p></p>
<p></p>
<p>We now have a look at data structures associated to relative extensions
of number fields L/K, and to projective <b>Z</b>_K-modules. When defining a
relative extension L/K, the <em>nf</em> associated to the base field K
must be defined by a variable having a lower priority (see
Section [<b>Label: se:priority</b>]) than the variable defining the extension. For example,
you may use the variable name y to define the base field K, and x to
define the relative extension L/K.</p>

<hr></hr>
<a name="Class field theory"></a>
<h4>Class field theory</h4>
<p></p>
<p></p>
<p>A <em>modulus</em>, in the sense of class field theory, is a divisor supported
on the non-complex places of K. In PARI terms, this means either an
ordinary ideal I as above (no Archimedean component), or a pair [I,a],
where a is a vector with r_1 {0,1}-components, corresponding to the
infinite part of the divisor. More precisely, the i-th component of a
corresponds to the real embedding associated to the i-th real root of
<code>K.roots</code>. (That ordering is not canonical, but well defined once a
defining polynomial for K is chosen.) For instance, <code>[1, [1,1]]</code> is a
modulus for a real quadratic field, allowing ramification at any of the two
places at infinity, and nowhere else.</p>
<p>
A <em>bid</em> or "big ideal" is a structure output by <code>idealstar</code>
needed to compute in (<b>Z</b>_K/I)^*, where I is a modulus in the above sense.
It is a finite abelian group as described above, supplemented by
technical data needed to solve discrete log problems.</p>
<p>
Finally we explain how to input ray number fields (or <em>bnr</em>), using class
field theory. These are defined by a triple A, B, C, where the
defining set [A,B,C] can have any of the following forms: [<em>bnr</em>],
[<em>bnr</em>,<em>subgroup</em>], [<em>bnf</em>,<em>mod</em>],
[<em>bnf</em>,<em>mod</em>,<em>subgroup</em>]. The last two forms are kept for
backward compatibility, but no longer serve any real purpose (see example
below); no newly written function will accept them.</p>
<p>
<b>*</b> <em>bnf</em> is as output by <code>bnfinit</code>, where units are mandatory
unless the modulus is trivial; <em>bnr</em> is as output by <code>bnrinit</code>. This
is the ground field K.</p>
<p>
<b>*</b> <em>mod</em> is a modulus <b>f</b>, as described above.</p>
<p>
<b>*</b> <em>subgroup</em> a subgroup of the ray class group modulo <b>f</b> of
K. As described above, this is input as a square matrix expressing
generators of a subgroup of the ray class group <code><em>bnr</em>.clgp</code> on the
given generators.</p>
<p>
The corresponding <em>bnr</em> is the subfield of the ray class field of K
modulo <b>f</b>, fixed by the given subgroup.</p>
<p></p>
<p>
<pre class="code">    ? K = bnfinit(y^2+1);
    ? bnr = bnrinit(K, 13)
    ? %.clgp
    %3 = [36, [12, 3]]
    ? bnrdisc(bnr); \\ discriminant of the full ray class field
    ? bnrdisc(bnr, [3,1;0,1]); \\ discriminant of cyclic cubic extension of K
</pre></p>
<p>
We could have written directly</p>
<p>
<pre class="code">    ? bnrdisc(K, 13);
    ? bnrdisc(K, 13, [3,1;0,1]);
</pre></p>
<p>
avoiding one <code>bnrinit</code>, but this would actually be slower since the
<code>bnrinit</code> is called internally anyway. And now twice!</p>

<hr></hr>
<a name="General use"></a>
<h4>General use</h4>
<p></p>
<p></p>
<p>All the functions which are specific to relative extensions, number fields,
Buchmann's number fields, Buchmann's number rays, share the prefix <code>rnf</code>,
<code>nf</code>, <code>bnf</code>, <code>bnr</code> respectively. They take as first argument a
number field of that precise type, respectively output by <code>rnfinit</code>,
<code>nfinit</code>, <code>bnfinit</code>, and <code>bnrinit</code>.</p>
<p>
However, and even though it may not be specified in the descriptions of the
functions below, it is permissible, if the function expects a <em>nf</em>, to
use a <em>bnf</em> instead, which contains much more information. On the other
hand, if the function requires a <code>bnf</code>, it will <em>not</em> launch
<code>bnfinit</code> for you, which is a costly operation. Instead, it will give you
a specific error message. In short, the types
 <code>nf</code> <code>&#60;=</code> <code>bnf</code> <code>&#60;=</code> <code>bnr</code>
are ordered, each function requires a minimal type to work properly, but you
may always substitute a larger type.</p>
<p>
The data types corresponding to the structures described above are rather
complicated. Thus, as we already have seen it with elliptic curves, GP
provides "member functions" to retrieve data from these structures (once
they have been initialized of course). The relevant types of number fields
are indicated between parentheses: </p>
<p></p>
<p></p>
<p></p>
<p>&nbsp;<code>bid</code>     (<em>bnr</em> ) :   bid ideal structure.</p>
<p></p>
<p>&nbsp;<code>bnf</code>     (<em>bnr</em>,  <em>bnf</em> ) :   Buchmann's number field.</p>
<p></p>
<p>&nbsp;<code>clgp</code>   (<em>bnr</em>,  <em>bnf</em> ) :   classgroup. This one admits the
following three subclasses:</p>
<p></p>
<p>&nbsp;        <code>cyc</code>  :     cyclic decomposition
 (SNF).</p>
<p></p>
<p>&nbsp;        <code>gen</code>  :  
   generators.</p>
<p></p>
<p>&nbsp;        <code>no</code>   :     number of elements.</p>
<p></p>
<p>&nbsp;<code>diff</code>   (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   the different ideal.</p>
<p></p>
<p>&nbsp;<code>codiff</code> (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   the codifferent
(inverse of the different in the ideal group).</p>
<p></p>
<p>&nbsp;<code>disc</code>  (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   discriminant.</p>
<p></p>
<p>&nbsp;<code>fu</code>    (<em>bnr</em>,  <em>bnf</em> ) :   fundamental units.</p>
<p></p>
<p>&nbsp;<code>index</code>    (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :  
 index of the power order in the ring of integers.</p>
<p></p>
<p>&nbsp;<code>mod</code>    (<em>bnr</em> ) :   modulus.</p>
<p></p>
<p>&nbsp;<code>nf</code>    (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   number field.</p>
<p></p>
<p>&nbsp;<code>pol</code>    (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   defining polynomial.</p>
<p></p>
<p>&nbsp;<code>r1</code>  (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   the number
of real embeddings.</p>
<p></p>
<p>&nbsp;<code>r2</code>  (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   the number
of pairs of complex embeddings.</p>
<p></p>
<p>&nbsp;<code>reg</code>   (<em>bnr</em>,  <em>bnf</em> ) :   regulator.</p>
<p></p>
<p>&nbsp;<code>roots</code> (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   roots of the
polynomial generating the field.</p>
<p></p>
<p>&nbsp;<code>sign</code>  (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   signature [r1,r2].</p>
<p></p>
<p>&nbsp;<code>t2</code>    (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   the T_2 matrix (see
<code>nfinit</code>).</p>
<p></p>
<p>&nbsp;<code>tu</code>    (<em>bnr</em>,  <em>bnf</em> ) :   a generator for the torsion
units.</p>
<p></p>
<p>&nbsp;<code>zk</code>    (<em>bnr</em>,  <em>bnf</em>,  <em>nf</em> ) :   integral basis, i.e.&nbsp;a
<b>Z</b>-basis of the maximal order.</p>
<p></p>
<p>&nbsp;<code>zkst</code>    (<em>bnr</em> ) :   structure of (<b>Z</b>_K/m)^*.</p>
<p>
<b>Deprecated.</b> The following member functions are still available, but deprecated and should not be used in new scripts :</p>
<p>&nbsp;<code>futu</code>  (<em>bnr</em>,  <em>bnf</em>, ) :  
 [u_1,...,u_r,w], (u_i) is a vector of fundamental units,</p>
<p>&nbsp;  w generates the torsion units.</p>
<p></p>
<p>&nbsp;<code>tufu</code>  (<em>bnr</em>,  <em>bnf</em>, ) :  
 [w,u_1,...,u_r], (u_i) is a vector of fundamental units,</p>
<p>&nbsp;  w generates the torsion units.</p>
<p></p>
<p>
  For instance, assume that <em>bnf</em> = <code>bnfinit</code>(<em>pol</em>), for some
polynomial. Then <code><em>bnf</em>.clgp</code> retrieves the class group, and
<code><em>bnf</em>.clgp.no</code> the class number. If we had set <em>bnf</em> = 
<code>nfinit</code>(<em>pol</em>), both would have output an error message. All these
functions are completely recursive, thus for instance
<code><em>bnr</em>.bnf.nf.zk</code> will yield the maximal order of <em>bnr</em>, which
you could get directly with a simple <code><em>bnr</em>.zk</code>.</p>

<hr></hr>
<a name="Class group, units, and the GRH"></a>
<h4>Class group, units, and the GRH</h4>
<p></p>
<p></p>
<p>Some of the functions starting with <code>bnf</code> are implementations of the
sub-exponential algorithms for finding class and unit groups under GRH,
due to Hafner-McCurley, Buchmann and Cohen-Diaz-Olivier. The general
call to the functions concerning class groups of general number fields
(i.e.&nbsp;excluding <code>quadclassunit</code>) involves a polynomial P and a
technical vector
<em>tech</em> = [c_1, c_2, <em>nrpid</em> ],
where the parameters are to be understood as follows:</p>
<p>
P is the defining polynomial for the number field, which must be in
<b>Z</b>[X], irreducible and monic. In fact, if you supply a non-monic polynomial
at this point, <code>gp</code> issues a warning, then <em>transforms your
polynomial</em> so that it becomes monic. The <code>nfinit</code> routine
will return a different result in this case: instead of <code>res</code>, you get a
vector <code>[res,Mod(a,Q)]</code>, where <code>Mod(a,Q) = Mod(X,P)</code> gives the change
of variables. In all other routines, the variable change is simply lost.</p>
<p>
The <em>tech</em> interface is obsolete and you should not tamper with
these parameters. Indeed, from version 2.4.0 on,</p>
<p>
<b>*</b> the results are always rigorous under GRH (before that version,
they relied on a heuristic strengthening, hence the need for overrides).</p>
<p>
<b>*</b> the influence of these parameters on execution time and stack size is
marginal. They <em>can</em> be useful to fine-tune and experiment with the
<code>bnfinit</code> code, but you will be better off modifying all tuning
parameters in the C code (there are many more than just those three).
We nevertheless describe it for completeness.</p>
<p>
The numbers c_1 <code>&#60;=</code> c_2 are non-negative real numbers. By default they are
chosen so that the result is correct under GRH. For i = 1,2, let
B_i = c_i(log |d_K|)^2, and denote by S(B) the set of maximal ideals of
K whose norm is less than B. We want S(B_1) to generate Cl(K) and hope
that S(B_2) can be <em>proven</em> to generate Cl(K).</p>
<p>
More precisely, S(B_1) is a factorbase used to compute a tentative
Cl(K) by generators and relations. We then check explicitly, using
essentially <code>bnfisprincipal</code>, that the elements of S(B_2) belong to the
span of S(B_1). Under the assumption that S(B_2) generates Cl(K), we
are done. User-supplied c_i are only used to compute initial guesses for
the bounds B_i, and the algorithm increases them until one can <em>prove</em>
under GRH that S(B_2) generates Cl(K). A uniform result of Bach says
that c_2 = 12 is always suitable, but this bound is very pessimistic and a
direct algorithm due to Belabas-Diaz-Friedman is used to check the condition,
assuming GRH. The default values are c_1 = c_2 = 0. When c_1 is equal to
0 the algorithm takes it equal to c_2.</p>
<p>
<em>nrpid</em> is the maximal number of small norm relations associated to each
ideal in the factor base. Set it to 0 to disable the search for small norm
relations. Otherwise, reasonable values are between 4 and 20. The default is
4.</p>
<p>
<b>Warning.</b> Make sure you understand the above! By default, most of
the <code>bnf</code> routines depend on the correctness of the GRH. In particular,
any of the class number, class group structure, class group generators,
regulator and fundamental units may be wrong, independently of each other.
Any result computed from such a <code>bnf</code> may be wrong. The only guarantee is
that the units given generate a subgroup of finite index in the full unit
group. You must use <code>bnfcertify</code> to certify the computations
unconditionally.</p>
<p>
<b>Remarks.</b></p>
<p>
You do not need to supply the technical parameters (under the library you
still need to send at least an empty vector, coded as <code>NULL</code>). However,
should you choose to set some of them, they <em>must</em> be given in the
requested order. For example, if you want to specify a given value of
<em>nrpid</em>, you must give some values as well for c_1 and c_2, and provide
a vector [c_1,c_2,<em>nrpid</em>].</p>
<p>
Note also that you can use an <em>nf</em> instead of P, which avoids
recomputing the integral basis and analogous quantities.</p>
<p></p>
<p></p>
<p></p>

<hr></hr>
<a name="bnfcertify"></a>
<h4>bnfcertify(<em>bnf</em>,{<em>flag</em> = 0})</h4>
<p></p>
<p><em>bnf</em> being as output by
<code>bnfinit</code>, checks whether the result is correct, i.e.&nbsp;whether it is
possible to remove the assumption of the Generalized Riemann
Hypothesis. It is correct if and only if the answer is 1. If it is
incorrect, the program may output some error message, or loop indefinitely.
You can check its progress by increasing the debug level. The <em>bnf</em>
structure must contain the fundamental units:</p>
<p>
<pre class="code">  ? K = bnfinit(x^3+2^2^3+1); bnfcertify(K)
    ***   at top-level: K=bnfinit(x^3+2^2^3+1);bnfcertify(K)
    ***                                        ^-------------
    *** bnfcertify: missing units in bnf.
  ? K = bnfinit(x^3+2^2^3+1, 1); \\ include units
  ? bnfcertify(K)
  %3 = 1
</pre></p>
<p></p>
<p>
If flag is present, only certify that the class group is a quotient of the
one computed in bnf (much simpler in general); likewise, the computed units
may form a subgroup of the full unit group. In this variant, the units are
no longer needed:</p>
<p>
<pre class="code">  ? K = bnfinit(x^3+2^2^3+1); bnfcertify(K, 1)
  %4 = 1
</pre></p>
<p></p>
<p>
The library syntax is <code>long <b>bnfcertify0</b>(GEN bnf, long flag )</code>.
Also available is  <code>GEN <b>bnfcertify</b>(GEN bnf)</code> (<em>flag</em> = 0).</p>

<hr></hr>
<a name="bnfcompress"></a>
<h4>bnfcompress(<em>bnf</em>)</h4>
<p></p>
<p>Computes a compressed version of <em>bnf</em> (from <code>bnfinit</code>), a
"small Buchmann's number field" (or <em>sbnf</em> for short) which contains
enough information to recover a full <em>bnf</em> vector very rapidly, but
which is much smaller and hence easy to store and print. Calling
<code>bnfinit</code> on the result recovers a true <code>bnf</code>, in general different
from the original. Note that an <em>snbf</em> is useless for almost all
purposes besides storage, and must be converted back to <em>bnf</em> form
before use; for instance, no <code>nf*</code>, <code>bnf*</code> or member function
accepts them.</p>
<p>
An <em>sbnf</em> is a 12 component vector v, as follows. Let <code>bnf</code> be
the result of a full <code>bnfinit</code>, complete with units. Then v[1] is
<code>bnf.pol</code>, v[2] is the number of real embeddings <code>bnf.sign[1]</code>,
v[3] is <code>bnf.disc</code>, v[4] is <code>bnf.zk</code>, v[5] is the list of roots
<code>bnf.roots</code>, v[7] is the matrix <code>W</code> = <code>bnf[1]</code>,
v[8] is the matrix <code>matalpha</code> = <code>bnf[2]</code>,
v[9] is the prime ideal factor base <code>bnf[5]</code> coded in a compact way,
and ordered according to the permutation <code>bnf[6]</code>, v[10] is the
2-component vector giving the number of roots of unity and a generator,
expressed on the integral basis, v[11] is the list of fundamental units,
expressed on the integral basis, v[12] is a vector containing the algebraic
numbers alpha corresponding to the columns of the matrix <code>matalpha</code>,
expressed on the integral basis.</p>
<p>
All the components are exact (integral or rational), except for the roots in
v[5].</p>
<p>
The library syntax is <code>GEN <b>bnfcompress</b>(GEN bnf)</code>.</p>

<hr></hr>
<a name="bnfdecodemodule"></a>
<h4>bnfdecodemodule(<em>nf</em>,m)</h4>
<p></p>
<p>If m is a module as output in the
first component of an extension given by <code>bnrdisclist</code>, outputs the
true module.</p>
<p>
<pre class="code">  ? K = bnfinit(x^2+23); L = bnrdisclist(K, 10); s = L[1][2]
  %1 = [[Mat([8, 1]), [[0, 0, 0]]], [Mat([9, 1]), [[0, 0, 0]]]]
  ? bnfdecodemodule(K, s[1][1])
  %2 =
  [2 0]
  
  [0 1]
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>decodemodule</b>(GEN nf, GEN m)</code>.</p>

<hr></hr>
<a name="bnfinit"></a>
<h4>bnfinit(P,{<em>flag</em> = 0},{<em>tech</em> = []})</h4>
<p></p>
<p>Initializes a
<em>bnf</em> structure. Used in programs such as <code>bnfisprincipal</code>,
<code>bnfisunit</code> or <code>bnfnarrow</code>. By default, the results are conditional
on the GRH, see [<b>Label: se:GRHbnf</b>]. The result is a
10-component vector <em>bnf</em>.</p>
<p>
This implements Buchmann's sub-exponential algorithm for computing the
class group, the regulator and a system of fundamental units of the
general algebraic number field K defined by the irreducible polynomial P
with integer coefficients.</p>
<p>
If the precision becomes insufficient, <code>gp</code> does not strive to compute
the units by default (<em>flag</em> = 0).</p>
<p>
When <em>flag</em> = 1, we insist on finding the fundamental units exactly. Be
warned that this can take a very long time when the coefficients of the
fundamental units on the integral basis are very large. If the fundamental
units are simply too large to be represented in this form, an error message
is issued. They could be obtained using the so-called compact representation
of algebraic numbers as a formal product of algebraic integers. The latter is
implemented internally but not publicly accessible yet.</p>
<p>
<em>tech</em> is a technical vector (empty by default, see [<b>Label: se:GRHbnf</b>]).
Careful use of this parameter may speed up your computations,
but it is mostly obsolete and you should leave it alone.</p>
<p></p>
<p></p>
<p>
The components of a <em>bnf</em> or <em>sbnf</em> are technical and never used by
the casual user. In fact: <em>never access a component directly, always use
a proper member function.</em> However, for the sake of completeness and internal
documentation, their description is as follows. We use the notations
explained in the book by H. Cohen, <em>A Course in Computational Algebraic
Number Theory</em>, Graduate Texts in Maths <b>138</b>, Springer-Verlag, 1993,
Section 6.5, and subsection 6.5.5 in particular.</p>
<p>
<em>bnf</em>[1] contains the matrix W, i.e.&nbsp;the matrix in Hermite normal
form giving relations for the class group on prime ideal generators
(<b>p</b>_i)_{1 <code>&#60;=</code> i <code>&#60;=</code> r}.</p>
<p>
<em>bnf</em>[2] contains the matrix B, i.e.&nbsp;the matrix containing the
expressions of the prime ideal factorbase in terms of the <b>p</b>_i.
It is an r x c matrix.</p>
<p>
<em>bnf</em>[3] contains the complex logarithmic embeddings of the system of
fundamental units which has been found. It is an (r_1+r_2) x (r_1+r_2-1)
matrix.</p>
<p>
<em>bnf</em>[4] contains the matrix M"_C of Archimedean components of the
relations of the matrix (W|B).</p>
<p>
<em>bnf</em>[5] contains the prime factor base, i.e.&nbsp;the list of prime
ideals used in finding the relations.</p>
<p>
<em>bnf</em>[6] used to contain a permutation of the prime factor base, but
has been obsoleted. It contains a dummy 0.</p>
<p>
<em>bnf</em>[7] or <code><em>bnf</em>.nf</code> is equal to the number field data
<em>nf</em> as would be given by <code>nfinit</code>.</p>
<p>
<em>bnf</em>[8] is a vector containing the classgroup <code><em>bnf</em>.clgp</code>
as a finite abelian group, the regulator <code><em>bnf</em>.reg</code>, a 1 (used to
contain an obsolete "check number"), the number of roots of unity and a
generator <code><em>bnf</em>.tu</code>, the fundamental units <code><em>bnf</em>.fu</code>.</p>
<p>
<em>bnf</em>[9] is a 3-element row vector used in <code>bnfisprincipal</code> only
and obtained as follows. Let D = U W V obtained by applying the
Smith normal form algorithm to the matrix W ( = <em>bnf</em>[1]) and
let U_r be the reduction of U modulo D. The first elements of the
factorbase are given (in terms of <code>bnf.gen</code>) by the columns of U_r,
with Archimedean component g_a; let also GD_a be the Archimedean
components of the generators of the (principal) ideals defined by the
<code>bnf.gen[i]^bnf.cyc[i]</code>. Then <em>bnf</em>[9] = [U_r, g_a, GD_a].</p>
<p>
<em>bnf</em>[10] is by default unused and set equal to 0. This field is used
to store further information about the field as it becomes available, which
is rarely needed, hence would be too expensive to compute during the initial
<code>bnfinit</code> call. For instance, the generators of the principal ideals
<code>bnf.gen[i]^bnf.cyc[i]</code> (during a call to <code>bnrisprincipal</code>), or
those corresponding to the relations in W and B (when the <code>bnf</code>
internal precision needs to be increased).</p>
<p>
The library syntax is <code>GEN <b>bnfinit0</b>(GEN P, long flag, GEN tech = NULL, long prec)</code>.</p>
<p>
Also available is <code>GEN <b>Buchall</b>(GEN P, long flag, long prec)</code>,
corresponding to <code>tech = NULL</code>, where
<code>flag</code> is either 0 (default) or <code>nf_FORCE</code> (insist on finding
fundamental units). The function
<code>GEN <b>Buchall_param</b>(GEN P, double c1, double c2, long nrpid, long flag, long prec)</code> gives direct access to the technical parameters.</p>

<hr></hr>
<a name="bnfisintnorm"></a>
<h4>bnfisintnorm(<em>bnf</em>,x)</h4>
<p></p>
<p>Computes a complete system of
solutions (modulo units of positive norm) of the absolute norm equation
Norm(a) = x,
where a is an integer in <em>bnf</em>. If <em>bnf</em> has not been certified,
the correctness of the result depends on the validity of GRH.</p>
<p>
See also <code>bnfisnorm</code>.</p>
<p>
The library syntax is <code>GEN <b>bnfisintnorm</b>(GEN bnf, GEN x)</code>.
The function <code>GEN <b>bnfisintnormabs</b>(GEN bnf, GEN a)</code>
returns a complete system of solutions modulo units of the absolute norm
equation |Norm(x) |= |a|. As fast as <code>bnfisintnorm</code>, but solves
the two equations Norm(x) = &#177; a simultaneously.</p>

<hr></hr>
<a name="bnfisnorm"></a>
<h4>bnfisnorm(<em>bnf</em>,x,{<em>flag</em> = 1})</h4>
<p></p>
<p>Tries to tell whether the
rational number x is the norm of some element y in <em>bnf</em>. Returns a
vector [a,b] where x = Norm(a)*b. Looks for a solution which is an S-unit,
with S a certain set of prime ideals containing (among others) all primes
dividing x. If <em>bnf</em> is known to be Galois, set <em>flag</em> = 0 (in
this case, x is a norm iff b = 1). If <em>flag</em> is non zero the program adds to
S the following prime ideals, depending on the sign of <em>flag</em>. If <em>flag</em> &#62; 0,
the ideals of norm less than <em>flag</em>. And if <em>flag</em> &#60; 0 the ideals dividing <em>flag</em>.</p>
<p>
Assuming GRH, the answer is guaranteed (i.e.&nbsp;x is a norm iff b = 1),
if S contains all primes less than 12log(disc(<em>Bnf</em>))^2, where
<em>Bnf</em> is the Galois closure of <em>bnf</em>.</p>
<p>
See also <code>bnfisintnorm</code>.</p>
<p>
The library syntax is <code>GEN <b>bnfisnorm</b>(GEN bnf, GEN x, long flag)</code>.</p>

<hr></hr>
<a name="bnfisprincipal"></a>
<h4>bnfisprincipal(<em>bnf</em>,x,{<em>flag</em> = 1})</h4>
<p></p>
<p><em>bnf</em> being the 
number field data output by <code>bnfinit</code>, and x being an ideal, this
function tests whether the ideal is principal or not. The result is more
complete than a simple true/false answer and solves general discrete
logarithm problem. Assume the class group is oplus (<b>Z</b>/d_i<b>Z</b>)g_i
(where the generators g_i and their orders d_i are respectively given by
<code>bnf.gen</code> and <code>bnf.cyc</code>). The routine returns a row vector [e,t],
where e is a vector of exponents 0 <code>&#60;=</code> e_i &#60; d_i, and t is a number
field element such that
 x = (t) <font color=#FF0000>prod</font>_i  g_i^{e_i}.
For <em>given</em> g_i (i.e. for a given <code>bnf</code>), the e_i are unique,
and t is unique modulo units.</p>
<p>
In particular, x is principal if and only if e is the zero vector. Note
that the empty vector, which is returned when the class number is 1, is
considered to be a zero vector (of dimension 0).</p>
<p>
<pre class="code">  ? K = bnfinit(y^2+23);
  ? K.cyc
  %2 = [3]
  ? K.gen
  %3 = [[2, 0; 0, 1]]          \\ a prime ideal above 2
  ? P = idealprimedec(K,3)[1]; \\ a prime ideal above 3
  ? v = bnfisprincipal(K, P)
  %5 = [[2]~, [3/4, 1/4]~]
  ? idealmul(K, v[2], idealfactorback(K, K.gen, v[1]))
  %6 =
  [3 0]
  
  [0 1]
  ? % == idealhnf(K, P)
  %7 = 1
</pre></p>
<p></p>
<p>
The binary digits of <em>flag</em> mean:</p>
<p>
<b>*</b> 1: If set, outputs [e,t] as explained above, otherwise returns
only e, which is much easier to compute. The following idiom only tests
whether an ideal is principal:</p>
<p>
<pre class="code">    is_principal(bnf, x) = !bnfisprincipal(bnf,x,0);
</pre></p>
<p></p>
<p>
<b>*</b> 2: It may not be possible to recover t, given the initial accuracy
to which <code>bnf</code> was computed. In that case, a warning is printed and t is
set equal to the empty vector <code>[]~</code>. If this bit is set,
increase the precision and recompute needed quantities until t can be
computed. Warning: setting this may induce <em>very</em> lengthy computations.</p>
<p>
The library syntax is <code>GEN <b>bnfisprincipal0</b>(GEN bnf, GEN x, long flag)</code>.
Instead of the above hardcoded numerical flags, one should
rather use an or-ed combination of the symbolic flags <code>nf_GEN</code> (include
generators, possibly a place holder if too difficult) and <code>nf_FORCE</code>
(insist on finding the generators).</p>

<hr></hr>
<a name="bnfissunit"></a>
<h4>bnfissunit(<em>bnf</em>,<em>sfu</em>,x)</h4>
<p></p>
<p><em>bnf</em> being output by
<code>bnfinit</code>, <em>sfu</em> by <code>bnfsunit</code>, gives the column vector of
exponents of x on the fundamental S-units and the roots of unity.
If x is not a unit, outputs an empty vector.</p>
<p>
The library syntax is <code>GEN <b>bnfissunit</b>(GEN bnf, GEN sfu, GEN x)</code>.</p>

<hr></hr>
<a name="bnfisunit"></a>
<h4>bnfisunit(<em>bnf</em>,x)</h4>
<p></p>
<p><em>bnf</em> being the number field data
output by <code>bnfinit</code> and x being an algebraic number (type integer,
rational or polmod), this outputs the decomposition of x on the fundamental
units and the roots of unity if x is a unit, the empty vector otherwise.
More precisely, if u_1,...,u_r are the fundamental units, and <font color=#FF0000>zeta</font>
is the generator of the group of roots of unity (<code>bnf.tu</code>), the output is
a vector [x_1,...,x_r,x_{r+1}] such that x = u_1^{x_1}...
u_r^{x_r}.<font color=#FF0000>zeta</font>^{x_{r+1}}. The x_i are integers for i <code>&#60;=</code> r and is an
integer modulo the order of <font color=#FF0000>zeta</font> for i = r+1.</p>
<p>
Note that <em>bnf</em> need not contain the fundamental unit explicitly:</p>
<p>
<pre class="code">  ? setrand(1); bnf = bnfinit(x^2-x-100000);
  ? bnf.fu
    ***   at top-level: bnf.fu
    ***                     ^--
    *** _.fu: missing units in .fu.
  ? u = [119836165644250789990462835950022871665178127611316131167, \
         379554884019013781006303254896369154068336082609238336]~;
  ? bnfisunit(bnf, u)
  %3 = [-1, Mod(0, 2)]~
</pre>
The given u is the inverse of the fundamental unit
implicitly stored in <em>bnf</em>. In this case, the fundamental unit was not
computed and stored in algebraic form since the default accuracy was too
low. (Re-run the command at \g1 or higher to see such diagnostics.)</p>
<p>
The library syntax is <code>GEN <b>bnfisunit</b>(GEN bnf, GEN x)</code>.</p>

<hr></hr>
<a name="bnfnarrow"></a>
<h4>bnfnarrow(<em>bnf</em>)</h4>
<p></p>
<p><em>bnf</em> being as output by
<code>bnfinit</code>, computes the narrow class group of <em>bnf</em>. The output is
a 3-component row vector v analogous to the corresponding class group
component <code><em>bnf</em>.clgp</code> (<code><em>bnf</em>[8][1]</code>): the first component
is the narrow class number <code>v.no</code>, the second component is a vector
containing the SNF cyclic components <code>v.cyc</code> of
the narrow class group, and the third is a vector giving the generators of
the corresponding <code>v.gen</code> cyclic groups. Note that this function is a
special case of <code>bnrinit</code>.</p>
<p>
The library syntax is <code>GEN <b>buchnarrow</b>(GEN bnf)</code>.</p>

<hr></hr>
<a name="bnfsignunit"></a>
<h4>bnfsignunit(<em>bnf</em>)</h4>
<p></p>
<p><em>bnf</em> being as output by
<code>bnfinit</code>, this computes an r_1 x (r_1+r_2-1) matrix having &#177;1
components, giving the signs of the real embeddings of the fundamental units.
The following functions compute generators for the totally positive units:</p>
<p></p>
<p>
<pre class="code">  /* exponents of totally positive units generators on bnf.tufu */
  tpuexpo(bnf)=
  { my(S,d,K);
  
    S = bnfsignunit(bnf); d = matsize(S);
    S = matrix(d[1],d[2], i,j, if (S[i,j] &#60; 0, 1,0));
    S = concat(vectorv(d[1],i,1), S);   \\ add sign(-1)
    K = lift(matker(S * Mod(1,2)));
    if (K, mathnfmodid(K, 2), 2*matid(d[1]))
  }
  
  /* totally positive units */
  tpu(bnf)=
  { my(vu = bnf.tufu, ex = tpuexpo(bnf));
  
    vector(#ex-1, i, factorback(vu, ex[,i+1]))  \\ ex[,1] is 1
  }
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>signunits</b>(GEN bnf)</code>.</p>

<hr></hr>
<a name="bnfsunit"></a>
<h4>bnfsunit(<em>bnf</em>,S)</h4>
<p></p>
<p>Computes the fundamental S-units of the
number field <em>bnf</em> (output by <code>bnfinit</code>), where S is a list of
prime ideals (output by <code>idealprimedec</code>). The output is a vector v with
6 components.</p>
<p>
v[1] gives a minimal system of (integral) generators of the S-unit group
modulo the unit group.</p>
<p>
v[2] contains technical data needed by <code>bnfissunit</code>.</p>
<p>
v[3] is an empty vector (used to give the logarithmic embeddings of the
generators in v[1] in version 2.0.16).</p>
<p>
v[4] is the S-regulator (this is the product of the regulator, the
determinant of v[2] and the natural logarithms of the norms of the ideals
in S).</p>
<p>
v[5] gives the S-class group structure, in the usual format
(a row vector whose three components give in order the S-class number,
the cyclic components and the generators).</p>
<p>
v[6] is a copy of S.</p>
<p>
The library syntax is <code>GEN <b>bnfsunit</b>(GEN bnf, GEN S, long prec)</code>.</p>

<hr></hr>
<a name="bnrL1"></a>
<h4>bnrL1(<em>bnr</em>, {H}, {<em>flag</em> = 0})</h4>
<p></p>
<p>Let <em>bnr</em> be the number field data output by <code>bnrinit(,,1)</code> and
<em>H</em> be a square matrix defining a congruence subgroup of the
ray class group corresponding to <em>bnr</em> (the trivial congruence subgroup
if omitted). This function returns, for each character <font color=#FF0000>chi</font> of the ray
class group which is trivial on H, the value at s = 1 (or s = 0) of the
abelian L-function associated to <font color=#FF0000>chi</font>. For the value at s = 0, the
function returns in fact for each <font color=#FF0000>chi</font> a vector [r_<font color=#FF0000>chi</font>, c_<font color=#FF0000>chi</font>] where
L(s, <font color=#FF0000>chi</font>) = c.s^r + O(s^{r + 1})
near 0.</p>
<p>
The argument <em>flag</em> is optional, its binary digits
mean 1: compute at s = 0 if unset or s = 1 if set, 2: compute the
primitive L-function associated to <font color=#FF0000>chi</font> if unset or the L-function
with Euler factors at prime ideals dividing the modulus of <em>bnr</em> removed
if set (that is L_S(s, <font color=#FF0000>chi</font>), where S is the
set of infinite places of the number field together with the finite prime
ideals dividing the modulus of <em>bnr</em>), 3: return also the character if
set.</p>
<p>
<pre class="code">  K = bnfinit(x^2-229);
  bnr = bnrinit(K,1,1);
  bnrL1(bnr)
</pre></p>
<p>
returns the order and the first non-zero term of L(s, <font color=#FF0000>chi</font>) at s = 0
where <font color=#FF0000>chi</font> runs through the characters of the class group of
K = <b>Q</b>(sqrt{229}). Then</p>
<p>
<pre class="code">  bnr2 = bnrinit(K,2,1);
  bnrL1(bnr2,,2)
</pre></p>
<p>
returns the order and the first non-zero terms of L_S(s, <font color=#FF0000>chi</font>) at s = 0
where <font color=#FF0000>chi</font> runs through the characters of the class group of K and S is
the set of infinite places of K together with the finite prime 2. Note
that the ray class group modulo 2 is in fact the class group, so
<code>bnrL1(bnr2,0)</code> returns the same answer as <code>bnrL1(bnr,0)</code>.</p>
<p>
This function will fail with the message</p>
<p>
<pre class="code">   *** bnrL1: overflow in zeta_get_N0 [need too many primes].
</pre>
if the approximate functional equation requires us to sum
too many terms (if the discriminant of K is too large).</p>
<p>
The library syntax is <code>GEN <b>bnrL1</b>(GEN bnr, GEN H = NULL, long flag, long prec)</code>.</p>

<hr></hr>
<a name="bnrclassno"></a>
<h4>bnrclassno(A,{B},{C})</h4>
<p></p>
<p>Let A, B, C define a class field L over a ground field K
(of type <code>[<em>bnr</em>]</code>,
<code>[<em>bnr</em>, <em>subgroup</em>]</code>,
or <code>[<em>bnf</em>, <em>modulus</em>]</code>,
or <code>[<em>bnf</em>, <em>modulus</em>,<em>subgroup</em>]</code>,
Section [<b>Label: se:CFT</b>]); this function returns the relative degree [L:K].</p>
<p>
In particular if A is a <em>bnf</em> (with units), and B a modulus,
this function returns the corresponding ray class number modulo B.
One can input the associated <em>bid</em> (with generators if the subgroup
C is non trivial) for B instead of the module itself, saving some time.</p>
<p>
This function is faster than <code>bnrinit</code> and should be used if only the
ray class number is desired. See <code>bnrclassnolist</code> if you need ray class
numbers for all moduli less than some bound.</p>
<p>
The library syntax is <code>GEN <b>bnrclassno0</b>(GEN A, GEN B = NULL, GEN C = NULL)</code>.
Also available is
<code>GEN <b>bnrclassno</b>(GEN bnf,GEN f)</code> to compute the ray class number
modulo&nbsp;f.</p>

<hr></hr>
<a name="bnrclassnolist"></a>
<h4>bnrclassnolist(<em>bnf</em>,<em>list</em>)</h4>
<p></p>
<p><em>bnf</em> being as
output by <code>bnfinit</code>, and <em>list</em> being a list of moduli (with units) as
output by <code>ideallist</code> or <code>ideallistarch</code>, outputs the list of the
class numbers of the corresponding ray class groups. To compute a single
class number, <code>bnrclassno</code> is more efficient.</p>
<p></p>
<p>
<pre class="code">  ? bnf = bnfinit(x^2 - 2);
  ? L = ideallist(bnf, 100, 2);
  ? H = bnrclassnolist(bnf, L);
  ? H[98]
  %4 = [1, 3, 1]
  ? l = L[1][98]; ids = vector(#l, i, l[i].mod[1])
  %5 = [[98, 88; 0, 1], [14, 0; 0, 7], [98, 10; 0, 1]]
</pre></p>
<p>
The weird <code>l[i].mod[1]</code>, is the first component of <code>l[i].mod</code>, i.e.
the finite part of the conductor. (This is cosmetic: since by construction
the Archimedean part is trivial, I do not want to see it). This tells us that
the ray class groups modulo the ideals of norm 98 (printed as <code>%5</code>) have
respectively order 1, 3 and 1. Indeed, we may check directly:</p>
<p>
<pre class="code">  ? bnrclassno(bnf, ids[2])
  %6 = 3
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>bnrclassnolist</b>(GEN bnf, GEN list)</code>.</p>

<hr></hr>
<a name="bnrconductor"></a>
<h4>bnrconductor(A,{B},{C},{<em>flag</em> = 0})</h4>
<p></p>
<p>Conductor f of the subfield of a ray class field as defined by [A,B,C]
(of type <code>[<em>bnr</em>]</code>,
<code>[<em>bnr</em>, <em>subgroup</em>]</code>,
<code>[<em>bnf</em>, <em>modulus</em>]</code> or
<code>[<em>bnf</em>, <em>modulus</em>, <em>subgroup</em>]</code>,
Section [<b>Label: se:CFT</b>])</p>
<p>
If <em>flag</em> = 0, returns f.</p>
<p>
If <em>flag</em> = 1, returns [f, Cl_f, H], where Cl_f is the ray class group
modulo f, as a finite abelian group; finally H is the subgroup of Cl_f
defining the extension.</p>
<p>
If <em>flag</em> = 2, returns [f, <em>bnr</em>(f), H], as above except Cl_f is
replaced by a <code>bnr</code> structure, as output by <code>bnrinit</code>(,f,1).</p>
<p>
The library syntax is <code>GEN <b>bnrconductor0</b>(GEN A, GEN B = NULL, GEN C = NULL, long flag)</code>.</p>
<p>
Also available is <code>GEN <b>bnrconductor</b>(GEN bnr, GEN H, long flag)</code></p>

<hr></hr>
<a name="bnrconductorofchar"></a>
<h4>bnrconductorofchar(<em>bnr</em>,<em>chi</em>)</h4>
<p></p>
<p><em>bnr</em> being a big
ray number field as output by <code>bnrinit</code>, and <em>chi</em> being a row vector
representing a character as expressed on the generators of the ray
class group, gives the conductor of this character as a modulus.</p>
<p>
The library syntax is <code>GEN <b>bnrconductorofchar</b>(GEN bnr, GEN chi)</code>.</p>

<hr></hr>
<a name="bnrdisc"></a>
<h4>bnrdisc(A,{B},{C},{<em>flag</em> = 0})</h4>
<p></p>
<p>A, B, C defining a class field L over a ground field K
(of type <code>[<em>bnr</em>]</code>,
<code>[<em>bnr</em>, <em>subgroup</em>]</code>,
<code>[<em>bnf</em>, <em>modulus</em>]</code> or
<code>[<em>bnf</em>, <em>modulus</em>, <em>subgroup</em>]</code>,
Section [<b>Label: se:CFT</b>]), outputs data [N,r_1,D] giving the discriminant and
signature of L, depending on the binary digits of <em>flag</em>:</p>
<p>
<b>*</b> 1: if this bit is unset, output absolute data related to L/<b>Q</b>:
N is the absolute degree [L:<b>Q</b>], r_1 the number of real places of L,
and D the discriminant of L/<b>Q</b>. Otherwise, output relative data for L/K:
N is the relative degree [L:K], r_1 is the number of real places of K
unramified in L (so that the number of real places of L is equal to r_1
times N), and D is the relative discriminant ideal of L/K.</p>
<p>
<b>*</b> 2: if this bit is set and if the modulus is not the conductor of L,
only return 0.</p>
<p>
The library syntax is <code>GEN <b>bnrdisc0</b>(GEN A, GEN B = NULL, GEN C = NULL, long flag)</code>.</p>

<hr></hr>
<a name="bnrdisclist"></a>
<h4>bnrdisclist(<em>bnf</em>,<em>bound</em>,{<em>arch</em>})</h4>
<p></p>
<p><em>bnf</em> being as output by <code>bnfinit</code> (with units), computes a
list of discriminants of Abelian extensions of the number field by increasing
modulus norm up to bound <em>bound</em>. The ramified Archimedean places are
given by <em>arch</em>; all possible values are taken if <em>arch</em> is omitted.</p>
<p>
The alternative syntax <code>bnrdisclist</code>(<em>bnf</em>,<em>list</em>) is
supported, where <em>list</em> is as output by <code>ideallist</code> or
<code>ideallistarch</code> (with units), in which case <em>arch</em> is disregarded.</p>
<p>
The output v is a vector of vectors, where v[i][j] is understood to be in
fact V[2^{15}(i-1)+j] of a unique big vector V. (This awkward scheme
allows for larger vectors than could be otherwise represented.)</p>
<p>
V[k] is itself a vector W, whose length is the number of ideals of norm
k. We consider first the case where <em>arch</em> was specified. Each
component of W corresponds to an ideal m of norm k, and
gives invariants associated to the ray class field L of <em>bnf</em> of
conductor [m, <em>arch</em>]. Namely, each contains a vector [m,d,r,D] with
the following meaning: m is the prime ideal factorization of the modulus,
d = [L:<b>Q</b>] is the absolute degree of L, r is the number of real places
of L, and D is the factorization of its absolute discriminant. We set d
 = r = D = 0 if m is not the finite part of a conductor.</p>
<p>
If <em>arch</em> was omitted, all t = 2^{r_1} possible values are taken and a
component of W has the form [m, [[d_1,r_1,D_1],..., [d_t,r_t,D_t]]],
where m is the finite part of the conductor as above, and
[d_i,r_i,D_i] are the invariants of the ray class field of conductor
[m,v_i], where v_i is the i-th Archimedean component, ordered by
inverse lexicographic order; so v_1 = [0,...,0], v_2 = [1,0...,0],
etc. Again, we set d_i = r_i = D_i = 0 if [m,v_i] is not a conductor.</p>
<p>
Finally, each prime ideal pr = [p,<font color=#FF0000>alpha</font>,e,f,<font color=#FF0000>beta</font>] in the prime
factorization m is coded as the integer p.n^2+(f-1).n+(j-1),
where n is the degree of the base field and j is such that</p>
<p>
<code>pr = idealprimedec(<em>nf</em>,p)[j]</code>.</p>
<p>
m can be decoded using <code>bnfdecodemodule</code>.</p>
<p>
Note that to compute such data for a single field, either <code>bnrclassno</code>
or <code>bnrdisc</code> is more efficient.</p>
<p>
The library syntax is <code>GEN <b>bnrdisclist0</b>(GEN bnf, GEN bound, GEN arch = NULL)</code>.</p>

<hr></hr>
<a name="bnrinit"></a>
<h4>bnrinit(<em>bnf</em>,f,{<em>flag</em> = 0})</h4>
<p></p>
<p><em>bnf</em> is as
output by <code>bnfinit</code>, f is a modulus, initializes data linked to
the ray class group structure corresponding to this module, a so-called
<em>bnr</em> structure. One can input the associated <em>bid</em> with generators
for f instead of the module itself, saving some time.
(As in <code>idealstar</code>, the finite part of the conductor may be given
by a factorization into prime ideals, as produced by <code>idealfactor</code>.)</p>
<p>
The following member functions are available
on the result: <code>.bnf</code> is the underlying <em>bnf</em>,
<code>.mod</code> the modulus, <code>.bid</code> the <em>bid</em> structure associated to the
modulus; finally, <code>.clgp</code>, <code>.no</code>, <code>.cyc</code>, <code>.gen</code> refer to the
ray class group (as a finite abelian group), its cardinality, its elementary
divisors, its generators (only computed if <em>flag</em> = 1).</p>
<p>
The last group of functions are different from the members of the underlying
<em>bnf</em>, which refer to the class group; use <code><em>bnr</em>.bnf.<em>xxx</em></code>
to access these, e.g.&nbsp;<code><em>bnr</em>.bnf.cyc</code> to get the cyclic decomposition
of the class group.</p>
<p>
They are also different from the members of the underlying <em>bid</em>, which
refer to (<b>Z</b>_K/f)^*; use <code><em>bnr</em>.bid.<em>xxx</em></code> to access these,
e.g.&nbsp;<code><em>bnr</em>.bid.no</code> to get <font color=#FF0000>phi</font>(f).</p>
<p>
If <em>flag</em> = 0 (default), the generators of the ray class group are not computed,
which saves time. Hence <code><em>bnr</em>.gen</code> would produce an error.</p>
<p>
If <em>flag</em> = 1, as the default, except that generators are computed.</p>
<p>
The library syntax is <code>GEN <b>bnrinit0</b>(GEN bnf, GEN f, long flag)</code>.
Instead the above  hardcoded  numerical flags,  one should rather use
<code>GEN <b>Buchray</b>(GEN bnf, GEN module, long flag)</code>
where flag is an or-ed combination of <code>nf_GEN</code> (include generators)
and <code>nf_INIT</code> (if omitted, return just the cardinal of the ray class group
and its structure), possibly 0.</p>

<hr></hr>
<a name="bnrisconductor"></a>
<h4>bnrisconductor(A,{B},{C})</h4>
<p></p>
<p>A, B, C represent
an extension of the base field, given by class field theory
(see&nbsp;Section [<b>Label: se:CFT</b>]). Outputs 1 if this modulus is the conductor, and 0
otherwise. This is slightly faster than <code>bnrconductor</code>.</p>
<p>
The library syntax is <code>long <b>bnrisconductor0</b>(GEN A, GEN B = NULL, GEN C = NULL)</code>.</p>

<hr></hr>
<a name="bnrisprincipal"></a>
<h4>bnrisprincipal(<em>bnr</em>,x,{<em>flag</em> = 1})</h4>
<p></p>
<p><em>bnr</em> being the
number field data which is output by <code>bnrinit</code>(,,1) and x being an
ideal in any form, outputs the components of x on the ray class group
generators in a way similar to <code>bnfisprincipal</code>. That is a 2-component
vector v where v[1] is the vector of components of x on the ray class
group generators, v[2] gives on the integral basis an element <font color=#FF0000>alpha</font> such
that x = <font color=#FF0000>alpha</font><font color=#FF0000>prod</font>_ig_i^{x_i}.</p>
<p>
If <em>flag</em> = 0, outputs only v_1. In that case, <em>bnr</em> need not contain the
ray class group generators, i.e.&nbsp;it may be created with <code>bnrinit</code>(,,0)
If x is not coprime to the modulus of <em>bnr</em> the result is undefined.</p>
<p>
The library syntax is <code>GEN <b>bnrisprincipal</b>(GEN bnr, GEN x, long flag)</code>.
Instead of hardcoded  numerical flags,  one should rather
use
<code>GEN <b>isprincipalray</b>(GEN bnr, GEN x)</code> for <code>flag</code> = 0, and if you
want generators:</p>
<p>
<pre class="code">    bnrisprincipal(bnr, x, nf_GEN)
</pre></p>
<p></p>

<hr></hr>
<a name="bnrrootnumber"></a>
<h4>bnrrootnumber(<em>bnr</em>,<em>chi</em>,{<em>flag</em> = 0})</h4>
<p></p>
<p>If <font color=#FF0000>chi</font> = <em>chi</em> is a
character over <em>bnr</em>, not necessarily primitive, let
L(s,<font color=#FF0000>chi</font>) = <font color=#FF0000>sum</font>_{id} <font color=#FF0000>chi</font>(id) N(id)^{-s} be the associated
Artin L-function. Returns the so-called Artin root number, i.e.&nbsp;the
complex number W(<font color=#FF0000>chi</font>) of modulus 1 such that</p>
<p>
<font color=#FF0000>Lambda</font>(1-s,<font color=#FF0000>chi</font>) = W(<font color=#FF0000>chi</font>) <font color=#FF0000>Lambda</font>(s,\overline{<font color=#FF0000>chi</font>})</p>
<p>
where <font color=#FF0000>Lambda</font>(s,<font color=#FF0000>chi</font>) = A(<font color=#FF0000>chi</font>)^{s/2}<font color=#FF0000>gamma</font>_<font color=#FF0000>chi</font>(s) L(s,<font color=#FF0000>chi</font>) is
the enlarged L-function associated to L.</p>
<p>
The generators of the ray class group are needed, and you can set <em>flag</em> = 1 if
the character is known to be primitive. Example:</p>
<p></p>
<p>
<pre class="code">  bnf = bnfinit(x^2 - x - 57);
  bnr = bnrinit(bnf, [7,[1,1]], 1);
  bnrrootnumber(bnr, [2,1])
</pre></p>
<p>
returns the root number of the character <font color=#FF0000>chi</font> of
Cl_{7 oo _1 oo _2}(<b>Q</b>(sqrt{229})) defined by <font color=#FF0000>chi</font>(g_1^ag_2^b)
 = <font color=#FF0000>zeta</font>_1^{2a}<font color=#FF0000>zeta</font>_2^b. Here g_1, g_2 are the generators of the
ray-class group given by <code>bnr.gen</code> and <font color=#FF0000>zeta</font>_1 = e^{2i<font color=#FF0000>Pi</font>/N_1},
<font color=#FF0000>zeta</font>_2 = e^{2i<font color=#FF0000>Pi</font>/N_2} where N_1, N_2 are the orders of g_1 and
g_2 respectively (N_1 = 6 and N_2 = 3 as <code>bnr.cyc</code> readily tells us).</p>
<p>
The library syntax is <code>GEN <b>bnrrootnumber</b>(GEN bnr, GEN chi, long flag, long prec)</code>.</p>

<hr></hr>
<a name="bnrstark"></a>
<h4>bnrstark(<em>bnr</em>,{<em>subgroup</em>})</h4>
<p></p>
<p><em>bnr</em> being as output by <code>bnrinit(,,1)</code>, finds a relative equation
for the class field corresponding to the modulus in <em>bnr</em> and the given
congruence subgroup (as usual, omit <em>subgroup</em> if you want the whole ray
class group).</p>
<p>
The main variable of <em>bnr</em> must not be x, and the ground field and the
class field must be totally real. When the base field is <b>Q</b>, the vastly
simpler <code>galoissubcyclo</code> is used instead. Here is an example:</p>
<p>
<pre class="code">  bnf = bnfinit(y^2 - 3);
  bnr = bnrinit(bnf, 5, 1);
  bnrstark(bnr)
</pre></p>
<p>
returns the ray class field of <b>Q</b>(sqrt{3}) modulo 5. Usually, one wants
to apply to the result one of</p>
<p>
<pre class="code">  rnfpolredabs(bnf, pol, 16)     \\  compute a reduced relative polynomial
  rnfpolredabs(bnf, pol, 16 + 2) \\  compute a reduced absolute polynomial
</pre></p>
<p></p>
<p>
The routine uses Stark units and needs to find a suitable auxiliary
conductor, which may not exist when the class field is not cyclic over the
base. In this case <code>bnrstark</code> is allowed to return a vector of
polynomials defining <em>independent</em> relative extensions, whose compositum
is the requested class field. It was decided that it was more useful
to keep the extra information thus made available, hence the user has to take
the compositum herself.</p>
<p>
Even if it exists, the auxiliary conductor may be so large that later
computations become unfeasible. (And of course, Stark's conjecture may simply
be wrong.) In case of difficulties, try <code>rnfkummer</code>:</p>
<p>
<pre class="code">  ? bnr = bnrinit(bnfinit(y^8-12*y^6+36*y^4-36*y^2+9,1), 2, 1);
  ? bnrstark(bnr)
    ***   at top-level: bnrstark(bnr)
    ***                 ^-------------
    *** bnrstark: need 3919350809720744 coefficients in initzeta.
    *** Computation impossible.
  ? lift( rnfkummer(bnr) )
  time = 24 ms.
  %2 = x^2 + (1/3*y^6 - 11/3*y^4 + 8*y^2 - 5)
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>bnrstark</b>(GEN bnr, GEN subgroup = NULL, long prec)</code>.</p>

<hr></hr>
<a name="dirzetak"></a>
<h4>dirzetak(<em>nf</em>,b)</h4>
<p></p>
<p>Gives as a vector the first b
coefficients of the Dedekind zeta function of the number field <em>nf</em>
considered as a Dirichlet series.</p>
<p>
The library syntax is <code>GEN <b>dirzetak</b>(GEN nf, GEN b)</code>.</p>

<hr></hr>
<a name="factornf"></a>
<h4>factornf(x,t)</h4>
<p></p>
<p>Factorization of the univariate polynomial x
over the number field defined by the (univariate) polynomial t. x may
have coefficients in <b>Q</b> or in the number field. The algorithm reduces to
factorization over <b>Q</b> (Trager's trick). The direct approach of
<code>nffactor</code>, which uses van Hoeij's method in a relative setting, is
in general faster.</p>
<p>
The main variable of t must be of <em>lower</em> priority than that of x
(see Section [<b>Label: se:priority</b>]). However if non-rational number field elements
occur (as polmods or polynomials) as coefficients of x, the variable of
these polmods <em>must</em> be the same as the main variable of t. For
example</p>
<p></p>
<p>
<pre class="code">  ? factornf(x^2 + Mod(y, y^2+1), y^2+1);
  ? factornf(x^2 + y, y^2+1); \\  these two are OK
  ? factornf(x^2 + Mod(z,z^2+1), y^2+1)
    ***   at top-level: factornf(x^2+Mod(z,z
    ***                 ^--------------------
    *** factornf: inconsistent data in rnf function.
  ? factornf(x^2 + z, y^2+1)
    ***   at top-level: factornf(x^2+z,y^2+1
    ***                 ^--------------------
    *** factornf: incorrect variable in rnf function.
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>polfnf</b>(GEN x, GEN t)</code>.</p>

<hr></hr>
<a name="galoisexport"></a>
<h4>galoisexport(<em>gal</em>,{<em>flag</em>})</h4>
<p></p>
<p><em>gal</em> being be a Galois group as output by <code>galoisinit</code>,
export the underlying permutation group as a string suitable
for (no flags or <em>flag</em> = 0) GAP or (<em>flag</em> = 1) Magma. The following example
compute the index of the underlying abstract group in the GAP library:</p>
<p>
<pre class="code">  ? G = galoisinit(x^6+108);
  ? s = galoisexport(G)
  %2 = "Group((1, 2, 3)(4, 5, 6), (1, 4)(2, 6)(3, 5))"
  ? extern("echo \"IdGroup("s");\" | gap -q")
  %3 = [6, 1]
  ? galoisidentify(G)
  %4 = [6, 1]
</pre></p>
<p>
This command also accepts subgroups returned by <code>galoissubgroups</code>.</p>
<p>
To <em>import</em> a GAP permutation into gp (for <code>galoissubfields</code> for
instance), the following GAP function may be useful:</p>
<p>
<pre class="code">  PermToGP := function(p, n)
    return Permuted([1..n],p);
  end;
  
  gap&#62; p:= (1,26)(2,5)(3,17)(4,32)(6,9)(7,11)(8,24)(10,13)(12,15)(14,27)
    (16,22)(18,28)(19,20)(21,29)(23,31)(25,30)
  gap&#62; PermToGP(p,32);
  [ 26, 5, 17, 32, 2, 9, 11, 24, 6, 13, 7, 15, 10, 27, 12, 22, 3, 28, 20, 19,
    29, 16, 31, 8, 30, 1, 14, 18, 21, 25, 23, 4 ]
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>galoisexport</b>(GEN gal, long flag)</code>.</p>

<hr></hr>
<a name="galoisfixedfield"></a>
<h4>galoisfixedfield(<em>gal</em>,<em>perm</em>,{<em>flag</em>},{v = y})</h4>
<p></p>
<p><em>gal</em> being be a Galois group as output by <code>galoisinit</code> and
<em>perm</em> an element of <em>gal</em>.group, a vector of such elements
or a subgroup of <em>gal</em> as returned by galoissubgroups,
computes the fixed field of <em>gal</em> by the automorphism defined by the
permutations <em>perm</em> of the roots <em>gal</em>.roots. P is guaranteed to
be squarefree modulo <em>gal</em>.p.</p>
<p>
If no flags or <em>flag</em> = 0, output format is the same as for <code>nfsubfield</code>,
returning [P,x] such that P is a polynomial defining the fixed field, and
x is a root of P expressed as a polmod in <em>gal</em>.pol.</p>
<p>
If <em>flag</em> = 1 return only the polynomial P.</p>
<p>
If <em>flag</em> = 2 return [P,x,F] where P and x are as above and F is the
factorization of <em>gal</em>.pol over the field defined by P, where
variable v (y by default) stands for a root of P. The priority of v
must be less than the priority of the variable of <em>gal</em>.pol (see
Section [<b>Label: se:priority</b>]). Example:</p>
<p></p>
<p>
<pre class="code">  ? G = galoisinit(x^4+1);
  ? galoisfixedfield(G,G.group[2],2)
  %2 = [x^2 + 2, Mod(x^3 + x, x^4 + 1), [x^2 - y*x - 1, x^2 + y*x - 1]]
</pre></p>
<p>
computes the factorization  x^4+1 = (x^2-sqrt{-2}x-1)(x^2+sqrt{-2}x-1)</p>
<p>
The library syntax is <code>GEN <b>galoisfixedfield</b>(GEN gal, GEN perm, long flag, long v = -1)</code>, where <code>v</code> is a variable number.</p>

<hr></hr>
<a name="galoisgetpol"></a>
<h4>galoisgetpol(a,{b},{s})</h4>
<p></p>
<p>Query the galpol package for a polynomial with Galois group isomorphic to
GAP4(a,b), totally real if s = 1 (default) and totally complex if s = 2. The
output is a vector [<code>pol</code>, <code>den</code>] where</p>
<p>
<b>*</b>  <code>pol</code> is the polynomial of degree a</p>
<p>
<b>*</b> <code>den</code> is the denominator of <code>nfgaloisconj(pol)</code>.
Pass it as an optional argument to <code>galoisinit</code> or <code>nfgaloisconj</code> to
speed them up:</p>
<p>
<pre class="code">  ? [pol,den] = galoisgetpol(64,4,1);
  ? G = galoisinit(pol);
  time = 352ms
  ? galoisinit(pol, den);  \\ passing 'den' speeds up the computation
  time = 264ms
  ? % == %`
  %4 = 1  \\ same answer
</pre></p>
<p>
If b and s are omitted, return the number of isomorphism classes of
groups of order a.</p>
<p>
The library syntax is <code>GEN <b>galoisgetpol</b>(long a, long b, long s)</code>.
Also available is <code>GEN <b>galoisnbpol</b>(long a)</code> when b and s
are omitted.</p>

<hr></hr>
<a name="galoisidentify"></a>
<h4>galoisidentify(<em>gal</em>)</h4>
<p></p>
<p><em>gal</em> being be a Galois group as output by <code>galoisinit</code>,
output the isomorphism class of the underlying abstract group as a
two-components vector [o,i], where o is the group order, and i is the
group index in the GAP4 Small Group library, by Hans Ulrich Besche, Bettina
Eick and Eamonn O'Brien.</p>
<p>
This command also accepts subgroups returned by <code>galoissubgroups</code>.</p>
<p>
The current implementation is limited to degree less or equal to 127.
Some larger "easy" orders are also supported.</p>
<p>
The output is similar to the output of the function <code>IdGroup</code> in GAP4.
Note that GAP4 <code>IdGroup</code> handles all groups of order less than 2000
except 1024, so you can use <code>galoisexport</code> and GAP4 to identify large
Galois groups.</p>
<p>
The library syntax is <code>GEN <b>galoisidentify</b>(GEN gal)</code>.</p>

<hr></hr>
<a name="galoisinit"></a>
<h4>galoisinit(<em>pol</em>,{<em>den</em>})</h4>
<p></p>
<p>Computes the Galois group
and all necessary information for computing the fixed fields of the
Galois extension K/<b>Q</b> where K is the number field defined by
<em>pol</em> (monic irreducible polynomial in <b>Z</b>[X] or
a number field as output by <code>nfinit</code>). The extension K/<b>Q</b> must be
Galois with Galois group "weakly" super-solvable, see below;
returns 0 otherwise. Hence this permits to quickly check whether a polynomial
of order strictly less than 36 is Galois or not.</p>
<p>
The algorithm used is an improved version of the paper
"An efficient algorithm for the computation of Galois automorphisms",
Bill Allombert, Math.&nbsp;Comp, vol.&nbsp;73, 245, 2001, pp.&nbsp;359--375.</p>
<p>
A group G is said to be "weakly" super-solvable if there exists a
normal series</p>
<p>
{1} = H_0 \triangleleft H_1 \triangleleft...\triangleleft H_{n-1}
\triangleleft H_n</p>
<p>
such that each H_i is normal in G and for i &#60; n, each quotient group
H_{i+1}/H_i is cyclic, and either H_n = G (then G is super-solvable) or
G/H_n is isomorphic to either A_4 or S_4.</p>
<p>
In practice, almost all small groups are WKSS, the exceptions having order
36(1 exception), 48(2), 56(1), 60(1), 72(5), 75(1), 80(1), 96(10) and \geq
108.</p>
<p>
This function is a prerequisite for most of the <code>galois</code>xxx routines.
For instance:</p>
<p></p>
<p>
<pre class="code">  P = x^6 + 108;
  G = galoisinit(P);
  L = galoissubgroups(G);
  vector(#L, i, galoisisabelian(L[i],1))
  vector(#L, i, galoisidentify(L[i]))
</pre></p>
<p></p>
<p>
The output is an 8-component vector <em>gal</em>.</p>
<p>
<em>gal</em>[1] contains the polynomial <em>pol</em>
(<code><em>gal</em>.pol</code>).</p>
<p>
<em>gal</em>[2] is a three-components vector [p,e,q] where p is a
prime number (<code><em>gal</em>.p</code>) such that <em>pol</em> totally split
modulo p , e is an integer and q = p^e (<code><em>gal</em>.mod</code>) is the
modulus of the roots in <code><em>gal</em>.roots</code>.</p>
<p>
<em>gal</em>[3] is a vector L containing the p-adic roots of
<em>pol</em> as integers implicitly modulo <code><em>gal</em>.mod</code>.
(<code><em>gal</em>.roots</code>).</p>
<p>
<em>gal</em>[4] is the inverse of the Vandermonde matrix of the
p-adic roots of <em>pol</em>, multiplied by <em>gal</em>[5].</p>
<p>
<em>gal</em>[5] is a multiple of the least common denominator of the
automorphisms expressed as polynomial in a root of <em>pol</em>.</p>
<p>
<em>gal</em>[6] is the Galois group G expressed as a vector of
permutations of L (<code><em>gal</em>.group</code>).</p>
<p>
<em>gal</em>[7] is a generating subset S = [s_1,...,s_g] of G
expressed as a vector of permutations of L (<code><em>gal</em>.gen</code>).</p>
<p>
<em>gal</em>[8] contains the relative orders [o_1,...,o_g] of
the generators of S (<code><em>gal</em>.orders</code>).</p>
<p>
Let H_n be as above, we have the following properties:</p>
<p>
&nbsp;&nbsp;<b>*</b> if G/H_n ~  A_4 then [o_1,...,o_g] ends by
[2,2,3].</p>
<p>
&nbsp;&nbsp;<b>*</b> if G/H_n ~  S_4 then [o_1,...,o_g] ends by
[2,2,3,2].</p>
<p>
&nbsp;&nbsp;<b>*</b> for 1 <code>&#60;=</code> i <code>&#60;=</code> g the subgroup of G generated by
[s_1,...,s_g] is normal, with the exception of i = g-2 in the
A_4 case and of i = g-3 in the S_A case.</p>
<p>
&nbsp;&nbsp;<b>*</b> the relative order o_i of s_i is its order in the
quotient group G/<code>&#60;</code>s_1,...,s_{i-1}<code>&#62;</code>, with the same
exceptions.</p>
<p>
&nbsp;&nbsp;<b>*</b> for any x belongs to G there exists a unique family
[e_1,...,e_g] such that (no exceptions):</p>
<p>
-- for 1 <code>&#60;=</code> i <code>&#60;=</code> g we have 0 <code>&#60;=</code> e_i &#60; o_i</p>
<p>
-- x = g_1^{e_1}g_2^{e_2}...g_n^{e_n}</p>
<p>
If present den must be a suitable value for <em>gal</em>[5].</p>
<p>
The library syntax is <code>GEN <b>galoisinit</b>(GEN pol, GEN den = NULL)</code>.</p>

<hr></hr>
<a name="galoisisabelian"></a>
<h4>galoisisabelian(<em>gal</em>,{<em>flag</em> = 0})</h4>
<p></p>
<p><em>gal</em> being as output by <code>galoisinit</code>, return 0 if
<em>gal</em> is not an abelian group, and the HNF matrix of <em>gal</em> over
<code>gal.gen</code> if fl = 0, 1 if fl = 1.</p>
<p>
This command also accepts subgroups returned by <code>galoissubgroups</code>.</p>
<p>
The library syntax is <code>GEN <b>galoisisabelian</b>(GEN gal, long flag)</code>.</p>

<hr></hr>
<a name="galoisisnormal"></a>
<h4>galoisisnormal(<em>gal</em>,<em>subgrp</em>)</h4>
<p></p>
<p><em>gal</em> being as output by <code>galoisinit</code>, and <em>subgrp</em> a subgroup
of <em>gal</em> as output by <code>galoissubgroups</code>,return 1 if <em>subgrp</em> is a
normal subgroup of <em>gal</em>, else return 0.</p>
<p>
This command also accepts subgroups returned by <code>galoissubgroups</code>.</p>
<p>
The library syntax is <code>long <b>galoisisnormal</b>(GEN gal, GEN subgrp)</code>.</p>

<hr></hr>
<a name="galoispermtopol"></a>
<h4>galoispermtopol(<em>gal</em>,<em>perm</em>)</h4>
<p></p>
<p><em>gal</em> being a
Galois group as output by <code>galoisinit</code> and <em>perm</em> a element of
<em>gal</em>.group, return the polynomial defining the Galois
automorphism, as output by <code>nfgaloisconj</code>, associated with the
permutation <em>perm</em> of the roots <em>gal</em>.roots. <em>perm</em> can
also be a vector or matrix, in this case, <code>galoispermtopol</code> is
applied to all components recursively.</p>
<p>
Note that</p>
<p>
<pre class="code">  G = galoisinit(pol);
  galoispermtopol(G, G[6])~
</pre></p>
<p>
is equivalent to <code>nfgaloisconj(pol)</code>, if degree of <em>pol</em> is greater
or equal to 2.</p>
<p>
The library syntax is <code>GEN <b>galoispermtopol</b>(GEN gal, GEN perm)</code>.</p>

<hr></hr>
<a name="galoissubcyclo"></a>
<h4>galoissubcyclo(N,H,{<em>fl</em> = 0},{v})</h4>
<p></p>
<p>Computes the subextension
of <b>Q</b>(<font color=#FF0000>zeta</font>_n) fixed by the subgroup H \subset (<b>Z</b>/n<b>Z</b>)^*. By the
Kronecker-Weber theorem, all abelian number fields can be generated in this
way (uniquely if n is taken to be minimal).</p>
<p>
The pair (n, H) is deduced from the parameters (N, H) as follows</p>
<p>
<b>*</b> N an integer: then n = N; H is a generator, i.e. an
integer or an integer modulo n; or a vector of generators.</p>
<p>
<b>*</b> N the output of <code>znstar(n)</code>. H as in the first case
above, or a matrix, taken to be a HNF left divisor of the SNF for (<b>Z</b>/n<b>Z</b>)^*
(of type <code>N.cyc</code>), giving the generators of H in terms of <code>N.gen</code>.</p>
<p>
<b>*</b> N the output of <code>bnrinit(bnfinit(y), m, 1)</code> where m is a
module. H as in the first case, or a matrix taken to be a HNF left
divisor of the SNF for the ray class group modulo m
(of type <code>N.cyc</code>), giving the generators of H in terms of <code>N.gen</code>.</p>
<p>
In this last case, beware that H is understood relatively to N; in
particular, if the infinite place does not divide the module, e.g if m is
an integer, then it is not a subgroup of (<b>Z</b>/n<b>Z</b>)^*, but of its quotient by
{&#177; 1}.</p>
<p>
If fl = 0, compute a polynomial (in the variable <em>v</em>) defining the
the subfield of <b>Q</b>(<font color=#FF0000>zeta</font>_n) fixed by the subgroup <em>H</em> of (<b>Z</b>/n<b>Z</b>)^*.</p>
<p>
If fl = 1, compute only the conductor of the abelian extension, as a module.</p>
<p>
If fl = 2, output [pol, N], where pol is the polynomial as output when
fl = 0 and N the conductor as output when fl = 1.</p>
<p>
The following function can be used to compute all subfields of
<b>Q</b>(<font color=#FF0000>zeta</font>_n) (of exact degree <code>d</code>, if <code>d</code> is set):</p>
<p>
<pre class="code">  polsubcyclo(n, d = -1)=
  { my(bnr,L,IndexBound);
    IndexBound = if (d &#60; 0, n, [d]);
    bnr = bnrinit(bnfinit(y), [n,[1]], 1);
    L = subgrouplist(bnr, IndexBound, 1);
    vector(#L,i, galoissubcyclo(bnr,L[i]));
  }
</pre></p>
<p>
Setting <code>L = subgrouplist(bnr, IndexBound)</code> would produce subfields of exact
conductor n oo .</p>
<p>
The library syntax is <code>GEN <b>galoissubcyclo</b>(GEN N, GEN H = NULL, long fl, long v = -1)</code>, where <code>v</code> is a variable number.</p>

<hr></hr>
<a name="galoissubfields"></a>
<h4>galoissubfields(G,{<em>flags</em> = 0},{v})</h4>
<p></p>
<p>Outputs all the subfields of the Galois group <em>G</em>, as a vector.
This works by applying <code>galoisfixedfield</code> to all subgroups. The meaning of
the flag <em>fl</em> is the same as for <code>galoisfixedfield</code>.</p>
<p>
The library syntax is <code>GEN <b>galoissubfields</b>(GEN G, long flags, long v = -1)</code>, where <code>v</code> is a variable number.</p>

<hr></hr>
<a name="galoissubgroups"></a>
<h4>galoissubgroups(G)</h4>
<p></p>
<p>Outputs all the subgroups of the Galois group <code>gal</code>. A subgroup is a
vector [<em>gen</em>, <em>orders</em>], with the same meaning
as for <em>gal</em>.gen and <em>gal</em>.orders. Hence <em>gen</em> is a vector of
permutations generating the subgroup, and <em>orders</em> is the relatives
orders of the generators. The cardinal of a subgroup is the product of the
relative orders. Such subgroup can be used instead of a Galois group in the
following command: <code>galoisisabelian</code>, <code>galoissubgroups</code>,
<code>galoisexport</code> and <code>galoisidentify</code>.</p>
<p>
To get the subfield fixed by a subgroup <em>sub</em> of <em>gal</em>, use</p>
<p>
<pre class="code">  galoisfixedfield(gal,sub[1])
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>galoissubgroups</b>(GEN G)</code>.</p>

<hr></hr>
<a name="idealadd"></a>
<h4>idealadd(<em>nf</em>,x,y)</h4>
<p></p>
<p>Sum of the two ideals x and y in the number field <em>nf</em>. The
result is given in HNF.</p>
<p>
<pre class="code">   ? K = nfinit(x^2 + 1);
   ? a = idealadd(K, 2, x + 1)  \\ ideal generated by 2 and 1+I
   %2 =
   [2 1]
  
   [0 1]
   ? pr = idealprimedec(K, 5)[1];  \\ a prime ideal above 5
   ? idealadd(K, a, pr)     \\ coprime, as expected
   %4 =
   [1 0]
  
   [0 1]
</pre></p>
<p>
This function cannot be used to add arbitrary <b>Z</b>-modules, since it assumes
that its arguments are ideals:</p>
<p>
<pre class="code">    ? b = Mat([1,0]~);
    ? idealadd(K, b, b)     \\ only square t_MATs represent ideals
    *** idealadd: non-square t_MAT in idealtyp.
    ? c = [2, 0; 2, 0]; idealadd(K, c, c)   \\ non-sense
    %6 =
    [2 0]
  
    [0 2]
    ? d = [1, 0; 0, 2]; idealadd(K, d, d)   \\ non-sense
    %7 =
    [1 0]
  
    [0 1]
  
</pre>
In the last two examples, we get wrong results since the
matrices c and d do not correspond to an ideal: the <b>Z</b>-span of their
columns (as usual interpreted as coordinates with respect to the integer basis
<code>K.zk</code>) is not an O_K-module. To add arbitrary <b>Z</b>-modules generated
by the columns of matrices A and B, use <code>mathnf(concat(A,B))</code>.</p>
<p>
The library syntax is <code>GEN <b>idealadd</b>(GEN nf, GEN x, GEN y)</code>.</p>

<hr></hr>
<a name="idealaddtoone"></a>
<h4>idealaddtoone(<em>nf</em>,x,{y})</h4>
<p></p>
<p>x and y being two co-prime
integral ideals (given in any form), this gives a two-component row vector
[a,b] such that a belongs to x, b belongs to y and a+b = 1.</p>
<p>
The alternative syntax <code>idealaddtoone</code>(<em>nf</em>,v), is supported, where
v is a k-component vector of ideals (given in any form) which sum to
<b>Z</b>_K. This outputs a k-component vector e such that e[i] belongs to x[i] for
1 <code>&#60;=</code> i <code>&#60;=</code> k and <font color=#FF0000>sum</font>_{1 <code>&#60;=</code> i <code>&#60;=</code> k}e[i] = 1.</p>
<p>
The library syntax is <code>GEN <b>idealaddtoone0</b>(GEN nf, GEN x, GEN y = NULL)</code>.</p>

<hr></hr>
<a name="idealappr"></a>
<h4>idealappr(<em>nf</em>,x,{<em>flag</em> = 0})</h4>
<p></p>
<p>If x is a fractional ideal
(given in any form), gives an element <font color=#FF0000>alpha</font> in <em>nf</em> such that for
all prime ideals <b>p</b> such that the valuation of x at <b>p</b> is
non-zero, we have v_{<b>p</b>}(<font color=#FF0000>alpha</font>) = v_{<b>p</b>}(x), and
v_{<b>p</b>}(<font color=#FF0000>alpha</font>) <code>&#62;=</code> 0 for all other <b>p</b>.</p>
<p>
If <em>flag</em> is non-zero, x must be given as a prime ideal factorization, as
output by <code>idealfactor</code>, but possibly with zero or negative exponents.
This yields an element <font color=#FF0000>alpha</font> such that for all prime ideals <b>p</b>
occurring in x, v_{<b>p</b>}(<font color=#FF0000>alpha</font>) is equal to the exponent of
<b>p</b> in x, and for all other prime ideals,
v_{<b>p</b>}(<font color=#FF0000>alpha</font>) <code>&#62;=</code> 0. This generalizes <code>idealappr</code>(<em>nf</em>,x,0)
since zero exponents are allowed. Note that the algorithm used is slightly
different, so that</p>
<p>
<pre class="code">    idealappr(nf, idealfactor(nf,x))
</pre></p>
<p>
may not be the same as <code>idealappr(nf,x,1)</code>.</p>
<p>
The library syntax is <code>GEN <b>idealappr0</b>(GEN nf, GEN x, long flag)</code>.</p>

<hr></hr>
<a name="idealchinese"></a>
<h4>idealchinese(<em>nf</em>,x,y)</h4>
<p></p>
<p>x being a prime ideal factorization
(i.e.&nbsp;a 2 by 2 matrix whose first column contains prime ideals, and the second
column integral exponents), y a vector of elements in <em>nf</em> indexed by
the ideals in x, computes an element b such that</p>
<p>
v_{<b>p</b>}(b - y_{<b>p</b>}) <code>&#62;=</code> v_{<b>p</b>}(x) for all prime ideals
in x and v_{<b>p</b>}(b) <code>&#62;=</code> 0 for all other <b>p</b>.</p>
<p>
The library syntax is <code>GEN <b>idealchinese</b>(GEN nf, GEN x, GEN y)</code>.</p>

<hr></hr>
<a name="idealcoprime"></a>
<h4>idealcoprime(<em>nf</em>,x,y)</h4>
<p></p>
<p>Given two integral ideals x and y
in the number field <em>nf</em>, returns a <font color=#FF0000>beta</font> in the field,
such that <font color=#FF0000>beta</font>.x is an integral ideal coprime to y.</p>
<p>
The library syntax is <code>GEN <b>idealcoprime</b>(GEN nf, GEN x, GEN y)</code>.</p>

<hr></hr>
<a name="idealdiv"></a>
<h4>idealdiv(<em>nf</em>,x,y,{<em>flag</em> = 0})</h4>
<p></p>
<p>Quotient x.y^{-1} of the two ideals x and y in the number
field <em>nf</em>. The result is given in HNF.</p>
<p>
If <em>flag</em> is non-zero, the quotient x.y^{-1} is assumed to be an
integral ideal. This can be much faster when the norm of the quotient is
small even though the norms of x and y are large.</p>
<p>
The library syntax is <code>GEN <b>idealdiv0</b>(GEN nf, GEN x, GEN y, long flag)</code>.
Also available are <code>GEN <b>idealdiv</b>(GEN nf, GEN x, GEN y)</code>
(<em>flag</em> = 0) and <code>GEN <b>idealdivexact</b>(GEN nf, GEN x, GEN y)</code> (<em>flag</em> = 1).</p>

<hr></hr>
<a name="idealfactor"></a>
<h4>idealfactor(<em>nf</em>,x)</h4>
<p></p>
<p>Factors into prime ideal powers the
ideal x in the number field <em>nf</em>. The output format is similar to the
<code>factor</code> function, and the prime ideals are represented in the form
output by the <code>idealprimedec</code> function, i.e.&nbsp;as 5-element vectors.</p>
<p>
The library syntax is <code>GEN <b>idealfactor</b>(GEN nf, GEN x)</code>.</p>

<hr></hr>
<a name="idealfactorback"></a>
<h4>idealfactorback(<em>nf</em>,f,{e},{<em>flag</em> = 0})</h4>
<p></p>
<p>Gives back the ideal corresponding to a factorization. The integer 1
corresponds to the empty factorization.
If e is present, e and f must be vectors of the same length (e being
integral), and the corresponding factorization is the product of the
f[i]^{e[i]}.</p>
<p>
If not, and f is vector, it is understood as in the preceding case with e
a vector of 1s: we return the product of the f[i]. Finally, f can be a
regular factorization, as produced by <code>idealfactor</code>.</p>
<p>
<pre class="code">  ? nf = nfinit(y^2+1); idealfactor(nf, 4 + 2*y)
  %1 =
  [[2, [1, 1]~, 2, 1, [1, 1]~] 2]
  
  [[5, [2, 1]~, 1, 1, [-2, 1]~] 1]
  
  ? idealfactorback(nf, %)
  %2 =
  [10 4]
  
  [0  2]
  
  ? f = %1[,1]; e = %1[,2]; idealfactorback(nf, f, e)
  %3 =
  [10 4]
  
  [0  2]
  
  ? % == idealhnf(nf, 4 + 2*y)
  %4 = 1
</pre></p>
<p>
If <code>flag</code> is non-zero, perform ideal reductions (<code>idealred</code>) along the
way. This is most useful if the ideals involved are all <em>extended</em>
ideals (for instance with trivial principal part), so that the principal parts
extracted by <code>idealred</code> are not lost. Here is an example:</p>
<p>
<pre class="code">  ? f = vector(#f, i, [f[i], [;]]);  \\ transform to extended ideals
  ? idealfactorback(nf, f, e, 1)
  %6 = [[1, 0; 0, 1], [2, 1; [2, 1]~, 1]]
  ? nffactorback(nf, %[2])
  %7 = [4, 2]~
</pre></p>
<p>
The extended ideal returned in <code>%6</code> is the trivial ideal 1, extended
with a principal generator given in factored form. We use <code>nffactorback</code>
to recover it in standard form.</p>
<p>
The library syntax is <code>GEN <b>idealfactorback</b>(GEN nf, GEN f, GEN e = NULL, long flag )</code>.</p>

<hr></hr>
<a name="idealfrobenius"></a>
<h4>idealfrobenius(<em>nf</em>,<em>gal</em>,<em>pr</em>)</h4>
<p></p>
<p>Let K be the number field defined by nf and assume K/<b>Q</b> be a
Galois extension with Galois group given <code>gal = galoisinit(nf)</code>,
and that pr is the prime ideal <b>P</b> in prid format, and that
<b>P</b> is unramified.
This function returns a permutation of <code>gal.group</code> which defines the
automorphism <font color=#FF0000>sigma</font> = (<b>P</b>\over K/<b>Q</b> ), i.e the Frobenius
element associated to <b>P</b>. If p is the unique prime number
in <b>P</b>, then <font color=#FF0000>sigma</font>(x) = x^p mod \P for all x belongs to <b>Z</b>_K.</p>
<p>
<pre class="code">  ? nf = nfinit(polcyclo(31));
  ? gal = galoisinit(nf);
  ? pr = idealprimedec(nf,101)[1];
  ? g = idealfrobenius(nf,gal,pr);
  ? galoispermtopol(gal,g)
  %5 = x^8
</pre>
This is correct since 101 = 8 mod 31.</p>
<p>
The library syntax is <code>GEN <b>idealfrobenius</b>(GEN nf, GEN gal, GEN pr)</code>.</p>

<hr></hr>
<a name="idealhnf"></a>
<h4>idealhnf(<em>nf</em>,u,{v})</h4>
<p></p>
<p>Gives the Hermite normal form of the ideal u<b>Z</b>_K+v<b>Z</b>_K, where u
and v are elements of the number field K defined by <code>nf</code>.</p>
<p>
<pre class="code">  ? nf = nfinit(y^3 - 2);
  ? idealhnf(nf, 2, y+1)
  %2 =
  [1 0 0]
  
  [0 1 0]
  
  [0 0 1]
  ? idealhnf(nf, y/2, [0,0,1/3]~)
  %3 =
  [1/3 0 0]
  
  [0 1/6 0]
  
  [0 0 1/6]
</pre></p>
<p></p>
<p>
If b is omitted, returns the HNF of the ideal defined by u: u may be an
algebraic number (defining a principal ideal), a maximal ideal (as given by
<code>idealprimedec</code> or <code>idealfactor</code>), or a matrix whose columns give
generators for the ideal. This last format is a little complicated, but
useful to reduce general modules to the canonical form once in a while:</p>
<p>
<b>*</b> if strictly less than N = [K:<b>Q</b>] generators are given, u
is the <b>Z</b>_K-module they generate,</p>
<p>
<b>*</b> if N or more are given, it is <em>assumed</em> that they form a
<b>Z</b>-basis of the ideal, in particular that the matrix has maximal rank N.
This acts as <code>mathnf</code> since the <b>Z</b>_K-module structure is (taken for
granted hence) not taken into account in this case.</p>
<p>
<pre class="code">  ? idealhnf(nf, idealprimedec(nf,2)[1])
  %4 =
  [2 0 0]
  
  [0 1 0]
  
  [0 0 1]
  ? idealhnf(nf, [1,2;2,3;3,4])
  %5 =
  [1 0 0]
  
  [0 1 0]
  
  [0 0 1]
</pre>
Finally, when K is quadratic with discriminant D_K, we
allow u =  <code>Qfb(a,b,c)</code>, provided b^2 - 4ac = D_K. As usual,
this represents the ideal a <b>Z</b> + (1/2)(-b + sqrt{D_K}) <b>Z</b>.</p>
<p>
<pre class="code">  ? K = nfinit(x^2 - 60); K.disc
  %1 = 60
  ? idealhnf(K, qfbprimeform(60,2))
  %2 =
  [2 1]
  
  [0 1]
  ? idealhnf(K, Qfb(1,2,3))
    ***   at top-level: idealhnf(K,Qfb(1,2,3
    ***                 ^--------------------
    *** idealhnf: Qfb(1, 2, 3) has discriminant != 60 in idealhnf.
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>idealhnf0</b>(GEN nf, GEN u, GEN v = NULL)</code>.
Also available is <code>GEN <b>idealhnf</b>(GEN nf, GEN a)</code>.</p>

<hr></hr>
<a name="idealintersect"></a>
<h4>idealintersect(<em>nf</em>,A,B)</h4>
<p></p>
<p>Intersection of the two ideals
A and B in the number field <em>nf</em>. The result is given in HNF.</p>
<p>
<pre class="code">  ? nf = nfinit(x^2+1);
  ? idealintersect(nf, 2, x+1)
  %2 =
  [2 0]
  
  [0 2]
</pre></p>
<p></p>
<p>
This function does not apply to general <b>Z</b>-modules, e.g.&nbsp;orders, since its
arguments are replaced by the ideals they generate. The following script
intersects <b>Z</b>-modules A and B given by matrices of compatible
dimensions with integer coefficients:</p>
<p>
<pre class="code">  ZM_intersect(A,B) =
  { my(Ker = matkerint(concat(A,B)));
    mathnf( A * Ker[1..#A,] )
  }
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>idealintersect</b>(GEN nf, GEN A, GEN B)</code>.</p>

<hr></hr>
<a name="idealinv"></a>
<h4>idealinv(<em>nf</em>,x)</h4>
<p></p>
<p>Inverse of the ideal x in the
number field <em>nf</em>, given in HNF. If x is an extended
ideal, its principal part is suitably
updated: i.e. inverting [I,t], yields [I^{-1}, 1/t].</p>
<p>
The library syntax is <code>GEN <b>idealinv</b>(GEN nf, GEN x)</code>.</p>

<hr></hr>
<a name="ideallist"></a>
<h4>ideallist(<em>nf</em>,<em>bound</em>,{<em>flag</em> = 4})</h4>
<p></p>
<p>Computes the list
of all ideals of norm less or equal to <em>bound</em> in the number field
<em>nf</em>. The result is a row vector with exactly <em>bound</em> components.
Each component is itself a row vector containing the information about
ideals of a given norm, in no specific order, depending on the value of
<em>flag</em>:</p>
<p>
The possible values of <em>flag</em> are:</p>
<p>
&nbsp;&nbsp;0: give the <em>bid</em> associated to the ideals, without generators.</p>
<p>
&nbsp;&nbsp;1: as 0, but include the generators in the <em>bid</em>.</p>
<p>
&nbsp;&nbsp;2: in this case, <em>nf</em> must be a <em>bnf</em> with units. Each
component is of the form [<em>bid</em>,U], where <em>bid</em> is as case 0
and U is a vector of discrete logarithms of the units. More precisely, it
gives the <code>ideallog</code>s with respect to <em>bid</em> of <code>bnf.tufu</code>.
This structure is technical, and only meant to be used in conjunction with
<code>bnrclassnolist</code> or <code>bnrdisclist</code>.</p>
<p>
&nbsp;&nbsp;3: as 2, but include the generators in the <em>bid</em>.</p>
<p>
&nbsp;&nbsp;4: give only the HNF of the ideal.</p>
<p></p>
<p>
<pre class="code">  ? nf = nfinit(x^2+1);
  ? L = ideallist(nf, 100);
  ? L[1]
  %3 = [[1, 0; 0, 1]]  \\  A single ideal of norm 1
  ? #L[65]
  %4 = 4               \\  There are 4 ideals of norm 4 in <b>Z</b>[i]
</pre></p>
<p>
If one wants more information, one could do instead:</p>
<p>
<pre class="code">  ? nf = nfinit(x^2+1);
  ? L = ideallist(nf, 100, 0);
  ? l = L[25]; vector(#l, i, l[i].clgp)
  %3 = [[20, [20]], [16, [4, 4]], [20, [20]]]
  ? l[1].mod
  %4 = [[25, 18; 0, 1], []]
  ? l[2].mod
  %5 = [[5, 0; 0, 5], []]
  ? l[3].mod
  %6 = [[25, 7; 0, 1], []]
</pre>
where we ask for the structures of the (<b>Z</b>[i]/I)^* for all
three ideals of norm 25. In fact, for all moduli with finite part of norm
25 and trivial Archimedean part, as the last 3 commands show. See
<code>ideallistarch</code> to treat general moduli.</p>
<p>
The library syntax is <code>GEN <b>ideallist0</b>(GEN nf, long bound, long flag)</code>.</p>

<hr></hr>
<a name="ideallistarch"></a>
<h4>ideallistarch(<em>nf</em>,<em>list</em>,<em>arch</em>)</h4>
<p></p>
<p><em>list</em> is a vector of vectors of bid's, as output by <code>ideallist</code> with
flag 0 to 3. Return a vector of vectors with the same number of
components as the original <em>list</em>. The leaves give information about
moduli whose finite part is as in original list, in the same order, and
Archimedean part is now <em>arch</em> (it was originally trivial). The
information contained is of the same kind as was present in the input; see
<code>ideallist</code>, in particular the meaning of <em>flag</em>.</p>
<p></p>
<p>
<pre class="code">  ? bnf = bnfinit(x^2-2);
  ? bnf.sign
  %2 = [2, 0]                         \\  two places at infinity
  ? L = ideallist(bnf, 100, 0);
  ? l = L[98]; vector(#l, i, l[i].clgp)
  %4 = [[42, [42]], [36, [6, 6]], [42, [42]]]
  ? La = ideallistarch(bnf, L, [1,1]); \\  add them to the modulus
  ? l = La[98]; vector(#l, i, l[i].clgp)
  %6 = [[168, [42, 2, 2]], [144, [6, 6, 2, 2]], [168, [42, 2, 2]]]
</pre></p>
<p>
Of course, the results above are obvious: adding t places at infinity will
add t copies of <b>Z</b>/2<b>Z</b> to the ray class group. The following application
is more typical:</p>
<p>
<pre class="code">  ? L = ideallist(bnf, 100, 2);        \\  units are required now
  ? La = ideallistarch(bnf, L, [1,1]);
  ? H = bnrclassnolist(bnf, La);
  ? H[98];
  %6 = [2, 12, 2]
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>ideallistarch</b>(GEN nf, GEN list, GEN arch)</code>.</p>

<hr></hr>
<a name="ideallog"></a>
<h4>ideallog(<em>nf</em>,x,<em>bid</em>)</h4>
<p></p>
<p><em>nf</em> is a number field,
<em>bid</em> is as output by <code>idealstar(nf, D,...)</code> and x a
non-necessarily integral element of <em>nf</em> which must have valuation
equal to 0 at all prime ideals in the support of <code>D</code>. This function
computes the discrete logarithm of x on the generators given in
<code><em>bid</em>.gen</code>. In other words, if g_i are these generators, of orders
d_i respectively, the result is a column vector of integers (x_i) such
that 0 <code>&#60;=</code> x_i &#60; d_i and
x = <font color=#FF0000>prod</font>_i g_i^{x_i} (mod ^*D) .
Note that when the support of <code>D</code> contains places at infinity, this
congruence implies also sign conditions on the associated real embeddings.
See <code>znlog</code> for the limitations of the underlying discrete log algorithms.</p>
<p>
The library syntax is <code>GEN <b>ideallog</b>(GEN nf, GEN x, GEN bid)</code>.</p>

<hr></hr>
<a name="idealmin"></a>
<h4>idealmin(<em>nf</em>,<em>ix</em>,{<em>vdir</em>})</h4>
<p></p>
<p><em>This function is useless and kept for backward compatibility only,
use <code>idealred</code></em>. Computes a pseudo-minimum of the ideal x in the
direction <em>vdir</em> in the number field <em>nf</em>.</p>
<p>
The library syntax is <code>GEN <b>idealmin</b>(GEN nf, GEN ix, GEN vdir = NULL)</code>.</p>

<hr></hr>
<a name="idealmul"></a>
<h4>idealmul(<em>nf</em>,x,y,{<em>flag</em> = 0})</h4>
<p></p>
<p>Ideal multiplication of the ideals x and y in the number field
<em>nf</em>; the result is the ideal product in HNF. If either x or y
are extended ideals, their principal part is suitably
updated: i.e. multiplying [I,t], [J,u] yields [IJ, tu]; multiplying
I and [J, u] yields [IJ, u].</p>
<p>
<pre class="code">  ? nf = nfinit(x^2 + 1);
  ? idealmul(nf, 2, x+1)
  %2 =
  [4 2]
  
  [0 2]
  ? idealmul(nf, [2, x], x+1)        \\ extended ideal * ideal
  %4 = [[4, 2; 0, 2], x]
  ? idealmul(nf, [2, x], [x+1, x])   \\ two extended ideals
  %5 = [[4, 2; 0, 2], [-1, 0]~]
</pre></p>
<p>
If <em>flag</em> is non-zero, reduce the result using <code>idealred</code>.</p>
<p>
The library syntax is <code>GEN <b>idealmul0</b>(GEN nf, GEN x, GEN y, long flag)</code>.</p>
<p>
See also
<code>GEN <b>idealmul</b>(GEN nf, GEN x, GEN y)</code> (<em>flag</em> = 0) and
<code>GEN <b>idealmulred</b>(GEN nf, GEN x, GEN y)</code> (<em>flag</em> != 0).</p>

<hr></hr>
<a name="idealnorm"></a>
<h4>idealnorm(<em>nf</em>,x)</h4>
<p></p>
<p>Computes the norm of the ideal&nbsp;x in the number field&nbsp;<em>nf</em>.</p>
<p>
The library syntax is <code>GEN <b>idealnorm</b>(GEN nf, GEN x)</code>.</p>

<hr></hr>
<a name="idealnumden"></a>
<h4>idealnumden(<em>nf</em>,x)</h4>
<p></p>
<p>Returns [A,B], where A,B are coprime integer ideals
such that x = A/B, in the number field <em>nf</em>.</p>
<p>
<pre class="code">  ? nf = nfinit(x^2+1);
  ? idealnumden(nf, (x+1)/2)
  %2 = [[1, 0; 0, 1], [2, 1; 0, 1]]
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>idealnumden</b>(GEN nf, GEN x)</code>.</p>

<hr></hr>
<a name="idealpow"></a>
<h4>idealpow(<em>nf</em>,x,k,{<em>flag</em> = 0})</h4>
<p></p>
<p>Computes the k-th power of
the ideal x in the number field <em>nf</em>; k belongs to <b>Z</b>.
If x is an extended
ideal, its principal part is suitably
updated: i.e. raising [I,t] to the k-th power, yields [I^k, t^k].</p>
<p>
If <em>flag</em> is non-zero, reduce the result using <code>idealred</code>, <em>throughout
the (binary) powering process</em>; in particular, this is <em>not</em> the same as
as <code>idealpow</code>(<em>nf</em>,x,k) followed by reduction.</p>
<p>
The library syntax is <code>GEN <b>idealpow0</b>(GEN nf, GEN x, GEN k, long flag)</code>.</p>
<p>
See also
<code>GEN <b>idealpow</b>(GEN nf, GEN x, GEN k)</code> and
<code>GEN <b>idealpows</b>(GEN nf, GEN x, long k)</code> (<em>flag</em> = 0).
Corresponding to <em>flag</em> = 1 is <code>GEN <b>idealpowred</b>(GEN nf, GEN vp, GEN k)</code>.</p>

<hr></hr>
<a name="idealprimedec"></a>
<h4>idealprimedec(<em>nf</em>,p)</h4>
<p></p>
<p>Computes the prime ideal
decomposition of the (positive) prime number p in the number field K
represented by <em>nf</em>. If a non-prime p is given the result is undefined.</p>
<p>
The result is a vector of <em>prid</em> structures, each representing one of the
prime ideals above p in the number field <em>nf</em>. The representation
<code>pr</code> = [p,a,e,f,<em>mb</em>] of a prime ideal means the following: a and
is an algebraic integer in the maximal order <b>Z</b>_K and the prime ideal is
equal to <b>p</b> = p<b>Z</b>_K + a<b>Z</b>_K;
e is the ramification index; f is the residual index;
finally, <em>mb</em> is the multiplication table associated to the algebraic
integer b is such that <b>p</b>^{-1} = <b>Z</b>_K+ b/ p<b>Z</b>_K, which is used
internally to compute valuations. In other words if p is inert,
then <em>mb</em> is the integer 1, and otherwise it's a square <code>t_MAT</code>
whose j-th column is b.<code>nf.zk[j]</code>.</p>
<p>
The algebraic number a is guaranteed to have a
valuation equal to 1 at the prime ideal (this is automatic if e &#62; 1).</p>
<p>
The components of <code>pr</code> should be accessed by member functions: <code>pr.p</code>,
<code>pr.e</code>, <code>pr.f</code>, and <code>pr.gen</code> (returns the vector [p,a]):</p>
<p>
<pre class="code">  ? K = nfinit(x^3-2);
  ? L = idealprimedec(K, 5);
  ? #L       \\ 2 primes above 5 in Q(2^(1/3))
  %3 = 2
  ? p1 = L[1]; p2 = L[2];
  ? [p1.e, p1.f]    \\ the first is unramified of degree 1
  %4 = [1, 1]
  ? [p2.e, p2.f]    \\ the second is unramified of degree 2
  %5 = [1, 2]
  ? p1.gen
  %6 = [5, [2, 1, 0]~]
  ? nfbasistoalg(K, %[2])  \\ a uniformizer for p1
  %7 = Mod(x + 2, x^3 - 2)
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>idealprimedec</b>(GEN nf, GEN p)</code>.</p>

<hr></hr>
<a name="idealprincipalunits"></a>
<h4>idealprincipalunits(<em>nf</em>,<em>pr</em>,k)</h4>
<p></p>
<p>Given a prime ideal in <code>idealprimedec</code> format,
returns the multiplicative group (1 + <em>pr</em>) / (1 + <em>pr</em>^k) as an
abelian group. This function is much faster than <code>idealstar</code> when the
norm of <em>pr</em> is large, since it avoids (useless) work in the
multiplicative group of the residue field.</p>
<p>
<pre class="code">  ? K = nfinit(y^2+1);
  ? P = idealprimedec(K,2)[1];
  ? G = idealprincipalunits(K, P, 20);
  ? G.cyc
  [512, 256, 4]   \\ Z/512 x Z/256 x Z/4
  ? G.gen
  %5 = [[-1, -2]~, 1021, [0, -1]~] \\ minimal generators of given order
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>idealprincipalunits</b>(GEN nf, GEN pr, long k)</code>.</p>

<hr></hr>
<a name="idealramgroups"></a>
<h4>idealramgroups(<em>nf</em>,<em>gal</em>,<em>pr</em>)</h4>
<p></p>
<p>Let K be the number field defined by <em>nf</em> and assume that K/<b>Q</b> is
Galois with Galois group G given by <code>gal = galoisinit(nf)</code>.
Let <em>pr</em> be the prime ideal <b>P</b> in prid format.
This function returns a vector g of subgroups of <code>gal</code>
as follow:</p>
<p>
<b>*</b> <code>g[1]</code> is the decomposition group of <b>P</b>,</p>
<p>
<b>*</b> <code>g[2]</code> is G_0(<b>P</b>), the inertia group of <b>P</b>,</p>
<p>
and for i <code>&#62;=</code> 2,</p>
<p>
<b>*</b> <code>g[i]</code> is G_{i-2}(<b>P</b>), the i-2-th \idx{ramification
group} of <b>P</b>.</p>
<p>
The length of g is the number of non-trivial groups in the
sequence, thus is 0 if e = 1 and f = 1, and 1 if f &#62; 1 and e = 1.
The following function computes the cardinality of a subgroup of G,
as given by the components of g:</p>
<p>
<pre class="code">  card(H) =my(o=H[2]); prod(i=1,#o,o[i]);
</pre></p>
<p></p>
<p>
<pre class="code">  ? nf=nfinit(x^6+3); gal=galoisinit(nf); pr=idealprimedec(nf,3)[1];
  ? g = idealramgroups(nf, gal, pr);
  ? apply(card,g)
  %4 = [6, 6, 3, 3, 3] \\ cardinalities of the G_i
</pre></p>
<p></p>
<p></p>
<p>
<pre class="code">  ? nf=nfinit(x^6+108); gal=galoisinit(nf); pr=idealprimedec(nf,2)[1];
  ? iso=idealramgroups(nf,gal,pr)[2]
  %4 = [[Vecsmall([2, 3, 1, 5, 6, 4])], Vecsmall([3])]
  ? nfdisc(galoisfixedfield(gal,iso,1))
  %5 = -3
</pre>
The field fixed by the inertia group of 2 is not ramified at
2.</p>
<p>
The library syntax is <code>GEN <b>idealramgroups</b>(GEN nf, GEN gal, GEN pr)</code>.</p>

<hr></hr>
<a name="idealred"></a>
<h4>idealred(<em>nf</em>,I,{v = 0})</h4>
<p></p>
<p>LLL reduction of
the ideal I in the number field <em>nf</em>, along the direction v.
The v parameter is best left omitted, but if it is present, it must
be an <code>nf.r1</code> + <code>nf.r2</code>-component vector of <em>non-negative</em>
integers. (What counts is the relative magnitude of the entries: if all
entries are equal, the effect is the same as if the vector had been omitted.)</p>
<p>
This function finds a "small" a in I (see the end for technical details).
The result is the Hermite normal form of
the "reduced" ideal J = r I/a, where r is the unique rational number such
that J is integral and primitive. (This is usually not a reduced ideal in
the sense of Buchmann.)</p>
<p>
<pre class="code">  ? K = nfinit(y^2+1);
  ? P = idealprimedec(K,5)[1];
  ? idealred(K, P)
  %3 =
  [1 0]
  
  [0 1]
</pre>
More often than not, a principal ideal yields the unit
ideal as above. This is a quick and dirty way to check if ideals are principal,
but it is not a necessary condition: a non-trivial result does not prove that
the ideal is non-principal. For guaranteed results, see <code>bnfisprincipal</code>,
which requires the computation of a full <code>bnf</code> structure.</p>
<p>
If the input is an extended ideal [I,s], the output is [J,sa/r]; this way,
one can keep track of the principal ideal part:</p>
<p>
<pre class="code">  ? idealred(K, [P, 1])
  %5 = [[1, 0; 0, 1], [-2, 1]~]
</pre></p>
<p>
meaning that P is generated by [-2, 1]&nbsp;. The number field element in the
extended part is an algebraic number in any form <em>or</em> a factorization
matrix (in terms of number field elements, not ideals!). In the latter case,
elements stay in factored form, which is a convenient way to avoid
coefficient explosion; see also <code>idealpow</code>.</p>
<p>
<b>Technical note.</b> The routine computes an LLL-reduced
basis for the lattice I equipped with the quadratic form
|| x ||_v^2 = <font color=#FF0000>sum</font>_{i = 1}^{r_1+r_2} 2^{v_i}<font color=#FF0000>varepsilon</font>_i|<font color=#FF0000>sigma</font>_i(x)|^2,
where as usual the <font color=#FF0000>sigma</font>_i are the (real and) complex embeddings and
<font color=#FF0000>varepsilon</font>_i = 1, resp.&nbsp;2, for a real, resp.&nbsp;complex place. The element
a is simply the first vector in the LLL basis. The only reason you may want
to try to change some directions and set some v_i != 0 is to randomize
the elements found for a fixed ideal, which is heuristically useful in index
calculus algorithms like <code>bnfinit</code> and <code>bnfisprincipal</code>.</p>
<p>
<b>Even more technical note.</b> In fact, the above is a white lie.
We do not use ||.||_v exactly but a rescaled rounded variant which
gets us faster and simpler LLLs. There's no harm since we are not using any
theoretical property of a after all, except that it belongs to I and is
"expected to be small".</p>
<p>
The library syntax is <code>GEN <b>idealred0</b>(GEN nf, GEN I, GEN v = NULL)</code>.</p>

<hr></hr>
<a name="idealstar"></a>
<h4>idealstar(<em>nf</em>,I,{<em>flag</em> = 1})</h4>
<p></p>
<p>Outputs a <em>bid</em> structure,
necessary for computing in the finite abelian group G = (<b>Z</b>_K/I)^*. Here,
<em>nf</em> is a number field and I is a <em>modulus</em>: either an ideal in any
form, or a row vector whose first component is an ideal and whose second
component is a row vector of r_1 0 or 1. Ideals can also be given
by a factorization into prime ideals, as produced by <code>idealfactor</code>.</p>
<p>
This <em>bid</em> is used in <code>ideallog</code> to compute discrete logarithms. It
also contains useful information which can be conveniently retrieved as
<code><em>bid</em>.mod</code> (the modulus),
<code><em>bid</em>.clgp</code> (G as a finite abelian group),
<code><em>bid</em>.no</code> (the cardinality of G),
<code><em>bid</em>.cyc</code> (elementary divisors) and
<code><em>bid</em>.gen</code> (generators).</p>
<p>
If <em>flag</em> = 1 (default), the result is a <em>bid</em> structure without
generators.</p>
<p>
If <em>flag</em> = 2, as <em>flag</em> = 1, but including generators, which wastes some time.</p>
<p>
If <em>flag</em> = 0, only outputs (<b>Z</b>_K/I)^* as an abelian group,
i.e as a 3-component vector [h,d,g]: h is the order, d is the vector of
SNF cyclic components and g the corresponding
generators.</p>
<p>
The library syntax is <code>GEN <b>idealstar0</b>(GEN nf, GEN I, long flag)</code>.
Instead the above hardcoded numerical flags, one should rather use
<code>GEN <b>Idealstar</b>(GEN nf, GEN ideal, long flag)</code>, where <code>flag</code> is
an or-ed combination of <code>nf_GEN</code> (include generators) and <code>nf_INIT</code>
(return a full <code>bid</code>, not a group), possibly 0. This offers
one more combination: gen, but no init.</p>

<hr></hr>
<a name="idealtwoelt"></a>
<h4>idealtwoelt(<em>nf</em>,x,{a})</h4>
<p></p>
<p>Computes a two-element
representation of the ideal x in the number field <em>nf</em>, combining a
random search and an approximation theorem; x is an ideal
in any form (possibly an extended ideal, whose principal part is ignored)</p>
<p>
<b>*</b> When called as <code>idealtwoelt(nf,x)</code>, the result is a row vector
[a,<font color=#FF0000>alpha</font>] with two components such that x = a<b>Z</b>_K+<font color=#FF0000>alpha</font><b>Z</b>_K and a is
chosen to be the positive generator of xcap<b>Z</b>, unless x was given as a
principal ideal (in which case we may choose a = 0). The algorithm
uses a fast lazy factorization of xcap <b>Z</b> and runs in randomized
polynomial time.</p>
<p>
<b>*</b> When called as <code>idealtwoelt(nf,x,a)</code> with an explicit non-zero a
supplied as third argument, the function assumes that a belongs to x and returns
<font color=#FF0000>alpha</font> belongs to x such that x = a<b>Z</b>_K + <font color=#FF0000>alpha</font><b>Z</b>_K. Note that we must factor
a in this case, and the algorithm is generally much slower than the
default variant.</p>
<p>
The library syntax is <code>GEN <b>idealtwoelt0</b>(GEN nf, GEN x, GEN a = NULL)</code>.
Also available are
<code>GEN <b>idealtwoelt</b>(GEN nf, GEN x)</code> and
<code>GEN <b>idealtwoelt2</b>(GEN nf, GEN x, GEN a)</code>.</p>

<hr></hr>
<a name="idealval"></a>
<h4>idealval(<em>nf</em>,x,<em>pr</em>)</h4>
<p></p>
<p>Gives the valuation of the ideal x at the prime ideal <em>pr</em> in the
number field <em>nf</em>, where <em>pr</em> is in <code>idealprimedec</code> format.</p>
<p>
The library syntax is <code>long <b>idealval</b>(GEN nf, GEN x, GEN pr)</code>.</p>

<hr></hr>
<a name="matalgtobasis"></a>
<h4>matalgtobasis(<em>nf</em>,x)</h4>
<p></p>
<p><em>nf</em> being a number field in <code>nfinit</code> format, and x a
(row or column) vector or matrix, apply <code>nfalgtobasis</code> to each entry
of x.</p>
<p>
The library syntax is <code>GEN <b>matalgtobasis</b>(GEN nf, GEN x)</code>.</p>

<hr></hr>
<a name="matbasistoalg"></a>
<h4>matbasistoalg(<em>nf</em>,x)</h4>
<p></p>
<p><em>nf</em> being a number field in <code>nfinit</code> format, and x a
(row or column) vector or matrix, apply <code>nfbasistoalg</code> to each entry
of x.</p>
<p>
The library syntax is <code>GEN <b>matbasistoalg</b>(GEN nf, GEN x)</code>.</p>

<hr></hr>
<a name="modreverse"></a>
<h4>modreverse(z)</h4>
<p></p>
<p>Let z = <code>Mod(A, T)</code> be a polmod, and Q be its minimal
polynomial, which must satisfy {deg}(Q) = {deg}(T).
Returns a "reverse polmod" <code>Mod(B, Q)</code>, which is a root of T.</p>
<p>
This is quite useful when one changes the generating element in algebraic
extensions:</p>
<p>
<pre class="code">  ? u = Mod(x, x^3 - x -1); v = u^5;
  ? w = modreverse(v)
  %2 = Mod(x^2 - 4*x + 1, x^3 - 5*x^2 + 4*x - 1)
</pre></p>
<p>
which means that x^3 - 5x^2 + 4x -1 is another defining polynomial for the
cubic field
<b>Q</b>(u) = <b>Q</b>[x]/(x^3 - x - 1) = <b>Q</b>[x]/(x^3 - 5x^2 + 4x - 1) = <b>Q</b>(v),
and that u \to v^2 - 4v + 1 gives an explicit isomorphism. From this, it is
easy to convert elements between the A(u) belongs to <b>Q</b>(u) and B(v) belongs to <b>Q</b>(v)
representations:</p>
<p>
<pre class="code">  ? A = u^2 + 2*u + 3; subst(lift(A), 'x, w)
  %3 = Mod(x^2 - 3*x + 3, x^3 - 5*x^2 + 4*x - 1)
  ? B = v^2 + v + 1;   subst(lift(B), 'x, v)
  %4 = Mod(26*x^2 + 31*x + 26, x^3 - x - 1)
</pre></p>
<p>
If the minimal polynomial of z has lower degree than expected, the routine
fails</p>
<p>
<pre class="code">  ? u = Mod(-x^3 + 9*x, x^4 - 10*x^2 + 1)
  ? modreverse(u)
   *** modreverse: domain error in modreverse: deg(minpoly(z)) &#60; 4
   ***   Break loop: type 'break' to go back to GP prompt
  break&#62; Vec( dbg_err() ) \\ ask for more info
  ["e_DOMAIN", "modreverse", "deg(minpoly(z))", "&#60;", 4,
    Mod(-x^3 + 9*x, x^4 - 10*x^2 + 1)]
  break&#62; minpoly(u)
  x^2 - 8
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>modreverse</b>(GEN z)</code>.</p>

<hr></hr>
<a name="newtonpoly"></a>
<h4>newtonpoly(x,p)</h4>
<p></p>
<p>Gives the vector of the slopes of the Newton
polygon of the polynomial x with respect to the prime number p. The n
components of the vector are in decreasing order, where n is equal to the
degree of x. Vertical slopes occur iff the constant coefficient of x is
zero and are denoted by <code>LONG_MAX</code>, the biggest single precision
integer representable on the machine (2^{31}-1 (resp.&nbsp;2^{63}-1) on 32-bit
(resp.&nbsp;64-bit) machines), see Section [<b>Label: se:valuation</b>].</p>
<p>
The library syntax is <code>GEN <b>newtonpoly</b>(GEN x, GEN p)</code>.</p>

<hr></hr>
<a name="nfalgtobasis"></a>
<h4>nfalgtobasis(<em>nf</em>,x)</h4>
<p></p>
<p>Given an algebraic number x in the number field <em>nf</em>,
transforms it to a column vector on the integral basis <code><em>nf</em>.zk</code>.</p>
<p>
<pre class="code">  ? nf = nfinit(y^2 + 4);
  ? nf.zk
  %2 = [1, 1/2*y]
  ? nfalgtobasis(nf, [1,1]~)
  %3 = [1, 1]~
  ? nfalgtobasis(nf, y)
  %4 = [0, 2]~
  ? nfalgtobasis(nf, Mod(y, y^2+4))
  %4 = [0, 2]~
</pre></p>
<p>
This is the inverse function of <code>nfbasistoalg</code>.</p>
<p>
The library syntax is <code>GEN <b>algtobasis</b>(GEN nf, GEN x)</code>.</p>

<hr></hr>
<a name="nfbasis"></a>
<h4>nfbasis(T)</h4>
<p></p>
<p>Let T(X) be an irreducible polynomial with integral coefficients. This
function returns an integral basis of the number field defined by T,
that is a <b>Z</b>-basis of its maximal order. The basis elements are given as
elements in <b>Q</b>[X]/(T):</p>
<p>
<pre class="code">  ? nfbasis(x^2 + 1)
  %1 = [1, x]
</pre></p>
<p>
This function uses a modified version of the round 4 algorithm,
due to David Ford, Sebastian Pauli and Xavier Roblot.</p>
<p>
<b>Local basis, orders maximal at certain primes.</b></p>
<p>
Obtaining the maximal order is hard: it requires factoring the discriminant
D of T. Obtaining an order which is maximal at a finite explicit set of
primes is easy, but if may then be a strict suborder of the maximal order. To
specify that we are interested in a given set of places only, we can replace
the argument T by an argument [T,<em>listP</em>], where <em>listP</em> encodes
the primes we are interested in: it must be a factorization matrix, a vector
of integers or a single integer.</p>
<p>
<b>*</b> Vector: we assume that it contains distinct <em>prime</em> numbers.</p>
<p>
<b>*</b> Matrix: we assume that it is a two-column matrix of a
(partial) factorization of D; namely the first column contains
<em>primes</em> and the second one the valuation of D at each of these
primes.</p>
<p>
<b>*</b> Integer B: this is replaced by the vector of primes up to B. Note
that the function will use at least O(B) time: a small value, about
10^5, should be enough for most applications. Values larger than 2^{32}
are not supported.</p>
<p>
In all these cases, the primes may or may not divide the discriminant D
of T. The function then returns a <b>Z</b>-basis of an order whose index is
not divisible by any of these prime numbers. The result is actually a global
integral basis if all prime divisors of the <em>field</em> discriminant are
included! Note that <code>nfinit</code> has built-in support for such
a check:</p>
<p>
<pre class="code">  ? K = nfinit([T, listP]);
  ? nfcertify(K)   \\ we computed an actual maximal order
  %2 = [];
</pre>
The first line initializes a number field structure
incorporating <code>nfbasis([T, listP]</code> in place of a proven integral basis.
The second line certifies that the resulting structure is correct. This
allows to create an <code>nf</code> structure associated to the number field K = 
<b>Q</b>[X]/(T), when the discriminant of T cannot be factored completely,
whereas the prime divisors of disc K are known.</p>
<p>
Of course, if <em>listP</em> contains a single prime number p,
the function returns a local integral basis for <b>Z</b>_p[X]/(T):</p>
<p>
<pre class="code">  ? nfbasis(x^2+x-1001)
  %1 = [1, 1/3*x - 1/3]
  ? nfbasis( [x^2+x-1001, [2]] )
  %2 = [1, x]
</pre></p>
<p></p>
<p>
<b>The Buchmann-Lenstra algorithm.</b></p>
<p>
We now complicate the picture: it is in fact allowed to include
<em>composite</em> numbers instead of primes
in <code>listP</code> (Vector or Matrix case), provided they are pairwise coprime.
The result will still be a correct integral basis <em>if</em>
the field discriminant factors completely over the actual primes in the list.
Adding a composite C such that C^2 <em>divides</em> D may help because
when we consider C as a prime and run the algorithm, two good things can
happen: either we
succed in proving that no prime dividing C can divide the index
(without actually needing to find those primes), or the computation
exhibits a non-trivial zero divisor, thereby factoring C and
we go on with the refined factorization. (Note that including a C
such that C^2 does not divide D is useless.) If neither happen, then the
computed basis need not generate the maximal order. Here is an example:</p>
<p>
<pre class="code">  ? B = 10^5;
  ? P = factor(poldisc(T), B)[,1]; \\ primes &#60;= B dividing D + cofactor
  ? basis = nfbasis([T, listP])
  ? disc = nfdisc([T, listP])
</pre>
We obtain the maximal order and its discriminant if the
field discriminant factors
completely over the primes less than B (together with the primes
contained in the <code>addprimes</code> table). This can be tested as follows:</p>
<p>
<pre class="code">    check = factor(disc, B);
    lastp = check[-1..-1,1];
    if (lastp &#62; B &amp;&amp; !setsearch(addprimes(), lastp),
      warning("nf may be incorrect!"))
</pre></p>
<p>
This is a sufficient but not a necessary condition, hence the warning,
instead of an error. N.B. <code>lastp</code> is the last entry
in the first column of the <code>check</code> matrix, i.e. the largest prime
dividing <code>nf.disc</code> if  <code>&#60;=</code> B or if it belongs to the prime table.</p>
<p>
The function <code>nfcertify</code> speeds up and automates the above process:</p>
<p>
<pre class="code">  ? B = 10^5;
  ? nf = nfinit([T, B]);
  ? nfcertify(nf)
  %3 = []      \\ nf is unconditionally correct
  ? basis = nf.zk;
  ? disc = nf.disc;
</pre></p>
<p></p>
<p>
The library syntax is <code><b>nfbasis</b>(GEN T, GEN *d, GEN listP = NULL)</code>, which returns the order
basis, and where <code>*d</code> receives the order discriminant.</p>

<hr></hr>
<a name="nfbasistoalg"></a>
<h4>nfbasistoalg(<em>nf</em>,x)</h4>
<p></p>
<p>Given an algebraic number x in the number field <code>nf</code>, transforms it
into <code>t_POLMOD</code> form.</p>
<p>
<pre class="code">  ? nf = nfinit(y^2 + 4);
  ? nf.zk
  %2 = [1, 1/2*y]
  ? nfbasistoalg(nf, [1,1]~)
  %3 = Mod(1/2*y + 1, y^2 + 4)
  ? nfbasistoalg(nf, y)
  %4 = Mod(y, y^2 + 4)
  ? nfbasistoalg(nf, Mod(y, y^2+4))
  %4 = Mod(y, y^2 + 4)
</pre></p>
<p>
This is the inverse function of <code>nfalgtobasis</code>.</p>
<p>
The library syntax is <code>GEN <b>basistoalg</b>(GEN nf, GEN x)</code>.</p>

<hr></hr>
<a name="nfcertify"></a>
<h4>nfcertify(<em>nf</em>)</h4>
<p></p>
<p><em>nf</em> being as output by
<code>nfinit</code>, checks whether the integer basis is known unconditionally.
This is in particular useful when the argument to <code>nfinit</code> was of the
form [T, <code>listP</code>], specifying a finite list of primes when
p-maximality had to be proven.</p>
<p>
The function returns a vector of composite integers. If this vector is
empty, then <code>nf.zk</code> and <code>nf.disc</code> are correct. Otherwise, the
result is dubious. In order to obtain a certified result, one must
completely factor each of the given integers, then <code>addprime</code> each of
them, then check whether <code>nfdisc(nf.pol)</code> is equal to <code>nf.disc</code>.</p>
<p>
The library syntax is <code>GEN <b>nfcertify</b>(GEN nf)</code>.</p>

<hr></hr>
<a name="nfdetint"></a>
<h4>nfdetint(<em>nf</em>,x)</h4>
<p></p>
<p>Given a pseudo-matrix x, computes a
non-zero ideal contained in (i.e.&nbsp;multiple of) the determinant of x. This
is particularly useful in conjunction with <code>nfhnfmod</code>.</p>
<p>
The library syntax is <code>GEN <b>nfdetint</b>(GEN nf, GEN x)</code>.</p>

<hr></hr>
<a name="nfdisc"></a>
<h4>nfdisc(T)</h4>
<p></p>
<p>field discriminant of the number field defined by the integral,
preferably monic, irreducible polynomial T(X). Returns the discriminant of
the number field <b>Q</b>[X]/(T), using the Round 4 algorithm.</p>
<p>
<b>Local discriminants, valuations at certain primes.</b></p>
<p>
As in <code>nfbasis</code>, the argument T can be replaced by [T,<em>listP</em>],
where <code>listP</code> is as in <code>nfbasis</code>: a vector of
pairwise coprime integers (usually distinct primes), a factorization matrix,
or a single integer. In that case, the function returns the discriminant of
an order whose basis is given by <code>nfbasis(T,listP)</code>, which need not be
the maximal order, and whose valuation at a prime entry in <code>listP</code> is the
same as the valuation of the field discriminant.</p>
<p>
In particular, if <code>listP</code> is [p] for a prime p, we can
return the p-adic discriminant of the maximal order of <b>Z</b>_p[X]/(T),
as a power of p, as follows:</p>
<p>
<pre class="code">  ? padicdisc(T,p) = p^valuation(nfdisc(T,[p]), p);
  ? nfdisc(x^2 + 6)
  %1 = -24
  ? padicdisc(x^2 + 6, 2)
  %2 = 8
  ? padicdisc(x^2 + 6, 3)
  %3 = 3
</pre></p>
<p></p>
<p>
The library syntax is <code><b>nfdisc</b>(GEN T)</code> (<code>listP = NULL</code>). Also available is
<code>GEN <b>nfbasis</b>(GEN T, GEN *d, GEN listP = NULL)</code>, which returns the order
basis, and where <code>*d</code> receives the order discriminant.</p>

<hr></hr>
<a name="nfeltadd"></a>
<h4>nfeltadd(<em>nf</em>,x,y)</h4>
<p></p>
<p>Given two elements x and y in
<em>nf</em>, computes their sum x+y in the number field <em>nf</em>.</p>
<p>
The library syntax is <code>GEN <b>nfadd</b>(GEN nf, GEN x, GEN y)</code>.</p>

<hr></hr>
<a name="nfeltdiv"></a>
<h4>nfeltdiv(<em>nf</em>,x,y)</h4>
<p></p>
<p>Given two elements x and y in
<em>nf</em>, computes their quotient x/y in the number field <em>nf</em>.</p>
<p>
The library syntax is <code>GEN <b>nfdiv</b>(GEN nf, GEN x, GEN y)</code>.</p>

<hr></hr>
<a name="nfeltdiveuc"></a>
<h4>nfeltdiveuc(<em>nf</em>,x,y)</h4>
<p></p>
<p>Given two elements x and y in
<em>nf</em>, computes an algebraic integer q in the number field <em>nf</em>
such that the components of x-qy are reasonably small. In fact, this is
functionally identical to <code>round(nfdiv(<em>nf</em>,x,y))</code>.</p>
<p>
The library syntax is <code>GEN <b>nfdiveuc</b>(GEN nf, GEN x, GEN y)</code>.</p>

<hr></hr>
<a name="nfeltdivmodpr"></a>
<h4>nfeltdivmodpr(<em>nf</em>,x,y,<em>pr</em>)</h4>
<p></p>
<p>Given two elements x
and y in <em>nf</em> and <em>pr</em> a prime ideal in <code>modpr</code> format (see
<code>nfmodprinit</code>), computes their quotient x / y modulo the prime ideal
<em>pr</em>.</p>
<p>
The library syntax is <code>GEN <b>nfdivmodpr</b>(GEN nf, GEN x, GEN y, GEN pr)</code>.
This function is normally useless in library mode. Project your
inputs to the residue field using <code>nf_to_Fq</code>, then work there.</p>

<hr></hr>
<a name="nfeltdivrem"></a>
<h4>nfeltdivrem(<em>nf</em>,x,y)</h4>
<p></p>
<p>Given two elements x and y in
<em>nf</em>, gives a two-element row vector [q,r] such that x = qy+r, q is
an algebraic integer in <em>nf</em>, and the components of r are
reasonably small.</p>
<p>
The library syntax is <code>GEN <b>nfdivrem</b>(GEN nf, GEN x, GEN y)</code>.</p>

<hr></hr>
<a name="nfeltmod"></a>
<h4>nfeltmod(<em>nf</em>,x,y)</h4>
<p></p>
<p>Given two elements x and y in
<em>nf</em>, computes an element r of <em>nf</em> of the form r = x-qy with
q and algebraic integer, and such that r is small. This is functionally
identical to
<code>x - nfmul(<em>nf</em>,round(nfdiv(<em>nf</em>,x,y)),y)</code>.</p>
<p>
The library syntax is <code>GEN <b>nfmod</b>(GEN nf, GEN x, GEN y)</code>.</p>

<hr></hr>
<a name="nfeltmul"></a>
<h4>nfeltmul(<em>nf</em>,x,y)</h4>
<p></p>
<p>Given two elements x and y in
<em>nf</em>, computes their product x*y in the number field <em>nf</em>.</p>
<p>
The library syntax is <code>GEN <b>nfmul</b>(GEN nf, GEN x, GEN y)</code>.</p>

<hr></hr>
<a name="nfeltmulmodpr"></a>
<h4>nfeltmulmodpr(<em>nf</em>,x,y,<em>pr</em>)</h4>
<p></p>
<p>Given two elements x and
y in <em>nf</em> and <em>pr</em> a prime ideal in <code>modpr</code> format (see
<code>nfmodprinit</code>), computes their product x*y modulo the prime ideal
<em>pr</em>.</p>
<p>
The library syntax is <code>GEN <b>nfmulmodpr</b>(GEN nf, GEN x, GEN y, GEN pr)</code>.
This function is normally useless in library mode. Project your
inputs to the residue field using <code>nf_to_Fq</code>, then work there.</p>

<hr></hr>
<a name="nfeltnorm"></a>
<h4>nfeltnorm(<em>nf</em>,x)</h4>
<p></p>
<p>Returns the absolute norm of x.</p>
<p>
The library syntax is <code>GEN <b>nfnorm</b>(GEN nf, GEN x)</code>.</p>

<hr></hr>
<a name="nfeltpow"></a>
<h4>nfeltpow(<em>nf</em>,x,k)</h4>
<p></p>
<p>Given an element x in <em>nf</em>, and a positive or negative integer k,
computes x^k in the number field <em>nf</em>.</p>
<p>
The library syntax is <code>GEN <b>nfpow</b>(GEN nf, GEN x, GEN k)</code>.
<code>GEN <b>nfinv</b>(GEN nf, GEN x)</code> correspond to k = -1, and
<code>GEN <b>nfsqr</b>(GEN nf,GEN x)</code> to k = 2.</p>

<hr></hr>
<a name="nfeltpowmodpr"></a>
<h4>nfeltpowmodpr(<em>nf</em>,x,k,<em>pr</em>)</h4>
<p></p>
<p>Given an element x in <em>nf</em>, an integer k and a prime ideal
<em>pr</em> in <code>modpr</code> format
(see <code>nfmodprinit</code>), computes x^k modulo the prime ideal <em>pr</em>.</p>
<p>
The library syntax is <code>GEN <b>nfpowmodpr</b>(GEN nf, GEN x, GEN k, GEN pr)</code>.
This function is normally useless in library mode. Project your
inputs to the residue field using <code>nf_to_Fq</code>, then work there.</p>

<hr></hr>
<a name="nfeltreduce"></a>
<h4>nfeltreduce(<em>nf</em>,a,<em>id</em>)</h4>
<p></p>
<p>Given an ideal <em>id</em> in
Hermite normal form and an element a of the number field <em>nf</em>,
finds an element r in <em>nf</em> such that a-r belongs to the ideal
and r is small.</p>
<p>
The library syntax is <code>GEN <b>nfreduce</b>(GEN nf, GEN a, GEN id)</code>.</p>

<hr></hr>
<a name="nfeltreducemodpr"></a>
<h4>nfeltreducemodpr(<em>nf</em>,x,<em>pr</em>)</h4>
<p></p>
<p>Given an element x of the number field <em>nf</em> and a prime ideal
<em>pr</em> in <code>modpr</code> format compute a canonical representative for the
class of x modulo <em>pr</em>.</p>
<p>
The library syntax is <code>GEN <b>nfreducemodpr</b>(GEN nf, GEN x, GEN pr)</code>.
This function is normally useless in library mode. Project your
inputs to the residue field using <code>nf_to_Fq</code>, then work there.</p>

<hr></hr>
<a name="nfelttrace"></a>
<h4>nfelttrace(<em>nf</em>,x)</h4>
<p></p>
<p>Returns the absolute trace of x.</p>
<p>
The library syntax is <code>GEN <b>nftrace</b>(GEN nf, GEN x)</code>.</p>

<hr></hr>
<a name="nfeltval"></a>
<h4>nfeltval(<em>nf</em>,x,<em>pr</em>)</h4>
<p></p>
<p>Given an element x in
<em>nf</em> and a prime ideal <em>pr</em> in the format output by
<code>idealprimedec</code>, computes their the valuation at <em>pr</em> of the
element x. The same result could be obtained using
<code>idealval(<em>nf</em>,x,<em>pr</em>)</code> (since x would then be converted to a
principal ideal), but it would be less efficient.</p>
<p>
The library syntax is <code>long <b>nfval</b>(GEN nf, GEN x, GEN pr)</code>.</p>

<hr></hr>
<a name="nffactor"></a>
<h4>nffactor(<em>nf</em>,T)</h4>
<p></p>
<p>Factorization of the univariate
polynomial T over the number field <em>nf</em> given by <code>nfinit</code>; T
has coefficients in <em>nf</em> (i.e.&nbsp;either scalar, polmod, polynomial or
column vector). The factors are sorted by increasing degree.</p>
<p>
The main variable of <em>nf</em> must be of <em>lower</em>
priority than that of T, see Section [<b>Label: se:priority</b>]. However if
the polynomial defining the number field occurs explicitly  in the
coefficients of T as modulus of a <code>t_POLMOD</code> or as a <code>t_POL</code>
coefficient, its main variable must be <em>the same</em> as the main variable
of T. For example,</p>
<p>
<pre class="code">  ? nf = nfinit(y^2 + 1);
  ? nffactor(nf, x^2 + y); \\  OK
  ? nffactor(nf, x^2 + Mod(y, y^2+1)); \\   OK
  ? nffactor(nf, x^2 + Mod(z, z^2+1)); \\   WRONG
</pre></p>
<p></p>
<p>
It is possible to input a defining polynomial for <em>nf</em>
instead, but this is in general less efficient since parts of an <code>nf</code>
structure will then be computed internally. This is useful in two
situations: when you do not need the <code>nf</code> elsewhere, or when you cannot
compute the field discriminant due to integer factorization difficulties. In
the latter case, if you must use a partial discriminant factorization (as
allowed by both <code>nfdisc</code> or <code>nfbasis</code>) to build a partially correct
<em>nf</em> structure, always input <code>nf.pol</code> to <code>nffactor</code>, and not your
makeshift <em>nf</em>: otherwise factors could be missed.</p>
<p>
The library syntax is <code>GEN <b>nffactor</b>(GEN nf, GEN T)</code>.</p>

<hr></hr>
<a name="nffactorback"></a>
<h4>nffactorback(<em>nf</em>,f,{e})</h4>
<p></p>
<p>Gives back the <code>nf</code> element corresponding to a factorization.
The integer 1 corresponds to the empty factorization.</p>
<p>
If e is present, e and f must be vectors of the same length (e being
integral), and the corresponding factorization is the product of the
f[i]^{e[i]}.</p>
<p>
If not, and f is vector, it is understood as in the preceding case with e
a vector of 1s: we return the product of the f[i]. Finally, f can be a
regular factorization matrix.</p>
<p>
<pre class="code">  ? nf = nfinit(y^2+1);
  ? nffactorback(nf, [3, y+1, [1,2]~], [1, 2, 3])
  %2 = [12, -66]~
  ? 3 * (I+1)^2 * (1+2*I)^3
  %3 = 12 - 66*I
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>nffactorback</b>(GEN nf, GEN f, GEN e = NULL)</code>.</p>

<hr></hr>
<a name="nffactormod"></a>
<h4>nffactormod(<em>nf</em>,Q,<em>pr</em>)</h4>
<p></p>
<p>Factors the univariate polynomial Q modulo the prime ideal <em>pr</em> in
the number field <em>nf</em>. The coefficients of Q belong to the number
field (scalar, polmod, polynomial, even column vector) and the main variable
of <em>nf</em> must be of lower priority than that of Q (see
Section [<b>Label: se:priority</b>]). The prime ideal <em>pr</em> is either in
<code>idealprimedec</code> or (preferred) <code>modprinit</code> format. The coefficients
of the polynomial factors are lifted to elements of <em>nf</em>:</p>
<p>
<pre class="code">  ? K = nfinit(y^2+1);
  ? P = idealprimedec(K, 3)[1];
  ? nffactormod(K, x^2 + y*x + 18*y+1, P)
  %3 =
  [x + (2*y + 1) 1]
  
  [x + (2*y + 2) 1]
  ? P = nfmodprinit(K, P);  \\ convert to nfmodprinit format
  ? nffactormod(K, x^2 + y*x + 18*y+1)
  [x + (2*y + 1) 1]
  
  [x + (2*y + 2) 1]
</pre>
Same result, of course, here about 10% faster due to the
precomputation.</p>
<p>
The library syntax is <code>GEN <b>nffactormod</b>(GEN nf, GEN Q, GEN pr)</code>.</p>

<hr></hr>
<a name="nfgaloisapply"></a>
<h4>nfgaloisapply(<em>nf</em>,<em>aut</em>,x)</h4>
<p></p>
<p>Let <em>nf</em> be a
number field as output by <code>nfinit</code>, and let <em>aut</em> be a Galois
automorphism of <em>nf</em> expressed by its image on the field generator
(such automorphisms can be found using <code>nfgaloisconj</code>). The function
computes the action of the automorphism <em>aut</em> on the object x in the
number field; x can be a number field element, or an ideal (possibly
extended). Because of possible confusion with elements and ideals, other
vector or matrix arguments are forbidden.</p>
<p>
<pre class="code">   ? nf = nfinit(x^2+1);
   ? L = nfgaloisconj(nf)
   %2 = [-x, x]~
   ? aut = L[1]; /* the non-trivial automorphism */
   ? nfgaloisapply(nf, aut, x)
   %4 = Mod(-x, x^2 + 1)
   ? P = idealprimedec(nf,5); /* prime ideals above 5 */
   ? nfgaloisapply(nf, aut, P[2]) == P[1]
   %7 = 0 \\ !!!!
   ? idealval(nf, nfgaloisapply(nf, aut, P[2]), P[1])
   %8 = 1
</pre>
The surprising failure of the equality test (<code>%7</code>) is
due to the fact that although the corresponding prime ideals are equal, their
representations are not. (A prime ideal is specificed by a uniformizer, and
there is no guarantee that applying automorphisms yields the same elements
as a direct <code>idealprimedec</code> call.)</p>
<p>
The automorphism can also be given as a column vector, representing the
image of <code>Mod(x, nf.pol)</code> as an algebraic number. This last
representation is more efficient and should be preferred if a given
automorphism must be used in many such calls.</p>
<p>
<pre class="code">   ? nf = nfinit(x^3 - 37*x^2 + 74*x - 37);
   ? l = nfgaloisconj(nf); aut = l[2] \\   automorphisms in basistoalg form
   %2 = -31/11*x^2 + 1109/11*x - 925/11
   ? L = matalgtobasis(nf, l); AUT = L[2] \\   same in algtobasis form
   %3 = [16, -6, 5]~
   ? v = [1, 2, 3]~; nfgaloisapply(nf, aut, v) == nfgaloisapply(nf, AUT, v)
   %4 = 1 \\   same result...
   ? for (i=1,10^5, nfgaloisapply(nf, aut, v))
   time = 1,451 ms.
   ? for (i=1,10^5, nfgaloisapply(nf, AUT, v))
   time = 1,045 ms.  \\   but the latter is faster
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>galoisapply</b>(GEN nf, GEN aut, GEN x)</code>.</p>

<hr></hr>
<a name="nfgaloisconj"></a>
<h4>nfgaloisconj(<em>nf</em>,{<em>flag</em> = 0},{d})</h4>
<p></p>
<p><em>nf</em> being a number field as output by <code>nfinit</code>, computes the
conjugates of a root r of the non-constant polynomial x = <em>nf</em>[1]
expressed as polynomials in r. This also makes sense when the number field
is not Galois since some conjugates may lie in the field.
<em>nf</em> can simply be a polynomial.</p>
<p>
If no flags or <em>flag</em> = 0, use a combination of flag 4 and 1 and the result
is always complete. There is no point whatsoever in using the other flags.</p>
<p>
If <em>flag</em> = 1, use <code>nfroots</code>: a little slow, but guaranteed to work in
polynomial time.</p>
<p>
If <em>flag</em> = 2 (OBSOLETE), use complex approximations to the roots and an integral
LLL. The result is not guaranteed to be complete: some
conjugates may be missing (a warning is issued if the result is not proved
complete), especially so if the corresponding polynomial has a huge index,
and increasing the default precision may help. This variant is slow and
unreliable: don't use it.</p>
<p>
If <em>flag</em> = 4, use <code>galoisinit</code>: very fast, but only applies to (most) Galois
fields. If the field is Galois with weakly
super-solvable Galois group (see <code>galoisinit</code>), return the complete list
of automorphisms, else only the identity element. If present, d is assumed to
be a multiple of the least common denominator of the conjugates expressed as
polynomial in a root of <em>pol</em>.</p>
<p>
This routine can only compute <b>Q</b>-automorphisms, but it may be used to get
K-automorphism for any base field K as follows:</p>
<p>
<pre class="code">  rnfgaloisconj(nfK, R) = \\ K-automorphisms of L = K[X] / (R)
  { my(polabs, N);
    R *= Mod(1, nfK.pol);             \\ convert coeffs to polmod elts of K
    polabs = rnfequation(nfK, R);
    N = nfgaloisconj(polabs) % R;     \\ Q-automorphisms of L
    \\ select the ones that fix K
    select(s-&#62;subst(R, variable(R), Mod(s,R)) == 0, N);
  }
  K  = nfinit(y^2 + 7);
  rnfgaloisconj(K, x^4 - y*x^3 - 3*x^2 + y*x + 1)  \\ K-automorphisms of L
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>galoisconj0</b>(GEN nf, long flag, GEN d = NULL, long prec)</code>.
Use directly
<code>GEN <b>galoisconj</b>(GEN nf, GEN d)</code>, corresponding to <em>flag</em> = 0, the others
only have historical interest.</p>

<hr></hr>
<a name="nfhilbert"></a>
<h4>nfhilbert(<em>nf</em>,a,b,{<em>pr</em>})</h4>
<p></p>
<p>If <em>pr</em> is omitted,
compute the global quadratic Hilbert symbol (a,b) in <em>nf</em>, that
is 1 if x^2 - a y^2 - b z^2 has a non trivial solution (x,y,z) in
<em>nf</em>, and -1 otherwise. Otherwise compute the local symbol modulo
the prime ideal <em>pr</em>, as output by <code>idealprimedec</code>.</p>
<p>
The library syntax is <code>long <b>nfhilbert0</b>(GEN nf, GEN a, GEN b, GEN pr = NULL)</code>.</p>
<p>
Also available is <code>long <b>nfhilbert</b>(GEN bnf,GEN a,GEN b)</code> (global
quadratic Hilbert symbol).</p>

<hr></hr>
<a name="nfhnf"></a>
<h4>nfhnf(<em>nf</em>,x)</h4>
<p></p>
<p>Given a pseudo-matrix (A,I), finds a
pseudo-basis in Hermite normal form of the module it generates.</p>
<p>
The library syntax is <code>GEN <b>nfhnf</b>(GEN nf, GEN x)</code>.
Also available:</p>
<p>
<code>GEN <b>rnfsimplifybasis</b>(GEN bnf, GEN x)</code> simplifies the pseudo-basis
given by x = (A,I). The ideals in the list I are integral, primitive and
either trivial (equal to the full ring of integer) or non-principal.</p>

<hr></hr>
<a name="nfhnfmod"></a>
<h4>nfhnfmod(<em>nf</em>,x,<em>detx</em>)</h4>
<p></p>
<p>Given a pseudo-matrix (A,I)
and an ideal <em>detx</em> which is contained in (read integral multiple of) the
determinant of (A,I), finds a pseudo-basis in Hermite normal form
of the module generated by (A,I). This avoids coefficient explosion.
<em>detx</em> can be computed using the function <code>nfdetint</code>.</p>
<p>
The library syntax is <code>GEN <b>nfhnfmod</b>(GEN nf, GEN x, GEN detx)</code>.</p>

<hr></hr>
<a name="nfinit"></a>
<h4>nfinit(<em>pol</em>,{<em>flag</em> = 0})</h4>
<p></p>
<p><em>pol</em> being a non-constant,
preferably monic, irreducible polynomial in <b>Z</b>[X], initializes a
<em>number field</em> structure (<code>nf</code>) associated to the field K defined
by <em>pol</em>. As such, it's a technical object passed as the first argument
to most <code>nf</code><em>xxx</em> functions, but it contains some information which
may be directly useful. Access to this information via <em>member
functions</em> is preferred since the specific data organization specified below
may change in the future. Currently, <code>nf</code> is a row vector with 9
components:</p>
<p>
<em>nf</em>[1] contains the polynomial <em>pol</em> (<code><em>nf</em>.pol</code>).</p>
<p>
<em>nf</em>[2] contains [r1,r2] (<code><em>nf</em>.sign</code>, <code><em>nf</em>.r1</code>,
<code><em>nf</em>.r2</code>), the number of real and complex places of K.</p>
<p>
<em>nf</em>[3] contains the discriminant d(K) (<code><em>nf</em>.disc</code>) of K.</p>
<p>
<em>nf</em>[4] contains the index of <em>nf</em>[1] (<code><em>nf</em>.index</code>),
i.e.&nbsp;[<b>Z</b>_K : <b>Z</b>[<font color=#FF0000>theta</font>]], where <font color=#FF0000>theta</font> is any root of <em>nf</em>[1].</p>
<p>
<em>nf</em>[5] is a vector containing 7 matrices M, G, <em>roundG</em>, T,
MD, TI, MDI useful for certain computations in the number field K.</p>
<p>
&nbsp;&nbsp;<b>*</b> M is the (r1+r2) x n matrix whose columns represent
the numerical values of the conjugates of the elements of the integral
basis.</p>
<p>
&nbsp;&nbsp;<b>*</b> G is an n x n matrix such that T2 = ^t G G,
where T2 is the quadratic form T_2(x) = <font color=#FF0000>sum</font> |<font color=#FF0000>sigma</font>(x)|^2, <font color=#FF0000>sigma</font>
running over the embeddings of K into <b>C</b>.</p>
<p>
&nbsp;&nbsp;<b>*</b> <em>roundG</em> is a rescaled copy of G, rounded to nearest
integers.</p>
<p>
&nbsp;&nbsp;<b>*</b> T is the n x n matrix whose coefficients are
{Tr}(<font color=#FF0000>omega</font>_i<font color=#FF0000>omega</font>_j) where the <font color=#FF0000>omega</font>_i are the elements of the
integral basis. Note also that det(T) is equal to the discriminant of the
field K. Also, when understood as an ideal, the matrix T^{-1}
generates the codifferent ideal.</p>
<p>
&nbsp;&nbsp;<b>*</b> The columns of MD (<code><em>nf</em>.diff</code>) express a <b>Z</b>-basis
of the different of K on the integral basis.</p>
<p>
&nbsp;&nbsp;<b>*</b> TI is equal to the primitive part of T^{-1}, which has integral
coefficients.</p>
<p>
&nbsp;&nbsp;<b>*</b> Finally, MDI is a two-element representation (for faster
ideal product) of d(K) times the codifferent ideal
(<code><em>nf</em>.disc*<em>nf</em>.codiff</code>, which is an integral ideal). MDI
is only used in <code>idealinv</code>.</p>
<p>
<em>nf</em>[6] is the vector containing the r1+r2 roots
(<code><em>nf</em>.roots</code>) of <em>nf</em>[1] corresponding to the r1+r2
embeddings of the number field into <b>C</b> (the first r1 components are real,
the next r2 have positive imaginary part).</p>
<p>
<em>nf</em>[7] is an integral basis for <b>Z</b>_K (<code><em>nf</em>.zk</code>) expressed
on the powers of&nbsp;<font color=#FF0000>theta</font>. Its first element is guaranteed to be 1. This
basis is LLL-reduced with respect to T_2 (strictly speaking, it is a
permutation of such a basis, due to the condition that the first element be
1).</p>
<p>
<em>nf</em>[8] is the n x n integral matrix expressing the power
basis in terms of the integral basis, and finally</p>
<p>
<em>nf</em>[9] is the n x n^2 matrix giving the multiplication table
of the integral basis.</p>
<p>
If a non monic polynomial is input, <code>nfinit</code> will transform it into a
monic one, then reduce it (see <em>flag</em> = 3). It is allowed, though not very
useful given the existence of <code>nfnewprec</code>, to input a <code>nf</code> or a
<code>bnf</code> instead of a polynomial.</p>
<p></p>
<p>
<pre class="code">  ? nf = nfinit(x^3 - 12); \\ initialize number field Q[X] / (X^3 - 12)
  ? nf.pol   \\ defining polynomial
  %2 = x^3 - 12
  ? nf.disc  \\ field discriminant
  %3 = -972
  ? nf.index \\ index of power basis order in maximal order
  %4 = 2
  ? nf.zk    \\ integer basis, lifted to Q[X]
  %5 = [1, x, 1/2*x^2]
  ? nf.sign  \\ signature
  %6 = [1, 1]
  ? factor(abs(nf.disc ))  \\ determines ramified primes
  %7 =
  [2 2]
  
  [3 5]
  ? idealfactor(nf, 2)
  %8 =
  [[2, [0, 0, -1]~, 3, 1, [0, 1, 0]~] 3]  \\   <b>p</b>_2^3
</pre></p>
<p></p>
<p>
<b>Huge discriminants, helping nfdisc.</b></p>
<p>
In case <em>pol</em> has a huge discriminant which is difficult to factor,
it is hard to compute from scratch the maximal order. The special input
format [<em>pol</em>, B] is also accepted where <em>pol</em> is a polynomial as
above and B has one of the following forms</p>
<p>
<b>*</b> an integer basis, as would be computed by <code>nfbasis</code>: a vector of
polynomials with first element 1. This is useful if the maximal order is
known in advance.</p>
<p>
<b>*</b> an argument <code>listP</code> which specifies a list of primes (see
<code>nfbasis</code>). Instead of the maximal order, <code>nfinit</code> then computes an
order which is maximal at these particular primes as well as the primes
contained in the private prime table (see <code>addprimes</code>). The result is
unconditionnaly correct when the discriminant <code>nf.disc</code> factors
completely over this set of primes. The function <code>nfcertify</code> automates
this:</p>
<p>
<pre class="code">  ? pol = polcompositum(x^5 - 101, polcyclo(7))[1];
  ? nf = nfinit( [pol, 10^3] );
  ? nfcertify(nf)
  %3 = []
</pre>
A priori, <code>nf.zk</code> defines an order which is only known
to be maximal at all primes  <code>&#60;=</code> 10^3 (no prime  <code>&#60;=</code> 10^3 divides
<code>nf.index</code>). The certification step proves the correctness of the
computation.</p>
<p></p>
<p>
If <em>flag</em> = 2: <em>pol</em> is changed into another polynomial P defining the same
number field, which is as simple as can easily be found using the
<code>polredbest</code> algorithm, and all the subsequent computations are done
using this new polynomial. In particular, the first component of the result
is the modified polynomial.</p>
<p>
If <em>flag</em> = 3, apply <code>polredbest</code> as in case 2, but outputs
[<em>nf</em>,<code>Mod</code>(a,P)], where <em>nf</em> is as before and
<code>Mod</code>(a,P) = <code>Mod</code>(x,<em>pol</em>) gives the change of
variables. This is implicit when <em>pol</em> is not monic: first a linear change
of variables is performed, to get a monic polynomial, then <code>polredbest</code>.</p>
<p>
The library syntax is <code>GEN <b>nfinit0</b>(GEN pol, long flag, long prec)</code>.
Also available are
<code>GEN <b>nfinit</b>(GEN x, long prec)</code> (<em>flag</em> = 0),
<code>GEN <b>nfinitred</b>(GEN x, long prec)</code> (<em>flag</em> = 2),
<code>GEN <b>nfinitred2</b>(GEN x, long prec)</code> (<em>flag</em> = 3).
Instead of the above hardcoded numerical flags in <code>nfinit0</code>, one should
rather use</p>
<p>
<code>GEN <b>nfinitall</b>(GEN x, long flag, long prec)</code>, where <em>flag</em> is an
or-ed combination of</p>
<p>
<b>*</b> <code>nf_RED</code>: find a simpler defining polynomial,</p>
<p>
<b>*</b> <code>nf_ORIG</code>: if <code>nf_RED</code> set, also return the change of variable,</p>
<p>
<b>*</b> <code>nf_ROUND2</code>: <em>Deprecated</em>. Slow down the routine by using an
obsolete normalization algorithm (do not use this one!),</p>
<p>
<b>*</b> <code>nf_PARTIALFACT</code>: <em>Deprecated</em>. Lazy factorization of the
polynomial discriminant. Result is conditional unless <code>nfcertify</code>
can certify it.</p>

<hr></hr>
<a name="nfisideal"></a>
<h4>nfisideal(<em>nf</em>,x)</h4>
<p></p>
<p>Returns 1 if x is an ideal in the number field <em>nf</em>, 0 otherwise.</p>
<p>
The library syntax is <code>long <b>isideal</b>(GEN nf, GEN x)</code>.</p>

<hr></hr>
<a name="nfisincl"></a>
<h4>nfisincl(x,y)</h4>
<p></p>
<p>Tests whether the number field K defined
by the polynomial x is conjugate to a subfield of the field L defined
by y (where x and y must be in <b>Q</b>[X]). If they are not, the output
is the number 0. If they are, the output is a vector of polynomials, each
polynomial a representing an embedding of K into L, i.e.&nbsp;being such
that y | x o a.</p>
<p>
If y is a number field (<em>nf</em>), a much faster algorithm is used
(factoring x over y using <code>nffactor</code>). Before version 2.0.14, this
wasn't guaranteed to return all the embeddings, hence was triggered by a
special flag. This is no more the case.</p>
<p>
The library syntax is <code>GEN <b>nfisincl</b>(GEN x, GEN y)</code>.</p>

<hr></hr>
<a name="nfisisom"></a>
<h4>nfisisom(x,y)</h4>
<p></p>
<p>As <code>nfisincl</code>, but tests for isomorphism. If either x or y is a
number field, a much faster algorithm will be used.</p>
<p>
The library syntax is <code>GEN <b>nfisisom</b>(GEN x, GEN y)</code>.</p>

<hr></hr>
<a name="nfkermodpr"></a>
<h4>nfkermodpr(<em>nf</em>,x,<em>pr</em>)</h4>
<p></p>
<p>Kernel of the matrix a in <b>Z</b>_K/<em>pr</em>, where <em>pr</em> is in
<b>modpr</b> format (see <code>nfmodprinit</code>).</p>
<p>
The library syntax is <code>GEN <b>nfkermodpr</b>(GEN nf, GEN x, GEN pr)</code>.
This function is normally useless in library mode. Project your
inputs to the residue field using <code>nfM_to_FqM</code>, then work there.</p>

<hr></hr>
<a name="nfmodprinit"></a>
<h4>nfmodprinit(<em>nf</em>,<em>pr</em>)</h4>
<p></p>
<p>Transforms the prime ideal <em>pr</em> into <code>modpr</code> format necessary
for all operations modulo <em>pr</em> in the number field <em>nf</em>.</p>
<p>
The library syntax is <code>GEN <b>nfmodprinit</b>(GEN nf, GEN pr)</code>.</p>

<hr></hr>
<a name="nfnewprec"></a>
<h4>nfnewprec(<em>nf</em>)</h4>
<p></p>
<p>Transforms the number field <em>nf</em>
into the corresponding data using current (usually larger) precision. This
function works as expected if <em>nf</em> is in fact a <em>bnf</em> (update
<em>bnf</em> to current precision) but may be quite slow (many generators of
principal ideals have to be computed).</p>
<p>
The library syntax is <code>GEN <b>nfnewprec</b>(GEN nf, long prec)</code>.
See also <code>GEN <b>bnfnewprec</b>(GEN bnf, long prec)</code>
and <code>GEN <b>bnrnewprec</b>(GEN bnr, long prec)</code>.</p>

<hr></hr>
<a name="nfroots"></a>
<h4>nfroots({<em>nf</em>},x)</h4>
<p></p>
<p>Roots of the polynomial x in the
number field <em>nf</em> given by <code>nfinit</code> without multiplicity (in <b>Q</b>
if <em>nf</em> is omitted). x has coefficients in the number field (scalar,
polmod, polynomial, column vector). The main variable of <em>nf</em> must be
of lower priority than that of x (see Section [<b>Label: se:priority</b>]). However if the
coefficients of the number field occur explicitly (as polmods) as
coefficients of x, the variable of these polmods <em>must</em> be the same as
the main variable of t (see <code>nffactor</code>).</p>
<p>
It is possible to input a defining polynomial for <em>nf</em>
instead, but this is in general less efficient since parts of an <code>nf</code>
structure will be computed internally. This is useful in two situations: when
you don't need the <code>nf</code>, or when you can't compute its discriminant due
to integer factorization difficulties. In the latter case, <code>addprimes</code> is
a possibility but a dangerous one: roots will probably be missed if the
(true) field discriminant and an <code>addprimes</code> entry are strictly divisible
by some prime. If you have such an unsafe <em>nf</em>, it is safer to input
<code>nf.pol</code>.</p>
<p>
The library syntax is <code>GEN <b>nfroots</b>(GEN nf = NULL, GEN x)</code>.
See also <code>GEN <b>nfrootsQ</b>(GEN x)</code>,
corresponding to <code>nf</code> = <code>NULL</code>.</p>

<hr></hr>
<a name="nfrootsof1"></a>
<h4>nfrootsof1(<em>nf</em>)</h4>
<p></p>
<p>Returns a two-component vector [w,z] where w is the number of roots of
unity in the number field <em>nf</em>, and z is a primitive w-th root
of unity.</p>
<p>
<pre class="code">  ? K = nfinit(polcyclo(11));
  ? nfrootsof1(K)
  %2 = [22, [0, 0, 0, 0, 0, -1, 0, 0, 0, 0]~]
  ? z = nfbasistoalg(K, %[2])   \\ in algebraic form
  %3 = Mod(-x^5, x^10 + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1)
  ? [lift(z^11), lift(z^2)]     \\ proves that the order of z is 22
  %4 = [-1, -x^9 - x^8 - x^7 - x^6 - x^5 - x^4 - x^3 - x^2 - x - 1]
</pre></p>
<p>
This function guesses the number w as the gcd of the #k(v)^* for
unramified v above odd primes, then computes the roots in <em>nf</em>
of the w-th cyclotomic polynomial: the algorithm is polynomial time with
respect to the field degree and the bitsize of the multiplication table in
<em>nf</em> (both of them polynomially bounded in terms of the size of the
discriminant). Fields of degree up to 100 or so should require less than
one minute.</p>
<p>
The library syntax is <code>GEN <b>rootsof1</b>(GEN nf)</code>.
Also available is <code>GEN <b>rootsof1_kannan</b>(GEN nf)</code>, that computes
all algebraic integers of T_2 norm equal to the field degree
(all roots of 1, by Kronecker's theorem). This is in general a little
faster than the default when there <em>are</em> roots of 1 in the field
(say twice faster), but can be much slower (say, <em>days</em> slower), since
the algorithm is a priori exponential in the field degree.</p>

<hr></hr>
<a name="nfsnf"></a>
<h4>nfsnf(<em>nf</em>,x)</h4>
<p></p>
<p>Given a <b>Z</b>_K-module x associated to the integral pseudo-matrix
(A,I,J), returns an ideal list d_1,...,d_n which is the \idx{Smith
normal form} of x. In other words, x is isomorphic to
<b>Z</b>_K/d_1oplus...oplus<b>Z</b>_K/d_n and d_i divides d_{i-1} for i <code>&#62;=</code> 2.</p>
<p>
See Section [<b>Label: se:ZKmodules</b>] for the definition of integral pseudo-matrix;
briefly, it is input as a 3-component row vector [A,I,J] where
I = [b_1,...,b_n] and J = [a_1,...,a_n] are two ideal lists,
and A is a square n x n matrix with columns (A_1,...,A_n),
seen as elements in K^n (with canonical basis (e_1,...,e_n)).
This data defines the <b>Z</b>_K module x given by
 (b_1e_1oplus...oplus b_ne_n) / (a_1A_1oplus...oplus a_nA_n)
 , 
The integrality condition is a_{i,j} belongs to b_i a_j^{-1} for all i,j. If it
is not satisfied, then the d_i will not be integral. Note that every
finitely generated torsion module is isomorphic to a module of this form and
even with b_i = Z_K for all i.</p>
<p>
The library syntax is <code>GEN <b>nfsnf</b>(GEN nf, GEN x)</code>.</p>

<hr></hr>
<a name="nfsolvemodpr"></a>
<h4>nfsolvemodpr(<em>nf</em>,a,b,P)</h4>
<p></p>
<p>Let P be a prime ideal in <b>modpr</b> format (see <code>nfmodprinit</code>),
let a be a matrix, invertible over the residue field, and let b be
a column vector or matrix. This function returns a solution of a.x = 
b; the coefficients of x are lifted to <em>nf</em> elements.</p>
<p>
<pre class="code">  ? K = nfinit(y^2+1);
  ? P = idealprimedec(K, 3)[1];
  ? P = nfmodprinit(K, P);
  ? a = [y+1, y; y, 0]; b = [1, y]~
  ? nfsolvemodpr(K, a,b, P)
  %5 = [1, 2]~
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>nfsolvemodpr</b>(GEN nf, GEN a, GEN b, GEN P)</code>.
This function is normally useless in library mode. Project your
inputs to the residue field using <code>nfM_to_FqM</code>, then work there.</p>

<hr></hr>
<a name="nfsubfields"></a>
<h4>nfsubfields(<em>pol</em>,{d = 0})</h4>
<p></p>
<p>Finds all subfields of degree
d of the number field defined by the (monic, integral) polynomial
<em>pol</em> (all subfields if d is null or omitted). The result is a vector
of subfields, each being given by [g,h], where g is an absolute equation
and h expresses one of the roots of g in terms of the root x of the
polynomial defining <em>nf</em>. This routine uses J.&nbsp;Kl&uuml;ners's algorithm
in the general case, and B.&nbsp;Allombert's <code>galoissubfields</code> when <em>nf</em>
is Galois (with weakly supersolvable Galois group).</p>
<p>
The library syntax is <code>GEN <b>nfsubfields</b>(GEN pol, long d)</code>.</p>

<hr></hr>
<a name="polcompositum"></a>
<h4>polcompositum(P,Q,{<em>flag</em> = 0})</h4>
<p></p>
<p> P and Q
being squarefree polynomials in <b>Z</b>[X] in the same variable, outputs
the simple factors of the &eacute;tale <b>Q</b>-algebra A = <b>Q</b>(X, Y) / (P(X), Q(Y)).
The factors are given by a list of polynomials R in <b>Z</b>[X], associated to
the number field <b>Q</b>(X)/ (R), and sorted by increasing degree (with respect
to lexicographic ordering for factors of equal degrees). Returns an error if
one of the polynomials is not squarefree.</p>
<p>
Note that it is more efficient to reduce to the case where P and Q are
irreducible first. The routine will not perform this for you, since it may be
expensive, and the inputs are irreducible in most applications anyway. In
this case, there will be a single factor R if and only if the number
fields defined by P and Q are disjoint.</p>
<p>
Assuming P is irreducible (of smaller degree than Q for efficiency), it
is in general much faster to proceed as follows</p>
<p>
<pre class="code">  nf = nfinit(P); L = nffactor(nf, Q)[,1];
  vector(#L, i, rnfequation(nf, L[i]))
</pre></p>
<p>
to obtain the same result. If you are only interested in the degrees of the
simple factors, the <code>rnfequation</code> instruction can be replaced by a
trivial <code>poldegree(P) * poldegree(L[i])</code>.</p>
<p>
If <em>flag</em> = 1, outputs a vector of 4-component vectors [R,a,b,k], where R
ranges through the list of all possible compositums as above, and a
(resp. b) expresses the root of P (resp. Q) as an element of
<b>Q</b>(X)/(R). Finally, k is a small integer such that b + ka = X modulo
R.</p>
<p>
A compositum is often defined by a complicated polynomial, which it is
advisable to reduce before further work. Here is an example involving
the field <b>Q</b>(<font color=#FF0000>zeta</font>_5, 5^{1/5}):</p>
<p>
<pre class="code">  ? L = polcompositum(x^5 - 5, polcyclo(5), 1); \\  list of [R,a,b,k]
  ? [R, a] = L[1];  \\  pick the single factor, extract R,a (ignore b,k)
  ? R               \\  defines the compositum
  %3 = x^20 + 5*x^19 + 15*x^18 + 35*x^17 + 70*x^16 + 141*x^15 + 260*x^14\
  + 355*x^13 + 95*x^12 - 1460*x^11 - 3279*x^10 - 3660*x^9 - 2005*x^8    \
  + 705*x^7 + 9210*x^6 + 13506*x^5 + 7145*x^4 - 2740*x^3 + 1040*x^2     \
  - 320*x + 256
  ? a^5 - 5         \\  a fifth root of 5
  %4 = 0
  ? [T, X] = polredbest(R, 1);
  ? T     \\  simpler defining polynomial for <b>Q</b>[x]/(R)
  %6 = x^20 + 25*x^10 + 5
  ? X     \\   root of R in <b>Q</b>[y]/(T(y))
  %7 = Mod(-1/11*x^15 - 1/11*x^14 + 1/22*x^10 - 47/22*x^5 - 29/11*x^4 + 7/22,\
  x^20 + 25*x^10 + 5)
  ? a = subst(a.pol, 'x, X)  \\  <code>a</code> in the new coordinates
  %8 = Mod(1/11*x^14 + 29/11*x^4, x^20 + 25*x^10 + 5)
  ? a^5 - 5
  %9 = 0
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>polcompositum0</b>(GEN P, GEN Q, long flag)</code>.
Also available are
<code>GEN <b>compositum</b>(GEN P, GEN Q)</code> (<em>flag</em> = 0) and
<code>GEN <b>compositum2</b>(GEN P, GEN Q)</code> (<em>flag</em> = 1).</p>

<hr></hr>
<a name="polgalois"></a>
<h4>polgalois(T)</h4>
<p></p>
<p>Galois group of the non-constant
polynomial T belongs to <b>Q</b>[X]. In the present version <b>2.7.0</b>, T must be irreducible
and the degree d of T must be less than or equal to 7. If the
<code>galdata</code> package has been installed, degrees 8, 9, 10 and 11 are also
implemented. By definition, if K = <b>Q</b>[x]/(T), this computes the action of
the Galois group of the Galois closure of K on the d distinct roots of
T, up to conjugacy (corresponding to different root orderings).</p>
<p>
The output is a 4-component vector [n,s,k,name] with the
following meaning: n is the cardinality of the group, s is its signature
(s = 1 if the group is a subgroup of the alternating group A_d, s = -1
otherwise) and name is a character string containing name of the transitive
group according to the GAP 4 transitive groups library by Alexander Hulpke.</p>
<p>
k is more arbitrary and the choice made up to version&nbsp;2.2.3 of PARI is rather
unfortunate: for d &#62; 7, k is the numbering of the group among all
transitive subgroups of S_d, as given in "The transitive groups of degree up
to eleven", G.&nbsp;Butler and J.&nbsp;McKay, <em>Communications in Algebra</em>, vol.&nbsp;11,
1983,
pp.&nbsp;863--911 (group k is denoted T_k there). And for d <code>&#60;=</code> 7, it was ad
hoc, so as to ensure that a given triple would denote a unique group.
Specifically, for polynomials of degree d <code>&#60;=</code> 7, the groups are coded as
follows, using standard notations</p>
<p>
In degree 1: S_1 = [1,1,1].</p>
<p>
In degree 2: S_2 = [2,-1,1].</p>
<p>
In degree 3: A_3 = C_3 = [3,1,1], S_3 = [6,-1,1].</p>
<p>
In degree 4: C_4 = [4,-1,1], V_4 = [4,1,1], D_4 = [8,-1,1], A_4 = [12,1,1],
S_4 = [24,-1,1].</p>
<p>
In degree 5: C_5 = [5,1,1], D_5 = [10,1,1], M_{20} = [20,-1,1],
A_5 = [60,1,1], S_5 = [120,-1,1].</p>
<p>
In degree 6: C_6 = [6,-1,1], S_3 = [6,-1,2], D_6 = [12,-1,1], A_4 = [12,1,1],
G_{18} = [18,-1,1], S_4^ -= [24,-1,1], A_4 x C_2 = [24,-1,2],
S_4^ += [24,1,1], G_{36}^ -= [36,-1,1], G_{36}^ += [36,1,1],
S_4 x C_2 = [48,-1,1], A_5 = PSL_2(5) = [60,1,1], G_{72} = [72,-1,1],
S_5 = PGL_2(5) = [120,-1,1], A_6 = [360,1,1], S_6 = [720,-1,1].</p>
<p>
In degree 7: C_7 = [7,1,1], D_7 = [14,-1,1], M_{21} = [21,1,1],
M_{42} = [42,-1,1], PSL_2(7) = PSL_3(2) = [168,1,1], A_7 = [2520,1,1],
S_7 = [5040,-1,1].</p>
<p>
This is deprecated and obsolete, but for reasons of backward compatibility,
we cannot change this behavior yet. So you can use the default
<code>new_galois_format</code> to switch to a consistent naming scheme, namely k is
always the standard numbering of the group among all transitive subgroups of
S_n. If this default is in effect, the above groups will be coded as:</p>
<p>
In degree 1: S_1 = [1,1,1].</p>
<p>
In degree 2: S_2 = [2,-1,1].</p>
<p>
In degree 3: A_3 = C_3 = [3,1,1], S_3 = [6,-1,2].</p>
<p>
In degree 4: C_4 = [4,-1,1], V_4 = [4,1,2], D_4 = [8,-1,3], A_4 = [12,1,4],
S_4 = [24,-1,5].</p>
<p>
In degree 5: C_5 = [5,1,1], D_5 = [10,1,2], M_{20} = [20,-1,3],
A_5 = [60,1,4], S_5 = [120,-1,5].</p>
<p>
In degree 6: C_6 = [6,-1,1], S_3 = [6,-1,2], D_6 = [12,-1,3], A_4 = [12,1,4],
G_{18} = [18,-1,5], A_4 x C_2 = [24,-1,6], S_4^ += [24,1,7],
S_4^ -= [24,-1,8], G_{36}^ -= [36,-1,9], G_{36}^ += [36,1,10],
S_4 x C_2 = [48,-1,11], A_5 = PSL_2(5) = [60,1,12], G_{72} = [72,-1,13],
S_5 = PGL_2(5) = [120,-1,14], A_6 = [360,1,15], S_6 = [720,-1,16].</p>
<p>
In degree 7: C_7 = [7,1,1], D_7 = [14,-1,2], M_{21} = [21,1,3],
M_{42} = [42,-1,4], PSL_2(7) = PSL_3(2) = [168,1,5], A_7 = [2520,1,6],
S_7 = [5040,-1,7].</p>
<p></p>
<p>
<b>Warning.</b> The method used is that of resolvent polynomials and is
sensitive to the current precision. The precision is updated internally but,
in very rare cases, a wrong result may be returned if the initial precision
was not sufficient.</p>
<p>
The library syntax is <code>GEN <b>polgalois</b>(GEN T, long prec)</code>.
To enable the new format in library mode,
set the global variable <code>new_galois_format</code> to 1.</p>

<hr></hr>
<a name="polred"></a>
<h4>polred(T,{<em>flag</em> = 0})</h4>
<p></p>
<p>This function is <em>deprecated</em>, use <code>polredbest</code> instead.
Finds polynomials with reasonably small coefficients defining subfields of
the number field defined by T. One of the polynomials always defines <b>Q</b>
(hence is equal to x-1), and another always defines the same number field
as T if T is irreducible.</p>
<p>
All T accepted by <code>nfinit</code> are also allowed here;
in particular, the format <code>[T, listP]</code> is recommended, e.g. with
<code>listP</code> = 10^5 or a vector containing all ramified primes. Otherwise,
the maximal order of <b>Q</b>[x]/(T) must be computed.</p>
<p>
The following binary digits of <em>flag</em> are significant:</p>
<p>
1: Possibly use a suborder of the maximal order. The
primes dividing the index of the order chosen are larger than
<code>primelimit</code> or divide integers stored in the <code>addprimes</code> table.
This flag is <em>deprecated</em>, the <code>[T, listP]</code> format is more
flexible.</p>
<p>
2: gives also elements. The result is a two-column matrix, the first column
giving primitive elements defining these subfields, the second giving the
corresponding minimal polynomials.</p>
<p>
<pre class="code">  ? M = polred(x^4 + 8, 2)
  %1 =
  [1 x - 1]
  
  [1/2*x^2 x^2 + 2]
  
  [1/4*x^3 x^4 + 2]
  
  [x x^4 + 8]
  ? minpoly(Mod(M[2,1], x^4+8))
  %2 = x^2 + 2
</pre></p>
<p></p>
<p>
The library syntax is <code><b>polred</b>(GEN T)</code> (<em>flag</em> = 0). Also available is
<code>GEN <b>polred2</b>(GEN T)</code> (<em>flag</em> = 2). The function <code>polred0</code> is
deprecated, provided for backward compatibility.</p>

<hr></hr>
<a name="polredabs"></a>
<h4>polredabs(T,{<em>flag</em> = 0})</h4>
<p></p>
<p>Returns a canonical defining polynomial P for the number field
<b>Q</b>[X]/(T) defined by T, such that the sum of the squares of the modulus
of the roots (i.e.&nbsp;the T_2-norm) is minimal. Different T defining
isomorphic number fields will yield the same P. All T accepted by
<code>nfinit</code> are also allowed here, e.g. non-monic polynomials, or pairs
<code>[T, listP]</code> specifying that a non-maximal order may be used.</p>
<p>
<b>Warning 1.</b> Using a <code>t_POL</code> T requires fully factoring the
discriminant of T, which may be very hard. The format <code>[T, listP]</code>
computes only a suborder of the maximal order and replaces this part of the
algorithm by a polynomial time computation. In that case the polynomial P
is a priori no longer canonical, and it may happen that it does not have
minimal T_2 norm. The routine attempts to certify the result independently
of this order computation (as per <code>nfcertify</code>: we try to prove that the
order is maximal); if it fails, the routine returns 0 instead of P.
In order to force an output in that case as well, you may either use
<code>polredbest</code>, or <code>polredabs(,16)</code>, or</p>
<p>
<pre class="code">    polredabs([T, nfbasis([T, listP])])
</pre>
(In all three cases, the result is no longer canonical.)</p>
<p>
<b>Warning 2.</b> Apart from the factorization of the discriminant of
T, this routine runs in polynomial time for a <em>fixed</em> degree.
But the complexity is exponential in the degree: this routine
may be exceedingly slow when the number field has many subfields, hence a
lot of elements of small T_2-norm. If you do not need a canonical
polynomial, the function <code>polredbest</code> is in general much faster (it runs
in polynomial time), and tends to return polynomials with smaller
discriminants.</p>
<p>
The binary digits of <em>flag</em> mean</p>
<p>
1: outputs a two-component row vector [P,a], where P is the default
output and <code>Mod(a, P)</code> is a root of the original T.</p>
<p>
4: gives <em>all</em> polynomials of minimal T_2 norm; of the two polynomials
P(x) and &#177; P(-x), only one is given.</p>
<p>
16: Possibly use a suborder of the maximal order, <em>without</em> attempting to
certify the result as in Warning 1: we always return a polynomial and never
0. The result is a priori not canonical.</p>
<p></p>
<p>
<pre class="code">  ? T = x^16 - 136*x^14 + 6476*x^12 - 141912*x^10 + 1513334*x^8 \
        - 7453176*x^6 + 13950764*x^4 - 5596840*x^2 + 46225
  ? T1 = polredabs(T); T2 = polredbest(T);
  ? [ norml2(polroots(T1)), norml2(polroots(T2)) ]
  %3 = [88.0000000, 120.000000]
  ? [ sizedigit(poldisc(T1)), sizedigit(poldisc(T2)) ]
  %4 = [75, 67]
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>polredabs0</b>(GEN T, long flag)</code>.
Instead of the above hardcoded numerical flags, one should use an
or-ed combination of</p>
<p>
<b>*</b> <code>nf_PARTIALFACT</code>: possibly use a suborder of the maximal order,
<em>without</em> attempting to certify the result.</p>
<p>
<b>*</b> <code>nf_ORIG</code>: return [P, a], where <code>Mod(a, P)</code> is a root of T.</p>
<p>
<b>*</b> <code>nf_RAW</code>: return [P, b], where <code>Mod(b, T)</code> is a root of P.
The algebraic integer b is the raw result produced by the small vectors
enumeration in the maximal order; P was computed as the characteristic
polynomial of <code>Mod(b, T)</code>. <code>Mod(a, P)</code> as in <code>nf_ORIG</code>
is obtained with <code>modreverse</code>.</p>
<p>
<b>*</b> <code>nf_ADDZK</code>: if r is the result produced with some of the above
flags (of the form P or [P,c]), return <code>[r,zk]</code>, where <code>zk</code> is a
<b>Z</b>-basis for the maximal order of <b>Q</b>[X]/(P).</p>
<p>
<b>*</b> <code>nf_ALL</code>: return a vector of results of the above form, for all
polynomials of minimal T_2-norm.</p>

<hr></hr>
<a name="polredbest"></a>
<h4>polredbest(T,{<em>flag</em> = 0})</h4>
<p></p>
<p>Finds a polynomial with reasonably
small coefficients defining the same number field as T.
All T accepted by <code>nfinit</code> are also allowed here (e.g. non-monic
polynomials, <code>nf</code>, <code>bnf</code>, <code>[T,Z_K_basis]</code>). Contrary to
<code>polredabs</code>, this routine runs in polynomial time, but it offers no
guarantee as to the minimality of its result.</p>
<p>
This routine computes an LLL-reduced basis for the ring of integers of
<b>Q</b>[X]/(T), then examines small linear combinations of the basis vectors,
computing their characteristic polynomials. It returns the <em>separable</em>
P polynomial of smallest discriminant (the one with lexicographically
smallest <code>abs(Vec(P))</code> in case of ties). This is a good candidate
for subsequent number field computations, since it guarantees that
the denominators of algebraic integers, when expressed in the power basis,
are reasonably small. With no claim of minimality, though.</p>
<p>
It can happen that iterating this functions yields better and better
polynomials, until it stabilizes:</p>
<p>
<pre class="code">  ? \p5
  ? P = X^12+8*X^8-50*X^6+16*X^4-3069*X^2+625;
  ? poldisc(P)*1.
  %2 = 1.2622 E55
  ? P = polredbest(P);
  ? poldisc(P)*1.
  %4 = 2.9012 E51
  ? P = polredbest(P);
  ? poldisc(P)*1.
  %6 = 8.8704 E44
</pre>
In this example, the initial polynomial P is the one
returned by <code>polredabs</code>, and the last one is stable.</p>
<p>
If <em>flag</em> = 1: outputs a two-component row vector [P,a],  where P is the
default output and <code>Mod(a, P)</code> is a root of the original T.</p>
<p>
<pre class="code">  ? [P,a] = polredbest(x^4 + 8, 1)
  %1 = [x^4 + 2, Mod(x^3, x^4 + 2)]
  ? charpoly(a)
  %2 = x^4 + 8
</pre>
In particular, the map <b>Q</b>[x]/(T) \to <b>Q</b>[x]/(P),
x<code>|---&#62;</code><code>Mod(a,P)</code> defines an isomorphism of number fields, which can
be computed as</p>
<p>
<pre class="code">    subst(lift(Q), 'x, a)
</pre>
if Q is a <code>t_POLMOD</code> modulo T; <code>b = modreverse(a)</code>
returns a <code>t_POLMOD</code> giving the inverse of the above map (which should be
useless since <b>Q</b>[x]/(P) is a priori a better representation for the number
field and its elements).</p>
<p>
The library syntax is <code>GEN <b>polredbest</b>(GEN T, long flag)</code>.</p>

<hr></hr>
<a name="polredord"></a>
<h4>polredord(x)</h4>
<p></p>
<p>Finds polynomials with reasonably small
coefficients and of the same degree as that of x defining suborders of the
order defined by x. One of the polynomials always defines <b>Q</b> (hence
is equal to (x-1)^n, where n is the degree), and another always defines
the same order as x if x is irreducible. Useless function: try
<code>polredbest</code>.</p>
<p>
The library syntax is <code>GEN <b>polredord</b>(GEN x)</code>.</p>

<hr></hr>
<a name="poltschirnhaus"></a>
<h4>poltschirnhaus(x)</h4>
<p></p>
<p>Applies a random Tschirnhausen
transformation to the polynomial x, which is assumed to be non-constant
and separable, so as to obtain a new equation for the &eacute;tale algebra
defined by x. This is for instance useful when computing resolvents,
hence is used by the <code>polgalois</code> function.</p>
<p>
The library syntax is <code>GEN <b>tschirnhaus</b>(GEN x)</code>.</p>

<hr></hr>
<a name="rnfalgtobasis"></a>
<h4>rnfalgtobasis(<em>rnf</em>,x)</h4>
<p></p>
<p>Expresses x on the relative
integral basis. Here, <em>rnf</em> is a relative number field extension L/K
as output by <code>rnfinit</code>, and x an element of L in absolute form, i.e.
expressed as a polynomial or polmod with polmod coefficients, <em>not</em> on
the relative integral basis.</p>
<p>
The library syntax is <code>GEN <b>rnfalgtobasis</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfbasis"></a>
<h4>rnfbasis(<em>bnf</em>,M)</h4>
<p></p>
<p>Let K the field represented by
<em>bnf</em>, as output by <code>bnfinit</code>. M is a projective <b>Z</b>_K-module
of rank n (M\otimes K is an n-dimensional K-vector space), given by a
pseudo-basis of size n. The routine returns either a true <b>Z</b>_K-basis of
M (of size n) if it exists, or an n+1-element generating set of M if
not.</p>
<p>
It is allowed to use an irreducible polynomial P in K[X] instead of M,
in which case, M is defined as the ring of integers of K[X]/(P), viewed
as a <b>Z</b>_K-module.</p>
<p>
The library syntax is <code>GEN <b>rnfbasis</b>(GEN bnf, GEN M)</code>.</p>

<hr></hr>
<a name="rnfbasistoalg"></a>
<h4>rnfbasistoalg(<em>rnf</em>,x)</h4>
<p></p>
<p>Computes the representation of x
as a polmod with polmods coefficients. Here, <em>rnf</em> is a relative number
field extension L/K as output by <code>rnfinit</code>, and x an element of
L expressed on the relative integral basis.</p>
<p>
The library syntax is <code>GEN <b>rnfbasistoalg</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfcharpoly"></a>
<h4>rnfcharpoly(<em>nf</em>,T,a,{<em>var</em> = 'x})</h4>
<p></p>
<p>Characteristic polynomial of
a over <em>nf</em>, where a belongs to the algebra defined by T over
<em>nf</em>, i.e.&nbsp;<em>nf</em>[X]/(T). Returns a polynomial in variable v
(x by default).</p>
<p>
<pre class="code">  ? nf = nfinit(y^2+1);
  ? rnfcharpoly(nf, x^2+y*x+1, x+y)
  %2 = x^2 + Mod(-y, y^2 + 1)*x + 1
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfcharpoly</b>(GEN nf, GEN T, GEN a, long var = -1)</code>, where <code>var</code> is a variable number.</p>

<hr></hr>
<a name="rnfconductor"></a>
<h4>rnfconductor(<em>bnf</em>,<em>pol</em>)</h4>
<p></p>
<p>Given <em>bnf</em>
as output by <code>bnfinit</code>, and <em>pol</em> a relative polynomial defining an
Abelian extension, computes the class field theory conductor of this
Abelian extension. The result is a 3-component vector
[<em>conductor</em>,<em>rayclgp</em>,<em>subgroup</em>], where <em>conductor</em> is
the conductor of the extension given as a 2-component row vector
[f_0,f_ oo ], <em>rayclgp</em> is the full ray class group corresponding to
the conductor given as a 3-component vector [h,cyc,gen] as usual for a group,
and <em>subgroup</em> is a matrix in HNF defining the subgroup of the ray class
group on the given generators gen.</p>
<p>
The library syntax is <code>GEN <b>rnfconductor</b>(GEN bnf, GEN pol)</code>.</p>

<hr></hr>
<a name="rnfdedekind"></a>
<h4>rnfdedekind(<em>nf</em>,<em>pol</em>,{<em>pr</em>},{<em>flag</em> = 0})</h4>
<p></p>
<p>Given a number field K coded by <em>nf</em> and a monic
polynomial P belongs to <b>Z</b>_K[X], irreducible over K and thus defining a relative
extension L of K, applies Dedekind's criterion to the order
<b>Z</b>_K[X]/(P), at the prime ideal <em>pr</em>. It is possible to set <em>pr</em>
to a vector of prime ideals (test maximality at all primes in the vector),
or to omit altogether, in which case maximality at <em>all</em> primes is tested;
in this situation <em>flag</em> is automatically set to 1.</p>
<p>
The default historic behavior (<em>flag</em> is 0 or omitted and <em>pr</em> is a
single prime ideal) is not so useful since
<code>rnfpseudobasis</code> gives more information and is generally not that
much slower. It returns a 3-component vector [<em>max</em>, <em>basis</em>, v]:</p>
<p>
<b>*</b> <em>basis</em> is a pseudo-basis of an enlarged order O produced by
Dedekind's criterion, containing the original order <b>Z</b>_K[X]/(P)
with index a power of <em>pr</em>. Possibly equal to the original order.</p>
<p>
<b>*</b> <em>max</em> is a flag equal to 1 if the enlarged order O
could be proven to be <em>pr</em>-maximal and to 0 otherwise; it may still be
maximal in the latter case if <em>pr</em> is ramified in L,</p>
<p>
<b>*</b> v is the valuation at <em>pr</em> of the order discriminant.</p>
<p>
If <em>flag</em> is non-zero, on the other hand, we just return 1 if the order
<b>Z</b>_K[X]/(P) is <em>pr</em>-maximal (resp.&nbsp;maximal at all relevant primes, as
described above), and 0 if not. This is much faster than the default,
since the enlarged order is not computed.</p>
<p>
<pre class="code">  ? nf = nfinit(y^2-3); P = x^3 - 2*y;
  ? pr3 = idealprimedec(nf,3)[1];
  ? rnfdedekind(nf, P, pr3)
  %2 = [1, [[1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 1, 1]], 8]
  ? rnfdedekind(nf, P, pr3, 1)
  %3 = 1
</pre>
In this example, <code>pr3</code> is the ramified ideal above 3,
and the order generated by the cube roots of y is already
<code>pr3</code>-maximal. The order-discriminant has valuation 8. On the other
hand, the order is not maximal at the prime above 2:</p>
<p>
<pre class="code">  ? pr2 = idealprimedec(nf,2)[1];
  ? rnfdedekind(nf, P, pr2, 1)
  %5 = 0
  ? rnfdedekind(nf, P, pr2)
  %6 = [0, [[2, 0, 0; 0, 1, 0; 0, 0, 1], [[1, 0; 0, 1], [1, 0; 0, 1],
       [1, 1/2; 0, 1/2]]], 2]
</pre></p>
<p>
The enlarged order is not proven to be <code>pr2</code>-maximal yet. In fact, it
is; it is in fact the maximal order:</p>
<p>
<pre class="code">  ? B = rnfpseudobasis(nf, P)
  %7 = [[1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 1, [1, 1/2; 0, 1/2]],
       [162, 0; 0, 162], -1]
  ? idealval(nf,B[3], pr2)
  %4 = 2
</pre></p>
<p>
It is possible to use this routine with non-monic
P = <font color=#FF0000>sum</font>_{i <code>&#60;=</code> n} a_i X^i belongs to <b>Z</b>_K[X] if <em>flag</em> = 1;
in this case, we test maximality of Dedekind's order generated by
1, a_n <font color=#FF0000>alpha</font>, a_n<font color=#FF0000>alpha</font>^2 + a_{n-1}<font color=#FF0000>alpha</font>,...,
a_n<font color=#FF0000>alpha</font>^{n-1} + a_{n-1}<font color=#FF0000>alpha</font>^{n-2} +...+ a_1<font color=#FF0000>alpha</font>.
The routine will fail if P is 0 on the projective line over the residue
field <b>Z</b>_K/<code>pr</code> (FIXME).</p>
<p>
The library syntax is <code>GEN <b>rnfdedekind</b>(GEN nf, GEN pol, GEN pr = NULL, long flag)</code>.</p>

<hr></hr>
<a name="rnfdet"></a>
<h4>rnfdet(<em>nf</em>,M)</h4>
<p></p>
<p>Given a pseudo-matrix M over the maximal
order of <em>nf</em>, computes its determinant.</p>
<p>
The library syntax is <code>GEN <b>rnfdet</b>(GEN nf, GEN M)</code>.</p>

<hr></hr>
<a name="rnfdisc"></a>
<h4>rnfdisc(<em>nf</em>,<em>pol</em>)</h4>
<p></p>
<p>Given a number field <em>nf</em> as
output by <code>nfinit</code> and a polynomial <em>pol</em> with coefficients in
<em>nf</em> defining a relative extension L of <em>nf</em>, computes the
relative discriminant of L. This is a two-element row vector [D,d], where
D is the relative ideal discriminant and d is the relative discriminant
considered as an element of <em>nf</em>^*/{<em>nf</em>^*}^2. The main variable of
<em>nf</em> <em>must</em> be of lower priority than that of <em>pol</em>, see
Section [<b>Label: se:priority</b>].</p>
<p>
The library syntax is <code>GEN <b>rnfdiscf</b>(GEN nf, GEN pol)</code>.</p>

<hr></hr>
<a name="rnfeltabstorel"></a>
<h4>rnfeltabstorel(<em>rnf</em>,x)</h4>
<p></p>
<p><em>rnf</em> being a relative
number field extension L/K as output by <code>rnfinit</code> and x being an
element of L expressed as a polynomial modulo the absolute equation
<code><em>rnf</em>.pol</code>, computes x as an element of the relative extension
L/K as a polmod with polmod coefficients.</p>
<p>
<pre class="code">  ? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
  ? L.pol
  %2 = x^4 + 1
  ? rnfeltabstorel(L, Mod(x, L.pol))
  %3 = Mod(x, x^2 + Mod(-y, y^2 + 1))
  ? rnfeltabstorel(L, Mod(2, L.pol))
  %4 = 2
  ? rnfeltabstorel(L, Mod(x, x^2-y))
   ***   at top-level: rnfeltabstorel(L,Mod
   ***                 ^--------------------
   *** rnfeltabstorel: inconsistent moduli in rnfeltabstorel: x^2-y != x^4+1
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfeltabstorel</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfeltdown"></a>
<h4>rnfeltdown(<em>rnf</em>,x)</h4>
<p></p>
<p><em>rnf</em> being a relative number
field extension L/K as output by <code>rnfinit</code> and x being an element of
L expressed as a polynomial or polmod with polmod coefficients, computes
x as an element of K as a polmod, assuming x is in K (otherwise a
domain error occurs).</p>
<p>
<pre class="code">  ? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
  ? L.pol
  %2 = x^4 + 1
  ? rnfeltdown(L, Mod(x^2, L.pol))
  %3 = Mod(y, y^2 + 1)
  ? rnfeltdown(L, Mod(y, x^2-y))
  %4 = Mod(y, y^2 + 1)
  ? rnfeltdown(L, Mod(y,K.pol))
  %5 = Mod(y, y^2 + 1)
  ? rnfeltdown(L, Mod(x, L.pol))
   ***   at top-level: rnfeltdown(L,Mod(x,x
   ***                 ^--------------------
   *** rnfeltdown: domain error in rnfeltdown: element not in the base field
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfeltdown</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfeltnorm"></a>
<h4>rnfeltnorm(<em>rnf</em>,x)</h4>
<p></p>
<p><em>rnf</em> being a relative number field extension L/K as output by
<code>rnfinit</code> and x being an element of L, returns the relative norm
N_{L/K}(x) as an element of K.</p>
<p>
<pre class="code">  ? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
  ? rnfeltnorm(L, Mod(x, L.pol))
  %2 = Mod(x, x^2 + Mod(-y, y^2 + 1))
  ? rnfeltnorm(L, 2)
  %3 = 4
  ? rnfeltnorm(L, Mod(x, x^2-y))
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfeltnorm</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfeltreltoabs"></a>
<h4>rnfeltreltoabs(<em>rnf</em>,x)</h4>
<p></p>
<p><em>rnf</em> being a relative
number field extension L/K as output by <code>rnfinit</code> and x being an
element of L expressed as a polynomial or polmod with polmod
coefficients, computes x as an element of the absolute extension L/<b>Q</b> as
a polynomial modulo the absolute equation <code><em>rnf</em>.pol</code>.</p>
<p>
<pre class="code">  ? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
  ? L.pol
  %2 = x^4 + 1
  ? rnfeltreltoabs(L, Mod(x, L.pol))
  %3 = Mod(x, x^4 + 1)
  ? rnfeltreltoabs(L, Mod(y, x^2-y))
  %4 = Mod(x^2, x^4 + 1)
  ? rnfeltreltoabs(L, Mod(y,K.pol))
  %5 = Mod(x^2, x^4 + 1)
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfeltreltoabs</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfelttrace"></a>
<h4>rnfelttrace(<em>rnf</em>,x)</h4>
<p></p>
<p><em>rnf</em> being a relative number field extension L/K as output by
<code>rnfinit</code> and x being an element of L, returns the relative trace
N_{L/K}(x) as an element of K.</p>
<p>
<pre class="code">  ? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
  ? rnfelttrace(L, Mod(x, L.pol))
  %2 = 0
  ? rnfelttrace(L, 2)
  %3 = 4
  ? rnfelttrace(L, Mod(x, x^2-y))
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfelttrace</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfeltup"></a>
<h4>rnfeltup(<em>rnf</em>,x)</h4>
<p></p>
<p><em>rnf</em> being a relative number field extension L/K as output by
<code>rnfinit</code> and x being an element of K, computes x as an element of
the absolute extension L/<b>Q</b> as a polynomial modulo the absolute equation
<code><em>rnf</em>.pol</code>.</p>
<p>
<pre class="code">  ? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
  ? L.pol
  %2 = x^4 + 1
  ? rnfeltup(L, Mod(y, K.pol))
  %4 = Mod(x^2, x^4 + 1)
  ? rnfeltup(L, y)
  %5 = Mod(x^2, x^4 + 1)
  ? rnfeltup(L, [1,2]~) \\ in terms of K.zk
  %6 = Mod(2*x^2 + 1, x^4 + 1)
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfeltup</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfequation"></a>
<h4>rnfequation(<em>nf</em>,<em>pol</em>,{<em>flag</em> = 0})</h4>
<p></p>
<p>Given a number field
<em>nf</em> as output by <code>nfinit</code> (or simply a polynomial) and a
polynomial <em>pol</em> with coefficients in <em>nf</em> defining a relative
extension L of <em>nf</em>, computes an absolute equation of L over
<b>Q</b>.</p>
<p>
The main variable of <em>nf</em> <em>must</em> be of lower priority than that
of <em>pol</em> (see Section [<b>Label: se:priority</b>]). Note that for efficiency, this does
not check whether the relative equation is irreducible over <em>nf</em>, but
only if it is squarefree. If it is reducible but squarefree, the result will
be the absolute equation of the &eacute;tale algebra defined by <em>pol</em>. If
<em>pol</em> is not squarefree, raise an <code>e_DOMAIN</code> exception.</p>
<p>
<pre class="code">  ? rnfequation(y^2+1, x^2 - y)
  %1 = x^4 + 1
  ? T = y^3-2; rnfequation(nfinit(T), (x^3-2)/(x-Mod(y,T)))
  %2 = x^6 + 108  \\ Galois closure of Q(2^(1/3))
</pre></p>
<p></p>
<p>
If <em>flag</em> is non-zero, outputs a 3-component row vector [z,a,k], where</p>
<p>
<b>*</b> z is the absolute equation of L over <b>Q</b>, as in the default
behavior,</p>
<p>
<b>*</b> a expresses as a <code>t_POLMOD</code> modulo z a root <font color=#FF0000>alpha</font> of the
polynomial defining the base field <em>nf</em>,</p>
<p>
<b>*</b> k is a small integer such that <font color=#FF0000>theta</font> = <font color=#FF0000>beta</font>+k<font color=#FF0000>alpha</font>
is a root of z, where <font color=#FF0000>beta</font> is a root of <em>pol</em>.</p>
<p>
<pre class="code">  ? T = y^3-2; pol = x^2 +x*y + y^2;
  ? [z,a,k] = rnfequation(T, pol, 1);
  ? z
  %4 = x^6 + 108
  ? subst(T, y, a)
  %5 = 0
  ? alpha= Mod(y, T);
  ? beta = Mod(x*Mod(1,T), pol);
  ? subst(z, x, beta + k*alpha)
  %8 = 0
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfequation0</b>(GEN nf, GEN pol, long flag)</code>.
Also available are
<code>GEN <b>rnfequation</b>(GEN nf, GEN pol)</code> (<em>flag</em> = 0) and
<code>GEN <b>rnfequation2</b>(GEN nf, GEN pol)</code> (<em>flag</em> = 1).</p>

<hr></hr>
<a name="rnfhnfbasis"></a>
<h4>rnfhnfbasis(<em>bnf</em>,x)</h4>
<p></p>
<p>Given <em>bnf</em> as output by
<code>bnfinit</code>, and either a polynomial x with coefficients in <em>bnf</em>
defining a relative extension L of <em>bnf</em>, or a pseudo-basis x of
such an extension, gives either a true <em>bnf</em>-basis of L in upper
triangular Hermite normal form, if it exists, and returns 0 otherwise.</p>
<p>
The library syntax is <code>GEN <b>rnfhnfbasis</b>(GEN bnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfidealabstorel"></a>
<h4>rnfidealabstorel(<em>rnf</em>,x)</h4>
<p></p>
<p>Let <em>rnf</em> be a relative
number field extension L/K as output by <code>rnfinit</code> and x be an ideal of
the absolute extension L/<b>Q</b> given by a <b>Z</b>-basis of elements of L.
Returns the relative pseudo-matrix in HNF giving the ideal x considered as
an ideal of the relative extension L/K, i.e.&nbsp;as a <b>Z</b>_K-module.</p>
<p>
The reason why the input does not use the customary HNF in terms of a fixed
<b>Z</b>-basis for <b>Z</b>_L is precisely that no such basis has been explicitly
specified. On the other hand, if you already computed an (absolute) <em>nf</em>
structure <code>Labs</code> associated to L, and m is in HNF, defining
an (absolute) ideal with respect to the <b>Z</b>-basis <code>Labs.zk</code>, then
<code>Labs.zk * m</code> is a suitable <b>Z</b>-basis for the ideal, and</p>
<p>
<pre class="code">    rnfidealabstorel(rnf, Labs.zk * m)
</pre>
converts m to a relative ideal.</p>
<p>
<pre class="code">  ? K = nfinit(y^2+1); L = rnfinit(K, x^2-y); Labs = nfinit(L.pol);
  ? m = idealhnf(Labs, 17, x^3+2);
  ? B = rnfidealabstorel(L, Labs.zk * m)
  %3 = [[1, 8; 0, 1], [[17, 4; 0, 1], 1]]  \\ pseudo-basis for m as Z_K-module
  ? A = rnfidealreltoabs(L, B)
  %4 = [17, x^2 + 4, x + 8, x^3 + 8*x^2]   \\ Z-basis for m in Q[x]/(L.pol)
  ? mathnf(matalgtobasis(Labs, A))
  %5 =
  [17 8 4 2]
  
  [ 0 1 0 0]
  
  [ 0 0 1 0]
  
  [ 0 0 0 1]
  ? % == m
  %6 = 1
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfidealabstorel</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfidealdown"></a>
<h4>rnfidealdown(<em>rnf</em>,x)</h4>
<p></p>
<p>Let <em>rnf</em> be a relative number
field extension L/K as output by <code>rnfinit</code>, and x an ideal of
L, given either in relative form or by a <b>Z</b>-basis of elements of L
(see Section [<b>Label: se:rnfidealabstorel</b>]). This function returns the ideal of K
below x, i.e.&nbsp;the intersection of x with K.</p>
<p>
The library syntax is <code>GEN <b>rnfidealdown</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfidealhnf"></a>
<h4>rnfidealhnf(<em>rnf</em>,x)</h4>
<p></p>
<p><em>rnf</em> being a relative number
field extension L/K as output by <code>rnfinit</code> and x being a relative
ideal (which can be, as in the absolute case, of many different types,
including of course elements), computes the HNF pseudo-matrix associated to
x, viewed as a <b>Z</b>_K-module.</p>
<p>
The library syntax is <code>GEN <b>rnfidealhnf</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfidealmul"></a>
<h4>rnfidealmul(<em>rnf</em>,x,y)</h4>
<p></p>
<p><em>rnf</em> being a relative number
field extension L/K as output by <code>rnfinit</code> and x and y being ideals
of the relative extension L/K given by pseudo-matrices, outputs the ideal
product, again as a relative ideal.</p>
<p>
The library syntax is <code>GEN <b>rnfidealmul</b>(GEN rnf, GEN x, GEN y)</code>.</p>

<hr></hr>
<a name="rnfidealnormabs"></a>
<h4>rnfidealnormabs(<em>rnf</em>,x)</h4>
<p></p>
<p>Let <em>rnf</em> be a relative
number field extension L/K as output by <code>rnfinit</code> and let x be a
relative ideal (which can be, as in the absolute case, of many different
types, including of course elements). This function computes the norm of the
x considered as an ideal of the absolute extension L/<b>Q</b>. This is
identical to</p>
<p>
<pre class="code">     idealnorm(rnf, rnfidealnormrel(rnf,x))
</pre>
but faster.</p>
<p>
The library syntax is <code>GEN <b>rnfidealnormabs</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfidealnormrel"></a>
<h4>rnfidealnormrel(<em>rnf</em>,x)</h4>
<p></p>
<p>Let <em>rnf</em> be a relative
number field extension L/K as output by <code>rnfinit</code> and let x be a
relative ideal (which can be, as in the absolute case, of many different
types, including of course elements). This function computes the relative
norm of x as an ideal of K in HNF.</p>
<p>
The library syntax is <code>GEN <b>rnfidealnormrel</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfidealreltoabs"></a>
<h4>rnfidealreltoabs(<em>rnf</em>,x)</h4>
<p></p>
<p>Let <em>rnf</em> be a relative
number field extension L/K as output by <code>rnfinit</code> and let x be a
relative ideal, given as a <b>Z</b>_K-module by a pseudo matrix [A,I].
This function returns the ideal x as an absolute ideal of L/<b>Q</b> in
the form of a <b>Z</b>-basis, given by a vector of polynomials (modulo
<code>rnf.pol</code>).</p>
<p>
The reason why we do not return the customary HNF in terms of a fixed
<b>Z</b>-basis for <b>Z</b>_L is precisely that no such basis has been explicitly
specified. On the other hand, if you already computed an (absolute) <em>nf</em>
structure <code>Labs</code> associated to L, then</p>
<p>
<pre class="code">    xabs = rnfidealreltoabs(L, x);
    xLabs = mathnf(matalgtobasis(Labs, xabs));
</pre>
computes a traditional HNF <code>xLabs</code> for x in terms of
the fixed <b>Z</b>-basis <code>Labs.zk</code>.</p>
<p>
The library syntax is <code>GEN <b>rnfidealreltoabs</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfidealtwoelt"></a>
<h4>rnfidealtwoelt(<em>rnf</em>,x)</h4>
<p></p>
<p><em>rnf</em> being a relative
number field extension L/K as output by <code>rnfinit</code> and x being an
ideal of the relative extension L/K given by a pseudo-matrix, gives a
vector of two generators of x over <b>Z</b>_L expressed as polmods with polmod
coefficients.</p>
<p>
The library syntax is <code>GEN <b>rnfidealtwoelement</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfidealup"></a>
<h4>rnfidealup(<em>rnf</em>,x)</h4>
<p></p>
<p>Let <em>rnf</em> be a relative number
field extension L/K as output by <code>rnfinit</code> and let x be an ideal of
K. This function returns the ideal x<b>Z</b>_L as an absolute ideal of L/<b>Q</b>,
in the form of a <b>Z</b>-basis, given by a vector of polynomials (modulo
<code>rnf.pol</code>).</p>
<p>
The reason why we do not return the customary HNF in terms of a fixed
<b>Z</b>-basis for <b>Z</b>_L is precisely that no such basis has been explicitly
specified. On the other hand, if you already computed an (absolute) <em>nf</em>
structure <code>Labs</code> associated to L, then</p>
<p>
<pre class="code">    xabs = rnfidealup(L, x);
    xLabs = mathnf(matalgtobasis(Labs, xabs));
</pre>
computes a traditional HNF <code>xLabs</code> for x in terms of
the fixed <b>Z</b>-basis <code>Labs.zk</code>.</p>
<p>
The library syntax is <code>GEN <b>rnfidealup</b>(GEN rnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfinit"></a>
<h4>rnfinit(<em>nf</em>,<em>pol</em>)</h4>
<p></p>
<p><em>nf</em> being a number field in <code>nfinit</code>
format considered as base field, and <em>pol</em> a polynomial defining a relative
extension over <em>nf</em>, this computes data to work in the
relative extension. The main variable of <em>pol</em> must be of higher priority
(see Section [<b>Label: se:priority</b>]) than that of <em>nf</em>, and the coefficients of
<em>pol</em> must be in <em>nf</em>.</p>
<p>
The result is a row vector, whose components are technical. In the following
description, we let K be the base field defined by <em>nf</em> and L/K
the large field associated to the <em>rnf</em>. Furthermore, we let
m = [K:<b>Q</b>] the degree of the base field, n = [L:K] the relative degree,
r_1 and r_2 the number of real and complex places of K. Acces to this
information via <em>member functions</em> is preferred since the specific
data organization specified below will change in the future.</p>
<p>
<em>rnf</em>[1](<code>rnf.pol</code>) contains the relative polynomial <em>pol</em>.</p>
<p>
<em>rnf</em>[2] contains the integer basis [A,d] of K, as
(integral) elements of L/<b>Q</b>. More precisely, A is a vector of
polynomial with integer coefficients, d is a denominator, and the integer
basis is given by A/d.</p>
<p>
<em>rnf</em>[3] (<code>rnf.disc</code>) is a two-component row vector
[<b>d</b>(L/K),s] where <b>d</b>(L/K) is the relative ideal discriminant
of L/K and s is the discriminant of L/K viewed as an element of
K^*/(K^*)^2, in other words it is the output of <code>rnfdisc</code>.</p>
<p>
<em>rnf</em>[4](<code>rnf.index</code>) is the ideal index <b>f</b>, i.e.&nbsp;such
that d(pol)<b>Z</b>_K = <b>f</b>^2<b>d</b>(L/K).</p>
<p>
<em>rnf</em>[5] is currently unused.</p>
<p>
<em>rnf</em>[6] is currently unused.</p>
<p>
<em>rnf</em>[7] (<code>rnf.zk</code>) is the pseudo-basis (A,I) for the maximal
order <b>Z</b>_L as a <b>Z</b>_K-module: A is the relative integral pseudo basis
expressed as polynomials (in the variable of pol) with polmod coefficients
in <em>nf</em>, and the second component I is the ideal list of the
pseudobasis in HNF.</p>
<p>
<em>rnf</em>[8] is the inverse matrix of the integral basis matrix, with
coefficients polmods in <em>nf</em>.</p>
<p>
<em>rnf</em>[9] is currently unused.</p>
<p>
<em>rnf</em>[10] (<code>rnf.nf</code>) is <em>nf</em>.</p>
<p>
<em>rnf</em>[11] is the output of <code>rnfequation(K, pol, 1)</code>. Namely, a
vector [P, a, k] describing the <em>absolute</em> extension
L/<b>Q</b>: P is an absolute equation, more conveniently obtained
as <code>rnf.polabs</code>; a expresses the generator <font color=#FF0000>alpha</font> = y mod <code>K.pol</code>
of the number field K as an element of L, i.e.&nbsp;a polynomial modulo the
absolute equation P;</p>
<p>
k is a small integer such that, if <font color=#FF0000>beta</font> is an abstract root of <em>pol</em>
and <font color=#FF0000>alpha</font> the generator of K given above, then P(<font color=#FF0000>beta</font> + k<font color=#FF0000>alpha</font>) = 0.</p>
<p>
<b>Caveat..</b> Be careful if k != 0 when dealing simultaneously with
absolute and relative quantities since L = <b>Q</b>(<font color=#FF0000>beta</font> + k<font color=#FF0000>alpha</font>) = 
K(<font color=#FF0000>alpha</font>), and the generator chosen for the absolute extension is not the
same as for the relative one. If this happens, one can of course go on
working, but we advise to change the relative polynomial so that its root
becomes <font color=#FF0000>beta</font> + k <font color=#FF0000>alpha</font>. Typical GP instructions would be</p>
<p>
<pre class="code">    [P,a,k] = rnfequation(K, pol, 1);
    if (k, pol = subst(pol, x, x - k*Mod(y, K.pol)));
    L = rnfinit(K, pol);
</pre></p>
<p></p>
<p>
<em>rnf</em>[12] is by default unused and set equal to 0. This field is used
to store further information about the field as it becomes available (which
is rarely needed, hence would be too expensive to compute during the initial
<code>rnfinit</code> call).</p>
<p>
The library syntax is <code>GEN <b>rnfinit</b>(GEN nf, GEN pol)</code>.</p>

<hr></hr>
<a name="rnfisabelian"></a>
<h4>rnfisabelian(<em>nf</em>,T)</h4>
<p></p>
<p>T being a relative polynomial with coefficients
in <em>nf</em>, return 1 if it defines an abelian extension, and 0 otherwise.</p>
<p>
<pre class="code">  ? K = nfinit(y^2 + 23);
  ? rnfisabelian(K, x^3 - 3*x - y)
  %2 = 1
</pre></p>
<p></p>
<p>
The library syntax is <code>long <b>rnfisabelian</b>(GEN nf, GEN T)</code>.</p>

<hr></hr>
<a name="rnfisfree"></a>
<h4>rnfisfree(<em>bnf</em>,x)</h4>
<p></p>
<p>Given <em>bnf</em> as output by
<code>bnfinit</code>, and either a polynomial x with coefficients in <em>bnf</em>
defining a relative extension L of <em>bnf</em>, or a pseudo-basis x of
such an extension, returns true (1) if L/<em>bnf</em> is free, false (0) if
not.</p>
<p>
The library syntax is <code>long <b>rnfisfree</b>(GEN bnf, GEN x)</code>.</p>

<hr></hr>
<a name="rnfisnorm"></a>
<h4>rnfisnorm(T,a,{<em>flag</em> = 0})</h4>
<p></p>
<p>Similar to
<code>bnfisnorm</code> but in the relative case. T is as output by
<code>rnfisnorminit</code> applied to the extension L/K. This tries to decide
whether the element a in K is the norm of some x in the extension
L/K.</p>
<p>
The output is a vector [x,q], where a = Norm(x)*q. The
algorithm looks for a solution x which is an S-integer, with S a list
of places of K containing at least the ramified primes, the generators of
the class group of L, as well as those primes dividing a. If L/K is
Galois, then this is enough; otherwise, <em>flag</em> is used to add more primes to
S: all the places above the primes p <code>&#60;=</code> <em>flag</em> (resp.&nbsp;p|<em>flag</em>) if <em>flag</em> &#62; 0
(resp.&nbsp;<em>flag</em> &#60; 0).</p>
<p>
The answer is guaranteed (i.e.&nbsp;a is a norm iff q = 1) if the field is
Galois, or, under GRH, if S contains all primes less than
12log^2|disc(M)|, where M is the normal
closure of L/K.</p>
<p>
If <code>rnfisnorminit</code> has determined (or was told) that L/K is
Galois, and <em>flag</em> != 0, a Warning is issued (so that you can set
<em>flag</em> = 1 to check whether L/K is known to be Galois, according to T).
Example:</p>
<p></p>
<p>
<pre class="code">  bnf = bnfinit(y^3 + y^2 - 2*y - 1);
  p = x^2 + Mod(y^2 + 2*y + 1, bnf.pol);
  T = rnfisnorminit(bnf, p);
  rnfisnorm(T, 17)
</pre></p>
<p>
checks whether 17 is a norm in the Galois extension <b>Q</b>(<font color=#FF0000>beta</font>) /
<b>Q</b>(<font color=#FF0000>alpha</font>), where <font color=#FF0000>alpha</font>^3 + <font color=#FF0000>alpha</font>^2 - 2<font color=#FF0000>alpha</font> - 1 = 0 and <font color=#FF0000>beta</font>^2 +
<font color=#FF0000>alpha</font>^2 + 2<font color=#FF0000>alpha</font> + 1 = 0 (it is).</p>
<p>
The library syntax is <code>GEN <b>rnfisnorm</b>(GEN T, GEN a, long flag)</code>.</p>

<hr></hr>
<a name="rnfisnorminit"></a>
<h4>rnfisnorminit(<em>pol</em>,<em>polrel</em>,{<em>flag</em> = 2})</h4>
<p></p>
<p>Let K be defined by a root of <em>pol</em>, and L/K the extension defined
by the polynomial <em>polrel</em>. As usual, <em>pol</em> can in fact be an <em>nf</em>,
or <em>bnf</em>, etc; if <em>pol</em> has degree 1 (the base field is <b>Q</b>),
polrel is also allowed to be an <em>nf</em>, etc. Computes technical data needed
by <code>rnfisnorm</code> to solve norm equations Nx = a, for x in L, and a
in K.</p>
<p>
If <em>flag</em> = 0, do not care whether L/K is Galois or not.</p>
<p>
If <em>flag</em> = 1, L/K is assumed to be Galois (unchecked), which speeds up
<code>rnfisnorm</code>.</p>
<p>
If <em>flag</em> = 2, let the routine determine whether L/K is Galois.</p>
<p>
The library syntax is <code>GEN <b>rnfisnorminit</b>(GEN pol, GEN polrel, long flag)</code>.</p>

<hr></hr>
<a name="rnfkummer"></a>
<h4>rnfkummer(<em>bnr</em>,{<em>subgp</em>},{d = 0})</h4>
<p></p>
<p><em>bnr</em>
being as output by <code>bnrinit</code>, finds a relative equation for the
class field corresponding to the module in <em>bnr</em> and the given
congruence subgroup (the full ray class field if <em>subgp</em> is omitted).
If d is positive, outputs the list of all relative equations of
degree d contained in the ray class field defined by <em>bnr</em>, with
the <em>same</em> conductor as (<em>bnr</em>, <em>subgp</em>).</p>
<p>
<b>Warning.</b> This routine only works for subgroups of prime index. It
uses Kummer theory, adjoining necessary roots of unity (it needs to compute a
tough <code>bnfinit</code> here), and finds a generator via Hecke's characterization
of ramification in Kummer extensions of prime degree. If your extension does
not have prime degree, for the time being, you have to split it by hand as a
tower / compositum of such extensions.</p>
<p>
The library syntax is <code>GEN <b>rnfkummer</b>(GEN bnr, GEN subgp = NULL, long d, long prec)</code>.</p>

<hr></hr>
<a name="rnflllgram"></a>
<h4>rnflllgram(<em>nf</em>,<em>pol</em>,<em>order</em>)</h4>
<p></p>
<p>Given a polynomial
<em>pol</em> with coefficients in <em>nf</em> defining a relative extension L and
a suborder <em>order</em> of L (of maximal rank), as output by
<code>rnfpseudobasis</code>(<em>nf</em>,<em>pol</em>) or similar, gives
[[<em>neworder</em>],U], where <em>neworder</em> is a reduced order and U is
the unimodular transformation matrix.</p>
<p>
The library syntax is <code>GEN <b>rnflllgram</b>(GEN nf, GEN pol, GEN order, long prec)</code>.</p>

<hr></hr>
<a name="rnfnormgroup"></a>
<h4>rnfnormgroup(<em>bnr</em>,<em>pol</em>)</h4>
<p></p>
<p><em>bnr</em> being a big ray
class field as output by <code>bnrinit</code> and <em>pol</em> a relative polynomial
defining an Abelian extension, computes the norm group (alias Artin
or Takagi group) corresponding to the Abelian extension of
<em>bnf</em> = <code>bnr.bnf</code>
defined by <em>pol</em>, where the module corresponding to <em>bnr</em> is assumed
to be a multiple of the conductor (i.e.&nbsp;<em>pol</em> defines a subextension of
bnr). The result is the HNF defining the norm group on the given generators
of <code>bnr.gen</code>. Note that neither the fact that <em>pol</em> defines an
Abelian extension nor the fact that the module is a multiple of the conductor
is checked. The result is undefined if the assumption is not correct.</p>
<p>
The library syntax is <code>GEN <b>rnfnormgroup</b>(GEN bnr, GEN pol)</code>.</p>

<hr></hr>
<a name="rnfpolred"></a>
<h4>rnfpolred(<em>nf</em>,<em>pol</em>)</h4>
<p></p>
<p>THIS FUNCTION IS OBSOLETE: use <code>rnfpolredbest</code> instead.
Relative version of <code>polred</code>. Given a monic polynomial <em>pol</em> with
coefficients in <em>nf</em>, finds a list of relative polynomials defining some
subfields, hopefully simpler and containing the original field. In the present
version <b>2.7.0</b>, this is slower and less efficient than <code>rnfpolredbest</code>.</p>
<p>
<b>Remark.</b> this function is based on an incomplete reduction
theory of lattices over number fields, implemented by <code>rnflllgram</code>, which
deserves to be improved.</p>
<p>
The library syntax is <code>GEN <b>rnfpolred</b>(GEN nf, GEN pol, long prec)</code>.</p>

<hr></hr>
<a name="rnfpolredabs"></a>
<h4>rnfpolredabs(<em>nf</em>,<em>pol</em>,{<em>flag</em> = 0})</h4>
<p></p>
<p>THIS FUNCTION IS OBSOLETE: use <code>rnfpolredbest</code> instead.
Relative version of <code>polredabs</code>. Given a monic polynomial <em>pol</em>
with coefficients in <em>nf</em>, finds a simpler relative polynomial defining
the same field. The binary digits of <em>flag</em> mean</p>
<p>
The binary digits of <em>flag</em> correspond to 1: add information to convert
elements to the new representation, 2: absolute polynomial, instead of
relative, 16: possibly use a suborder of the maximal order. More precisely:</p>
<p>
0: default, return P</p>
<p>
1: returns [P,a] where P is the default output and a,
a <code>t_POLMOD</code> modulo P, is a root of <em>pol</em>.</p>
<p>
2: returns <em>Pabs</em>, an absolute, instead of a relative, polynomial.
Same as but faster than</p>
<p>
<pre class="code">    rnfequation(nf, rnfpolredabs(nf,pol))
</pre></p>
<p></p>
<p>
3: returns [<em>Pabs</em>,a,b], where <em>Pabs</em> is an absolute polynomial
as above, a, b are <code>t_POLMOD</code> modulo <em>Pabs</em>, roots of <code>nf.pol</code>
and <em>pol</em> respectively.</p>
<p>
16: possibly use a suborder of the maximal order. This is slower than the
default when the relative discriminant is smooth, and much faster otherwise.
See Section [<b>Label: se:polredabs</b>].</p>
<p>
<b>Warning.</b> In the present implementation, <code>rnfpolredabs</code>
produces smaller polynomials than <code>rnfpolred</code> and is usually
faster, but its complexity is still exponential in the absolute degree.
The function <code>rnfpolredbest</code> runs in polynomial time, and  tends  to
return polynomials with smaller discriminants.</p>
<p>
The library syntax is <code>GEN <b>rnfpolredabs</b>(GEN nf, GEN pol, long flag)</code>.</p>

<hr></hr>
<a name="rnfpolredbest"></a>
<h4>rnfpolredbest(<em>nf</em>,<em>pol</em>,{<em>flag</em> = 0})</h4>
<p></p>
<p>Relative version of <code>polredbest</code>. Given a monic polynomial <em>pol</em>
with coefficients in <em>nf</em>, finds a simpler relative polynomial P
defining the same field. As opposed to <code>rnfpolredabs</code> this function does
not return a <em>smallest</em> (canonical) polynomial with respect to some
measure, but it does run in polynomial time.</p>
<p>
The binary digits of <em>flag</em> correspond to 1: add information to convert
elements to the new representation, 2: absolute polynomial, instead of
relative. More precisely:</p>
<p>
0: default, return P</p>
<p>
1: returns [P,a] where P is the default output and a,
a <code>t_POLMOD</code> modulo P, is a root of <em>pol</em>.</p>
<p>
2: returns <em>Pabs</em>, an absolute, instead of a relative, polynomial.
Same as but faster than</p>
<p>
<pre class="code">    rnfequation(nf, rnfpolredbest(nf,pol))
</pre></p>
<p></p>
<p>
3: returns [<em>Pabs</em>,a,b], where <em>Pabs</em> is an absolute polynomial
as above, a, b are <code>t_POLMOD</code> modulo <em>Pabs</em>, roots of <code>nf.pol</code>
and <em>pol</em> respectively.</p>
<p></p>
<p>
<pre class="code">  ? K = nfinit(y^3-2); pol = x^2 +x*y + y^2;
  ? [P, a] = rnfpolredbest(K,pol,1);
  ? P
  %3 = x^2 - x + Mod(y - 1, y^3 - 2)
  ? a
  %4 = Mod(Mod(2*y^2+3*y+4,y^3-2)*x + Mod(-y^2-2*y-2,y^3-2),
           x^2 - x + Mod(y-1,y^3-2))
  ? subst(K.pol,y,a)
  %5 = 0
  ? [Pabs, a, b] = rnfpolredbest(K,pol,3);
  ? Pabs
  %7 = x^6 - 3*x^5 + 5*x^3 - 3*x + 1
  ? a
  %8 = Mod(-x^2+x+1, x^6-3*x^5+5*x^3-3*x+1)
  ? b
  %9 = Mod(2*x^5-5*x^4-3*x^3+10*x^2+5*x-5, x^6-3*x^5+5*x^3-3*x+1)
  ? subst(K.pol,y,a)
  %10 = 0
  ? substvec(pol,[x,y],[a,b])
  %11 = 0
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>rnfpolredbest</b>(GEN nf, GEN pol, long flag)</code>.</p>

<hr></hr>
<a name="rnfpseudobasis"></a>
<h4>rnfpseudobasis(<em>nf</em>,<em>pol</em>)</h4>
<p></p>
<p>Given a number field
<em>nf</em> as output by <code>nfinit</code> and a polynomial <em>pol</em> with
coefficients in <em>nf</em> defining a relative extension L of <em>nf</em>,
computes a pseudo-basis (A,I) for the maximal order <b>Z</b>_L viewed as a
<b>Z</b>_K-module, and the relative discriminant of L. This is output as a
four-element row vector [A,I,D,d], where D is the relative ideal
discriminant and d is the relative discriminant considered as an element of
<em>nf</em>^*/{<em>nf</em>^*}^2.</p>
<p>
The library syntax is <code>GEN <b>rnfpseudobasis</b>(GEN nf, GEN pol)</code>.</p>

<hr></hr>
<a name="rnfsteinitz"></a>
<h4>rnfsteinitz(<em>nf</em>,x)</h4>
<p></p>
<p>Given a number field <em>nf</em> as
output by <code>nfinit</code> and either a polynomial x with coefficients in
<em>nf</em> defining a relative extension L of <em>nf</em>, or a pseudo-basis
x of such an extension as output for example by <code>rnfpseudobasis</code>,
computes another pseudo-basis (A,I) (not in HNF in general) such that all
the ideals of I except perhaps the last one are equal to the ring of
integers of <em>nf</em>, and outputs the four-component row vector [A,I,D,d]
as in <code>rnfpseudobasis</code>. The name of this function comes from the fact
that the ideal class of the last ideal of I, which is well defined, is the
Steinitz class of the <b>Z</b>_K-module <b>Z</b>_L (its image in SK_0(<b>Z</b>_K)).</p>
<p>
The library syntax is <code>GEN <b>rnfsteinitz</b>(GEN nf, GEN x)</code>.</p>

<hr></hr>
<a name="subgrouplist"></a>
<h4>subgrouplist(<em>bnr</em>,{<em>bound</em>},{<em>flag</em> = 0})</h4>
<p></p>
<p><em>bnr</em> being as output by <code>bnrinit</code> or a list of cyclic components
of a finite Abelian group G, outputs the list of subgroups of G. Subgroups
are given as HNF left divisors of the SNF matrix corresponding to G.</p>
<p>
If <em>flag</em> = 0 (default) and <em>bnr</em> is as output by <code>bnrinit</code>, gives
only the subgroups whose modulus is the conductor. Otherwise, the modulus is
not taken into account.</p>
<p>
If <em>bound</em> is present, and is a positive integer, restrict the output to
subgroups of index less than <em>bound</em>. If <em>bound</em> is a vector
containing a single positive integer B, then only subgroups of index
exactly equal to B are computed. For instance</p>
<p>
<pre class="code">  ? subgrouplist([6,2])
  %1 = [[6, 0; 0, 2], [2, 0; 0, 2], [6, 3; 0, 1], [2, 1; 0, 1], [3, 0; 0, 2],
  [1, 0; 0, 2], [6, 0; 0, 1], [2, 0; 0, 1], [3, 0; 0, 1], [1, 0; 0, 1]]
  ? subgrouplist([6,2],3)    \\  index less than 3
  %2 = [[2, 1; 0, 1], [1, 0; 0, 2], [2, 0; 0, 1], [3, 0; 0, 1], [1, 0; 0, 1]]
  ? subgrouplist([6,2],[3])  \\  index 3
  %3 = [[3, 0; 0, 1]]
  ? bnr = bnrinit(bnfinit(x), [120,[1]], 1);
  ? L = subgrouplist(bnr, [8]);
</pre></p>
<p>
In the last example, L corresponds to the 24 subfields of
<b>Q</b>(<font color=#FF0000>zeta</font>_{120}), of degree 8 and conductor 120 oo  (by setting <em>flag</em>,
we see there are a total of 43 subgroups of degree 8).</p>
<p>
<pre class="code">  ? vector(#L, i, galoissubcyclo(bnr, L[i]))
</pre></p>
<p>
will produce their equations. (For a general base field, you would
have to rely on <code>bnrstark</code>, or <code>rnfkummer</code>.)</p>
<p>
The library syntax is <code>GEN <b>subgrouplist0</b>(GEN bnr, GEN bound = NULL, long flag)</code>.</p>

<hr></hr>
<a name="zetak"></a>
<h4>zetak(<em>nfz</em>,x,{<em>flag</em> = 0})</h4>
<p></p>
<p><em>znf</em> being a number
field initialized by <code>zetakinit</code> (<em>not</em> by <code>nfinit</code>),
computes the value of the Dedekind zeta function of the number
field at the complex number x. If <em>flag</em> = 1 computes Dedekind <font color=#FF0000>Lambda</font>
function instead (i.e.&nbsp;the product of the Dedekind zeta function by its gamma
and exponential factors).</p>
<p>
<b>CAVEAT.</b> This implementation is not satisfactory and must be
rewritten. In particular</p>
<p>
<b>*</b> The accuracy of the result depends in an essential way on the
accuracy of both the <code>zetakinit</code> program and the current accuracy.
Be wary in particular that x of large imaginary part or, on the
contrary, very close to an ordinary integer will suffer from precision
loss, yielding fewer significant digits than expected. Computing with 28
digits of relative accuracy, we have</p>
<p>
<pre class="code">  ? zeta(3)
  %1 = 1.202056903159594285399738161
  ? zeta(3-1e-20)
  %2 = 1.202056903159594285401719424
  ? zetak(zetakinit(x), 3-1e-20)
  %3 = 1.2020569031595952919  \\ 5 digits are wrong
  ? zetak(zetakinit(x), 3-1e-28)
  %4 = -25.33411749           \\ junk
</pre></p>
<p></p>
<p>
<b>*</b> As the precision increases, results become unexpectedly
completely wrong:</p>
<p>
<pre class="code">  ? \p100
  ? zetak(zetakinit(x^2-5), -1) - 1/30
  %1 = 7.26691813 E-108    \\ perfect
  ? \p150
  ? zetak(zetakinit(x^2-5), -1) - 1/30
  %2 = -2.486113578 E-156  \\ perfect
  ? \p200
  ? zetak(zetakinit(x^2-5), -1) - 1/30
  %3 = 4.47... E-75        \\ more than half of the digits are wrong
  ? \p250
  ? zetak(zetakinit(x^2-5), -1) - 1/30
  %4 = 1.6 E43             \\ junk
</pre></p>
<p></p>
<p>
The library syntax is <code>GEN <b>gzetakall</b>(GEN nfz, GEN x, long flag, long prec)</code>.
See also <code>GEN <b>glambdak</b>(GEN znf, GEN x, long prec)</code> or
<code>GEN <b>gzetak</b>(GEN znf, GEN x, long prec)</code>.</p>

<hr></hr>
<a name="zetakinit"></a>
<h4>zetakinit(<em>bnf</em>)</h4>
<p></p>
<p>Computes a number of initialization data
concerning the number field associated to <code>bnf</code> so as to be able
to compute the Dedekind zeta and lambda functions, respectively
<code>zetak</code>(x) and <code>zetak</code>(x,1), at the current real precision. If
you do not need the <code>bnfinit</code> data somewhere else, you may call it
with an irreducible polynomial instead of a <em>bnf</em>: it will call
<code>bnfinit</code> itself.</p>
<p>
The result is a 9-component vector v whose components are very technical
and cannot really be used except through the <code>zetak</code> function.</p>
<p>
This function is very inefficient and should be rewritten. It needs to
computes millions of coefficients of the corresponding Dirichlet series if
the precision is big. Unless the discriminant is small it will not be able
to handle more than 9 digits of relative precision. For instance,
<code>zetakinit(x^8 - 2)</code> needs 440MB of memory at default precision.</p>
<p>
This function will fail with the message</p>
<p>
<pre class="code">   *** bnrL1: overflow in zeta_get_N0 [need too many primes].
</pre>
if the approximate functional equation requires us to sum
too many terms (if the discriminant of the number field is too large).</p>
<p>
The library syntax is <code>GEN <b>initzeta</b>(GEN bnf, long prec)</code>.</p>
<p></p>

<hr></hr>

</BODY>
</HTML>
