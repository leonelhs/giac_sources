<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="casrouge.css">
<TITLE>Codage</TITLE>
</HEAD>
<BODY >
<A HREF="casrouge011.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="casrouge013.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc292">Chapitre 12</A>  Codage</H1><H2 CLASS="section"><A NAME="toc83"></A><A NAME="htoc293">12.1</A>  Codage de Jules Cesar</H2><P><A NAME="sec:Cesar"></A>
</P><H3 CLASS="subsection"><A NAME="htoc294">12.1.1</A>  Introduction</H3><P>
Le principe est simple : on écrit un message en n’utilisant que les 26 
lettres de l’alphabet et on le code en remplacant une lettre par une autre 
lettre.
Ceci peut être considéré comme une application <I>f</I> de l’ensemble 
des lettres {A,B,C,...X,Y,Z} dans lui-même.<BR>
Pour pouvoir décoder, il faut que l’application <I>f</I> ci-dessus soit 
bijective!<BR>
Il parait que Jules César utilisait cette méthode pour communiquer ses 
ordres.
</P><H3 CLASS="subsection"><A NAME="htoc295">12.1.2</A>  Codage par symétrie point ou par rotation d’angle π</H3><P><A NAME="sec:symp"></A>
Une façon simple de coder est la suivante :<BR>
on écrit les lettres sur un cercle (de façon équirépartie) et on 
remplace chaque lettre par la lettre symétrique par rapport au centre du 
cercle :</P><P><IMG SRC="casrouge007.png"></P><P>Le décodage s’obtient de la même façon car ici <I>f</I> ∘ <I>f</I>=<I>Id</I> </P><H3 CLASS="subsection"><A NAME="htoc296">12.1.3</A>  Avec les élèves</H3><P>
On explique que l’on va coder un message en remplacant une lettre par une autre
(on suppose que le message n’utilise que les 26 lettres de l’alphabet et que 
l’on n’écrit pas les espaces).<BR>
Pour cela on distribue une feuille sur laquelle figure quatre cercles divisés
en 26 parties égales.<BR>
 On écrit sur ce cercle les 26 lettres de l’alphabet et le codage consiste 
à remplacer chaque lettre du message par la lettre diamétralement opposéesur le cercle.<BR>
Par exemple voici le message à coder selon cette méthode :<BR>
"BONJOURLESAMIS"<BR>
Le message à décoder est donc :<BR>
"OBAWBHEYRFNZVF"<BR>
Quel sont les éléments pertinents qu’il faut transmettre pour que le
décodage soit possible ?<BR>
Parmi les réponses il est apparu qu’il fallait ajouter +13 pour décoder.<BR>
Puis chaque élève invente un codage et écrit un message selon son codage
et le donne à décoder à son voisin, par écrit avec les explications 
nécessaires pour le décoder.<BR>
Voici quelques codages obtenus :<BR>
- codage obtenu en remplacant chaque lettre par celle qui la suit dans 
l’alphabet,<BR>
- codage obtenu en remplacant chaque lettre par celle qui est obtenue en 
avançant de +4 sur la roue (ou en reculant de 3 etc...),<BR>
- codage obtenu en remplaçant chaque lettre par celle qui est obtenue
par symétrie par rapport à la droite [A,N] (verticale sur le dessin),ou par 
symétrie par rapport à la droite horizontale sur le dessin,<BR>
- codage par symétrie par rapport au centre du cercle mais où l’ordre des 
lettres sur le cercle n’est pas respecté,<BR>
- d’autres codages comme de remplacer le message par une suite de nombres 
(intéressant mais cela ne repond pas à la question posée),<BR>
- codage qui dépend de la position de la lettre dans le message. Ce codage
n’est pas une application puisque une même lettre peut avoir des codages 
différents.<BR>
Combien y-a-t-il de codages (i.e de bijections) possibles ?<BR>
Il a fallut parler de bijections :<BR>
un étudiant a dit qu’il fallait que deux lettres différentes soient codées par
des lettres différentes pour que le décodage soit possible (injection).<BR>
Ceci entraine que toutes les lettres sont le codage d’une autre lettre
(surjection).<BR>
Pour simplifier on a préféré parler de permutations des lettres avec comme
exemple : trouver tous les codages possibles si on suppose que l’alphabet 
utilisé ne comporte que les trois lettres A, B, C.<BR>
Donnez un ordre de grandeur de 26!<BR>
A supposer que vous vouliez écrire les 26! codages possibles sur un cahier et
que votre rythme est de 1 codage par seconde (vous êtes super rapide !!!...
félicitations !!!) combien de temps (réponse en heures, en mois, en années...?) 
vous faut-il ?<BR>
Combien de cahiers de 10000 lignes (200 pages de 50 lignes) vous faut-il ? 
Donner la longueur occupée par ces cahiers dans une bibliothèque, si chaque
cahier occupe 1 cm. 
Combien y-a-t-il de codages involutifs possibles qui sont sans point double 
(c’est à dire de bijections <I>f</I>
vérifiant <I>f</I>=<I>f</I><SUP>−1</SUP> et <I>f</I>(<I>x</I>)≠ <I>x</I>  pour tout <I>x</I>) ?<BR>
Comment faire pour que la clé du décodage soit simple ?
</P><H3 CLASS="subsection"><A NAME="htoc297">12.1.4</A>  Travail dans Z/26Z</H3><P>
Le codage de Jules César consiste à faire une symétrie point ou encore 
une rotation d’angle π.<BR>
Si on numérote les lettres de 0 à 25, le codage consiste donc à faire 
une addition de 13 (modulo 26). 
(voir figure <A HREF="#sec:symp">12.1.2</A>).<BR>
<B>Exemple</B> :<BR>
"BONJOUR" sera codé par "OBAWBHE"</P><H3 CLASS="subsection"><A NAME="htoc298">12.1.5</A>  Codage par rotation d’angle α=<I>k</I>*π/13</H3><P><A NAME="sec:rotn"></A>
Le principe est le même :<BR>
on écrit les lettres sur un cercle (de façon équirépartie) et on remplace 
chaque lettre par la lettre obtenue par rotation d’angle 
α=<I>k</I>*π/13 (0≤  <I>k</I> ≤  25) (k est un entier).<BR>
Si on numérote les lettres de 0 à 25, le codage consiste donc à faire subir
à chaque lettre un décalage de <TT>k</TT> c’est à dire à faire subir à son 
numéro une addition de <TT>k</TT> (modulo 26) (voir figure <A HREF="#sec:rotn">12.1.5</A>).<BR>
On remarquera que si le paramètre de codage par rotation est <TT>k</TT>, le 
décodage sera un codage par rotation de paramètre <TT>-k</TT> ou encore
<TT>26-k</TT>.</P><P><IMG SRC="casrouge008.png">
</P><H2 CLASS="section"><A NAME="toc84"></A><A NAME="htoc299">12.2</A>  Écriture des programmes correspondants</H2><H3 CLASS="subsection"><A NAME="htoc300">12.2.1</A>  Passage d’une lettre à un entier entre 0 et 25</H3><P><A NAME="@default89"></A>
À chaque lettre on peut faire correspondre son code ASCII.<BR>
Avec <TT>Xcas</TT>, <TT>asc("A")=[65]</TT> et <TT>asc("BON")=[66,79,78]</TT>.<BR>
 Donc pour avoir un entier entre 
0 et 25 il suffit de retrancher 65 :<BR>
 <TT>asc("A")-65</TT> (<TT>=0</TT>) ou <TT>asc("BON")-[65,65,65]</TT> (<TT>=[1,14,13]</TT>).<BR>
On écrit donc la procédure <TT>c2n</TT> qui transforme une chaîne de caractères 
<TT>m</TT> en une liste d’entiers <TT>l=c2n(m)</TT> entre 0 et 25 (le 2 de <TT>c2n</TT> veut dire "to" ou "vers" en français).<BR>
Il faut créer une liste formée des nombres <TT>65</TT> et de même longueur que le message avec <TT>makelist(65,1,size(m))</TT>.<BR>
On écrit :
</P><PRE CLASS="verbatim">c2n(m):={
return(asc(m)-makelist(65,1,size(m)));
}
</PRE><P><B>Exemple</B> :<BR>
<TT>c2n("BONJOUR")=[1,14,13,9,14,20,17]</TT>
</P><H3 CLASS="subsection"><A NAME="htoc301">12.2.2</A>  Passage d’un entier entre 0 et 25 à une lettre</H3><P><A NAME="@default90"></A>
À chaque entier <I>n</I> compris entre 0 et 25, on fait correspondre la 
(<I>n</I>−1)<SUP><I>ieme</I></SUP> lettre en majuscule de l’alphabet (à 0 correspond "A", 
‘a 1 correspond "B" etc...).<BR>
Avec <TT>Xcas</TT>, <TT>char(65)="A"</TT> et <TT>char([66,79,78])="BON"</TT>.<BR>
On écrit donc la procédure <TT>n2c</TT> qui transforme une liste d’entiers 
<TT>l</TT>
entre 0 et 25 en une chaîne de caractères <TT>m</TT>.<BR>
Il faut penser à ajouter <TT>65</TT> à tous les éléments de la liste 
<TT>l</TT> (on forme une liste formée de <TT>65</TT> avec la fonction 
<TT>makelist</TT> :
<TT>l+makelist(65,1,size(l))</TT>).<BR>
On écrit :
</P><PRE CLASS="verbatim">n2c(l):={
return(char(l+makelist(65,1,size(l))));
}
</PRE><P><B>Exemple</B> :<BR>
<TT>n2c([1,14,13,9,14,20,17])="BONJOUR"</TT> 
</P><H3 CLASS="subsection"><A NAME="htoc302">12.2.3</A>  Passage d’un entier k entre 0 et 25 à l’entier n+k mod 26</H3><P>
On écrit donc la procédure <TT>decal</TT> de paramètres <TT>n</TT> et <TT>l</TT> qui 
transforme une liste <TT>l</TT> d’entiers <TT>k</TT> entre 0 et 25 en la liste d’entiers 
<TT><I>n</I>+<I>k</I>  <I>mod</I> 26</TT>.<BR>
On écrit :
</P><PRE CLASS="verbatim">decal(n,l):={
return(irem(l+makelist(n,1,size(l)),26));
}
</PRE><P><B>Exemple</B> :<BR>
<TT>decal(13,[1,14,13,9,14,20,17])=[14,1,0,22,1,7,4]</TT>
</P><H3 CLASS="subsection"><A NAME="htoc303">12.2.4</A>  Codage d’un message selon Jules César</H3><P>
On écrit la procédure finale <TT>CESAR</TT> qui a deux paramètres :<BR>
l’entier <TT>n</TT> de décalage et le message <TT>m</TT>.<BR>
On écrit :
</P><PRE CLASS="verbatim">cesar(n,m):={
return(n2c(decal(n,c2n(m))));
}
</PRE><P><B>Exemple</B> :<BR>
<TT>cesar(13,"BONJOUR")="OBAWBHE"</TT>
</P><H2 CLASS="section"><A NAME="toc85"></A><A NAME="htoc304">12.3</A>  Codage en utilisant une symétrie par rapport à un axe</H2><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 12.1: Codage par symétrie par rapport à Ox</TD></TR>
</TABLE></DIV><A NAME="sec:symd"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE><H3 CLASS="subsection"><A NAME="htoc305">12.3.1</A>  Passage d’un entier k entre 0 et 25 à l’entier n-k mod 26</H3><P>
On reprend les procédures <TT>c2n</TT> et <TT>n2c</TT> vues précédemment :<BR>
<TT>c2n</TT> transforme une chaîne
de caractères <TT>m</TT> en une liste d’entiers entre 0 et 25 et <TT>n2c</TT> 
transforme une liste <TT>l</TT> d’entiers entre
0 et 25 en une chaîne de caractères <TT>m</TT>.<BR>
On écrit ensuite la procédure <TT>sym</TT> de paramètres <TT>n</TT> et <TT>l</TT> qui
transforme une liste <TT>l</TT> d’entiers <TT>k</TT> entre 0 et 25 en la liste 
d’entiers <TT><I>n</I>-<I>k</I> <I>mod</I> 26</TT>.
On peut considérer que le paramètre <TT>n</TT> détermine le diamètre <TT>D</TT>
perpendiculaire à la corde <TT>[0,n]</TT> (joignant <TT>A</TT> à la <TT>(n-1)ième</TT> lettre).<BR>
La procédure <TT>sym</TT> de paramètre 
<TT>n</TT> est donc une symétrie par rapport à la droite <TT>D</TT>.<BR>
On écrit :
</P><PRE CLASS="verbatim">sym(n,l):={
return(irem(makelist(n,1,size(l))-l,26));
}
</PRE><H3 CLASS="subsection"><A NAME="htoc306">12.3.2</A>  Codage d’un message selon une symétrie droite D</H3><P>
On écrit la procédure finale <TT>cesarsym</TT> qui a deux paramètres :<BR>
l’entier <TT>n</TT> (définissant la corde <TT>[0,n]</TT> normale au diamètre <TT>D</TT>)
et le message <TT>m</TT>.<BR>
On écrit :
</P><PRE CLASS="verbatim">cesarsym(n,m):={
return(n2c(sym(n,c2n(m))));
}
</PRE><P><B>Exemple</B> :<BR>
Si on prend <TT>n=13</TT> on réalise une symétrie par rapport à la droite <TT>Ox</TT>
(cf figure <A HREF="#sec:symd">12.1</A>).<BR>
<TT>cesarsym(13,"BONJOUR")="MZAEZTW"</TT>
</P><H2 CLASS="section"><A NAME="toc86"></A><A NAME="htoc307">12.4</A>  Codage en utilisant une application affine</H2><P>
Comme précédemment, on écrit la procédure <TT>c2n</TT> qui transforme une chaîne
de caractères <TT>m</TT> en une liste d’entiers entre 0 et 25 et on écrit 
la procédure <TT>n2c</TT> qui transforme une liste <TT>l</TT> d’entiers entre 
0 et 25 en une chaîne de caractères <TT>m</TT>.<BR>
On écrit ensuite la procédure <TT>affine</TT> de paramètre <TT>a,b,l</TT> qui
transforme une liste <TT>l</TT> d’entiers <TT>k</TT> entre 0 et 25 en la liste 
d’entiers <TT><I>a</I>*<I>k</I>+<I>b</I> <I>mod</I> 26</TT>.<BR>
On écrit :
</P><PRE CLASS="verbatim">affine(a,b,l):={
return(irem((a*l+makelist(b,1,size(l))),26));
}
</PRE><P>On écrit ensuite :
</P><PRE CLASS="verbatim">cesaraffine(a,b,m):={
return(n2c(affine(a,b,c2n(m))));
}
</PRE><P>Question :<BR>
Pour quelles valeurs de <I>a</I> et <I>b</I> le codage obtenu par <TT>cesaraffine</TT> peut-il être décodé ?</P><H2 CLASS="section"><A NAME="toc87"></A><A NAME="htoc308">12.5</A>  Codage en utilisant un groupement de deux lettres</H2><P>
On écrit la procédure <TT>c2n2</TT> qui transforme une chaîne de caractères
<TT>m</TT> en une liste <TT>l</TT> d’entiers entre 0 et 26<SUP>2</SUP>−1=675 :<BR>
On fait des groupements de deux lettres (quitte à terminer le message par la 
lettre "F" pour avoir un nombre pair de lettres), chaque groupement est
considéré comme l’écriture en base 26 d’un entier en utilisant comme 
"chiffre" les lettres majuscules. Ainsi, <TT>"BC"</TT> est l’écriture en base 26 de 28 (28=1*26+2).<BR>
On écrit :
</P><PRE CLASS="verbatim">c2n2(m):={
local s,lr,l,n;
s:=size(m);
if (irem(s,2)==1){
m:=append(m,"F");
s:=s+1;
}
lr:=[];
l:=asc(m);
for (k:=0;k&lt;s;k:=k+2){
n:=l[k]*26+l[k+1];
lr:=append(lr,n);
}
return(lr);
}
</PRE><P>On écrit ensuite la procédure <TT>n2c2</TT> qui transforme une liste 
d’entiers 
entre 0 et 675 (675=25*26+25=26*26-1) en une chaîne de caractères 
<TT>m</TT> :<BR>
chaque entier étant écrit en base 26 avec comme "symboles" les 26 lettres 
majuscules.<BR>
On écrit :
</P><PRE CLASS="verbatim">n2c2(l):={
local s,n,m;
s:=size(l);
m:="";
for (k:=0;k&lt;s;k++){
n:=l[k];
m:=append(m,char(iquo(n,26)+65));
m:=append(m,char(irem(n,26)+65));
}
return(m);
}
</PRE><P>On écrit ensuite la fonction <TT>affin2</TT> de paramètre <TT>a,b,l</TT> qui
transforme une liste <TT>l</TT> d’entiers <TT>k</TT> entre 0 et 675 en la liste 
d’entiers <TT><I>a</I>*<I>k</I>+<I>b</I> <I>mod</I> 676</TT> (entiers encore compris entre 0 et 675).<BR>
On écrit :
</P><PRE CLASS="verbatim">affin2(a,b,l):={
local s;
s:=size(l);
for (k:=0;k&lt;s;k++){
l[k]:=irem(a*l[k]+b,676);
}
return(l);
}
</PRE><P>On écrit ensuite la fonction <TT>cesar2</TT> qui réalise le codage par 
groupement de 2 lettres utilisant l’application affine <TT>affin2</TT>:
</P><PRE CLASS="verbatim">cesar2(a,b,m):={
return(n2c2(affin2(a,b,c2n2(m))));
}
</PRE><P><B>Question</B> :<BR>
Pour quelles valeurs <I>a</I>1 de <I>a</I> et <I>b</I>1 de <I>b</I>, le codage obtenu par 
<TT>cesaraffine</TT> peut-il être décodé ?<BR>
<B>Réponse</B> :<BR>
On doit avoir <I>a</I>1*(<I>a</I>*<I>n</I>+<I>b</I>)+<I>b</I>1=<I>a</I>1*<I>a</I>*<I>n</I>+<I>a</I>1*<I>b</I>+<I>b</I>1=<I>n</I>.<BR>
Il suffit donc de prendre : <I>b</I>1=−<I>a</I>1*<I>b</I> mod676 et <I>a</I>1*<I>a</I>=1 mod676
</P><H2 CLASS="section"><A NAME="toc88"></A><A NAME="htoc309">12.6</A>  Le codage Jules César et le codage linéaire</H2><H3 CLASS="subsection"><A NAME="htoc310">12.6.1</A>  Les caractères et leurs codes</H3><P><A NAME="sec:code"></A>
Ici, on ne se borne plus aux 26 lettres de l’alphabet, mais on veut pouvoir 
utiliser les 101 caractères de la table ci-dessous.<BR>
Dans cette table, on a le code du caractère, puis, le caractère : ainsi
"5" a pour code 21 et "R" a pour code 50 et l’espace " " a pour code 0.<BR><BR>

</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> 0</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP> 1  !</TD><TD ALIGN=left NOWRAP> 2  "</TD><TD ALIGN=left NOWRAP> 3 #</TD><TD ALIGN=left NOWRAP> 4 $</TD><TD ALIGN=left NOWRAP> 5 %</TD><TD ALIGN=left NOWRAP> 6 &amp;</TD><TD ALIGN=left NOWRAP> 7  ’</TD><TD ALIGN=left NOWRAP> 8 (</TD><TD ALIGN=left NOWRAP> 9 )</TD><TD ALIGN=left NOWRAP>10 *</TD></TR>
<TR><TD ALIGN=left NOWRAP>11 +</TD><TD ALIGN=left NOWRAP>12 ,</TD><TD ALIGN=left NOWRAP>13 -</TD><TD ALIGN=left NOWRAP>14 .</TD><TD ALIGN=left NOWRAP>15 /</TD><TD ALIGN=left NOWRAP>16 0</TD><TD ALIGN=left NOWRAP>17 1</TD><TD ALIGN=left NOWRAP>18 2</TD><TD ALIGN=left NOWRAP>19 3</TD><TD ALIGN=left NOWRAP>20 4</TD></TR>
<TR><TD ALIGN=left NOWRAP>21 5</TD><TD ALIGN=left NOWRAP>22 6</TD><TD ALIGN=left NOWRAP>23 7</TD><TD ALIGN=left NOWRAP>24 8</TD><TD ALIGN=left NOWRAP>25 9</TD><TD ALIGN=left NOWRAP>26 :</TD><TD ALIGN=left NOWRAP>27  ;</TD><TD ALIGN=left NOWRAP>28 &lt;</TD><TD ALIGN=left NOWRAP>29 =</TD><TD ALIGN=left NOWRAP>30 &gt;</TD></TR>
<TR><TD ALIGN=left NOWRAP>31 ?</TD><TD ALIGN=left NOWRAP>32 @</TD><TD ALIGN=left NOWRAP>33 A</TD><TD ALIGN=left NOWRAP>34 B</TD><TD ALIGN=left NOWRAP>35 C</TD><TD ALIGN=left NOWRAP>36 D</TD><TD ALIGN=left NOWRAP>37 E</TD><TD ALIGN=left NOWRAP>38 F</TD><TD ALIGN=left NOWRAP>39 G</TD><TD ALIGN=left NOWRAP>40 H</TD></TR>
<TR><TD ALIGN=left NOWRAP>41 I</TD><TD ALIGN=left NOWRAP>42 J</TD><TD ALIGN=left NOWRAP>43 K</TD><TD ALIGN=left NOWRAP>44 L</TD><TD ALIGN=left NOWRAP>45 M</TD><TD ALIGN=left NOWRAP>46 N</TD><TD ALIGN=left NOWRAP>47 O</TD><TD ALIGN=left NOWRAP>48 P</TD><TD ALIGN=left NOWRAP>49 Q</TD><TD ALIGN=left NOWRAP>50 R</TD></TR>
<TR><TD ALIGN=left NOWRAP>51 S</TD><TD ALIGN=left NOWRAP>52 T</TD><TD ALIGN=left NOWRAP>53 U</TD><TD ALIGN=left NOWRAP>54 V</TD><TD ALIGN=left NOWRAP>55 W</TD><TD ALIGN=left NOWRAP>56 X</TD><TD ALIGN=left NOWRAP>57 Y</TD><TD ALIGN=left NOWRAP>58 Z</TD><TD ALIGN=left NOWRAP>59 [</TD><TD ALIGN=left NOWRAP>60 \</TD></TR>
<TR><TD ALIGN=left NOWRAP>61 ]</TD><TD ALIGN=left NOWRAP>62 &63 _</TD><TD ALIGN=left NOWRAP>64 ‘</TD><TD ALIGN=left NOWRAP>65 a</TD><TD ALIGN=left NOWRAP>66 b</TD><TD ALIGN=left NOWRAP>67 c</TD><TD ALIGN=left NOWRAP>68 d</TD><TD ALIGN=left NOWRAP>69 e</TD><TD ALIGN=left NOWRAP>70 f</TD></TR>
<TR><TD ALIGN=left NOWRAP>71 g</TD><TD ALIGN=left NOWRAP>72 h</TD><TD ALIGN=left NOWRAP>73 i</TD><TD ALIGN=left NOWRAP>74 j</TD><TD ALIGN=left NOWRAP>75 k</TD><TD ALIGN=left NOWRAP>76 l</TD><TD ALIGN=left NOWRAP>77 m</TD><TD ALIGN=left NOWRAP>78 n</TD><TD ALIGN=left NOWRAP>79 o</TD><TD ALIGN=left NOWRAP>80 p</TD></TR>
<TR><TD ALIGN=left NOWRAP>81 q</TD><TD ALIGN=left NOWRAP>82 r</TD><TD ALIGN=left NOWRAP>83 s</TD><TD ALIGN=left NOWRAP>84 t</TD><TD ALIGN=left NOWRAP>85 u</TD><TD ALIGN=left NOWRAP>86 v</TD><TD ALIGN=left NOWRAP>87 w</TD><TD ALIGN=left NOWRAP>88 x</TD><TD ALIGN=left NOWRAP>89 y</TD><TD ALIGN=left NOWRAP>90 z</TD></TR>
<TR><TD ALIGN=left NOWRAP>91 {</TD><TD ALIGN=left NOWRAP>92 |</TD><TD ALIGN=left NOWRAP>93 }</TD><TD ALIGN=left NOWRAP>94 &95 ê</TD><TD ALIGN=left NOWRAP>96 ù</TD><TD ALIGN=left NOWRAP>97 ç</TD><TD ALIGN=left NOWRAP>98 à</TD><TD ALIGN=left NOWRAP>99 è</TD><TD ALIGN=left NOWRAP>100 é</TD></TR>
</TABLE><P><BR>
</P><H3 CLASS="subsection"><A NAME="htoc311">12.6.2</A>  Les différentes étapes du codage</H3><P>
Voici les différentes étapes du codage (elles seront programmées avec 
<TT>Xcas</TT> dans le paragraphe suivant) :
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
À chaque lettre ou symbole,
on associe un nombre, comme dans la table <A HREF="#sec:code">12.6.1</A>. Un texte devient ainsi 
une suite de nombres : par exemple <TT>ê</TT> sera codée par 95 et
<TT>BONJOUR</TT> par 34 47 46 42 47 53 50.<BR>
La fonction <TT>codec2n</TT> réalise cette étape : elle transforme un 
caractère en un nombre <I>n</I> (0 ≤ <I>n</I>&lt; 101), selon la table <A HREF="#sec:code">12.6.1</A>.
</LI><LI CLASS="li-enumerate">On effectue une ou plusieurs opérations sur ces nombres :
<UL CLASS="itemize"><LI CLASS="li-itemize">
pour le codage de Jules César, on ajoute à ces nombres un nombre 
fixé appelé clef de chiffrement (par exemple 17), puis on prend le 
reste de la division par 101 des nombres obtenus.
Ainsi avec ce codage, <TT>ê</TT> est transformé 95
qui est transformé en 11 (95+17=112 =101+11, ou encore, 11 est le reste 
de la division de 112 par 101).<BR>
Avec <TT>Xcas</TT>, on effectue la transformation de <TT>n</TT> avec la commande 
<TT>irem(n+clef,101)</TT>, où <TT>clef</TT> est une variable qui contient la clef 
de chiffrement. 
</LI><LI CLASS="li-itemize">pour le codage linéaire on multiplie ces nombres par un nombre 
fixé appelé clef de chiffrement (par exemple 17) puis on prend le reste de la division par 101 des nombres obtenus.
Ainsi avec ce codage <TT>ê</TT> est transformé 95 qui est 
transformé en 100 (95*17=1615 =15*101+100, ou encore, 100 est le reste de la
division de 1615 par 101).<BR>
Avec <TT>Xcas</TT>, on effectue la transformation de <TT>n</TT> avec la commande :<BR>
<TT>irem(n*clef,101)</TT><BR>
 si <TT>clef</TT> est une variable qui contient la clef de chiffrement.
</LI></UL>
</LI><LI CLASS="li-enumerate">On transforme ensuite cette suite de nombre en une suite de caractères,
c’est le message crypté. 
Ainsi, avec le codage de Jules César de clef 17, <TT>ê</TT> devient 
<TT>+</TT> et <TT>BONJOUR</TT> devient 
<TT>S‘_|‘fc</TT> et 
avec le codage linéaire de clef 17, <TT>ê</TT> devient 
<TT>é</TT> et <TT>BONJOUR</TT> devient 
<TT>i|k’|}J</TT>.<BR>
La fonction <TT>coden2c</TT> réalise cette étape : elle transforme un nombre 
<I>n</I> (0 ≤ <I>n</I>&lt; 101) en un caractère <I>c</I>, selon la table <A HREF="#sec:code">12.6.1</A>.
</LI><LI CLASS="li-enumerate">Le décryptage nécessite d’inverser les opérations 3, 2 et 1.
Dans les exemples :
<UL CLASS="itemize"><LI CLASS="li-itemize">
avec le codage de Jules César, il faut enlever 17 ou rajouter 84
et prendre le reste de la division par 101, 
(84 est la clef de déchiffrement car 84+17=101). Ainsi, 11 est décripté par
95 puisque 11+84=95.
</LI><LI CLASS="li-itemize">avec le codage linéaire, il faut multiplier par 6 et prendre 
le reste de la division par 101, (6 est la clef de déchiffrement car 
6*17=102=101+1). Ainsi, 100 est décripté par 95 puisque 100*6=5*101+95.
</LI></UL> 
Le calcul de la
clef de déchiffrement à partir de la clef de chiffrement
fait intervenir l’arithmétique des entiers :<BR>
- savoir trouver l’opposé <I>u</I> d’un élément <I>n</I> de <I>Z</I>/101<I>Z</I> pour le 
codage de Jules César (<I>u</I>=101−<I>n</I> car <I>u</I>+<I>n</I>=101).<BR>
- savoir utiliser l’identité de Bézout pour trouver l’inverse <I>u</I>
d’un élément de <I>n</I> de <I>Z</I>/101<I>Z</I> pour le codage linéaire (on a
<I>u</I>=<TT><I>iegcd</I>(<I>n</I>,101)[0]</TT> car <I>u</I>*<I>n</I>+<I>v</I>*101=1).
</LI></OL><H3 CLASS="subsection"><A NAME="htoc312">12.6.3</A>  Le programme Xcas</H3><PRE CLASS="verbatim">codec2n(c):={
if (c=="\'e") return 100;
if (c=="\`e") return 99;
if (c=="\`a") return 98;
if (c=="\c{c}") return 97;
if (c=="\`u") return 96;
if (c=="\^e") return 95;
return(asc(c)-32);
};

coden2c(k):={
if (k== 100) return "\'e";
if (k==99) return "\`e";
if (k==98) return "\`a";
if (k==97) return "\c{c}";
if (k==96) return "\`u";
if (k==95) return "\^e";
return(char(k+32));
};

jules_cesar(message,clef):={
local s,j,messcode;
s:=size(message);
messcode:="";
for (j:=0;j&lt;s;j++) {
messcode:=append(messcode,
                 coden2c(irem(clef+codec2n(message[j]),101)));
}
return (messcode);
};

lineaire(message,clef):={
local s,j,messcode;
s:=size(message);
messcode:="";
for (j:=0;j&lt;s;j++) {
messcode:=messcode+coden2c(irem(clef*codec2n(message[j]),101));
}
return (messcode);
};
</PRE><P><TT>codec2n</TT> transforme un caractère <I>c</I> "autorisé" en un entier <I>n</I>, 
0≤ <I>n</I> &lt;101 selon la table <A HREF="#sec:code">12.6.1</A>.<BR>
<TT>coden2c</TT> transforme un entier <I>n</I>, 0≤ <I>n</I> &lt;101 
en un caractère <I>c</I> selon la table <A HREF="#sec:code">12.6.1</A>.<BR>
<TT>jules_cesar</TT> (respectivement <TT>lineaire</TT>) code le message selon la 
clé choisie. On remarquera que les deux fonctions ne diffèrent que par 
l’opération effectuée :<BR>
<TT>clef+codec2n(message[j])</TT> pour la fonction <TT>jules_cesar</TT> et<BR>
<TT>clef+codec2n(message[j])</TT> pour la fonction <TT>lineaire</TT>.<BR>
Pour décoder, il suffit d’employer le même programme en utilisant la clef 
de décodage associée à la clef de codage et à la méthode utilisée :
par exemple, pour <TT>jules_cesar</TT> de clef de codage 99 la clé 
de décodage associée est 2 (2+99=101=0 mod101) et<BR>
pour <TT>lineaire</TT> de clef de codage 99 la clef 
de décodage associée est 50 puisque 99*50=−2*50=−100=1 mod101.</P><H3 CLASS="subsection"><A NAME="htoc313">12.6.4</A>  Le programme C++</H3><PRE CLASS="verbatim">//#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

//using namespace std;

int codec2n(char c){
  int i=c;
  switch (c){
  case  '\'e':
    i=100; 
    break;
  case '\`e':
    i=99;
    break;
  case '\`a':
    i=98;
    break;
  case '\c{c}':
    i=97;
    break;
  case '\`u':
    i=96;
    break;
  case '\^e':
    i=95;
    break;
  default:
    i -= 32;
  }
  return i;
}

char coden2c(int i){
  if (i&lt;95)
    return i+32;
  switch (i){
  case 95:
    return '\^e';
  case 96:
    return '\`u';
  case 97:
    return '\c{c}';
  case 98:
    return '\`a';
  case 99:
    return '\`e';
  case 100:
    return '\'e';
  }
}

int main(int argc,char ** argv){
  char * s=0,ch;
  size_t n=0;
  int i,d,fois;
  if (!strcmp(argv[0],"./table")){
    for (i=0;i&lt;101;++i){
      ch=coden2c(i);
      printf("%d:%c &amp;",i,ch);
      if (i%10==0)
 printf("\n");
    }
    return 0;
  }
  if (!strcmp(argv[0],"./coden2c")){
    for (i=1;i&lt;argc;++i){
      d=atoi(argv[i]);
      ch=coden2c(d);
      printf("%c",ch);
    }
    printf("\n");
    return 0;
  }
  if (argc==3)
    fois=atoi(argv[2]);
  else
    fois=0;
  if (argc&gt;=2){
    s=argv[1];
    n=strlen(s);
  }
  else {
    printf("Entrez un message \`a num\'eriser\n");
    getline(&amp;s,&amp;n,stdin);
    n=strlen(s)-1;
  }
  for (i=0;i&lt;n;++i){
    d=codec2n(s[i]);
    if (fois)
      printf("%c",coden2c(d*fois % 101));
    else
      printf("%d ",d);
  }
  printf("\n");
  return 0;
}
</PRE><H3 CLASS="subsection"><A NAME="htoc314">12.6.5</A>  Exercices de décodage</H3><H4 CLASS="subsubsection">Avec le codage Jules César</H4><P><FONT SIZE=5>message 1, codage Jules César clef 10<BR>
</FONT><CODE><FONT SIZE=5>\`uy\^e}*kvvo\'e*qkqxo|*\^ex*MN</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 2, codage Jules César clef 10<BR>
</FONT><CODE><FONT SIZE=5>vk*}yv\^e~syx*x1o}~*zk}*)\`usnox~o</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 3, codage Jules César clef 23<BR>
</FONT><CODE><FONT SIZE=5>(\`u(|7\`e|%7\`e!~\`uz\`u|\`e%7\`e\`uy$|%</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 4, codage Jules César clef 23<BR>
</FONT><CODE><FONT SIZE=5>$\`u| 7 |7%|$&amp;7{|7z!'$\`u$</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 5, codage Jules César clef 35<BR>
</FONT><CODE><FONT SIZE=5>\'e..#*-,1C3,C!&amp;\'e2C3,C!&amp;\'e2</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 6, codage Jules César clef 35<BR>
</FONT><FONT SIZE=5><TT>*éC0B.-,1#C0#*A4#C"3C"B$’</TT></FONT><FONT SIZE=5>
<BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 7, codage Jules César clef 99<BR>
</FONT><CODE><FONT SIZE=5>f_`gjcr\`aq\`ea_jasj_rmgpcq\`em`jge_rmgpcq</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 8, codage Jules César clef 99<BR>
</FONT><CODE><FONT SIZE=5>gj\`ed_gr\`e`c_s\`ecr\`eaf_sb</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 9, codage Jules César clef 51<BR>
</FONT><CODE><FONT SIZE=5>:ZCB7:7A/B7=&lt;S23S13S1=2/53S3ABS27A1CB/0:3</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 10, codage Jules César clef 51<BR>
</FONT><CODE><FONT SIZE=5>&lt;=CASD=C:=&lt;ASRD7B3@S:/S1=&lt;4CA7=&lt;</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>

message 11, codage Jules César clef 45<BR>
</FONT><CODE><FONT SIZE=5>*-)=+7=8M,-M&lt;:)&gt;)14M87=:M:1-6</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 12, codage Jules César clef 45<BR>
</FONT><CODE><FONT SIZE=5>;+1-6+-M;)6;M+76;+1-6+-M6T-;&lt;M9=-M:=16-M,-M4T)5-</FONT></CODE><FONT SIZE=5>
</FONT>
</P><H4 CLASS="subsubsection">Avec le codage linéaire</H4><P>
<FONT SIZE=5>message 1, codage linéaire clef 10<BR>
</FONT><CODE><FONT SIZE=5>TsJ6 LUUt| #L#it, Ji OY</FONT></CODE><FONT SIZE=5>
<BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 2, codage linéaire clef 10<BR>
</FONT><CODE><FONT SIZE=5>UL 6sUJ@7si ift6@ }L6 {T7jti@t</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 3, codage linéaire clef 23<BR>
</FONT><CODE><FONT SIZE=5>[_[h ?h{ ?\'e1_:_h?{ ?_#dh{</FONT></CODE><FONT SIZE=5>
<BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 4, codage linéaire clef 23<BR>
</FONT><CODE><FONT SIZE=5>d_hm mh {hd- Qh :\'eDd_d</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 5, codage linéaire clef 35<BR>
</FONT><CODE><FONT SIZE=5>Uii|BF#m N# 6\`uU+ N# 6\`uU+</FONT></CODE><FONT SIZE=5>
<BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 6, codage linéaire clef 35<BR>
</FONT><CODE><FONT SIZE=5> BU JbiF#m| J|B?q| YN Yb:&gt;</FONT></CODE><FONT SIZE=5>
<BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 7, codage linéaire clef 99<BR>
</FONT><CODE><FONT SIZE=5>ZhfXR`B"D dhRd@RhBLXF`D LfRX\hBLXF`D</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 8, codage linéaire clef 99<BR>
</FONT><CODE><FONT SIZE=5>XR ^hXB f`h@ `B dZh@b</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 9, codage linéaire clef 51<BR>
</FONT><CODE><FONT SIZE=5>FV}JwFw|sJwzG Bu tu tzBsvu u|J Bw|t}JsAFu</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 10, codage linéaire clef 51<BR>
</FONT><CODE><FONT SIZE=5>Gz}| Kz}FzG| RKwJuI Fs tzGC}|wzG</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>

message 11, codage linéaire clef 45<BR>
</FONT><CODE><FONT SIZE=5>Ik\c{c}xv4xa &gt;k KV\c{c}@\c{c}Uw a4xV VUkl</FONT></CODE></P><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 12, codage linéaire clef 45<BR>
</FONT><CODE><FONT SIZE=5>\`evUklvk \`e\c{c}l\`e v4l\`evUklvk l,k\`eK )xk VxUlk &gt;k w,\c{c}?k</FONT></CODE><FONT SIZE=5>
</FONT></P><H3 CLASS="subsection"><A NAME="htoc315">12.6.6</A>  Solutions des exercices de décodage Jules César et linéaire</H3><P>
1: vous allez gagner un CD<BR>
2: la solution n’est pas évidente<BR>
3: vive les logiciels libres<BR>
4: rien ne sert de courir<BR>
5: appelons un chat un chat<BR>
6: la réponse relève du défi<BR>
7: habiletés calculatoires obligatoires<BR>
8: il fait beau et chaud<BR>
9: l’utilisation de ce codage est discutable<BR>
10: nous voulons éviter la confusion<BR>
11: beaucoup de travail pour rien<BR>
12: science sans conscience n’est que ruine de l’ame<BR>

</P><H2 CLASS="section"><A NAME="toc89"></A><A NAME="htoc316">12.7</A>  Chiffrement affine : premier algorithme</H2><P><A NAME="sec:bijection"></A>
</P><H3 CLASS="subsection"><A NAME="htoc317">12.7.1</A>  L’algorithme</H3><P><A NAME="subsec:bijection"></A>
Pour écrire le message on ne se restreint plus aux 26 lettres de l’alphabet. 
On suppose que le message à coder n’utilise que les caractères dont le code
ASCII va de 32 à 127 (avant 32, les caractères ne sont pas imprimables, et
après 127 il s’agit de caractères spéciaux...).<BR>
On choisit dans ce premier algorithme de coder chaque lettre : cela à 
l’incovénient de décrypter facilement le message en analysant la 
fréquence des lettres du message crypté, c’est pourquoi dans le deuxième 
algorithme, on code des groupements de trois lettres.<BR>
Il y a alors trois choses à faire qui sont les trois instructions de la 
fonction <TT>cod1</TT> et qui code un caractère par un autre caractère :<BR>
- on transforme chaque caractère en un entier <I>n</I> de 0 à 95 (en enlevant 32
à son code ASCII)<BR>
- puis, on applique à cet entier <I>n</I> le chiffrement affine :</P><P> <I>f</I>(<I>n</I>)=<I>a</I> × <I>n</I>+<I>b</I> (mod 96) avec <I>f</I>(<I>n</I>) ∈[0..95].<BR>
Pour que cette application soit bijective il faut et il suffit que <I>a</I> soit 
premier avec 96. En effet d’après l’identité de Bézout il
existe <I>u</I> et <I>v</I> tels que :<BR>
<I>a</I> × <I>u</I>+96 × <I>v</I>=1 donc <I>a</I> × <I>u</I>=1 (mod 96)).<BR>
On a donc <I>f</I><SUP>−1</SUP>(<I>m</I>)=<I>u</I>.(<I>m</I>−<I>b</I>) (mod96)<BR>
- on transforme le nombre trouvé <I>f</I>(<I>n</I>) en un caractère de code <I>f</I>(<I>n</I>)+32.<BR>
 Pour coder le message, il suffit ensuite de coder chaque caractère, 
c’est ce que fait la fonction <TT>codm1</TT>.<BR>

Pour décoder, il suffit de remplacer la valeur de <I>a</I> par 
<I>a</I>1=<I>u</I> (mod 96) si <I>a</I> × <I>u</I>+96 × <I>v</I>=1<BR>
et la valeur de <I>b</I> par <I>b</I>1=−<I>a</I>1 × <I>b</I> (mod 96)<BR>
car alors on a <I>n</I>=<I>a</I>1 × <I>f</I>(<I>n</I>)+<I>b</I>1 (mod 96)<BR>
Les fonctions de décodage et de codage sont donc les mêmes , seuls les 
paramètres sont différents!<BR>
<B>Exemple</B><BR>
<I>a</I>=85 <I>b</I>=2<BR>
On a par l’identité de Bézout :<BR>
 85 × 61 − 96 × 54 = 1
et
 −2 × 61 = −122 = 70 (mod 96)<BR>
donc on obtient :<BR>
<I>a</I>1=61 <I>b</I>1=70
</P><H3 CLASS="subsection"><A NAME="htoc318">12.7.2</A>  Traduction Algorithmique</H3><P>
On note <TT>char</TT> la fonction qui à un nombre <TT>n</TT> associe 
le caractère de code ASCII <TT>n</TT> et <TT>asc</TT> la fonction qui à un caractère associe son code ASCII.<BR>
Voici le codage d’une lettre <TT>c</TT> par la fonction cod1 (<TT>a,b</TT> sont les 
paramètres du chiffrement affine) :<BR>
<TT>fonction cod1(c,a,b)<BR>
local n<BR>
asc(c)-32 =&gt; n<BR>
a.n+b mod 96 =&gt; n<BR>
résultat char(n+32)<BR>
ffonction</TT><BR>

On suppose que l’on a accés au <TT>k</TT>-ième caractère du mot <TT>m</TT> en 
mettant <TT>m[k]</TT>.<BR>
On suppose que la concaténation de deux mots se fait avec <TT>concat</TT>.<BR>
Voici le codage du message <TT>m</TT> par la fonction coda1 (<TT>a,b</TT> sont les 
paramètres du chiffrement affine) :<BR>
<TT>fonction codm1(m,a,b)<BR>
local r,k,n<BR>
"" =&gt;r<BR>
k=&gt;0
longueur_mot(m)=&gt;s
tantque k&lt;s<BR>
m[k]=&gt;c<BR>
k+1=&gt;k<BR>
concat(r,cod1(c,a,b))=&gt;r<BR>
ftantque<BR>
retourne r<BR>
ffonction</TT><BR>
</P><H3 CLASS="subsection"><A NAME="htoc319">12.7.3</A>  Traduction Xcas</H3><P>
On dispose de :<BR>
- <TT>char</TT> la fonction qui à un nombre <TT>n</TT> associe le caractère de
code ASCII <TT>n</TT> et, qui a une liste de nombres associe la chaîne des 
caractères dont les codes correspondent aux nombres de la liste.<BR>
- <TT>asc</TT> la fonction qui à une chaîne de caractères 
associe la liste des codes ASCII des caractères composant la chaîne.<BR>
<B>Attention</B> <TT>asc("A")=[65]</TT> et donc <TT>(asc("A"))[0]=65</TT>.</P><P>Voici le codage d’une lettre par la fonction cod1 :
</P><PRE CLASS="verbatim">cod1(c,a,b):={
local n;
n:=(asc(c))[0]-32;
n:=irem(a*n+b,96);
return(char(n+32));
}
</PRE><P>Voici le codage du message par la fonction codm1 :
</P><PRE CLASS="verbatim">codm1(m,a,b):={
local r,c,s;
r:="";
s:=size(m);
for (k:=0;k&lt;s;k++){
c:=m[k];
r:=concat(r,cod1(c,a,b));
}
return(r);
}
</PRE><P>On peut aussi coder directement le message <TT>mess</TT> : en effet avec 
<TT>Xcas</TT> les fonctions <TT>asc</TT>
et <TT>char</TT> gérent les chaînes et les listes.<BR>
On transforme donc le message (i.e une chaîne de caractères)
en une liste <TT>l</TT> de nombres avec <TT>asc(mess)</TT>, puis on transforme cette 
liste de nombres par l’application
affine  <I>f</I>(<I>n</I>)=<I>a</I> × <I>n</I>+<I>b</I> (mod 96) en la liste <TT>mc</TT>, puis on 
transformer la liste <TT>lc</TT>
des nombres ainsi obtenus en une chaîne de caractères 
(avec <TT>char(lc)</TT>, c’est ce que fait la fonction <TT>codm</TT>).<BR>
Dans ce qui suit on a écrit les fonctions :<BR>
<TT>bonpara(para)</TT> (avec <TT>para=[a,b]</TT>) renvoie la liste des paramètres 
de décodage si le paramètre <TT>a</TT> est premier avec 96. 
Cette fonction utilise la fonction <TT>decopara(para)</TT> qui calcule les paramètres de décodage. 
</P><PRE CLASS="verbatim">decopara(para):={
//decopara permet de trouver les parametres de decodage
local bez,a,b;
a:=para[0];
b:=para[1];
bez:=bezout(a,96);
a:=irem(bez[0],96);
if (a&lt;0) a:=a+96;
b:=irem(-b*a,96);
if (b&lt;0) b:=b+96;
return([a,b]);
};
bonpara(para):={
//teste si a est premier avec 96
if (pgcd(para[0],96)==1) return(decopara(para)); else return(false);
};
codm(mess,para):={
//codage par chiffrement affine de parametres para=[a,b] mod 96
//codm code le message mess (="....") avec para=[a,b]
local l,lc,sl,a,b,c;
a:=para[0];
b:=para[1];
l:=asc(mess);
sl:=size(l);
for (k:=0;k&lt;sl;k++){
//les caracteres codes entre 0 et 31 ne sont pas lisibles
l[k]:=l[k]-32;
}
lc:=[];
for (j:=0;j&lt;sl;j++){
c:=irem(a*l[j]+b,96);
lc:=concat(lc,32+c);
}
return(char(lc));
}
</PRE><H2 CLASS="section"><A NAME="toc90"></A><A NAME="htoc320">12.8</A>  Chiffrement affine : deuxième algorithme</H2><H3 CLASS="subsection"><A NAME="htoc321">12.8.1</A>  L’algorithme</H3><P>
On peut aussi choisir de coder le message en le découpant par paquets de 3
lettres que l’on appelle mot et en rajoutant, éventuellement, des espaces à la fin du message 
pour que le nombre de caractères du message soit un multiple de 3.<BR>
Comme précédemment, à chaque caractère on fait correspondre un nombre entier
de l’intervalle [0..95].<BR>
 On considére alors un mot de 3 lettres comme l’écriture dans la base 96 d’un nombre entier <I>n</I> :<BR>
<B>Exemple</B><BR>
le mot <TT>BAL</TT> est la représentation de <I>n</I>=34 × 96<SUP>2</SUP>+33 × 96+44=316556.<BR>
En effet <TT>B</TT> est codé par 34 puisque son code ASCII est 66 (66-32=34),
<TT>A</TT> est codé par 33 et <TT>L</TT> est codé par 44.<BR>
On code les mots de 3 lettres par un autre mot, puis on en déduit le 
codage du message tout entier.
Le programme <TT>mot2n</TT> transforme un mot <I>m</I> de 3 lettres en un nombre entier
<I>n</I> dont l’écriture en base 96 est <I>m</I>. On a donc, si <I>m</I> a 3 lettres 
<I>n</I>&lt;96<SUP>3</SUP>.<BR>
Par exemple <TT>mot2n("BAL")=316559</TT>. </P><P>Le progamme <TT>codaff</TT> transforme <I>n</I> selon le chiffrement affine :<BR>
 <I>f</I>(<I>n</I>)=<I>a</I> × <I>n</I>+<I>b</I>  mod <I>p</I> .<BR>
- il faut choisir <I>p</I> ≥ 96<SUP>3</SUP> ; si <I>p</I>&gt;96<SUP>3</SUP>, le nombre (<I>f</I>(<I>n</I>)) obtenu 
aprés transformation affine de <I>n</I>, peut avoir une représentation de 
plus de 3 lettres dans la base 96.
Mais, au décodage tous les mots auront exactement 3 lettres.
Pour les calculateurs qui limitent la représentation d’un entier à 12 
chiffres il faut choisir <I>p</I> ≤ 10<SUP>6</SUP> pour que <I>a</I> × <I>n</I> +<I>b</I> &lt; 10<SUP>12</SUP><BR>
- pour que <I>f</I> soit inversible il faut que <I>a</I> et <I>p</I> soient premiers entre eux
(cf p <A HREF="#sec:bijection">??</A>) .</P><P><B>Exemple</B><BR>
<I>a</I>=567 <I>b</I>=2 <I>p</I>=10<SUP>6</SUP></P><P>On obtient par Bézout :</P><P>567 × 664903 +10<SUP>6</SUP> × 377 =1</P><P>et  −2 × 664903 = 670164  mod 10<SUP>6</SUP></P><P>donc <I>a</I>1=664903 et <I>b</I>1=670164</P><P>Le programme <TT>n2mot</TT> fait l’opération inverse et transforme un nombre 
entier <I>n</I> en un mot <I>m</I> (d’au moins 3 symboles) qui est la représentation 
de <I>n</I> dans la base 96.<BR>
Il faut faire attention aux espaces en début de mot!!! En effet, l’espace 
est codé par <TT>0</TT> et il risque de disparaître si on ne fait pas 
attention, au décodage!!!<BR>
Exemple<BR>
On a <TT><I>n</I>2<I>mot</I>(34)="   <I>B</I>"</TT> (c’est à dire la chaîne formée par 2 espaces et B).<BR>
Le programme <TT>codmot3</TT> code les mots d’au moins 3 lettres en un mot d’au moins 3 
lettres à l’aide du chiffrement affine. En changeant les paramètres <I>a</I> et <I>b</I>
<TT>codmot3</TT> décode les mots codés avec <TT>codmot3</TT>.</P><P>Le programme <TT>codmess3</TT> code les messages à l’aide du chiffrement affine.
Pour décoder, il suffit d’utiliser la fonction <TT>codmess3</TT> en changeant les paramètres <I>a</I> et <I>b</I>. 
</P><H3 CLASS="subsection"><A NAME="htoc322">12.8.2</A>  Traduction Algorithmique</H3><P>
Voici la transformation d’un mot <TT>m</TT> en un nombre
entier <TT>n</TT> par la fonction <TT>mot2n</TT> :<BR>
<TT>fonction mot2n(mo)<BR>
local k,p,n<BR>
0=&gt;n<BR>
0=&gt;k<BR>
tantque k&lt;longueur_mot(mo) </TT><TT>≠</TT><TT> ""<BR>
asc(mo[k])-32=&gt;p<BR>
k+1=&gt;k<BR>
n*96+p=&gt;n<BR>
ftantque<BR>
retourne n<BR>
ffonction</TT><BR>
Voici la transformation d’un nombre entier <TT>n</TT> en son écriture en base 96 
(c’est à dire en un mot <TT>m</TT> d’au moins 3 lettres) par la fonction 
<TT>n2mot</TT> :<BR>
<TT>fonction n2mot(n)<BR>
local m,r,j<BR>
""=&gt;m<BR>
0=&gt;j<BR>
tantque n &gt;0 ou j&lt; 3<BR>
char((n mod 96)+32)=&gt;r<BR>
int(n/96)=&gt;n<BR>
r+m=&gt;m<BR>
j+1=&gt;j<BR>
ftantque<BR>
retourne m<BR>
ffonction</TT><BR>
Voici le codage d’un mot d’au moins 3 lettres par la fonction <TT>codmot3</TT> :<BR>
<TT>fonction codmot3(m,a,b,p)<BR>
local n<BR>
mot2n(m)=&gt;n<BR>
a.n+b mod p =&gt;n<BR>
n2mot(n)=&gt;m<BR>
retourne m<BR>
ffonction</TT><BR>
Voici le codage d’un message par la fonction <TT>codmess</TT> :<BR>
<TT>fonction codmess3(m,a,b,p)<BR>
local n,i,r,d<BR>
int(dim(m)/3)+1=&gt;n<BR>
{}=&gt;r<BR>
1=&gt;i<BR>
tantque i&lt;n<BR>
debut(m,3)=&gt;d<BR>
fin(m,4)=&gt;m<BR>
codmot3(d,a,b,p)=&gt;r[i]<BR>
i+1=&gt;i<BR>
ftantque<BR>
si dim(m)=2 alors<BR>
m + " "=&gt;m<BR>
codmot3(m,a,b,p)=&gt;r[i]<BR>
sinon<BR>
si dim(m)=1 alors<BR>
m + " " =&gt;m<BR>
codmot3(m,a,b,p)=&gt;r[i]<BR>
sinon<BR>
fin(r,i-1)=&gt;r<BR>
fsi<BR>
fsi<BR>
retourne r<BR>
ffonction</TT></P><H3 CLASS="subsection"><A NAME="htoc323">12.8.3</A>  Traduction Xcas</H3><P>
Voici la fonction <TT>decopara3(para)</TT> qui donne les paramètres de décodage
quand les paramètres sont corrects.<BR>
On prend comme chiffrement affine  <I>a</I>*<I>n</I>+<I>b</I> mod 96<SUP>3</SUP> car on veut mettre le message codé dans une chaîne et donc transformer un paquet 
de 3 lettres en un paquet d’exactement 3 lettres.
</P><PRE CLASS="verbatim">decopara3(para):={
//=le parametrage de decodage du parametrage para (liste).
local a,b,l;
a:=para[0];
b:=para[1];
l:=bezout(a,96^3);
if (l[2]!=1) return(false);
a:=l[0];
if (a&lt;0) a:=a+96^3;
b:=-irem(b*a,96^3)+96^3;
return([a,b]);
}
</PRE><P>Voici la transformation d’un mot <I>s</I> d’au moins 3 lettres en un nombre entier 
par la fonction <TT>mot2n</TT> :
</P><PRE CLASS="verbatim">mot2n(s):={
//transforme un mot s de 3 lettres en n 
//n a pour ecriture s en base 96 
local l,n;
l:=asc(s);
n:=(l[0]-32)*96^2+(l[1]-32)*96+l[2]-32;
return(n);
}
</PRE><P>Voici la transformation d’un nombre entier <I>n</I> en son écriture en base 96 
(c’est à dire en un mot d’au moins 3 lettres) par la fonction <TT>n2mot</TT> :
cette fonction utilise la fonction <TT>ecritu96</TT> qui écrit <TT>n</TT> dans la
base 96 comme un mot de 1,2,3 etc caractères. Pour obtenir un mot d’au moins 3 lettres il suffit de rajouter des espaces devant le mot puisque le code 
ASCII de l’espace vaut 32, cela revient à rajouter des zéros devant l’écriture de <TT>n</TT>. 
</P><PRE CLASS="verbatim">ecritu96(n):={
//transforme l'entier n en la chaine s
//s est l'ecriture de n en base 96
local s,r;
// n est un entier et b=96
// ecritu96 est une fonction iterative 
//ecritu96(n)=l'ecriture de n en base 96 
s:="";
while (n&gt;=96){
r:=irem(n,96);
r:=char(r+32);
s:=r+s;
n:=iquo(n,96);
}
n:=char(n+32);
s:=n+s;
return(s);
};

n2mot(n):={
local mot,s;
mot:=ecritu96(n);
s:=size(mot);
//on suppose n&lt;96^3 on transforme n en un mot de 3 caracteres
//on rajoute des espaces si le mot n'a pas 3 lettres
if (s==2) {mot:=" "+mot;}
else {
if (s==1) {mot:="  "+mot;}
}
return(mot); 
}
</PRE><P>Voici le codage d’un mot d’au moins 3 lettres par la fonction codmot3 : en prenant toujours <TT><I>p</I>=96</TT><SUP><TT>3</TT></SUP>
</P><PRE CLASS="verbatim">codmot3(mot,para):={
//codage d'un mot de 3 lettres avec le parametrage para=[a,b]
local n,m,a,b;
//para:[569,2] mod 96^3
//decopara3=[674825, 419822]
a:=para[0];
b:=para[1];
n:=mot2n(mot);
m:=irem(a*n+b,96^3);
return(n2mot(m));
}
</PRE><P>Le décodage d’un mot codé avec <TT>codmot3</TT> se fait aussi avec la fonction 
<TT>codmot3</TT>.<BR>
Voici le codage d’un message par la fonction <TT>codmess3</TT> :
</P><PRE CLASS="verbatim">codmess3(mess,para):={
//code le message mess,parametrage para et paquet de 3 lettres 
  local s,messcod,mess3;
  s:=size(mess);
  if (irem(s,3)==2){ 
    mess:=mess+" ";
    s:=s+1;
  }
  else {
    if (irem(s,3)==1) { 
       mess:=mess+"  ";
       s:=s+2;
    }
  } 
  messcod:="";
  for (k:=0;k&lt;s;k:=k+3){
    mess3:=mess[k..k+2];
    mess3:=codmot3(mess3,para);
    messcod:=messcod+mess3;
  }
return(messcod);
}
</PRE><P>Le décodage du message se fait aussi par la fonction <TT>codmess3</TT>
</P><H2 CLASS="section"><A NAME="toc91"></A><A NAME="htoc324">12.9</A>  Devoir à la maison</H2><P><A NAME="sec:dev"></A>
On écrit un message plus ou moins long selon le nombre d’élèves de la classe.
Puis on le partage en groupement de 8 lettres.<BR>
Chaque groupe de 8 lettres est ensuite codé (lettre par lettre) à l’aide d’un chiffrement affine 
de paramètres diffèrents selon les élèves.</P><P>Le chiffrement affine lettre à lettre est déterminé par la donnée de 3 paramètres :<BR>
<I>a</I>,<I>b</I>,<I>p</I> qui transforme l’entier <I>n</I> en <I>m</I>=<I>a</I>*<I>n</I>+<I>b</I> (mod <I>p</I>).<BR>
Pour avoir une fonction de décodage il faut et il suffit que <I>a</I> soit inversible
dans <I>Z</I>/<I>pZ</I> c’est à dire que <I>a</I> et <I>p</I> soient premiers entre eux.<BR>
La fonction de décodage est alors :<BR>
 <I>a</I><SUB>1</SUB>*<I>m</I>+<I>b</I><SUB>1</SUB> avec,<BR>
<I>a</I><SUB>1</SUB> inverse de <I>a</I>  dans <I>Z</I>/<I>pZ</I> (<I>a</I><SUB>1</SUB>=<I>u</I> (mod <I>p</I>) si <I>a</I>*<I>u</I>+<I>p</I>*<I>v</I>=1 
(identité de Bézout)) et <I>b</I><SUB>1</SUB>=−<I>b</I>*<I>a</I><SUB>1</SUB> (mod <I>p</I>).<BR>

Pour ce chiffrement affine, on peut utiliser tous les caractères dont les codes
ASCII vont de 32 à 127 (les caractères de code 0 à 31 ne sont pas imprimables
et au delà de 127 ils ne sont pas standards).<BR>

Étant donnés <I>a</I>, <I>b</I>, <I>p</I>=96, comment coder ?<BR>
À chaque caractère (de code ASCII compris entre 32 et 127) on fait 
correspondre un entier <I>n</I> entre 0 et 95 ; 
<I>n</I> est égal à : (code ASCII du caractère) - 32.<BR>
Par exemple, à <TT>B</TT> on fait correspondre 34 (66-32 ).<BR>
Puis, on calcule <I>m</I>=<I>a</I>*<I>n</I>+<I>b</I>  mod 96 :<BR>
pour <I>a</I>=55, <I>b</I>=79 et <I>n</I>=34 on obtient <I>m</I>=29.<BR>
Puis, on cherche le caractère de code ASCII <I>m</I>+32. Le caractère qui a
comme code ASCII 29+32=61 est le signe <TT>=</TT>) : c’est ce caractère qui 
sera donc choisi comme codage de la lettre <TT>B</TT>.<BR>
<B>Exemple :</B><BR>
On va coder la phrase :<BR>
<TT>BEAUCOUP DE TRAVAIL POUR RIEN!?</TT><BR>
en la coupant en trois morceaux (le caractère espace termine les deux premiers morceaux).<BR>
Par exemple :<BR>
<TT>BEAUCOUP </TT> sera codé avec <I>a</I>=55 <I>b</I>=79 et <I>p</I>=96<BR>
<TT>DE TRAVAIL </TT> sera codé avec <I>a</I>=49 <I>b</I>=25 et <I>p</I>=96<BR>
<TT>POUR RIEN!?</TT> sera codé avec <I>a</I>=73 <I>b</I>=48 et <I>p</I>=96<BR>
On code <TT>BEAUCOUP </TT> avec <I>a</I>=55 <I>b</I>=79 et <I>p</I>=96.<BR>
 On obtient :<BR>
<TT>="f2th2?o</TT><BR>
Le devoir du premier élève est donc :<BR>
avec les paramètres de codage <I>a</I>=55  <I>b</I>=79 et <I>p</I>=96, décoder <TT>="f2th2?o</TT><BR>
L’élève doit :<BR>
 - trouver les paramètres de décodage (ici <I>a</I><SUB>1</SUB>=7  <I>b</I><SUB>1</SUB>=23) :<BR>
en effet l’inverse <I>a</I><SUB>1</SUB> de <I>a</I> (mod96) est obtenu en ecrivant l’identité de Bézout pour <I>a</I> et <I>p</I> :<BR>
55*7−96*4=1 et <I>b</I><SUB>1</SUB>=79*7  (mod 96) = 23<BR>
 - puis décoder à l’aide d’une table de code ASCII :<BR>
le code ASCII du caractère <TT>  = </TT> est 61 donc :<BR>
<I>m</I>=61−32=29<BR>
<I>a</I><SUB>1</SUB>*<I>n</I>+<I>b</I><SUB>1</SUB> (mod 96) = 7*29+23  (mod 96) = 226 (mod 96) = 34<BR>
La lettre de code 34+32 = 66 est <TT>B</TT><BR>
</P><H3 CLASS="subsection"><A NAME="htoc325">12.9.1</A>  Le code Ascii</H3><P> 
Voici pour <TT>Xcas</TT>, la table des codes ASCII compris entre 30 
et 127.<BR>

</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>0</TD><TD ALIGN=right NOWRAP>1</TD><TD ALIGN=right NOWRAP>2</TD><TD ALIGN=right NOWRAP>3</TD><TD ALIGN=right NOWRAP>4</TD><TD ALIGN=right NOWRAP>5</TD><TD ALIGN=right NOWRAP>6</TD><TD ALIGN=right NOWRAP>7</TD><TD ALIGN=right NOWRAP>8</TD><TD ALIGN=right NOWRAP>9</TD></TR>
<TR><TD ALIGN=right NOWRAP>30</TD><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>_</TD><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>!</TD><TD ALIGN=right NOWRAP>"</TD><TD ALIGN=right NOWRAP>#</TD><TD ALIGN=right NOWRAP>$</TD><TD ALIGN=right NOWRAP>%</TD><TD ALIGN=right NOWRAP>&amp;</TD><TD ALIGN=right NOWRAP>’</TD></TR>
<TR><TD ALIGN=right NOWRAP>40</TD><TD ALIGN=right NOWRAP>(</TD><TD ALIGN=right NOWRAP>)</TD><TD ALIGN=right NOWRAP>*</TD><TD ALIGN=right NOWRAP>+</TD><TD ALIGN=right NOWRAP>,</TD><TD ALIGN=right NOWRAP>-</TD><TD ALIGN=right NOWRAP>.</TD><TD ALIGN=right NOWRAP>/</TD><TD ALIGN=right NOWRAP>0</TD><TD ALIGN=right NOWRAP>1</TD></TR>
<TR><TD ALIGN=right NOWRAP>50</TD><TD ALIGN=right NOWRAP>2</TD><TD ALIGN=right NOWRAP>3</TD><TD ALIGN=right NOWRAP>4</TD><TD ALIGN=right NOWRAP>5</TD><TD ALIGN=right NOWRAP>6</TD><TD ALIGN=right NOWRAP>7</TD><TD ALIGN=right NOWRAP>8</TD><TD ALIGN=right NOWRAP>9</TD><TD ALIGN=right NOWRAP>:</TD><TD ALIGN=right NOWRAP>;</TD></TR>
<TR><TD ALIGN=right NOWRAP>60</TD><TD ALIGN=right NOWRAP>&lt;</TD><TD ALIGN=right NOWRAP>=</TD><TD ALIGN=right NOWRAP>&gt;</TD><TD ALIGN=right NOWRAP>?</TD><TD ALIGN=right NOWRAP>@</TD><TD ALIGN=right NOWRAP>A</TD><TD ALIGN=right NOWRAP>B</TD><TD ALIGN=right NOWRAP>C</TD><TD ALIGN=right NOWRAP>D</TD><TD ALIGN=right NOWRAP>E</TD></TR>
<TR><TD ALIGN=right NOWRAP>70</TD><TD ALIGN=right NOWRAP>F</TD><TD ALIGN=right NOWRAP>G</TD><TD ALIGN=right NOWRAP>H</TD><TD ALIGN=right NOWRAP>I</TD><TD ALIGN=right NOWRAP>J</TD><TD ALIGN=right NOWRAP>K</TD><TD ALIGN=right NOWRAP>L</TD><TD ALIGN=right NOWRAP>M</TD><TD ALIGN=right NOWRAP>N</TD><TD ALIGN=right NOWRAP>O</TD></TR>
<TR><TD ALIGN=right NOWRAP>80</TD><TD ALIGN=right NOWRAP>P</TD><TD ALIGN=right NOWRAP>Q</TD><TD ALIGN=right NOWRAP>R</TD><TD ALIGN=right NOWRAP>S</TD><TD ALIGN=right NOWRAP>T</TD><TD ALIGN=right NOWRAP>U</TD><TD ALIGN=right NOWRAP>V</TD><TD ALIGN=right NOWRAP>W</TD><TD ALIGN=right NOWRAP>X</TD><TD ALIGN=right NOWRAP>Y</TD></TR>
<TR><TD ALIGN=right NOWRAP>90</TD><TD ALIGN=right NOWRAP>Z</TD><TD ALIGN=right NOWRAP>[</TD><TD ALIGN=right NOWRAP>\</TD><TD ALIGN=right NOWRAP>]</TD><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>_</TD><TD ALIGN=right NOWRAP>‘</TD><TD ALIGN=right NOWRAP>a</TD><TD ALIGN=right NOWRAP>b</TD><TD ALIGN=right NOWRAP>c</TD></TR>
<TR><TD ALIGN=right NOWRAP>100</TD><TD ALIGN=right NOWRAP>d</TD><TD ALIGN=right NOWRAP>e</TD><TD ALIGN=right NOWRAP>f</TD><TD ALIGN=right NOWRAP>g</TD><TD ALIGN=right NOWRAP>h</TD><TD ALIGN=right NOWRAP>i</TD><TD ALIGN=right NOWRAP>j</TD><TD ALIGN=right NOWRAP>k</TD><TD ALIGN=right NOWRAP>l</TD><TD ALIGN=right NOWRAP>m</TD></TR>
<TR><TD ALIGN=right NOWRAP>110</TD><TD ALIGN=right NOWRAP>n</TD><TD ALIGN=right NOWRAP>o</TD><TD ALIGN=right NOWRAP>p</TD><TD ALIGN=right NOWRAP>q</TD><TD ALIGN=right NOWRAP>r</TD><TD ALIGN=right NOWRAP>s</TD><TD ALIGN=right NOWRAP>t</TD><TD ALIGN=right NOWRAP>u</TD><TD ALIGN=right NOWRAP>v</TD><TD ALIGN=right NOWRAP>w</TD></TR>
<TR><TD ALIGN=right NOWRAP>120</TD><TD ALIGN=right NOWRAP>x</TD><TD ALIGN=right NOWRAP>y</TD><TD ALIGN=right NOWRAP>z</TD><TD ALIGN=right NOWRAP>{</TD><TD ALIGN=right NOWRAP>|</TD><TD ALIGN=right NOWRAP>}</TD><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>?</TD><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>130</TD><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE><H2 CLASS="section"><A NAME="toc92"></A><A NAME="htoc326">12.10</A>  Codage de Vigenère</H2><H3 CLASS="subsection"><A NAME="htoc327">12.10.1</A>  Le principe du codage</H3><P>
On veut coder un message <TT>mess</TT> qui n’utilise que les 26 lettres majuscules 
de l’alphabet.<BR>
Dans le codage de César à chaque caractère correspond toujours le même 
caractère : c’est une fonction qui à une lettre de l’alphabet fait 
correspondre une lettre de l’alphabet.<BR>
Dans le codage de Vigenère à un caractère <I>cara</I> du message correspond un 
caractère qui dépend de la position du caractère <I>cara</I> dans 
le message : c’est une fonction <I>f</I> de 2 variables qui à un entier <I>n</I> 
(0≤ <I>n</I>≤ 25) et et à une lettre de l’alphabet fait correspondre une 
lettre de l’alphabet. Cette correspondance se fait à l’aide d’une matrice 
carrée symétrique de dimension 26 appelée : carré de Vigenère.
</P><H3 CLASS="subsection"><A NAME="htoc328">12.10.2</A>  Le carré de Vigenère</H3><P>
On a <TT>asc("A")=65</TT>. Si le rang de <TT>"A"</TT> dans la liste alphabétique 
est <TT>0</TT> alors le rang d’une lettre <TT>c</TT> dans la liste alphabétique 
est : <TT>op(asc(cara))-65</TT>. Il faut utiliser la commande <TT>op</TT> pour 
transformer la liste de dimension 1 renvoyée par <TT>asc</TT> en un nombre.<BR>
Si à une lettre on fait correspondre son rang dans la liste alphabétique, 
au carré de Vigenère on peut faire correspondre la matrice carrèe de 
dimension 26 :<BR>
<TT>A[j,k]:=irem(j+k, 26)</TT> pour <TT>j=0..25</TT> et <TT>k=0..25</TT>.<BR>
Réciproquement si à un entier <TT>j</TT> de l’intervalle 0..25] on fait 
correspondre la lettre de rang <TT>j</TT> dans la liste alphabétique, alors,
à la matrice la matrice carrèe de dimension 26 <TT>A[j,k]:=irem(j+k, 26)</TT> 
on fait correspondre le carré de Vigenère.<BR>
On tape pour obtenir le carré de Vigenère <TT>CV</TT> :<BR>
<TT>CV:=makemat((j,k)-&gt;char(65+irem(j+k,26)),26,26)</TT><BR>
On tape pour obtenir la fonction <TT>f</TT> de codage :<BR>
<TT>f(n,cara):=CV[n,op(asc(cara))-65]</TT><BR>

<B>Propriétés</B>
La matrice <TT>A[j,k]:=irem(j+k, 26)</TT> est symétrique donc le carré de 
Vigenère est symétrique.<BR>
Si connaissant <TT>j</TT> et <TT>r</TT>, on cherche <TT>k</TT> pour que <TT>r=A[j,k]</TT>, 
alors on a <TT>k=A[26-j,r]=A[r,26-j]</TT>.<BR>
En effet, <TT>r=irem(j+k,26)</TT> donc <TT>k=irem(r-j,26)=irem(r+26-j,26</TT>.<BR>
Donc si <TT>r=A[j,k]</TT> alors <TT>k=A[26-j,r]=A[r,26-j]</TT>.<BR>

On peut utiliser le tableau à double entrées ci-dessous pour coder à la 
main :<BR>
</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left>&nbsp;</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD></TR>
<TR><TD VALIGN=top ALIGN=left>0</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD></TR>
<TR><TD VALIGN=top ALIGN=left>1</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD></TR>
<TR><TD VALIGN=top ALIGN=left>2</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD></TR>
<TR><TD VALIGN=top ALIGN=left>3</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD></TR>
<TR><TD VALIGN=top ALIGN=left>4</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD></TR>
<TR><TD VALIGN=top ALIGN=left>5</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD></TR>
<TR><TD VALIGN=top ALIGN=left>6</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD></TR>
<TR><TD VALIGN=top ALIGN=left>7</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD></TR>
<TR><TD VALIGN=top ALIGN=left>8</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD></TR>
<TR><TD VALIGN=top ALIGN=left>9</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD></TR>
<TR><TD VALIGN=top ALIGN=left>10</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD></TR>
<TR><TD VALIGN=top ALIGN=left>11</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD></TR>
<TR><TD VALIGN=top ALIGN=left>12</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD></TR>
<TR><TD VALIGN=top ALIGN=left>13</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD></TR>
<TR><TD VALIGN=top ALIGN=left>14</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left>15</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD></TR>
<TR><TD VALIGN=top ALIGN=left>16</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD></TR>
<TR><TD VALIGN=top ALIGN=left>17</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD></TR>
<TR><TD VALIGN=top ALIGN=left>18</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD></TR>
<TR><TD VALIGN=top ALIGN=left>19</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD></TR>
<TR><TD VALIGN=top ALIGN=left>20</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD></TR>
<TR><TD VALIGN=top ALIGN=left>21</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD></TR>
<TR><TD VALIGN=top ALIGN=left>22</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD></TR>
<TR><TD VALIGN=top ALIGN=left>23</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD></TR>
<TR><TD VALIGN=top ALIGN=left>24</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD></TR>
<TR><TD VALIGN=top ALIGN=left>25</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD></TR>
</TABLE><P><BR>
Si à une lettre on fait correspondre son rang dans la liste alphabétique, 
au carré de Vigenère on peut faire correspondre la matrice :<BR>
<TT>A[j,k]:=irem(j+k, 26)</TT>.<BR>
Ce carré donne la valeur de la fonction <TT>f</TT> du codage qui est :
<TT>f(0,"D")="D"</TT> (ligne 0 et colonne 3) et <TT>f(2,"D")="F"</TT> (ligne 2 et 
colonne 3) pour coder par exemple les <TT>"D"</TT> de <TT>"DINDON"</TT> (Attention 
les indices commencent à 0).<BR>
Ainsi <TT>"BONJOUR"</TT> sera codé par :<BR>
<TT>f("B",0)+f("O",1)+f("N",2)+f("J",3)+f("O",4)+f("U",5)+f("R",6)</TT><BR>
c’est à dire <TT>"BPPMSZX"</TT>
On pourra voir le programme qui code, décode avec ou sans clé en
<A HREF="#sec:coddecod">12.10.10</A>.
</P><H3 CLASS="subsection"><A NAME="htoc329">12.10.3</A>  Le programme du codage lettre par lettre</H3><P>
On utilise <TT>CV</TT> dans le programme.<BR>
On veut coder la lettre <TT>c</TT> qui est d’indice <TT>j</TT> dans le message.
Cette lettre <TT>c</TT> est de rang <TT>op(asc(c))-65</TT> dans l’alphabet.<BR>
Il faut donc chercher dans le tableau <TT>CV</TT> la lettre d’indice ligne 
<TT>irem(j,26)</TT> et d’indice colonne <TT>op(asc(c))-65</TT>.<BR>
Par exemple si on cherche à coder <TT>"O"</TT> d’indice 4 du message (la 5ième lettre du message à coder).<BR>
<TT>"O"</TT> a comme rang <TT>op(asc("O"))-65=14</TT> dans l’alphabet (<TT>"O"</TT> 
est la 15ième lettre de l’alphabet).<BR>
Le codage est donc la lettre située dans la ligne d’indice <TT>irem(4,26)=4</TT> 
(ligne débutant par <TT>"E"</TT>) et dans la colonne <TT>14</TT> du tableau 
<TT>CV</TT>.<BR>
<TT>"O"</TT> a donc pour code <TT>CV[4,14]="S"</TT> car :<BR>
</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD></TR>
</TABLE><P><BR>
On tape :
</P><PRE CLASS="verbatim">f(n,cara):=CV[irem(n,26),op(asc(cara))-65]:;
CV:=makemat((j,k)-&gt;char(65+irem(j+k,26)),26,26):;
codage(str):={
local j,k,c,s,code,CV;
s:=size(str);
CV:=makemat((j,k)-&gt;char(65+irem(j+k,26)),26,26):;
code:="";
pour j de 0 jusque s-1 faire
c:=str[j];
code:=code+CV[irem(j,26),op(asc(c))-65];
//code:=code+f(j,c);
fpour;
return code;
}:;
</PRE><P>On peut aussi ne pas utiliser <TT>CV</TT> :<BR>
On veut coder la lettre <TT>c</TT> qui est d’indice <TT>j</TT> dans le message.
Cette lettre <TT>c</TT> est de rang <TT>op(asc(c))-65</TT> dans l’alphabet.<BR>
Dans le tableau <TT>CV</TT> la lettre qui commence la ligne d’indice 
<TT>irem(j,26)</TT> est <TT>char(irem(j,26))+65</TT> et a comme code ASCII
<TT>irem(j,26)+65</TT>.<BR>
La lettre de cette ligne située à la colonne d’indice <TT>op(asc(c))-65</TT> a 
donc comme rang <TT>k:=irem(op(asc(c))-65+irem(j,26),26)</TT> dans l’alphabet.<BR>
La lettre de codage de <TT>c</TT> est donc char(k+65).<BR>
Par exemple si on cherche à coder <TT>"O"</TT> d’indice 4 du message (la 5ième lettre du message à coder).<BR>
<TT>"O"</TT> a comme rang <TT>op(asc("O"))-65=14</TT> dans l’alphabet (<TT>"O"</TT> 
est la 15ième lettre de l’alphabet).<BR>
Le codage est donc la lettre située dans la ligne d’indice <TT>irem(4,26)=4</TT> 
(ligne débutant par <TT>"E"</TT> ayant comme rang <TT>4</TT> dans l’alphabet) et 
dans la colonne <TT>14</TT> c’est donc la lettre <TT>"S"</TT> de rang <TT>4+14=18</TT> 
de l’alphabet (car <TT>"S"</TT> est la 19ième lettre de l’alphabet).<BR>
 Attention si la somme des 2 indices se fait modulo 26 car cette somme est 
l’indice d’une lettre de l’alphabet et cette somme ne doit pas dépasser 25,
c’est pourquoi <TT>k:=irem(op(asc(c))-65+irem(j,26),26)</TT>.<BR>
<TT>"O"</TT> a donc pour code <TT>"S"</TT>.<BR>
On tape :
</P><PRE CLASS="verbatim">codage(str):={
local j,k,c,s,code;
s:=size(str);
code:="";
pour j de 0 jusque s-1 faire
c:=str[j];
k:=irem(op(asc(c))-65+irem(j,26),26);
code:=code+char(k+65);
fpour;
return code;
}:;
</PRE><P>On tape :<BR>
<TT>codage("BONJOURBONJOURBONJOURBONJOUR")</TT><BR>
On obtient :<BR>
<TT>"BPPMSZXIWWTZGEPDDAGNLWKKHNUS"</TT>
</P><H3 CLASS="subsection"><A NAME="htoc330">12.10.4</A>  Le programme du décodage lettre par lettre</H3><P>
On utilise <TT>CV</TT> dans le programme :<BR>
Si la lettre à déchiffrer <TT>c</TT> est d’indice <TT>j</TT> dans le message à 
décoder, il faut chercher l’indice de la lettre <TT>c</TT> sur la ligne 
d’indice <TT>irem(j,26)]</TT> et trouver son indice <TT>k</TT> dans cette ligne sans 
utiliser la fonction <TT>member</TT>.<BR>
Propriété de la matrice <TT>CV</TT> :<BR>
On remarque que si pour <I>j</I>∈ 0..25 et <I>l</I>∈  "<I>A</I>".."<I>Z</I>" on définit :<BR>
<TT>f(j,l):=CV[op(asc(l))-65,irem(j,26)]</TT><BR>
<TT>g(j,l):=CV[irem(26-j,26),op(asc(l))-65]</TT><BR>
alors<BR>
<TT>f(j,g(j,l))=l</TT><BR>
Autrement dit si la lettre <TT>c</TT> est d’indice <TT>j</TT> dans 
le message codé alors la lettre d’indice <TT>j</TT> dans 
le message non codé est CV[irem(26-j,26),op(asc(c))-65].<BR>
Par exemple si on cherche à déchiffrer
<TT>"S"</TT> d’indice 4 (la 5ième lettre du message à décoder), il faut 
chercher l’indice de <TT>"S"</TT> dans la ligne d’indice 4. La lettre cherchèe a 
donc comme indices dans <TT>CV</TT> :<BR>
<TT>[irem(26-4,26), op(asc("S"))-65]=[22,18]</TT>.<BR>
 C’est donc <TT>CV[22,18]="O"</TT>.<BR>
On tape :
</P><PRE CLASS="verbatim">g(n,cara):=CV[irem(26-n,26),op(asc(cara))-65]:;
CV:=makemat((j,k)-&gt;char(65+irem(j+k,26)),26,26):;
decodage(str):={
local j,k,c,s,mess,CV;
s:=size(str);
CV:=makemat((j,k)-&gt;char(65+irem(j+k,26)),26,26):;
mess:="";
pour j de 0 jusque s-1 faire
c:=str[j];
//mess:=mess+g(j,c);
mess:=mess+CV[irem(26-j,26),op(asc(c))-65]
fpour;
return mess;
}:;
</PRE><P>On peut aussi ne pas utiliser <TT>CV</TT>.<BR>
Si la lettre à déchiffrer <TT>c</TT> est d’indice <TT>j</TT> dans le message à 
décoder, il faut chercher la lettre <TT>c</TT> sur la ligne 
d’indice <TT>irem(j,26)]</TT> et trouver son indice <TT>k</TT> dans cette ligne sans 
utiliser la fonction <TT>member</TT>.<BR>
Il suffit donc de faire la différence modulo 26, entre le rang de la 
lettre <TT>c</TT> dans l’alphabet (<TT>op(asc(c))-65</TT>) et l’indice 
<TT>irem(j,26)</TT> soit :<BR>
<TT>irem(op(asc(c))-65-irem(j,26),26)=irem(op(asc(c))-65-j,26)</TT>.<BR>
Par exemple si on cherche à déchiffrer
<TT>"S"</TT> d’indice 4 dans le message (la 5ième lettre du message à 
décoder), il faut chercher l’indice de <TT>"S"</TT> dans la ligne d’indice 4 
débutant par<TT>"E"</TT> :<BR>
</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD></TR>
</TABLE><P><BR>
L’indice de <TT>"S"</TT> dans la ligne d’indice 4 débutant par<TT>"E"</TT> est 
donc :<BR>
<TT>irem(op(asc("S"))-65-4,26)=irem(18-4,26)=14</TT>.<BR>
La lettre cherchèe a donc comme rang <TT>14</TT> dans l’alphabet.<BR>
C’est donc <TT>char(14+65)="O"</TT>.<BR>
On tape :
</P><PRE CLASS="verbatim">decodage1(str):={
local j,k,c,s,mess;
s:=size(str);
mess:="";
pour j de 0 jusque s-1 faire
c:=str[j];
k:=irem(op(asc(c))-65-j,26);
mess:=mess+char(k+65);
fpour;
return mess;
}:;
</PRE><P>On tape :<BR>
<TT>decodage("BPPMSZXIWWTZGEPDDAGNLWKKHNUS")</TT><BR>
On obtient :<BR>
<TT>"BONJOURBONJOURBONJOURBONJOUR"</TT>
</P><H3 CLASS="subsection"><A NAME="htoc331">12.10.5</A>  Le codage de Vigenère avec une clé</H3><P>
On voit qu’il est facile de faire le décodage d’un message si on ne donne
pas une clé.<BR>
La clé est un mot qui va nous servir à coder le message.<BR>
Prenons comme exemple une clé simple : "XCAS".<BR>
Si le message à coder est "BONJOUR", on écrit "XCAS" plusieurs fois sous le 
mot à coder :<BR>
<TT>"BONJOUR"</TT><BR>
<TT>"XCASXCA"</TT><BR>
puis, on utilise seulement le moceau du carré de Vigenère qui correspond
à la clè á savoir que les lignes qui commencent par "X","C","A","S":<BR>
</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left>&nbsp;</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD></TR>
<TR><TD VALIGN=top ALIGN=left>0</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD></TR>
<TR><TD VALIGN=top ALIGN=left>1</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD></TR>
<TR><TD VALIGN=top ALIGN=left>2</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD></TR>
<TR><TD VALIGN=top ALIGN=left>3</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD></TR>
</TABLE><P><BR>
Pour coder "BONJOUR", on code "B" avec "Y", (ligne 0 débutant par "X" et 
colonne "B"), "O" avec "Q" (ligne 1 débutant par "A" et colonne "O"), "N" 
avec "N", "J" avec "B", "O" avec "L", "U" avec "W" et "R" avec "R".<BR>
Le codage de "BONJOUR" est donc "YQNBLWR".<BR>
</P><H3 CLASS="subsection"><A NAME="htoc332">12.10.6</A>  Le programme du tableau de Vigenère avec une clé</H3><P>
Voici le programme qui donne en fonction de la clé utilisée, la matrice 
extraite de la matrice <TT>CV</TT> i.e. le carré de Vigenère.<BR>
 On tape :
</P><PRE CLASS="verbatim">TVAC(cle):={
local sc,VAC,CV;
sc:=size(cle);
CV:=makemat((j,k)-&gt;char(65+irem(j+k,26)),26,26);
VAC:=makemat(0,sc,26);
pour j de 0 jusque sc-1 faire
VAC[j]:=CV[op(asc(cle[j])-65)];
fpour;
return VAC;
}:;
</PRE><P>On tape :<BR>
<TT>TVAC("XCAS")</TT><BR>
On obtient :<BR>
</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD></TR>
<TR><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD></TR>
<TR><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD></TR>
<TR><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD></TR>
</TABLE><H3 CLASS="subsection"><A NAME="htoc333">12.10.7</A>  Le programme du codage</H3><P>
On peut utiliser la fonction <TT>TVAC</TT> pour programmer le codage de Vigenère 
avec une clé.<BR>
On veut coder la lettre <TT>c</TT> qui est d’indice <TT>j</TT> dans le message.
Cette lettre <TT>c</TT> est de rang <TT>op(asc(c))-65</TT> dans l’alphabet.<BR>
Il faut donc chercher dans le tableau <TT>VAC</TT> la lettre d’indice ligne 
<TT>irem(j,sc)</TT> et d’indice colonne <TT>op(asc(c))-65</TT> .<BR>
Par exemple si la clé est <TT>"XCAS"</TT> et que l’on cherche à coder
<TT>"O"</TT> d’indice 4 du message (la 5ième lettre du message à coder).<BR>
<TT>"O"</TT> a comme rang <TT>op(asc("O"))-65=14</TT> dans l’alphabet (<TT>"O"</TT> 
est la 15ième lettre de l’alphabet).<BR>
Le codage est donc la lettre située dans la ligne d’indice <TT>irem(4,4)=0</TT> 
(ligne débutant par <TT>"X"</TT>) et dans la colonne <TT>14</TT> du tableau 
<TT>VAC</TT>.<BR>
<TT>"O"</TT> a donc pour code <TT>VAC[0,14]="L"</TT> car :<BR>
</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD></TR>
</TABLE><P><BR>
On tape :
</P><PRE CLASS="verbatim">codagec0(str,cle):={
local j,k,c,s,sc,VAC,code;
s:=size(str);
VAC:=TVAC(cle);
sc:=size(cle);
code:="";
pour j de 0 jusque s-1 faire
c:=str[j];
code:=code+VAC[irem(j,sc),op(asc(c))-65];
fpour;
return code;
}:;
</PRE><P>On tape :<BR>
<TT>codagec0("BONJOUR","XCAS")</TT><BR>
On obtient :<BR>
<TT>"YQNBLWR"</TT><BR>
On tape :<BR>
<TT>codagec0("BONJOURBONJOUR","XCAS")</TT><BR>
On obtient :<BR>
<TT>"YQNBLWRTLPJGRT"</TT><BR>

On peut aussi n’utiliser que le carré de Vigenère <TT>CV</TT> pour coder.<BR>
On veut coder la lettre <TT>c</TT> qui est d’indice <TT>j</TT> dans le message.
Cette lettre <TT>c</TT> est de rang <TT>op(asc(c))-65</TT> dans l’alphabet.<BR>
Il faut donc chercher dans le tableau <TT>CV</TT> la lettre située dans la ligne 
débutant par <TT>cle[irem(j,sc)]</TT> qui est d’indice 
<TT>op(asc(cle[irem(j,sc)])-65)</TT> et d’indice colonne <TT>op(asc(c))-65</TT>.<BR>
Par exemple si la clé est <TT>"XCAS"</TT> et que l’on cherche à coder
<TT>"O"</TT> d’indice 4 du message (la 5ième lettre du message à coder).<BR>
<TT>"O"</TT> a comme rang <TT>op(asc("O"))-65=14</TT> dans l’alphabet (<TT>"O"</TT> 
est la 15ième lettre de l’alphabet et <TT>14</TT> est l’indice colonne de 
<TT>"O"</TT> du tableau CV).<BR>
Le codage est donc la lettre située dans le tableau <TT>CV</TT> à la ligne 
d’indice <TT>23</TT> (<TT>23</TT> est obtenu avec
<TT>op(asc(cle[irem(4,4)])-65)=op(asc(cle[0]))-65</TT>)
et à la colonne d’indice <TT>14</TT>.<BR>
<TT>"O"</TT> a donc pour code <TT>CV[23,14]="L"</TT>.<BR>
On tape : 
</P><PRE CLASS="verbatim">)
codagec1(str,cle):={
local j,k,c,s,sc,code,CV;
s:=size(str);
sc:=size(cle);
CV:=makemat((j,k)-&gt;char(65+irem(j+k,26)),26,26);
code:="";
pour j de 0 jusque s-1 faire
c:=str[j];
code:=code+CV[op(asc(cle[irem(j,sc)]))-65,op(asc(c))-65];
fpour;
return code;
}:;
</PRE><P>On tape :<BR>
<TT>codagec1("BONJOUR","XCAS")</TT><BR>
On obtient :<BR>
<TT>"YQNBLWR"</TT><BR>
On tape :<BR>
<TT>codagec1("BONJOURBONJOUR","XCAS")</TT><BR>
On obtient :<BR>
<TT>"YQNBLWRTLPJGRT"</TT><BR>
On tape :<BR>
<TT>codagec1("BONJOURBONJOURBONJOURBONJOUR","XCAS")</TT><BR>
On obtient :<BR>
<TT>"YQNBLWRTLPJGRTBGKLOMODOFGQUJ"</TT></P><H3 CLASS="subsection"><A NAME="htoc334">12.10.8</A>  Le programme du décodage</H3><P>
Comme pour le codage on peut utiliser la fonction <TT>TVAC</TT> pour programmer le 
décodage de Vigenère avec une clé.<BR>
Si la lettre à déchiffrer <TT>c</TT> est d’indice <TT>j</TT> dans le message à 
décoder, il faut chercher l’indice de la lettre <TT>c</TT> sur la ligne 
débutant par la lettre <TT>cle[irem(j,sc)]=VAC[0,irem(j,sc)]</TT> et trouver 
son indice <TT>k</TT> dans cette ligne sans utiliser la fonction <TT>member</TT>. 
Il suffit donc de faire la différence modulo 26, entre le code ASCII de la 
lettre <TT>c</TT> et celui de la lettre <TT>VAC[0,irem(j,sc)]</TT>.<BR>
Par exemple si la clé est <TT>"XCAS"</TT> et que l’on cherche à déchiffrer
<TT>"L"</TT> d’indice 4 (la 5ième lettre du message à décoder), il faut 
chercher l’indice de <TT>"L"</TT> dans la ligne débutant par <TT>VAC[0,0]="X"</TT> 
(<TT>"X"</TT> est <TT>VAC[0,0]</TT>) :<BR>
</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left>X</TD><TD VALIGN=top ALIGN=left>Y</TD><TD VALIGN=top ALIGN=left>Z</TD><TD VALIGN=top ALIGN=left>A</TD><TD VALIGN=top ALIGN=left>B</TD><TD VALIGN=top ALIGN=left>C</TD><TD VALIGN=top ALIGN=left>D</TD><TD VALIGN=top ALIGN=left>E</TD><TD VALIGN=top ALIGN=left>F</TD><TD VALIGN=top ALIGN=left>G</TD><TD VALIGN=top ALIGN=left>H</TD><TD VALIGN=top ALIGN=left>I</TD><TD VALIGN=top ALIGN=left>J</TD><TD VALIGN=top ALIGN=left>K</TD><TD VALIGN=top ALIGN=left>L</TD><TD VALIGN=top ALIGN=left>M</TD><TD VALIGN=top ALIGN=left>N</TD><TD VALIGN=top ALIGN=left>O</TD><TD VALIGN=top ALIGN=left>P</TD><TD VALIGN=top ALIGN=left>Q</TD><TD VALIGN=top ALIGN=left>R</TD><TD VALIGN=top ALIGN=left>S</TD><TD VALIGN=top ALIGN=left>T</TD><TD VALIGN=top ALIGN=left>U</TD><TD VALIGN=top ALIGN=left>V</TD><TD VALIGN=top ALIGN=left>W</TD></TR>
</TABLE><P>
On a :<BR>
<TT>VAC[0,0]=VAC[0,0]="X"</TT>
<TT>asc("L")=[76]</TT> et <TT>asc("X")=[88]</TT><BR>
<TT>op(asc("L"))=76</TT> et <TT>op(asc("X"))=88</TT><BR>
<TT>op(asc("L"))-op(asc("X"))=-12</TT><BR>
L’indice de <TT>"L"</TT> dans la ligne est donc <TT>irem(-12,26)=14</TT> et<BR>
<TT>char(14+65)="O"</TT>.
Le décodage de <TT>"L"</TT> d’indice 4 dans le message à 
décoder est donc <TT>"O"</TT> lorsque la clé est <TT>"XCAS"</TT>.<BR>
On tape :
</P><PRE CLASS="verbatim">decodagec0(str,cle):={
local j,k,c,s,sc,VAC,mess;
s:=size(str);
sc:=size(cle);
VAC:=TVAC(cle);
mess:="";
pour j de 0 jusque s-1 faire
c:=str[j];
//k:=member(c,VAC[irem(j,sc)])-1;
//k:=irem(op(asc(c))-op(asc(cle[irem(j,sc)])),26);
k:=irem(op(asc(c))-op(asc(VAC[0,irem(j,sc)])),26);
mess:=mess+char(k+65);
fpour;
return mess;
}:;
</PRE><P>On tape :<BR>
<TT>decodagec0("YQNBLWR","XCAS")</TT><BR>
On obtient :<BR>
<TT>"BONJOUR"</TT>
On tape :<BR>
<TT>decodagec0("YQNBLWRTLPJGRT","XCAS")</TT><BR>
On obtient :<BR>
<TT>"BONJOURBONJOUR"</TT>
On tape :<BR>
<TT>decodagec0("CYCPAQGKE","CHAISE")</TT><BR>
On obtient :<BR>
<TT>"ARCHIMEDE"</TT><BR>
Comme pour le codage on peut n’utiliser que le carré de Vigenère <TT>CV</TT> 
pour décoder.<BR>
On tape :
</P><PRE CLASS="verbatim">decodagec1(str,cle):={
local j,k,c,s,sc,VAC,mess,CV;
s:=size(str);
sc:=size(cle);
CV:=makemat((j,k)-&gt;char(65+irem(j+k,26)),26,26):;
mess:="";
pour j de 0 jusque s-1 faire
c:=str[j];
//mess:=mess+CV[26-op(asc(cle[irem(j,sc)]))+65,op(asc(c))-65];
k:=irem(op(asc(c))-op(asc(cle[irem(j,sc)])),26);
mess:=mess+char(k+65);
fpour;
return mess;
}:;
</PRE><P>On tape :<BR>
<TT>decodagec("YQNBLWR","XCAS")</TT><BR>
On obtient :<BR>
<TT>"BONJOUR"</TT>
On tape :<BR>
<TT>decodagec("YQNBLWRTLPJGRT","XCAS")</TT><BR>
On obtient :<BR>
<TT>"BONJOURBONJOUR"</TT>
On tape :<BR>
<TT>decodagec("CYCPAQGKE","CHAISE")</TT><BR>
On obtient :<BR>
<TT>"ARCHIMEDE"</TT><BR>
<B>Remarque</B><BR>
Lorsqu’on code avec le carré de Vigenère c’est comme si on avait choisit 
comme clé les 26 lettres de l’alphabet.<BR>
Pour passer des programmes de codage et de décodage sans clé avec les 
programmes de codage et de décodage avec clé qui n’utilise que CV, il 
suffit de remplacer l’indice <TT>j</TT> de la lettre à coder par 
<TT>jc:=op(asc(cle[irem(j,sc)]))-65</TT> où <TT>sc</TT> représente la longueur de
la clé.<BR>
Pour le codage on remplace :<BR>
<TT>code:=code+CV[irem(j,26),op(asc(c))-65];</TT><BR>
par :<BR>
<TT>code:=code+CV[op(asc(cle[irem(j,sc)]))-65,op(asc(c))-65];</TT><BR>
comme <TT>0&lt;=jc=op(asc(cle[irem(j,sc)]))-65&lt;=25</TT> il est inutile de chercher le 
reste de sa division par 26.<BR>
Pour le décodage on remplace :<BR>
<TT>mess:=mess+CV[irem(26-j,26),op(asc(c))-65];</TT><BR>
par :<BR>
<TT>mess:=mess+CV[26-op(asc(cle[irem(j,sc)]))+65,op(asc(c))-65];</TT>
ici encore le reste de de la division par 26 de <TT>26-jc</TT> est inutile !
</P><H3 CLASS="subsection"><A NAME="htoc335">12.10.9</A>  Peut-on décrypter sans connaitre la clé ?</H3><P>
Dans ce type de codage dit polyalphabétiques, on ne peut pas utiliser 
l’analyse des fréquences puisqu peusqu’un même caractère peut être 
codé par des caractères différents.<BR>
Mais le britannique Ch Babbage au 19 ième siecle a trouvé la parade.<BR>
Si on a choisit une clé de 4 lettres, chaque caractère peut être 
codé par au plus 4 caractères différents.<BR>
Si le texte est suffisamment long, on peut essayer de repérer dans le texte 
codé les mots qui se repétent et d’en déduire le nombre de lettres de la 
clé.<BR>
Par exemple :<BR>
<TT>codagec1("BONJOURBONJOURBONJOURBONJOURBONJOUR","XCAS")</TT><BR>
renvoie<BR>
<TT>"YQNBLWRTLPJGRTBGKLOMODOFGQUJYQNBLWR"</TT><BR>
On remarque que le premier et le dernier <TT>"BONJOUR"</TT> sont codés de la 
même façon et qu’entre 2 <TT>"Y"</TT> y a 27 lettres, 28 est donc 
un multiple du nombre de lettres de la clé......
Si on a plusieurs répétitions le nombre de lettres de la clé est un 
diviseur commun du nombre de lettre +1 qui sépare ces répétitions.<BR>
Si le nombre de lettres de la clé est 4 il reste alors à décoder 4 
chiffrements monoalphabétiques ....
</P><H3 CLASS="subsection"><A NAME="htoc336">12.10.10</A>  Exercice : codage et décodage globalement</H3><H4 CLASS="subsubsection">Codage sans une clé</H4><P>
Au lieu de coder ou de décoder lettre par lettre on va le faire globalement
<TT>ordres(mess):=asc(mess)-[65$(k=1..size(mess))];</TT>
<TT>transfCV(L):=[irem(j+L[j],26)$(j=0..size(L)-1)];</TT><BR>
<TT>codeA(LT):=[char(LT[j]+65)$(j=0..size(LT)-1)];</TT><BR>
<TT>mot(L):=ifte(L==[],"",L[0]+mot(tail(L)));</TT><BR>
Par exemple :<BR>
<TT>L:=ordres(("BONJOURBONJOURBONJOURBONJOURBONJOUR")</TT><BR>
renvoie<BR>
<TT>[1,14,13,9,14,20,17,1,14,13,9,14,20,17,1,14,13,9,14,20,17,1,14,13,9,14,20,17]</TT><BR>
<TT>LT:=transfCV(L)</TT><BR>
renvoie<BR>
<TT>[1,15,15,12,18,25,23,8,22,22,19,25,6,4,15,3,3,0,6,13,11,22,10,10,7,13,20,18]</TT><BR>
<TT>LA:=codeA(LT)</TT><BR>
renvoie<BR>
<TT>["B","P","P","M","S","Z","X","I","W","W","T","Z","G","E","P","D","D","A","G","N","L","W","K","K","H","N","U","S"]</TT><BR>
<TT>messcode:=mot(LA)</TT><BR>
renvoie<BR>
<TT>"BPPMSZXIWWTZGEPDDAGNLWKKHNUS"</TT></P><H4 CLASS="subsubsection">Décodage sans une clé</H4><P>
Il suffit de transformer <TT>transfCV</TT> en <TT>transgCV</TT> en utilisant la fonction <I>g</I> inverse de <I>f</I> :<BR>
<TT>transgCV(L):=[irem(26-j+L[j],26)$(j=0..size(L)-1)];</TT>
Par exemple :<BR>
<TT>Lde:=ordres("BPPMSZXIWWTZGEPDDAGNLWKKHNUS")</TT>
renvoie
<TT>[1,15,15,12,18,25,23,8,22,22,19,25,6,4,15,3,3,0,6,13,11,22,10,10,7,13,20,18]</TT>
<TT>LTde:=transgCV(Lde)</TT><BR>
renvoie<BR>
<TT>[1,14,13,9,14,20,17,1,14,13,9,14,20,17,1,14,13,9,14,20,17,1,14,13,9,14,20,17]</TT><BR>
<TT>mot(codeA(LTde))</TT><BR>
renvoie<BR>
<TT>"BONJOURBONJOURBONJOURBONJOUR"</TT>
</P><H4 CLASS="subsubsection">Codage avec une clé</H4><P>
<TT>ordres(mess):=asc(mess)-[65$(k=1..size(mess))];</TT>
<TT>transfCVcle(L,cle):=[irem((ordres(cle))[irem(j,size(cle))]+L[j],26)$(j=0..size(L)-1)];</TT><BR>
<TT>codeA(LT):=[char(LT[j]+65)$(j=0..size(LT)-1)];</TT><BR>
<TT>mot(L):=ifte(L==[],"",L[0]+mot(tail(L)));</TT><BR>
Par exemple :<BR>
<TT>L:=ordres(("BONJOURBONJOURBONJOURBONJOURBONJOUR")</TT><BR>
renvoie<BR>
<TT>[1,14,13,9,14,20,17,1,14,13,9,14,20,17,1,14,13,9,14,20,17,1,14,13,9,14,20,17]</TT><BR>
<TT>LTcle:=transfCVcle(L,"XCAS"</TT><BR>
renvoie<BR>
<TT>[24,16,13,1,11,22,17,19,11,15,9,6,17,19,1,6,10,11,14,12,14,3,14,5,6,16,20,9]</TT><BR>
<TT>LAcle:=codeA(LTcle)</TT><BR>
renvoie<BR>
<TT>["Y","Q","N","B","L","W","R","T","L","P","J","G","R","T","B","G","K","L","O","M","O","D","O","F","G","Q","U","J"]</TT><BR>
<TT>messcodecle:=mot(LAcle)</TT><BR>
renvoie<BR>
<TT>"YQNBLWRTLPJGRTBGKLOMODOFGQUJ"</TT>
</P><H4 CLASS="subsubsection">Décodage avec une clé</H4><P>
Il suffit de transformer <TT>transfCVcle</TT> en <TT>transgCVcle</TT> en utilisant la fonction <I>g</I> inverse de <I>f</I> :<BR>
<TT>transgCVcle(L,cle):=[irem(26-(ordres(cle))[irem(j,size(cle))]+L[j],26)$(j=0..size(L)-1)];</TT>
Par exemple :<BR>
<TT>Ldecle:=ordres("YQNBLWRTLPJGRTBGKLOMODOFGQUJ")</TT>
renvoie
<TT>[24,16,13,1,11,22,17,19,11,15,9,6,17,19,1,6,10,11,14,12,14,3,14,5,6,16,20,9]</TT>
<TT>LTdecle:=transgCVcle(Ldecle,"XCAS")</TT><BR>
renvoie<BR>
<TT>[1,14,13,9,14,20,17,1,14,13,9,14,20,17,1,14,13,9,14,20,17,1,14,13,9,14,20,17]</TT><BR>
<TT>mot(codeA(LTde))</TT><BR>
renvoie<BR>
<TT>"BONJOURBONJOURBONJOURBONJOUR"</TT>
</P><H4 CLASS="subsubsection">Le programme qui code et décode avec ou sans clé</H4><P><A NAME="sec:coddecod"></A>
Soit un message <TT>mess</TT> qui n’utilise que les 26 lettres majuscules de 
l’alphabet.
Voici le programme définitif qui code (si <TT>n&gt;0</TT>), qui décode (si 
<TT>n&lt;0</TT>) avec une clé ou sans clé (si <TT>cle=""</TT>).
On écrit la procédure récursive <TT>mot</TT> qui à une liste de 
caractères renvoie le mot formé par ses caractères.
</P><PRE CLASS="verbatim">mot(L):=ifte(L==[],"",L[0]+mot(tail(L)));
codage(mess,cle,n):={
local s,sc,messc,messcT,messTL;
  si (n==0) alors retourne "erreur n!=0" fsi;
  si (cle=="") alors cle:=char((65+j)$(j=0..25)); fsi;
  s:=size(mess);
  sc:=size(cle);
  messc:=asc(mess)-[65$ s];
  clec:=asc(cle)-[65$ sc];
  messcT:=[irem(sign(n)*clec[irem(j,sc)]+messc[j],26)$(j=0..s-1)];
  messTL:=[char(messcT[j]+65)$(j=0..s-1)];
  retourne mot(messTL);
}:;
</PRE><P>On tape :<BR>
<TT>codage("BONJOURBONJOURBONJOURBONJOUR","",1)</TT><BR>
On obtient :<BR>
<TT>"BPPMSZXIWWTZGEPDDAGNLWKKHNUS"</TT><BR>
On tape :<BR>
<TT>codage("BPPMSZXIWWTZGEPDDAGNLWKKHNUS","",-1)</TT><BR>
On obtient :<BR>
<TT>"BONJOURBONJOURBONJOURBONJOUR"</TT><BR>
On tape :<BR>
<TT>codage("BONJOURBONJOURBONJOURBONJOUR","XCAS",1)</TT><BR>
On obtient :<BR>
<TT>"YQNBLWRTLPJGRTBGKLOMODOFGQUJ"</TT><BR>
On tape :<BR>
<TT>codage("YQNBLWRTLPJGRTBGKLOMODOFGQUJ","XCAS",-1)</TT><BR>
On obtient :<BR>
<TT>"BONJOURBONJOURBONJOURBONJOUR"</TT>
</P><H2 CLASS="section"><A NAME="toc93"></A><A NAME="htoc337">12.11</A>  Codage RSA</H2><H3 CLASS="subsection"><A NAME="htoc338">12.11.1</A>  Le principe du codage avec clé publique et clé secrète</H3><P>
On suppose que l’on dispose d’un annuaire de clés (ce sont les clés 
publiques comme un annuaire de téléphone) qui permet d’envoyer à 
quelqu’un (par exemple à Tartanpion) un message que l’on code en se servant 
de la clé publique de Tartanpion. 
Mais seul Tartanpion pourra décoder les messages qu’il reçoit : il pourra
le faire grâce à sa clé secréte.<BR>
Autrement dit tout le monde sait comment il faut coder les messages pour 
Tartanpion : la fonction <I>f</I><SUB><I>T</I></SUB> de codage pour Tartanpion est connue mais la 
fonction <I>g</I><SUB><I>T</I></SUB> de décodage n’est connue que de Tartanpion car il existe des 
fonctions inversibles <I>f</I> dont l’inverse <I>g</I> est difficile à trouver.<BR>
</P><H3 CLASS="subsection"><A NAME="htoc339">12.11.2</A>  Codage avec signature, clé publique et clé secrète</H3><P>
Si Tartanpion reçoit un message provenant de Martin. Comment Tartanpion
peut-il être sûr que c’est bien Martin qui lui a envoyé ce message vu 
que sa clé publique est accessible à tout le monde ?<BR>
Martin et Tartanpion peuvent convenir de faire un codage avec signature :<BR>
Si la fonction <I>f</I><SUB><I>T</I></SUB> de codage pour Tartanpion est connue mais la 
fonction <I>g</I><SUB><I>T</I></SUB> de décodage n’est connue que de Tartanpion et
si la fonction <I>f</I><SUB><I>M</I></SUB> de codage pour Martin est connue mais la 
fonction <I>g</I><SUB><I>M</I></SUB> de décodage n’est connue que de Martin alors,<BR>
Martin codera les messages pour Tartanpion avec <I>f</I><SUB><I>T</I></SUB>o<I>g</I><SUB><I>M</I></SUB> c’est à dire en 
utilisant sa clé secréte puis la clé publique de Tartanpion et<BR>
Tartanpion décodera les messages provvenant de Martin avec <I>f</I><SUB><I>M</I></SUB>o<I>g</I><SUB><I>T</I></SUB> 
c’est à dire en utilisant sa clé secréte et la clé publique de Martin. 
</P><H3 CLASS="subsection"><A NAME="htoc340">12.11.3</A>  Le cryptage des nombres avec la méthode RSA </H3><P>
Cette méthode est due à Rivest Shamir et Adleman en 1977. Elle est basée 
sur le fait qu’il est facile de savoir si un nombre entier très grand <I>p</I> est 
premier, facile de faire le produit <I>n</I> de 2 nombres premiers tres grands <I>p</I> et <I>q</I> MAIS très difficile étant donné <I>n</I> de retrouver <I>p</I> et <I>q</I> c’est à dire de trouver la décomposition de <I>n</I> en facteurs premiers.<BR>
Tartanpion pour établir ses clés, choisit deux grand nombres premiers <I>p</I> 
et <I>q</I> et pose <I>n</I>=<I>pq</I>, puis 
il choisit <I>m</I> un nombre premier avec (<I>p</I>−1)(<I>q</I>−1) (par exemple il prend pour 
<I>m</I> un nombre premier plus grand que (<I>p</I>−1)/2 et que (<I>q</I>−1)/2).<BR>
Il calcule l’entier <I>u</I> pour que <I>u</I>*<I>m</I>=1 mod(<I>p</I>−1)*(<I>q</I>−1) (d’après 
l’identité de Bézout il existe des entiers <I>u</I> et <I>v</I> tel que 
<I>u</I>*<I>m</I>=1+<I>v</I>(<I>p</I>−1)*(<I>q</I>−1)). Puis il 
met dans l’annuaire les nombres <I>u</I> et <I>n</I> (quand <I>n</I> est grand <I>p</I> et <I>q</I> 
sont difficiles à obtenir à partir de <I>n</I>), le couple (<I>u</I>,<I>n</I>) est la clé 
publique alors que (<I>m</I>,<I>n</I>) est la clé secréte qui va servir à décoder 
le message : bien sûr <I>p</I> et <I>q</I> restent secrets, car sinon n’importe qui
peut calculer <I>m</I> en fonction de <I>u</I> avec l’identité de Bézout.</P><P>La fonction de codage <I>f</I> est la suivante :<BR>
à un entier <I>a</I> inférieur à <I>n</I>=<I>pq</I>
<I>f</I> fait correspondre <I>a</I><SUP><I>u</I></SUP> mod<I>n</I>.</P><P>La fonction de décodage <I>g</I> est la suivante :<BR>
à un entier <I>b</I>, <I>g</I> on fait correspondre <I>b</I><SUP><I>m</I></SUP> mod<I>n</I>.</P><P>Pour montrer que <I>g</I>(<I>f</I>(<I>a</I>))=<I>a</I>, on utilise le petit théorème de Fermat 
amélioré:<BR>
si <I>p</I> et <I>q</I> sont premiers, si <I>n</I>=<I>pq</I> si <I>a</I> est inférieur à <I>n</I>=<I>pq</I>
alors :<BR>
<I>a</I><SUP><I>k</I>(<I>p</I>−1)(<I>q</I>−1)+1</SUP>=<I>a</I>  mod  <I>n</I><BR>
On peut appliquer ce théorème ici car :
- si <I>a</I> est premier avec <I>n</I>, <I>p</I> et <I>q</I> sont premiers, <I>n</I>=<I>pq</I> et donc 
<I>a</I> est premier avec <I>p</I> et est premier avec <I>q</I> donc :<BR>
<I>a</I><SUP><I>v</I>(<I>p</I>−1)(<I>q</I>−1)</SUP>=1<SUP><I>v</I></SUP>=1  mod  <I>n</I> (d’après le petit théorème de Fermat)
<I>a</I><SUP><I>p</I>−1</SUP>=1  mod <I>p</I> et <I>a</I><SUP><I>q</I>−1</SUP>=1  mod <I>q</I> donc<BR>
<I>a</I><SUP><I>v</I>(<I>p</I>−1)(<I>q</I>−1)</SUP>=1<SUP><I>v</I></SUP>=1  mod  <I>p</I> et <I>a</I><SUP><I>v</I>(<I>p</I>−1)(<I>q</I>−1)</SUP>=1<SUP><I>v</I></SUP>=1  mod <I>q</I><BR>
 donc<BR>
<I>a</I><SUP><I>v</I>(<I>p</I>−1)(<I>q</I>−1)</SUP>=1<SUP><I>v</I></SUP>=1  mod  <I>n</I>.<BR>
 - si <I>a</I> n’est pas premier avec <I>n</I>, c’est que <I>a</I> est soit un multiple de 
<I>p</I> soit un multiple de <I>q</I> (puisque <I>a</I>&lt;<I>n</I>=<I>pq</I>). Supposons que <I>a</I> soit un 
multiple de <I>p</I>, <I>a</I> est donc premier avec <I>q</I> puisque <I>a</I>&lt;<I>p</I>*<I>q</I> et on a :<BR>
<I>a</I>=0 mod<I>p</I> donc <I>a</I><SUP><I>k</I>(<I>p</I>−1)(<I>q</I>−1)+1</SUP>=<I>a</I>=0  mod  <I>p</I><BR>
<I>a</I><SUP><I>q</I>−1</SUP>=1  mod  <I>q</I> car <I>q</I> est premier et <I>a</I> est premier avec <I>q</I> (th de 
Fermat), donc<BR>
<I>a</I><SUP><I>k</I>(<I>p</I>−1)(<I>q</I>−1)+1</SUP>=<I>a</I>  mod  <I>q</I><BR>
Donc <I>a</I><SUP><I>k</I>(<I>p</I>−1)(<I>q</I>−1)+1</SUP>−<I>a</I> est un multiple de <I>p</I> et de <I>q</I> donc est un
multiple de <I>n</I>=<I>pq</I> (car <I>p</I> et <I>q</I> sont premiers).<BR>
on a donc bien :<BR>
<I>g</I>(<I>f</I>(<I>a</I>))=<I>g</I>(<I>a</I><SUP><I>u</I></SUP>)  mod  <I>n</I>=<I>a</I><SUP><I>um</I></SUP>  mod  <I>n</I>=<I>a</I><SUP><I>v</I>(<I>p</I>−1)(<I>q</I>−1)+1</SUP> mod  <I>n</I>=<I>a</I><BR>
Un exemple :<BR>
<I>p</I>=123456791 et <I>q</I>=1234567891<BR>
:
<I>n</I>=<I>p</I>*<I>q</I>=152415790094497781<BR>
ϕ=(<I>p</I>−1)(<I>q</I>−1)=152415788736473100<BR>
<I>m</I>=12345701 (<I>m</I> est un nombre premier et <I>m</I> ne divise pas ϕ)<BR>
On cherche <I>u</I> en tapant <TT><I>inv</I>(<I>m</I> % ϕ)</TT> on trouve :<BR>
<TT>(-36645934363466299) % 152415788736473100 </TT> et on a :<BR>
<I>u</I>=−36645934363466299+ϕ=115769854373006801<BR>
Pour coder, on utilise la clé publique <I>u</I> et <I>n</I> et pour décoder, on 
utilise la clé secréte <I>m</I> et <I>n</I>.</P><P><B>Remarque</B><BR>
Pour passer d’un message à une suite de nombres, on groupe
plusieurs caractères (car sinon on pourrait décrypter le
message en utilisant des statistiques de fréquence des
caractères en fonction de la langue), le groupement est
l’écriture d’un nombre en une base donnée (256 ici correspondant
au codage ASCII d’un caractère), par exemple, puisque asc("BONJOUR")=[66,79,78,74,79,85,82], si on groupe par 3, 
<TT>BONJOUR </TT> devient les nombres
(66*256+79)*256+78=4345678, (74*256+79)*256+85=4869973, (82*256+0)*256+0 =5373952 qui seront transformés par 
<I>f</I> en 156330358492191937, 126697584810299952, 50295601528998788 car
powmod(4345678,u,n)=15633035849219193 etc...<BR>
Pour décoder on applique à ces nombres la fonction <I>g</I> on a :<BR>
powmod(15633035849219193,m,n)=4345678 etc...</P><H3 CLASS="subsection"><A NAME="htoc341">12.11.4</A>  La fonction de codage</H3><P>
Tartanpion choisit 2 grands nombres premiers <I>p</I> et <I>q</I> et met dans l’annuaire 
le nombre <I>n</I>=<I>p</I>*<I>q</I>.
Il est facile d’obtenir <I>n</I> à partir de <I>p</I> et <I>q</I> mais par contre <I>p</I> et <I>q</I>
sont difficiles à obtenir à partir de <I>n</I> car la décomposition en 
facteurs premiers de grands nombres est longue et presque impossible si <I>n</I> a 
plus de 130 chiffres.
</P><H4 CLASS="subsubsection">Première étape</H4><P>
On découpe le message en tranche ayant <I>ncara</I> caractères.
On choisit <I>ncara</I> en fonction des nombres <I>p</I> et <I>q</I> pour que 256<SUP><I>ncara</I></SUP> 
soit inférieur à <I>p</I> et à <I>q</I>. En effet, 
on considère que la tranche du message que l’on veut coder est l’écriture 
en base 256 d’un nombre : par exemple si <I>ncara</I>=5 "BABAR" est le nombre 
<I>a</I>=66*256<SUP>4</SUP>+65*256<SUP>3</SUP>+66*256<SUP>2</SUP>+65*256+82=284562702674
et on verra dans la section suivante que ces nombres <I>a</I>
doivent être premiers avec <I>n</I>=<I>p</I>*<I>q</I>, donc par exemple être inférieurs à 
<I>p</I> et <I>q</I> (ce qui est vérifié si 256<SUP><I>ncara</I></SUP>&lt;<I>p</I> et 256<SUP><I>ncara</I></SUP>&lt;<I>q</I> 
puisque <I>a</I>&lt;256<SUP><I>ncara</I></SUP>).) 
</P><H4 CLASS="subsubsection">Deuxième étape : un peu de maths</H4><P>
Le petit théorème de Fermat dit que :<BR>
si <I>n</I> est premier et si <I>a</I> est premier avec <I>n</I> alors <I>a</I><SUP><I>n</I>−1</SUP>=1  mod <I>n</I>.<BR>
Une généralisation (simple) du petit théorème de Fermat est :<BR>
si <I>p</I> et <I>q</I> sont premiers, si <I>a</I> est quelconque, si <I>n</I>=<I>p</I>*<I>q</I> et si <I>k</I> est 
un entier, alors :<BR>
<I>a</I><SUP><I>k</I>(<I>p</I>−1)*(<I>q</I>−1)+1</SUP>=<I>a</I>  mod <I>p</I>*<I>q</I>.<BR>
Montrons cette généralisation simple :<BR>
- si <I>a</I> est un multiple de <I>n</I> c’est évident puisque<BR>
<I>a</I>=0 mod<I>n</I> donc <I>a</I><SUP><I>k</I>(<I>p</I>−1)*(<I>q</I>−1)+1</SUP>=<I>a</I>=0  mod <I>n</I> 
- si <I>a</I> est premier avec <I>n</I> alors <I>a</I> est premier avec <I>q</I> (car <I>q</I> est un 
diviseur de <I>n</I>),<BR>
puisque <I>a</I> est premier avec <I>q</I> on a :<BR>
<I>a</I><SUP><I>q</I>−1</SUP>=1  mod <I>q</I> (application du petit théorème de 
Fermat) et<BR>
donc <I>a</I><SUP><I>k</I>(<I>q</I>−1)*(<I>p</I>−1)</SUP>=1  mod <I>q</I><BR>
puisque <I>a</I> est premier avec <I>p</I> on a:<BR>
 <I>a</I><SUP><I>p</I>−1</SUP>=1  mod <I>p</I> (application du petit 
théorème de Fermat)<BR>
donc <I>a</I><SUP><I>k</I>(<I>p</I>−1)*(<I>q</I>−1)</SUP>=1  mod <I>p</I> .<BR>
On en déduit donc que :<BR>
<I>a</I><SUP><I>k</I>(<I>p</I>−1)*(<I>q</I>−1)</SUP>−1=0  mod <I>p</I> et <I>a</I><SUP><I>k</I>(<I>p</I>−1)*(<I>q</I>−1)</SUP>−1=0  mod <I>q</I>
c’est à dire que :<BR>
 <I>a</I><SUP><I>k</I>(<I>p</I>−1)*(<I>q</I>−1)</SUP>−1 est un multiple de <I>p</I> et de <I>q</I> donc 
de <I>n</I>=<I>p</I>*<I>q</I> puisque <I>p</I> et <I>q</I> sont premiers.<BR>
donc <I>a</I><SUP><I>k</I>(<I>q</I>−1)*(<I>p</I>−1)</SUP>=1  mod <I>n</I> et donc<BR>
<I>a</I><SUP><I>k</I>(<I>q</I>−1)*(<I>p</I>−1)+1</SUP>=<I>a</I>  mod <I>n</I><BR>
- si <I>a</I> n’est pas premier avec <I>n</I> et si <I>a</I>&lt;<I>n</I>, c’est que <I>a</I> est soit un 
multiple de <I>p</I> soit un multiple de <I>q</I> (puisque <I>a</I>&lt;<I>n</I>=<I>pq</I>).<BR>
 Supposons que <I>a</I> soit un multiple de <I>p</I> :<BR>
<I>a</I>=0 mod<I>p</I> donc <I>a</I><SUP><I>k</I>(<I>p</I>−1)(<I>q</I>−1)+1</SUP>=<I>a</I>=0 mod<I>p</I><BR>
<I>a</I><SUP><I>q</I>−1</SUP>=1 mod<I>q</I> car <I>q</I> est premier et <I>a</I> est premier avec <I>q</I> (th de 
Fermat), donc<BR>
<I>a</I><SUP><I>k</I>(<I>p</I>−1)(<I>q</I>−1)+1</SUP>=<I>a</I> mod<I>q</I><BR>
Donc <I>a</I><SUP><I>k</I>(<I>p</I>−1)(<I>q</I>−1)+1</SUP>−<I>a</I> est un multiple de <I>p</I> et de <I>q</I> donc est un
multiple de <I>n</I>=<I>pq</I> (car <I>p</I> et <I>q</I> sont premiers).<BR>

Donc si <I>n</I>=<I>p</I>*<I>q</I> avec <I>p</I> et <I>q</I> premiers quelque soit <I>a</I> et quelque soit 
<I>k</I> entier on a :<BR>
<I>a</I><SUP><I>k</I>(<I>p</I>−1)*(<I>q</I>−1)</SUP>=<I>a</I>  mod <I>n</I> .<BR>

Revenons au codage.<BR>
Soit <I>m</I> un nombre premier avec (<I>p</I>−1)*(<I>q</I>−1) (par exemple on peut choisir pour
<I>m</I> un nombre premier assez grand).<BR>
D’après l’identité de Bézout il existe deux entiers <I>u</I> et <I>v</I> tels que :<BR>
<I>u</I>*<I>m</I>+<I>v</I>*(<I>p</I>−1)*(<I>q</I>−1)=1<BR>
 donc :<BR>
<I>a</I><SUP><I>u</I>*<I>m</I>+<I>v</I>*(<I>p</I>−1)*(<I>q</I>−1)</SUP>=<I>a</I><SUP>1</SUP> et comme <I>a</I><SUP>(<I>p</I>−1)*(<I>q</I>−1)</SUP>=1  mod <I>n</I>,<BR>
<I>a</I><SUP><I>u</I>*<I>m</I></SUP>=<I>a</I>  mod <I>n</I><BR>
La fonction <I>f</I> de codage sera alors :<BR>
<I>a</I>−&gt;<I>a</I><SUP><I>u</I></SUP> mod<I>n</I> pour <I>a</I>&lt;<I>p</I> et <I>a</I>&lt;<I>q</I> (pour avoir pgcd(<I>a</I>,<I>n</I>)=1).<BR>
La fonction <I>g</I> de décodage sera alors :<BR>
<I>b</I>−&gt;<I>b</I><SUP><I>m</I></SUP> mod<I>n</I>.<BR>
et on a bien <I>g</I>(<I>f</I>(<I>a</I>))=<I>a</I><SUP><I>u</I>*<I>m</I></SUP>=<I>a</I> mod<I>n</I>  ou encore <I>g</I>(<I>f</I>(<I>a</I>))=<I>a</I> car <I>a</I>&lt;<I>n</I><BR>
La clé publique se trouvant dans l’annuaire sera (<I>u</I>,<I>n</I>),<BR>
la clé secrète sera (<I>m</I>,<I>n</I>), mais bien sûr, <I>p</I> et <I>q</I> devront 
rester secrets.<BR>
Remarque : <I>u</I> et <I>m</I> jouent un rôle symétrique, par exemple <I>u</I> est 
aussi premier avec (<I>p</I>−1)(<I>q</I>−1) et donc si on connait <I>u</I>, <I>p</I> et <I>q</I> il
sera aisé de retrouver <I>m</I> avec l’identité de Bézout (<I>u</I>*<I>m</I>+<I>v</I>*(<I>p</I>−1)*(<I>q</I>−1)=1). 
</P><H4 CLASS="subsubsection">Troisième étape : le choix des clés</H4><P>
Comment vais-je choisir ma clé publique et ma clé secrète ?<BR>
Si on tape :<BR>
<TT>p:=nextprime(123456789)</TT> (<TT>p</TT> est un grand nombre premier),<BR>
<TT>q:=nextprime(1234567890)</TT> (<TT>q</TT> est un grand nombre premier),<BR>
<TT>n:=p*q</TT><BR>
<TT>m:=nextprime(12345678)</TT> (<TT>m</TT> est un nombre premier),<BR>
<TT>phi:=(p-1)*(q-1)</TT><BR>
On vérifie que m et premier avec <I>phi</I> en tapant :<BR>
<TT>gcd(m,(p-1)*(q-1))</TT>, on obtient bien <TT>1</TT>.<BR>
On obtient :<BR>
<I>p</I>=123456791, <I>q</I>= 1234567891, <I>m</I>=12345701, <I>phi</I>=152415788736473100<BR>
 et on a <I>n</I>=152415790094497781 (<I>n</I> a 18 chiffres).<BR>

On cherche <I>u</I> et <I>v</I> en tapant :
<TT>iegcd(m,phi)</TT> (<TT>u*m+v*phi=1</TT>)<BR>
on obtient : [-36645934363466299,2968326,1]<BR>
On tape <TT>u:=-36645934363466299+phi</TT> donc <I>u</I>=115769854373006801.<BR>
Donc, ma clé publique qui se trouvera dans l’annuaire sera (<I>u</I>,<I>n</I>),<BR>
ma clé secrète sera (<I>m</I>,<I>n</I>) <I>p</I> et <I>q</I> devront rester secrets.
Avec ce choix de <I>p</I> et de <I>q</I>, on va choisir de découper le message en 
tranches de 3 caractères (<I>ncara</I>=3)
car 256<SUP>3</SUP>=16777216&lt;<I>p</I>&lt;<I>q</I> et ainsi tout nombre inférieur à 256<SUP>3</SUP> sera
premier avec <I>n</I>
</P><H4 CLASS="subsubsection">Quatrième étape : le codage </H4><P>
Vous voulez m’envoyer le message "BABAR". Dans l’annuaire, vous trouvez en 
face de mon nom :<BR>
<I>u</I>=115769854373006801 et <I>n</I>=152415790094497781<BR>
Grâce à la première étape le mot "BABAR" est transformé en la liste de
nombres <TT>l=[4342082,16722]</TT> car<BR>
<TT>chaine2n("BAB") = 4342082 et chaine2n("AR") = 16722</TT>.<BR>
Vous calculez :
<I>f</I>(<I>a</I>)=<I>a</I><SUP><I>u</I></SUP> mod<I>n</I> grâce à la commande <TT>powmod(a,u,n)</TT><BR>
Vous obtenez :<BR>
<I>f</I>(4342082)=4342082<SUP>115769854373006801</SUP>= 6243987715571440 mod <I>n</I> car<BR>
 <TT>powmod(4342082,u,n) = 6243987715571440</TT>.<BR>
<I>f</I>(16722)=16722<SUP>115769854373006801</SUP>= 70206283680955159 mod <I>n</I> car<BR>
<TT>powmod(16722,u,n) =70206283680955159</TT>.<BR>
Le message codé est donc :<BR>
<TT>l=[6243987715571440,70206283680955159]</TT> et c’est cette liste de
nombres que vous m’envoyez.
Remarque : On ne transforme pas cette liste de nombres en un message de 
caractères car on risque d’avoir des caractères non imprimables.<BR>
Le codage transforme donc le message en une suite de nombres.
</P><H4 CLASS="subsubsection">Cinqième étape : le décodage</H4><P>
Le décodage transforme une suite de nombres en un message.<BR>
Je reçois <TT>l=[6243987715571440,70206283680955159]</TT> pour le décoder je
calcule pour chaque élément <I>b</I> de la liste :<BR>
<I>g</I>(<I>b</I>)=<I>b</I><SUP><I>m</I></SUP>   mod <I>n</I> grâce à la commande <TT>powmod(b,m,n)</TT><BR>
<I>g</I>(6243987715571440)=6243987715571440<SUP><I>m</I></SUP>= 4342082  mod <I>n</I> car<BR>
<TT>powmod(6243987715571440,m,n)=4342082</TT>.<BR>
<I>g</I>(70206283680955159)=70206283680955159<SUP><I>m</I></SUP>= 16722  mod <I>n</I> car<BR>
<TT>powmod(70206283680955159,m,n)=16722</TT>.<BR>
Il suffit maintenant de traduire le nombre <I>a</I>=4342082 en écrivant ce nombre 
dans la base 256 les symboles pour écrire 0&lt;<I>k</I>&lt;256 étant le caractére 
de code ASCII <I>k</I>.<BR>
Je tape :<BR>
<TT>irem(a,256)=66</TT><BR>
<TT>a:=iquo(a,256)= 16961</TT><BR>
puis <TT>irem(a,256)=65</TT><BR>
<TT>a:=iquo(a,256)=66</TT><BR>
<TT>irem(a,256)=66</TT><BR>
<TT>a:=iquo(a,256)=0</TT><BR>
on obtient la liste l=[66,65,66] qui correspond à "BAB"<BR>
puis pour <I>a</I>=16722<BR>
Je tape :<BR>
<TT>irem(a,256)=82</TT><BR>
<TT>a:=iquo(a,256)= 65</TT><BR>
puis <TT>irem(a,256)=65</TT><BR>
<TT>a:=iquo(a,256)=0</TT><BR>
on obtient la liste l=[65,82] qui correspond à "AR"
c’est ce que fait la fonction <TT>ecritu256(a)</TT> (cf <A HREF="#sec:ecritu">12.12</A>), on a :<BR>
 <TT>ecritu256(4342082)="BAB"</TT> et <TT>ecritu256(16722)="AR"</TT>
</P><H2 CLASS="section"><A NAME="toc94"></A><A NAME="htoc342">12.12</A>  Les programmes correspondants au codage et décodage RSA</H2><P><A NAME="sec:ecritu"></A>
les programmes qui suivent se trouvent dans le fichier <TT>rsa.xws</TT> du menu 
<TT>Exemples-&gt;arit</TT>.
</P><H4 CLASS="subsubsection">La première et la dernière étape</H4><PRE CLASS="verbatim">chaine2n(m):={
//chaine2n(m) transforme la chaine m en l'entier n 
//m est l'ecriture de n dans la base 256 
local l,n,s,k;
s:=size(m);
l:=asc(m);
n:=0;
for (k:=0;k&lt;s;k++){
n:=n*256+l[k];
}
return(n);
};

ecritu256(n):={
//transforme l'entier n en son ecriture en base 256
local s,r;
//n est un entier et b=256, ecritu256 est une fonction iterative 
//ecritu256(n)=le mot de caracteres l'ecriture de n en base 256 
s:="";
while (n&gt;=256){
r:=irem(n,256);
r:=char(r);
s:=r+s;
n:=iquo(n,256);
}
n:=char(n);
s:=n+s;
return(s);
};
</PRE><H4 CLASS="subsubsection">Le codage</H4><P>
En principe les valeurs de <I>p</I> et <I>q</I> sont beaucoup plus grandes et donc 
<I>ncara</I> le nombre de caractères par tranche peut être choisi plus grand 
que 3, il suffira alors dans le programme qui suit de d’initialiser <TT>ncara</TT>
par la valeur de <I>ncara</I> que l’on a choisie (ou de rajouter le paramètre 
<I>ncara</I> et remplacer tous les 3 par <I>ncara</I>). 
</P><PRE CLASS="verbatim">//mess est une chaine u:=115769854373006801 n:=152415790094497781
codrsa(mess,u,n):={
local s,j,j3,l,mot,ncara,k,a;
s:=size(mess);
j:=0;
ncara:=3;
j3:=ncara;
l:=[];
//j est le nombre de paquets de 3 lettres
while (j3&lt;s) {
mot:="";
for (k:=j;k&lt;j3;k++){
mot:=mot+mess[k];
}
//on code le mot
a:=chaine2n(mot);
l:=append(l,powmod(a,u,n));
j:=j3;
j3:=j+ncara;
}
mot:="";
for (k:=j;k&lt;s;k++){
mot:=mot+mess[k];
}
a:=chaine2n(mot);
l:=append(l,powmod(a,u,n));
return(l);
};
</PRE><H4 CLASS="subsubsection">Le décodage</H4><PRE CLASS="verbatim">//l=codrsa(mess,u,n) m:=12345701 n:=152415790094497781
decodrsa(l,m,n):={
local mess,s,a,j,b;
s:=size(l);
mess:="";
for (j:=0;j&lt;s;j++){
b:=l[j];
a:=powmod(b,m,n);
mess:=mess+ecritu256(a);
}
return(mess);
};
</PRE><H3 CLASS="subsection"><A NAME="htoc343">12.12.1</A>  Un exemple</H3><P>
<B>On envoie une liste de nombres</B><BR>
On veut coder le message : "Mon chat prefere Xcas"
Avec la clé secrète u:=115769854373006801,n:=152415790094497781 et<BR>
la clé publique m:=12345701,n:=152415790094497781.<BR>
On tape :<BR>
<TT>l:=codrsa("Mon chat prefere Xcas",u,n)</TT><BR>
On obtient la liste <TT>l</TT> de nombres qu’on envoie :<BR>
<TT>[31195019450305671,28742122827339904,95711325368572864,
31278264398990889,69628571922096941,10184568821703026,4849962211742328]</TT>
Le receveur tape :<BR>
<TT>decodrsa(l,m,n)</TT>
et il obtient :<BR>
<TT>"Mon chat prefere Xcas"</TT><BR>
<B>On envoie une liste de mots</B><BR>
Si on veut envoyer une liste <TT>s</TT> de mots il faut transformer la liste 
<TT>l</TT> en une liste de chaines de caractères 
l’aide de <TT>seq</TT> (ou de <TT>$</TT>) et de <TT>ecritu256</TT>.<BR>
On tape :<BR>
<TT>s:=seq(ecritu256(l[j]),j,0,size(l)-1)</TT><BR>
ou <TT>s:=[ecritu256(l[j])$(j=0..size(l)-1)]</TT><BR>
On obtient la liste <TT>s</TT> des mots qu’on envoie :<BR>
Le receveur tape :<BR>
<TT>decodrsa(seq(chaine2n(s[j]),j,0,size(s)-1),m,n)</TT><BR>
ou <TT>decodrsa([chaine2n(s[j])$(j=0..size(s)-1)],m,n)</TT><BR>
et il obtient :<BR>
<TT>"Mon chat prefere Xcas"</TT></P><H3 CLASS="subsection"><A NAME="htoc344">12.12.2</A>  Exercices de décodage RSA avec différents paramètres</H3><P>
<FONT SIZE=5><BR>
<BR>
<BR>

message 1, clefs u=115769854373006801, n=15241579009449778<BR>
</FONT></P><PRE CLASS="verbatim"><FONT SIZE=5>[19997497666981017, 33496307064035264, 
72208210789185231, 38104201170888279, 
56130089351291689, 108729853375227157,
136817903768324205, 81458241359929537]
</FONT></PRE><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 2, clefs u=115769854373006801, n=152415790094497781<BR>
</FONT></P><PRE CLASS="verbatim"><FONT SIZE=5>[58349203435709531, 75028631000317890,
101956612737443104, 110175082548593487,
118493016617194452,10653842382337002,
65709918090014837, 24509343625849117,
77226207180242279, 113156355216337045]
</FONT></PRE><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 3, clefs u=115769854373006801, n=152415790094497781<BR>
</FONT></P><PRE CLASS="verbatim"><FONT SIZE=5>[33980482988235109, 116825916853291998,
113895924367530643, 95775057248987857,
24977608335450648, 134968149482489339,
76334436210349648, 98925075877640635,
20555288284806828]
</FONT></PRE><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 4, clefs u=115769854373006801, n=152415790094497781<BR>
</FONT></P><PRE CLASS="verbatim"><FONT SIZE=5>[99352887245994702, 7452725220300033,
99097515262143188, 35018957119694836,
76149403346897851, 17052742903948315,
34401001263323402, 146933964211893603]
</FONT></PRE><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 5, clefs u=115769854373006801, n=152415790094497781<BR>
</FONT></P><PRE CLASS="verbatim"><FONT SIZE=5>[69885005423074530, 71482680640174902,
76566059181695815, 136817903768324205,
34106973474155998, 33620404767752971,
12729299234654259,20531594133810598]
</FONT></PRE><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 6, clefs u=115769854373006801, n=152415790094497781<BR>
</FONT></P><PRE CLASS="verbatim"><FONT SIZE=5>[58349203435709531, 68614189698168613,
95894768844660062, 130069211243087116,
130376871729616040, 74306178317514482,
125801418681172709, 128922533769427856,
138902168479749054]
</FONT></PRE><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 7, clefs u=115769854373006801, n=152415790094497781 
</FONT></P><PRE CLASS="verbatim"><FONT SIZE=5>[82887698188763362, 147317794362550340,
11063280558757506, 62347560564639831,
66591192455199994, 108687460796034362,
68698456418704171, 113895924367530643,
97840742991040396, 103130061177405851,
21744064573167843, 81810384887704706]
</FONT></PRE><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 8, clefs u=115769854373006801, n=152415790094497781<BR>
</FONT></P><PRE CLASS="verbatim"><FONT SIZE=5>[42711799087786740, 134878744490172482,
149439358926120238, 25442479184362935,
1828072730594369, 28742122827339904,
77333486723748758]
</FONT></PRE><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 9, clefs u=115769854373006801, n=152415790094497781<BR>
</FONT></P><PRE CLASS="verbatim"><FONT SIZE=5>[143623866399748045, 7966012486327335,
82446555671577207, 59363718845705744,
116869540684493084, 27219079163512489,
27219079163512489, 115256914037599394,
81123177371824181, 99166826446083588,
90648282883057820, 28314425697650614,
147744966399483701, 24903506954684046]
</FONT></PRE><P><FONT SIZE=5><BR>
<BR>
<BR>

message 10, clefs u=115769854373006801, n=152415790094497781<BR>
</FONT></P><PRE CLASS="verbatim"><FONT SIZE=5>[21958089817862266, 123349109967966870,
51927845315555689, 95894768844660062,
24509343625849117, 31027419256533256,
125503703895953175, 33160330760344892,
61040361422718323, 9544287545681754,
61022858667046639]
</FONT></PRE><P><FONT SIZE=5><BR>
<BR>
<BR>

message 11, clefs u=115769854373006801, n=152415790094497781<BR>
</FONT></P><PRE CLASS="verbatim"><FONT SIZE=5>[62981976688200842, 64536302600310087,
61310840516944212, 7486629931368896,
17472057692137769, 130815067487053887,
53351663594984181, 144381092812007128,
41251258816315103, 114751369092267608]
</FONT></PRE><P><FONT SIZE=5><BR>
<BR>
<BR>
</FONT></P><P><FONT SIZE=5>message 12, clefs u=115769854373006801, n=152415790094497781<BR>
</FONT></P><PRE CLASS="verbatim"><FONT SIZE=5>[123477331568497546, 46498884798484169,
99097515262143188, 7837029050945492,
17052742903948315, 106657774868209674,
48690166899675267, 79883234756846796,
118493016617194452, 10653842382337002,
128514412154198539, 142579296009343477,
28886262313123302, 76149403346897851,
123466365578590711, 123115348956556877]
</FONT></PRE><H3 CLASS="subsection"><A NAME="htoc345">12.12.3</A>  Solutions des exercices de décodage</H3><P>
1: vous allez gagner un CD<BR>
2: la solution n’est pas évidente<BR>
3: vive les logiciels libres<BR>
4: rien ne sert de courir<BR>
5: appelons un chat un chat<BR>
6: la réponse relève du défi<BR>
7: habiletés calculatoires obligatoires<BR>
8: il fait beau et chaud<BR>
9: l’utilisation de ce codage est discutable<BR>
10: nous voulons éviter la confusion<BR>
11: beaucoup de travail pour rien<BR>
12: science sans conscience n’est que ruine de l’ame<BR>

</P><H2 CLASS="section"><A NAME="toc95"></A><A NAME="htoc346">12.13</A>  Codage RSA avec signature</H2><P>
Avec des codages à clé publique comme RSA, n’importe qui peut vous envoyer
un message codé. La question qui se pose est : comment être sûr de
de l’identité de l’envoyeur ?<BR>
Avec le codage RSA, c’est assez facile car
si Tartanpion m’envoie un message codé avec signature, il va coder et signer
le message en utilisant <B>ma</B> clé publique et <B>sa</B> clé sectète.<BR>
Voici par exemple, les clés de codage et de décodage de Tartanpion.<BR>
<TT>ptar:=nextprime(223456789)</TT><BR>
<TT>qtar:=nextprime(823456789)</TT><BR>
<TT>mtar:=nextprime(32345678)</TT><BR>
<TT>phitar:=(ptar-1)*(qtar-1)</TT><BR>
<TT>ntar:=ptar*qtar</TT><BR>
On obtient :<BR>
<TT>ptar=223456811</TT>,<BR>
<TT>qtar= 823456811</TT>,<BR>
<TT>mtar= 32345689</TT> et<BR>
<TT>phitar=184007031935376100</TT><BR>
<TT>ntar=184007032982289721</TT> (<TT>ntar</TT> a 18 chiffres)<BR>
et on vérifie que <TT>mtar</TT> et premier avec <TT>phitar</TT> en tapant :<BR>
<TT>gcd(mtar,(ptar-1)*(qtar-1))</TT> on obtient bien <TT>1</TT>.<BR>
On cherche <TT>utar</TT> et <TT>vtar</TT> en tapant : <TT>egcd(mtar,phitar)</TT><BR>
 on obtient : [-44971265178398091,7905277,1].<BR>
On tape <TT>utar:=-44971265178398091+phitar</TT> donc<BR>
<TT>utar=139035766756978009</TT>.<BR>
Donc, la clé publique de Tartanpion (celle qui se trouve dans l’annuaire) 
sera <TT>(utar,ntar)</TT>,<BR>
sa clé secrète sera <TT>(mtar,ntar)</TT> mais <TT>ptar</TT> et <TT>qtar</TT> devront
rester secrets.<BR>
Tartanpion va coder le message <TT>mess</TT> qu’il veut m’envoyer selon un 
programme analogue à <TT>codrsa(mess,u,n)</TT> mais avant de mettre les nombres 
<TT>b</TT> dans la liste <TT>l</TT> il va utiliser sa fonction de décodage selon 
sa clé secrète et mettera dans <TT>l</TT> les nombres <TT>powmod(b,mtar,ntar)</TT>.<BR>
Il m’envoie donc <TT>codrsas(mess,u,n,mtar,ntar)</TT> (voir le programme ci-dessous).<BR>
Voici le détail du programme de codage avec signature <TT>codrsas</TT> (les 
programmes qui suivent se trouvent dans le fichier <TT>rsas</TT>) :
</P><PRE CLASS="verbatim">//mess=chaine 
//u:=115769854373006801 n:=152415790094497781 (ma cle publique)
//ntar:=184007032982289721 et mtar:=32345689 (cle secrete de Tar)
codrsas(mess,u,n,mtar,ntar):={
local s,j,j3,l,mot,a,b,ncara;
s:=size(mess);
j:=0;
ncara:=3
j3:=ncara;
l:=[];
//j est l'indice du premier \'el\'ement d'un paquet de 3 lettres
while (j3&lt;=s) {
mot:="";
for (k:=j;k&lt;j3;k++){
mot:=mot+mess[k];
}
//on code le mot
a:=chaine2n(mot);
b:=powmod(a,u,n); 
//fct de codage selon la cle publique (u,n) du receveur puis
//fct de decodage selon la cle secrete de l'envoyeur (mtar,ntar)
l:=append(l,powmod(b,mtar,ntar));
j:=j3;
j3:=j+ncara;
}
//on code la derniere tranche du message
mot:="";
for (k:=j;k&lt;s;k++){
mot:=mot+mess[k];
}
a:=chaine2n(mot);
b:=powmod(a,u,n);
l:=append(l,powmod(b,mtar,ntar));
return(l);
};
</PRE><P>Pour décoder il me suffira de coder les nombres <TT>b</TT> de la liste <TT>l</TT> 
en utilisant la clé publique de celui qui a signé le message 
(<TT>a:=powmod(b,utar,ntar)</TT>) puis, de décoder <TT>a</TT> en utilisant ma 
clé secréte (<TT>b:=powmod(a,u,n)</TT>). 
</P><PRE CLASS="verbatim">//l=codrsas(mess,u,n,mtar,ntar)
// m:=12345701 n:=152415790094497781 ma cle secrete (receveur)
//ntar:=184007032982289721 utar:=139035766756978009 cle pub de T 
decodrsas(l,m,n,utar,ntar):={
local mess,s,a,j,b;
s:=size(l);
mess:="";
for (j:=0;j&lt;s;j++){
b:=l[j];
//codage selon la cle publique (utar,ntar) de l'envoyeur (T)
a:=powmod(b,utar,ntar);
//decodage selon la cle secrete du receveur (m,n) (moi)
b:=powmod(a,m,n);
mess:=mess+ecritu256(b);
}
return(mess);
};
</PRE><P>Je reçois un message <TT>l</TT> signé de Tartanpion : je le décode en 
utilisant sa clé publique et ma clé secrète en tapant :<BR>
<TT>decodrsas(l,m,n,utar,ntar)</TT><BR>
Voici le détail avec <TT>mess:="demain 10 heures gare de Grenoble"</TT>.<BR>
<TT>l:=codrsas(mess,u,n,mtar,ntar)</TT><BR>
<TT>l:= [137370234628529043,113626149789068692,125222577739438308,<BR>
33473651820936779,42708525589347295,23751805405519257,<BR>
66289870504591745]</TT><BR>
<TT>decodrsas(l,m,n,utar,ntar)="demain 10 heures gare de Grenoble"</TT>
</P><H3 CLASS="subsection"><A NAME="htoc347">12.13.1</A>  Quelques précautions</H3><P>
Lorsqu’on envoie un message, il ne faut utiliser que les caractères dont les 
codes ASCII vont de 32 à 127. Il faut par exemple se méfier des 
caractères accentués qui n’ont pas toujours le même code...
Pour un codage avec signature on a des problèmes si on tape:<BR>
<TT>messcs:=decodrsa(codrsa(mess,u,n),mtar,ntar)</TT> car alors dans <TT>messcs</TT>
il figure très certainement des caractères qui ont des codes inférieurs
à 32 ou des codes supérieurs à 127.<BR>
Pour mémoire :<BR>
<TT>decodrsa(codrsa(mess,u,n),m,n)=mess</TT> car <TT>mess</TT> n’a que des 
caractères qui on des codes compris entre 32 et 127.</P><HR>
<A HREF="casrouge011.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="casrouge013.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
