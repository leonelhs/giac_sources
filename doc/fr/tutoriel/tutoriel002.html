<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="tutoriel.css">
<TITLE>Les objets du calcul formel</TITLE>
</HEAD>
<BODY >
<A HREF="tutoriel001.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="tutoriel003.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H2 CLASS="section"><A NAME="htoc5">2</A>&#XA0;&#XA0;Les objets du calcul formel</H2><H3 CLASS="subsection"><A NAME="toc4"></A><A NAME="htoc6">2.1</A>&#XA0;&#XA0;Les nombres</H3><P>
<A NAME="@default12"></A>
<A NAME="@default13"></A>
Les nombres peuvent &#XEA;tre exacts ou approch&#XE9;s.
Les nombres exacts sont les constantes pr&#XE9;d&#XE9;finies, les entiers, 
les fractions d&#X2019;entiers et plus g&#XE9;n&#XE9;ralement toute expression 
ne contenant que des entiers et des constantes, comme 
<CODE>sqrt(2)*e^(i*pi/3)</CODE>.
Les nombres approch&#XE9;s sont not&#XE9;s avec la notation scientifique 
standard&#XA0;: partie enti&#XE8;re suivie du point de s&#XE9;paration 
et partie fractionnaire (&#XE9;ventuellement
suivie de <CODE>e</CODE> et d&#X2019;un exposant).
Par exemple, <CODE>2</CODE> est un entier exact, 
<CODE>2.0</CODE> est la version approch&#XE9;e du m&#XEA;me
entier; <CODE>1/2</CODE> est un rationnel, <CODE>0.5</CODE> 
est la version approch&#XE9;e du m&#XEA;me
rationnel.
<TT>Xcas</TT> peut g&#XE9;rer des nombres entiers en pr&#XE9;cision arbitraire&#XA0;: 
essayez de taper <CODE>500!</CODE> et comptez le nombre de chiffres 
de la r&#XE9;ponse.</P><P>On passe d&#X2019;une valeur exacte &#XE0; une valeur approch&#XE9;e par
<CODE>evalf</CODE>, on transforme une valeur approch&#XE9;e en un rationnel
exact par <CODE>exact</CODE>
<A NAME="@default14"></A>
<A NAME="@default15"></A>
Les calculs sont effectu&#XE9;s en mode exact si tous les nombres qui
interviennent sont exacts. Ils sont effectu&#XE9;s en mode approch&#XE9; si
un des nombres est approch&#XE9;. Ainsi
<CODE>1.5+1</CODE> renvoie un nombre approch&#XE9; alors que <CODE>3/2+1</CODE> 
renvoie un nombre exact.
</P><PRE CLASS="verbatim">sqrt(2)
evalf(sqrt(2))
sqrt(2)-evalf(sqrt(2))
exact(evalf(sqrt(2)))*10^9
exact(evalf(sqrt(2)*10^9))
</PRE><P><A NAME="@default16"></A>
<A NAME="@default17"></A>
Pour les nombres r&#XE9;els approch&#XE9;s, la pr&#XE9;cision par d&#XE9;faut est
proche de 14 chiffres significatifs (la pr&#XE9;cision relative est de 53
ou 45 bits pour les r&#XE9;els flottants normalis&#XE9;s selon les versions de Xcas). 
Elle peut &#XEA;tre augment&#XE9;e, en
donnant le nombre de d&#XE9;cimales d&#XE9;sir&#XE9;
comme second argument de <CODE>evalf</CODE>.
</P><PRE CLASS="verbatim">evalf(sqrt(2),50)
evalf(pi,100)
</PRE><P>On peut aussi changer la pr&#XE9;cision par d&#XE9;faut pour tous les
calculs en modifiant
<A NAME="@default18"></A>
la variable <CODE>Digits</CODE>.
</P><PRE CLASS="verbatim">Digits:=50
evalf(pi)
evalf(exp(pi*sqrt(163)))
</PRE><P><A NAME="@default19"></A>
La lettre <CODE>i</CODE> est r&#XE9;serv&#XE9;e &#XE0; &#X221A;<SPAN style="text-decoration:overline">&#X2212;1</SPAN> et ne peut &#XEA;tre
r&#XE9;affect&#XE9;e&#XA0;; en particulier on ne peut pas l&#X2019;utiliser comme indice
de boucle.
</P><PRE CLASS="verbatim">(1+2*i)^2
(1+2*i)/(1-2*i)
e^(i*pi/3)
</PRE><P><A NAME="@default20"></A>
<A NAME="@default21"></A>
<TT>Xcas</TT> distingue l&#X2019;infini non sign&#XE9; <CODE>infinity</CODE> (&#X221E;), de
<CODE>+infinity</CODE> ou <CODE>inf</CODE> (+&#X221E;) et de <CODE>-infinity</CODE> 
ou <CODE>-inf</CODE>(&#X2212;&#X221E;).
</P><PRE CLASS="verbatim">1/0; (1/0)^2; -(1/0)^2 
</PRE><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP COLSPAN=2><B>Constantes pr&#XE9;d&#XE9;finies</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>pi</CODE></TD><TD ALIGN=left NOWRAP>&#X3C0;&#X2243; 3.14159265359</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>e</CODE></TD><TD ALIGN=left NOWRAP><I>e</I>&#X2243; 2.71828182846</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>i</CODE></TD><TD ALIGN=left NOWRAP><I>i</I>=&#X221A;<SPAN style="text-decoration:overline">&#X2212;1</SPAN></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>infinity</CODE></TD><TD ALIGN=left NOWRAP>&#X221E;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>+infinity</CODE> ou <CODE>inf</CODE></TD><TD ALIGN=left NOWRAP>+&#X221E;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>-infinity</CODE> ou <CODE>-inf</CODE></TD><TD ALIGN=left NOWRAP>&#X2212;&#X221E;</TD></TR>
</TABLE>
</DIV><P>
<A NAME="@default22"></A>
<A NAME="@default23"></A>
</P><H3 CLASS="subsection"><A NAME="toc5"></A><A NAME="htoc7">2.2</A>&#XA0;&#XA0;Les caract&#XE8;res et les cha&#XEE;nes</H3><P>
<A NAME="@default24"></A>
<A NAME="@default25"></A>
Une cha&#XEE;ne est parenth&#XE9;s&#XE9;e par des guillemets (<TT>"</TT>).
Un caract&#XE8;re est une cha&#XEE;ne ayant un seul &#XE9;l&#XE9;ment.
</P><PRE CLASS="verbatim">s:="azertyuiop"
size(s)
s[0]+s[3]+s[size(s)-1]
concat(s[0],concat(s[3],s[size(s)-1]))
head(s)
tail(s)
mid(s,3,2)
l:=asc(s)
ss:=char(l)
string(123)
expr(123)
expr(0123)
</PRE><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP COLSPAN=2><B>Cha&#XEE;nes</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>asc</CODE></TD><TD ALIGN=left NOWRAP>cha&#XEE;ne-&gt;liste des codes ASCII</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>char</CODE></TD><TD ALIGN=left NOWRAP>liste des codes ASCII-&gt;cha&#XEE;ne</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>size</CODE></TD><TD ALIGN=left NOWRAP>nombre de caract&#XE8;res</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>concat</CODE> ou <CODE>+</CODE></TD><TD ALIGN=left NOWRAP>concat&#XE9;nation</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>mid</CODE></TD><TD ALIGN=left NOWRAP>morceau de cha&#XEE;ne</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>head</CODE></TD><TD ALIGN=left NOWRAP>premier caract&#XE8;re</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>tail</CODE></TD><TD ALIGN=left NOWRAP>cha&#XEE;ne sans le 1ier caract&#XE8;re</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>string</CODE></TD><TD ALIGN=left NOWRAP>nombre ou expression-&gt;cha&#XEE;ne</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>expr</CODE></TD><TD ALIGN=left NOWRAP>cha&#XEE;ne-&gt;nombre (base 10 ou 8) ou expression</TD></TR>
</TABLE>
</DIV><H3 CLASS="subsection"><A NAME="toc6"></A><A NAME="htoc8">2.3</A>&#XA0;&#XA0;Les variables</H3><P>
<A NAME="@default26"></A>
<A NAME="@default27"></A>
On dit qu&#X2019;une variable est formelle si elle ne contient aucune valeur&#XA0;: 
toutes les variables sont formelles tant qu&#X2019;elles n&#X2019;ont pas &#XE9;t&#XE9;
affect&#XE9;es (&#XE0; une valeur).
<A NAME="@default28"></A>
L&#X2019;affectation est not&#XE9;e <CODE>:=</CODE>. Au d&#XE9;but 
de la session <CODE>a</CODE> 
est formelle, elle devient affect&#XE9;e apr&#XE8;s l&#X2019;instruction 
<CODE>a:=3</CODE>, <CODE>a</CODE> sera alors remplac&#XE9; par 3 dans tous
les calculs qui suivent, et <CODE>a+1</CODE> renverra 4. 
<TT>Xcas</TT> conserve tout le contenu de votre session. Si vous voulez que la variable 
<CODE>a</CODE> apr&#XE8;s l&#X2019;avoir affect&#XE9;e, soit &#XE0; nouveau une variable formelle, il
faut la "vider" par <CODE>purge(a)</CODE>. Dans les exemples qui suivent, les 
variables utilis&#XE9;es sont suppos&#XE9;es avoir &#XE9;t&#XE9; purg&#XE9;es avant chaque
suite de commandes.
<A NAME="@default29"></A> 
Il ne faut pas confondre
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
le signe <CODE>:=</CODE> qui d&#XE9;signe l&#X2019;affectation
</LI><LI CLASS="li-itemize">le signe <CODE>==</CODE> qui d&#XE9;signe une &#XE9;galit&#XE9;
bool&#XE9;enne&#XA0;: c&#X2019;est une op&#XE9;ration binaire qui retourne 1 ou 0 (1 pour true
qui veut dire Vrai et 0 pour false qui veut dire Faux) 
</LI><LI CLASS="li-itemize">le signe <CODE>=</CODE> utilis&#XE9; pour d&#XE9;finir une &#XE9;quation.
</LI></UL><P>
<A NAME="@default30"></A>
<A NAME="@default31"></A>
</P><PRE CLASS="verbatim">a==b
a:=b
a==b
solve(a=b,a)
solve(2*a=b+1,a)
</PRE><P><A NAME="@default32"></A>
<A NAME="@default33"></A>
On peut faire certains types d&#X2019;hypoth&#XE8;ses sur une variable avec
la commande <CODE>assume</CODE>, par exemple <CODE>assume(a&gt;2)</CODE>. Une
hypoth&#XE8;se est une forme sp&#XE9;ciale d&#X2019;affectation, elle efface
une &#XE9;ventuelle valeur pr&#XE9;c&#XE9;demment affect&#XE9;e &#XE0; la variable.
Lors d&#X2019;un calcul, la variable n&#X2019;est pas remplac&#XE9;e mais
l&#X2019;hypoth&#XE8;se sera utilis&#XE9;e dans la mesure du possible, par exemple
<CODE>abs(a)</CODE> renverra <CODE>a</CODE> si on fait l&#X2019;hypoth&#XE8;se <CODE>a&gt;2</CODE>.
</P><PRE CLASS="verbatim">sqrt(a^2)
assume(a&lt;0)
sqrt(a^2)
assume(n,integer)
sin(n*pi)
</PRE><P><A NAME="@default34"></A>
La fonction <CODE>subst</CODE> permet de remplacer une variable dans une
expression par un nombre ou une autre expression, 
sans affecter cette variable.
</P><PRE CLASS="verbatim">subst(a^2+1,a=1)
subst(a^2+1,a=sqrt(b-1))
a^2+1
</PRE><P><B>Remarque</B>&#XA0;: pour stocker une valeur dans une variable par r&#XE9;f&#XE9;rence,
par exemple pour modifier une valeur dans une liste (un vecteur, une
matrice), sans recr&#XE9;er une nouvelle liste mais en modifiant
en place la liste existante, on utilise l&#X2019;instruction <CODE>=&lt;</CODE>
au lieu de <CODE>:=</CODE>.
Cette instruction est plus rapide que l&#X2019;instruction <CODE>:=</CODE>, car
elle &#XE9;conomise le temps de copie de la liste.
</P><H3 CLASS="subsection"><A NAME="toc7"></A><A NAME="htoc9">2.4</A>&#XA0;&#XA0;Les expressions</H3><P>
<A NAME="@default35"></A>
Une expression est une combinaison de nombres et de variables
reli&#XE9;s entre eux par des op&#XE9;rations&#XA0;: par exemple 
<CODE>x^2+2*x+c</CODE>. </P><P>Lorsqu&#X2019;on valide une commande, <TT>Xcas</TT>
remplace les variables par leur valeur si elles en ont une,
et ex&#XE9;cute les op&#XE9;rations. 
</P><PRE CLASS="verbatim">(a-2)*x^2+a*x+1
a:=2
(a-2)*x^2+a*x+1
</PRE><P><A NAME="@default36"></A>
Certaines op&#XE9;rations de simplification sont ex&#XE9;cut&#XE9;es
automatiquement lors d&#X2019;une &#XE9;valuation&#XA0;:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
les op&#XE9;rations sur les entiers et sur les 
fractions, y compris la mise
sous forme irr&#XE9;ductible
</LI><LI CLASS="li-itemize">les simplifications triviales comme <I>x</I>+0=<I>x</I>,
<I>x</I>&#X2212;<I>x</I>=0, <I>x</I><SUP>1</SUP>=<I>x</I>&#X2026;</LI><LI CLASS="li-itemize">quelques formes trigonom&#XE9;triques comme 
cos(&#X2212;<I>x</I>)=cos(<I>x</I>), cos(&#X3C0;/4)=&#X221A;<SPAN style="text-decoration:overline">2</SPAN>/2, tan(&#X3C0;/4)=1&#X2026;</LI></UL><P>
Nous verrons dans la section suivante comment obtenir plus de simplifications.
</P><H3 CLASS="subsection"><A NAME="toc8"></A><A NAME="htoc10">2.5</A>&#XA0;&#XA0;D&#XE9;velopper et simplifier</H3><P>
<A NAME="@default37"></A>
<A NAME="@default38"></A>
En-dehors des r&#XE8;gles de la section pr&#XE9;c&#XE9;dente,
il n&#X2019;y a pas de simplification syst&#XE9;matique. 
Il y a deux raisons &#XE0; cela. La premi&#XE8;re est que les 
simplifications non triviales sont parfois
co&#XFB;teuses en temps, et le choix d&#X2019;en faire ou non est laiss&#XE9; 
&#XE0; l&#X2019;utilisateur&#XA0;;
la deuxi&#XE8;me est qu&#X2019;il y a en g&#XE9;n&#XE9;ral plusieurs mani&#XE8;res de
simplifier une m&#XEA;me expression, selon l&#X2019;usage que l&#X2019;on veut en
faire. 
Les principales commandes pour transformer une expression 
sont les suivantes&#XA0;:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A NAME="@default39"></A>
<CODE>expand</CODE>&#XA0;: d&#XE9;veloppe une expression en tenant compte 
uniquement de la distributivit&#XE9; de la multiplication sur l&#X2019;addition et
du d&#XE9;veloppement des puissances enti&#XE8;res.
</LI><LI CLASS="li-itemize"><A NAME="@default40"></A>
<A NAME="@default41"></A>
<CODE>normal</CODE> et <CODE>ratnormal</CODE>&#XA0;: 
d&#X2019;un bon rapport temps d&#X2019;ex&#XE9;cution-simplification, elles
&#XE9;crivent une fraction rationnelle (rapport de deux polyn&#XF4;mes)
sous forme de fraction irr&#XE9;ductible d&#XE9;velopp&#XE9;e; <CODE>normal</CODE>
tient compte des nombres alg&#XE9;briques (par exemple comme <CODE>sqrt(2)</CODE>)
mais pas <CODE>ratnormal</CODE>. Les deux ne tiennent pas compte des relations
entre fonctions transcendantes (par exemple comme <CODE>sin</CODE> et <CODE>cos</CODE>).
</LI><LI CLASS="li-itemize"><A NAME="@default42"></A>
<CODE>factor</CODE>&#XA0;: un peu plus lente que les pr&#XE9;c&#XE9;dentes, elle
&#XE9;crit une fraction sous forme irr&#XE9;ductible factoris&#XE9;e.
</LI><LI CLASS="li-itemize"><A NAME="@default43"></A>
<CODE>simplify</CODE>&#XA0;: elle essaie de se ramener &#XE0;
des variables alg&#XE9;briquement ind&#XE9;pendantes avant d&#X2019;appliquer
<CODE>normal</CODE>. Ceci est plus co&#XFB;teux en temps et "aveugle" (on
ne contr&#XF4;le pas les r&#XE9;&#XE9;critures interm&#XE9;diaires).
Les simplifications faisant intervenir des extensions
alg&#XE9;briques (par exemple des racines carr&#XE9;es) 
n&#XE9;cessitent parfois deux appels et/ou des hypoth&#XE8;ses (<CODE>assume</CODE>)
pour enlever des valeurs absolues avant d&#X2019;obtenir la simplification
souhait&#XE9;e.
</LI><LI CLASS="li-itemize"><A NAME="@default44"></A>
<CODE>tsimplify</CODE> essaie de se ramener &#XE0; des variables 
alg&#XE9;briquement ind&#XE9;pendantes mais sans appliquer <CODE>normal</CODE>
ensuite.
</LI></UL><P>
Dans le menu <CODE>Expression</CODE> du bandeau sup&#XE9;rieur, les sous-menus sont
des menus de r&#XE9;&#XE9;criture et contiennent d&#X2019;autres fonctions, pour des 
transformations plus ou moins sp&#XE9;cialis&#XE9;es. 
</P><PRE CLASS="verbatim">b:=sqrt(1-a^2)/sqrt(1-a)
ratnormal(b)
normal(b)
tsimplify(b)
simplify(b)
simplify(simplify(b))
assume(a&lt;1)
simplify(b)   
simplify(simplify(b))
</PRE><P><A NAME="@default45"></A>
La fonction <CODE>convert</CODE> permet de passer d&#X2019;une expression &#XE0; une
autre &#XE9;quivalente, sous un format qui est sp&#XE9;cifi&#XE9; par le
deuxi&#XE8;me argument. 
</P><PRE CLASS="verbatim">convert(exp(i*x),sincos)
convert(1/(x^4-1),partfrac)
convert(series(sin(x),x=0,6),polynom)
</PRE><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP COLSPAN=2><B>Transformations</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>simplify</CODE></TD><TD ALIGN=left NOWRAP>simplifier</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>tsimplify</CODE></TD><TD ALIGN=left NOWRAP>simplifier (moins puissant)</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>normal</CODE></TD><TD ALIGN=left NOWRAP>forme normale</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>ratnormal</CODE></TD><TD ALIGN=left NOWRAP>forme normale (moins puissant)</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>expand</CODE></TD><TD ALIGN=left NOWRAP>d&#XE9;velopper</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>factor</CODE></TD><TD ALIGN=left NOWRAP>factoriser</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>assume</CODE></TD><TD ALIGN=left NOWRAP>rajout d&#X2019;hypoth&#XE8;ses</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>convert</CODE></TD><TD ALIGN=left NOWRAP>transformer en un format sp&#XE9;cifi&#XE9;</TD></TR>
</TABLE>
</DIV><H3 CLASS="subsection"><A NAME="toc9"></A><A NAME="htoc11">2.6</A>&#XA0;&#XA0;Les fonctions</H3><P>
De nombreuses fonctions sont d&#XE9;j&#XE0; d&#XE9;finies dans <TT>Xcas</TT>, en
particulier les fonctions classiques. Les plus courantes figurent dans
le tableau ci-apr&#XE8;s; pour les autres, voir le menu <CODE>Cmds-&gt;Reel-&gt;Special</CODE>.<BR>

Sinon l&#X2019;utilisateur peut d&#XE9;finir ses propre fonctions, par exemple :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
D&#XE9;finition d&#X2019;une fonction d&#X2019;une variable :<BR>
<TT>f(x):=x*exp(x)</TT> ou<BR>
<TT>f:=x-&gt;x*exp(x)</TT> ou<BR>
<TT>f:=unapply(x*exp(x),x)</TT>
</LI><LI CLASS="li-itemize">D&#XE9;finition de sa d&#XE9;riv&#XE9;e :<BR>
<TT>g:=function_diff(f)</TT> ou<BR>
<TT>g:=unapply(diff(f(x),x),x)</TT>)<BR>
<B>ATTENTION</B> <TT>g(x):=diff(f(x),x)</TT> N&#X2019;EST PAS VALABLE ! car ce qui est 
&#XE0; droite de <TT>:=</TT> n&#X2019;est pas &#XE9;valu&#XE9; lors de la d&#XE9;finition....il
faut utiliser <TT>unapply</TT>.
</LI><LI CLASS="li-itemize">D&#XE9;finition d&#X2019;une fonction de 2 variables :<BR>
<TT>h(r,t):=(r*exp(t),r*t)</TT> ou<BR>
<TT>h:=(r,t)-&gt;(r*exp(t),r*t);</TT>
</LI><LI CLASS="li-itemize">D&#XE9;finition &#XE0; partir d&#X2019;une fonction de 2 variables, d&#X2019;une fonction qui
&#XE0; 1 variable fait correspondre une fonction:<BR>
<TT>k(t):=unapply(h(r,t),r)</TT><BR>
<B>ATTENTION</B> Ici <TT>k(t)</TT> est une fonction de la variable <TT>r</TT>
qui &#XE0; <TT>r</TT> fait 
correspondre <TT>h(r,t)</TT>. On a par exemple : <TT>k(1)(2)=(2*exp(1),2)</TT>. L&#XE0; aussi, il faut 
utiliser <TT>unapply</TT>.
</LI></UL><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP COLSPAN=2><B>Fonctions classiques</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>abs</CODE></TD><TD ALIGN=left NOWRAP>valeur absolue</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>sign</CODE></TD><TD ALIGN=left NOWRAP>signe (-1,0,+1)</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>max</CODE></TD><TD ALIGN=left NOWRAP>maximum</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>min</CODE></TD><TD ALIGN=left NOWRAP>minimum</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>round</CODE></TD><TD ALIGN=left NOWRAP>arrondi</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>floor</CODE></TD><TD ALIGN=left NOWRAP>partie enti&#XE8;re (plus grand entier &#X2264;)</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>frac</CODE></TD><TD ALIGN=left NOWRAP>partie fractionnaire</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>ceil</CODE></TD><TD ALIGN=left NOWRAP>plus petit entier &#X2265;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>re</CODE></TD><TD ALIGN=left NOWRAP>partie r&#XE9;elle</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>im</CODE></TD><TD ALIGN=left NOWRAP>partie imaginaire</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>abs</CODE></TD><TD ALIGN=left NOWRAP>module</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>arg</CODE></TD><TD ALIGN=left NOWRAP>argument</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>conj</CODE></TD><TD ALIGN=left NOWRAP>conjugu&#XE9;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>affixe</CODE></TD><TD ALIGN=left NOWRAP>affixe</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>coordonees</CODE></TD><TD ALIGN=left NOWRAP>coordonn&#XE9;es</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>factorial ou !</CODE></TD><TD ALIGN=left NOWRAP>factorielle</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>sqrt</CODE></TD><TD ALIGN=left NOWRAP>racine carr&#XE9;e</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>exp</CODE></TD><TD ALIGN=left NOWRAP>exponentielle</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>log</CODE></TD><TD ALIGN=left NOWRAP>logarithme naturel</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>ln</CODE></TD><TD ALIGN=left NOWRAP>logarithme naturel</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>log10</CODE></TD><TD ALIGN=left NOWRAP>logarithme en base 10</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>sin</CODE></TD><TD ALIGN=left NOWRAP>sinus</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>cos</CODE></TD><TD ALIGN=left NOWRAP>cosinus</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>tan</CODE></TD><TD ALIGN=left NOWRAP>tangente</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>cot</CODE></TD><TD ALIGN=left NOWRAP>cotangente</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>asin</CODE></TD><TD ALIGN=left NOWRAP>arc sinus</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>acos</CODE></TD><TD ALIGN=left NOWRAP>arc cosinus</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>atan</CODE></TD><TD ALIGN=left NOWRAP>arc tangente</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>sinh</CODE></TD><TD ALIGN=left NOWRAP>sinus hyperbolique</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>cosh</CODE></TD><TD ALIGN=left NOWRAP>cosinus hyperbolique</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>tanh</CODE></TD><TD ALIGN=left NOWRAP>tangente hyperbolique</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>asinh</CODE></TD><TD ALIGN=left NOWRAP>argument sinus hyperbolique</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>acosh</CODE></TD><TD ALIGN=left NOWRAP>argument cosinus hyperbolique</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>atanh</CODE></TD><TD ALIGN=left NOWRAP>argument tangente hyperbolique</TD></TR>
</TABLE>
</DIV><P>
<A NAME="@default46"></A>
<A NAME="@default47"></A>
<A NAME="@default48"></A>
<A NAME="@default49"></A>
<A NAME="@default50"></A>
<A NAME="@default51"></A>
<A NAME="@default52"></A>
<A NAME="@default53"></A>
<A NAME="@default54"></A>
<A NAME="@default55"></A>
<A NAME="@default56"></A>
<A NAME="@default57"></A>
<A NAME="@default58"></A>
<A NAME="@default59"></A>
<A NAME="@default60"></A>
<A NAME="@default61"></A>
<A NAME="@default62"></A>
<A NAME="@default63"></A>
<A NAME="@default64"></A>
<A NAME="@default65"></A>
<A NAME="@default66"></A>
<A NAME="@default67"></A>
<A NAME="@default68"></A>
<A NAME="@default69"></A>
<A NAME="@default70"></A>
<A NAME="@default71"></A>
<A NAME="@default72"></A>
<A NAME="@default73"></A>
<A NAME="@default74"></A>
<A NAME="@default75"></A>
<A NAME="@default76"></A>
<A NAME="@default77"></A>
<A NAME="@default78"></A>
<A NAME="@default79"></A>
<A NAME="@default80"></A>
<A NAME="@default81"></A>
<A NAME="@default82"></A>
<A NAME="@default83"></A>
<A NAME="@default84"></A>
<A NAME="@default85"></A>
<A NAME="@default86"></A>
<A NAME="@default87"></A>
<A NAME="@default88"></A>
<A NAME="@default89"></A>
<A NAME="@default90"></A>
<A NAME="@default91"></A>
<A NAME="@default92"></A>
<A NAME="@default93"></A>
<A NAME="@default94"></A>
<A NAME="@default95"></A>
<A NAME="@default96"></A>
<A NAME="@default97"></A>
<A NAME="@default98"></A>
<A NAME="@default99"></A>
<A NAME="@default100"></A>
<A NAME="@default101"></A>
<A NAME="@default102"></A>
<A NAME="@default103"></A>
<A NAME="@default104"></A>
<A NAME="@default105"></A>
<A NAME="@default106"></A>
Pour cr&#XE9;er une nouvelle fonction, il faut la d&#XE9;clarer &#XE0; l&#X2019;aide 
d&#X2019;une expression contenant la variable. 
Par exemple l&#X2019;expression <I>x</I><SUP>2</SUP>&#X2212;1 est 
d&#XE9;finie par <CODE>x^2-1</CODE>. Pour la transformer en la fonction <I>f</I> qui
&#XE0; <I>x</I> associe <I>x</I><SUP>2</SUP>&#X2212;1, trois possibilit&#XE9;s existent&#XA0;:
</P><PRE CLASS="verbatim">f(x):= x^2-1
f:=x-&gt;x^2-1
f:=unapply(x^2-1,x)

f(2); 
f(a^2);
</PRE><P><A NAME="@default107"></A>
<A NAME="@default108"></A>
<A NAME="@default109"></A>
<A NAME="@default110"></A>
Si <CODE>f</CODE> est une fonction d&#X2019;une variable et <CODE>E</CODE> est une
expression, <CODE>f(E)</CODE> est une autre expression.
Il est essentiel de ne pas confondre fonction et expression.
Si on d&#XE9;finit : <CODE>E:=x^2-1</CODE>, alors la variable <CODE>E</CODE> 
contient l&#X2019;expression <I>x</I><SUP>2</SUP>&#X2212;1. Pour avoir la valeur de cette
expression en <I>x</I>=2 il faut 
&#XE9;crire <CODE>subst(E,x=2)</CODE> et non <CODE>E(2)</CODE>
car <CODE>E</CODE> n&#X2019;est pas une fonction.
Lorsqu&#X2019;on d&#XE9;finit une fonction,
le membre de droite de l&#X2019;affectation n&#X2019;est pas &#XE9;valu&#XE9;.
Ainsi l&#X2019;&#XE9;criture <CODE>E:=x^2-1; f(x):=E</CODE>
d&#XE9;finit la fonction <I>f</I>: <I>x</I> &#X21A6; <I>E</I> car <CODE>E</CODE> n&#X2019;est pas &#XE9;valu&#XE9;.
Par contre <CODE>E:= x^2-1; f:=unapply(E,x)</CODE> d&#XE9;finit bien la
fonction <I>f</I>: <I>x</I>&#X21A6; <I>x</I><SUP>2</SUP>&#X2212;1 car <CODE>E</CODE> est &#XE9;valu&#XE9;.</P><P><A NAME="@default111"></A>
<A NAME="@default112"></A>
On peut ajouter et multiplier des fonctions,
par exemple <CODE>f:=sin*exp</CODE>. Pour composer des fonctions, on utilise 
l&#X2019;op&#XE9;rateur <CODE>@</CODE> et pour composer plusieurs fois une fonction 
avec elle-m&#XEA;me, on utilise l&#X2019;op&#XE9;rateur <CODE>@@</CODE>.
</P><PRE CLASS="verbatim">f:=x-&gt;x^2-1;
(f@f)(2);
(f@sqrt)(a);
f1:=f@sin
f2:=f@f
f3:=f@@3
f1(a)
f2(a)
f3(a)
</PRE><P>On peut d&#XE9;finir des fonctions de plusieurs variables &#XE0; valeurs dans 
&#X211D; comme :<BR>
<CODE>f(x,y):=x+2*y</CODE><BR>
et des fonctions de plusieurs variables &#XE0; valeurs dans &#X211D;<SUP><I>p</I></SUP>
par exemple :<BR>
<CODE>f(x,y):=(x+2*y,x-y)</CODE> </P><H3 CLASS="subsection"><A NAME="toc10"></A><A NAME="htoc12">2.7</A>&#XA0;&#XA0;Listes, s&#XE9;quences, ensembles</H3><P>
<A NAME="@default113"></A>
<A NAME="@default114"></A>
<A NAME="@default115"></A>
<TT>Xcas</TT> distingue plusieurs sortes de collections d&#X2019;objets, 
s&#XE9;par&#XE9;s par des virgules&#XA0;: 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
les listes (entre crochets)
</LI><LI CLASS="li-itemize">les s&#XE9;quences (entre parenth&#XE8;ses) 
</LI><LI CLASS="li-itemize">les ensembles (entre pourcentage-accolades)
</LI></UL><PRE CLASS="verbatim">liste:=[1,2,4,2]
sequence:=(1,2,4,2)
ensemble:=%{1,2,4,2%}
</PRE><P>Les listes peuvent contenir des listes (c&#X2019;est le cas des matrices), 
alors que les s&#XE9;quences sont plates (un &#XE9;l&#XE9;ment d&#X2019;une s&#XE9;quence
ne peut pas &#XEA;tre une s&#XE9;quence). Dans un ensemble,
l&#X2019;ordre n&#X2019;a pas d&#X2019;importance et chaque objet est unique. 
Il existe une autre structure, appel&#XE9;e table, dont nous
reparlerons plus loin.</P><P>Il suffit de mettre une s&#XE9;quence entre crochets pour en faire une liste
ou entre accolades pr&#XE9;c&#XE9;d&#XE9;es de <CODE>%</CODE> pour en faire un ensemble.
On passe d&#X2019;une liste &#XE0; sa s&#XE9;quence associ&#XE9;e par <CODE>op</CODE>, 
d&#X2019;une s&#XE9;quence &#XE0; sa liste associ&#XE9;e en la mettant entre crochets
ou avec la fonction <CODE>nop</CODE>.
Le nombre d&#X2019;&#XE9;l&#XE9;ments d&#X2019;une liste est donn&#XE9; par <CODE>size</CODE> 
(ou <CODE>nops</CODE>).
<A NAME="@default116"></A>
<A NAME="@default117"></A>
<A NAME="@default118"></A>
<A NAME="@default119"></A>
<A NAME="@default120"></A>
</P><PRE CLASS="verbatim">se:=(1,2,4,2)
li:=[se]
op(li)
nop(se)
nops(se)
%{se%}
size([se])
size(%{se%})
</PRE><P><A NAME="@default121"></A>
<A NAME="@default122"></A>
<A NAME="@default123"></A>
Pour fabriquer une liste ou une s&#XE9;quence, on utilise des commandes
d&#X2019;it&#XE9;ration comme <CODE>$</CODE> ou <CODE>seq</CODE> (qui it&#XE8;rent une
expression) ou <CODE>makelist</CODE> (qui d&#XE9;finit une liste &#XE0; l&#X2019;aide d&#X2019;une 
fonction). 
</P><PRE CLASS="verbatim">1$5
k^2 $ (k=-2..2)
seq(k^2,k=-2..2)
seq(k^2,k,-2..2)
[k^2$(k=-2..2)]
seq(k^2,k,-2,2)
seq(k^2,k,-2,2,2)
makelist(x-&gt;x^2,-2,2)
seq(k^2,k,-2,2,2)
makelist(x-&gt;x^2,-2,2,2)
</PRE><P><A NAME="@default124"></A>
<A NAME="@default125"></A>
<A NAME="@default126"></A>
La s&#XE9;quence vide est not&#XE9;e <CODE>NULL</CODE>, la liste vide
<CODE>[]</CODE>. Pour ajouter un &#XE9;l&#XE9;ment &#XE0; une s&#XE9;quence il suffit
d&#X2019;&#XE9;crire la s&#XE9;quence et l&#X2019;&#XE9;l&#XE9;ment s&#XE9;par&#XE9;s par une virgule. 
<A NAME="@default127"></A>
Pour ajouter un
&#XE9;l&#XE9;ment &#XE0; une liste on utilise <CODE>append</CODE>.
On acc&#XE8;de &#XE0; un &#XE9;l&#XE9;ment d&#X2019;une liste ou d&#X2019;une s&#XE9;quence gr&#XE2;ce 
&#XE0; son indice mis entre 
crochets, le premier &#XE9;l&#XE9;ment &#XE9;tant d&#X2019;indice 0.
</P><PRE CLASS="verbatim">se:=NULL; se:=se,k^2$(k=-2..2); se:=se,1
li:=[1,2]; (li:=append(li,k^2))$(k=-2..2)
li[0],li[1],li[2]
</PRE><P>Les polyn&#XF4;mes sont souvent d&#XE9;finis par une expression, mais
ils peuvent aussi &#XEA;tre repr&#XE9;sent&#XE9;s 
par la liste de leurs coefficients par ordre
de degr&#XE9; d&#XE9;croissant, avec comme d&#XE9;limiteurs <CODE>poly1[</CODE> et <CODE>]</CODE>.
Il existe aussi une repr&#XE9;sentation
pour les polyn&#XF4;mes &#XE0; plusieurs variables. Les fonctions
<CODE>symb2poly</CODE> et <CODE>poly2symb</CODE> permettent
de passer de la repr&#XE9;sentation expression &#XE0; la repr&#XE9;sentation
par liste et inversement, 
le deuxi&#XE8;me argument d&#XE9;termine s&#X2019;il s&#X2019;agit de polyn&#XF4;mes
en une variable (on met le nom de la variable) ou de
polyn&#XF4;mes &#XE0; plusieurs variables (on met la liste des variables).</P><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP COLSPAN=2><B>S&#XE9;quences et listes</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>E$(k=n..m)</CODE></TD><TD ALIGN=left NOWRAP>cr&#XE9;er une s&#XE9;quence</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>seq(E,k=n..m)</CODE></TD><TD ALIGN=left NOWRAP>cr&#XE9;er une s&#XE9;quence</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>[E$(k=n..m)]</CODE></TD><TD ALIGN=left NOWRAP>cr&#XE9;er une liste</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>makelist(f,k,n,m,p)</CODE></TD><TD ALIGN=left NOWRAP>cr&#XE9;er une liste</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>op(li)</CODE></TD><TD ALIGN=left NOWRAP>passer de liste &#XE0; s&#XE9;quence</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>nop(se)</CODE></TD><TD ALIGN=left NOWRAP>passer de s&#XE9;quence &#XE0; liste</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>nops(li)</CODE></TD><TD ALIGN=left NOWRAP>nombre d&#X2019;&#XE9;l&#XE9;ments</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>size(li)</CODE></TD><TD ALIGN=left NOWRAP>nombre d&#X2019;&#XE9;l&#XE9;ments</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>sum</CODE></TD><TD ALIGN=left NOWRAP>somme des &#XE9;l&#XE9;ments</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>product</CODE></TD><TD ALIGN=left NOWRAP>produit des &#XE9;l&#XE9;ments</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>cumSum</CODE></TD><TD ALIGN=left NOWRAP>sommes cumul&#XE9;es des &#XE9;l&#XE9;ments</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>apply(f,li)</CODE></TD><TD ALIGN=left NOWRAP>appliquer une fonction aux &#XE9;l&#XE9;ments d&#X2019;une liste</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>map(li,f)</CODE></TD><TD ALIGN=left NOWRAP>appliquer une fonction aux &#XE9;l&#XE9;ments d&#X2019;une liste</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>map(li,f,matrix)</CODE></TD><TD ALIGN=left NOWRAP>appliquer une fonction aux &#XE9;l&#XE9;ments d&#X2019;une matrice</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>poly2symb</CODE></TD><TD ALIGN=left NOWRAP>polyn&#XF4;me associ&#XE9; &#XE0; une liste</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>symb2poly</CODE></TD><TD ALIGN=left NOWRAP>coefficients d&#X2019;un polyn&#XF4;me</TD></TR>
</TABLE>
</DIV><P>
<A NAME="@default128"></A>
<A NAME="@default129"></A>
<A NAME="@default130"></A>
<A NAME="@default131"></A>
<A NAME="@default132"></A>
<A NAME="@default133"></A>
<A NAME="@default134"></A>
<A NAME="@default135"></A>
<A NAME="@default136"></A>
<A NAME="@default137"></A>
<A NAME="@default138"></A>
<A NAME="@default139"></A>
</P><H3 CLASS="subsection"><A NAME="toc11"></A><A NAME="htoc13">2.8</A>&#XA0;&#XA0;Temps de calcul, place m&#XE9;moire</H3><P>
Le principal probl&#XE8;me du calcul formel est la complexit&#XE9; des 
calculs interm&#XE9;diaires. Elle se traduit &#XE0; la fois par le temps
n&#XE9;cessaire &#XE0; l&#X2019;ex&#XE9;cution des commandes et par la place m&#XE9;moire
requise. Les algorithmes impl&#XE9;ment&#XE9;s dans les fonctions
de <TT>Xcas</TT> sont performants, mais ils ne
<A NAME="@default140"></A>
<A NAME="@default141"></A>
peuvent pas &#XEA;tre optimaux dans tous les cas. La fonction <CODE>time</CODE> 
permet de conna&#XEE;tre le temps d&#X2019;ex&#XE9;cution d&#X2019;une commande (si ce temps
est tr&#XE8;s court, <TT>Xcas</TT> ex&#XE9;cute plusieurs fois la commande pour
afficher un r&#XE9;sultat plus pr&#XE9;cis). La m&#XE9;moire utilis&#XE9;e 
appara&#XEE;t dans les versions Unix dans la ligne d&#X2019;&#XE9;tat
(la barre-bouton). Si le temps d&#X2019;ex&#XE9;cution d&#X2019;une
commande d&#XE9;passe quelques secondes, il est possible que vous ayez
commis une erreur de saisie. N&#X2019;h&#XE9;sitez pas &#XE0; interrompre
l&#X2019;ex&#XE9;cution (bouton rouge <CODE>STOP</CODE> en haut &#XE0; droite, il est
conseill&#XE9; de faire une sauvegarde de votre session auparavant).</P><HR>
<A HREF="tutoriel001.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="tutoriel003.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
