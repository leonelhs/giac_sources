<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="cascmd_fr.css">
<TITLE>Point sur un objet géométrique : element</TITLE>
</HEAD>
<BODY >
<A HREF="cascmd_fr889.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="cascmd_fr891.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H3 CLASS="subsection"><A NAME="htoc1047">10.8.14</A>  Point sur un objet géométrique : <TT>element</TT></H3><P><A NAME="@default1727"></A>
<TT>element</TT> peut avoir différents types d’arguments :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
un intervalle <I>a</I>..<I>b</I> et deux réels la valeur et le pas (par défaut la
valeur vaut (<I>a</I>+<I>b</I>)/2 et le pas (<I>b</I>−<I>a</I>)/100), par exemple, 
<TT>t:=element(0..pi)</TT> ou 
<TT>t:=element(0..pi,pi/2)</TT> ou
<TT>t:=element(0..pi,pi/2,pi/100.0)</TT> 
signifie que <TT>t</TT> peut prendre une valeur quelconque de l’intervalle 
[0;π] et le deuxième argument π/2 donne la valeur qui définit 
<TT>t</TT> : cela a pour effet d’avoir en haut et à droite un curseur noté 
<TT>t</TT> que l’on peut faire bouger à la souris de 0 à π, avec à 
gauche de ce curseur un nombre égal à la valeur de <TT>t</TT> du curseur.
</LI><LI CLASS="li-itemize">un objet géométrique et un réel (par défaut ce réel vaut 
1/2), par exemple, <TT>A:=element(cercle(0,2),1)</TT> signifie que <TT>A</TT> se 
trouve sur le cercle de centre 0 et de rayon 2 et a comme affixe 2*exp(<I>i</I>) 
(car 2*exp(<I>i</I>*<I>t</I>) est l’équation paramétrique du cercle(0,2) et le 
deuxième argument 1 donne la valeur du paramètre <I>t</I> pour définir 
<TT>A</TT>). Par exemple, <TT>A:=element(cercle(0,1))</TT> signifie que <TT>A</TT> se 
trouve sur le cercle de centre 0 et de rayon 1, le point <TT>A</TT> sera tracé
en prenant <I>t</I>=1/2 comme valeur du paramètre de l’équation 
paramétrique de l’objet géométrique (ici <TT>affixe(A)</TT>=
2*exp(<I>i</I>/2)). Lorsque ensuite on déplacera <TT>A</TT> avec la souris, 
<TT>A</TT> se déplacera sur l’objet géométrique.</LI><LI CLASS="li-itemize">un objet géométrique et un nom de variable (par exemple <TT>t</TT>)
défini auparavant par la commande <TT>element</TT> : par exemple 
<TT>t:=element(0..pi)</TT>. Si on tape <TT>A:=element(cercle(0,2),t)</TT>, alors
<I>t</I> est la variable de paramétrage de l’obget géométrique défini par 
le premier argument, c’est à dire que <TT>A</TT> se trouve sur le cercle de 
centre 0 et de rayon 2 et que <TT>A</TT> a comme affixe 2*exp(<I>i</I>*<I>t</I>), car 
2*exp(<I>i</I>*<I>t</I>) est l’équation paramétrique du cercle(0,2). Il est donc 
obligatoire dans ce cas de définir auparavant le deuxième argument (ici 
<TT>t</TT>) comme étant l’élément d’un intervalle.<BR>
On tape par exemple:<BR>
<DIV CLASS="center"><TT>t:=element(0..pi)</TT></DIV>
puis
<DIV CLASS="center"><TT>A:=element(cercle(0,2),t)</TT></DIV>
cela a pour effet d’avoir en haut et à droite un curseur noté <TT>t</TT> que 
l’on peut faire bouger à la souris de 0 à π, avec à gauche de ce 
curseur un nombre égal à la valeur de <TT>t</TT> du curseur. Ce curseur permet
de faire bouger le point <TT>A</TT> sur le demi-cercle supérieur du cercle de 
centre 0 et de rayon 1 (car 0≤ <I>t</I> ≤ π) et cela sans tracer ce 
demi-cercle.
On tape par exemple:<BR>
<DIV CLASS="center"><TT>A:=point(1);B:=point(2+i)</TT></DIV>
<DIV CLASS="center"><TT>t:=element(0..2)</TT></DIV>
puis
<DIV CLASS="center"><TT>M:=element(droite(A,B),t)</TT></DIV>
<TT>M</TT> est un point de la droite <TT>AB</TT> et on a <TT>M=A+t*(B-A)</TT>
c’est à dire <TT>M=(1-t)*A+t*B</TT>
pout parcourir le segment <TT>AB</TT> , il faut mettre <TT>t:=element(0..1)</TT> ou 
encore <TT>M:=element(segment(A,B),t)</TT> qui aura pour effet de laisser <TT>M</TT> 
en <TT>A</TT> si <TT>t&lt;0</TT> et de laisser <TT>M</TT> en <TT>B</TT> si <TT>t&gt;1</TT>.
</LI><LI CLASS="li-itemize">une ligne polygonale <TT>LP</TT> et <TT>[floor(t),frac(t)]</TT> avec <TT>t</TT>
défini auparavant par la commande <TT>element</TT> : par exemple 
<TT>t:=element(0..5)</TT> si <TT>LP</TT> a 5 côtés.<BR>
Les côtés de la ligne polygonale <TT>LP</TT> ont comme numèro : 0,1....<BR>
Si par exemple <TT>LP</TT> a 5 côtés et a pour sommets 
<TT>A(0),...A(4),A(5)=A(0)</TT>,
on tapera :<BR>
<TT>t:=element(0..5)</TT><BR>
<TT>M:=element(LP,[floor(t),frac(t)])</TT><BR>
Ainsi selon les valeurs de <TT>t</TT>, <TT>M</TT> va parcourir les 5 côtés de 
<TT>LP</TT> : <TT>M</TT> sera situé sur le côté de numéro <TT>n=floor(t)</TT>
et on aura <TT>M=frac(t)*A(n)+(1-frac(t))*A(n+1)</TT>.<BR>
Par exemple :
<PRE CLASS="verbatim">A:=point(0);
B:=point(4);
C:=point(4*i);
t:=element(0..3);
T:=triangle(A,B,C);
M:=element(T,[floor(t),frac(t)]);
</PRE></LI></UL><P>
<B>Attention</B>
Si à un point <I>M</I> d’affixe <I>m</I>, défini comme élément d’une courbe <I>C</I>,
on ajoute un complexe <I>a</I>, cela définit un point <I>N</I> de la courbe <I>C</I> qui est
le projeté du point d’affixe <I>m</I>+<I>a</I> sur <I>C</I>.<BR>
Par contre si un point <I>M</I> d’affixe <I>m</I>, défini comme élément d’une 
courbe <I>C</I>, on ajoute un point <I>A</I> d’affixe <I>a</I>, cela définit un point <I>P</I>
d’affixe <I>m</I>+<I>a</I>
Par exemple, étant donné 3 points <I>M</I>,<I>A</I>,<I>B</I>, si on veut définir le point 
<TT>N</TT> vérifiant par exemple : <I>MN</I>=<I>AB</I>, 
on peut taper : <TT>N:=M+(B-A)</TT> à condition que <I>M</I> ne soit pas défini 
comme élément d’une courbe <I>C</I>.
En effet si on a tapé <TT>M:=element(C)</TT> il faut définir <I>N</I> en tapant :
<TT>N:=affixe(M)+B-A</TT> ou <TT>N:=M+B-A</TT> (sans parenthèses) car 
<TT>N:=M+B-A</TT> est interprété en <TT>N:=(M+B)-A</TT> car il n’y a pas de 
règle de priorité entre <TT>+</TT> et <TT>-</TT> alors que<BR>
 <TT>M+(B-A)</TT> renvoie un élément de la courbe <I>C</I> qui est le projeté de
<I>N</I> sur <I>C</I>.<BR>
On a donc, si on tape :<BR>
<TT>A:=point(-2,2);B:=point(1,3);C:=cercle(0,1);</TT><BR>
<TT>M:=element(C);N:=affixe(M)+B-A</TT>;(ou <TT>N:=M+B-A</TT>;) <TT>N</TT> n’est pas sur
la courbe <TT>C</TT><BR>
si on tape :<BR>
<TT>P:=M+(B-A)</TT> (ou P:=projection(C,N);) <TT>P</TT> est sur la courbe <TT>C</TT><BR>

</P><HR>
<A HREF="cascmd_fr889.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="cascmd_fr891.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
