<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="cascmd_fr.css">
<TITLE>La fonction : seq</TITLE>
</HEAD>
<BODY >
<A HREF="cascmd_fr845.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="cascmd_fr847.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H3 CLASS="subsection"><A NAME="htoc992">9.4.22</A>  La fonction : <TT>seq</TT></H3><P><A NAME="@default1543"></A>
Si <TT>seq</TT> a 4 ou 5 arguments : une expression dépendant d’une 
variable, le nom de cette variable, sa valeur de départ, sa valeur 
d’arrivée, et éventuellement le pas(le pas vaut 1 par défaut).<BR>
<TT>seq</TT> est une fonction qui permet
de renvoyer la liste constituée par les différentes valeurs du premier 
argument lorsque le deuxième argument varie selon les valeurs des arguments 
suivants : valeur de départ, valeur d’arrivée, pas.<BR>
 <TT>seq(f(k),k,1,3)=[f(1),f(2),f(3)]</TT><BR>
<TT>seq(f(k),k,1,5,2)=[f(1),f(3),f(5)]</TT><BR>
On tape :
</P><DIV CLASS="center"><TT>seq(x+1,x,1,10,2)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>[2,4,6,8,10]</TT></DIV><P>
Si <TT>seq</TT> a 3 arguments : une expression dépendant d’une variable, le nom 
de cette variable et une liste <TT>L</TT>.<BR>
<TT>seq</TT> est une fonction qui permet de renvoyer la liste constituée par les 
images de <TT>L</TT> par la fonction <TT>unapply(expression,variable)</TT> ce qui est 
équivalent à <TT>map(liste,unapply(expression,variable))</TT>.
On tape :
</P><DIV CLASS="center"><TT>seq(x+1,x,[3,4,7])</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>[4,5,8]</TT></DIV><P><BR>
La fonction <TT>seq</TT> est utile pour tracer une suite de points dans les
écrans de géométrie.<BR>
<B>Exemple</B><BR>
 On veut représenter les 10 premiers termes de la suite :<BR>
<I>u</I><SUB><I>n</I></SUB>=(1+1/<I>n</I>)<SUP><I>n</I></SUP>=<I>f</I>(<I>n</I>) par les points <I>n</I>+<I>i</I>*<I>f</I>(<I>n</I>).<BR>
On ouvre un écran de géomérie et on tape :
</P><DIV CLASS="center"><TT>f(n):=(1+1/n)</TT><CODE><TT>^</TT></CODE><TT>n</TT></DIV><DIV CLASS="center"><TT>seq(point(k+i*f(k)),k,1,10)</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>On voit les points dans cet écran de géométrie</TT></DIV><P>
Si on tape:
</P><DIV CLASS="center"><TT>for (k:=1;k&lt;11;k++) {point(k+i*f(k));}</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>les points sont seulement dans l’écran </TT><TT>DispG</TT><TT> qu’on 
ouvre avec Cfg-&gt;Montrer-&gt;DispG ou avec DispG()</TT></DIV><P>
Mais si on ouvre un écran de géomérie et si on tape:
</P><DIV CLASS="center"><TT>L:=[];for (k:=1;k&lt;11;k++) {L:=append(L,point(k+i*f(k)));}:;L;</TT></DIV><P>
On obtient :
</P><DIV CLASS="center"><TT>On voit les points dans cet écran de géomérie</TT></DIV><P>On peut aussi utiliser la syntaxe comme avec Maple,
<CODE>seq(2^k,k=0..8)</CODE>, en ajoutant éventuellement un pas
<CODE>seq(2^k,k=0..8,1)</CODE></P><HR>
<A HREF="cascmd_fr845.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="cascmd_fr847.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
