<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Algorithmes de calcul formel et numérique
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: /usr/bin/hevea algo -->
<!--HTMLHEAD-->
Retour à la page principale de <A HREF="http://www-fourier.ujf-grenoble.fr/parisse/giac_fr.html">Giac/Xcas</A>.<!--ENDHTML-->
<!--CUT DEF section 1 --><TABLE CLASS="title"><TR><TD><H1 CLASS="titlemain">Algorithmes de calcul formel et numérique</H1><H3 CLASS="titlerest">B. Parisse<BR>
Institut Fourier<BR>
UMR 5582 du CNRS<BR>
Université de Grenoble I</H3></TD></TR>
</TABLE><BLOCKQUOTE CLASS="abstract"><B>Résumé: </B>
Giac/Xcas est un logiciel libre de calcul formel dont
une caractéristique est de nécessiter peu de ressources sans
sacrifier les performances (en particulier sur les calculs polynomiaux).
Ce document décrit une partie des algorithmes de calcul formel et
numérique qui y sont
impleémentés, l’objectif à long terme
est de couvrir l’essentiel des algorithmes implémentés.
Ce n’est pas le manuel d’utilisation de Xcas, ni un manuel de programmation
ou d’exercices illustrés avec Xcas (voir le menu Aide, Manuels :
Référence calcul formel, Programmation, Exercices, Amusements...).
Ce texte regroupe donc des résultats
mathématiques qui ont été ou sont utilisés dans Giac
(ou sont susceptibles de l’être),
ils sont en général accompagnés de preuves 
et souvent d’illustrations avec Xcas.<BR>
Pour plus d’informations sur Giac/Xcas, cf. :<BR>
<CODE>www-fourier.ujf-grenoble.fr/~parisse/giac_fr.html</CODE>
</BLOCKQUOTE><!--TOC section Table des matières-->
<H2 CLASS="section"><!--SEC ANCHOR -->Table des matières</H2><!--SEC END --><UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">1  Index, plan</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc2">2  Calculer sur ordinateur</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc3">2.1  Représentation des entiers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">2.2  Les réels</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc5">2.2.1  Virgule fixe et flottante.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">2.2.2  Les flottants au format <TT>double</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc7">2.2.3  Opérations sur les flottants</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">2.2.4  Erreurs</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc9">2.2.5  Erreur absolue, relative, arrondi propagation des erreurs.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc10">2.3  L’arithmétique d’intervalle.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc11">2.4  Calcul exact et approché, types, évaluation.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc12">2.5  Forme normale et reconnaissance du 0.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc13">2.6  Valeur générique des variables et
hypothèses</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc14">2.7  Structures de données</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc15">2.7.1  Maple, Mathematica, ...</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc16">2.7.2  Giac/xcas</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc17">2.7.3  Calculatrices formelles HP48/49</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc18">2.7.4  Calculatrices formelles TI92/89/Voyage 200</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc19">2.8  Algorithmes et complexité.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc20">2.8.1  Algorithmes modulaires ou p-adiques</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc21">2.8.2  Algorithmes déterministes. Algorithmes probabilistes: Las Vegas
et Monte-Carlo</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc22">2.9  Quelques algorithmes d’arithmétique de base.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc23">2.9.1  Exemple : l’algorithme de Karatsuba</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc24">2.9.2  Bezout sur les entiers et les fractions continues</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc25">2.9.3  La puissance rapide itérative</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc26">2.10  Pour en savoir plus.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc27">2.11  Exercices sur types, calcul exact et approché, 
algorithmes de bases</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc28">3  Le PGCD de polynômes.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc29">3.1  Le sous-résultant.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc30">3.2  Le pgcd en une variable.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc31">3.2.1  Le pgcd heuristique.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc32">3.2.2  Le pgcd modulaire</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc33">3.3  Le pgcd à plusieurs variables.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc34">3.3.1  Le pgcd heuristique.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc35">3.3.2  Le pgcd modulaire multivariables.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc36">3.3.3  EZGCD.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc37">3.4  Quel algorithme choisir?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc38">3.5  Pour en savoir plus.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc39">4  Le résultant</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc40">4.1  Définition</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc41">4.2  Applications</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc42">4.3  Résultant et degrés</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc43">4.4  Lien avec l’algorithme du sous-résultant (calcul de PGCD)</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc44">4.5  Calcul efficace du résultant</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">5  Localisation des racines</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc46">5.1  Majoration</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc47">5.2  Les suites de Sturm.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc48">5.3  Autres algorithmes</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc49">6  Exercices (PGCD, résultant, ...)</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc50">6.1  Instructions</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc51">6.1.1  Entiers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc52">6.1.2  Polynômes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc53">6.1.3  Calculs modulo <I>n</I></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc54">6.2  Exercices PGCD</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc55">6.3  Exercices (résultant)</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc56">6.4  Exercice (Bézout modulaire)</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc57">6.5  Exercice (Géométrie et résultants).</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc58">6.6  Décalage entier entre racines.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc59">6.7  Exemple de correction de géométrie et résultant</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc60">7  Bases de Gröbner.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc61">7.1  Ordre et réduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc62">7.2  Idéaux</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc63">7.3  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc64">7.4  Checking a reconstructed Groebner basis</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc65">7.5  Speeding up by learning from previous primes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc66">7.6  Giac/Xcas implementation and experimentation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc67">7.7  Conclusion</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc68">7.8  Représentation rationnelle univariée 
(rur).</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc69">8  Courbes paramétriques et polaires</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc70">8.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc71">8.2  Représentation graphique</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc72">8.3  Paramétrage</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc73">8.4  Étude analytique d’une courbe en paramétrique</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc74">8.4.1  Branches infinies</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc75">8.4.2  Étude locale</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc76">8.5  Plan d’étude d’une courbe</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc77">8.6  Courbes en polaires</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc78">8.7  Coniques</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc79">8.7.1  Paramétrisation rationnelle</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc80">8.7.2  Ellipse</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc81">8.7.3  Parabole</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc82">8.7.4  Hyperbole</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc83">9  Propriétés métriques des courbes.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc84">9.1  Longueur d’arc</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc85">9.2  Courbure, repère de Frenet, accélération normale et
tangentielle.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc86">10  Représentation des courbes implicites.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc87">11  Formes différentielles et intégrales curvilignes</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc88">11.1  Forme différentielle</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc89">11.2  Intégrale curviligne</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc90">11.3  Forme différentielle exacte</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc91">11.4  Intégrale curviligne et intégrales doubles.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc92">12  Équations et systèmes différentiels.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc93">12.1  Introduction et représentation graphique.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc94">12.2  Existence et unicité</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc95">12.3  Quelques méthodes de résolution explicite.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc96">12.3.1  Équations à variables
séparables</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc97">12.3.2  Équations linéaires</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc98">12.3.3  Équations linéaires à coefficients constants</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc99">12.3.4  Systèmes différentiels linéaires à coefficients
constants d’ordre 1.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc100">12.3.5  Intégrales premières.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc101">12.3.6  Quelques autres méthodes</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc102">12.4  Comportement asymptotique des solutions</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc103">12.4.1  Équations linéaires à coefficients constants 
d’ordre 1 et 2</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc104">12.4.2  Forçage périodique</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc105">12.4.3  Équation autonome sans second membre</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc106">12.4.4  Systèmes linéaires</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc107">12.4.5  Forçage près d’un point d’équilibre de système.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc108">12.5  Résolution numérique</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc109">12.5.1  Méthodes à un pas</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc110">12.5.2  Méthodes de Runge-Kutta (explicites)</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc111">13  Introduction au calcul variationnel</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc112">14  Corps finis.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc113">14.1  Rappels</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc114">14.2  Représentation des corps non premiers.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc115">14.2.1  Cas général.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc116">14.2.2  Corps de petit cardinal, cas de la caractéristique 2</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc117">14.3  Exercices</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc118">14.4  Codes linéaires et polynomiaux.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc119">14.4.1  Le bit de parité.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc120">14.4.2  Codes linéaires</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc121">14.4.3  Codes polynomiaux</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc122">14.4.4  Détection et correction d’erreur</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc123">14.4.5  Distances</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc124">14.4.6  Correction au mot le plus proche</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc125">14.4.7  Codes de Hamming</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc126">14.5  Les codes de Reed-Solomon</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc127">14.5.1  Théorie</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc128">14.5.2  Preuve du calcul de <I>l</I></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc129">14.5.3  Avec Xcas</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc130">15  Factorisation des entiers et primalité.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc131">15.1  Le test de primalité de Pocklington.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc132">15.2  La méthode ρ de Pollard</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc133">15.3  Le crible quadratique</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc134">15.3.1  Recherche de racine carrée modulo p</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc135">16  Factorisation des polynômes.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc136">16.1  Les facteurs multiples</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc137">16.2  Factorisation en une variable</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc138">16.2.1  Factorisation dans ℤ/<I>p</I>ℤ[<I>X</I>]</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc139">16.2.2  Distinct degree factorization</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc140">16.2.3  La méthode de Cantor-Zassenhaus</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc141">16.2.4  La méthode de Berlekamp</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc142">16.2.5  Remontée (Hensel)</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc143">16.2.6  Combinaison de facteurs</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc144">16.3  Factorisation à plusieurs variables</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc145">16.4  Preuve de l’identité de Bézout généralisée</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc146">16.5  Algorithme de Bézout généralisé</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc147">16.6  Factorisation rationnelle et sur une extension</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc148">16.7  Factorisation absolue</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc149">16.8  Compléments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc150">16.9  Exercices (factorisation des polynômes)</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc151">17  Intégration formelle.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc152">17.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc153">17.2  Fonctions élémentaires</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc154">17.2.1  Extensions transcendantes, tour de variables</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc155">17.2.2  Théorème de structure de Risch</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc156">17.2.3  Théorème de Liouville</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc157">17.3  L’algorithme de Risch</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc158">17.3.1  Intégration d’une fraction propre</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc159">17.3.2  Réduction sans facteurs multiples</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc160">17.3.3  La partie logarithmique</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc161">17.3.4  La partie polynomiale (généralisée)</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc162">17.3.5  Extension logarithmique</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc163">17.3.6  Extension exponentielle</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc164">17.4  Quelques références</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc165">18  Intégration numérique</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc166">18.1  Les rectangles et les trapèzes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc167">18.2  Ordre d’une méthode</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc168">18.3  Simpson</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc169">18.4  Newton-Cotes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc170">18.5  En résumé</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc171">18.6  Accélération de Richardson-Romberg</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc172">18.7  Cas des fonctions périodiques.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc173">18.8  Quadratures gaussiennes.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc174">18.9  Méthode adaptative.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc175">18.10  Méthodes probabilistes.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc176">19  Suites récurrentes et applications</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc177">19.1  Calcul de l’expression des suites récurrentes.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc178">19.1.1  Récurrence affine</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc179">19.1.2  Utilisation de la base de Newton si <I>A</I>=<I>I</I><SUB><I>d</I></SUB> et <I>c</I>=1</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc180">19.2  Le point fixe dans ℝ</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc181">19.3  Le point fixe dans ℝ<SUP><I>n</I></SUP></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc182">19.4  La méthode de Newton dans ℝ.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc183">19.5  La méthode de Newton dans ℝ<SUP><I>n</I></SUP>.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc184">19.6  Calcul approché des racines complexes simples</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc185">20  Algèbre linéaire</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc186">20.1  Résolution de systèmes, calcul de déterminant.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc187">20.1.1  La méthode du pivot de Gauß.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc188">20.1.2  Le déterminant.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc189">20.1.3  Systèmes linéaires</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc190">20.1.4  Bézout et les <I>p</I>-adiques.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc191">20.1.5  Base du noyau</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc192">20.2  Algèbre linéaire sur ℤ</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc193">20.2.1  Calcul du déterminant d’une matrice à coefficient entiers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc194">20.2.2  Réduction de Hermite et Smith</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc195">20.2.3  L’algorithme LLL.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc196">20.3  Le pivot de Gauss numérique.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc197">20.3.1  Efficacité de l’algorithme</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc198">20.3.2  Erreurs d’arrondis du pivot de Gauss</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc199">20.4  La méthode de factorisation <I>LU</I></A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc200">20.4.1  Interprétation matricielle du pivot de Gauss</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc201">20.4.2  Factorisation <I>PA</I>=<I>LU</I></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc202">20.4.3  Applications de la décomposition <I>LU</I></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc203">20.5  La factorisation de Cholesky</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc204">20.6  Conditionnement</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc205">20.7  Réduction des endomorphismes</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc206">20.7.1  Le polynôme minimal</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc207">20.7.2  Le polynôme caractéristique</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc208">20.7.3  La méthode de Hessenberg</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc209">20.7.4  La méthode de
Leverrier-Faddeev-Souriau</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc210">20.7.5  Les vecteurs propres simples.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc211">20.7.6  La forme normale de Jordan</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc212">20.7.7  Exemple 1</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc213">20.7.8  Exemple 2</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc214">20.7.9  Le polynôme minimal par Faddeev</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc215">20.7.10  Formes normales rationnelles</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc216">20.7.11  Fonctions analytiques</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc217">20.8  Quelques autres algorithmes utiles</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc218">20.8.1  Complexité asymptotique</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc219">20.9  Quelques méthodes alternatives au pivot</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc220">20.9.1  Factorisation <I>QR</I></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc221">20.9.2  Méthodes itératives de
Jacobi, Gauss-Seidel, relaxation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc222">20.9.3  Méthode itérative du gradient conjugué</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc223">20.10  Réduction approchée des endomorphismes</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc224">20.10.1  Méthode de la puissance</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc225">20.10.2  Itérations inverses</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc226">20.10.3  Elimination des valeurs propres trouvées</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc227">20.10.4  Décomposition de Schur</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc228">20.11  Quelques références</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc229">20.12  Exercices (algèbre linéaire)</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc230">20.12.1  Instructions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc231">20.12.2  Exercices</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc232">21  Approximation polynomiale</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc233">21.1  Polynôme de Lagrange</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc234">21.1.1  Existence et unicité</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc235">21.1.2  Majoration de l’erreur d’interpolation.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc236">21.1.3  Calcul efficace du polynôme de
Lagrange.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc237">21.1.4  Sensibilité aux erreurs sur les données.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc238">21.2  Interpolation aux points de Tchebyshev</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc239">21.3  Interpolation de Hermite</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc240">21.4  Polynômes de Bernstein et courbes de
Bézier</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc241">21.5  Polynômes orthogonaux.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc242">21.6  Les splines</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc243">22  Développement de Taylor, asymptotiques, 
séries entières, fonctions usuelles</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc244">22.1  La fonction exponentielle</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc245">22.2  Séries entières.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc246">22.3  Série alternée</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc247">22.4  La fonction logarithme</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc248">22.5  Approximants de Padé.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc249">22.6  Autres applications</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc250">22.6.1  Exemple : la fonction d’erreur (error fonction, <TT>erf</TT>)</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc251">22.6.2  Recherche de solutions d’équations différentielles</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc252">22.6.3  Exemple : fonctions de Bessel d’ordre entier</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc253">22.7  Développements asymptotiques et séries
divergentes</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc254">23  La transformée de Fourier discrète.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc255">23.1  Définition et propriétés</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc256">23.2  La transformée de Fourier rapide</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc257">23.3  Applications.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc258">24  Le rayonnement solaire.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc259">24.1  L’insolation au cours de l’année.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc260">24.2  Les saisons</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc261">24.3  L’orbite de la Terre.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc262">24.3.1  Calcul en utilisant le vecteur excentricité.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc263">24.3.2  Calcul par l’équation différentielle.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc264">24.3.3  Lois de Képler.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc265">24.4  Quelques propriétés de l’ellipse</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc266">24.5  Influence de l’ellipse sur les saisons</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc267">24.6  L’équation du temps, la durée des
saisons.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc268">24.7  Les variations des paramètres orbitaux</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc269">25  La moyenne arithmético-géométrique.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc270">25.1  Définition et convergence</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc271">25.2  Lien avec les intégrales elliptiques</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc272">25.3  Application : calcul efficace du logarithme.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc273">26  Les générateurs de nombres pseudo-aléatoires.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc274">26.1  Selon la loi uniforme</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc275">26.1.1  Les générateurs congruentiels.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc276">26.1.2  Mersenne twister.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc277">26.2  Selon plusieurs lois classiques</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc278">A  Bonus : le “making of” de Giac/Xcas</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc279">A.1  Comment le projet Giac/Xcas est né.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc280">A.2  L’enfance d’Xcas: 2000-2006</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc281">A.3  La montée en puissance: 2007-2013</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc282">A.4  Le présent et le futur proche</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc283">A.5  Les concurrents open-source.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc284">B  Quelques opinions.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc285">B.1  Languages</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc286">B.2  Le libre, la recherche et l’éducation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc287">B.3  Les maths et les outils de calcul.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc288">B.4  Calculatrices, tablettes ou PC ?</A>
</LI></UL>
</LI></UL><!--TOC section Index, plan-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc1">1</A>  Index, plan</H2><!--SEC END --><P> <A NAME="sec:index"></A>
L’index commence page suivante dans la version PDF.</P><P>Quelques conseils de lecture :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Des aspects calcul numérique sont abordés dans les sections
<A HREF="#sec:calculer">2</A> (représentation des données), 
<A HREF="#sec:intnum">18</A> (intégration numérique),
<A HREF="#sec:rec">19</A> (point fixe, Newton), <A HREF="#sec:linalg">20</A> (Gauss, LU,
conditionnement, Schur...), <A HREF="#sec:interp">21</A> et <A HREF="#sec:series">22</A>
(interpolation, approximation polynomiale),
<A HREF="#sec:dft">23</A> (transformée de Fourier discrète),
</LI><LI CLASS="li-itemize">Des aspects calcul exact sont abordés dans les sections
<A HREF="#sec:calculer">2</A> (représentation des données), 
<A HREF="#sec:pgcd">3</A> (PGCD), <A HREF="#sec:resultant">4</A>
(résultant), <A HREF="#sec:racines">5</A> (racines), <A HREF="#sec:groebner">7</A>
(bases de Gröbner), <A HREF="#sec:gf">14</A> (corps
finis), <A HREF="#sec:ifactor">15</A>
et <A HREF="#sec:factor">16</A> (factorisation des entiers et polynômes),
<A HREF="#sec:intg">17</A> (calcul de primitives), <A HREF="#sec:linalg">20</A> (algèbre
linéaire), <A HREF="#sec:agm">25</A> (moyenne
arithmético-géométrique), 
</LI><LI CLASS="li-itemize">le lecteur physicien trouvera peut-être un intérêt
aux chapitres tirés de mon cours de licence L2 courbes et
équations différentielles pour la physique,
sections <A HREF="#sec:courbes">8</A>,
<A HREF="#sec:courbes_m">9</A>, <A HREF="#sec:implicite">10</A>, <A HREF="#sec:diff">11</A>,
<A HREF="#sec:ode">12</A>, <A HREF="#sec:lagrangien">13</A>, ainsi que le calcul de la
répartition du rayonnement solaire sur Terre <A HREF="#sec:soleil">24</A>
</LI></UL><!--TOC section Index-->
<H2 CLASS="section"><!--SEC ANCHOR -->Index</H2><!--SEC END --><P></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv">
équation caractéristique, <A HREF="#@default135">12.3.3</A>
</LI><LI CLASS="li-indexenv">équation linéaire, <A HREF="#@default133">12.3.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Akritas, <A HREF="#@default61">5.3</A>
</LI><LI CLASS="li-indexenv">accélération normale, <A HREF="#@default95">9.2</A>
</LI><LI CLASS="li-indexenv">accélération tangentielle, <A HREF="#@default94">9.2</A>
</LI><LI CLASS="li-indexenv">action, <A HREF="#@default148">13</A>
</LI><LI CLASS="li-indexenv">affine, récurrence, <A HREF="#@default214">19.1.1</A>
</LI><LI CLASS="li-indexenv">aléatoire, <A HREF="#@default328">26</A>
</LI><LI CLASS="li-indexenv">algébrique, extension, <A HREF="#@default21">2.7.2</A>, <A HREF="#@default76">7.8</A>, <A HREF="#@default187">16.6</A>, <A HREF="#@default190">16.7</A>
</LI><LI CLASS="li-indexenv">arrondi, <A HREF="#@default4">2.2.1</A>
</LI><LI CLASS="li-indexenv">assume, <A HREF="#@default19">2.6</A>
</LI><LI CLASS="li-indexenv">astroïde, <A HREF="#@default102">9.2</A>
</LI><LI CLASS="li-indexenv">asymptote, <A HREF="#@default81">8.4.1</A>
</LI><LI CLASS="li-indexenv">asymptotique, direction, <A HREF="#@default80">8.4.1</A>
</LI><LI CLASS="li-indexenv">atan, <A HREF="#@default296">22.2</A>
</LI><LI CLASS="li-indexenv">autonome, <A HREF="#@default142">12.4.3</A>, <A HREF="#@default144">12.4.4</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Bézier, courbes de, <A HREF="#@default285">21.4</A>
</LI><LI CLASS="li-indexenv">Bézout généralisé, <A HREF="#@default184">16.5</A>
</LI><LI CLASS="li-indexenv">Bézout, identité de, <A HREF="#@default32">2.9</A>
</LI><LI CLASS="li-indexenv">Bézout, théorème, <A HREF="#@default58">4.3</A>
</LI><LI CLASS="li-indexenv">Bareiss, <A HREF="#@default229">20.1.1</A>
</LI><LI CLASS="li-indexenv">BCD, <A HREF="#@default6">2.2.1</A>
</LI><LI CLASS="li-indexenv">Berlekamp, <A HREF="#@default181">16.2.4</A>
</LI><LI CLASS="li-indexenv">Bernstein, polynômes de, <A HREF="#@default284">21.4</A>
</LI><LI CLASS="li-indexenv">Bessel, <A HREF="#@default303">22.6.3</A>
</LI><LI CLASS="li-indexenv">base, <A HREF="#@default1">2.1</A>
</LI><LI CLASS="li-indexenv">base de Gröbner, <A HREF="#@default65">7</A>
</LI><LI CLASS="li-indexenv">birégulier, <A HREF="#@default84">8.4.2</A>
</LI><LI CLASS="li-indexenv">bit, <A HREF="#@default9">2.2.2</A>
</LI><LI CLASS="li-indexenv">branche, infinie, <A HREF="#@default78">8.4.1</A>
</LI><LI CLASS="li-indexenv">branche, parabolique, <A HREF="#@default79">8.4.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Cantor-Zassenhaus, <A HREF="#@default180">16.2.3</A>
</LI><LI CLASS="li-indexenv">Cholesky, <A HREF="#@default246">20.5</A>
</LI><LI CLASS="li-indexenv">caractéristique,
équation, <A HREF="#@default134">12.3.3</A>
</LI><LI CLASS="li-indexenv">caractéristique, polynôme, <A HREF="#@default253">20.7.2</A>
</LI><LI CLASS="li-indexenv">caustique, <A HREF="#@default103">9.2</A>
</LI><LI CLASS="li-indexenv">centrale, force, <A HREF="#@default139">12.3.5</A>
</LI><LI CLASS="li-indexenv">chinois, <A HREF="#@default34">2.9</A>
</LI><LI CLASS="li-indexenv">clothoïde, <A HREF="#@default106">9.2</A>
</LI><LI CLASS="li-indexenv">code correcteur, <A HREF="#@default159">14.4</A>
</LI><LI CLASS="li-indexenv">code linéaire, <A HREF="#@default157">14.4</A>
</LI><LI CLASS="li-indexenv">code polynomial, <A HREF="#@default158">14.4</A>
</LI><LI CLASS="li-indexenv">conditionnement, <A HREF="#@default248">20.6</A>
</LI><LI CLASS="li-indexenv">congruentiel, générateur, <A HREF="#@default330">26.1.1</A>
</LI><LI CLASS="li-indexenv">conique, <A HREF="#@default89">8.7</A>, <A HREF="#@default115">10</A>
</LI><LI CLASS="li-indexenv">constante de Lebesgue, <A HREF="#@default281">21.1.4</A>
</LI><LI CLASS="li-indexenv">contenu, <A HREF="#@default44">3</A>
</LI><LI CLASS="li-indexenv">continue, fraction, <A HREF="#@default39">2.9.2</A>
</LI><LI CLASS="li-indexenv">contractante, <A HREF="#@default218">19.2</A>
</LI><LI CLASS="li-indexenv">convexe, <A HREF="#@default85">8.4.2</A>, <A HREF="#@default221">19.4</A>
</LI><LI CLASS="li-indexenv">corps fini, <A HREF="#@default152">14</A>
</LI><LI CLASS="li-indexenv">correction d’erreur, <A HREF="#@default161">14.4.4</A>
</LI><LI CLASS="li-indexenv">cos, <A HREF="#@default294">22.1</A>
</LI><LI CLASS="li-indexenv">courbe implicite, <A HREF="#@default114">10</A>
</LI><LI CLASS="li-indexenv">courbure, <A HREF="#@default99">9.2</A>
</LI><LI CLASS="li-indexenv">courbure, rayon, <A HREF="#@default96">9.2</A>
</LI><LI CLASS="li-indexenv">crible, <A HREF="#@default167">15</A>
</LI><LI CLASS="li-indexenv">crible quadratique, <A HREF="#@default173">15.3</A>
</LI><LI CLASS="li-indexenv">curviligne, intégrale, <A HREF="#@default120">11.2</A>
</LI><LI CLASS="li-indexenv">cyclique, élément, <A HREF="#@default156">14.2.1</A>
</LI><LI CLASS="li-indexenv">cycloïde, <A HREF="#@default93">9.1</A>, <A HREF="#@default151">13</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">DFT, <A HREF="#@default310">23</A>
</LI><LI CLASS="li-indexenv">Durand-Kerner, Weierstrass, <A HREF="#@default226">19.6</A>
</LI><LI CLASS="li-indexenv">dénormalisé, <A HREF="#@default5">2.2.1</A>
</LI><LI CLASS="li-indexenv">déterminant, <A HREF="#@default230">20.1.2</A>
</LI><LI CLASS="li-indexenv">déterministe, <A HREF="#@default29">2.8.2</A>
</LI><LI CLASS="li-indexenv">développée, <A HREF="#@default100">9.2</A>
</LI><LI CLASS="li-indexenv">développement asymptotique, <A HREF="#@default304">22.7</A>
</LI><LI CLASS="li-indexenv">déterminant, modulaire, <A HREF="#@default231">20.1.2</A>
</LI><LI CLASS="li-indexenv">ddf (distinct
degree factorization), <A HREF="#@default179">16.2.2</A>
</LI><LI CLASS="li-indexenv">différences divisées, <A HREF="#@default279">21.1.3</A>
</LI><LI CLASS="li-indexenv">différentielle, <A HREF="#@default116">11.1</A>
</LI><LI CLASS="li-indexenv">différentielle, forme, <A HREF="#@default118">11.1</A>
</LI><LI CLASS="li-indexenv">discriminant, <A HREF="#@default56">4.1</A>
</LI><LI CLASS="li-indexenv">distance d’un code, <A HREF="#@default164">14.4.5</A>
</LI><LI CLASS="li-indexenv">distance de Hamming, <A HREF="#@default163">14.4.5</A>
</LI><LI CLASS="li-indexenv">divisées, différences, <A HREF="#@default278">21.1.3</A>
</LI><LI CLASS="li-indexenv">diviseur élémentaire, <A HREF="#@default240">20.2.2</A>
</LI><LI CLASS="li-indexenv">division euclidienne, <A HREF="#@default0">2.1</A>
</LI><LI CLASS="li-indexenv">double, <A HREF="#@default8">2.2.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Ei, <A HREF="#@default305">22.7</A>
</LI><LI CLASS="li-indexenv">Euler, constante, <A HREF="#@default307">22.7</A>
</LI><LI CLASS="li-indexenv">Euler, Mac Laurin, <A HREF="#@default207">18.6</A>
</LI><LI CLASS="li-indexenv">Euler, méthode d’, <A HREF="#@default145">12.5.1</A>
</LI><LI CLASS="li-indexenv">Euler, spirale, <A HREF="#@default104">9.2</A>
</LI><LI CLASS="li-indexenv">Euler-Lagrange, <A HREF="#@default149">13</A>
</LI><LI CLASS="li-indexenv">ellipse, <A HREF="#@default91">8.7.2</A>, <A HREF="#@default321">24.4</A>
</LI><LI CLASS="li-indexenv">elliptique, intégrale, <A HREF="#@default325">25.2</A>
</LI><LI CLASS="li-indexenv">enveloppe, <A HREF="#@default101">9.2</A>
</LI><LI CLASS="li-indexenv">erf, <A HREF="#@default301">22.6.1</A>
</LI><LI CLASS="li-indexenv">erreur, <A HREF="#@default12">2.2.4</A>, <A HREF="#@default13">2.2.5</A>, <A HREF="#@default242">20.3.2</A>
</LI><LI CLASS="li-indexenv">erreur absolue, <A HREF="#@default14">2.2.5</A>
</LI><LI CLASS="li-indexenv">erreur relative, <A HREF="#@default15">2.2.5</A>
</LI><LI CLASS="li-indexenv">erreur, fonction, <A HREF="#@default302">22.6.1</A>
</LI><LI CLASS="li-indexenv">evaluation, <A HREF="#@default17">2.4</A>
</LI><LI CLASS="li-indexenv">exacte, forme différentielle, <A HREF="#@default122">11.3</A>
</LI><LI CLASS="li-indexenv">excentricité, <A HREF="#@default319">24.3.1</A>
</LI><LI CLASS="li-indexenv">exp, <A HREF="#@default291">22.1</A>
</LI><LI CLASS="li-indexenv">exponentielle, <A HREF="#@default292">22.1</A>
</LI><LI CLASS="li-indexenv">exponentielle
intégrale, <A HREF="#@default306">22.7</A>
</LI><LI CLASS="li-indexenv">exposant, <A HREF="#@default11">2.2.2</A>
</LI><LI CLASS="li-indexenv">extension
algébrique, <A HREF="#@default189">16.7</A>
</LI><LI CLASS="li-indexenv">extension algébrique, <A HREF="#@default20">2.7.2</A>, <A HREF="#@default75">7.8</A>, <A HREF="#@default186">16.6</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Faddeev, <A HREF="#@default258">20.7.4</A>
</LI><LI CLASS="li-indexenv">FFT, <A HREF="#@default313">23.2</A>
</LI><LI CLASS="li-indexenv">Fourier, transformée
discrète, <A HREF="#@default311">23</A>
</LI><LI CLASS="li-indexenv">Frenet, <A HREF="#@default97">9.2</A>
</LI><LI CLASS="li-indexenv">Fresnel,
spirale, <A HREF="#@default105">9.2</A>
</LI><LI CLASS="li-indexenv">facteurs invariants, <A HREF="#@default239">20.2.2</A>
</LI><LI CLASS="li-indexenv">factorisation, <A HREF="#@default166">15</A>, <A HREF="#@default224">19.6</A>
</LI><LI CLASS="li-indexenv">factorisation absolue, <A HREF="#@default188">16.7</A>
</LI><LI CLASS="li-indexenv">factorisation algébrique, <A HREF="#@default185">16.6</A>
</LI><LI CLASS="li-indexenv">factorisation de Cholesky, <A HREF="#@default247">20.5</A>
</LI><LI CLASS="li-indexenv">factorisation de Schur, <A HREF="#@default271">20.10.4</A>
</LI><LI CLASS="li-indexenv">factorisation LU, <A HREF="#@default245">20.4</A>
</LI><LI CLASS="li-indexenv">fermée, forme différentielle, <A HREF="#@default124">11.3</A>
</LI><LI CLASS="li-indexenv">fixe, point, <A HREF="#@default217">19.2</A>
</LI><LI CLASS="li-indexenv">flottant, <A HREF="#@default7">2.2.2</A>
</LI><LI CLASS="li-indexenv">forçage, <A HREF="#@default141">12.4.2</A>
</LI><LI CLASS="li-indexenv">force centrale, <A HREF="#@default140">12.3.5</A>
</LI><LI CLASS="li-indexenv">forme différentielle, <A HREF="#@default119">11.1</A>
</LI><LI CLASS="li-indexenv">fraction continue, <A HREF="#@default38">2.9.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Gauß, <A HREF="#@default228">20.1.1</A>
</LI><LI CLASS="li-indexenv">Gauss-Seidel, <A HREF="#@default266">20.9.2</A>
</LI><LI CLASS="li-indexenv">GF, <A HREF="#@default153">14</A>
</LI><LI CLASS="li-indexenv">Givens, <A HREF="#@default255">20.7.3</A>
</LI><LI CLASS="li-indexenv">Gröbner, base de, <A HREF="#@default64">7</A>
</LI><LI CLASS="li-indexenv">Green-Riemann, <A HREF="#@default127">11.4</A>
</LI><LI CLASS="li-indexenv">générateur congruentiel, <A HREF="#@default329">26.1.1</A>
</LI><LI CLASS="li-indexenv">gradient, <A HREF="#@default117">11.1</A>
</LI><LI CLASS="li-indexenv">gradient conjugué, <A HREF="#@default267">20.9.3</A>
</LI><LI CLASS="li-indexenv">gravité, centre, <A HREF="#@default129">11.4</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Hörner, <A HREF="#@default42">2.11</A>
</LI><LI CLASS="li-indexenv">Hadamard, borne, <A HREF="#@default233">20.1.2</A>
</LI><LI CLASS="li-indexenv">Hamming, <A HREF="#@default162">14.4.5</A>
</LI><LI CLASS="li-indexenv">Hensel, <A HREF="#@default53">3.3.3</A>, <A HREF="#@default182">16.2.5</A>
</LI><LI CLASS="li-indexenv">Hermite (forme
de), <A HREF="#@default237">20.2.2</A>
</LI><LI CLASS="li-indexenv">Hermite, interpolation de, <A HREF="#@default283">21.3</A>
</LI><LI CLASS="li-indexenv">Hermite, réduction de, <A HREF="#@default194">17.3.1</A>
</LI><LI CLASS="li-indexenv">Hessenberg, <A HREF="#@default254">20.7.3</A>
</LI><LI CLASS="li-indexenv">Householder, <A HREF="#@default256">20.7.3</A>
</LI><LI CLASS="li-indexenv">hamiltonien, <A HREF="#@default150">13</A>
</LI><LI CLASS="li-indexenv">heuristique, PGCD, <A HREF="#@default47">3.2.1</A>, <A HREF="#@default51">3.3.1</A>
</LI><LI CLASS="li-indexenv">hyperbole, <A HREF="#@default90">8.7.1</A>
</LI><LI CLASS="li-indexenv">hypothèse, <A HREF="#@default18">2.6</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">idéal, <A HREF="#@default70">7.2</A>
</LI><LI CLASS="li-indexenv">implicite,
courbe, <A HREF="#@default113">10</A>
</LI><LI CLASS="li-indexenv">inertie, moment, <A HREF="#@default128">11.4</A>
</LI><LI CLASS="li-indexenv">inflexion, <A HREF="#@default86">8.4.2</A>
</LI><LI CLASS="li-indexenv">insolation, <A HREF="#@default316">24.1</A>
</LI><LI CLASS="li-indexenv">intégrale curviligne, <A HREF="#@default121">11.2</A>
</LI><LI CLASS="li-indexenv">intégrale première, <A HREF="#@default138">12.3.5</A>
</LI><LI CLASS="li-indexenv">intégration, <A HREF="#@default192">17</A>
</LI><LI CLASS="li-indexenv">integration, <A HREF="#@default196">18</A>
</LI></UL></TD><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv">interpolation, <A HREF="#@default274">21.1</A>, <A HREF="#@default276">21.1.1</A>
</LI><LI CLASS="li-indexenv">intersection de
courbes, <A HREF="#@default57">4.3</A>
</LI><LI CLASS="li-indexenv">intervalle, arithmétique, <A HREF="#@default16">2.3</A>
</LI><LI CLASS="li-indexenv">irréductible, <A HREF="#@default155">14.2.1</A>
</LI><LI CLASS="li-indexenv">isolation de racines, <A HREF="#@default63">5.3</A>
</LI><LI CLASS="li-indexenv">itérations inverses, <A HREF="#@default269">20.10.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Jacobi, <A HREF="#@default265">20.9.2</A>
</LI><LI CLASS="li-indexenv">Jordan, <A HREF="#@default260">20.7.6</A>
</LI><LI CLASS="li-indexenv">Jordan rationnel, <A HREF="#@default261">20.7.10</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Képler, <A HREF="#@default320">24.3.3</A>
</LI><LI CLASS="li-indexenv">Karatsuba, <A HREF="#@default37">2.9.1</A>
</LI><LI CLASS="li-indexenv">knapsack, <A HREF="#@default183">16.2.6</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Lagrange, <A HREF="#@default273">21.1</A>
</LI><LI CLASS="li-indexenv">Landau, <A HREF="#@default49">3.2.2</A>
</LI><LI CLASS="li-indexenv">Laplace
(déterminant), <A HREF="#@default234">20.1.2</A>
</LI><LI CLASS="li-indexenv">Las Vegas, <A HREF="#@default27">2.8.2</A>
</LI><LI CLASS="li-indexenv">Lebesgue, constante
de, <A HREF="#@default280">21.1.4</A>
</LI><LI CLASS="li-indexenv">Legendre, <A HREF="#@default210">18.8</A>
</LI><LI CLASS="li-indexenv">Leverrier, <A HREF="#@default257">20.7.4</A>
</LI><LI CLASS="li-indexenv">Liouville, <A HREF="#@default193">17.2.3</A>
</LI><LI CLASS="li-indexenv">LLL, <A HREF="#@default241">20.2.3</A>
</LI><LI CLASS="li-indexenv">LU, <A HREF="#@default244">20.4</A>
</LI><LI CLASS="li-indexenv">lagrange, <A HREF="#@default275">21.1.1</A>, <A HREF="#@default277">21.1.2</A>
</LI><LI CLASS="li-indexenv">lagrangien, <A HREF="#@default147">13</A>
</LI><LI CLASS="li-indexenv">lexicographique, <A HREF="#@default68">7.1</A>
</LI><LI CLASS="li-indexenv">linéaire,
équation, <A HREF="#@default132">12.3.2</A>
</LI><LI CLASS="li-indexenv">linéaire, récurrence, <A HREF="#@default215">19.1.1</A>
</LI><LI CLASS="li-indexenv">linéaire, système différentiel, <A HREF="#@default136">12.3.4</A>, <A HREF="#@default143">12.4.4</A>
</LI><LI CLASS="li-indexenv">ln, <A HREF="#@default298">22.4</A>
</LI><LI CLASS="li-indexenv">logarithme, <A HREF="#@default299">22.4</A>, <A HREF="#@default326">25.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Mac Laurin, Euler, <A HREF="#@default208">18.6</A>
</LI><LI CLASS="li-indexenv">Mignotte, <A HREF="#@default50">3.2.2</A>
</LI><LI CLASS="li-indexenv">Miller, <A HREF="#@default35">2.9</A>, <A HREF="#@default168">15</A>
</LI><LI CLASS="li-indexenv">Monte-Carlo, <A HREF="#@default28">2.8.2</A>, <A HREF="#@default211">18.10</A>
</LI><LI CLASS="li-indexenv">mantisse, <A HREF="#@default2">2.2.1</A>, <A HREF="#@default10">2.2.2</A>
</LI><LI CLASS="li-indexenv">minimal, polynôme, <A HREF="#@default252">20.7.1</A>
</LI><LI CLASS="li-indexenv">modulaire symétrique, <A HREF="#@default26">2.8.1</A>
</LI><LI CLASS="li-indexenv">modulaire, déterminant, <A HREF="#@default232">20.1.2</A>
</LI><LI CLASS="li-indexenv">modulaire, méthode, <A HREF="#@default22">2.8.1</A>
</LI><LI CLASS="li-indexenv">modulaire, PGCD, <A HREF="#@default48">3.2.2</A>, <A HREF="#@default52">3.3.2</A>
</LI><LI CLASS="li-indexenv">moyenne arithmético-géométrique, <A HREF="#@default324">25</A>
</LI><LI CLASS="li-indexenv">multiplicité, <A HREF="#@default177">16.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Newton, <A HREF="#@default220">19.4</A>, <A HREF="#@default222">19.4</A>, <A HREF="#@default223">19.5</A>
</LI><LI CLASS="li-indexenv">Newton, base de, <A HREF="#@default216">19.1.2</A>
</LI><LI CLASS="li-indexenv">Newton, méthode de, <A HREF="#@default25">2.8.1</A>
</LI><LI CLASS="li-indexenv">Newton-Cotes, <A HREF="#@default204">18.4</A>
</LI><LI CLASS="li-indexenv">nombre de condition, <A HREF="#@default249">20.6</A>
</LI><LI CLASS="li-indexenv">normale, loi, <A HREF="#@default331">26.2</A>
</LI><LI CLASS="li-indexenv">normalisé, <A HREF="#@default3">2.2.1</A>
</LI><LI CLASS="li-indexenv">noyau, <A HREF="#@default236">20.1.5</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">orbite de la Terre, <A HREF="#@default318">24.3</A>
</LI><LI CLASS="li-indexenv">ordre, <A HREF="#@default201">18.2</A>
</LI><LI CLASS="li-indexenv">ordre de monômes, <A HREF="#@default66">7.1</A>
</LI><LI CLASS="li-indexenv">orthogonaux, polynômes, <A HREF="#@default286">21.5</A>
</LI><LI CLASS="li-indexenv">osculateur, cercle, <A HREF="#@default98">9.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Péano, noyau de, <A HREF="#@default202">18.2</A>
</LI><LI CLASS="li-indexenv">Padé, <A HREF="#@default300">22.5</A>
</LI><LI CLASS="li-indexenv">PGCD (polynômes), <A HREF="#@default43">3</A>
</LI><LI CLASS="li-indexenv">Pocklington, <A HREF="#@default170">15.1</A>
</LI><LI CLASS="li-indexenv">Pollard, <A HREF="#@default172">15.2</A>
</LI><LI CLASS="li-indexenv">p-adique (système linéaire), <A HREF="#@default235">20.1.3</A>
</LI><LI CLASS="li-indexenv">p-adique, méthode, <A HREF="#@default23">2.8.1</A>
</LI><LI CLASS="li-indexenv">parabole, <A HREF="#@default92">8.7.3</A>
</LI><LI CLASS="li-indexenv">paramétrique, courbe, <A HREF="#@default77">8.4</A>
</LI><LI CLASS="li-indexenv">parité (bit de), <A HREF="#@default160">14.4.1</A>
</LI><LI CLASS="li-indexenv">pi,
calcul de, <A HREF="#@default327">25.3</A>
</LI><LI CLASS="li-indexenv">pivot, <A HREF="#@default227">20.1.1</A>
</LI><LI CLASS="li-indexenv">pivot partiel, <A HREF="#@default243">20.3.2</A>
</LI><LI CLASS="li-indexenv">point
régulier, <A HREF="#@default107">10</A>
</LI><LI CLASS="li-indexenv">point fixe, <A HREF="#@default219">19.2</A>
</LI><LI CLASS="li-indexenv">point milieu, <A HREF="#@default200">18.1</A>
</LI><LI CLASS="li-indexenv">point singulier, <A HREF="#@default109">10</A>
</LI><LI CLASS="li-indexenv">point singulier ordinaire, <A HREF="#@default112">10</A>
</LI><LI CLASS="li-indexenv">point singulier régulier, <A HREF="#@default111">10</A>
</LI><LI CLASS="li-indexenv">polaire, courbe, <A HREF="#@default88">8.6</A>
</LI><LI CLASS="li-indexenv">polynômes orthogonaux, <A HREF="#@default287">21.5</A>
</LI><LI CLASS="li-indexenv">potentiel, <A HREF="#@default123">11.3</A>, <A HREF="#@default125">11.3</A>
</LI><LI CLASS="li-indexenv">première,
intégrale, <A HREF="#@default137">12.3.5</A>
</LI><LI CLASS="li-indexenv">primalité, <A HREF="#@default171">15.1</A>
</LI><LI CLASS="li-indexenv">primitif, <A HREF="#@default154">14.2.1</A>
</LI><LI CLASS="li-indexenv">primitive, partie, <A HREF="#@default45">3</A>
</LI><LI CLASS="li-indexenv">probabiliste, <A HREF="#@default30">2.8.2</A>
</LI><LI CLASS="li-indexenv">pseudo-division, <A HREF="#@default31">2.9</A>
</LI><LI CLASS="li-indexenv">puissance, <A HREF="#@default268">20.10.1</A>
</LI><LI CLASS="li-indexenv">puissance
rapide, <A HREF="#@default40">2.9.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">QR, <A HREF="#@default264">20.9.1</A>, <A HREF="#@default272">20.10.4</A>
</LI><LI CLASS="li-indexenv">quadratique, crible, <A HREF="#@default174">15.3</A>
</LI><LI CLASS="li-indexenv">quadrature, <A HREF="#@default197">18</A>
</LI><LI CLASS="li-indexenv">quadratures gaussiennes, <A HREF="#@default209">18.8</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Rabin, <A HREF="#@default36">2.9</A>, <A HREF="#@default169">15</A>
</LI><LI CLASS="li-indexenv">Reed-Solomon (codes), <A HREF="#@default165">14.5</A>
</LI><LI CLASS="li-indexenv">Richardson-Romberg, <A HREF="#@default206">18.6</A>
</LI><LI CLASS="li-indexenv">Risch, <A HREF="#@default191">17</A>
</LI><LI CLASS="li-indexenv">Romberg, <A HREF="#@default205">18.6</A>
</LI><LI CLASS="li-indexenv">Rothstein, <A HREF="#@default195">17.3.6</A>
</LI><LI CLASS="li-indexenv">Runge-Kutta, <A HREF="#@default146">12.5.2</A>
</LI><LI CLASS="li-indexenv">récurrence, <A HREF="#@default212">19</A>
</LI><LI CLASS="li-indexenv">régulier, point, <A HREF="#@default82">8.4.2</A>, <A HREF="#@default108">10</A>
</LI><LI CLASS="li-indexenv">réduction, <A HREF="#@default67">7.1</A>
</LI><LI CLASS="li-indexenv">racine, <A HREF="#@default225">19.6</A>
</LI><LI CLASS="li-indexenv">racine carrée modulaire, <A HREF="#@default175">15.3.1</A>
</LI><LI CLASS="li-indexenv">racine rationnelle, <A HREF="#@default24">2.8.1</A>
</LI><LI CLASS="li-indexenv">rapide, puissance, <A HREF="#@default41">2.9.3</A>
</LI><LI CLASS="li-indexenv">rapide, transformée de
Fourier, <A HREF="#@default315">23.2</A>
</LI><LI CLASS="li-indexenv">rationnelle, représentation
univariée, <A HREF="#@default73">7.8</A>
</LI><LI CLASS="li-indexenv">rebroussement, <A HREF="#@default87">8.4.2</A>
</LI><LI CLASS="li-indexenv">rectangle, <A HREF="#@default198">18.1</A>
</LI><LI CLASS="li-indexenv">représentation rationnelle univariée, <A HREF="#@default74">7.8</A>
</LI><LI CLASS="li-indexenv">restes chinois, <A HREF="#@default33">2.9</A>
</LI><LI CLASS="li-indexenv">resultant, <A HREF="#@default54">4</A>
</LI><LI CLASS="li-indexenv">revlex, <A HREF="#@default69">7.1</A>
</LI><LI CLASS="li-indexenv">rur, <A HREF="#@default72">7.8</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Schur (factorisation), <A HREF="#@default270">20.10.4</A>
</LI><LI CLASS="li-indexenv">Si, <A HREF="#@default308">22.7</A>
</LI><LI CLASS="li-indexenv">Simpson, <A HREF="#@default203">18.3</A>
</LI><LI CLASS="li-indexenv">Smith (forme de), <A HREF="#@default238">20.2.2</A>
</LI><LI CLASS="li-indexenv">Souriau, <A HREF="#@default259">20.7.4</A>
</LI><LI CLASS="li-indexenv">Stokes, <A HREF="#@default126">11.4</A>
</LI><LI CLASS="li-indexenv">Strassen, <A HREF="#@default262">20.8.1</A>
</LI><LI CLASS="li-indexenv">Strzebonski, <A HREF="#@default62">5.3</A>
</LI><LI CLASS="li-indexenv">Sturm, suites de, <A HREF="#@default59">5.2</A>
</LI><LI CLASS="li-indexenv">Sylvester, <A HREF="#@default55">4.1</A>
</LI><LI CLASS="li-indexenv">s-polynôme, <A HREF="#@default71">7.2</A>
</LI><LI CLASS="li-indexenv">séparables, variables, <A HREF="#@default130">12.3.1</A>
</LI><LI CLASS="li-indexenv">série altèrnée, <A HREF="#@default297">22.3</A>
</LI><LI CLASS="li-indexenv">série entière, <A HREF="#@default295">22.2</A>
</LI><LI CLASS="li-indexenv">saisons, <A HREF="#@default317">24.2</A>
</LI><LI CLASS="li-indexenv">saisons, durée, <A HREF="#@default323">24.6</A>
</LI><LI CLASS="li-indexenv">sin, <A HREF="#@default293">22.1</A>
</LI><LI CLASS="li-indexenv">singulière, valeur, <A HREF="#@default250">20.6</A>
</LI><LI CLASS="li-indexenv">singulier, point, <A HREF="#@default83">8.4.2</A>, <A HREF="#@default110">10</A>
</LI><LI CLASS="li-indexenv">sinus intégral, <A HREF="#@default309">22.7</A>
</LI><LI CLASS="li-indexenv">sous-résultant, <A HREF="#@default46">3.1</A>
</LI><LI CLASS="li-indexenv">splines, <A HREF="#@default288">21.6</A>
</LI><LI CLASS="li-indexenv">squarefree, <A HREF="#@default178">16.1</A>
</LI><LI CLASS="li-indexenv">suite, <A HREF="#@default213">19</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Taylor, <A HREF="#@default290">22</A>
</LI><LI CLASS="li-indexenv">Taylor, développement, <A HREF="#@default289">22</A>
</LI><LI CLASS="li-indexenv">Tchebyshev, <A HREF="#@default282">21.2</A>
</LI><LI CLASS="li-indexenv">temps, équation du, <A HREF="#@default322">24.6</A>
</LI><LI CLASS="li-indexenv">transformée de Fourier discrète, <A HREF="#@default312">23</A>
</LI><LI CLASS="li-indexenv">transformée de Fourier rapide, <A HREF="#@default314">23.2</A>
</LI><LI CLASS="li-indexenv">trapèze, <A HREF="#@default199">18.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Vincent, <A HREF="#@default60">5.3</A>
</LI><LI CLASS="li-indexenv">valeur singulière, <A HREF="#@default251">20.6</A>
</LI><LI CLASS="li-indexenv">variables séparables, <A HREF="#@default131">12.3.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Winograd, <A HREF="#@default263">20.8.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Yun, <A HREF="#@default176">16.1</A>
</LI></UL></TD></TR>
</TABLE><!--TOC section Calculer sur ordinateur-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">2</A>  Calculer sur ordinateur</H2><!--SEC END --><P> <A NAME="sec:calculer"></A></P><!--TOC subsection Représentation des entiers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc3">2.1</A>  Représentation des entiers</H3><!--SEC END --><DIV CLASS="theorem"><B>Proposition 1</B>  <EM>
</EM><EM><B>Division euclidienne de deux entiers :</B></EM><EM> si </EM><EM><I>a</I></EM><EM> et </EM><EM><I>b</I></EM><EM> sont
deux entiers, </EM><EM><I>a</I> ≥ 0, <I>b</I>&gt;0</EM><EM>, il existe un unique couple </EM><EM>(<I>q</I>,<I>r</I>)</EM><EM> tel que
</EM><A NAME="@default0"></A><EM>
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><I>a</I> = <I>bq</I> +<I>r</I> ,    <I>r</I> ∈ [0, <I>b</I>[ </EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>
Preuve : On prend pour <I>q</I> le plus grand entier tel que <I>a</I>−<I>bq</I> ≥ 0.</P><P>La division euclidienne permet d’écrire un nombre entier, en utilisant
une base <I>b</I> et des caractères pour représenter les entiers
entre 0 et <I>b</I>−1. Nous écrivons les nombres entiers en <B>base</B> <I>b</I>=10<A NAME="@default1"></A>
avec comme caractères les chiffres de 0 à 9.
Les ordinateurs utilisent des circuits binaires pour stocker
les informations, il est donc naturel d’y travailler en base 2 
en utilisant comme caractères 0 et 1 ou en base 16 en utilisant
comme caractères les chiffres de 0 à 9 et les lettres de A à F.
En général, pour trouver l’écriture d’un nombre en base <I>b</I> (par
exemple <I>b</I>=2), 
on effectue des divisions euclidienne successives par <I>b</I> du nombre puis
de ses quotients successifs jusqu’à ce que le quotient soit 0 et on
accolle les restes obtenus (premier reste à droite, dernier
reste à gauche).
Inversement, pour retrouver un entier <I>d</I> à partir
de son écriture <I>d</I><SUB><I>n</I></SUB>...<I>d</I><SUB>0</SUB>, on traduit les divisions euclidiennes 
successives en 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>d</I></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>( ... ((<I>d</I><SUB><I>n</I></SUB> <I>b</I> +<I>d</I><SUB><I>n</I>−1</SUB>)<I>b</I> + <I>d</I><SUB><I>n</I>−2</SUB>)...+<I>d</I><SUB>1</SUB>)<I>b</I>+<I>d</I><SUB>0</SUB></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>d</I><SUB><I>n</I></SUB> <I>b</I><SUP><I>n</I></SUP> + <I>d</I><SUB><I>n</I>−1</SUB> <I>b</I><SUP><I>n</I>−1</SUP> + ... + <I>d</I><SUB>0</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Par exemple, vingt-cinq s’écrit en base 16 <CODE>0x19</CODE> car 25 divisé
par 16 donne quotient 1, reste 9.
En base 2, on trouverait <CODE>0b11001</CODE> car 25=2<SUP>4</SUP>+2<SUP>3</SUP>+1.
On peut effectuer les opérations arithmétiques de base 
(+,-,*, division) directement en base 2 (ou 16). Par exemple
la table de l’addition est 0+0=0, 0+1=1+0=1 et 1+1=0 je retiens 1,
donc :
</P><PRE CLASS="verbatim">  01001111
+ 01101011
----------
  10111010
</PRE><P><B>Exercice </B>: 
comment passe-t-on simplement de la représentation d’un nombre en
base 2 à un nombre en base 16 et réciproquement ?</P><P>Les microprocesseurs peuvent effectuer directement
les opérations arithmétiques de base sur les entiers “machine”
(déclinés en plusieurs variantes selon la taille et la
possibilité d’avoir un signe). Noter que la division de deux
entiers <I>a</I> et <I>b</I> n’a pas la même signification que la division de deux
réels, comme elle ne tomberait pas forcément juste, 
on calcule le quotient et le reste de la division euclidienne. </P><P>Ces entiers machines permettent
de représenter de manière exacte des petits entiers relatifs 
par exemple un entier machine signé sur 4 octets est
compris entre [−2<SUP>31</SUP>,2<SUP>31</SUP>−1]. </P><P>Ces entiers machines permettent de faire très rapidement
du calcul exact sur les
entiers, mais à condition qu’il n’y ait pas de dépassement
de capacité, par exemple pour des entiers 32 bits, 2<SUP>30</SUP>+2<SUP>30</SUP>+2<SUP>30</SUP>+2<SUP>30</SUP>
renverra 0. Ils sont utilisables avec tous les langages de
programmation traditionnels.</P><P>Les logiciels de calcul formel et certains logiciels
de programmation permettent de travailler avec
des entiers de taille beaucoup plus grande, ainsi qu’avec des
rationnels, permettant de faire du calcul exact, mais on paie
cette exactitude par un temps de calcul plus long, de plus
pas mal de méthodes numériques ne gagnent rien à
faire des calculs intermédiaires exacts. Néanmoins, l’utilisation
d’un logiciel de calcul formel permettra dans certains cas d’illustrer
certains phénomènes dus au calcul approché.</P><!--TOC subsection Les réels-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc4">2.2</A>  Les réels</H3><!--SEC END --><P>
On se ramène d’abord au cas des réels positifs, en machine
on garde traditionnellement un bit pour stocker le signe du réel
à représenter.</P><!--TOC subsubsection Virgule fixe et flottante.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc5">2.2.1</A>  Virgule fixe et flottante.</H4><!--SEC END --><P>
La première idée qui vient naturellement serait d’utiliser
un entier et de déplacer la virgule
d’un nombre fixe de position, ce qui revient à mulitplier
par une puissance (négative) de la base. Par exemple en base 10 avec un
décalage de 4, <CODE>1234.5678</CODE>
serait représenté par <CODE>12345678</CODE> et <CODE>1.2345678</CODE> par
<CODE>12345</CODE> (on passe de l’entier au réel par multiplication
par 10<SUP>−4</SUP>. L’inconvénient d’une telle représentation est
qu’on ne peut pas représenter des réels grands ou petits,
comme par exemple le nombre d’Avogadro, la constante de Planck, etc.</P><P>D’où l’idée de ne pas fixer la position de la virgule, on parle
alors de représentation à virgule flottante ou de nombre flottant : on
représente un nombre par deux entier, l’un appelé <B>mantisse</B><A NAME="@default2"></A>
reprend les chiffres significatifs du réel sans virgule, l’autre
l’exposant, donne la position de la virgule. Attention, le séparateur
est un point et non une virgule dans la grande
majorité des logiciels scientifiques.
On sépare
traditionnellement la mantisse de l’exposant par la lettre <CODE>e</CODE>.
Par exemple <CODE>1234.5678</CODE> peut être représenté 
par <CODE>12345678e-8</CODE> (mantisse <CODE>12345678</CODE>, exposant -8)
mais aussi par <CODE>1234567800e-10</CODE>.</P><P>Naturellement, sur un ordinateur, il y a des limites pour les entiers 
représentant la mantisse <I>m</I> et l’exposant <I>e</I>. 
Si on écrit les nombres en base
<I>b</I>, la mantisse <I>m</I> s’écrira avec un nombre <I>n</I> fixé de chiffres (ou
de bits en base 2), donc <I>m</I> ∈ [0,<I>b</I><SUP><I>n</I></SUP>[. Soit un réel <I>x</I> représenté
par
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>=<I>mb</I><SUP><I>e</I></SUP>,    <I>m</I> ∈ [0,<I>b</I><SUP><I>n</I></SUP>[ </TD></TR>
</TABLE><P>
Si <I>m</I>∈ [0,<I>b</I><SUP><I>n</I>−1</SUP>[, alors on peut aussi écrire <I>x</I>=<I>m</I>′ <I>b</I><SUP><I>e</I>−1</SUP> avec
<I>m</I>′=<I>mb</I> ∈ [0,<I>b</I><SUP><I>n</I></SUP>[, quelle écriture faut-il choisir?
Intuitivement, on sent qu’il vaut mieux prendre <I>m</I>′ le plus grand
possible, car cela augmente le nombre de chiffres significatifs (alors
que des 0 au début de <I>m</I> ne sont pas significatifs).
Ceci est confirmé par le calcul de l’erreur d’arrondi pour
représenter un réel. En effet, si <I>x</I> est un réel non nul, il ne
s’écrit pas forcément sous la forme <I>mb</I><SUP><I>e</I></SUP>, on doit l’arrondir,
par exemple au plus proche réel de la forme <I>mb</I><SUP><I>e</I></SUP>. La distance
de <I>x</I> à ce réel est inférieure ou égale à la moitié
de la distance entre deux flottants consécutifs, 
<I>mb</I><SUP><I>e</I></SUP> et (<I>m</I>+1)<I>b</I><SUP><I>e</I></SUP>, donc l’erreur d’arrondi
est inférieure ou égale à <I>b</I><SUP><I>e</I></SUP>/2. Si on divise par <I>x</I> ≥ <I>mb</I><SUP><I>e</I></SUP>,
on obtient une erreur relative d’arrondi majorée par 1/(2<I>m</I>).
On a donc intérêt à prendre <I>m</I> le plus grand possible pour
minimiser cette erreur. Quitte à mulitplier par <I>b</I>, on peut
toujours se ramener (sauf exceptions, cf. ci-dessous), 
à <I>m</I> ∈ [<I>b</I><SUP><I>n</I>−1</SUP>,<I>b</I><SUP><I>n</I></SUP>[, on a alors
une erreur d’arrondi relative majorée par
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>b</I><SUP><I>n</I>−1</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>On appelle <B>flottant normalisé</B><A NAME="@default3"></A> un flottant tel que <I>m</I> ∈
[<I>b</I><SUP><I>n</I>−1</SUP>,<I>b</I><SUP><I>n</I></SUP>[. Pour écrire un réel sous forme de flottant
normalisé, on écrit le réel en base <I>b</I>, et on déplace
la virgule pour avoir exactement <I>n</I> chiffres non nuls avant la
virgule et on arrondit (par exemple au plus proche). 
L’exposant est égal au décalage effectué.
Notez qu’en base 2, un flottant normalisé commence forcément
par 1, ce qui permet d’économiser un bit dans le stockage.</P><P>Ainsi, l’erreur d’<B>arrondi</B><A NAME="@default4"></A> commise lorsqu’on
représente un réel (connu exactement) par un double normalisé 
est une erreur relative inférieure à
de 2<SUP>−53</SUP> (<I>b</I>=2 et <I>n</I>=52+1 pour les doubles).</P><P>Exemples : 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
en base 10 avec <I>n</I>=6, pour représenter
π=3,14159265..., on doit décaler la virgule de 5 positions,
on obtient <CODE>314159.265...</CODE> on arrondit à 314159 donc
on obtient <CODE>314159e-5</CODE>.
</LI><LI CLASS="li-itemize">en base 2 avec <I>n</I>=10, pour représenter trois cinquièmes (3/5
en base 10, noté 11/101 en base 2), 
on pose la division en base 2 de <CODE>11</CODE> par 
<CODE>101</CODE>, ce qui donne
<PRE CLASS="verbatim"> 11        | 101
 110       ---------
-101       | 0.1001
----       |
  010      |
   100     |
   1000    |
  - 101    |
  -----    |
    011    |
</PRE>on retrouve le nombre de départ donc le développement est
périodique et vaut <CODE>0.1001 1001 1001 ...</CODE>.
On décale le point de 10 positions, on arrondit,
donc trois cinquièmes est
représenté par la mantisse <CODE>1001100110</CODE> et l’exposant
<CODE>-10</CODE>. On observe aussi sur cet exemple que 3/5 dont l’écriture
en base 10 <CODE>0.6</CODE> est exacte, n’a pas d’écriture exacte en base
2 (de même que 1/3 n’a pas d’écriture exacte en base 10).
</LI></UL><P>Il existe une exception à la possibilité de normaliser les flottants,
lorsqu’on atteint la limite inférieure de l’exposant <I>e</I>. 
Soit en effet <I>e</I><SUB><I>m</I></SUB> le plus petit exposant des flottants normalisés
et considérons les flottants <I>x</I>=<I>b</I><SUP><I>e</I><SUB><I>m</I></SUB></SUP>(1+1/<I>b</I>) et <I>y</I>=<I>b</I><SUP><I>e</I><SUB><I>m</I></SUB></SUP>. Ces
flottants sont distincts, 
mais leur différence n’est plus représentable par un flottant normalisé.
Comme on ne souhaite pas représenter <I>x</I>−<I>y</I> par 0, 
(puisque le test <I>x</I>==<I>y</I> renvoie faux), on introduit les flottants 
<B>dénormalisés</B> <A NAME="@default5"></A>, il s’agit de
flottants dont l’exposant est l’exposant minimal représentable sur
machine et dont la mantisse appartient à [0,<I>b</I><SUP><I>n</I>−1</SUP>[. Par exemple
0 est représenté par un flottant dénormalisé de mantisse 0
(en fait 0 a deux reprśentation, une de signe positif et une de
signe négatif).</P><P>Enfin, on utilise traditionnellement une valeur de l’exposant pour
représenter les nombres plus grands que le plus grand réel
reprśentable sur machine (traditionnellement appelé plus ou
moins infini)
et les erreurs (par exemple 0./0. ou racine carrée d’un nombre
réel négatif, traditionnellement appelé NaN, Not a Number).</P><P><B>Exercice</B> : quels sont les nombres réels représentables exactement
en base 10 mais pas en base 2 ?
Si on écrit 1/10 en base 2 avec 53 bits de précision, puis que
l’on arrondit avec 64 bits de précision, ou si on écrit 1/10 en
base 2 avec 64 bits de précision, obtient-on la même chose ?</P><P>Les ordinateurs reprśentent généralement les flottants en base 2 
(cf. la section suivante pour
plus de précisions), mais cette représentation n’est pas utilisée
habituellement par les humains, qui préfèrent compter
en base 10. Les ordinateurs effectuent donc la conversion dans
les routines d’entrée-sortie. Le format standard utilisé
pour saisir ou afficher un nombre flottant dans un logiciel
scientifique est composé d’un nombre à virgule
flottante utilisant le point comme séparateur décimal (et
non la virgule) suivi si nécessaire de la lettre <CODE>e</CODE> puis de l’exposant,
par exemple <CODE>1.23e-5</CODE> ou <CODE>0.0000123</CODE>. Dans les
logiciels de calcul formel, pour distinguer un entiers
représentés par un entier
d’un entier représenté par un flottant on écrit
l’entier suivi de <CODE>.0</CODE> par exemple <CODE>23.0</CODE>.</P><P><B>Remarque</B> :<BR>
Les microprocesseurs ayant un mode <B>BCD</B><A NAME="@default6"></A> peuvent avoir un format
de représentation des flottants en base 10, les nombres décimaux
comme par exemple 0.3 peuvent être représentés exactement. 
Certains logiciels, notamment maple, utilisent par défaut des
flottants logiciels en base 10 sur des microprocesseurs sans mode BCD, 
ce qui entraine une baisse de
rapidité importante pour les calculs numériques (on peut
partiellement améliorer les performances en utilisant <CODE>evalhf</CODE>
en maple).</P><!--TOC subsubsection Les flottants au format <TT>double</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc6">2.2.2</A>  Les flottants au format <TT>double</TT></H4><!--SEC END --><P> 
<A NAME="@default7"></A> <A NAME="@default8"></A>
Cette section développe les notions de la section précédente
pour les flottants machine selon la norme IEEE-754, utilisables dans les langage de
programmation usuels, elle peut être omise en première lecture.
La représentation d’un double
en mémoire se compose de 3 parties : le bit<A NAME="@default9"></A> 
de signe <I>s</I>=± 1 sur 1 bit, 
la mantisse<A NAME="@default10"></A> <I>M</I> ∈ [0,2<SUP>52</SUP>[ sur 52 bits, 
et l’exposant<A NAME="@default11"></A> <I>e</I> ∈ [0, 2<SUP>11</SUP>[ sur 11 bits. Pour les nombres
“normaux”, l’exposant est en fait compris entre 1 et 2<SUP>11</SUP>−2,
le nombre représenté est le rationnel
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(1+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>M</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP>52</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">) 2<SUP><I>e</I>+1−2<SUP>10</SUP></SUP> </TD></TR>
</TABLE><P>
Pour écrire un nombre sous cette forme, il faut d’abord chercher par
quel multiple de 2 il faut le diviser pour obtenir un réel <I>r</I> dans
[1,2[, ce qui permet de déterminer l’exposant <I>e</I>. Ensuite on
écrit la représentation en base 2 de <I>r</I>−1 ∈ [0,1[.
Exemples :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
-2<BR>
Signe négatif. Il faut diviser sa valeur absolue 
2 par 2<SUP>1</SUP> pour être entre 1 et 2 dont
<I>e</I>+1−2<SUP>10</SUP>=1, l’exposant est <I>e</I>=2<SUP>10</SUP>. On a alors <I>r</I>=1, <I>r</I>−1=0.
Représentation<BR>
<CODE>1 10000000000 00000000...0000</CODE>
</LI><LI CLASS="li-itemize">1.5=3/2<BR>
Signe positif, compris entre 1 et 2 dont l’exposant vérifie
<I>e</I>+1−2<SUP>10</SUP>=0 soit
<I>e</I>=2<SUP>10</SUP>−1=2<SUP>9</SUP>+2<SUP>8</SUP>+2<SUP>7</SUP>+2<SUP>6</SUP>+2<SUP>5</SUP>+2<SUP>4</SUP>+2<SUP>3</SUP>+2<SUP>2</SUP>+2<SUP>1</SUP>+2<SUP>0</SUP>. 
On a <I>r</I>−1=1/2=2<SUP>−1</SUP>. D’où la représentation<BR>
<CODE>0 01111111111 10000000...0000</CODE>
</LI><LI CLASS="li-itemize">6.4=32/5<BR>
Positif. Il faut le diviser par 2<SUP>2</SUP> pour avoir 8/5 ∈ [1,2[
donc <I>e</I>+1−2<SUP>10</SUP>=2 soit <I>e</I>=2<SUP>10</SUP>+1. Ensuite <I>r</I>=3/5 qu’il faut
écrire en base 2 (cf. section précédente),
on écrit donc les 52 premiers éléments du développement
avec une règle d’arrondi du dernier bit au nombre le plus proche. 
Ici le bit suivant le dernier <CODE>1001</CODE> est un <CODE>1</CODE>, on arrondit
donc à <CODE>1010</CODE>. D’où la représentation<BR>
<CODE>0 1000000001 100110011001...10011010</CODE><BR>
</LI></UL><P>
On observe que la représentation en base 2 de 6.4 a du être
arrondie (car elle est infinie en base 2) bien qu’elle soit exacte
(finie) en base 10.
Seuls les entiers et les rationnels dont le dénominateur est une puissance
de 2 peuvent être représentés exactement.
Ceci entraine des résultats qui peuvent surprendre
comme par exemple le fait que
<CODE>0.5 - 5*0.1</CODE> n’est pas nul.</P><P>Des représentations spéciales (avec <I>e</I>=0 ou <I>e</I>=2<SUP>11</SUP>−1) 
ont été introduites
pour représenter ± ∞ (pour les flottants plus grands
en valeur absolue que le plus grand flottant représentable), et pour
représenter les
nombres non nuls plus petits que le plus petit flottant représentable
de la manière exposée ci-dessus (on parle de flottants dénormalisés),
ainsi que le nombre NaN (Not a Number) lorsqu’une opération a un résultat
indéfini (par exemple 0/0).</P><P>Remarque : Sur les processeurs compatibles avec les i386, 
le coprocesseur arithmétique i387 gère en interne des flottants
avec 80 bits dont 64 bits de mantisse. Sur les architectures 64 bits
(x86 ou AMD), le jeu d’instruction SSE permet de travailler avec
des flottants de 128 bits. Le compilateur gcc permet d’utiliser
ces flottants longs avec le type <CODE>long double</CODE> ou
les types <CODE>__float80</CODE> et <CODE>__float128</CODE> en utilisant
un drapeau de compilation du type <CODE>-msse</CODE></P><!--TOC subsubsection Opérations sur les flottants-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc7">2.2.3</A>  Opérations sur les flottants</H4><!--SEC END --><P>
Les opérations arithmétiques de base sur les flottants
se font de la manière suivante :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
addition et soustraction : on détecte s’il faut additionner
ou soustraire en valeur absolue en analysant les signes,
on détermine l’exposant le plus grand et on décale la partie mantisse 
du flottant dont l’exposant est le plus petit pour se ramener à additionner
deux entiers (partie mantisses correspondant au même exposant), 
on décale à nouveau la partie mantisse en modifiant l’exposant 
après l’opération pour normaliser le flottant
</LI><LI CLASS="li-itemize">multiplication : on additionne les exposants et on multiplie
les parties mantisses (vus comme des entiers), on arrondit et
on ajuste l’exposant si nécessaire
</LI><LI CLASS="li-itemize">division : on soustrait les exposants et on divise les parties
mantisses (division “à virgule”), on tronque et on
ajuste l’exposant si nécessaire
</LI></UL><!--TOC subsubsection Erreurs-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc8">2.2.4</A>  Erreurs</H4><!--SEC END --><P> <A NAME="@default12"></A>
La représentation des nombres réels par des doubles présente
des avantages, les opérations arithmétiques
sont faites au plus vite par le microprocesseur.
Les coprocesseurs arithmétiques (intégrés sur les microprocesseurs
de PC) proposent même
le calcul des fonctions usuelles (trigonométriques, racine carrée, log et exp)
sur le type double et utilisent des formats de représentation interne
ayant plus de 64 bits pour les doubles, ce qui permet de limiter
les erreurs d’arrondi. 
Par contre, des erreurs vont être introduites,
on parle de calcul approché par opposition au calcul exact sur les
rationnels. En effet, la représentation doit d’abord arrondir 
tout réel qui n’est pas un rationnel dont le dénominateur
est une puissance de 2. Ensuite chaque opération va entrainer
une propagation de ces erreurs et va y ajouter une erreur d’arrondi 
sur le résultat.
Enfin, l’utilisation du type double peut provoquer un dépassement
de capacité (par exemple <CODE>100!*100!</CODE>).</P><P>Pour diminuer ces erreurs et les risques de dépassement de
capacité, il existe des types flottants multiple précision,
qui permettent de travailler avec un nombre fixé à l’avance
de décimales et une plage d’exposants plus grande. Les calculs sont plus longs mais les erreurs
plus faibles. Attention, il s’agit toujours de calcul approché!
De plus, pour des quantités dont la valeur est déterminée
de manière expérimentale, la source principale de propagation
d’erreurs est la précision des quantités initiales, il ne sert
souvent à rien d’utiliser des types flottants multiprécision car les
erreurs dus à la représentation (double) sont négligeables devant
les erreurs de mesure. Dans ce cas, il est pertinent lorsqu’on
évalue <I>f</I>(<I>x</I>) avec <I>x</I> mal connu de calculer aussi <I>f</I>′(<I>x</I>), en effet :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>x</I>(1+<I>h</I>))= <I>f</I>(<I>x</I>)+<I>xh</I> <I>f</I>′(<I>x</I>) + <I>O</I>(<I>h</I><SUP>2</SUP>)</TD></TR>
</TABLE><P>
l’erreur relative sur <I>f</I>(<I>x</I>) est donc au premier ordre multipliée par
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>xf</I>′(<I>x</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>f</I>(<I>x</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">|</TD></TR>
</TABLE><P>
Par exemple, l’erreur relative sur <I>e</I><SUP><I>x</I></SUP> est au premier ordre l’erreur relative sur <I>x</I>
multipliée par |<I>x</I>|.</P><!--TOC subsubsection Erreur absolue, relative, arrondi propagation des erreurs.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc9">2.2.5</A>  Erreur absolue, relative, arrondi propagation des erreurs.</H4><!--SEC END --><P>
On a vu précédemment que pour représenter un réel, on devait
l’arrondir, ce qui introduit une erreur même si le réel est
connu exactement (par exemple 1/10).
Voyons comment se propagent les <B>erreurs</B><A NAME="@default13"></A> 
dans les opérations arithmétiques
de base : on distingue l’addition, la multiplication
et l’inversion. La soustraction se ramène à l’addition car
le calcul de l’opposé n’introduit aucune erreur nouvelle.
Pour l’addition, si |<I>x</I> −<I>x</I><SUB>0</SUB>| ≤ ε<SUB>0</SUB> et si |<I>y</I>−<I>y</I><SUB>0</SUB>| ≤ ε<SUB>1</SUB>
alors par l’inégalité triangulaire (|<I>a</I>+<I>b</I>|≤ |<I>a</I>|+|<I>b</I>|), on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|(<I>x</I>+<I>y</I>)−(<I>x</I><SUB>0</SUB>+<I>y</I><SUB>0</SUB>)| ≤ |<I>x</I>−<I>x</I><SUB>0</SUB>| + | <I>y</I>−<I>y</I><SUB>0</SUB> | ≤ 
ε<SUB>0</SUB> + ε<SUB>1</SUB> </TD></TR>
</TABLE><P>
on dit que les erreurs <EM>absolues</EM> s’additionnent. 
</P><DIV CLASS="theorem"><B>Définition 2</B>  <EM>
L’</EM><EM><B>erreur absolue</B></EM><A NAME="@default14"></A><EM>
est définie comme un majorant de la valeur absolue
de la différence entre le nombre réel et
son représentant double :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>|<I>x</I>−<I>x</I></EM><SUB><EM>0</EM></SUB><EM>| ≤ ε </EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>
Mais comme il faut représenter <I>x</I><SUB>0</SUB>+<I>y</I><SUB>0</SUB>
en machine, on doit ajouter une erreur d’arrondi, qui est
proportionnelle à la valeur absolue de <I>x</I><SUB>0</SUB>+<I>y</I><SUB>0</SUB> d’où la notion
d’erreur <EM>relative</EM> :
</P><DIV CLASS="theorem"><B>Définition 3</B>  <EM>
L’</EM><EM><B>erreur relative</B></EM><A NAME="@default15"></A><EM> 
est égale à l’erreur absolue divisée par
la valeur absolue du nombre
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>|<I>x</I>−<I>x</I></EM><SUB><EM>0</EM></SUB><EM>| ≤ ε |<I>x</I></EM><SUB><EM>0</EM></SUB><EM>| </EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>
Remarquons au passage que les erreurs de mesure expérimentales sont 
pratiquement toujours des erreurs relatives.</P><P>Donc lorsqu’on effectue une addition (ou une soustraction) de deux réels
sur machine, on doit additionner les deux erreurs absolues sur les opérandes
et ajouter une erreur d’arrondi (relative de 2<SUP>−53</SUP>, à titre
d’exercice, on pourra vérifier que cette erreur
d’arrondi est majorée par l’erreur absolue de la somme 
<I>x</I>+<I>y</I> dès l’instant où
<I>x</I> et <I>y</I> ont eux-même une erreur d’arrondi).</P><P>Lorsqu’on effectue une multiplication de deux nombres <I>x</I>,<I>y</I> dont les
représentants <I>x</I><SUB>0</SUB>,<I>y</I><SUB>0</SUB> sont non nuls, on a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>xy</I>−<I>x</I><SUB>0</SUB> <I>y</I><SUB>0</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB>0</SUB> <I>y</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD><TD CLASS="dcell">= 
</TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>y</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> −1 </TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD><TD CLASS="dcell">
= </TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD><TD CLASS="dcell">
(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">−1)(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>y</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> −1)+(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">−1)+(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>y</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> −1) 
</TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD></TR>
</TABLE><P>
l’erreur relative est donc la somme des erreurs relatives et du produit
des erreurs relatives (on peut souvent négliger le produit devant la somme). Il
faut aussi y ajouter une erreur relative d’arrondi de 2<SUP>−53</SUP> sur <I>x</I><SUB>0</SUB> <I>y</I><SUB>0</SUB>.</P><P>On observe que la multiplication est une opération posant moins
de problèmes que l’addition, car on manipule toujours des erreurs
relatives, par exemple si l’erreur relative sur deux doubles
<I>x</I> et <I>y</I> non nuls
est de 2<SUP>−53</SUP>, alors l’erreur relative sur <I>xy</I> sera de 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">2<SUP>−53</SUP> + 2<SUP>−53</SUP> + 2<SUP>−106</SUP> + 2<SUP>−53</SUP> ≈ 3 × 2<SUP>−53</SUP> </TD></TR>
</TABLE><P>
Lorsque l’erreur relative sur les données est grande devant 2<SUP>−53</SUP>,
l’erreur relative d’arrondi final est négligeable, on peut alors dire que
les erreurs relatives s’additionnent pour un produit (c’est aussi vrai
pour un quotient: exercice!).
Par contre, si on additionne deux nombres dont le représentant de
la somme est proche de 0, la somme des erreurs absolues peut
devenir non négligeable par rapport à la somme des représentants, entrainant
une erreur relative très grande. Par exemple si <I>x</I> est représenté
par <I>x</I><SUB>0</SUB>=1+2<SUP>−52</SUP> avec
une erreur d’arrondi de 2<SUP>−53</SUP> et
<I>y</I> par <I>y</I><SUB>0</SUB>=−1 avec la même erreur d’arrondi, 
l’addition de <I>x</I> et <I>y</I> renvoie 2<SUP>−52</SUP> avec une erreur
absolue de 2 * 2<SUP>−53</SUP> (ici il n’y a pas d’arrondi lorsqu’on fait la somme).
C’est une erreur relative de 1 (qui domine largement
l’erreur d’arrondi) ce qui signifie que dans la mantisse, seul le
premier bit sur les 52 a un sens, la perte de précision est très grande.</P><P>Une autre conséquence importante est que l’addition de réels sur machine
n’est pas une opération associative,
par exemple
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(2.0<SUP>−53</SUP>+2.0<SUP>−53</SUP>)+1.0 → 1+2<SUP>−52</SUP> </TD></TR>
</TABLE><P>
alors que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(2.0<SUP>−53</SUP>+1.0)+2.0<SUP>−53</SUP> → 1 </TD></TR>
</TABLE><P>
Si on a plusieurs termes
à additionner, il faut commencer par additionner entre eux
les termes les plus petits, pour que les petits termes ne soient
pas absorbés un à un dans les erreurs d’arrondi (les petits ruisseaux
font les grands fleuves).</P><P>Exercice : pour calculer la valeur
numérique d’une dérivée de fonction, il vaut mieux
calculer (<I>f</I>(<I>x</I>+<I>h</I>)−<I>f</I>(<I>x</I>−<I>h</I>))/(2<I>h</I>) que (<I>f</I>(<I>x</I>+<I>h</I>)−<I>f</I>(<I>x</I>))/<I>h</I>. Attention
toutefois à ne pas prendre <I>h</I> trop petit, sinon <I>x</I>+<I>h</I>=<I>x</I>! Par
exemple <I>h</I>=10<SUP>−8</SUP> donne un <I>h</I><SUP>2</SUP> de l’ordre des erreurs d’arrondi.</P><P>Remarquons néanmoins que les erreurs calculées ici sont des majorations
des erreurs réelles (ou si on préfère l’erreur obtenue dans le pire
des cas), statistiquement les erreurs sur les résultats sont moindres,
par exemple si on effectue <I>n</I> calculs susceptibles de provoquer
des erreurs indépendantes suivant une même loi d’espérance nulle, la moyenne des
erreurs divisée par l’écart-type de la loi
tend vers une loi normale centrée réduite. De manière plus
déterministe, on a l’inégalité de Bienaymé-Tchebyshev
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(|<I>X</I>|&gt;α) ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>σ<SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">α<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
où <I>X</I> est la variable aléatoire somme des <I>n</I> erreurs, α
l’erreur et <I>n</I>σ<SUP>2</SUP> la variance de la somme <I>n</I> erreurs
supposées indépendantes, cette probabilité tend vers 0 pour <I>n</I>
grand si α est d’ordre <I>n</I>, et ne tend
pas vers 0 si α est de l’ordre de √<SPAN style="text-decoration:overline"><I>n</I></SPAN>.</P><P>Il est d’ailleurs souvent trop difficile de calculer une majoration
rigoureuse de l’erreur pour des calculs sauf les plus simples.
Lorsqu’on doute de la précision d’un calcul, un test peu couteux consiste
à refaire ce calcul en utilisant des flottants en précision plus
grande et tester si le résultat varie en fonction du nombre de chiffres
significatifs utilisés, ou faire varier légèrement
les données et observer la sensibilité du résultat.
Si on veut travailler en toute rigueur sans
pour autant calculer les erreurs à priori, il faut utiliser un logiciel
utilisant des intervalles pour représenter les réels (section suivante)</P><!--TOC subsection L’arithmétique d’intervalle.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc10">2.3</A>  L’arithmétique d’intervalle.</H3><!--SEC END --><P><A NAME="@default16"></A>
Certains systèmes de calcul formel peuvent manipuler directement
des intervalles réels, par exemple par l’intermédiaire de la
bibliothèque C MPFI. Les opérations arithmétiques sur des
intervalles renvoient alors le meilleur intervalle possible contenant
toutes les valeurs possibles lorsque les opérandes parcourent
leurs intervalles respectifs.
Exemple en Xcas (version 1.1.1 et ultérieures) :
<CODE>[-1..2]*[-1..2]</CODE> renvoie <CODE>[-2..4]</CODE>.
Attention ici on parcourt toutes les valeurs possibles de 
<I>xy</I>,  <I>x</I> ∈ [−1,2], <I>y</I> ∈ [−1,2]. Ce qui est différent du carré
d’un intervalle ou plus généralement de l’évaluation
d’un polynôme en un intervalle, <CODE>horner(x^2,[-1..2])</CODE>
renvoie ainsi <CODE>[0..4]</CODE>.</P><P>Les fonctions disponibles sont souvent moins riches qu’en
arithmétique flottante, le calcul d’une fonction non monotone
sur un intervalle peut s’avérer délicat, alors que si la fonction
est monotone, il suffit de calculer l’image des deux bornes
de l’intervalle. Pour les polynômes, Xcas décompose
les coefficients en deux parties <I>P</I>=<I>P</I><SUB>+</SUB>−<I>P</I><SUB>−</SUB> en fonction
du signe, puis utilise la monotonie de <I>P</I><SUB>+</SUB> et <I>P</I><SUB>−</SUB> sur
ℝ<SUP>+</SUP> et ℝ<SUP>−</SUP> respectivement.</P><P>L’arithmétique d’intervalle dans ℂ est beaucoup plus difficile
à mettre en oeuvre puisqu’il n’y a plus d’ordre ni de monotonie,
on doit alors s’en remettre à des estimations sur les parties
réelles et imaginaires qui ne tiendront pas compte du phénomène
ci-dessus sur la différence entre <I>xy</I>,  <I>x</I> ∈ [−1,2], <I>y</I> ∈ [−1,2]
et <I>x</I><SUP>2</SUP>,  <I>x</I> ∈ [−1,2].</P><!--TOC subsection Calcul exact et approché, types, évaluation.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc11">2.4</A>  Calcul exact et approché, types, évaluation.</H3><!--SEC END --><P><A NAME="@default17"></A>
Dans les langages de programmation traditionnel (C, Pascal,...), il existe 
déjà des types permettant une représentation 
exacte des données (type entier) ou une représentation approchée 
(type flottant). Mais ces types de donnée de base 
occupent une taille fixe en mémoire, le type entier est donc
limité à un intervalle d’entiers (par exemple [0,2<SUP>32</SUP>−1] pour un entier
non signé sur une machine utilisant un processeur 32 bits) alors que le 
type flottant peut représenter des nombres réels, mais est 
limité à une précision en nombre de digits de la mantisse et de l’exposant 
(par exemple 12 chiffres significatifs et un 
exposant compris entre -499 et 499). </P><P>En calcul formel, on souhaite pouvoir calculer rigoureusement d’une part, 
et avec des paramètres dont la valeur n’est 
pas connue d’autre part ; il faut donc s’affranchir de ces limites : 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
pour les entiers relatifs, on utilise des entiers de 
<EM>précision arbitraire</EM>
dont la taille en mémoire est dynamique (déterminée pendant l’exécution et non
à la compilation),
</LI><LI CLASS="li-itemize">pour les nombres complexes, on utilise un couple de nombres réels,
</LI><LI CLASS="li-itemize">pour les rationnels, on utilise un couple d’entiers relatifs,
</LI><LI CLASS="li-itemize">pour les irrationnels algébriques (par exemple √<SPAN style="text-decoration:overline">2</SPAN>), 
on utilise un polynôme irréductible dont ils sont racines,
</LI><LI CLASS="li-itemize">pour les paramètres (<I>x</I>,<I>y</I>,<I>z</I>,<I>t</I>...), on utilise un type 
structuré contenant un champ de type chaine de caractères pour 
représenter le nom du paramètre et
un champ pour attribuer une valeur à (ou une hypothèse sur) ce paramètre,
</LI><LI CLASS="li-itemize">pour les nombres transcendants (par exemple π), on est obligé
d’introduire un paramètre auquel on attribue une valeur numérique, 
qui ne sera utilisée qu’au moment où on veut une 
approximation numérique d’une expression contenant ce nombre transcendant,
on parle de constante,
</LI><LI CLASS="li-itemize">lorsqu’on a besoin d’une approximation numérique d’un nombre,
on peut utiliser des conversions de ces types en un type flottant. On peut 
aussi pour lutter contre les erreurs 
d’arrondi utiliser des nombres flottants étendus dont la précision est 
dynamique ou même des intervalles de flottants étendus,
</LI><LI CLASS="li-itemize">il faut aussi
un nouveau type, appelé expression ou symbolique, permettant d’appliquer
une fonction qu’on ne peut évaluer directement sur les objets précédents,
par exemple sin(<I>x</I>). Il
doit s’agir d’une opération de clôture, au sens où appliquer une fonction à
un objet symbolique ne nécessite pas la création d’un nouveau type
(en général on renvoie un objet symbolique).
</LI></UL><P>Enfin, il faut pouvoir évaluer un objet (en particulier symbolique) :
par exemple évaluer sin(<I>x</I>) lorsqu’on assigne une valeur à <I>x</I>. 
Dans cet exemple, on voit qu’il faut d’abord remplacer <I>x</I> par
sa valeur avant de lui appliquer la fonction sinus. C’est le mécanisme
général de l’évaluation, mais il y a quelques exceptions où
on souhaite empêcher l’évaluation d’un ou plusieurs arguments
d’une fonction avant l’évaluation de la fonction. Par exemple si on 
veut calculer la valeur numérique d’une intégrale par des méthodes
de quadrature, on ne souhaitera pas rechercher une primitive de la 
fonction à intégrer. Dans le jargon, on parle alors de “quoter” un argument 
(l’origine du terme vient probablement de la notation <CODE>'</CODE> du langage 
Lisp). Certaines fonctions doivent toujours quoter leurs arguments
(par exemple la fonction qui permet de purger le contenu d’un paramètre),
on parle parfois d’autoquotation.</P><!--TOC subsection Forme normale et reconnaissance du 0.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc12">2.5</A>  Forme normale et reconnaissance du 0.</H3><!--SEC END --><P>
Une fois défini ces types de base représentant les nombres d’un système de 
calcul formel, il faut pouvoir comparer ces 
nombres, en particulier décider si deux représentations distinctes 
correspondent au même nombre ou, ce qui revient au 
même, par soustraction décider quand un nombre est nul. 
Par exemple 4/2 et 2 représentent le même nombre. 
Lorsqu’on dispose d’un algorithme permettant de représenter un nombre 
d’une manière unique, on parle de forme normale. 
C’est par exemple le cas pour les nombres rationnels, la forme normale 
usuelle est la fraction irréductible de 
dénominateur positif. C’est aussi le cas pour les fractions rationnelles 
de polynômes à coefficients entiers représentées par une fraction 
irréductible, avec au dénominateur un coefficient de plus haut degré
positif.
Malheureusement, il n’est pas toujours possible de trouver une forme normale
pour diverses raisons théoriques ou pratiques : 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
on ne connaît pas toujours le statut de certaines constantes
(par exemple la constante d’Euler),
</LI><LI CLASS="li-itemize">il n’existe pas d’algorithmes permettant de déterminer
s’il existe des relations algébriques entre constantes,
</LI><LI CLASS="li-itemize">il n’existe pas forcément une seule forme plus simple, par exemple :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD></TR>
</TABLE></TD><TD CLASS="dcell">+1)<I>x</I>+1</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>+</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD></TR>
</TABLE></TD><TD CLASS="dcell">+1</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>+</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD></TR>
</TABLE></TD><TD CLASS="dcell">−1</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD></TR>
</TABLE></TD><TD CLASS="dcell">−1)<I>x</I>+1</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE>
Ce cas se présente fréquemment avec les extensions algébriques.
</LI><LI CLASS="li-itemize">en pratique il peut être trop coûteux d’utiliser une forme
normale, par exemple le polynôme <I>x</I><SUP>1000</SUP>−1/<I>x</I>−1 possède 1000 monômes
</LI></UL><P>
En résumé, au mieux on a une forme normale, au pire on risque de ne pas 
reconnaître un zéro, entre les deux on peut ne
pas avoir de forme normale mais être capable de reconnaître à coup sûr 
une expression nulle (par contre, si le système 
de calcul formel détermine qu’une expression est nulle, alors elle l’est).</P><P>Il n’existe pas d’algorithme solution
pour le problème de la reconnaissance du zéro pour une classe 
d’expressions "assez générale". Heureusement, 
dans la plupart des cas pratiques on sait résoudre ce problème, en
se ramenant le plus souvent au cas des polynômes et fractions rationnelles.
Par exemple, pour simplifier une expression trigonométrique,
on remplace les fonctions trigonométriques sin(<I>x</I>), cos(<I>x</I>), tan(<I>x</I>)
par leur expression en fonction de <I>t</I>=tan(<I>x</I>/2), on est ainsi ramené
à une fraction rationnelle en <I>t</I> que l’on écrit sous forme normale.</P><P>Les polynômes ont un rôle central dans tout système de calcul formel
puisque sauf dans les cas les plus simples (fractions d’entiers par exemple), 
la simplification d’expressions
fait appel à un moment ou à un autre à des calculs
de PGCD de polynômes. Le PGCD de polynômes est un algorithme 
très sollicité auquel nous consacrerons une section. En effet,
l’application brutale de l’algorithme d’Euclide pose des problèmes
d’efficacité ce qui a obligé à inventer des méthodes plus efficaces.
Anticipons rapidement sur un exemple qui montre l’un des problèmes
majeurs des algorithmes de calcul formel, l’explosion en taille
(ici des coefficients des restes successifs).
Voici donc les restes successifs lorsqu’on applique l’algorithme
d’Euclide pour calculer le PGCD de <I>P</I>(<I>x</I>)=(<I>x</I>+1)<SUP>7</SUP>−(<I>x</I>−1)<SUP>6</SUP> avec
sa dérivée (les deux polynômes sont premiers entre eux) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>7 (<I>x</I>+1)<SUP>6</SUP>−6 (<I>x</I>−1)<SUP>5</SUP></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">162</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">49</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>5</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−390</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">49</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>4</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1060</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">49</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>3</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−780</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">49</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>2</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">474</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">49</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−78</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">49</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">157780</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">729</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>4</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−507640</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2187</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>3</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">290864</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">729</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>2</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−101528</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">729</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">28028</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">729</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">49</TD></TR>
</TABLE></TD><TD CLASS="dcell">  (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1400328</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2645</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>3</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−732888</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2645</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>2</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1133352</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3703</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−732888</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">18515</TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2187</TD></TR>
</TABLE></TD><TD CLASS="dcell">  (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2161816376832</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4669921</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>2</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−555436846944</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4669921</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">301917024864</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4669921</TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">907235</TD></TR>
</TABLE></TD><TD CLASS="dcell">  (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">469345063045455</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">129411872</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−47641670106615</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">129411872</TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">5497465490623352995840</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">209648836272383412129</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Le lecteur voulant tester d’autres exemples pourra utiliser le programme 
<CODE>Xcas</CODE> (cf. l’appendice) suivant :
</P><PRE CLASS="verbatim">pgcd(a):={
  local b,r,res;
  b:=diff(a,x);
  res:=NULL;
  for (;b!=0;){
    res:=res,b;
    r:=rem(a,b);
    a:=b;
    b:=r;
  }
  return(res);
}
</PRE><!--TOC subsection Valeur générique des variables et
hypothèses-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc13">2.6</A>  Valeur générique des variables et
hypothèses</H3><!--SEC END --><P><A NAME="@default18"></A> <A NAME="@default19"></A>
Lorsqu’on utilise un symbole sans lui affecter de valeurs en mathématiques 
on s’attend à une discussion en fonction du 
paramètre représenté par ce symbole. Ce qui nécessiterait de créer un 
arborescence de calculs (on retrouve ici les problèmes 
d’explosion évoqués dans la section précédente). 
La plupart des systèmes de calcul formel contournent la difficulté en 
supposant que le paramètre possède une valeur 
générique (par exemple la solution de (<I>t</I><SUP>2</SUP>−1)<I>x</I>=<I>t</I>−1 sera <I>x</I>=1/(<I>t</I>+1)) ou 
choisissent une branche pour les fonctions 
possédant un point de branchement (par exemple pour résoudre <I>x</I><SUP>2</SUP>=<I>t</I> 
en fonction de <I>t</I>). Certains systèmes demandent de 
manière interactive à l’utilisateur si la variable est par exemple positive 
ou différente de 1 mais cela s’oppose à un 
traitement automatique. 
On peut aussi anticiper ce type de décision en faisant des hypothèses
sur une paramètre, la plupart des systèmes de calcul formel actuel
proposent cette possibilité.</P><!--TOC subsection Structures de données-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc14">2.7</A>  Structures de données</H3><!--SEC END --><P>
On a vu plus haut qu’on souhaitait manipuler des entiers de taille non 
fixe, des réels de précision fixe ou non, des
fractions, des nombres complexes, des extensions algébriques, des 
paramètres, des expressions symboliques. La plupart des systèmes
proposent un type générique qui recouvre ces divers types de scalaire.
On peut par exemple utiliser un type structuré comportant un champ
type et la donnée ou un pointeur sur la donnée (avec dans ce cas un 
pointeur sur un compteur de références de la donnée
pour pouvoir la détruire dès qu’elle n’est plus référencée<SUP><A NAME="text1" HREF="#note1">1</A></SUP>). 
En programmation orientée objet, on utiliserait plutôt un
type abstrait dont dérivent ces différents scalaires et le polymorphisme.</P><P>Il faut aussi un type pour les vecteurs, les matrices et les
listes. Il faut prendre garde à la méthode utilisée
par le système lorsqu’on modifie un élément
d’un vecteur, matrice ou liste : soit on effectue une copie de tout
l’objet en modifiant l’élément, soit on modifie l’élément
de l’objet original. La première méthode (par valeur) est
plus aisée à comprendre pour un débutant mais
la seconde méthode (par référence) est bien plus efficace.</P><P>On peut se poser la question de savoir s’il faut inclure 
ces types dans le type générique ; en général la 
réponse est affirmative, une des raisons étant que les 
interpréteurs qui permettront de lire des données dans un 
fichier texte sont en général basé sur le couple de logiciels
<CODE>lex(flex)/yacc(bison)</CODE> qui ne peut compiler qu’à destination d’un 
seul type. Ceci permet également d’unifier en un seul type symbolique 
les fonctions ayant un ou plusieurs arguments en 
voyant plusieurs arguments comme un vecteur d’arguments. 
Les fonctions sont le plus souvent elle-même incluses dans le 
type générique permettant ainsi à l’utilisateur de saisir des 
commandes ou programmes fonctionnels (on peut
utiliser une fonction comme argument d’une commande).</P><P>Pour des raisons d’efficacité, les systèmes de calcul formel
utilisent souvent des représentations particulières pour les polynômes
dont on a dit qu’ils jouaient un rôle central.
Pour les polynômes à une variable,
on peut utiliser la liste des coefficients du polynôme, on parle
alors de représentation dense. On peut aussi décider de ne stocker
que les coefficients non nuls, on parle alors de représentation creuse
(on stocke alors un couple formé par le coefficient et le degré
du monôme correspondant). Pour les polynômes à plusieurs variables,
on peut les considérer comme des polynômes à une variable à
coefficients polynomiaux, on parle alors de représentation récursive.
On peut aussi décider de ne pas briser la symétrie entre les
variables (pas de variable principale), on parle alors de représentation
distribuée, le plus souvent les représentation distribuées
sont creuses car les représentations
denses nécessitent très vite beaucoup de coefficients. Les méthodes
de représentation creuses sont parfois aussi utilisées pour les
matrices ayant beaucoup de coefficients nuls.</P><P>Voyons maintenant plus précisément sur quelques exemples de logiciels
de calcul formel répandus quelles structures de données sont
utilisées. Plusieurs éléments entrent en compte dans les choix faits :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
le(s) profil(s) d’utilisation (enseignement, ingéniérie,
calcul intensif, recherche)
</LI><LI CLASS="li-itemize">les ressources disponibles (mémoire, puissance du processeur...)
</LI><LI CLASS="li-itemize">la facilité d’implémentation (choix du langage, outils
disponibles en particulier débuggueurs, ...)
</LI><LI CLASS="li-itemize">l’histoire du système (un système conçu avec les outils
disponibles aujourd’hui est forcément différent d’un système 
conçu il y a 20 ans)
</LI></UL><P>
Voyons quelques exemples, d’abord Giac, puis des systèmes 
pour ordinateur où les ressources
(par exemple mémoire) sont moins limitées ce qui permet 
d’utiliser des langages de programmation de plus haut niveau.
On termine par les calculatrices formelles
HP et TI des années 2000<SUP><A NAME="text2" HREF="#note2">2</A></SUP>.
Ce sont des systèmes plutôt destinés à l’enseignement, soumis 
à de fortes contraintes en termes de taille mémoire, et destinés
à traiter des petits problèmes.</P><!--TOC subsubsection Maple, Mathematica, ...-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc15">2.7.1</A>  Maple, Mathematica, ...</H4><!--SEC END --><P>
Ces systèmes ont un noyau fermé, au sens où l’utilisateur n’a pas
accès du tout, ou en tout cas pas facilement, aux structures de données
de base. Je ne dispose donc pas d’information sur les structures de données
utilisées par le noyau.</P><P>L’interaction système-utilisateur se fait quasiment toujours en utilisant le
langage de programmation propre au système, langage interprété
par le noyau du système (ce qui ralentit l’exécution). Ces langages 
utilisateurs sont essentiellement
non typés : on travaille avec des variables du type générique sans pouvoir
accéder aux types sous-jacents. On ne bénéficie en général pas des
vérifications faites lors de la compilation avec un langage typé,
de plus ces systèmes ne sont pas toujours fourni avec de bon outils de 
mise au point. Enfin ces langages ne sont pas standardisés d’un
système à l’autre et il est en général impossible
d’utiliser ces systèmes comme des librairies depuis un langage
de programmation traditionnel. Leur intérêt principal réside donc
dans une utilisation interactive en profitant de la librairie de 
fonctions accessibles.</P><!--TOC subsubsection Giac/xcas-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc16">2.7.2</A>  Giac/xcas</H4><!--SEC END --><P>
Il s’agit du système de calcul formel que j’implémente actuellement sous 
forme d’une bibliothèque C++ (ce qui
permettra aux programmes tiers d’utiliser beaucoup plus facilement du 
calcul formel qu’avec les systèmes précédents). L’objectif est 
d’avoir un système facile à programmer directement en C++, proche 
du langage utilisateur, lui-même compatible avec Maple ou MuPAD, 
tout cela sans trop perdre en performances comparativement aux
librairies spécialisées écrites en C/C++. Ce qui explique un choix 
de type générique (<CODE>gen</CODE>) non orienté objet, avec un champ type 
et soit une donnée immédiate (pour les nombres flottants par exemple), 
soit un pointeur vers un objet du type correspondant au champ type pour 
les données de taille non fixe (on pourrait donc se
contenter du langage C, mais le langage C++ permet de redéfinir 
les opérateurs sur des types utilisateurs ce qui
améliore considérablement la lisibilité du code source). 
Les données dynamiques ne sont pas dupliquées, Giac
utilise un pointeur sur un compteur de référence pour détruire 
ces données lorsqu’elles ne sont plus référencées.</P><P>Les entiers en précision arbitraire sont hérités de la bibliothque
GMP (écrite en C) du projet GNU. Les flottants en précision arbitraire
utiliseront aussi GMP (plus précisément MPFR).
Il y a un type fraction, structure C composé d’un champ numérateur
et d’un champ dénominateur, et un type nombre complexe.</P><P>Les listes, vecteurs, matrices utilisent le type paramétré <CODE>vector&lt;&gt;</CODE>
de la librairie standard C++ (Standard Template Library).
Les objets symboliques sont des structures composés d’un champ sommet
qui est une fonction prenant un argument de type <CODE>gen</CODE>
et renvoyant un résultat
de type <CODE>gen</CODE>, et d’un champ feuille qui est de type <CODE>gen</CODE>.
Lorsqu’une fonction possède plusieurs arguments, ils sont rassemblés
en une liste formant le champ feuille de l’objet symbolique.
Les programmes sont aussi des objets symboliques, dont le champ
sommet est la fonction évaluation d’un programme.
Les listes sont aussi utilisées pour représenter vecteurs, matrices
et polynômes en une variable en représentation dense, on peut
y accéder par valeur (<CODE>:=</CODE>) ou par référence
(<CODE>=&lt;</CODE>). Ces polynômes servent eux-mêmes á représenter
des éléments d’une 
<B>extension algébrique</B><A NAME="@default20"></A><A NAME="@default21"></A> de ℚ (vus comme
un couple de polynômes <I>P</I>,<I>Q</I>, où <I>Q</I> est un polynome minimal
irréductible à coefficients entiers, autrement dit <I>P</I>,<I>Q</I> vaut <I>P</I>(α) 
où <I>Q</I>(α)=0),
ou des éléments d’un corps fini (comme ci-dessus, mais ici <I>Q</I> est
à coefficients dans ℤ/<I>p</I>ℤ avec <I>p</I> premier, cf. la commande <CODE>GF</CODE>).
Giac posséde aussi un type pour les polynômes
en représentation creuse distribuée en plusieurs
indéterminées (cf. les commandes <CODE>symb2poly</CODE> et <CODE>poly2symb</CODE>).</P><P>L’évaluation d’un objet symbolique se fait en regardant d’abord si
la fonction au sommet doit évaluer ou non ses arguments (autoquote),
on évalue les arguments si nécessaire puis on applique la fonction.</P><P>Une hypthèse sur un paramètre est une valeur spéciale
affectée au paramètre, valeur ignorée par la routine d’évaluation.</P><!--TOC subsubsection Calculatrices formelles HP48/49-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc17">2.7.3</A>  Calculatrices formelles HP48/49</H4><!--SEC END --><P>
Les langages utilisés pour programmer ces calculateurs sont l’assembleur
et le RPL (Reverse Polish Lisp) adapté à l’écriture de code
en mémoire morte très compact.</P><P>Le type générique est implémenté avec un champ type appelé prologue (qui est
en fait un pointeur sur la fonction chargée d’évaluer ce type d’objet)
suivi de la donnée elle-même (et non d’un pointeur sur la donnée, on
économise ainsi la place mémoire du compteur de référence).</P><P>Le type entier en précision arbitraire est codé par le nombre de digits 
(sur 5 quartets<SUP><A NAME="text3" HREF="#note3">3</A></SUP>) suivi du signe sur un 
quartet et de la représentation BCD (en base 10) de la valeur absolue de 
l’entier. Le choix de la représentation BCD a été fait pour optimiser 
les temps de conversion en chaîne de caractères pour l’affichage. La mémoire
vive disponible est de 256K, c’est elle qui limite la taille des entiers 
et non le champ longueur de l’entier. Il n’y a pas de type spécifique 
pour les rationnels (on utilise un objet
symbolique normal). </P><P>Les fonctions internes des HP49/50/40 utilisent 
le type programme pour représenter les entiers de Gauß (complexes
dont la partie réelle et imaginaire est entière).
Les nombres algébriques ne sont pas implémentés, sauf les racines carrées
(représentée de manière interne par le type programme). 
Il y a un type spécifique prévu pour les flottants en précision arbitraire, 
mais l’implémentation des opérations sur ces types
n’a pas été intégrée en ROM à ce jour. </P><P>Les types listes, programmes et objet symbolique sont composés du prologue
(champ type) suivi par la succession d’objets situés en
mémoire vive ou de pointeurs sur des objets situés en mémoire en lecture 
seule (ROM) et se terminent par un pointeur sur une
adresse fixe (appelée <CODE>SEMI</CODE>). Ces types sont eux-mêmes des 
objets et peuvent donc être utilisés de manière
récursive. La longueur des types listes, programmes, symboliques 
n’est stockée nulle part, c’est le délimiteur final
qui permet de la connaître, ce qui est parfois source d’inefficacité.
On utilise de manière interne les listes pour représenter les 
polynômes denses (avec 
représentation récursive pour les polynômes à plusieurs variables). </P><P>Les calculatrices HP4xG utilisent une pile<SUP><A NAME="text4" HREF="#note4">4</A></SUP>, c’est-à-dire une liste
de taille non fixée d’objets. On place les objets sur la pile,
l’exécution d’une fonction prend ces arguments sur
la pile et renvoie un ou plusieurs résultats sur la pile (ce qui est
une souplesse du RPN comparé aux langages où on ne peut renvoyer
qu’une valeur de retour). Il faut donc
donner les arguments avant d’appeler la fonction correspondante. Par
exemple pour calculer <I>a</I>+<I>b</I> on tapera <CODE>a b +</CODE>. C’est
la syntaxe dite polonaise inversée (RPN). Un avantage de cette syntaxe
est que le codage d’un objet symbolique par cette syntaxe est évidente,
il suffit de stocker la liste précédente <CODE>{a b +}</CODE>.
Les objets symboliques sont donc représenté par une suite d’objets écrit
en syntaxe polonaise inversée. L’évaluation d’un objet symbolique se fait
dans l’ordre polonaise inversé : les arguments sont évalués
puis les fonctions leur sont appliqués. Pour des raisons d’efficacité, 
on représente souvent les objets composites (listes, symboliques) par 
leurs composants placés sur la pile (appelé meta-objets).</P><P>Une rigidité de la syntaxe polonaise est
que les fonctions ont toujours un nombre fixe d’arguments<SUP><A NAME="text5" HREF="#note5">5</A></SUP>, par
exemple l’addition a toujours 2 arguments, ainsi
<I>a</I>+<I>b</I>+<I>c</I> est obtenu par (<I>a</I>+<I>b</I>)+<I>c</I> ou par <I>a</I>+(<I>b</I>+<I>c</I>)
c’est-à-dire respectivement <CODE>a b + c +</CODE> ou <CODE>a b c + +</CODE> ce qui
brise parfois artificiellement la symétrie de certaines opérations. En
polonaise inversée, le système doit de plus jongler avec l’autoquote puisque
les arguments sont évalués avant l’opérateur qui éventuellement demanderait
à ne pas évaluer ses arguments. À noter l’existence d’une commande 
<CODE>QUOTE</CODE> permettant à l’utilisateur de quoter une sous-expression.</P><P>Les hypothèses sur des variables réelles sont regroupées dans une liste
stockée dans la variable globale <CODE>REALASSUME</CODE>, on peut supposer
qu’une variable est dans un intervalle. Il n’y a pas à ce jour
de possibilité de supposer qu’une variable est entière (ni à fortiori
qu’une variable à une valeur modulo un entier fixé), bien qu’il ait été
décidé de réserver la variable globale <CODE>INTEGERASSUME</CODE> à cet effet.
Il n’y a pas de possibilité de faire des hypothèses ayant une portée
locale.</P><!--TOC subsubsection Calculatrices formelles TI92/89/Voyage 200-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc18">2.7.4</A>  Calculatrices formelles TI92/89/Voyage 200</H4><!--SEC END --><P>
Le langage utilisé pour programmer ces calculatrices est le langage C
(on peut aussi écrire du code en assembleur pour ces calculatrices).
On retrouve ici les différents types de données regroupé en un
type générique qui est un tableau d’octets (aussi appelé quantum). 
Le champ type
est appelé tag dans la documentation TI. Contrairement à ce qui
précède, ce champ type est placé en mémoire à la fin de l’objet,
ce qui est possible car la longueur d’un objet est toujours indiquée
au début de l’objet. Ceci est fait afin de faciliter l’évaluation (cf.
infra).</P><P>Les entiers en précision arbitraire sont codés par un tag parmi deux (pour
différencier le signe), un octet pour la longueur, puis la valeur
absolue de l’entier (en base 256). Ils sont donc limités par le
champ longueur à 255 octets, le plus grand entier représentable est
<SUP><A NAME="text6" HREF="#note6">6</A></SUP> (256<SUP>255</SUP>−1).
Il existe un tag spécifique pour les rationnels, pour les constantes 
réelles et entières qui apparaissent par exemple en résolvant une équation.
Il existe des tags utilisés de manière interne, par exemple
pour les nombres complexes. 
Il n’y a pas de tag prévu pour les flottants en précision arbitraire.
ni pour les nombres algébriques (racines carrées par 
exemple).</P><P>Les listes sont codées par la succession de leurs éléments. En principe
elles ne peuvent pas contenir des listes (sauf pour représenter
une matrice).
Quelques fonctions utilisent les listes pour représenter des polynômes 
denses à une variable, mais probablement pas pour représenter de manière
récursive des polynômes à plusieurs variables (puisque le type liste
n’est en principe pas récursif).</P><P>Comme les HP, les TI utilisent une pile (non visible par
l’utilisateur) appelée expression stack
afin de traduire un expression mathématique sous forme d’un texte
en un objet symbolique codé exactement comme ci-dessus en syntaxe
polonaise. Toutefois, la présence du champ longueur
permet d’évaluer un objet symbolique sans perdre en efficacité
en partant de l’opérateur
final et en redescendant ensuite sur ces arguments, c’est la stratégie
adoptée. C’est pour cela que le tag d’identification
se trouve à la fin de l’objet. L’utilisation de cette méthode
facilite grandement l’autoquotation (on peut toutefois regretter
que le système n’ait pas prévu d’instruction permettant à l’utilisateur 
d’empêcher l’évaluation d’une sous-expression).</P><P>On ne peut pas faire d’hypothèse globale sur un paramètre par
contre on peut faire des hypothèses de type appartenance à un intervalle 
ayant une portée locale.</P><!--TOC subsection Algorithmes et complexité.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc19">2.8</A>  Algorithmes et complexité.</H3><!--SEC END --><P>
On va présenter dans la suite quelques algorithmes que l’on peut
considérer comme classiques dans le domaine du calcul formel. Avant 
d’implémenter ce type d’algorithmes, on a besoin des algorithmes de base
en arithmétique. Le lecteur trouvera en appendice une brève présentation
de certains de ces algorithmes, mes références en la matière sont le livre
de Henri Cohen, et les livres de Donald Knuth (cf. appendice).</P><P>La plupart des problèmes posés en calcul formel nécessitent des
calculs dont la taille croit de manière exponentielle voire
doublement exponentielle en fonction de la taille des données et
ce même si le résultat est lui aussi de taille petite. Un
exemple est la réduction des systèmes de plusieurs équations polynomiales
(bases de Groebner).</P><!--TOC subsubsection Algorithmes modulaires ou p-adiques-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc20">2.8.1</A>  Algorithmes modulaires ou p-adiques</H4><!--SEC END --><P>
Dans certains cas, l’application de théories mathématiques
parfois sophistiquées permet de réduire la complexité (par exemple,
M. Van Hoeij a découvert récemment qu’un algorithme très utilisé en théorie des
nombres, l’algorithme LLL, permettait d’améliorer la complexité d’une des
étapes de la factorisation des polynomes à coefficients entiers sur les
entiers). Heureusement, dans de nombreux cas, on peut réduire la
complexité (donc le temps de calcul) par des adaptations au
problème d’une même idée à condition de faire des
hypothèses sur les données (autrement dit en abandonnant la volonté
d’implémenter un algorithme très générique, ou tout au moins
en spécialisant des algorithmes génériques).
Par exemple lorsqu’on travaille
avec des entiers (ou des polynômes à coefficients entiers, ou
des matrices à coefficients entiers...) on utilise souvent des algorithmes
modulaires et <I>p</I>-adiques. Comme le calcul exact nécessite
presque toujours de calculer avec des entiers, ces méthodes
ont un rôle central en calcul formel, nous les présentons donc
maintenant brièvement. Dans les prochaines sections, nous utiliserons
ce type de méthode, par exemple pour le calcul de PGCD ou la factorisation
de polynômes à coefficients entiers.</P><P>Les méthodes <B>modulaires</B><A NAME="@default22"></A> consistent à réduire un problème dans 
ℤ à son équivalent dans <I>Z</I>/<I>n</I>ℤ pour une ou 
plusieurs valeurs de <I>n</I>, nombre premier. Le calcul dans ℤ/<I>n</I>ℤ
a l’avantage de se faire avec des entiers dont la taille est bornée.
Ensuite à l’aide d’estimations 
à priori sur la taille des solutions 
éventuelles du problème initial, on reconstruit la solution au problème
initial avec le théorème des restes chinois. </P><P>Par exemple, on peut calculer un déterminant d’une matrice
à coefficients entiers en cherchant ce déterminant dans ℤ/<I>n</I>ℤ
pour plusieurs nombres premiers <I>n</I>, dont le produit est deux fois plus grand qu’une 
estimation à priori de la taille du déterminant 
(donnée par exemple par l’inégalité d’Hadamard, cf. Cohen, p. 50). </P><P>Les méthodes <B><I>p</I></B><B>-adiques</B><A NAME="@default23"></A> commencent de manière identique par un 
calcul dans ℤ/<I>n</I>ℤ, on augmente ensuite la
précision de la solution en la «liftant»de ℤ/<I>n</I><SUP><I>k</I></SUP> ℤ vers 
ℤ/<I>n</I><SUP><I>k</I>+1</SUP>ℤ ou vers ℤ/<I>n</I><SUP>2<I>k</I></SUP>ℤ (lift
linéaire ou lift quadratique), on s’arrête lorsque <I>k</I> est assez grand 
(à l’aide d’estimations à priori) et on
reconstruit alors la solution initiale. L’étape de «lift»est en 
général un lemme de Hensel dont on verra quelques exemples dans les
prochains articles. L’algorithme
commun au lemme de Hensel et au théorème des restes chinois est 
l’identité de Bézout, que l’on retrouve 
d’ailleurs un peu partout (par exemple pour le calcul de primitives). </P><P>Illustrons cette méthode sur un exemple simple, la recherche de 
<B>racines rationnelles</B><A NAME="@default24"></A> d’un polynôme <I>P</I>(<I>X</I>)=<I>a</I><SUB><I>d</I></SUB> <I>X</I><SUP><I>d</I></SUP> + ⋯ + <I>a</I><SUB>0</SUB> 
à coefficients entiers ou polynomiaux, avec <I>a</I><SUB><I>d</I></SUB> et <I>a</I><SUB>0</SUB> non nuls. 
L’algorithme générique (assez connu) consiste 
à chercher les diviseurs de <I>a</I><SUB>0</SUB> et de <I>a</I><SUB><I>d</I></SUB> et à tester toutes 
les fractions de ces diviseurs, on montre en effet 
aisément que si <I>X</I>=<I>p</I>/<I>q</I> fraction irréductible est racine de <I>P</I> 
alors <I>q</I> divise <I>a</I><SUB><I>d</I></SUB> et <I>p</I> divise <I>a</I><SUB>0</SUB>. Cet 
algorithme est très inefficace si <I>a</I><SUB><I>d</I></SUB> ou <I>a</I><SUB>0</SUB> est un grand entier 
(car on ne sait pas forcément le factoriser) ou 
s’il a beaucoup de facteurs premiers (la liste des diviseurs à tester 
est alors très grande). </P><P>Lorsque les coefficients de <I>P</I> sont entiers, la recherche précédente 
revient à trouver un facteur à
coefficients entiers <I>qX</I>−<I>p</I> de <I>P</I>, on peut donc réduire le problème 
modulo un entier premier <I>n</I> qui ne divise pas <I>a</I><SUB><I>d</I></SUB> : si un tel facteur 
existe dans ℤ alors ce facteur (réduit modulo <I>n</I>) est un facteur 
de <I>P</I> dans ℤ/<I>n</I>ℤ
donc <I>P</I> admet une racine dans ℤ/<I>n</I>ℤ (puisque <I>q</I> est inversible 
modulo <I>n</I> car on a choisi <I>n</I> premier ne divisant pas <I>a</I><SUB><I>d</I></SUB>). On
évalue maintenant <I>P</I> en les <I>n</I> éléments de ℤ/<I>n</I>ℤ. S’il n’y a pas 
de 0, alors <I>P</I> n’a pas de racine rationnelle. S’il y a des racines, on va 
les lifter de ℤ/<I>n</I><SUP><I>k</I></SUP>ℤ dans ℤ/<I>n</I><SUP>2<I>k</I></SUP>ℤ.</P><P>On suppose donc que pour <I>k</I>≥ 1, il existe un entier <I>p</I><SUB><I>k</I></SUB> tel que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>p</I><SUB><I>k</I></SUB>)=0 (mod <I>n</I><SUP><I>k</I></SUP> ) </TD></TR>
</TABLE><P>
Il s’agit de trouver un entier <I>x</I> tel que <I>p</I><SUB><I>k</I>+1</SUB>=<I>p</I><SUB><I>k</I></SUB>+<I>n</I><SUP><I>k</I></SUP>  <I>x</I>
vérifie
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>p</I><SUB><I>k</I>+1</SUB>)=0 (mod <I>n</I><SUP>2<I>k</I></SUP> ) </TD></TR>
</TABLE><P>
On applique la formule de Taylor à l’ordre 1 pour <I>P</I> en <I>p</I><SUB><I>k</I></SUB>, le
reste est nul modulo <I>n</I><SUP>2<I>k</I></SUP>, donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>p</I><SUB><I>k</I></SUB>)+ <I>n</I><SUP><I>k</I></SUP>  <I>x</I> <I>P</I>′(<I>p</I><SUB><I>k</I></SUB>)=0 (mod <I>n</I><SUP>2<I>k</I></SUP> ) </TD></TR>
</TABLE><P>
soit finalement :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>=−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I>(<I>p</I><SUB><I>k</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I><SUP><I>k</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  ( <I>P</I>′(<I>p</I><SUB><I>k</I></SUB>) (mod <I>n</I><SUP><I>k</I></SUP> )) <SUP>−1</SUP> </TD></TR>
</TABLE><P>
On reconnaît au passage la méthode de Newton<A NAME="@default25"></A>, pour qu’elle fonctionne 
il suffit que <I>P</I>′(<I>p</I><SUB><I>k</I></SUB>) ≠ 0 (mod <I>n</I> ) ce qui
permet de l’inverser modulo <I>n</I><SUP><I>k</I></SUP> (et c’est ici qu’intervient 
l’identité de Bézout). En pratique quand on factorise
un polynôme, on commence par retirer les multiplicités, 
on peut donc supposer que <I>P</I> est sans facteur multiple dans
ℤ. Ceci n’entraîne pas forcément qu’il le reste dans ℤ/<I>n</I>ℤ 
ce qui crée une contrainte supplémentaire sur le choix
de <I>n</I>, à savoir que <I>P</I> et <I>P</I>′ restent premier entre eux dans ℤ/<I>n</I>ℤ 
(il existe forcément de tels <I>n</I>, par exemple
<I>n</I> premier plus grand que le plus grand entier intervenant dans le calcul 
du PGCD de <I>P</I> et <I>P</I>′ dans ℤ).</P><P>Reste donc à revenir dans ℤ à partir d’une racine <I>p</I><SUB><I>k</I></SUB> dans ℤ/(<I>n</I><SUP><I>k</I></SUP> ℤ)
(où on peut choisir <I>k</I>). 
On va maintenant utiliser la représentation 
<B>modulaire symétrique</B><A NAME="@default26"></A> :
on prend comme représentant modulaire d’un entier <I>z</I> dans ℤ/<I>n</I><SUP><I>k</I></SUP>ℤ
l’unique entier congru à <I>z</I> modulo <I>n</I> qui est strictement compris entre
−<I>n</I><SUP><I>k</I></SUP>/2 et <I>n</I><SUP><I>k</I></SUP>/2 (si <I>n</I> est pair, la deuxième inégalité
est choisie large).</P><P>Si <I>qX</I>−<I>p</I> est un facteur de <I>P</I>, alors <I>a</I><SUB><I>d</I></SUB><I>X</I>−<I>a</I><SUB><I>d</I></SUB>/<I>q</I><I>p</I> est encore 
un facteur de <I>P</I> (le quotient de <I>P</I> par <I>a</I><SUB><I>d</I></SUB><I>X</I>−<I>a</I><SUB><I>d</I></SUB>/<I>q</I><I>p</I>
est à coefficients rationnels mais le facteur est à coefficients entiers). 
Si on a choisi <I>k</I> tel que <I>n</I><SUP><I>k</I></SUP>&gt;2|<I>a</I><SUB><I>d</I></SUB> <I>a</I><SUB>0</SUB>|, l’écriture en représentation
modulaire symétrique de <I>a</I><SUB><I>d</I></SUB><I>X</I>−<I>a</I><SUB><I>d</I></SUB>/<I>q</I><I>p</I> est inchangée,
en effet on a des estimations à priori sur les entiers <I>p</I> et <I>q</I> : 
|<I>q</I>|≤ |<I>a</I><SUB><I>d</I></SUB>| et |<I>p</I>| ≤ |<I>a</I><SUB>0</SUB>| puisque <I>q</I> 
divise <I>a</I><SUB><I>d</I></SUB> et <I>p</I> divise <I>a</I><SUB>0</SUB>. 
Comme <I>a</I><SUB><I>d</I></SUB><I>X</I>−<I>a</I><SUB><I>d</I></SUB>/<I>q</I><I>p</I> est égal à <I>a</I><SUB><I>d</I></SUB>(<I>X</I>−<I>p</I><SUB><I>k</I></SUB>) dans ℤ/(<I>n</I><SUP><I>k</I></SUP> ℤ),
il nous suffit d’écrire en représentation modulaire 
symétrique <I>a</I><SUB><I>d</I></SUB>(<I>X</I>−<I>p</I><SUB><I>k</I></SUB>)=<I>a</I><SUB><I>d</I></SUB> <I>X</I>−<I>p</I>′.
Pour conclure, on sait que <I>a</I><SUB><I>d</I></SUB> <I>X</I>−<I>p</I>′ est un multiple entier de <I>qX</I>−<I>p</I>.
On divise donc le facteur <I>a</I><SUB><I>d</I></SUB> <I>X</I>−<I>p</I>′ par le pgcd de <I>a</I><SUB><I>d</I></SUB> et <I>p</I>′ et on
teste la divisibilité de <I>P</I> par ce facteur réduit.</P><P><B>Exemple</B><BR>
Considérons le polynôme 2 <I>X</I><SUP>3</SUP>−<I>X</I><SUP>2</SUP>−<I>X</I>−3 qui est sans facteur carré.
On ne peut pas choisir <I>n</I>=2 car on réduirait le degré, pour <I>n</I>=3,
on a <I>P</I>′=<I>X</I>−1 qui est facteur de <I>P</I>, pour <I>n</I>=5, <I>P</I>′=6<I>X</I><SUP>2</SUP>−2<I>X</I>−1,
on vérifie que <I>P</I> et <I>P</I>′ sont premiers entre eux (par exemple
avec <CODE>GCDMOD</CODE> sur une HP49 où on aura fixé la variable <CODE>MODULO</CODE>
à 5).</P><P>On teste ensuite les entiers de -2 à 2 sur <I>P</I>. Seul -1 est racine
modulo 5 (<I>P</I>(−1)=−5), on va maintenant lifter <I>p</I><SUB>1</SUB>=−1. </P><P>L’estimation à priori est 2|<I>a</I><SUB><I>d</I></SUB>||<I>a</I><SUB>0</SUB>|=12 donc <I>k</I>=2 (5<SUP>2</SUP>=25&gt;12), 
une itération suffira. On a <I>P</I>′(−1)=7, l’inverse de <I>P</I>′(−1) (mod 5 )
est -2 donc:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>= −</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I>(−1)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">5</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (−2) = −(−1)  (−2)=−2 </TD></TR>
</TABLE><P>
et <I>p</I><SUB>2</SUB>=−1+5×(−2)=−11 est racine de <I>P</I> dans ℤ/25ℤ.
On calcule ensuite <I>a</I><SUB><I>d</I></SUB>(<I>X</I>−<I>p</I><SUB><I>k</I></SUB>)=2(<I>X</I>+11)=2<I>X</I>+22=2<I>X</I>−3 en représentation
symétrique, le PGCD de 2 et -3 est 1 donc on teste le facteur
2<I>X</I>−3, ici il divise <I>P</I> donc <I>P</I> admet un unique facteur entier
de degré 1 qui est 2<I>X</I>−3.</P><!--TOC subsubsection Algorithmes déterministes. Algorithmes probabilistes: Las Vegas
et Monte-Carlo-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc21">2.8.2</A>  Algorithmes déterministes. Algorithmes probabilistes: Las Vegas
et Monte-Carlo</H4><!--SEC END --><P><A NAME="@default27"></A><A NAME="@default28"></A><A NAME="@default29"></A><A NAME="@default30"></A>
L’algorithme p-adique présenté ci-dessus est un algorithme
déterministe, il renvoie toujours un résultat certifié et 
le temps de calcul nécessaire à son exécution ne dépend
pas du hasard (sauf si on choisit le nombre premier <I>p</I> au hasard...).
Ce type d’algorithmes est parfois trop long par rapport 
à d’autres type d’algorithmes utilisant le hasard :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
les algorithmes de type Las Vegas. Ceux-ci utilisent un 
élément aléatoire (dont dépend le temps d’exécution) mais
certifient le résultat. Par exemple pour calculer le polynôme
caractéristique d’une matrice <I>M</I> de taille <I>n</I>, on choisit 
un vecteur <I>v</I> aléatoirement
et on cherche une relation linéaire entre <I>v</I>,<I>Mv</I>,...,<I>M</I><SUP><I>n</I></SUP><I>v</I>,
s’il n’y en a qu’une à constante multiplicative près, alors
elle donne le polynôme caractéristique, sinon on se rabat
sur une autre méthode (ou on renvoie une erreur).
</LI><LI CLASS="li-itemize">les algorithmes de type Monte-Carlo. Ceux-ci utilisent un
élément aléatoire mais ne certifient pas le résultat, qui a
une très faible probabilité d’être inexact. Par exemple,
pour calculer un déterminant d’une matrice à coefficients
entiers, on peut faire le calcul modulo plusieurs nombres
premiers et reconstruire le résultat par le théorème
des restes chinois et décider de s’arrêter lorsque
le résultat reconstruit est stable pour un, deux, ... nombres
premiers. L’inverse de la probabilité d’erreur est égale
au produit des nombres premiers pour lesquel on observe la
stabilité. Autre exemple: le test de pseudo-primalité
de Miller-Rabin.
</LI></UL><P>
Dans Xcas, certains algorithmes sont de type Monte-Carlo par
défaut, notamment le calcul de déterminant de grandes matrices
à coefficients entiers ou de bases de Gröbner, et un warning
s’affiche alors. La variable
<CODE>proba_epsilon</CODE> permet de régler le niveau de probabilité
d’erreur acceptée, on peut la mettre à 0 pour forcer l’utilisation
d’algorithmes déterministes ou de type Las Vegas avec certification
du résultat. Si l’on fait des calculs à but expérimental pour
établir une conjecture, il n’est pas nécessaire de certifier un
calcul et il ne sert à rien de mettre <CODE>proba_epsilon</CODE> à 0.
Par contre, pour établir une preuve (au sens mathématique du terme) qui
nécessite un calcul fait sur machine,
on prendra soin de mettre <CODE>proba_epsilon</CODE> à 0. 
On remarquera au passage que ce type de
preuve ne peut se faire qu’avec un logiciel open-source, puisqu’il
faut aussi pouvoir montrer que l’algorithme utilisé
est correctement implémenté.</P><!--TOC subsection Quelques algorithmes d’arithmétique de base.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc22">2.9</A>  Quelques algorithmes d’arithmétique de base.</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
Les algorithmes de multiplication et division dit rapides
des entiers et polynômes (Karatsuba, FFT, ...). Cf. par exemple Knuth.
ou pour les entiers la documentation de GMP, ou infra pour Karatsuba.
</LI><LI CLASS="li-itemize">Au lieu de la division euclidienne, on utilise très souvent la
<B>pseudo-division</B><A NAME="@default31"></A> pour les polynômes : étant donné deux polynômes <I>A</I>
et <I>B</I> de degrés <I>a</I> et <I>b</I> à coefficients dans un anneau contenu dans un corps
(par exemple ℤ), on multiplie <I>A</I> par une puissance du coefficient
dominant <I>B</I><SUB><I>b</I></SUB> de <I>B</I>, plus précisément par <I>B</I><SUB><I>b</I></SUB><SUP><I>a</I>−<I>b</I>+1</SUP>, ce qui permet 
d’effectuer la division par <I>B</I> sans que
les coefficients sortent de l’anneau.
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>B</I><SUB><I>b</I></SUB><SUP><I>a</I>−<I>b</I>+1</SUP> <I>A</I>= <I>B</I> <I>Q</I> + <I>R</I> </TD></TR>
</TABLE>
On utilise cette méthode lorsqu’on peut multiplier les polynômes par
des constantes sans changer le problème (par exemple pour l’algorithme
d’Euclide).
</LI><LI CLASS="li-itemize">L’algorithme d’Euclide est un algorithme «générique»de calcul
de PGCD. Il n’est en général pas utilisé tel quel. Pour les entiers 
on utilise une variation adaptée à la
représentation binaire des entiers (cf. Cohen ou le manuel de GMP version 4 
pour plus de détails). Nous décrirons des
algorithmes de PGCD plus efficaces pour les polynômes dans le prochain article.
</LI><LI CLASS="li-itemize">l’<B>identité de Bézout</B><A NAME="@default32"></A>, aussi appelée PGCD étendu. Étant donné
deux entiers ou deux polynômes <I>a</I> et <I>b</I> on calcule <I>u</I>, <I>v</I> et
<I>d</I> tels que <I>au</I>+<I>bv</I>=<I>d</I>. On écrit la matrice :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><I>a</I></TD><TD ALIGN=left NOWRAP>1</TD><TD ALIGN=left NOWRAP>0 </TD></TR>
<TR><TD ALIGN=left NOWRAP><I>b</I></TD><TD ALIGN=left NOWRAP>0</TD><TD ALIGN=left NOWRAP>1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD></TR>
</TABLE>
où on remarque que pour chaque ligne le coefficient de la 1ère colonne 
est égal à <I>a</I> multiplié par le coefficient de la
2ème colonne additionné à <I>b</I> multiplié par le coefficient de la 
3ème colonne. Ce qui reste vrai si on effectue des
combinaisons linéaires de lignes (type réduction de Gauß). 
Comme on travaille dans les entiers ou les polynômes, on remplace la
réduction de Gauß des matrices à coefficients réels par une combinaison 
linéaire utilisant le quotient <EM>euclidien</EM> (entier ou polynomial
selon le cas) <I>q</I>
de <I>a</I> par <I>b</I>. On obtient alors le reste <I>r</I> en 1ère colonne :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>L</I><SUB>1</SUB></TD><TD ALIGN=left NOWRAP><I>a</I></TD><TD ALIGN=left NOWRAP>1</TD><TD ALIGN=left NOWRAP>0 </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>L</I><SUB>2</SUB></TD><TD ALIGN=left NOWRAP><I>b</I></TD><TD ALIGN=left NOWRAP>0</TD><TD ALIGN=left NOWRAP>1 </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>L</I><SUB>3</SUB>=<I>L</I><SUB>1</SUB>−<I>qL</I><SUB>2</SUB></TD><TD ALIGN=left NOWRAP><I>r</I></TD><TD ALIGN=left NOWRAP>1</TD><TD ALIGN=left NOWRAP>−<I>q</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE>
et on recommence jusqu’à obtenir 0 en 1ère colonne.
L’avant-dernière ligne obtenue est l’identité de Bézout (la dernière
ligne donne les cofacteurs du PPCM de <I>a</I> et <I>b</I>). 
Si l’on veut l’inverse de <I>a</I> modulo
<I>b</I> on remarque qu’il n’est pas utile de calculer les coefficients
appartenant à la 3ème colonne. Enfin, les lignes intermédiaires
peuvent servir à reconstruire une fraction d’entier représentée
par un entier de ℤ/<I>n</I>ℤ lorsque le numérateur et le dénominateur
sont de valeur absolue inférieure à √<SPAN style="text-decoration:overline"><I>n</I>/2</SPAN>.
</LI><LI CLASS="li-itemize">Le théorème des <B>restes chinois</B><A NAME="@default33"></A><A NAME="@default34"></A>. 
Si on connaît <I>x</I>=<I>a</I> (mod <I>m</I> )
et <I>x</I>= <I>b</I> (mod <I>n</I> )  avec <I>m</I> et <I>n</I> premiers entre eux,
on détermine <I>c</I> tel que
<I>x</I>=<I>c</I> (mod <I>m</I>× <I>n</I> ). On a donc <I>c</I>=<I>a</I>+<I>mu</I>=<I>b</I>+<I>nv</I> et on applique
Bézout pour trouver <I>u</I> ou <I>v</I>, on en déduit <I>c</I>. En pratique,
on cherche un des coefficients de Bézout, par exemple on cherche <I>U</I>
tel que <I>mU</I>+<I>nV</I>=1, on a alors :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>c</I>=<I>a</I>+<I>m</I> (<I>b</I>−<I>a</I>)<I>U</I> </TD></TR>
</TABLE>
Si <I>n</I> est petit devant <I>m</I> (par exemple 32 bits), <I>U</I> est aussi petit,
on commence par réduire <I>b</I>−<I>a</I> modulo <I>n</I>,
puis on multiplie par <I>U</I>, on réduit à nouveau modulo <I>n</I> et on
multiple enfin par <I>m</I>.
</LI><LI CLASS="li-itemize">Les tests de pseudo-primalité. Il est essentiel d’avoir une
méthode rapide permettant de générer des nombres premiers pour appliquer
des méthodes modulaires et <I>p</I>-adiques. On utilise souvent le
<B>test de Miller-Rabin</B><A NAME="@default35"></A><A NAME="@default36"></A>, qui prolonge le petit théorème de Fermat
(si <I>p</I> est premier, alors <I>a</I><SUP><I>p</I></SUP>=<I>a</I> (mod <I>p</I> )). Voir le manuel de
programmation de Xcas.
</LI></UL><!--TOC subsubsection Exemple : l’algorithme de Karatsuba-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc23">2.9.1</A>  Exemple : l’algorithme de Karatsuba</H4><!--SEC END --><P><A NAME="@default37"></A>
Soient <I>P</I>, <I>Q</I> deux polynômes de degrés strictement inférieur à
2<I>n</I>. On suppose que le cout d’une opération arithmétique dans le
corps des coefficients vaut 1 et on néglige les autres
opérations (on suppose par exemple que le corps des coefficients
est un corps fini). On écrit
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>=<I>A</I>+<I>x</I><SUP><I>n</I></SUP> <I>B</I>,    <I>Q</I>=<I>C</I>+<I>x</I><SUP><I>n</I></SUP> <I>D</I></TD></TR>
</TABLE><P>
avec <I>A</I>,<I>B</I>,<I>C</I>,<I>D</I> de degrés strictement inférieur à <I>n</I>, on a
alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I> <I>Q</I> = <I>AC</I> + <I>x</I><SUP><I>n</I></SUP>(<I>AD</I>+<I>BC</I>)+<I>x</I><SUP>2<I>n</I></SUP> <I>BD</I></TD></TR>
</TABLE><P>
Il y a 4 produits de polynômes de degrés &lt;<I>n</I>, mais au prix
d’additions intermédiaires, on peut se ramener à 3 produits, en
effet
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>A</I>+<I>B</I>)(<I>C</I>+<I>D</I>)−<I>AC</I>−<I>BD</I> = <I>AD</I>+<I>BC</I></TD></TR>
</TABLE><P>
donc pour calculer le cofacteur de <I>x</I><SUP><I>n</I></SUP> il suffit de soustraire
à (<I>A</I>+<I>B</I>)(<I>C</I>+<I>D</I>) les produits <I>AC</I> et <I>BD</I> que l’on calcule par
ailleurs.
Soit <I>M</I>(<I>n</I>) le temps nécessaire pour calculer le produit de 2
polynômes par cette méthode, on a alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I>(2<I>n</I>) = 3<I>M</I>(<I>n</I>)+ 8<I>n</I></TD></TR>
</TABLE><P>
où 8<I>n</I> représente le nombre d’additions ou de soustractions
pour former <I>A</I>+<I>B</I>, <I>C</I>+<I>D</I>, soustraire <I>AC</I> et <I>BD</I>, et tenir compte
des "retenues" (les termes de degré ≥ <I>n</I> de <I>AC</I> se combinent
avec ceux de degré &lt;2<I>n</I> de <I>AD</I>+<I>BC</I> et les termes de degré &lt; 3<I>n</I>
de <I>x</I><SUP>2<I>n</I></SUP><I>BD</I> avec ceux de degré ≥ 2<I>n</I> de <I>AD</I>+<I>BC</I>).
On en déduit
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I></SUB>=<I>M</I>(2<SUP><I>n</I></SUP>),    <I>u</I><SUB><I>n</I>+1</SUB>=3<I>u</I><SUB><I>n</I></SUB>+8 × 2<SUP><I>n</I></SUP> </TD></TR>
</TABLE><P> 
cette récurrence se résoud facilement par la commande<BR>
<CODE>rsolve(u(n+1)=3*u(n)+8*2^n,u(n),u(0)=1)</CODE><BR>
qui donne <I>M</I>(2<SUP><I>n</I></SUP>)=<I>u</I><SUB><I>n</I></SUB>=−8· 2<SUP><I>n</I></SUP>+9· 3<SUP><I>n</I></SUP>.</P><P>Asymptotiquement, <I>M</I>(2<SUP><I>n</I></SUP>) ≈ 9· 3<SUP><I>n</I></SUP> ce qui est bien
meilleur que la multiplication naive en 2 · 4<SUP><I>n</I></SUP>, mais pour de
petites valeurs de <I>n</I>, la multiplication naive est plus rapide, on
utilise Karatsuba (récursivement) uniquement pour des valeurs de <I>n</I>
suffisamment grandes (théoriquement lorsque 8<I>n</I>, le surcout dû
aux additions est plus petit que la multiplication économisée,
soit 8<I>n</I>&lt;2<I>n</I><SUP>2</SUP> soit <I>n</I>&gt;4, en pratique plutôt pour <I>n</I> de l’ordre de quelques
dizaines selon les implémentations, car nous n’avons tenu compte
que des opérations arithmétiques).</P><!--TOC subsubsection Bezout sur les entiers et les fractions continues-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc24">2.9.2</A>  Bezout sur les entiers et les fractions continues</H4><!--SEC END --><P>
Il existe une variante de l’identité de Bézout présentée
ci-dessus pour les entiers. Soient <I>a</I>≥ <I>b</I>&gt;0 deux entiers, on pose
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>L</I><SUB><I>n</I></SUB>)    <I>a</I> <I>u</I><SUB><I>n</I></SUB> − <I>b</I> <I>v</I><SUB><I>n</I></SUB> = (−1)<SUP><I>n</I></SUP> <I>r</I><SUB><I>n</I></SUB> </TD></TR>
</TABLE><P> 
où <I>r</I><SUB>0</SUB>=<I>a</I>, <I>r</I><SUB>1</SUB>=<I>b</I> et <I>r</I><SUB><I>n</I>+2</SUB> est le reste de la division
euclidienne de <I>r</I><SUB><I>n</I></SUB> par <I>r</I><SUB><I>n</I>+1</SUB> (<I>q</I><SUB><I>n</I>+2</SUB> le quotient), <I>u</I><SUB>0</SUB>=1, <I>u</I><SUB>1</SUB>=0, <I>v</I><SUB>0</SUB>=0,<I>v</I><SUB>1</SUB>=1.
Comme précedemment, chaque ligne s’obtient par combinaison
linéaire des deux précédentes, mais cette fois avec une addition
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>L</I><SUB><I>n</I>+2</SUB>=<I>L</I><SUB><I>n</I></SUB>+<I>q</I><SUB><I>n</I>+2</SUB> <I>L</I><SUB><I>n</I>+1</SUB></TD></TR>
</TABLE><P> 
ce qui se traduit par :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I>+2</SUB>=<I>u</I><SUB><I>n</I></SUB>+<I>q</I><SUB><I>n</I>+2</SUB> <I>u</I><SUB><I>n</I>+1</SUB>,    <I>v</I><SUB><I>n</I>+2</SUB>=<I>v</I><SUB><I>n</I></SUB>+<I>q</I><SUB><I>n</I>+2</SUB> <I>v</I><SUB><I>n</I>+1</SUB></TD></TR>
</TABLE><P>
Les suites <I>u</I><SUB><I>n</I></SUB> et <I>v</I><SUB><I>n</I></SUB> sont alors strictement croissantes (à
partir du rang 1 pour <I>u</I><SUB><I>n</I></SUB>). Au rang <I>k</I> du dernier reste non nul on
a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I> <I>u</I><SUB><I>k</I></SUB> − <I>b</I> <I>v</I><SUB><I>k</I></SUB> = (−1)<SUP><I>k</I></SUP> <I>r</I><SUB><I>k</I></SUB>,    <I>r</I><SUB><I>k</I></SUB>=<I>d</I>=gcd(<I>a</I>,<I>b</I>)</TD></TR>
</TABLE><P>
et au rang suivant :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>au</I><SUB><I>k</I>+1</SUB> −<I>b</I> <I>v</I><SUB><I>k</I>+1</SUB>=0</TD></TR>
</TABLE><P>
On montre par récurrence que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>v</I><SUB><I>n</I></SUB> <I>r</I><SUB><I>n</I>+1</SUB> + <I>v</I><SUB><I>n</I>+1</SUB> <I>r</I><SUB><I>n</I></SUB>=<I>a</I></TD></TR>
</TABLE><P>
et une relation analogue pour <I>u</I><SUB><I>n</I></SUB>, on en déduit alors que
<I>v</I><SUB><I>k</I>+1</SUB>=<I>a</I>/<I>d</I> et <I>u</I><SUB><I>k</I>+1</SUB>=<I>b</I>/<I>d</I> (ce sont les cofacteurs du PPCM de <I>a</I>
et <I>b</I>), 
en particulier les coefficients de
Bézout vérifient <I>u</I><SUB><I>k</I></SUB>&lt;<I>b</I> et <I>v</I><SUB><I>k</I></SUB>&lt;<I>a</I>.</P><P>On va aussi voir que <I>u</I><SUB><I>n</I>+2</SUB>/<I>v</I><SUB><I>n</I>+2</SUB> est la <I>n</I>-ième réduite du
développement
en fractions continues de <I>a</I>/<I>b</I> (donc les coefficients de Bézout
se lisent sur l’avant-dernière réduite). On introduit la notation
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">[<I>a</I><SUB>0</SUB>,<I>a</I><SUB>1</SUB>,..,<I>a</I><SUB><I>n</I></SUB>] =<I>a</I><SUB>0</SUB>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB>1</SUB>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB>2</SUB>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">...</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
pour <I>a</I><SUB>0</SUB> ≥ 0, <I>a</I><SUB>1</SUB>&gt;0, ..., <I>a</I><SUB><I>n</I></SUB>&gt;0.
On a alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>b</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">=[<I>q</I><SUB>2</SUB>,<I>q</I><SUB>3</SUB>,..,<I>q</I><SUB><I>k</I></SUB>]</TD></TR>
</TABLE><P>
En effet :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>b</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>r</I><SUB>0</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">=<I>q</I><SUB>2</SUB> +</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>r</I><SUB>2</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = <I>q</I><SUB>2</SUB> +
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>r</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I><SUB>2</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = ...</TD></TR>
</TABLE><P>
D’autre part, on montre par récurrence sur <I>n</I>≥ 1 que si <I>x</I>&gt;0
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">[<I>q</I><SUB>2</SUB>,..., <I>q</I><SUB><I>n</I></SUB>,<I>x</I>]=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>n</I></SUB><I>x</I>+<I>v</I><SUB><I>n</I>−1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I></SUB><I>x</I>+<I>u</I><SUB><I>n</I>−1</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
en effet au rang <I>n</I>=1
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">[<I>x</I>]=<I>x</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB>1</SUB> <I>x</I> + <I>v</I><SUB>0</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB>1</SUB> <I>x</I>+<I>u</I><SUB>0</SUB> </TD></TR>
</TABLE></TD></TR>
</TABLE><P>
et pour l’induction :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>  [<I>q</I><SUB>2</SUB>,..., <I>q</I><SUB><I>n</I></SUB>,<I>x</I>]</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">[<I>q</I><SUB>2</SUB>,..., <I>q</I><SUB><I>n</I>−1</SUB>,<I>q</I><SUB><I>n</I></SUB>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">] </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>n</I>−1</SUB>(<I>q</I><SUB><I>n</I></SUB>+1/<I>x</I>)+<I>v</I><SUB><I>n</I>−2</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I>−1</SUB>(<I>q</I><SUB><I>n</I></SUB>+1/<I>x</I>)+<I>u</I><SUB><I>n</I>−2</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I>(<I>v</I><SUB><I>n</I>−1</SUB><I>q</I><SUB><I>n</I></SUB>+<I>v</I><SUB><I>n</I>−2</SUB>)+<I>v</I><SUB><I>n</I>−1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>(<I>u</I><SUB><I>n</I>−1</SUB><I>q</I><SUB><I>n</I></SUB>+<I>u</I><SUB><I>n</I>−2</SUB>)+<I>u</I><SUB><I>n</I>−1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>n</I></SUB><I>x</I>+<I>v</I><SUB><I>n</I>−1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I></SUB><I>x</I>+<I>u</I><SUB><I>n</I>−1</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Donc au rang <I>n</I>−1 et pour <I>x</I>=<I>q</I><SUB><I>n</I></SUB>, on obtient 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">[<I>q</I><SUB>2</SUB>,..., <I>q</I><SUB><I>n</I></SUB>]=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>n</I>+1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I>+1</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Les <B>fractions continues</B><A NAME="@default38"></A> <A NAME="@default39"></A>
servent bien entendu aussi et d’abord à approcher les
réels par des rationnels.
L’algorithme de calcul des termes du développement est le suivant :
Soit <I>x</I>≥0. On initialise <I>y</I>=<I>x</I> et la liste des <I>a</I><SUB><I>p</I></SUB> à vide. 
Puis on fait une boucle : on ajoute la partie entière de <I>y</I> à la
liste, on calcule la partie fractionnaire de <I>y</I>, si elle est nulle on
s’arrête (dans ce cas <I>x</I>∈ ℚ),
sinon on stocke dans <I>y</I> l’inverse de cette partie fractionnaire et on recommence.
On note classiquement :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">


     

</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>h</I><SUB>−2</SUB>=0,</TD><TD ALIGN=center NOWRAP> <I>h</I><SUB>−1</SUB>=1,</TD><TD ALIGN=left NOWRAP> <I>h</I><SUB><I>p</I></SUB>=<I>a</I><SUB><I>p</I></SUB> <I>h</I><SUB><I>p</I>−1</SUB>+<I>h</I><SUB><I>p</I>−2</SUB></TD><TD ALIGN=right NOWRAP>    (1)</TD></TR>
<TR><TD ALIGN=right NOWRAP><I>k</I><SUB>−2</SUB>=1,</TD><TD ALIGN=center NOWRAP> <I>k</I><SUB>−1</SUB>=0,</TD><TD ALIGN=left NOWRAP> <I>k</I><SUB><I>p</I></SUB>=<I>a</I><SUB><I>p</I></SUB> <I>k</I><SUB><I>p</I>−1</SUB>+<I>k</I><SUB><I>p</I>−2</SUB>
</TD><TD ALIGN=right NOWRAP>    (2)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On a <I>h</I><SUB>0</SUB>=<I>a</I><SUB>0</SUB>, <I>h</I><SUB>1</SUB>=<I>a</I><SUB>1</SUB> <I>a</I><SUB>0</SUB>+1, <I>k</I><SUB>0</SUB>=1, <I>k</I><SUB>1</SUB>=<I>a</I><SUB>1</SUB>.
Les suites <I>h</I><SUB><I>p</I></SUB> et <I>k</I><SUB><I>p</I></SUB> sont donc positives et strictement croissantes pour <I>p</I>
≥ 1, puisque pour <I>p</I> ≥ 1, <I>a</I><SUB><I>p</I></SUB>≥ 1, elles tendent vers
l’infini au moins aussi vite que des suites de Fibonacci (à vitesse
au moins géométrique donc).
On a aussi aisément par récurrence :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:fraccon"></A>
<I>h</I><SUB><I>p</I></SUB> <I>k</I><SUB><I>p</I>−1</SUB> − <I>h</I><SUB><I>p</I>−1</SUB><I>k</I><SUB><I>p</I></SUB>=(−1)<SUP><I>p</I>+1</SUP>
    (3)</TD></TR>
</TABLE><P>
On montre aussi comme ci-dessus :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">[<I>a</I><SUB>0</SUB>,...,<I>a</I><SUB><I>p</I>−1</SUB>,<I>y</I>]=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>yh</I><SUB><I>p</I>−1</SUB>+<I>h</I><SUB><I>p</I>−2</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>yk</I><SUB><I>p</I>−1</SUB>+<I>k</I><SUB><I>p</I>−2</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On définit <I>x</I><SUB><I>p</I></SUB> par <I>x</I>=[<I>a</I><SUB>0</SUB>,...,<I>a</I><SUB><I>p</I>−1</SUB>,<I>x</I><SUB><I>p</I></SUB>], en faisant <I>y</I>=<I>x</I><SUB><I>p</I></SUB>
on a alors <I>x</I>=<I>x</I><SUB><I>p</I></SUB><I>h</I><SUB><I>p</I>−1</SUB>+<I>h</I><SUB><I>p</I>−2</SUB>/<I>x</I><SUB><I>p</I></SUB> <I>k</I><SUB><I>p</I>−1</SUB>+<I>k</I><SUB><I>p</I>−2</SUB> ce qui
donne <I>x</I><SUB><I>p</I></SUB> en fonction de <I>x</I> et
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>p</I></SUB>=floor</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">− </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>xk</I><SUB><I>p</I>−2</SUB>−<I>h</I><SUB><I>p</I>−2</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>xk</I><SUB><I>p</I>−1</SUB>−<I>h</I><SUB><I>p</I>−1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
En faisant <I>y</I>=<I>a</I><SUB><I>p</I></SUB> on obtient [<I>a</I><SUB>0</SUB>,...,<I>a</I><SUB><I>p</I></SUB>]=<I>h</I><SUB><I>p</I></SUB>/<I>k</I><SUB><I>p</I></SUB>.
On montre ensuite que les suites (<I>h</I><SUB><I>p</I></SUB>/<I>k</I><SUB><I>p</I></SUB>) pour les indices pairs et impairs sont deux
suites adjacentes qui convergent vers <I>x</I>, et on a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:fraccon1"></A>
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I><SUB><I>p</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUB><I>p</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I><SUB><I>p</I>−1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUB><I>p</I>−1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(−1)<SUP><I>p</I>−1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUB><I>p</I></SUB>
<I>k</I><SUB><I>p</I>−1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">
    (4)</TD></TR>
</TABLE><P>
En effet, la dernière égalité est une conséquence immédiate
de (<A HREF="#eq:fraccon">3</A>), la croissance ou décroissance des suites
d’indice pair ou impair s’en déduit en ajoutant (<A HREF="#eq:fraccon1">4</A>) au cran
suivant. La convergence vient de la
limite infinie de <I>k</I><SUB><I>p</I></SUB> en l’infini.
On a donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>=<I>a</I><SUB>0</SUB>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>p</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(−1)<SUP><I>p</I>−1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUB><I>p</I></SUB> <I>k</I><SUB><I>p</I>+1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">, 
   </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUB><I>p</I></SUB>(<I>k</I><SUB><I>p</I></SUB>+<I>k</I><SUB><I>p</I>+1</SUB>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ≤ |<I>x</I>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUB><I>p</I></SUB>
<I>k</I><SUB><I>p</I>+1</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
La convergence est d’autant plus rapide que les <I>k</I><SUB><I>p</I></SUB> tendent
rapidement vers l’infini, donc si les <I>a</I><SUB><I>p</I></SUB> sont plus grands que 1.
La convergence la plus lente correspond au cas où tous les <I>a</I><SUB><I>p</I></SUB>=1
cas du nombre d’or, ou à partir d’un certain rang (nombre de <I>Q</I>[√<SPAN style="text-decoration:overline">5</SPAN>]).</P><!--TOC subsubsection La puissance rapide itérative-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc25">2.9.3</A>  La puissance rapide itérative</H4><!--SEC END --><P><A NAME="@default40"></A><A NAME="@default41"></A>
Pour calculer <I>a</I><SUP><I>k</I></SUP> (mod <I>n</I> ), on décompose <I>k</I> en base 2
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>k</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>J</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>k</I><SUB><I>j</I></SUB> 2<SUP><I>j</I></SUP>,    <I>a</I><SUP><I>k</I></SUP> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>J</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUP><I>k</I><SUB><I>j</I></SUB> 2<SUP><I>j</I></SUP></SUP> 
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>/<I>k</I><SUB><I>j</I></SUB> ≠ 0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUP>2<SUP><I>j</I></SUP></SUP> </TD></TR>
</TABLE><P>
On initialise une variable <CODE>B</CODE> à 1, <CODE>B</CODE> vaudra <I>a</I><SUP><I>k</I></SUP> (mod <I>n</I> ) en fin de calcul, on initialise une variable <CODE>k</CODE> à <I>k</I>.
On calcule dans une boucle les carrés successifs de <I>a</I>
(mod <I>n</I> ) que l’on stocke dans une variable <CODE>A</CODE> (<CODE>A</CODE> 
vaudra donc successivement <I>a</I> (mod <I>n</I> ), <I>a</I><SUP>2</SUP> (mod <I>n</I> ), <I>a</I><SUP>4</SUP> (mod <I>n</I> ),
...) et simultanément on teste si <I>k</I><SUB><I>j</I></SUB> vaut 1 en prenant le reste de la
division par 2 de <CODE>k</CODE> (dans ce cas on multuplie <CODE>B</CODE> par
<CODE>A</CODE> modulo <I>n</I>), on divise ensuite <CODE>k</CODE> par 2 au sens du quotient
euclidien.
</P><PRE CLASS="verbatim">rapide(a,k,n):={
  local A,B;
  A:=a; B:=1;
  tantque k!=0 faire
    si irem(k,2)==1 alors B:=irem(A*B,n); fsi;
    k:=iquo(k,2);
    A:=irem(A*A,n);
  ftantque;
  return B;
}
</PRE><!--TOC subsection Pour en savoir plus.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc26">2.10</A>  Pour en savoir plus.</H3><!--SEC END --><P>
Sur des aspects plus théoriques :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Knuth: TAOCP (The Art of Computer Programming), volumes 1 et suivants
</LI><LI CLASS="li-itemize">Henri Cohen: A Course in Computational Algebraic Number Theory
</LI><LI CLASS="li-itemize">Davenport, Siret, Tournier: Calcul formel: Systèmes et algorithmes 
de manipulations algébriques
</LI></UL><P>Sur des aspects plus pratiques, quelques références en ligne, 
la plupart sont accessibles gratuitement :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
le code source de Giac disponible à l’URL :<BR>
<CODE>http://www-fourier.ujf-grenoble.fr/~parisse/giac.html</CODE>
</LI><LI CLASS="li-itemize">le code source de GiNaC, cf. :
<CODE>http://www.ginac.de</CODE>
</LI><LI CLASS="li-itemize">le site <CODE>http://www.hpcalc.org</CODE> pour les calculatrices HP,
on y trouve tout, de la documentation, des émulateurs de
calculatrices HP, des outils de développement pour Windows
et Unix/Linux, ... Pour ce qui concerne cet article, je conseille de lire<BR>
<CODE>http://www.hpcalc.org/hp48/docs/programming/rplman.zip</CODE>
</LI><LI CLASS="li-itemize">le site <CODE>http://www.ticalc.org</CODE>, on y trouve le portage
tigcc du compilateur C de GNU, des émulateurs, etc. Des informations de 
cet article ont leur source dans le guide du
développeur TI89/92<BR>
<CODE>http://education.ti.com/</CODE>
</LI><LI CLASS="li-itemize">la librairie du système <CODE>MuPAD</CODE> (archivée dans le fichier
<CODE>lib.tar</CODE> des distributions Unix, pour une installation
par défaut, ce fichier
se trouve dans le rérpertoire <CODE>/usr/local/MuPAD/share/lib</CODE>), 
cf. <CODE>www.sciface.com</CODE> pour obtenir une licence
d’utilisation.
</LI><LI CLASS="li-itemize">en Maple, il est possible de
décompiler une instruction <CODE>Maple</CODE> avec la commande<BR>
<CODE>eval(instruction);</CODE><BR>
après avoir tapé<BR>
<CODE>interface(verboseproc=2);</CODE>
</LI><LI CLASS="li-itemize">le source du plus ancien système de calcul formel <CODE>maxima</CODE>
(devenu logiciel libre) pour les personnes familières du langage Lisp<BR>
<CODE>http://sourceforge.net/projects/maxima</CODE><BR>
de même pour le système Axiom
</LI><LI CLASS="li-itemize">le source de librairies plus spécialisées (GMP, GP-PARI, Singular,
NTL, Zen, ALP, GAP, CoCoA, ...), rechercher ces moms sur google.
</LI></UL><!--TOC subsection Exercices sur types, calcul exact et approché, 
algorithmes de bases-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc27">2.11</A>  Exercices sur types, calcul exact et approché, 
algorithmes de bases</H3><!--SEC END --><P>
Pour télécharger et installer Xcas sur votre ordinateur, suivre
les instructions données sur<BR>
<CODE>http://www-fourier.ujf-grenoble.fr/~parisse/giac_fr.html</CODE><BR>
Pour lancer <TT>xcas</TT> sous linux, cherchez Xcas dans le menu
Education ou ouvrir un fenêtre terminal et
taper la commande<BR>
<CODE>  xcas &amp; </CODE><BR>
Lors de la première exécution, vous devrez choisir entre
différents types de syntaxe (compatible C, maple ou TI89). Vous
pouvez changer ce choix à tout moment en utilisant le menu
Configuration-&gt;mode (syntaxe).</P><P>L’aide en ligne est accessible en tapant <CODE>?nom_de_commande</CODE>.
Dans Xcas, vous pouvez aussi taper le début d’un
nom de commande puis la touche de tabulation (à gauche du A sur
un clavier francais), sélectionner la commande dans la boite
de dialogues puis cliquer sur Details pour avoir une aide plus
complète dans votre navigateur. Pour plus de détails sur
l’interface de Xcas, consultez le manuel (Aide-&gt;Interface).
Si vous n’avez jamais utilisé de logiciel de calcul formel,
vous pouvez commencer par lire le tutoriel (menu Aide-&gt;Debuter en
calcul formel-&gt;tutoriel) et faire certains des exercices 
proposés (des corrigés sous forme de sessions Xcas sont 
dans Aide-&gt;Debuter en calcul formel-&gt;solutions)</P><P>Il peut être interessant de tester ces exercices
en parallèle avec Xcas et des calculatrices
formelles....</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
À quelle vitesse votre logiciel multiplie-t-il des
grands entiers (en fonction du nombre de chiffres)? 
On pourra tester le temps de calcul du produit
de <I>a</I>(<I>a</I>+1) où <I>a</I>=10 000!, <I>a</I>=15000!, etc. .
Même question pour des polynômes en une variable (à générer
par exemple avec <CODE>symb2poly(randpoly(n))</CODE> ou avec <CODE>poly1[op(ranm(.))]</CODE>).</LI><LI CLASS="li-enumerate">Comparer le temps de calcul de <I>a</I><SUP><I>n</I></SUP> (mod <I>m</I> ) par la fonction
<CODE>powmod</CODE> et la méthode prendre le reste modulo <I>m</I> après avoir 
calculé <I>a</I><SUP><I>n</I></SUP>.<BR>
Programmez la méthode rapide et la méthode lente. Refaites la
comparaison. Pour la méthode rapide, programmer aussi la version
itérative utilisant la décomposition en base 2 de l’exposant :
on stocke dans une variable locale <I>b</I> les puissances successives
<I>a</I><SUP>2<SUP>0</SUP></SUP> (mod <I>m</I> ),<I>a</I><SUP>2<SUP>1</SUP></SUP> (mod <I>m</I> ), ..., <I>a</I><SUP>2<SUP><I>k</I></SUP></SUP> (mod <I>m</I> ), ...,
on forme <I>a</I><SUP><I>n</I></SUP> (mod <I>n</I> ) en prenant le produit modulo <I>m</I> de ces puissances
successives lorsque le bit correspondant est à 1 (ce qui se
détecte par le reste de divisions euclidiennes sucessives par 2, le
calcul de <I>b</I> et du bit correspondant se font dans une même boucle).</LI><LI CLASS="li-enumerate">Déterminer un entier <I>c</I> tel que <I>c</I>=1 (mod 3 ), 
<I>c</I>=3 (mod 5 ), <I>c</I>=5 (mod 7 ) et <I>c</I>=2 (mod 11 ).</LI><LI CLASS="li-enumerate">Calculez dans ℤ/11ℤ
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">10</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>x</I>−<I>a</I>)</TD></TR>
</TABLE></LI><LI CLASS="li-enumerate">Algorithmes fondementaux : écrire des programmes implémentant
<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
le pgcd de 2 entiers
</LI><LI CLASS="li-enumerate">l’algorithme de Bézout
</LI><LI CLASS="li-enumerate">l’inverse modulaire en ne calculant que ce qui est nécessaire
dans l’algorithme de Bézout
</LI><LI CLASS="li-enumerate">les restes chinois
</LI></OL></LI><LI CLASS="li-enumerate">Construire un corps fini de cardinal 128 (<CODE>GF</CODE>), puis factoriser
le polynôme <I>x</I><SUP>2</SUP>−<I>y</I> où <I>y</I> est un élément quelconque du corps
fini.
Comparer avec la valeur de √<SPAN style="text-decoration:overline"><I>y</I></SPAN>.</LI><LI CLASS="li-enumerate">Utiliser la commande <TT>type</TT> ou <TT>whattype</TT> ou équivalent
pour déterminer la représentation
utilisée par le logiciel pour représenter
une fraction, un nombre complexe, un flottant en précision machine, 
un flottant avec 100 décimales, la variable <I>x</I>, l’expression sin(<I>x</I>)+2,
la fonction <TT>x-&gt;sin(x)</TT>, une liste, une séquence, un vecteur,
une matrice. Essayez d’accéder aux parties de
l’objet pour les objets composites (en utilisant <TT>op</TT> par exemple).</LI><LI CLASS="li-enumerate">Comparer le type de l’objet <CODE>t</CODE> si on effectue
la commande <CODE>t[2]:=0;</CODE> après avoir purgé <CODE>t</CODE>
ou après avoir affecté <CODE>t:=[1,2,3]</CODE> ?</LI><LI CLASS="li-enumerate">Comparer l’effet de l’affectation dans une liste et dans un
vecteur ou une matrice sur votre logiciel (en Xcas, on peut utiliser
<CODE>=&lt;</CODE> au lieu de <CODE>:=</CODE> pour stocker par référence).</LI><LI CLASS="li-enumerate">Voici un programme qui calcule la base utilisée
pour représenter les flottants. 
<PRE CLASS="verbatim">Base():={
  local A,B;
  A:=1.0; B:=1.0;
  while (evalf(evalf(A+1.0)-A)-1.0=0.0) { A:=2*A;};
  while (evalf(evalf(A+B)-A)-B&lt;&gt;0) { B:=B+1;}
  return B;
} :;
</PRE>Testez-le et expliquez.</LI><LI CLASS="li-enumerate">Déterminer le plus grand réel positif <I>x</I> de la forme 
2<SUP>−<I>n</I></SUP> (<I>n</I> entier)
tel que (1.0+<I>x</I>)−1.0 renvoie 0 sur PC avec la précision par
défaut puis avec <CODE>Digits:=30</CODE>.</LI><LI CLASS="li-enumerate">Calculer la valeur de <I>a</I>:=exp(π √<SPAN style="text-decoration:overline">163</SPAN>) avec 30 chiffres
significatifs, puis sa partie fractionnaire. Proposez une commande
permettant de décider si <I>a</I> est un entier.</LI><LI CLASS="li-enumerate">Déterminer la valeur et le signe de la fraction rationnelle 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I>(<I>x</I>,<I>y</I>)= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1335</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>y</I><SUP>6</SUP> + <I>x</I><SUP>2</SUP> (11<I>x</I><SUP>2</SUP> <I>y</I><SUP>2</SUP>−<I>y</I><SUP>6</SUP> −121<I>y</I><SUP>4</SUP>−2) + 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">11</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>y</I><SUP>8</SUP> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>y</I></TD></TR>
</TABLE></TD></TR>
</TABLE>
en <I>x</I>=77617 et <I>y</I>=33096 en faisant deux calculs, l’un en mode approché et 
l’autre en mode exact. Que pensez-vous de ces résultats?
Combien de chiffres significatifs faut-il pour obtenir un résultat
raisonnable en mode approché?</LI><LI CLASS="li-enumerate">Que se passe-t-il si on essaie d’appliquer l’algorithme de la
puissance rapide pour calculer (<I>x</I>+<I>y</I>+<I>z</I>+1)<SUP><I>k</I></SUP> par exemple pour
<I>k</I>=64 ? 
Calculer le nombre
de termes dans le développement de (<I>x</I>+<I>y</I>+<I>z</I>+1)<SUP><I>n</I></SUP> et expliquez.</LI><LI CLASS="li-enumerate">Programmation de la <B>méthode de Horner</B><A NAME="@default42"></A><BR>
Il s’agit d’évaluer efficacement un polynôme 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>X</I>) = <I>a</I><SUB><I>n</I></SUB> <I>X</I><SUP><I>n</I></SUP> + ... + <I>a</I><SUB>0</SUB> </TD></TR>
</TABLE>
en un point.
On pose <I>b</I><SUB>0</SUB>=<I>P</I>(α ) et on écrit :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>X</I>)−<I>b</I><SUB>0</SUB>=(<I>X</I>−α )<I>Q</I>(<I>X</I>) </TD></TR>
</TABLE>
où :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Q</I>(<I>X</I>) = <I>b</I><SUB><I>n</I></SUB> <I>X</I><SUP><I>n</I>−1</SUP> + ... +<I>b</I><SUB>2</SUB> <I>X</I> + <I>b</I><SUB>1</SUB> </TD></TR>
</TABLE>
On calcule alors par ordre décroissant <I>b</I><SUB><I>n</I></SUB>, <I>b</I><SUB><I>n</I>−1</SUB>, ..., <I>b</I><SUB>0</SUB>.
<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
Donner <I>b</I><SUB><I>n</I></SUB> en fonction de <I>a</I><SUB><I>n</I></SUB> puis pour <I>i</I>≤ <I>n</I>−1, <I>b</I><SUB><I>i</I></SUB>
en fonction de <I>a</I><SUB><I>i</I></SUB> et <I>b</I><SUB><I>i</I>+1</SUB>. Indiquez le détail des calculs
pour <I>P</I>(<I>X</I>)=<I>X</I><SUP>3</SUP>−2<I>X</I>+5 et une valeur de α  non nulle.
</LI><LI CLASS="li-enumerate">Écrire un fonction <CODE>horn</CODE> effectuant ce calcul:
on donnera en arguments le polynôme sous forme de la
liste de ces coefficients (dans l’exemple <CODE>[1,0,-2,5]</CODE>) et la
valeur de α  et le programme renverra <I>P</I>(α ).
(On pourra aussi renvoyer les coefficients de <I>Q</I>).
</LI><LI CLASS="li-enumerate">En utilisant cette fonction, écrire une fonction qui calcule
le développement de Taylor complet d’un polynôme en un point.
</LI></OL></LI></OL><!--TOC section Le PGCD de polynômes.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc28">3</A>  Le PGCD de polynômes.</H2><!--SEC END --><P> <A NAME="sec:pgcd"></A> <A NAME="@default43"></A>
Comme on l’a remarqué dans le premier article, l’algorithme d’Euclide est
inefficace pour calculer le pgcd de deux polynômes à coefficients entiers. On
va présenter ici les algorithmes utilisés habituellement par les systèmes de
calcul formel: sous-résultant (PRS), modulaire (GCDMOD), <I>p</I>-adique (EEZGD) et
heuristique (GCDHEU). Le premier est une adaptation de l’algorithme d’Euclide
et s’adapte à des coefficients assez génériques. Les trois autres ont en
commun d’évaluer une ou plusieurs variables du polynôme (dans ce dernier cas
il est nécessaire de bien distinguer le cas de polynômes à plusieurs
variables) et de reconstruire le pgcd par des techniques distinctes, la
plupart du temps ces algorithmes fonctionnent seulement si les coefficients
sont entiers.</P><P>Soit donc  <I>P</I> et <I>Q</I> deux polynômes à coefficients dans un corps. Le
pgcd de <I>P</I> et <I>Q</I> n’est défini qu’à une constante près. Mais lorsque les
coefficients de <I>P</I> et <I>Q</I> sont dans un anneau euclidien comme par exemple
ℤ ou
ℤ[ <I>i</I> ], on appellera pgcd de <I>P</I> et <I>Q</I> un polynôme <I>D</I> tel
que <I>P</I> / <I>D</I> et <I>Q</I> / <I>D</I> soient encore à coefficients dans l’anneau, et que <I>D</I>
soit optimal, c’est-à-dire que si un multiple µ <I>D</I> de <I>D</I> vérifie <I>P</I> / µ
<I>D</I> et <I>Q</I> / µ <I>D</I> sont à coefficients dans l’anneau, alors µ est
inversible. </P><P>La première étape d’un algorithme de calcul de pgcd consiste donc
à diviser par son contenu (pgcd des coefficients entiers) chaque polynôme.</P><P><B>Exemple</B>: <I>P</I> = 4 <I>X</I><SUP>2</SUP> − 4 et <I>Q</I> = 6 <I>X</I><SUP>2</SUP> + 12 <I>X</I> + 6. Le polynôme
<I>X</I> + 1 est un pgcd de <I>P</I> et <I>Q</I> puisqu’il est de degré maximal divisant <I>P</I>
et <I>Q</I> mais le pgcd de <I>P</I> et <I>Q</I> est 2 ( <I>X</I> + 1 ). Remarquons qu’avec notre
définition − 2 ( <I>X</I> + 1 ) convient aussi. Par convention on appelera
pgcd dans ℤ[<I>X</I>] le
polynôme ayant un coefficient dominant positif.</P><P><B>Définition</B>: On appelle <B>contenu</B><A NAME="@default44"></A> <I>c</I> ( <I>P</I> ) d’un polynôme <I>P</I> le
pgcd des coefficients de <I>P</I>. On définit alors la 
<B>partie primitive</B><A NAME="@default45"></A> de <I>P</I>:
pp( <I>P</I> ) = <I>P</I> / <I>c</I> ( <I>P</I> ). Si <I>c</I>(<I>P</I>)=1, on dit que <I>P</I> est primitif.</P><P><B>Proposition </B>: Si <I>A</I> et <I>B</I> sont primitifs et si <I>B</I> divise <I>A</I>
dans ℚ[<I>X</I>] alors <I>A</I>/<I>B</I> ∈ ℤ[<I>X</I>].</P><P><B>Preuve </B>: Soit <I>Q</I>=<I>A</I>/<I>B</I> ∈ ℚ[<I>X</I>]. Soit <I>q</I> ∈ ℕ  le PPCM des
dénominateurs des coefficients de <I>Q</I> et notons <I>P</I>=<I>qQ</I> ∈ ℤ[<I>X</I>]. On a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I> <I>B</I> = <I>qQB</I>=<I>q</I> <I>A</I> </TD></TR>
</TABLE><P>
Si <I>q</I>=1 la proposition est démontrée. 
Sinon, considérons un facteur premier <I>p</I> de <I>q</I>, dans ℤ/<I>p</I>ℤ[<I>X</I>] on a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>PB</I> = 0 (mod <I>p</I> )</TD></TR>
</TABLE><P>
Comme <I>B</I> est primitif, <I>B</I>≠ 0 (mod <I>p</I> ) donc
<I>P</I>=0 (mod <I>p</I> ), donc <I>P</I>/<I>p</I>=<I>q</I>/<I>p</I> <I>Q</I> ∈ ℤ[<I>X</I>] ce qui est absurde car <I>q</I>
est le PPCM des dénominateurs de <I>Q</I>.</P><P>Donc le PGCD de <I>A</I> et <I>B</I>, polynômes primitifs de ℤ[<I>X</I>] est
obtenu en prenant un PGCD de <I>A</I> et <I>B</I> dans ℚ[<I>X</I>], en multipliant
par le PPCM des dénominateurs et en rendant le polynôme obtenu
primitif (on change le signe du résultat si nécessaire pour avoir
un coefficient dominant positif).</P><P>On en déduit que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>D</I> = pgcd ( <I>P</I>, <I>Q</I> ) = pgcd ( <I>c</I> ( <I>P</I> ), <I>c</I> ( <I>Q</I> )) pgcd (
pp ( <I>P</I> ), pp ( <I>Q</I> )) </TD></TR>
</TABLE><!--TOC subsection Le sous-résultant.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc29">3.1</A>  Le sous-résultant.</H3><!--SEC END --><P><A NAME="@default46"></A></P><P>La première idée qui vient à l’esprit pour améliorer l’efficacité de
l’algorithme d’Euclide consiste à éviter les fractions qui sont créées par les
divisions euclidiennes. On utilise à cet effet la pseudo-division: au lieu de
prendre le reste <I>R</I> de la division euclidienne du polynôme <I>P</I> par <I>Q</I>, on
prend le reste de la division de <I>P</I> <I>q</I><SUP>δ + 1</SUP> par <I>Q</I>, où <I>q</I> désigne le
coefficient dominant de <I>Q</I> et δ la différence entre le degré de <I>P</I> et
de <I>Q</I>.</P><P><B>Exercice:</B> En utilisant votre système de calcul formel préféré,
calculez les restes intermédiaires générés dans l’algorithme d’Euclide
lorsqu’on utilise la pseudo-division par exemple pour les polynômes <I>P</I> ( <I>x</I> ) =
( <I>x</I> + 1 )<SUP>7</SUP> − ( <I>x</I> − 1 )<SUP>6</SUP> et sa dérivée.</P><P><B>Une solution avec giac/xcas</B>:
</P><PRE CLASS="verbatim">// -*- mode:C++ -*- a,b 2 polynomes -&gt; pgcd de a et b
pgcd(a,b):={ 
 local P,p,Q,q,R,g,h,d;
 // convertit a et b en polynomes listes 
 // et extrait la partie primitive   
 P:=symb2poly1(a);
 p:=lgcd(P); // pgcd des elements de la liste
 P:=P/p; 
 Q:=symb2poly1(b);
 q:=lgcd(Q);
 Q:=Q/q; 
 if (size(P)&lt;size(Q)){ // echange P et Q
  R:=P; P:=Q; Q:=R; 
 } 
 // calcul du contenu du pgcd
 p:=gcd(p,q);
 g:=1;
 h:=1;
 while (size(Q)!=1){
  q:=Q[0]; // coefficient dominant
  d:=size(P)-size(Q);
  R:=rem(q^(d+1)*P,Q);
  if (size(R)==0) return(p*poly12symb(Q/lgcd(Q),x));
  P:=Q;
  Q:=R;
  // ligne suivante a decommenter pour prs 
  // Q:=R/(g*h^d);
  print(Q);
  // ligne suivante a decommenter pour prs 
  // g:=q; h:=q^d/h^(d-1);
 } 
 return(p);
}
</PRE><P>On s’aperçoit que les coefficients croissent de manière exponentielle. La
deuxième idée qui vient naturellement est alors à chaque étape de rendre le
reste primitif, donc de diviser <I>R</I> par le pgcd de ces coefficients. Cela
donne un algorithme plus efficace, mais encore assez peu efficace car à chaque
étape on doit calculer le pgcd de tous les coefficients, on peut imaginer le
temps que cela prendra en dimension 1 et à fortiori en dimension supérieure.
L’idéal serait de connaitre à l’avance une quantité suffisamment grande qui
divise tous les coefficients du reste.</P><P>C’est ici qu’intervient l’algorithme du sous-résultant: après chaque
pseudo-division euclidienne, on exhibe un coefficient "magique" qui divise les
coefficients du reste. Ce coefficient n’est pas le pgcd mais il est
suffisamment grand pour qu’on évite la croissance exponentielle des
coefficients.</P><P><B>Algorithme du sous-résultant</B></P><P>Arguments: 2 polynômes <I>P</I> et <I>Q</I> primitifs. Valeur de retour: le pgcd de <I>P</I>
et <I>Q</I>.</P><P>Pour calculer le coefficient "magique" on utilise 2 variables auxiliaires <I>g</I>
et <I>h</I> initialisées a 1.</P><P>Boucle à effectuer tant que <I>Q</I> est non nul:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
on note δ =degre(<I>P</I>)-degre(<I>Q</I>) et <I>q</I> le coefficient dominant
de <I>Q</I></LI><LI CLASS="li-itemize">on effectue la division euclidienne (sans fraction) de <I>q</I><SUP>δ + 1</SUP>
<I>P</I> par <I>Q</I>, soit <I>R</I> le reste</LI><LI CLASS="li-itemize">Si <I>R</I> est constant, on sort de l’algorithme en renvoyant 1 comme pgcd</LI><LI CLASS="li-itemize">on recopie <I>Q</I> dans <I>P</I> puis <I>R</I> / ( <I>g</I> <I>h</I><SUP>δ</SUP> ) dans <I>Q</I></LI><LI CLASS="li-itemize">on recopie <I>q</I> dans <I>g</I> et <I>h</I><SUP>1 − δ</SUP> <I>q</I><SUP>δ</SUP> dans <I>h</I>.
</LI></UL><P>
Si on sort normalement de la boucle, <I>Q</I> est nul, on renvoie donc la partie
primitive de <I>P</I> qui est le pgcd cherché.</P><P>Pour tester l’algorithme avec <TT>xcas</TT>, il suffit de décommenter les
deux lignes <TT>Q:=R/(g*h^d);</TT> et <TT>g:=q; h:=q^d/h
(d-1);</TT> ci-dessus.</P><P>La preuve de l’algorithme est un peu longue et par ailleurs bien expliquée
dans le 2ème tome de Knuth (The Art of Computer Programming, Semi-numerical
Algorithms), on y renvoie donc le lecteur intéressé. L’idée générale
(et l’origine du nom de l’algorithme) 
est de considérer la matrice de Sylvester des polynômes de
départ <I>P</I> et <I>Q</I> (celle dont le déterminant est appelé résultant de <I>P</I> et
<I>Q</I>) et de traduire les pseudo-divisions qui permettent de calculer les restes
successifs du sous-résultant en opération de ligne sur ces matrices. On
démontre alors que les coefficients de <I>R</I> divisés par <I>g</I> <I>h</I><SUP>δ</SUP> peuvent
être interprétés comme des déterminants de sous-matrices de la matrice de
Sylvester après réduction et c’est cela qui permet de conclure qu’ils sont
entiers.</P><P>Par exemple, supposons que <I>P</I>=<I>R</I><SUB>0</SUB>, <I>Q</I>=<I>R</I><SUB>1</SUB>, <I>R</I><SUB>2</SUB>... diminuent de 1 en degré
à chaque division 
(c’est le cas générique dans le déroulement de l’algorithme
d’Euclide). Dans ce cas, δ=1, il s’agit par exemple
de montrer que le reste <I>R</I><SUB>3</SUB> de <I>Q</I>=<I>R</I><SUB>1</SUB> par <I>R</I><SUB>2</SUB> est divisible par le
carré du coefficient dominant de <I>Q</I>=<I>R</I><SUB>1</SUB>.
Voyons comment on obtient les coefficients de <I>R</I><SUB>3</SUB>
à partir de la matrice de Sylvester de <I>P</I> et <I>Q</I>. 
Prenons la sous-matrice constituée des 2 premières lignes de <I>P</I>
et des 3 premières lignes de <I>Q</I> et réduisons-la sous forme
échelonnée sans introduire de dénominateur. 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>p</I><SUB><I>n</I></SUB></TD><TD ALIGN=center NOWRAP><I>p</I><SUB><I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>p</I><SUB><I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP><I>p</I><SUB><I>n</I>−3</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>p</I><SUB><I>n</I></SUB></TD><TD ALIGN=center NOWRAP><I>p</I><SUB><I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>p</I><SUB><I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−3</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−4</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−3</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP>...  </TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
On effectue <I>L</I><SUB>1</SUB> ← <I>q</I><SUB><I>n</I>−1</SUB> <I>L</I><SUB>1</SUB> − <I>p</I><SUB><I>n</I></SUB> <I>L</I><SUB>3</SUB>
et <I>L</I><SUB>2</SUB> ← <I>q</I><SUB><I>n</I>−1</SUB> <I>L</I><SUB>2</SUB> − <I>p</I><SUB><I>n</I></SUB> <I>L</I><SUB>4</SUB>, ce qui correspond à
l’élimination du terme en <I>x</I> du quotient de <I>P</I> par <I>Q</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−1</SUB> <I>p</I><SUB><I>n</I>−1</SUB> − <I>p</I><SUB><I>n</I></SUB> <I>q</I><SUB><I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−1</SUB> <I>p</I><SUB><I>n</I>−1</SUB> − <I>p</I><SUB><I>n</I></SUB> <I>q</I><SUB><I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−3</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−4</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−3</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP>...  </TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
on effectue ensuite 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>L</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP>←</TD><TD ALIGN=left NOWRAP><I>q</I><SUB><I>n</I>−1</SUB> <I>L</I><SUB>1</SUB> − (<I>q</I><SUB><I>n</I>−1</SUB> <I>p</I><SUB><I>n</I>−1</SUB> − <I>p</I><SUB><I>n</I></SUB> <I>q</I><SUB><I>n</I>−2</SUB>)  <I>L</I><SUB>4</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>L</I><SUB>2</SUB></TD><TD ALIGN=center NOWRAP>←</TD><TD ALIGN=left NOWRAP><I>q</I><SUB><I>n</I>−1</SUB> <I>L</I><SUB>2</SUB> − (<I>q</I><SUB><I>n</I>−1</SUB> <I>p</I><SUB><I>n</I>−1</SUB> − <I>p</I><SUB><I>n</I></SUB> <I>q</I><SUB><I>n</I>−2</SUB>)  <I>L</I><SUB>5</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P> 
ce qui correspond à l’élimination du terme constant du quotient
de <I>P</I> par <I>Q</I>, on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>r</I><SUB>2,<I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>r</I><SUB>2,<I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−3</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−4</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−3</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP>...  </TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
si on enlève les lignes 3 et 4, et les colonnes 1 et 2,
on obtient (après échanges
de lignes) une sous-matrice de la matrice de Sylvester de <I>Q</I> et <I>R</I><SUB>2</SUB>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> <I>q</I><SUB><I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP> <I>r</I><SUB>2,<I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP> 0</TD><TD ALIGN=center NOWRAP><I>r</I><SUB>2,<I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
On recommence les opérations de réduction de cette sous-matrice
correspondant à la division euclidienne de <I>Q</I> par <I>R</I><SUB>2</SUB>, on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>r</I><SUB>3,<I>n</I>−3</SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP> <I>r</I><SUB>2,<I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP> 0</TD><TD ALIGN=center NOWRAP><I>r</I><SUB>2,<I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
puis après suppression des colonnes 1 et 2 et des lignes 2 et 3
la ligne des coefficients de <I>R</I><SUB>3</SUB>.</P><P>Supposons qu’on se limite dès le début de la réduction à ne
garder que les colonnes 1 à 4 et une 5-ième colonne parmi
les suivantes, on obtient à la fin de la réduction
une matrice 1,1 qui contient
un des coefficients de <I>R</I><SUB>3</SUB> (selon le choix de la 5-ième colonne).
Donc ce coefficient est égal au déterminant de la matrice 1,1
qui est égal, au signe près, au déterminant de la matrice 3,3
dont il est issu par notre réduction (en effet, dans la 2ième
partie de la réduction,
on a multiplié deux fois <I>L</I><SUB>1</SUB> par <I>r</I><SUB>2,<I>n</I>−2</SUB>, mais on doit ensuite diviser 
le déterminant par <I>r</I><SUB>2,<I>n</I>−2</SUB><SUP>2</SUP> pour éliminer les colonnes 1 et 2).
Quant au déterminant de la matrice 3,3, il se déduit du
déterminant de la matrice 5,5 par multiplication par <I>q</I><SUB><I>n</I>−1</SUB><SUP>4</SUP>
(2 lignes ont été multipliées 2 fois par <I>q</I><SUB><I>n</I>−1</SUB>) et division
par <I>q</I><SUB><I>n</I>−1</SUB><SUP>2</SUP> (élimination des colonnes 1 et 2). Au final,
tout coefficient de <I>R</I><SUB>3</SUB> est égal au produit d’un déterminant
5,5 extrait de la matrice de Sylvester de <I>P</I> et <I>Q</I> par <I>q</I><SUB><I>n</I>−1</SUB><SUP>2</SUP>,
qui est justement le coefficient “magique” par lequel on divise le reste
de <I>R</I><SUB>1</SUB>=<I>Q</I> par <I>R</I><SUB>2</SUB> lors de l’algorithme du sous-résultant.</P><!--TOC subsection Le pgcd en une variable.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc30">3.2</A>  Le pgcd en une variable.</H3><!--SEC END --><!--TOC subsubsection Le pgcd heuristique.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc31">3.2.1</A>  Le pgcd heuristique.</H4><!--SEC END --><P><A NAME="@default47"></A></P><P>On suppose ici que les coefficients sont entiers ou entiers de Gauss.
<B>On peut donc se ramener au cas où les polynômes sont primitifs.</B></P><P>L’idée consiste à évaluer <I>P</I> et <I>Q</I> en un entier <I>z</I> et à extraire des
informations du pgcd <I>g</I> des entiers <I>P</I> ( <I>z</I> ) et <I>Q</I> ( <I>z</I> ). Il faut donc un
moyen de remonter de l’entier <I>g</I> à un polynôme <I>G</I> tel que <I>G</I> ( <I>z</I> ) = <I>g</I>. La
méthode consiste à écrire en base <I>z</I> l’entier <I>g</I>, avec une particularité
dans les divisions euclidiennes successives on utilise le reste symétrique
(compris entre − <I>z</I> / 2 et <I>z</I> / 2). Cette écriture donne les coefficients
d’un polynôme <I>G</I> unique. On extrait ensuite la partie primitive de ce
polynôme <I>G</I>. Lorsque <I>z</I> est assez grand par rapport aux coefficients des
polynômes <I>P</I> et <I>Q</I>, si pp ( <I>G</I> ) divise <I>P</I> et <I>Q</I>, on va montrer
que le pgcd de <I>P</I> et de <I>Q</I> est <I>D</I> = pp ( <I>G</I> ).</P><P>On remarque tout d’abord que <I>d</I> : = <I>D</I> ( <I>z</I> ) divise <I>g</I>. En effet <I>D</I> divise
<I>P</I> et <I>Q</I> donc pour tout entier (ou entier de Gauss) <I>z</I>, <I>D</I> ( <I>z</I> ) divise <I>P</I>
( <I>z</I> ) et <I>Q</I> ( <I>z</I> ). Il existe donc une constante <I>a</I> telle que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>g</I> = <I>a</I> <I>d</I> </TD></TR>
</TABLE><P>
On a aussi pp ( <I>G</I> ) divise <I>D</I>. Il existe donc un polynôme <I>C</I> tel
que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>D</I> = pp ( <I>G</I> ) <I>C</I> </TD></TR>
</TABLE><P>
Nous devons prouver que <I>C</I> est un polynôme constant. On suppose dans la suite
que ce n’est pas le cas. Evaluons l’égalité précédente au point <I>z</I>, on
obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>d</I> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>g</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>c</I> ( <I>G</I> )</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>C</I> ( <I>z</I> ) </TD></TR>
</TABLE><P>
Finalement
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">1 = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>c</I> ( <I>G</I> )</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>C</I> ( <I>z</I> ) </TD></TR>
</TABLE><P>
La procédure de construction de <I>G</I> nous donne une majoration de ces
coefficients par | <I>z</I> | / 2, donc de <I>c</I> ( <I>G</I> ) par | <I>z</I> | / 2, donc <I>C</I> ( <I>z</I>
) divise un entier de module plus petit que | <I>z</I> | / 2, donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>C</I> ( <I>z</I> ) | ⩽ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">| <I>z</I> |</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
On considère maintenant les racines complexes <I>z</I><SUB>1</SUB>, … ., <I>z</I><SUB><I>n</I></SUB> du polynôme
<I>C</I> (il en existe au moins une puisqu’on a supposé <I>C</I> non constant). On a:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>C</I> ( <I>X</I> ) = <I>c</I><SUB><I>n</I></SUB> ( <I>X</I> − <I>z</I><SUB>1</SUB> ) … . ( <I>X</I> − <I>z</I><SUB><I>n</I></SUB> ) </TD></TR>
</TABLE><P>
Donc, comme <I>c</I><SUB><I>n</I></SUB> est un entier (ou entier de Gauss) non nul, sa norme est
supérieure ou égale à 1 et :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>C</I> ( <I>z</I> ) | ⩾ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> = 1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ( | <I>z</I> | − | <I>z</I><SUB><I>j</I></SUB> | ) </TD></TR>
</TABLE><P>
Il nous reste à majorer les racines de <I>C</I> pour minorer | <I>C</I> ( <I>z</I> ) |. Comme
<I>C</I> divise <I>D</I> il divise <I>P</I> et <I>Q</I> donc les racines de <I>C</I> sont des racines
communes à <I>P</I> et <I>Q</I>. On va appliquer le:</P><DIV CLASS="theorem"><B>Lemme 4</B>  <EM> </EM><A NAME="lemme:majoration"></A><EM>
Soit x une racine complexe d’un polynôme </EM><EM><I>P</I> = <I>a</I></EM><SUB><EM><I>n</I></EM></SUB><EM> <I>X</I></EM><SUP><EM><I>n</I></EM></SUP><EM> + … . + <I>a</I></EM><SUB><EM>0</EM></SUB><EM>.</EM><P><EM>Alors 
</EM></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>| <I>x</I> | &lt; </EM><EM>| <I>P</I> |/| <I>a</I></EM><SUB><EM><I>n</I></EM></SUB><EM> |</EM><EM> + 1, | <I>P</I> | = </EM><EM>max</EM><SUB><EM>0 ⩽ <I>i</I>
⩽ <I>n</I></EM></SUB><EM> ( | <I>a</I></EM><SUB><EM><I>i</I></EM></SUB><EM> | )</EM><EM> </EM></TD></TR>
</TABLE></DIV><P>Application du lemme à <I>C</I>(<I>X</I>) : on a 1/|<I>c</I><SUB><I>n</I></SUB>|≤ 1
donc si on a choisi <I>z</I> tel que | <I>z</I> | ⩾ 2 min( | <I>P</I> |, | <I>Q</I> | ) + 2,
alors pour tout <I>j</I>, | <I>z</I><SUB><I>j</I></SUB> | &lt; | <I>z</I> | / 2 donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>C</I> ( <I>z</I> ) | &gt; </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">| <I>z</I> |</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
qui contredit notre majoration de | <I>C</I> ( <I>z</I> ) |.</P><DIV CLASS="theorem"><B>Théorème 5</B>  <EM>
Soit </EM><EM><I>P</I></EM><EM> et Q deux polynômes à coefficients entiers. On
choisit un entier z tel que </EM><EM>| <I>z</I> | ⩾ 2 </EM><EM>min</EM><EM>( | <I>P</I> |, | <I>Q</I> | ) + 2</EM><EM>,
si la partie primitive du polynôme </EM><EM><I>G</I></EM><EM> reconstruit à partir du pgcd de </EM><EM><I>P</I> (
<I>z</I> ) </EM><EM>et</EM><EM>Q(z) par écriture en base </EM><EM><I>z</I></EM><EM> (avec comme reste euclidien le
reste symétrique) divise </EM><EM><I>P</I></EM><EM> et </EM><EM><I>Q</I></EM><EM> alors c’est le pgcd de </EM><EM><I>P</I></EM><EM> et </EM><EM><I>Q</I></EM><EM>.
</EM></DIV><P>Pour finir la démonstration du théorème, il nous faut encore montrer le lemme.
On a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">− <I>a</I><SUB><I>n</I></SUB> <I>x</I><SUP><I>n</I></SUP> = <I>a</I><SUB><I>n</I> − 1</SUB> <I>x</I><SUP><I>n</I> − 1</SUP> + … . + <I>a</I><SUB>0</SUB> </TD></TR>
</TABLE><P>
Donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>a</I><SUB><I>n</I></SUB> | | <I>x</I> |<SUP><I>n</I></SUP> ⩽ | <I>P</I> | ( 1 + … . + | <I>x</I> |<SUP><I>n</I> − 1</SUP> ) = | <I>P</I> |
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">| <I>x</I> |<SUP><I>n</I></SUP> − 1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">| <I>x</I> | − 1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
Ici on peut supposer que | <I>x</I> | ⩾ 1, sinon le lemme est démontré,
donc | <I>x</I> | − 1 est positif et
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>a</I><SUB><I>n</I></SUB> | ( | <I>x</I> | − 1 ) ⩽ | <I>P</I> | </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">| <I>x</I> |<SUP><I>n</I></SUP> − 1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">| <I>x</I> |<SUP><I>n</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
⇒ | <I>x</I> | − 1 &lt; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">| <I>P</I> |</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">| <I>a</I><SUB><I>n</I></SUB> |</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
Remarques
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Le théorème publié par Char, Geddes et Gonnet 
porte sur des coefficients entiers et
c’est comme cela qu’il est utilisé par les systèmes de calcul formel (en
commençant historiquement par Maple). Peu de systèmes l’utilisent pour les
polynômes à coefficients entiers de Gauss. On peut d’ailleurs généraliser le
théorème à d’autres types de coefficients, à condition d’avoir un anneau
euclidien plongé dans ℂ avec une minoration sur la valeur absolue
des élements non nuls de l’anneau.</LI><LI CLASS="li-itemize">Nous n’avons jusqu’à présent aucune certitude qu’il existe des entiers
<I>z</I> tels que la partie primitive de <I>G</I> divise <I>P</I> et <I>Q</I>. Nous allons
montrer en utilisant l’identité de Bézout que pour <I>z</I> assez grand c’est
toujours le cas. Plus précisément, on sait qu’il existe deux polynômes <I>U</I>
et <I>V</I> tels que
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I> <I>U</I> + <I>Q</I> <I>V</I> = <I>D</I> </TD></TR>
</TABLE>
Attention toutefois, <I>U</I> et <I>V</I> sont à coefficients rationnels, pour avoir
des coefficients entiers, on doit multiplier par une constante entière
α, donc en évaluant en <I>z</I> on obtient l’existence d’une égalité à
coefficients entiers
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I> ( <I>z</I> ) <I>u</I> + <I>Q</I> ( <I>z</I> ) <I>v</I> = α <I>D</I> ( <I>z</I> ) </TD></TR>
</TABLE><P>Donc le pgcd <I>g</I> de <I>P</I> ( <I>z</I> ) et <I>Q</I> ( <I>z</I> ) divise α <I>D</I> ( <I>z</I> ) = α
<I>d</I>. Comme <I>g</I> est un multiple de <I>d</I>, on en déduit que <I>g</I> = β <I>d</I>, où
β est un diviseur de α. Si on a choisi <I>z</I> tel que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>z</I> | &gt;  2 | <I>D</I> | | α | </TD></TR>
</TABLE><P>
alors | <I>z</I> | &gt; 2 | <I>D</I> | | β | donc l’écriture symétrique en base <I>z</I> de
<I>g</I> est <I>G</I> = β <I>D</I>. Donc la partie primitive de <I>G</I> est <I>D</I>, le
pgcd de <I>P</I> et <I>Q</I>.</P></LI></UL><DIV CLASS="theorem"><B>Exemple 6</B>  <EM>
Si </EM><EM><I>P</I></EM><SUB><EM>0</EM></SUB><EM> = 6 ( <I>X</I></EM><SUP><EM>2</EM></SUP><EM> − 1 )</EM><EM> et </EM><EM><I>Q</I></EM><SUB><EM>0</EM></SUB><EM> = 4 ( <I>X</I></EM><SUP><EM>3</EM></SUP><EM> − 1 )</EM><EM>.</EM><P><EM>Le contenu de </EM><EM><I>P</I></EM><SUB><EM>0</EM></SUB><EM> est 6, celui de </EM><EM><I>Q</I></EM><SUB><EM>0</EM></SUB><EM> est 4.<BR>
 On a donc pgcd des contenus = 2, </EM><EM><I>P</I> = <I>X</I></EM><SUP><EM>2</EM></SUP><EM> − 1, <I>Q</I> = <I>X</I></EM><SUP><EM>3</EM></SUP><EM> − 1</EM><EM>. La valeur
initiale de </EM><EM><I>z</I></EM><EM> est donc </EM><EM>2 ∗ 1 + 2 = 4</EM><EM>. On trouve </EM><EM><I>P</I> ( 4 ) = 15, <I>Q</I> ( 4
) = 63</EM><EM>. Le pgcd entier de 15 et 63 est 3 que nous écrivons symétriquement
en base 4 sous la forme </EM><EM>3 = 1 ∗ 4 − 1</EM><EM>, donc </EM><EM><I>G</I> = <I>X</I> − 1</EM><EM>, sa partie
primitive est </EM><EM><I>X</I> − 1</EM><EM>. On teste si </EM><EM><I>X</I> − 1</EM><EM> divise </EM><EM><I>P</I></EM><EM> et </EM><EM><I>Q</I></EM><EM>, c’est le cas,
donc c’est le pgcd de </EM><EM><I>P</I></EM><EM> et </EM><EM><I>Q</I></EM><EM> et le pgcd de </EM><EM><I>P</I></EM><SUB><EM>0</EM></SUB><EM> et </EM><EM><I>Q</I></EM><SUB><EM>0</EM></SUB><EM> est </EM><EM>2 ( <I>X</I> − 1
)</EM><EM>.
</EM></P></DIV><P><B>Algorithme gcdheu</B><BR>
En arguments deux polynômes <I>P</I><SUB>0</SUB> et <I>Q</I><SUB>0</SUB> à coefficients entiers ou entiers
de Gauss. Retourne le pgcd de 
<I>P</I><SUB>0</SUB> et <I>Q</I><SUB>0</SUB> ou faux en cas d’échec.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Calculer le contenu de <I>P</I><SUB>0</SUB> et <I>Q</I><SUB>0</SUB>. Vérifier que les coefficients
sont entiers de Gauss sinon retourner faux.</LI><LI CLASS="li-enumerate">Extraire la partie primitive <I>P</I> de <I>P</I><SUB>0</SUB> et <I>Q</I> de <I>Q</I><SUB>0</SUB>, calculer le
pgcd <I>c</I> des contenus de <I>P</I><SUB>0</SUB> et <I>Q</I><SUB>0</SUB></LI><LI CLASS="li-enumerate">Déterminer <I>z</I> = 2 min( | <I>P</I> |, | <I>Q</I> | ) + 2.</LI><LI CLASS="li-enumerate">Début de boucle: initialisation du nombre d’essais à 1, test d’arrêt
sur un nombre maximal d’essais, avec changement de <I>z</I> entre deux itérations
(par exemple <I>z</I> ← 2 <I>z</I>).</LI><LI CLASS="li-enumerate">Calculer le pgcd <I>g</I> de <I>P</I> ( <I>z</I> ) et <I>Q</I> ( <I>z</I> ) puis son écriture
symétrique en base <I>z</I> dont on extrait la partie primitive <I>G</I>.</LI><LI CLASS="li-enumerate">Si <I>G</I> ne divise pas<I>P</I> passer à l’itération
suivante. De même pour <I>Q</I>.</LI><LI CLASS="li-enumerate">Retourner <I>c</I> <I>G</I></LI><LI CLASS="li-enumerate">Fin de la boucle</LI><LI CLASS="li-enumerate">Retourner faux.
</LI></OL><P>
On remarque au passage qu’on a calculé le quotient de <I>P</I> par <I>G</I> et le
quotient de <I>Q</I> par <I>G</I> lorsque la procédure réussit. On peut donc passer à la
procédure gcdheu deux paramètres supplémentaires par référence, les deux
polynômes que l’on affectera en cas de succès, ce qui optimise la
simplification d’une fraction de 2 polynômes.</P><!--TOC subsubsection Le pgcd modulaire-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc32">3.2.2</A>  Le pgcd modulaire</H4><!--SEC END --><P><A NAME="@default48"></A></P><P>On part du fait que si <I>D</I> est le pgcd de <I>P</I> et <I>Q</I> dans ℤ (ou
ℤ [ <I>i</I> ] ) alors après réduction modulo un nombre premier <I>n</I> qui ne
divise pas les coefficients dominants de <I>P</I> et <I>Q</I>, <I>D</I> divise le pgcd <I>G</I> de
<I>P</I> et <I>Q</I> dans ℤ / <I>n</I> ℤ (par convention, le pgcd dans
ℤ / <I>n</I> ℤ est normalisé pour que son coefficient dominant
vaille 1). Comme on calcule <I>G</I> dans ℤ / <I>n</I> ℤ, les
coefficients des restes intermédiaires de l’algorithme d’Euclide sont bornés,
on évite ainsi la croissance exponentielle des coefficients. Il faudra ensuite
reconstruire <I>D</I> à partir de <I>G</I>.</P><P>On remarque d’abord que si on trouve <I>G</I> = 1, alors <I>P</I> et <I>Q</I> sont premiers
entre eux. En général, on peut seulement dire que le degré de <I>G</I> est
supérieur ou égal au degré de <I>D</I>. En fait, le degré de <I>G</I> est égal au degré
de <I>D</I> lorsque les restes de l’algorithme d’Euclide (calculé en effectuant des
pseudo-divisions, cf. l’exercice 1) ont leur coefficient dominant non
divisible par <I>n</I>. Donc plus <I>n</I> est grand, plus la probabilité est grande de
trouver <I>G</I> du bon degré.</P><P>Dans la suite, nous allons déterminer une borne <I>b</I> à priori majorant 
les coefficients de
<I>D</I>. On utilisera ensuite la même méthode que dans l’algorithme modulaire de
recherche de racines évidentes: on multiplie <I>G</I> dans ℤ / <I>n</I>
ℤ par le pgcd dans ℤ des coefficients dominants <I>p</I> et
<I>q</I> de <I>P</I> et <I>Q</I>. Soit D = pgcd ( <I>p</I>, <I>q</I> ) <I>G</I> le résultat écrit
en représentation symétrique. Si <I>n</I> ⩾ <I>b</I> pgcd ( <I>p</I>, <I>q</I> ) et si
<I>G</I> est du bon degré, on montre de la même manière que <I>D</I> = D. Comme 
on ne connait pas le degré de <I>D</I>, on est obligé de tester si D 
divise <I>P</I>
et <I>Q</I>. Si c’est le cas, alors D divise <I>D</I> donc D = <I>D</I>
puisque degre ( D ) = degre ( <I>G</I> ) ⩾
degre ( <I>D</I> ). Sinon, <I>n</I> est un nombre premier malchanceux pour ce
calcul de pgcd (degre ( <I>G</I> ) ⩾ degre ( <I>D</I> )), il faut
essayer un autre premier.</P><P><B>Remarque:</B> On serait tenté de dire que les coefficients de <I>D</I>
sont bornés par le plus grand coefficient de <I>P</I>. C’est malheureusement faux,
par exemple ( <I>X</I> + 1 )<SUP>2</SUP> dont le plus grand coefficient est 2 divise ( <I>X</I> + 1
)<SUP>2</SUP> ( <I>X</I> − 1 ) dont le plus grand coefficient (en valeur absolue) est 1.</P><P>Soit <I>P</I> = ∑<I>p</I><SUB><I>i</I></SUB> <I>X</I><SUP><I>i</I></SUP> un polynôme à coefficients entiers. On utilise la
norme euclidienne
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
| <I>P</I> |<SUP>2</SUP> = <FONT SIZE=6>∑</FONT>| <I>p</I><SUB><I>i</I></SUB> |<SUP>2</SUP>
    (5)</TD></TR>
</TABLE><P>
On établit d’abord une majoration du produit des racines de norme supérieure à
1 de <I>P</I> à l’aide de | <I>P</I> |. Ensuite si <I>D</I> est un diviseur de <I>P</I>, le
coefficient dominant <I>d</I> de <I>D</I> divise le coefficient dominant <I>p</I> de <I>P</I> et 
les racines de <I>D</I> sont aussi des racines de <I>P</I>. On pourra donc déterminer une
majoration des polynômes symétriques des racines de <I>D</I> et donc des
coefficients de <I>D</I>.</P><DIV CLASS="theorem"><B>Lemme 7</B>  <EM> </EM><A NAME="lemme:A"></A><EM>
Soit </EM><EM><I>A</I> = ∑</EM><SUB><EM><I>j</I> = 0</EM></SUB><SUP><EM><I>a</I></EM></SUP><EM> <I>a</I></EM><SUB><EM><I>j</I></EM></SUB><EM> <I>X</I></EM><SUP><EM><I>j</I></EM></SUP><EM> un polynôme et </EM><EM>α ∈ ℂ</EM><EM>.
Alors
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>| ( <I>X</I> − α ) <I>A</I> | = | ( </EM><EM><SPAN style="text-decoration:overline">α</SPAN></EM><EM> <I>X</I> − 1 ) <I>A</I> |</EM><EM> </EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>Pour prouver le lemme <A HREF="#lemme:A">7</A>, on développe les produits de polynômes. 
On pose <I>a</I><SUB>−1</SUB> = <I>a</I><SUB><I>a</I> + 1</SUB> = 0 et on note ℜ la partie réelle.
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| ( <I>X</I> − α ) <I>A</I> |<SUP>2</SUP> = ∑<SUB><I>j</I> = 0</SUB><SUP><I>a</I> + 1</SUP> | <I>a</I><SUB><I>j</I> − 1</SUB> − α
<I>a</I><SUB><I>j</I></SUB> |<SUP>2</SUP> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I> + 1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> = 0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> | <I>a</I><SUB><I>j</I> − 1</SUB> |<SUP>2</SUP> + | α |<SUP>2</SUP> | <I>a</I><SUB><I>j</I></SUB> |<SUP>2</SUP> − 2
ℜ ( <I>a</I><SUB><I>j</I> − 1</SUB> </TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>α  <I>a</I><SUB><I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ) </TD></TR>
</TABLE><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| ( <SPAN style="text-decoration:overline">α</SPAN> <I>X</I> − 1 ) <I>A</I> |<SUP>2</SUP> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I> + 1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> = 0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> | 
</TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUB><I>j</I> − 1</SUB>
− <I>a</I><SUB><I>j</I></SUB> |<SUP>2</SUP> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I> + 1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> = 0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> | α |<SUP>2</SUP> | <I>a</I><SUB><I>j</I> − 1</SUB> |<SUP>2</SUP> + | <I>a</I><SUB><I>j</I></SUB> |<SUP>2</SUP> −
2 ℜ ( </TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>α</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>a</I><SUB><I>j</I> − 1</SUB>   </TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>a</I><SUB><I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ) </TD></TR>
</TABLE><P>
Les deux donnent bien le même résultat.</P><P>Soit <I>P</I> ( <I>X</I> ) = <I>p</I> ∏( <I>X</I> − α<SUB><I>j</I></SUB> ) la factorisation de <I>P</I> sur
ℂ. On introduit le polynôme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">P = <I>p</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> / | α<SUB><I>j</I></SUB> | ⩾ 1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ( <I>X</I> − α<SUB><I>j</I></SUB> )
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> / | α<SUB><I>j</I></SUB> | &lt; 1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (  </TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>α<SUB><I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>X</I> − 1 ) </TD></TR>
</TABLE><P>
qui d’après le lemme a la même norme que <I>P</I>. La norme de <I>P</I> majore donc le
coefficient constant de P  d’où:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
<A NAME="mignotte"></A>  ∏<SUB><I>j</I> / | α<SUB><I>j</I></SUB> | ⩾ 1</SUB> | α<SUB><I>j</I></SUB> |
⩽ | <I>P</I> |/| <I>p</I> |
    (6)</TD></TR>
</TABLE><P>
On remarque que (<A HREF="#mignotte">6</A>) reste vraie si on considère les
racines δ<SUB><I>j</I></SUB> de norme plus grande que 1 d’un diviseur <I>D</I> de <I>P</I> puisque
le produit porte alors sur un sous-ensemble. On écrit maintenant l’expression
des coefficients <I>d</I><SUB><I>j</I></SUB> de <I>D</I> à l’aide des racines δ<SUB><I>j</I></SUB> de <I>D</I>:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>d</I><SUB><I>m</I> − <I>j</I></SUB> | = | <I>d</I> | </TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">choix de <I>j</I> racines
parmi les <I>m</I> racines de <I>D</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">     </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">δ<SUB><I>k</I></SUB> ∈
racines choisies</TD></TR>
</TABLE></TD><TD CLASS="dcell"> δ<SUB><I>k</I></SUB> </TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD></TR>
</TABLE><P>
Pour majorer | <I>d</I><SUB><I>m</I> − <I>j</I></SUB> |, on commence par majorer | δ<SUB><I>k</I></SUB> | par
β<SUB><I>k</I></SUB> = max( 1, | δ<SUB><I>k</I></SUB> | ). On est donc ramené à majorer
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">σ<SUB><I>j</I>, <I>m</I></SUB> ( β ) = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">choix de <I>j</I> parmi <I>m</I>
valeurs β<SUB><I>k</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">    </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">β<SUB><I>k</I></SUB> ∈ choix</TD></TR>
</TABLE></TD><TD CLASS="dcell"> β<SUB><I>k</I></SUB>  </TD></TR>
</TABLE><P>
avec pour hypothèse une majoration de <I>M</I> = ∏<SUB><I>k</I> = 1</SUB><SUP><I>m</I></SUP> β<SUB><I>k</I></SUB> donnée par
la relation (<A HREF="#mignotte">6</A>). Pour cela, on cherche le maximum de σ<SUB><I>j</I>,
<I>m</I></SUB> ( β ) sous les contraintes <I>M</I> fixé et β<SUB><I>k</I></SUB> ⩾ 1.</P><P>On va montrer que le maximum ne peut être atteint que si l’un des β<SUB><I>k</I></SUB> =
<I>M</I> (et tous les autres β<SUB><I>k</I></SUB> = 1 ). Sinon, quitte à réordonner supposons
que les β<SUB><I>k</I></SUB> sont classés par ordre croissant. On a donc β<SUB><I>m</I> − 1</SUB>
≠ 1, on pose β<SUB><I>k</I></SUB> = β<SUB><I>k</I></SUB> pour <I>k</I> ⩽ <I>m</I> − 2,
β<SUB><I>m</I> − 1</SUB> = 1 et β<SUB><I>m</I></SUB> = β<SUB><I>m</I> − 1</SUB> β<SUB><I>m</I></SUB>.
Comparons σ<SUB><I>j</I>, <I>m</I></SUB> ( β ) et σ<SUB><I>j</I>, nm</SUB> ( β
). Si le choix de <I>j</I> parmi <I>m</I> comporte <I>k</I> = <I>m</I> − 1 et <I>k</I> = <I>m</I>, le produit
est inchangé. Sinon on a la somme de deux produits, l’un contenant <I>k</I> = <I>m</I> − 1
et l’autre <I>k</I> = <I>m</I>. On compare donc <I>B</I> ( β<SUB><I>m</I> − 1</SUB> + β<SUB><I>m</I></SUB> ) et <I>B</I> ( 1
+ β<SUB><I>m</I> − 1</SUB> β<SUB><I>m</I></SUB> ) avec <I>B</I> = ∏<SUB>β<SUB><I>k</I></SUB> ∈ reste du
choix</SUB> β<SUB><I>k</I></SUB>. Comme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">1 + β<SUB><I>m</I> − 1</SUB> β<SUB><I>m</I></SUB> ⩾ β<SUB><I>m</I> − 1</SUB> + β<SUB><I>m</I></SUB> </TD></TR>
</TABLE><P>
puisque la différence est le produit (1−β<SUB><I>m</I></SUB>)(1−β<SUB><I>m</I>−1</SUB>) de deux
nombres positifs, on arrive à la contradiction souhaitée.</P><P>Ensuite on décompose les choix de σ<SUB><I>m</I>, <I>j</I></SUB> en ceux contenant <I>M</I> et
des 1 et ceux ne contenant que des 1, d’où la majoration
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">σ<SUB><I>j</I>, <I>m</I></SUB> ( β ) ⩽ </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>     <I>m</I> − 1</TD></TR>
<TR><TD ALIGN=center NOWRAP>     <I>j</I> − 1</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><I>M</I> + </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>     <I>m</I> − 1</TD></TR>
<TR><TD ALIGN=center NOWRAP>     <I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
et finalement
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
| <I>d</I><SUB><I>m</I> − <I>j</I></SUB> | ⩽ | <I>d</I> | </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>    <I>m</I> − 1</TD></TR>
<TR><TD ALIGN=center NOWRAP>    <I>j</I> − 1</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">| <I>P</I> |</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">| <I>p</I> |</TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>    <I>m</I> − 1</TD></TR>
<TR><TD ALIGN=center NOWRAP>    <I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><A NAME="pgcdd"></A>
    (7)</TD></TR>
</TABLE><P>
On peut en déduire une majoration indépendante de <I>j</I> sur les coefficients de
<I>D</I>, en majorant | <I>d</I> | par | <I>p</I> | (puisque <I>d</I> divise <I>p</I>) et les
coefficients binomiaux par 2<SUP><I>m</I> − 1</SUP> (obtenue en développant ( 1 + 1 )<SUP><I>m</I> −
1</SUP>). D’où le</P><DIV CLASS="theorem"><B>Théorème 8</B>  <A NAME="@default49"></A><EM> </EM><A NAME="@default50"></A><EM>
(</EM><EM><B>Landau-Mignotte</B></EM><EM>) 
Soit </EM><EM><I>P</I></EM><EM> un polynôme à coefficients entiers (ou entiers de
Gauss) et </EM><EM><I>D</I></EM><EM> un diviseur de </EM><EM><I>P</I></EM><EM> de degré </EM><EM><I>m</I></EM><EM>. Si </EM><EM>| <I>P</I> |</EM><EM> désigne la norme
euclidienne du vecteur des coefficients de </EM><EM><I>P</I></EM><EM> et </EM><EM><I>p</I></EM><EM> le coefficient
dominant de </EM><EM><I>P</I></EM><EM> alors les coefficients </EM><EM><I>d</I></EM><SUB><EM><I>j</I></EM></SUB><EM> de </EM><EM><I>D</I></EM><EM> satisfont l’inégalité
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>
| <I>d</I></EM><SUB><EM><I>j</I></EM></SUB><EM> | ⩽ 2</EM><SUP><EM><I>m</I> − 1</EM></SUP><EM> ( | <I>P</I> | + | <I>p</I> | )
    (8)</EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>Avec cette estimation, on en déduit que si <I>n</I> est un premier plus grand que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
min( 2<SUP>degre ( <I>P</I> ) − 1</SUP> ( | <I>P</I> | + | <I>p</I> | ),
2<SUP>degre ( <I>Q</I> ) − 1</SUP> ( | <I>Q</I> | + | <I>q</I> | ) ), <A NAME="pgcdbound"></A>
    (9)</TD></TR>
</TABLE><P>
alors le pgcd trouvé dans ℤ / <I>n</I> ℤ va se reconstruire en un
pgcd dans ℤ si son degré est le bon.</P><P>Malheureusement la borne précédente est souvent très grande par rapport aux
coefficients du pgcd et calculer dans ℤ / <I>n</I> ℤ s’avèrera
encore inefficace (surtout si le pgcd est 1). Cela reste vrai même si on
optimise un peu la majoration (<A HREF="#pgcdbound">9</A>) en repartant de (<A HREF="#pgcdd">7</A>).</P><P>L’idée est donc de travailler modulo plusieurs nombres premiers plus petits et
reconstruire le pgcd des 2 polynômes à coefficients entiers à partir des pgcd
des polynômes dans ℤ / <I>n</I> ℤ et du
théorème des restes chinois. En pratique on prend des nombres premiers
inférieurs à la racine carrée du plus grand entier hardware de la machine
(donc plus petits que 2<SUP>16</SUP> sur une machine 32 bits) ce qui permet 
d’utiliser l’arithmétique hardware du processeur sans risque de débordement.</P><P><B>Algorithme du PGCD modulaire en 1 variable:</B></P><P>En argument: 2 polynômes primitifs <I>P</I> et <I>Q</I> à coefficients entiers. Le
résultat renvoyé sera le polynôme pgcd.</P><P>Variable auxiliaire: un entier <I>N</I> initialisé à 1 qui représente le produit
des nombres premiers utilisés jusqu’ici et un polynôme <I>H</I> initialisé à 0 qui
représente le pgcd dans ℤ / <I>N</I> ℤ.</P><P>Boucle infinie :
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Chercher un nouveau nombre premier <I>n</I> qui ne divise pas les
coefficients dominants <I>p</I> et <I>q</I> de <I>P</I> et <I>Q</I></LI><LI CLASS="li-enumerate">Calculer le pgcd <I>G</I> de <I>P</I> et <I>Q</I> dans ℤ / <I>n</I> ℤ.
Si <I>G</I>=1, renvoyer 1.</LI><LI CLASS="li-enumerate">Si <I>H</I> = 0 ou si le degré de <I>G</I> est plus petit que le degré
de <I>H</I>, recopier <I>G</I> dans <I>H</I> et <I>n</I> dans <I>N</I>, passer à la 6ème étape</LI><LI CLASS="li-enumerate">Si le degré de <I>G</I> est plus grand que celui de <I>H</I> passer à
l’itération suivante</LI><LI CLASS="li-enumerate">Si le degré de <I>G</I> est égal au degré de <I>H</I>, 
en utilisant le théorème des restes chinois, calculer un polynôme
H tel que H = <I>H</I> modulo <I>N</I> et H = <I>G</I> modulo
<I>n</I>. Recopier H dans <I>H</I> et <I>n</I> <I>N</I> dans <I>N</I>.</LI><LI CLASS="li-enumerate">Ecrire pgcd ( <I>p</I>, <I>q</I> ) <I>H</I> en représentation symétrique. Soit
H le résultat rendu primitif. Tester si H divise <I>P</I> et
<I>Q</I>. Si c’est le cas, renvoyer H, sinon passer à l’itération
suivante.
</LI></OL><P>
Finalement on n’a pas utilisé <I>b</I>, la borne de Landau-Mignotte. 
On peut penser que l’étape
6 ne devrait être effectuée que lorsque <I>N</I> est plus grand que pgcd (
<I>p</I>, <I>q</I> ) <I>b</I>. En pratique, on effectue le test de l’étape 6 plus tôt parce que
les coefficients du pgcd sont rarement aussi grand que <I>b</I>. Mais pour éviter
de faire le test trop tôt, on introduit une variable auxiliaire <I>H</I>′ qui
contient la valeur de <I>H</I> de l’itération précédente et on ne fait le test que
si <I>H</I>′ = <I>H</I> (ou bien sûr si on a dépassé la borne).</P><P><B>Remarque</B>:</P><P>L’algorithme ci-dessus fonctionne également pour des polynômes à plusieurs
variables.</P><P><B>Exemple 1:</B></P><P>Calcul du pgcd de ( <I>X</I> + 1 )<SUP>3</SUP> ( <I>X</I> − 1 )<SUP>4</SUP> et ( <I>X</I><SUP>4</SUP> − 1 ). Prenons pour
commencer <I>n</I> = 2. On trouve comme pgcd <I>X</I><SUP>4</SUP> + 1 (en effet − 1 = 1 donc on
cherchait le pgcd de ( <I>X</I> + 1 )<SUP>7</SUP> et de <I>X</I><SUP>4</SUP> + 1 = ( <I>X</I> + 1 )<SUP>4</SUP>). On teste si
<I>X</I><SUP>4</SUP> + 1 divise <I>P</I> et <I>Q</I>, ce n’est pas le cas donc on passe au nombre
premier suivant. Pour <I>n</I> = 3, on trouve <I>X</I><SUP>2</SUP> − 1. Donc <I>n</I> = 2 n’était pas un
bon nombre premier pour ce calcul de pgcd puisqu’on a trouvé un pgcd de degré
plus petit. On teste si <I>X</I><SUP>2</SUP> − 1 divise <I>P</I> et <I>Q</I>, c’est le cas ici donc on
peut arrêter, le pgcd cherché est <I>X</I><SUP>2</SUP>−1.</P><P><B>Exemple</B><B> 2 :</B></P><P>Calcul du pgcd de ( <I>X</I> + 1 )<SUP>3</SUP> ( <I>X</I> − 1 )<SUP>4</SUP> et ( <I>X</I><SUP>4</SUP> − 1 )<SUP>3</SUP>. 
Pour <I>n</I> = 2, on trouve un polynôme de degré 7.
Pour <I>n</I> = 3, on trouve <I>X</I><SUP>6</SUP> − 1 donc <I>n</I> = 2 était une mauvaise réduction.
Comme <I>X</I><SUP>6</SUP> − 1 ne divise pas <I>P</I> et <I>Q</I>, on passe à <I>n</I> = 5. On trouve <I>X</I><SUP>6</SUP> +
2 <I>X</I><SUP>4</SUP> − 2 <I>X</I><SUP>2</SUP> − 1. On applique le théorème des restes chinois qui va nous
donner un polynôme dans ℤ / 15 ℤ. On cherche donc un
entier congru à 2 modulo 5 et à 0 modulo 3, -3 est la solution (écrite en
représentation symétrique), donc le polynôme modulo 15 est <I>X</I><SUP>6</SUP> − 3 <I>X</I><SUP>4</SUP> + 3
<I>X</I><SUP>2</SUP> − 1 = ( <I>X</I><SUP>2</SUP> − 1 )<SUP>3</SUP>. Ce polynôme divise <I>P</I> et <I>Q</I>, c’est donc le pgcd de
<I>P</I> et de <I>Q</I>.</P><!--TOC subsection Le pgcd à plusieurs variables.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc33">3.3</A>  Le pgcd à plusieurs variables.</H3><!--SEC END --><!--TOC subsubsection Le pgcd heuristique.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc34">3.3.1</A>  Le pgcd heuristique.</H4><!--SEC END --><P><A NAME="@default51"></A></P><P>On suppose comme dans le cas à une variable que les polynômes sont primitifs,
donc qu’on a simplifié les polynômes par le pgcd entier de leurs coefficients
entiers.</P><P>Le principe est identique à celui du PGCD à 1 variable, on évalue les deux
polynômes <I>P</I> et <I>Q</I> de <I>k</I> variables <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>k</I></SUB> en un <I>X</I><SUB><I>k</I></SUB> = <I>z</I> et
on calcule le pgcd <I>g</I> des 2 polynômes <I>P</I> ( <I>z</I> ) et <I>Q</I> ( <I>z</I> ) de <I>k</I> − 1
variables. On remonte ensuite à un polynôme <I>G</I> par écriture symétrique en
base <I>z</I> de <I>g</I> et on teste si pp ( <I>G</I> ) divise <I>P</I> et <I>Q</I>. Il s’agit
à nouveau de montrer que si <I>z</I> est assez grand, alors pp ( <I>G</I> ) est
le pgcd cherché. On sait que <I>d</I> = <I>D</I> ( <I>z</I> ) divise <I>g</I>. Il existe donc un
polynôme <I>a</I> de <I>k</I> − 1 variables tel que <I>g</I> = <I>a</I> <I>d</I>. On sait aussi que
pp ( <I>G</I> ) divise <I>D</I>, donc il existe un polynôme <I>C</I> de <I>k</I> variables
tel que <I>D</I> = <I>C</I> ∗ pp ( <I>G</I> ) . On évalue en <I>z</I> et on obtient <I>d</I> = <I>C</I> (
<I>z</I> ) <I>g</I> / <I>c</I> ( <I>G</I> ), où <I>c</I> ( <I>G</I> ) est un entier, donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>c</I> ( <I>G</I> ) = <I>a</I> ∗ <I>C</I> ( <I>z</I> ) </TD></TR>
</TABLE><P>
Comme <I>c</I> ( <I>G</I> ) est un entier, <I>a</I> et <I>C</I> ( <I>z</I> ) sont des polynômes constants.
Comme précédemment, on a aussi | <I>C</I> ( <I>z</I> ) | ⩽ | <I>z</I> | / 2 puisque | <I>c</I>
( <I>G</I> ) | ⩽ | <I>z</I> | / 2.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Premier cas: si <I>C</I> ne dépend que de la variable <I>X</I><SUB><I>k</I></SUB>. On continue le
raisonnement comme dans le cas unidimensionnel.</LI><LI CLASS="li-itemize">Deuxième cas: si <I>C</I> dépend d’une autre variable, par exemple <I>X</I><SUB>1</SUB>.
On regarde le coefficient de plus haut degre de <I>C</I> par rapport a <I>X</I><SUB>1</SUB>. Ce
coefficient divise le coefficient de plus haut degre de <I>P</I> et de <I>Q</I> par
rapport a <I>X</I><SUB>1</SUB>. Comme <I>C</I> ( <I>z</I> ) est constant, on en deduit que le
coefficient de plus haut degre de <I>P</I> et <I>Q</I> par rapport a <I>X</I><SUB>1</SUB> est
divisible par <I>X</I><SUB><I>k</I></SUB> − <I>z</I> donc le coefficient de plus bas degre en <I>X</I><SUB><I>k</I></SUB> de
ces coefficients de plus haut degre est divisible par <I>z</I>, ce qui contredit
la majoration de ce coefficient.
</LI></UL><P>En pratique, cet algorithme nécessite le calcul récursif de pgcd sans
garantie de réussite. On l’évite donc s’il y a beaucoup de variables (la
limite est par exemple de 5 pour MuPAD).</P><!--TOC subsubsection Le pgcd modulaire multivariables.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc35">3.3.2</A>  Le pgcd modulaire multivariables.</H4><!--SEC END --><P><A NAME="@default52"></A></P><P>Ici, on travaille modulo <I>X</I><SUB><I>n</I></SUB> − α, où <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I></SUB> désignent
les variables des polynômes. On considère donc deux polynômes <I>P</I> et <I>Q</I> comme
polynômes de la variables <I>X</I><SUB><I>n</I></SUB> avec des coefficients dans ℤ [ <I>X</I><SUB>1</SUB>,
… ., <I>X</I><SUB><I>n</I> − 1</SUB> ]. On évalue en <I>X</I><SUB><I>n</I></SUB> = α, on obtient deux polynômes
en <I>n</I> − 1 variables dont on calcule le pgcd (récursivement).</P><P>Il s’agit de reconstruire le pgcd par interpolation. Tout d’abord, on a une 
borne évidente sur le degré du pgcd par rapport à la variable <I>X</I><SUB><I>n</I></SUB>, c’est le
minimum δ des degrés par rapport à <I>X</I><SUB><I>n</I></SUB> des polynômes <I>P</I> et <I>Q</I>. A
première vue, il suffit donc d’évaluer les polynômes
en δ + 1 points α.</P><P>Il faut toutefois prendre garde aux mauvaises évaluations et à la
normalisation des pgcd avant d’interpoler. En effet, si <I>D</I> ( <I>X</I><SUB>1</SUB>, … .,
<I>X</I><SUB><I>n</I></SUB> ) désigne le pgcd de <I>P</I> et <I>Q</I> et <I>G</I> ( <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB> ) le
pgcd de <I>P</I> ( <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB>, α ) et de <I>Q</I> ( <I>X</I><SUB>1</SUB>, … .,
<I>X</I><SUB><I>n</I> − 1</SUB>, α ), 
on peut seulement dire <I>D</I> ( <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB>, α )
divise <I>G</I>. Plusieurs cas sont donc possibles lorsqu’on évalue en un nouveau
point α:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
l’un des degrés de <I>G</I> est plus petit que le degré du polynôme <I>D</I>′
reconstruit par interpolation jusque là. Dans ce cas, toutes les évaluations
qui ont conduit à reconstruire <I>D</I>′ étaient mauvaises. Il faut recommencer
l’interpolation à zéro ou à partir de <I>G</I> (si tous les degrés de <I>G</I> sont
inférieurs ou égaux aux degrés du <I>D</I>′ reconstruit).</LI><LI CLASS="li-itemize">l’un des degrés de <I>G</I> est plus grand que le degré du <I>D</I>′ reconstruit
jusque là. Il faut alors ignorer α.</LI><LI CLASS="li-itemize">Tous les degrés de <I>G</I> sont égaux aux degrés du <I>D</I>′ reconstruit
jusque là. Dans ce cas, <I>G</I> est un multiple entier du polynôme <I>D</I>′
reconstruit jusque là et évalué en <I>X</I><SUB><I>n</I></SUB> = α. Si on suppose qu’on a pu
s’arranger pour que ce multiple soit 1, on ajoute le point α aux
points d’évaluation précédents α<SUB><I>j</I></SUB> en posant:
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>D</I>′ = <I>D</I>′ + ( <I>G</I> − <I>D</I>′ ) </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">α<SUB><I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ( <I>X</I><SUB><I>n</I></SUB> − α<SUB><I>j</I></SUB>
)</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">α<SUB><I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ( α − α<SUB><I>j</I></SUB> )</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE>
</LI></UL><P>
On voit que les mauvaises évaluations se détectent simplement par les degrés.
Pour la normalisation, on utilise une petite astuce: au lieu de reconstruire
le pgcd <I>D</I>, on va reconstruire un multiple du pgcd <I>D</I> (ce
multiple appartiendra à ℤ [ <I>X</I><SUB><I>n</I></SUB> ] ). On voit maintenant <I>P</I> et <I>Q</I>
comme des polynômes en <I>n</I> − 1 variables <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB> à
coefficients dans ℤ [ <I>X</I><SUB><I>n</I></SUB> ]. Alors lcoeff(<I>D</I>), 
le coefficient dominant de <I>D</I>
(relativement à l’ordre lexicographique sur les variables <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB>),
est un polynôme en <I>X</I><SUB><I>n</I></SUB> qui divise le coefficient dominant de <I>P</I> et de <I>Q</I>
donc divise le coefficient dominant du pgcd des coefficients dominants de <I>P</I>
et de <I>Q</I>. On va donc reconstruire le polynôme :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>D</I>′ = <I>D</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">Δ ( <I>X</I><SUB><I>n</I></SUB> )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">lcoeff ( <I>D</I> ) ( <I>X</I><SUB><I>n</I></SUB> )</TD></TR>
</TABLE></TD><TD CLASS="dcell">, Δ ( <I>X</I><SUB><I>n</I></SUB> ) =
pgcd ( lcoeff ( <I>P</I> ) ( <I>X</I><SUB><I>n</I></SUB> ), lcoeff ( <I>Q</I> ) ( <I>X</I><SUB><I>n</I></SUB> )) </TD></TR>
</TABLE><P>
c’est-à-dire <I>D</I> multiplié par un polynôme qui ne dépend que de <I>X</I><SUB><I>n</I></SUB>.</P><P>Revenons à <I>G</I> en un point α de bonne évaluation. C’est un multiple
entier de <I>D</I> ( <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB>, α ):
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>G</I> = β <I>D</I> ( <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB>, α ) </TD></TR>
</TABLE><P>
Donc, comme polynômes de <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB> à coefficients dans 
ℤ[<I>X</I><SUB><I>n</I></SUB>] ou dans ℤ,
lcoeff ( <I>G</I> ) = β lcoeff ( <I>D</I> )<SUB>| <I>X</I><SUB><I>n</I></SUB> = α</SUB>. Comme
lcoeff ( <I>D</I> ) divise Δ ( <I>X</I><SUB><I>n</I></SUB> ), il en est de même en <I>X</I><SUB><I>n</I></SUB> =
α donc lcoeff(<I>G</I>) divise β Δ(α). 
On en déduit que  Δ ( α) <I>G</I> qui 
est divisible par  Δ (α) β est
divisible par lcoeff ( <I>G</I> ). On va donc considérer le polynôme
 Δ (α) <I>G</I> / lcoeff ( <I>G</I> ) :
ses coefficients sont entiers et son coefficient dominant est 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">Δ ( α) = lcoeff(<I>D</I>′( <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB>, α ))</TD></TR>
</TABLE><P>
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">Δ (α) <I>G</I>  / lcoeff ( <I>G</I> )=
<I>D</I>′( <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB>, α )</TD></TR>
</TABLE><P><B>Algorithme du pgcd modulaire à plusieurs variables (interpolation
dense)</B>:</P><P>Arguments: 2 polynômes primitifs <I>P</I> et <I>Q</I> de <I>n</I> variables <I>X</I><SUB>1</SUB>, … .,
<I>X</I><SUB><I>n</I></SUB> à coefficients entiers. Renvoie le pgcd de <I>P</I> et <I>Q</I>.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Si <I>n</I> = 1, renvoyer le pgcd de <I>P</I> et <I>Q</I> en une variable.</LI><LI CLASS="li-enumerate">Test rapide de pgcd trivial par rapport à <I>X</I><SUB><I>n</I></SUB>. On cherche des <I>n</I> −
1-uplets α tels que <I>P</I> ( α, <I>X</I><SUB><I>n</I></SUB> ) et <I>Q</I> ( α, <I>X</I><SUB><I>n</I></SUB> )
soient de même degré que <I>P</I> et <I>Q</I> par rapport à la variable <I>X</I><SUB><I>n</I></SUB>. On
calcule le pgcd <I>G</I> de ces 2 polynômes en une variable. Si le pgcd est
constant, alors on retourne le pgcd des coefficients de <I>P</I> et <I>Q</I>.</LI><LI CLASS="li-enumerate">On divise <I>P</I> et <I>Q</I> par leur contenu respectifs vu comme polynômes en
<I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB> à coefficients dans ℤ [ <I>X</I><SUB><I>n</I></SUB> ], on note
<I>C</I> ( <I>X</I><SUB><I>n</I></SUB> ) le pgcd des contenus. On calcule aussi le pgcd Δ ( <I>X</I><SUB><I>n</I></SUB> )
des coefficients dominants de <I>P</I> et de <I>Q</I>.</LI><LI CLASS="li-enumerate">On initialise <I>D</I>′ le pgcd reconstruit à 0, <I>I</I> ( <I>X</I><SUB><I>n</I></SUB> ) le polynôme
d’interpolation à 1, δ=(δ<SUB>1</SUB>,...,δ<SUB><I>n</I>−1</SUB>) 
la liste des degrés partiels du pgcd par
rapport à <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB> au minimum des degrés partiels de <I>P</I>
et <I>Q</I> par rapport à <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB>, <I>e</I> le nombre d’évaluation
à 0 et <I>E</I> l’ensemble des points d’interpolation à la liste vide.</LI><LI CLASS="li-enumerate">Boucle infinie:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Faire α=entier aléatoire n’appartenant pas à <I>E</I> jusqu’à ce
que
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>      degre(<I>P</I> ( <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB>, α
))=degre<SUB><I>X</I><SUB><I>n</I></SUB></SUB> ( <I>P</I> ( <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I></SUB> )</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>      degre ( <I>Q</I> ( <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB>, α )) =
degre<SUB><I>X</I><SUB><I>n</I></SUB></SUB> ( <I>Q</I> ( <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I></SUB> ))</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>    </TD></TR>
</TABLE></TD></TR>
</TABLE>
</LI><LI CLASS="li-itemize">Calculer le pgcd <I>G</I> ( <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB> ) en <I>n</I> − 1
variables de <I>P</I> ( <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB>, α ) et <I>Q</I> ( <I>X</I><SUB>1</SUB>, …
., <I>X</I><SUB><I>n</I> − 1</SUB>, α ).</LI><LI CLASS="li-itemize">Si degre ( <I>G</I> )<SUB><I>i</I></SUB> &lt; δ<SUB><I>i</I></SUB> pour un indice au moins.
Si degre ( <I>G</I> ) ⩽ δ, on pose δ =
degre ( <I>G</I> ), <I>D</I>′ = <I>G</I> Δ ( α )/lcoeff ( <I>G</I>
), <I>I</I> = <I>X</I><SUB><I>n</I></SUB> − α, <I>e</I> = 1 et <I>E</I> = [ α ], sinon on pose δ
= min( δ, degre ( <I>G</I> )), <I>D</I>′ = 0, <I>I</I> = 1, <I>e</I> = 0, <I>E</I> = [ ].
On passe à l’itération suivante.</LI><LI CLASS="li-itemize">Si degre ( <I>G</I> ) &gt; δ, on passe à l’itération suivante.</LI><LI CLASS="li-itemize">Si degre ( <I>G</I> ) = δ, on interpole:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<I>G</I> := <I>G</I> Δ ( α )/lcoeff ( <I>G</I> )</LI><LI CLASS="li-itemize"><I>D</I>′ := <I>D</I>′ + <I>I</I> ( <I>X</I><SUB><I>n</I></SUB> )/∏<SUB>α<SUB><I>j</I></SUB> ∈ <I>E</I></SUB> ( α −
α<SUB><I>j</I></SUB> ) ( <I>G</I> − <I>D</I>′ ( <I>X</I><SUB>1</SUB>, … ., <I>X</I><SUB><I>n</I> − 1</SUB>, α ))</LI><LI CLASS="li-itemize"><I>I</I> := <I>I</I> ∗ ( <I>X</I><SUB><I>n</I></SUB> − α )</LI><LI CLASS="li-itemize"><I>e</I> := <I>e</I> + 1 et ajouter α à <I>E</I></LI><LI CLASS="li-itemize">Si <I>e</I> est strictement plus grand que le minimum des degrés
partiels de <I>P</I> et <I>Q</I> par rapport à <I>X</I><SUB><I>n</I></SUB>, on pose D la
partie primitive de <I>D</I>′ (vu comme polynôme à coefficients dans
ℤ [ <I>X</I><SUB><I>n</I></SUB> ]), on teste si <I>P</I> et <I>Q</I> sont divisibles par
D, si c’est le cas, on renvoie <I>D</I> = <I>C</I> ( <I>X</I><SUB><I>n</I></SUB> ) D
</LI></UL>
</LI></UL>
</LI></OL><P>
On observe que dans cet algorithme, on fait le test de divisibilite de
D par <I>P</I> et <I>Q</I>. En effet, même après avoir évalué en suffisamment
de points, rien n’indique que tous ces points sont des points de bonne
évaluation. En pratique cela reste extrêmement improbable. En pratique, on
teste la divisibilité plus tôt, dès que <I>D</I>′ n’est pas modifié par l’ajout
d’un nouveau point à la liste des α<SUB><I>j</I></SUB>.</P><P>Il existe une variation de cet algorithme, appelé SPMOD (sparse modular), qui
suppose que seuls les coefficients non nuls du pgcd en <I>n</I> − 1 variables sont
encore non nuls en <I>n</I> variables (ce qui a de fortes chances d’être le cas).
L’étape d’interpolation est alors remplacée par la résolution d’un
sous-système d’un système de Vandermonde. Cette variation est intéressante si
le nombre de coefficients non nuls en <I>n</I> − 1 variables est petit devant le
degré. Si elle échoue, on revient à l’interpolation dense.</P><P>Notons enfin qu’on peut appliquer cette méthode lorsque les coefficients de
<I>P</I> et <I>Q</I> sont dans ℤ / <I>n</I> ℤ mais il faut alors vérifier
qu’on dispose de suffisamment de points d’interpolation. Ce qui en combinant
avec l’algorithme modulaire à une variable donne un algorithme doublement
modulaire pour calculer le pgcd de 2 polynômes à coefficients entiers. C’est
cette méthode qu’utilise par exemple MuPAD (en essayant d’abord SPMOD puis
l’interpolation dense).</P><P><B>Exemple:</B></P><P>Dans cet exemple, on donne <I>F</I> et <I>G</I> sous forme factorisée, le but étant de
faire comprendre l’algorithme. En utilisation normale, on n’exécuterait cet
algorithme que si <I>F</I> et <I>G</I> étaient développés.</P><P><I>P</I> = (( <I>x</I> + 1 ) <I>y</I> + <I>x</I><SUP>2</SUP> + 1 ) ( <I>y</I><SUP>2</SUP> + <I>x</I> <I>y</I> + 1 ), <I>Q</I> = (( <I>x</I> + 1 ) <I>y</I> +
<I>x</I><SUP>2</SUP> + 1 ) ( <I>y</I><SUP>2</SUP> − <I>x</I> <I>y</I> − 1 ).</P><P>Prenons <I>x</I> comme variable <I>X</I><SUB>1</SUB> et <I>y</I> comme variable <I>X</I><SUB>2</SUB>. Les coefficients
dominants de <I>P</I> et <I>Q</I> sont respectivement <I>y</I> et − <I>y</I> donc Δ = <I>y</I>.</P><P>En <I>y</I> = 0, <I>P</I> ( <I>x</I>, 0 ) = <I>x</I><SUP>2</SUP> + 1 n’est pas du bon degré.</P><P>En <I>y</I> = 1, <I>P</I> ( <I>x</I>, 1 ) = ( <I>x</I> + <I>x</I><SUP>2</SUP> + 2 ) ( <I>x</I> + 2 ) et <I>Q</I> ( <I>x</I>, 1 ) = ( <I>x</I> +
<I>x</I><SUP>2</SUP> + 2 ) ( − <I>x</I> ) sont du bon degré. Leur pgcd est <I>G</I> = <I>x</I><SUP>2</SUP> + <I>x</I> + 2, Δ
( 1 ) = 1, donc <I>D</I>′ = <I>x</I><SUP>2</SUP> + <I>x</I> + 1. On teste la divisibilité de <I>P</I> par <I>D</I>′,
le teste échoue.</P><P>En <I>y</I> = 2, <I>P</I> ( <I>x</I>, 2 ) = ( <I>x</I><SUP>2</SUP> + 2 <I>x</I> + 3 ) ( 2 <I>x</I> + 5 ) et <I>Q</I> ( <I>x</I>, 2 ) = (
<I>x</I><SUP>2</SUP> + 2 <I>x</I> + 3 ) ( − 2 <I>x</I> + 3 ) donc <I>G</I> = <I>x</I><SUP>2</SUP> + 2 <I>x</I> + 3, Δ ( 2 ) = 2.
On interpole:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>D</I>′ = <I>x</I><SUP>2</SUP> + <I>x</I> + 2 + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I> − 1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2 − 1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ( 2 ( <I>x</I><SUP>2</SUP> + 2 <I>x</I> + 3 ) − ( <I>x</I><SUP>2</SUP> + <I>x</I> +
2 )) = <I>y</I> ( <I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4 ) − ( 2 <I>x</I> + 2 ) </TD></TR>
</TABLE><P>
On teste la divisibilité de <I>P</I> par <I>D</I>′, le test échoue.</P><P>En <I>y</I> = 3, <I>P</I> ( <I>x</I>, 3 ) = ( <I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4 ) ( 3 <I>x</I> + 10 ) et <I>Q</I> ( <I>x</I>, 3 ) = (
<I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4 ) ( − 3 <I>x</I> + 8 ) donc <I>G</I> = <I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4, Δ ( 3 ) = 3.
On interpole:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>  <I>D</I>′</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>y</I> ( <I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4 ) − ( 2 <I>x</I> + 2 ) + </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">( <I>y</I> − 2 ) ( <I>y</I> − 1 )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">( 3 − 2
) ( 3 − 1 )</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎝</TD><TD CLASS="dcell">3 ( <I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4 ) − ( 3 ( <I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4 ) − ( 2 <I>x</I> + 2
)) </TD><TD CLASS="dcell">⎞<BR>
⎠</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>D</I>′ = <I>y</I> ( <I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4 ) − ( 2 <I>x</I> + 2 ) + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">( <I>y</I> − 2 ) ( <I>y</I> − 1 )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ( −
2 <I>x</I> − 2 ) = <I>x</I><SUP>2</SUP> <I>y</I> + <I>x</I> <I>y</I><SUP>2</SUP> + <I>y</I><SUP>2</SUP> + <I>y</I> </TD></TR>
</TABLE><P>
On divise <I>D</I>′ par son contenu et on trouve <I>x</I><SUP>2</SUP> + <I>x</I> <I>y</I> + <I>y</I> + 1 qui est bien
le pgcd de <I>P</I> et <I>Q</I>.</P><!--TOC subsubsection EZGCD.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc36">3.3.3</A>  EZGCD.</H4><!--SEC END --><P>Il s’agit d’une méthode <I>p</I>-adique. On évalue toutes les variables sauf une,
on calcule le pgcd en une variable et on remonte au pgcd variable par variable
(EEZGCD) ou toutes les variables simultanément (EZGCD) par un lemme de Hensel.
Il semble qu’il est plus efficace de remonter les variables séparément.</P><P>Soit donc <I>F</I> et <I>G</I> deux polynômes primitifs dépendant des variables <I>X</I><SUB>1</SUB>,
…, <I>X</I><SUB><I>n</I></SUB> de pgcd <I>D</I>, on fixe une des variables qu’on appelera <I>X</I><SUB>1</SUB> dans
la suite. Soient lcoeff ( <I>F</I> ) et lcoeff ( <I>G</I> ) les
coefficients dominants de <I>F</I> et <I>G</I> par rapport à <I>X</I><SUB>1</SUB>. On évalue <I>F</I> et <I>G</I>
en un <I>n</I> − 1 uplet <I>b</I> tel que le degré de <I>F</I> et <I>G</I> par rapport à <I>X</I><SUB>1</SUB>
soit conservé après evaluation en <I>b</I>. On suppose que <I>D</I><SUB><I>b</I></SUB> ( <I>X</I><SUB>1</SUB> ) =
pgcd ( <I>F</I> ( <I>b</I> ), <I>G</I> ( <I>b</I> )) a le même degré que <I>D</I> ( <I>b</I> ). On a donc
l’égalité:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">( <I>F</I> ∗ lcoeff ( <I>F</I> )) ( <I>b</I> ) = </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><I>D</I><SUB><I>b</I></SUB>  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">lcoeff ( <I>F</I> (
<I>b</I> ))</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">lcoeff ( <I>D</I><SUB><I>b</I></SUB> )</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">∗ </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>F</I> ( <I>b</I> )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUB><I>b</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">lcoeff ( <I>F</I> ) ( <I>b</I> )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">lcoeff ( </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>F</I> ( <I>b</I> )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUB><I>b</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> )</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
et de même en remplaçant <I>F</I> par <I>G</I>.</P><P>Pour pouvoir lifter cette égalité (c’est-à-dire généraliser à plusieurs 
variables), il faut que <I>D</I><SUB><I>b</I></SUB> et <I>F</I> ( <I>b</I> )/<I>D</I><SUB><I>b</I></SUB>
soient premiers entre eux. Sinon, on peut essayer de lifter l’égalité analogue
avec <I>G</I>. En général, on montre qu’il existe un entier <I>j</I> tel que <I>D</I><SUB><I>b</I></SUB> et
<I>F</I> ( <I>b</I> ) + <I>j</I> <I>G</I> ( <I>b</I> )/<I>D</I><SUB><I>b</I></SUB> soient premiers entre eux. En effet, sinon
au moins un des facteurs irréductibles de <I>D</I><SUB><I>b</I></SUB> va diviser <I>F</I> ( <I>b</I> ) + <I>j</I>
<I>G</I> ( <I>b</I> )/<I>D</I><SUB><I>b</I></SUB> pour deux valeurs distinctes de <I>j</I> et va donc diviser à la
fois <I>F</I> ( <I>b</I> )/<I>D</I><SUB><I>b</I></SUB> et <I>G</I> ( <I>b</I> )/<I>D</I><SUB><I>b</I></SUB> en contradiction avec la
définition de <I>D</I><SUB><I>b</I></SUB> = pgcd ( <I>F</I> ( <I>b</I> ), <I>G</I> ( <I>b</I> )). On lifte alors
l’égalité obtenue en remplaçant <I>F</I> par ( <I>F</I> + <I>k</I> <I>G</I> ) ci-dessus. Dans la
suite, on suppose qu’on peut prendre <I>j</I> = 0 pour alléger les notations.</P><P>On va aussi supposer que <I>b</I> = 0. Sinon, on fait un changement d’origine sur
les polynômes <I>F</I> et <I>G</I> pour que <I>b</I> = 0 convienne, on calcule le pgcd et on
lui applique la translation d’origine opposée.</P><P>On adopte ensuite la notation suivante: si <I>k</I> est un entier, on dit qu’un
polynôme <I>P</I> est un <I>O</I> ( <I>k</I> ) si la valuation de <I>P</I> vu comme polynôme en
<I>X</I><SUB>2</SUB>, … ., <I>X</I><SUB><I>n</I></SUB> à coefficients dans ℤ [ <I>X</I><SUB>1</SUB> ] est supérieure
ou égale à <I>k</I>, ou de manière équivalente si
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I> ( <I>X</I><SUB>1</SUB>, <I>h</I> <I>X</I><SUB>2</SUB>, … ., <I>h</I> <I>X</I><SUB><I>n</I></SUB> ) = <I>O</I><SUB><I>h</I> → 0</SUB> ( <I>h</I><SUP><I>k</I></SUP> ) </TD></TR>
</TABLE><P>
L’égalité à lifter se réécrit donc:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I> lcoeff ( <I>F</I> ) = <I>P</I><SUB>0</SUB> <I>Q</I><SUB>0</SUB> + <I>O</I> ( 1 ) </TD></TR>
</TABLE><P> 
où <I>P</I><SUB>0</SUB> =<I>D</I><SUB><I>b</I></SUB> lcoeff ( <I>F</I> ( <I>b</I> ))/lcoeff ( <I>D</I><SUB><I>b</I></SUB> ) et
<I>Q</I><SUB>0</SUB> = <I>F</I> ( <I>b</I> )/<I>D</I><SUB><I>b</I></SUB> lcoeff ( <I>F</I> ) ( <I>b</I> )/lcoeff (
<I>F</I> ( <I>b</I> )/<I>D</I><SUB><I>b</I></SUB> ) sont premiers entre eux et de degré 0 par rapport aux
variables <I>X</I><SUB>2</SUB>, … ., <I>X</I><SUB><I>n</I></SUB>. Cherchons <I>P</I><SUB>1</SUB> = <I>O</I> ( 1 ) et <I>Q</I><SUB>1</SUB> = <I>O</I> ( 1 )
de degré 1 par rapport aux variables <I>X</I><SUB>2</SUB>, … ., <I>X</I><SUB><I>n</I></SUB> tels que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I> lcoeff ( <I>F</I> ) = ( <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB> ) ( <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB> ) + <I>O</I> ( 2 ) </TD></TR>
</TABLE><P>
Il faut donc résoudre
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I> lcoeff ( <I>F</I> ) − <I>P</I><SUB>0</SUB> <I>Q</I><SUB>0</SUB> = <I>P</I><SUB>0</SUB> <I>Q</I><SUB>1</SUB> + <I>Q</I><SUB>0</SUB> <I>P</I><SUB>1</SUB> + <I>O</I> ( 2 ) </TD></TR>
</TABLE><P>
On peut alors appliquer l’identité de Bézout qui permet de déterminer des
polynômes <I>P</I><SUB>1</SUB> et <I>Q</I><SUB>1</SUB> satisfaisant l’égalité ci-dessus (avec comme reste <I>O</I>
( 2 ) nul) puisque <I>P</I><SUB>0</SUB> et <I>Q</I><SUB>0</SUB> sont premiers entre eux. De plus, on
choisit <I>P</I><SUB>1</SUB> et <I>Q</I><SUB>1</SUB> tels que degre<SUB><I>X</I><SUB>1</SUB></SUB> <I>P</I><SUB>1</SUB> ⩽
degre<SUB><I>X</I><SUB>1</SUB></SUB> ( <I>F</I> ) − degre ( <I>Q</I><SUB>0</SUB> ) = degre ( <I>P</I><SUB>0</SUB> ) et
degre<SUB><I>X</I><SUB>1</SUB></SUB> ( <I>Q</I><SUB>1</SUB> ) ⩽ degre ( <I>Q</I><SUB>0</SUB> ) et
lcoeff<SUB><I>X</I><SUB>1</SUB></SUB> ( <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB> ) + <I>O</I> ( 2 ) = lcoeff<SUB><I>X</I><SUB>1</SUB></SUB> ( <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB>
) + <I>O</I> ( 2 ) = lcoeff<SUB><I>X</I><SUB>1</SUB></SUB> ( <I>F</I> ). On tronque ensuite <I>P</I><SUB>1</SUB> et <I>Q</I><SUB>1</SUB> en
ne conservant que les termes de degré 1 par rapport à <I>X</I><SUB>2</SUB>, … ., <I>X</I><SUB><I>n</I></SUB>.</P><P>On trouve de la même manière par récurrence <I>P</I><SUB><I>k</I></SUB> et <I>Q</I><SUB><I>k</I></SUB> homogènes de degré
<I>k</I> par rapport à <I>X</I><SUB>2</SUB>, … ., <I>X</I><SUB><I>k</I></SUB>, de degré par rapport à <I>X</I><SUB>1</SUB>
respectivement inférieur aux degrés de <I>Q</I><SUB>0</SUB> et de <I>P</I><SUB>0</SUB> et tels que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
<I>F</I> lcoeff ( <I>F</I> ) = ( <I>P</I><SUB>0</SUB> + … . + <I>P</I><SUB><I>k</I></SUB> ) ( <I>Q</I><SUB>0</SUB> + … . + <I>Q</I><SUB><I>k</I></SUB> ) +
<I>O</I> ( <I>k</I> + 1  ) <A NAME="ezgcd"></A>
    (10)</TD></TR>
</TABLE><P>
et lcoeff ( <I>F</I> ) = lcoeff<SUB><I>X</I><SUB>1</SUB></SUB> ( <I>P</I><SUB>0</SUB> + … . + <I>P</I><SUB><I>k</I></SUB> ) + <I>O</I> ( <I>k</I>
+ 1 ) = lcoeff<SUB><I>X</I><SUB>1</SUB></SUB> ( <I>Q</I><SUB>0</SUB> + … . + <I>Q</I><SUB><I>k</I></SUB> ) + <I>O</I> ( <I>k</I> + 1 ).</P><P>Si on est bien en un point de bonne évaluation et si <I>k</I> est plus grand que le
degré total (par rapport aux variables <I>X</I><SUB>2</SUB>, … ., <I>X</I><SUB><I>n</I></SUB>) du polynôme
<I>F</I> lcoeff ( <I>F</I> ) on va vérifier que <I>P</I><SUB>0</SUB> + … . + <I>P</I><SUB><I>k</I></SUB> = <I>D</I>
lcoeff ( <I>F</I> )/lcoeff ( <I>D</I> ). En effet, si on a deux
suites de polynômes <I>P</I> et <I>P</I>′ et <I>Q</I> et <I>Q</I>′ satisfaisant (<A HREF="#ezgcd">10</A>) avec
les même termes de degré zéro <I>P</I><SUB>0</SUB> et <I>Q</I><SUB>0</SUB>, alors en prenant la différence,
on obtient:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">( <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB> …  + <I>P</I><SUB><I>k</I></SUB> ) ( <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB> …  + <I>Q</I><SUB><I>k</I></SUB> ) = ( <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB>′
…  + <I>P</I><SUB><I>k</I></SUB>′ ) ( <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB>′ …  + <I>Q</I><SUB><I>k</I></SUB>′ ) + <I>O</I> ( <I>k</I> + 1 ) </TD></TR>
</TABLE><P>
On égale alors les termes homogènes de degré <I>j</I>, pour <I>j</I> = 1, on obtient
<I>P</I><SUB>0</SUB> ( <I>Q</I><SUB>1</SUB> − <I>Q</I><SUB>1</SUB>′ ) = <I>Q</I><SUB>0</SUB> ( <I>P</I><SUB>1</SUB> − <I>P</I><SUB>1</SUB>′ ), donc <I>Q</I><SUB>0</SUB> divise <I>Q</I><SUB>1</SUB> − <I>Q</I><SUB>1</SUB>′ qui
est de degré strictement inférieur au degré de <I>Q</I><SUB>0</SUB> par rapport à <I>X</I><SUB>1</SUB> (car
on a l’inégalité large et les termes de plus haut degré sont égaux),
donc <I>Q</I><SUB>1</SUB> = <I>Q</I><SUB>1</SUB>′ et <I>P</I><SUB>1</SUB> = <I>P</I><SUB>1</SUB>′. On montre de la même manière que <I>Q</I><SUB><I>j</I></SUB> =
<I>Q</I><SUB><I>j</I></SUB>′ et <I>P</I><SUB><I>j</I></SUB> = <I>P</I><SUB><I>j</I></SUB>′. L’écriture est donc unique, c’est donc l’écriture en
polynôme homogène de degré croissant de <I>D</I> lcoeff ( <I>F</I>
)/lcoeff ( <I>D</I> ) que l’on reconstruit.</P><P>Cet algorithme permet donc de reconstruire <I>D</I>, il suffit de tester à chaque
étape si <I>P</I><SUB>0</SUB> + … . + <I>P</I><SUB><I>k</I></SUB> divise <I>F</I> lcoeff ( <I>F</I> ). On appelle
cette méthode de remontée lemme de Hensel linéaire. Il existe une variante
dite lemme de Hensel quadratique qui consiste à passer de <I>O</I> ( <I>k</I> ) à <I>O</I> ( 2 <I>k</I>
). Elle nécessite toutefois un calcul supplémentaire, celui de l’identité de
Bézout à <I>O</I> ( 2 <I>k</I> ) près pour les polynômes <I>P</I><SUB>0</SUB> + … . + <I>P</I><SUB><I>k</I> − 1</SUB> et
<I>Q</I><SUB>0</SUB> + … . + <I>Q</I><SUB><I>k</I> − 1</SUB>. Ce calcul se fait également par lifting.</P><P><B>Algorithme EZGCD (Hensel linéaire)</B></P><P>Arguments: 2 polynômes <I>F</I> et <I>G</I> à coefficients entiers et primitifs. Renvoie
le pgcd de <I>F</I> et <I>G</I> ou false.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Evaluer <I>F</I> et <I>G</I> en ( <I>X</I><SUB>2</SUB>, … ., <I>X</I><SUB><I>n</I></SUB> ) = ( 0, … ., 0 ),
vérifier que les coefficients dominants de <I>F</I> et de <I>G</I> ne s’annulent pas.
Calculer le pgcd <I>D</I><SUB><I>b</I></SUB> de <I>F</I> ( 0 ) et de <I>G</I> ( 0 ). Prendre un autre point
d’évaluation au hasard qui n’annule pas les coefficients dominants de <I>F</I> et
de <I>G</I> et vérifier que le pgcd a le même degré que <I>D</I><SUB><I>b</I></SUB>. Sinon, renvoyer
false (on peut aussi faire une translation d’origine de <I>F</I> et de <I>G</I> en un
autre point mais cela diminue l’efficacité de l’algorithme).</LI><LI CLASS="li-enumerate">On note lcF et lcG les coefficients dominants de <I>F</I>
et de <I>G</I> par rapport à <I>X</I><SUB>1</SUB>.</LI><LI CLASS="li-enumerate">Si degre ( <I>F</I> ) ⩽ degre ( <I>G</I> ) et degre
( <I>D</I><SUB><I>b</I></SUB> ) = degre ( <I>G</I> ) et <I>F</I> divise <I>G</I> renvoyer <I>F</I></LI><LI CLASS="li-enumerate">Si degre ( <I>G</I> ) &lt; degre ( <I>F</I> ) et degre ( <I>D</I><SUB><I>b</I></SUB> )
= degre ( <I>F</I> ) et <I>G</I> divise <I>F</I> renvoyer <I>G</I></LI><LI CLASS="li-enumerate">Si degre ( <I>F</I> ) = degre ( <I>D</I><SUB><I>b</I></SUB> ) ou si degre ( <I>G</I>
) = degre ( <I>D</I><SUB><I>b</I></SUB> ) renvoyer false</LI><LI CLASS="li-enumerate">Boucle infinie sur <I>j</I> entier initialisé à 0, incrémenté de 1 à chaque
itération: si pgcd ( <I>D</I><SUB><I>b</I></SUB>, <I>F</I> ( 0 ) + <I>j</I> <I>G</I> ( 0 )/<I>D</I><SUB><I>b</I></SUB> ) = <I>C</I>
constant, alors arrêter la boucle</LI><LI CLASS="li-enumerate">Lifter l’égalité ( <I>F</I> + <I>j</I> <I>G</I> ) ( lcF + <I>j</I> lcG ) ( 0 ) =
( <I>D</I><SUB><I>b</I></SUB> ( lcF + <I>j</I> lcG ) ( 0 )/lcoeff ( <I>D</I><SUB><I>b</I>
)</SUB> ) ∗ … . par remontée de Hensel linéaire ou quadratique.
Si le résultat est false, renvoyer false. Sinon renvoyer le premier polynôme
du résultat divisé par son contenu vu comme polynôme en <I>X</I><SUB>1</SUB> à coefficients
dans ℤ [ <I>X</I><SUB>2</SUB>, … ., <I>X</I><SUB><I>n</I></SUB> ].
</LI></OL><P>
<B>Remontée de Hensel linéaire</B>:<A NAME="@default53"></A></P><P>Arguments: <I>F</I> un polynôme, lcF=lcoeff(<I>F</I>) 
son coefficient dominant, <I>P</I><SUB>0</SUB> un
facteur de <I>F</I> ( 0 ) ayant comme coefficient dominant lcF ( 0 ) et
dont le cofacteur <I>Q</I><SUB>0</SUB> est premier avec <I>P</I><SUB>0</SUB>.</P><P>Renvoie deux polynômes <I>P</I> et <I>Q</I> tels que <I>F</I> lcF = <I>P</I> <I>Q</I> et <I>P</I> ( 0 ) =
<I>P</I><SUB>0</SUB> et lcoeff ( <I>P</I> ) = lcoeff ( <I>Q</I> ) = lcF.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Soit <I>G</I> = <I>F</I> lcF, , <I>Q</I><SUB>0</SUB> = <I>G</I> ( 0 ) / <I>P</I><SUB>0</SUB>, <I>P</I> = <I>P</I><SUB>0</SUB>, <I>Q</I> =
<I>Q</I><SUB>0</SUB>.</LI><LI CLASS="li-enumerate">Déterminer les deux polynômes <I>U</I> et <I>V</I> de l’identité de Bézout
(tels que <I>P</I><SUB>0</SUB> <I>U</I> + <I>Q</I><SUB>0</SUB> <I>V</I> = <I>d</I> où <I>d</I> est un entier).</LI><LI CLASS="li-enumerate">Boucle infinie avec un compteur <I>k</I> initialisé à 1, incrémenté de 1 à
chaque itération
<UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>k</I> &gt; degre<SUB><I>X</I><SUB>2</SUB>, … ., <I>X</I><SUB><I>n</I></SUB></SUB> ( <I>G</I> ), renvoyer false.</LI><LI CLASS="li-itemize">Si <I>P</I> divise <I>G</I>, renvoyer <I>P</I> et <I>G</I> / <I>P</I>.</LI><LI CLASS="li-itemize">Soit <I>H</I> = <I>G</I> − <I>P</I> <I>Q</I> = <I>O</I> ( <I>k</I> ). Soit <I>u</I> = <I>U</I> <I>H</I>/<I>d</I> et <I>v</I> = <I>V</I>
<I>H</I>/<I>d</I>, on a <I>P</I><SUB>0</SUB> <I>u</I> + <I>Q</I><SUB>0</SUB> <I>v</I> = <I>H</I></LI><LI CLASS="li-itemize">Remplacer <I>v</I> par le reste de la division euclidienne de <I>v</I> par
<I>P</I><SUB>0</SUB> et <I>u</I> par le reste de la division euclidienne de <I>u</I> par <I>Q</I><SUB>0</SUB>. La
somme des deux quotients est égale au quotient euclidien de <I>H</I> par <I>P</I><SUB>0</SUB>
<I>Q</I><SUB>0</SUB>, c’est-à-dire au coefficient dominant de <I>H</I> divisé par le produit
des coefficients dominants de <I>P</I><SUB>0</SUB> et <I>Q</I><SUB>0</SUB> (qui sont égaux) donc on a
l’égalité:
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB>0</SUB> <I>u</I> + <I>Q</I><SUB>0</SUB> <I>v</I> = <I>H</I> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">lcoeff ( <I>H</I> )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">lcoeff ( <I>P</I><SUB>0</SUB>
)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>P</I><SUB>0</SUB> <I>Q</I><SUB>0</SUB> </TD></TR>
</TABLE>
</LI><LI CLASS="li-itemize">Soit
α = ( lcoeff ( <I>F</I> ) − lcoeff ( <I>P</I> )) / lcoeff (
<I>P</I><SUB>0</SUB> ) et β = ( lcoeff ( <I>F</I> ) − lcoeff ( <I>Q</I> )) /
lcoeff ( <I>P</I><SUB>0</SUB> ).
On ajoute α <I>P</I><SUB>0</SUB> à <I>v</I>, ainsi lcoeff ( <I>P</I> + <I>v</I> ) =
lcoeff ( <I>F</I> ) + <I>O</I> ( <I>k</I> + 1 ) et β <I>Q</I><SUB>0</SUB> à <I>u</I>, ainsi
lcoeff ( <I>Q</I> + <I>u</I> ) = lcoeff ( <I>F</I> ) + <I>O</I> ( <I>k</I> + 1 ) <P>Remarque: on montre alors que α + β = lcoeff ( <I>H</I>
)/lcoeff ( <I>P</I><SUB>0</SUB> <I>Q</I><SUB>0</SUB> ) + <I>O</I> ( <I>k</I> + 1 ) donc <I>P</I><SUB>0</SUB> <I>u</I> + <I>Q</I><SUB>0</SUB> <I>v</I> = <I>H</I> + <I>O</I> (
<I>k</I> + 1 ) en utilisant les propriétés :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">lcoeff ( <I>F</I> ) = lcoeff ( <I>P</I> ) + <I>O</I> ( <I>k</I> ) =
lcoeff ( <I>Q</I> ) + <I>O</I> ( <I>k</I> ) = lcoeff ( <I>P</I><SUB>0</SUB> ) + <I>O</I> ( 1 ) </TD></TR>
</TABLE></LI><LI CLASS="li-itemize">Réduire <I>u</I> et <I>v</I> en éliminant les termes de degré strictement
supérieur à <I>k</I> par rapport à <I>X</I><SUB>2</SUB>, … ., <I>X</I><SUB><I>n</I></SUB>. S’il reste un
coefficient non entier, renvoyer false</LI><LI CLASS="li-itemize">Remplacer <I>P</I> par <I>P</I> + <I>v</I> et <I>Q</I> par <I>Q</I> + <I>u</I>, passer à l’itération
suivante.
</LI></UL>
</LI></OL><P>
<B>Exemple</B>:</P><P><I>F</I> = (( <I>x</I> + 1 ) <I>y</I> + <I>x</I><SUP>2</SUP> + 1 ) ( <I>y</I><SUP>2</SUP> + <I>x</I> <I>y</I> + 1 ), <I>G</I> = (( <I>x</I> + 1 ) <I>y</I> + <I>x</I><SUP>2</SUP> + 1 )
( <I>y</I><SUP>2</SUP> − <I>x</I> <I>y</I> − 1 )</P><P>On a <I>F</I> ( 0, <I>y</I> ) = ( <I>y</I> + 1 ) ( <I>y</I><SUP>2</SUP> + 1 ) et <I>G</I> ( 0, <I>y</I> ) = ( <I>y</I> + 1 ) ( <I>y</I><SUP>2</SUP> − 1
), le pgcd est donc <I>D</I><SUB><I>b</I></SUB> = ( <I>y</I> + 1 ). On remarque que <I>D</I><SUB><I>b</I></SUB> est premier avec
le cofacteur de <I>F</I> mais pas avec le cofacteur de <I>G</I>. Si on évalue en un
autre point, par exemple <I>x</I> = 1, on trouve un pgcd <I>D</I><SUB>1</SUB> de même degré, donc
0 est vraissemblablement un bon point d’évaluation (ici on en est sûr puisque
le pgcd de <I>F</I> et <I>G</I> se calcule à vue...). On a lcoeff ( <I>F</I> ) = <I>x</I> +
1, on va donc lifter <I>G</I> = (( <I>x</I> + 1 ) <I>y</I> + <I>x</I><SUP>2</SUP> + 1 ) ( <I>y</I><SUP>2</SUP> + <I>x</I> <I>y</I> + 1 ) ( <I>x</I> + 1
) = <I>P</I> <I>Q</I> où <I>P</I><SUB>0</SUB> = ( <I>y</I> + 1 ) et <I>Q</I><SUB>0</SUB> = ( <I>y</I><SUP>2</SUP> + 1 ).</P><P>On calcule les polynômes de l’identité de Bézout <I>U</I> = ( 1 − <I>y</I> ) et <I>V</I> = 1
avec <I>d</I> = 2, puis à l’ordre <I>k</I> = 1:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>H</I> = <I>G</I> − <I>P</I><SUB>0</SUB> <I>Q</I><SUB>0</SUB> = ( 2 <I>y</I><SUP>3</SUP> + 2 <I>y</I><SUP>2</SUP> + 3 <I>y</I> + 1 ) <I>x</I> + <I>O</I> ( 2 ) </TD></TR>
</TABLE><P>
donc <I>u</I> = reste ( <I>U</I> <I>H</I> / <I>d</I>, <I>Q</I><SUB>0</SUB> ) = <I>x</I> <I>y</I> et <I>v</I> = reste ( <I>V</I> <I>H</I> / <I>d</I>,
<I>P</I><SUB>0</SUB> ) = − <I>x</I>.</P><P>Donc <I>Q</I><SUB>1</SUB> = <I>x</I> <I>y</I> + α <I>Q</I><SUB>0</SUB> avec α = ( <I>x</I> + 1 − 1 ) / lcoeff (
<I>P</I><SUB>0</SUB> ) = <I>x</I> et <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB> = ( <I>y</I><SUP>2</SUP> + 1 ) ( <I>x</I> + 1 ) + <I>x</I> <I>y</I>. De
même, <I>P</I><SUB>1</SUB> = − <I>x</I> + β <I>P</I><SUB>0</SUB>, avec β = ( <I>x</I> + 1 − 1 ) / lcoeff (
<I>P</I><SUB>0</SUB> ) = <I>x</I> donc <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB> = ( <I>y</I> + 1 ) ( <I>x</I> + 1 ) − <I>x</I>. On remarque que <I>P</I><SUB>0</SUB> +
<I>P</I><SUB>1</SUB> et <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB> sont bien à <I>O</I> ( 2 ) près les facteurs de <I>F</I>
lcoeff ( <I>F</I> ):
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I> = ( <I>x</I> + 1 ) <I>y</I> + <I>x</I><SUP>2</SUP> + 1 = <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB> + <I>O</I> ( 2 ),  <I>Q</I> = ( <I>x</I> +
1 ) ( <I>y</I><SUP>2</SUP> + <I>x</I> <I>y</I> + 1 ) = <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB> + <I>O</I> ( 2 ) </TD></TR>
</TABLE><P>
Une deuxième itération est nécessaire. On calcule
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>H</I> = <I>G</I> − ( <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB> ) ( <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB> ) = ( 2 <I>y</I><SUP>2</SUP> + <I>y</I> + 1 ) <I>x</I><SUP>2</SUP> + <I>O</I> ( 3
) </TD></TR>
</TABLE><P>
puis reste ( <I>U</I> <I>H</I> / <I>d</I>, <I>Q</I><SUB>0</SUB> ) = <I>y</I> <I>x</I><SUP>2</SUP> et reste ( <I>V</I> <I>H</I> / <I>d</I>, <I>P</I><SUB>0</SUB> )
= <I>x</I><SUP>2</SUP>. Ici les coefficients α et β sont nuls car lcoeff
( <I>F</I> ) n’a pas de partie homogène de degré 2. On trouve alors <I>P</I> = <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB> +
<I>P</I><SUB>2</SUB> et <I>Q</I> = <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB> + <I>Q</I><SUB>2</SUB>. Pour calculer le pgcd, il suffit de calculer la
partie primitive de <I>P</I> vu comme polynôme en <I>y</I>, ici c’est encore <I>P</I> car le
contenu de <I>P</I> est 1 (remarque: pour <I>Q</I> le contenu est <I>x</I> + 1).<BR>
On trouve donc <I>P</I> comme pgcd.</P><!--TOC subsection Quel algorithme choisir?-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc37">3.4</A>  Quel algorithme choisir?</H3><!--SEC END --><P>Il est toujours judicieux de faire une évaluation en quelques <I>n</I> − 1 uplets
pour traquer les pgcd triviaux. (E)EZGCD sera efficace si (0,...,0) est un
point de bonne évaluation et si le nombre de remontées nécessaires pour le
lemme de Hensel est petit donc pour les pgcd de petit degré, GCDMOD est aussi
efficace si le degré du pgcd est petit. Le sous-résultant est efficace pour
les pgcd de grand degré car il y a alors peu de divisions euclidiennes à
effectuer et les coefficients n’ont pas trop le temps de croitre. SPMOD est
intéressant pour les polynômes creux de pgcd non trivial creux. GCDHEU est
intéressant pour les problèmes relativement petits.</P><P>Avec des machines multiprocesseurs, on a probablement intérêt à lancer en
parallèle plusieurs algorithmes et à s’arrêter dès que l’un deux recontre le
succès.</P><!--TOC subsection Pour en savoir plus.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc38">3.5</A>  Pour en savoir plus.</H3><!--SEC END --><P>
Parmi les références citées dans le premier article, ce sont les livres de
Knuth, H. Cohen, et Davenport-Siret-Tournier qui traitent des algorithmes de
pgcd. On peut bien sûr consulter le source de son système de calcul formel
lorsqu’il est disponible :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
pour MuPAD sur un système Unix, depuis le
répertoire d’installation de MuPAD (en général <TT>/usr/local/MuPAD</TT>)
après avoir désarchivé le fichier <TT>lib.tar</TT> du répertoire <TT>share/lib</TT> 
par la commande<BR>
<TT>cd share/lib &amp;&amp; tar xvf lib.tar</TT><BR>
on trouve les algorithmes de calcul de PGCD dans le répertoire<BR>
<TT>share/lib/lib/POLYLIB/GCD</TT>
</LI><LI CLASS="li-itemize">Pour l’algorithme EZGCD, je me suis inspiré de l’implémentation de 
Singular (logiciel libre disponible à <TT>www.singular.uni-kl.de</TT>)
</LI></UL><P>
Sur le web on trouve quelques articles en lignes sur le
sujet en cherchant les mots clefs GCDHEU, EZGCD, SPMOD sur un moteur de 
recherche, il y a par exemple une description un peu différente du pgcd
heuristique sur:<BR>
<TT>www.inf.ethz.ch/personal/gonnet/CAII/HeuristicAlgorithms/node1.html</TT><BR>
et un article de comparaison de ces algorithmes 
par Fateman et Liao (dont la référence bibliographique est
Evaluation of the heuristic polynomial GCD.
in: ISSAC pages 240–247, 1995). Quelques autres références :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
K.O.Geddes et al "Alg. for Computer Algebra", Kluwer 1992.
</LI><LI CLASS="li-itemize">pour GCDHEU Char, Geddes, Gonnet, 
Gcdheu: Heuristic polynomial gcd algorithm based on integer gcd computation,
in: Journal of Symbolic Computation, 7:31–48, 1989.
</LI><LI CLASS="li-itemize">pour SPMOD "Probabilistic Algorithms for Sparse Polynomials",
in: Symbolic &amp; Algebraic Comp. (Ed E.W.Ng), Springer 1979, pp216,
</LI></UL><!--TOC section Le résultant-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc39">4</A>  Le résultant</H2><!--SEC END --><P> <A NAME="sec:resultant"></A> <A NAME="@default54"></A>
</P><!--TOC subsection Définition-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc40">4.1</A>  Définition</H3><!--SEC END --><P>
Il s’agit d’un point de vue d’algèbre linéaire sur le PGCD. Considérons
deux polynômes <I>A</I> et <I>B</I> à coefficients dans un corps,
de degrés <I>p</I> et <I>q</I> et de pgcd <I>D</I> et 
l’identité de Bézout correspondante :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:bezout"></A>
<I>A</I> <I>U</I> + <I>B</I> <I>V</I> =<I>D</I>
    (11)</TD></TR>
</TABLE><P>
avec degré(<I>U</I>)&lt;<I>q</I> et degré(<I>V</I>)&lt;<I>p</I>.
Imaginons qu’on cherche <I>U</I> et <I>V</I> en oubliant qu’il s’agit d’une
identité de Bézout, en considérant simplement qu’il s’agit d’un
problème d’algèbre linéaire de <I>p</I>+<I>q</I> équations (obtenues en développant
et en identifiant chaque puissance de <I>X</I> de 0 à <I>p</I>+<I>q</I>−1) 
à <I>p</I>+<I>q</I> inconnues (les <I>p</I> coefficients de <I>V</I> et les <I>q</I> coefficients de <I>U</I>)
On sait que <I>A</I> et <I>B</I> sont premiers entre eux si et seulement si ce problème
d’algèbre linéaire a une solution pour <I>D</I>=1. Donc si le déterminant
du système est non nul, alors <I>A</I> et <I>B</I> sont premiers entre eux.
Réciproquement si <I>A</I> et <I>B</I> sont premiers entre eux, le système a
une solution unique non seulement avec comme second membre 1 mais avec
n’importe quel polynôme de degré inférieur <I>p</I>+<I>q</I>, donc le
déterminant du système est non nul.</P><P><B>Définition:</B><BR>
On appelle résultant de <I>A</I> et <I>B</I> le déterminant de ce système 
(<A HREF="#eq:bezout">11</A>). Il s’annule si et seulement si <I>A</I> et <I>B</I>
ne sont pas premiers entre eux (ont au moins une racine commune).
On appelle <B>matrice de Sylvester</B><A NAME="@default55"></A> la transposée de la matrice du système
(les inconnues étant par ordre décroissant les coefficients de <I>U</I>
et <I>V</I>)
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I>(<I>A</I>,<I>B</I>)=</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>A</I><SUB><I>a</I></SUB></TD><TD ALIGN=center NOWRAP><I>A</I><SUB><I>a</I>−1</SUB></TD><TD ALIGN=center NOWRAP>…</TD><TD ALIGN=center NOWRAP>…</TD><TD ALIGN=center NOWRAP><I>A</I><SUB>0</SUB></TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>…</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>A</I><SUB><I>a</I></SUB></TD><TD ALIGN=center NOWRAP>…</TD><TD ALIGN=center NOWRAP>…</TD><TD ALIGN=center NOWRAP><I>A</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP><I>A</I><SUB>0</SUB></TD><TD ALIGN=center NOWRAP>…</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>⋮ </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>…</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP><I>A</I><SUB>0</SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I><SUB><I>b</I></SUB></TD><TD ALIGN=center NOWRAP><I>B</I><SUB><I>b</I>−1</SUB></TD><TD ALIGN=center NOWRAP>…</TD><TD ALIGN=center NOWRAP><I>B</I><SUB>0</SUB></TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>…</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>⋮ </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>…</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP><I>B</I><SUB>0</SUB> </TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
(cette matrice contient <I>b</I>=degré(<I>B</I>) lignes de coefficients
du polynôme <I>A</I> et <I>a</I>=degré(<I>A</I>) lignes de coefficients du
polynôme <I>B</I>, les coefficients diagonaux sont les <I>A</I><SUB><I>a</I></SUB> et <I>B</I><SUB>0</SUB>)</P><P><B>Remarques</B><BR>
Le résultant s’exprime polynomialement en fonction
des coefficients des polynômes <I>A</I> et <I>B</I> donc aussi en fonction
des coefficients dominants de <I>A</I> et <I>B</I> et des racines 
α<SUB>1</SUB>,..., α<SUB><I>a</I></SUB> de <I>A</I> et β<SUB>1</SUB>,...,β<SUB><I>b</I></SUB> <I>B</I>,
or si on fait varier les racines de <I>B</I> on annulera le résultant
si l’une d’elle coincide avec une racine de <I>A</I>, ceci montre
que le résultant est divisible par le produit des 
différences des racines β<SUB><I>j</I></SUB>−α<SUB><I>i</I></SUB> de <I>A</I> et <I>B</I>. 
On montre que le quotient 
est <I>A</I><SUB><I>a</I></SUB><SUP><I>b</I></SUP> <I>B</I><SUB><I>b</I></SUB><SUP><I>a</I></SUP> en regardant le coefficient
dominant du résultant en degré total par rapport aux β<SUB><I>j</I></SUB> :
dans le déterminant il faut prendre le produit des termes diagonaux
pour avoir le degré maximal en les β<SUB><I>j</I></SUB>.
On peut aussi l’écrire sous la forme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">resultant(<I>A</I>,<I>B</I>)=<I>A</I><SUB><I>a</I></SUB><SUP><I>b</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>B</I>(α<SUB><I>i</I></SUB>)</TD></TR>
</TABLE><P>Soit <I>P</I> un polynôme de degré <I>n</I> et coefficient dominant <I>p</I><SUB><I>n</I></SUB>.
Le coefficient dominant de <I>P</I>′ est <I>np</I><SUB><I>n</I></SUB>, un multiple de <I>p</I><SUB><I>n</I></SUB>, 
le résultant de <I>P</I> et <I>P</I>′ est donc divisible
par <I>p</I><SUB><I>n</I></SUB>, on appelle le quotient
<B>discriminant</B><A NAME="@default56"></A>. En terme des racines <I>r</I><SUB><I>i</I></SUB> de <I>P</I>, on a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">disc(<I>P</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">resultant(<I>P</I>,<I>P</I>′)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>p</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">
=<I>p</I><SUB><I>n</I></SUB><SUP><I>n</I>−2</SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>P</I>′(<I>r</I><SUB><I>i</I></SUB>) = <I>p</I><SUB><I>n</I></SUB><SUP>2<I>n</I>−2</SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1≤ <I>i</I>&lt;<I>j</I>≤ <I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>r</I><SUB><I>i</I></SUB>−<I>r</I><SUB><I>j</I></SUB>)<SUP>2</SUP></TD></TR>
</TABLE><P>
Ce résultat a un intérêt pour par exemple minorer à priori l’écart entre
2 racines d’un polynôme à coefficients entiers.</P><!--TOC subsection Applications-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc41">4.2</A>  Applications</H3><!--SEC END --><P>
Revenons au cas où nos polynômes sont à coefficients dans un
anneau contenu dans un corps, par exemple ℤ ∈ ℚ ou un anneau 
de polynômes ℤ[<I>X</I><SUB>2</SUB>,...,<I>X</I><SUB><I>n</I></SUB>]  dans son corps de fractions.
On remarque alors que l’équation :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>AU</I>+<I>BV</I>=<I>C</I></TD></TR>
</TABLE><P>
a une solution dans l’anneau si <I>C</I> est le résultant <I>r</I>
de <I>A</I> et <I>B</I> (ou un multiple). En effet, on écrit les solutions comme 
celles d’un système de Cramer, le dénominateur
de chaque inconnue est <I>r</I>, le numérateur 
est un déterminant ayant les coefficients de <I>C</I> dans une
des colonnes, on peut donc y factoriser <I>r</I> et simplifier.
On peut le voir directement à partir de la définition du
résultant en effectuant sur le déterminant
une manipulation de colonnes sur la dernière colonne,
on ajoute à cette dernière colonne <I>x</I> fois l’avant-dernière,
<I>x</I><SUP>2</SUP> fois l’avant-avant-dernière etc... La dernière colonne
devient 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>x</I><SUP><I>b</I>−1</SUP> <I>A</I> </TD></TR>
<TR><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>x</I><SUP><I>a</I>−1</SUP> <I>B</I> </TD></TR>
<TR><TD ALIGN=center NOWRAP>...</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
et en développant le déterminant par rapport à cette 
dernière colonne, on obtient l’identité de Bézout.</P><P><B>Exemple</B> : le résultant de <I>x</I>+1 et <I>x</I>−1 est 2, donc l’équation
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>x</I>+1)<I>U</I>+(<I>x</I>−1)<I>V</I>=2</TD></TR>
</TABLE><P> a une solution <I>U</I>=1 et <I>V</I>=−1 dans ℤ[<I>X</I>],
par contre </P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>x</I>+1)<I>U</I>+(<I>x</I>−1)<I>V</I>=1</TD></TR>
</TABLE><P> n’a pas de solution dans ℤ[<I>X</I>].</P><P>Ceci peut servir à éliminer des inconnues lorsqu’on résoud un
système d’équations polynomiales :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB>1</SUB>(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I></SUB>)=0, ..., <I>P</I><SUB><I>n</I></SUB>(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I></SUB>)=0</TD></TR>
</TABLE><P>
On pose 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB>1</SUB><SUP>1</SUP>(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB>)=resultant(<I>P</I><SUB>1</SUB>,<I>P</I><SUB><I>n</I></SUB>,<I>X</I><SUB><I>n</I></SUB>), ..., 
<I>P</I><SUB><I>n</I>−1</SUB><SUP>1</SUP>(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB>)=resultant(<I>P</I><SUB><I>n</I>−1</SUB>,<I>P</I><SUB><I>n</I></SUB>,<I>X</I><SUB><I>n</I></SUB>)
</TD></TR>
</TABLE><P>
Comme <I>P</I><SUB>1</SUB><SUP>1</SUP>, <I>P</I><SUB><I>n</I>−1</SUB><SUP>1</SUP>, ... sont des combinaisons linéaires des
polynômes de départ à coefficients dans l’anneau, si
(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I></SUB>)
est solution du système de départ, alors <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB>
est solution du deuxième système.
On élimine ainsi les variables les unes après les autres,
pour se ramener à une seule équation polynomiale <I>P</I><SUB>1</SUB><SUP><I>n</I>−1</SUP>(<I>X</I><SUB>1</SUB>)=0, dont on
cherche les racines, puis si <I>r</I><SUB>1</SUB> est une racine de <I>P</I><SUB>1</SUB><SUP><I>n</I>−1</SUP>, on
remonte au système précédent <I>P</I><SUB>1</SUB><SUP><I>n</I>−2</SUP>(<I>r</I><SUB>1</SUB>,<I>X</I><SUB>2</SUB>)=0,
<I>P</I><SUB>2</SUB><SUP><I>n</I>−2</SUP>(<I>r</I><SUB>1</SUB>,<I>X</I><SUB>2</SUB>)=0, que l’on résoud en cherchant
les racines de gcd(<I>P</I><SUB>1</SUB><SUP><I>n</I>−2</SUP>(<I>r</I><SUB>1</SUB>,<I>X</I><SUB>2</SUB>),<I>P</I><SUB>2</SUB><SUP><I>n</I>−2</SUP>(<I>r</I><SUB>1</SUB>,<I>X</I><SUB>2</SUB>)), et ainsi
de suite jusqu’au système de départ.</P><P>Lors des calculs de résultant, il peut arriver que le résultat
soit nul si les arguments ne sont pas premiers entre eux, dans
ce cas il faut diviser par le PGCD de ces 2 polynômes et traiter le cas
du PGCD à part.</P><P>Malheureusement, les calculs de résultant deviennent vite
impraticables (cf. infra), on ne peut guère traiter par cette méthode
que des systèmes 3x3 (ou 4x4 si on est patient). Pour
des systèmes plus ambitieux, on utilisera plutôt un
calcul de bases de Groebner. Mais le résultant est très bien
adapté par exemple à la recherche d’équations cartésiennes
d’une courbe ou surface paramétrée par des fractions rationnelles.</P><!--TOC subsection Résultant et degrés-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc42">4.3</A>  Résultant et degrés</H3><!--SEC END --><P>
Si <I>A</I> et <I>B</I> sont des polynômes en <I>d</I> variables de degré
total <I>m</I> et <I>n</I> alors le résultant de <I>A</I> et <I>B</I> par rapport à
une des variables, disons la première notée <I>x</I>,
est un polynôme en <I>d</I>−1 variables, on va voir qu’on peut
majorer son degré total par <I>mn</I>.</P><P>Quitte à ajouter une variable d’homogénéisation (appelons-la <I>t</I>), on peut
supposer que <I>A</I> et <I>B</I> sont homogènes, par exemple
si <I>A</I>=<I>x</I><SUP>3</SUP>+<I>xy</I>+1 on considère <I>A</I><SUB><I>t</I></SUB>=<I>x</I><SUP>3</SUP>+<I>xyt</I>+<I>t</I><SUP>3</SUP>. Le degré total 
par rapport aux <I>d</I>−1 variables d’un
coefficient <I>A</I><SUB><I>j</I></SUB> de <I>A</I> est alors <I>m</I>−<I>j</I>, et pour <I>B</I><SUB><I>k</I></SUB> c’est <I>n</I>−<I>k</I>.
On développe le déterminant comme somme sur toutes les
permutations de <I>a</I>+<I>b</I> éléments, et on regarde le degré
total d’un terme par rapport aux <I>d</I>−1 variables, on a donc
un produit de <I>r</I><SUB><I>i</I> σ(<I>i</I>)</SUB> pour <I>i</I> entre 1 et <I>a</I>+<I>b</I>. Pour <I>i</I>
entre 1 et <I>b</I>, on est dans les <I>b</I> premières lignes, donc
avec des coefficients de <I>A</I>, le degré total de <I>r</I><SUB><I>i</I> σ<SUB><I>i</I></SUB></SUB>
se déduit de la distance à la diagonale, il vaut
<I>m</I>−<I>a</I>+σ<SUB><I>i</I></SUB>−<I>i</I> puisque sur la diagonale c’est <I>m</I>−<I>a</I>.
Pour <I>i</I> entre <I>b</I>+1 et <I>b</I>+<I>a</I> on est dans les <I>a</I> dernières
lignes, donc avec des coefficients de <I>B</I>, le degré total est
<I>n</I>+σ<SUB><I>i</I></SUB>−<I>i</I>. Le degré total du produit vaut donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>b</I>(<I>m</I>−<I>a</I>)+<I>an</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I>+<I>b</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> σ<SUB><I>i</I></SUB> −<I>i</I> = <I>b</I>(<I>m</I>−<I>a</I>)+<I>an</I>=<I>mn</I>−(<I>m</I>−<I>a</I>)(<I>n</I>−<I>b</I>)</TD></TR>
</TABLE><P>
il est donc au plus <I>mn</I> avec égalité si <I>m</I>=<I>a</I> ou <I>n</I>=<I>b</I>
(c’est-à-dire si le degré total est identique au degré partiel
en <I>x</I> pour au moins un des deux polynômes).</P><P>Lorsqu’on enlève la variable d’homogénéisation (en posant
<I>t</I>=1), on peut également perdre un ou plusieurs degrés. Dans le
cas de polynômes en 2 variables <I>A</I>(<I>x</I>,<I>y</I>), <I>B</I>(<I>x</I>,<I>y</I>), cela correspond à un point
d’intersection à l’infini entre les 2 courbes <I>A</I>(<I>x</I>,<I>y</I>)=<I>B</I>(<I>x</I>,<I>y</I>)=0, en
coordonnées homogènes on a <I>t</I>=0 qui est solution, et on remplace
<I>t</I> par 0 dans <I>A</I><SUB><I>t</I></SUB>(<I>x</I>,<I>y</I>,<I>t</I>)=<I>B</I><SUB><I>t</I></SUB>(<I>x</I>,<I>y</I>,<I>t</I>)=0 pour trouver la direction.</P><P>Exemple (tiré d’un TP de Frédéric Han)
intersection des 2 courbes <I>x</I>*<I>y</I>=4 et <I>y</I><SUP>2</SUP>=(<I>x</I>−3)*(<I>x</I><SUP>2</SUP>−16).
On a donc <I>A</I>=<I>xy</I>−4, 
<I>B</I>=<I>y</I><SUP>2</SUP>−(<I>x</I>−3)(<I>x</I><SUP>2</SUP>−16), <I>m</I>=2, <I>n</I>=3
on définit alors :<BR>
<CODE> A:=x*y-4t^2; B:=y^2*t-(x-3t)*(x^2-16t^2);</CODE><BR>
On observe que <CODE>resultant(A,B,x)</CODE> est bien de degré 6 (car
<I>n</I>=<I>b</I>=3), alors que <CODE>resultant(A,B,y)</CODE> est de degré 5 (<I>m</I> ≠
<I>a</I>, <I>n</I> ≠ <I>b</I>).
On a donc 5 points d’intersection complexes et un point d’intersection
à l’infini correspondant à la racine <I>t</I>=0 du résultant en <I>x</I> 
de coordonnées homogènes
(<I>x</I>,<I>y</I>,<I>t</I>)=(0,1,0). Illustration<BR>
<CODE>solve(subst(resultant(A,B,y),t=1))</CODE><BR>
<CODE>implicitplot(subst(A,t=1));implicitplot(subst(B,t=1))</CODE></P><P>Plus généralement, soit deux courbes algébriques d’équations respectives
<I>A</I>(<I>x</I>,<I>y</I>)=0 et <I>B</I>(<I>x</I>,<I>y</I>)=0 de degré totaux <I>m</I> et <I>n</I> et premiers
entre eux, alors <I>A</I> et
<I>B</I> ont au plus <I>mn</I> points d’intersection<A NAME="@default57"></A> 
(<B>théorème de Bézout</B><A NAME="@default58"></A>). 
En effet, le résultant
en <I>x</I> par exemple est non nul puisque les 2 polynômes sont premiers
entre eux, donc est un polynôme en <I>y</I> qui a un nombre fini de
racines, puis on cherche les racines en <I>x</I> de gcd(<I>A</I>(.,<I>y</I>),<I>B</I>(.,<I>y</I>))
pour chaque valeur de <I>y</I> racine, il y a donc un nombre fini
d’intersections. On peut donc changer de repère et choisir un
repère tel que deux points d’intersections distincts aient leurs
abscisses distinctes. On refait le même
raisonnement, et on utilise la majoration du degré du résultant
par rapport à <I>y</I> par <I>mn</I>, on a donc au plus <I>mn</I> valeurs
de <I>y</I>, donc au plus <I>mn</I> points d’intersections, puisqu’une valeur
de <I>y</I> ne correspond qu’à une valeur de <I>x</I> par choix du repère.
Lorsqu’on travaille dans ℂ<SUP>2</SUP>, le défaut de nombre de points
d’intersection par rapport au majorant <I>mn</I> provient des points à
l’infini, à condition de prendre en compte la multiplicité des
intersections. Dans ℝ<SUP>2</SUP>, on perd aussi les points non réels.
Exemple : intersection de (<I>x</I>−2)<SUP>2</SUP>+<I>y</I><SUP>2</SUP>=4 et <I>y</I><SUP>2</SUP>=(<I>x</I>−3)*(<I>x</I><SUP>2</SUP>−16).</P><P>Le degré du résultant explique pourquoi on ne peut pas résoudre
en pratique de grands systèmes polynomiaux avec cet outil
d’élimination.
Par exemple pour un système de 5 équations en 5 inconnues de
degré 5, en éliminant une variable, on passe à 4 équation en
4 inconnues de degré 25, puis à 3 équations en 3 inconnues
de degré 25<SUP>2</SUP>=625, puis 2 équations en 2 inconnues de
degré 625<SUP>2</SUP>=390625 et enfin un polynôme de degré ...
152587890625. Pour <I>n</I> équations de degré <I>n</I>, on a une majoration
par <I>n</I><SUP>(2<SUP><I>n</I>−1</SUP>)</SUP>, ainsi pour <I>n</I>=4 on trouve 65536 qui est déjà discutable...</P><!--TOC subsection Lien avec l’algorithme du sous-résultant (calcul de PGCD)-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc43">4.4</A>  Lien avec l’algorithme du sous-résultant (calcul de PGCD)</H3><!--SEC END --><P>
On peut calculer le déterminant avec la suite des restes de divisions
euclidiennes de la manière suivante, on part de la pseudo-division
de <I>A</I> par <I>B</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>B</I><SUB><I>b</I></SUB><SUP><I>a</I>−<I>b</I>+1</SUP> <I>A</I>=<I>BQ</I>+<I>R</I> </TD></TR>
</TABLE><P>
on effectue alors sur chaque ligne contenant les coefficients de <I>A</I>
la manipulation de ligne correspondante, c’est-à-dire multiplier
la ligne par <I>B</I><SUB><I>b</I></SUB><SUP><I>a</I>−<I>b</I>+1</SUP> et soustraire (<I>q</I><SUB>0</SUB> fois la ligne
de <I>B</I> terminant dans la même colonne+<I>q</I><SUB>1</SUB> fois la ligne
de <I>B</I> terminant une colonne avant+...). Toutes les lignes
contenant les coefficients de <I>A</I> ont été remplacées par des lignes 
contenant les coefficients de <I>R</I>. Ces lignes contiennent <I>k</I> zéros initiaux
avec <I>k</I> ≥ 1, ce qui permet de réduire le déterminant à celui
de la matrice de Sylvester de <I>R</I> et <I>B</I> (à un coefficient multiplicatif
près qui vaut <I>B</I><SUB><I>b</I></SUB><SUP><I>k</I></SUP> par rapport au précédent donc
<I>B</I><SUB><I>b</I></SUB><SUP><I>k</I>−<I>b</I>(<I>a</I>−<I>b</I>+1)</SUP> par rapport au déterminant de départ). 
On échange ensuite <I>R</I> et <I>B</I> ce qui change
éventuellement le signe et on continue en faisant les
divisions euclidiennes de l’algorithme du sous-résultant (cf.
Knuth où on utilise la matrice de Sylvester pour prouver que
l’algorithme du sous-résultant est correct). Rappelons que
le sous-résultant définit les suites <I>A</I><SUB><I>k</I></SUB> (<I>A</I><SUB>0</SUB>=<I>A</I>, <I>A</I><SUB>1</SUB>=<I>B</I>),
<I>d</I><SUB><I>k</I></SUB> le degré de <I>A</I><SUB><I>k</I></SUB>, δ<SUB><I>k</I></SUB>=<I>d</I><SUB><I>k</I></SUB>−<I>d</I><SUB><I>k</I>+1</SUB>,
<I>g</I><SUB><I>k</I></SUB> (<I>g</I><SUB>0</SUB>=1, si <I>k</I>≠ 0, <I>g</I><SUB><I>k</I></SUB> coefficient dominant de <I>A</I><SUB><I>k</I></SUB>) 
<I>h</I><SUB><I>k</I></SUB> (<I>h</I><SUB>0</SUB>=1, <I>h</I><SUB><I>k</I>+1</SUB>=<I>h</I><SUB><I>k</I></SUB><SUP>1−δ<SUB><I>k</I></SUB></SUP> <I>g</I><SUB><I>k</I>+1</SUB><SUP>δ<SUB><I>k</I></SUB></SUP>) et
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>g</I><SUB><I>k</I></SUB><SUP>δ<SUB><I>k</I>−1</SUB>+1</SUP> <I>A</I><SUB><I>k</I>−1</SUB> = <I>A</I><SUB><I>k</I></SUB> <I>Q</I><SUB><I>k</I>+1</SUB> + 
<I>g</I><SUB><I>k</I>−1</SUB> <I>h</I><SUB><I>k</I>−1</SUB><SUP>δ<SUB><I>k</I>−1</SUB></SUP> <I>A</I><SUB><I>k</I>+1</SUB> </TD></TR>
</TABLE><DIV CLASS="theorem"><B>Théorème 9</B>  <EM>
Le résultant est égal au signe près au coefficient </EM><EM><I>h</I></EM><SUB><EM><I>k</I></EM></SUB><EM> où </EM><EM><I>k</I></EM><EM>
correspond au reste </EM><EM><I>A</I></EM><SUB><EM><I>k</I></EM></SUB><EM> constant (en supposant que le résultant
soit non nul).
</EM></DIV><P><B>Preuve</B><BR>
La transcription de l’égalité précédente sur les
résultants donne par la méthode ci-dessus :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>g</I><SUB><I>k</I></SUB><SUP>(δ<SUB><I>k</I>−1</SUB>+1)<I>d</I><SUB><I>k</I></SUB></SUP>Res(<I>A</I><SUB><I>k</I>−1</SUB>,<I>A</I><SUB><I>k</I></SUB>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>−1</SUB>−<I>d</I><SUB><I>k</I>+1</SUB></SUP> Res(<I>g</I><SUB><I>k</I>−1</SUB> <I>h</I><SUB><I>k</I>−1</SUB><SUP>δ<SUB><I>k</I>−1</SUB></SUP> <I>A</I><SUB><I>k</I>+1</SUB>,<I>A</I><SUB><I>k</I></SUB>)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>−1</SUB>−<I>d</I><SUB><I>k</I>+1</SUB></SUP> (<I>g</I><SUB><I>k</I>−1</SUB> <I>h</I><SUB><I>k</I>−1</SUB><SUP>δ<SUB><I>k</I>−1</SUB></SUP>)<SUP><I>d</I><SUB><I>k</I></SUB></SUP>
Res(<I>A</I><SUB><I>k</I>+1</SUB>,<I>A</I><SUB><I>k</I></SUB>)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On en déduit que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">Res(<I>A</I><SUB><I>k</I>−1</SUB>,<I>A</I><SUB><I>k</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>g</I><SUB><I>k</I>−1</SUB><SUP><I>d</I><SUB><I>k</I></SUB></SUP> <I>h</I><SUB><I>k</I>−1</SUB><SUP><I>d</I><SUB><I>k</I>−1</SUB>−1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
= <I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>−1</SUB>−<I>d</I><SUB><I>k</I>+1</SUB>−(δ<SUB><I>k</I>−1</SUB>+1)<I>d</I><SUB><I>k</I></SUB></SUP>  
<I>h</I><SUB><I>k</I>−1</SUB><SUP>δ<SUB><I>k</I>−1</SUB><I>d</I><SUB><I>k</I></SUB>+1−<I>d</I><SUB><I>k</I>−1</SUB></SUP> Res(<I>A</I><SUB><I>k</I>+1</SUB>,<I>A</I><SUB><I>k</I></SUB>) </TD></TR>
</TABLE><P>
On observe que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>h</I><SUB><I>k</I>−1</SUB><SUP>δ<SUB><I>k</I>−1</SUB><I>d</I><SUB><I>k</I></SUB>+1−<I>d</I><SUB><I>k</I>−1</SUB></SUP> =<I>h</I><SUB><I>k</I>−1</SUB><SUP>(δ<SUB><I>k</I>−1</SUB>−1)(<I>d</I><SUB><I>k</I></SUB>−1)</SUP>
= </TD><TD CLASS="dcell">⎛<BR>
⎝</TD><TD CLASS="dcell"><I>h</I><SUB><I>k</I>−1</SUB><SUP>δ<SUB><I>k</I>−1</SUB>−1</SUP></TD><TD CLASS="dcell">⎞<BR>
⎠</TD><TD CLASS="dcell"><SUP><I>d</I><SUB><I>k</I></SUB>−1</SUP>
= </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>g</I><SUB><I>k</I></SUB><SUP>δ<SUB><I>k</I>−1</SUB></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>h</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>d</I><SUB><I>k</I></SUB>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">Res(<I>A</I><SUB><I>k</I>−1</SUB>,<I>A</I><SUB><I>k</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>g</I><SUB><I>k</I>−1</SUB><SUP><I>d</I><SUB><I>k</I></SUB></SUP> <I>h</I><SUB><I>k</I>−1</SUB><SUP><I>d</I><SUB><I>k</I>−1</SUB>−1</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>−1</SUB>−<I>d</I><SUB><I>k</I>+1</SUB>−(δ<SUB><I>k</I>−1</SUB>+1)<I>d</I><SUB><I>k</I></SUB></SUP>  
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>g</I><SUB><I>k</I></SUB><SUP>δ<SUB><I>k</I>−1</SUB></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>h</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>d</I><SUB><I>k</I></SUB>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
Res(<I>A</I><SUB><I>k</I>+1</SUB>,<I>A</I><SUB><I>k</I></SUB>) </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>−1</SUB>−<I>d</I><SUB><I>k</I>+1</SUB>−<I>d</I><SUB><I>k</I></SUB>−δ<SUB><I>k</I>−1</SUB></SUP>  
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>h</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>d</I><SUB><I>k</I></SUB>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
Res(<I>A</I><SUB><I>k</I>+1</SUB>,<I>A</I><SUB><I>k</I></SUB>) </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"> Res(<I>A</I><SUB><I>k</I>+1</SUB>,<I>A</I><SUB><I>k</I></SUB>) </TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"> <I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>+1</SUB></SUP> <I>h</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I></SUB>−1</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Donc en valeur absolue
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">Res(<I>A</I><SUB>0</SUB>,<I>A</I><SUB>1</SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>g</I><SUB>0</SUB><SUP><I>d</I><SUB>1</SUB></SUP> <I>h</I><SUB>0</SUB><SUP><I>d</I><SUB>0</SUB>−1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">|
= |</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">Res(<I>A</I><SUB><I>k</I>−1</SUB>,<I>A</I><SUB><I>k</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>g</I><SUB><I>k</I>−1</SUB><SUP><I>d</I><SUB><I>k</I></SUB></SUP> <I>h</I><SUB><I>k</I>−1</SUB><SUP><I>d</I><SUB><I>k</I>−1</SUB>−1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> |</TD></TR>
</TABLE><P>
En prenant le rang <I>k</I> tel que <I>A</I><SUB><I>k</I></SUB> est constant, on a <I>d</I><SUB><I>k</I></SUB>=0
et le résultant est égal à <I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>−1</SUB></SUP>, on obtient donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|Res(<I>A</I><SUB>0</SUB>,<I>A</I><SUB>1</SUB>)|=|</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>−1</SUB></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"> <I>h</I><SUB><I>k</I>−1</SUB><SUP><I>d</I><SUB><I>k</I>−1</SUB>−1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> |
</TD></TR>
</TABLE><P>
Comme ici δ<SUB><I>k</I>−1</SUB>=<I>d</I><SUB><I>k</I>−1</SUB>, le terme de droite est |<I>h</I><SUB><I>k</I></SUB>|.</P><P><B>Remarque</B><BR>
On peut calculer au fur et à mesure le signe du résultant en tenant 
compte des degrés de <I>A</I><SUB><I>k</I></SUB> pour inverser l’ordre de <I>A</I><SUB><I>k</I>−1</SUB> et
<I>A</I><SUB><I>k</I></SUB> dans le résultant.</P><P><B>Utilisation</B><BR>
La valeur du résultant est très utile pour savoir si 2 polynômes
dépendant de paramètres sont premiers entre eux en fonction
de la valeur des paramètres. En effet, la fonction <TT>gcd</TT> d’un
logiciel de calcul formel calculera le PGCD par rapport à toutes
les variables en incluant les paramètres. En cherchant quand le résultant
s’annule en fonction des paramètres on obtient un autre type
d’information.</P><P><B>Exemple :</B><BR>
Chercher quand le polynône <I>P</I>=<I>x</I><SUP>3</SUP>+<I>px</I>+<I>q</I> possède
une racine multiple en fonction de <I>p</I> et <I>q</I>. On calcule le
résultant de <I>P</I> et <I>P</I>′ et on trouve 4<I>p</I><SUP>3</SUP>+27<I>q</I><SUP>2</SUP>, donc <I>P</I>
a une racine multiple si et seulement si 4<I>p</I><SUP>3</SUP>+27<I>q</I><SUP>2</SUP>=0.</P><!--TOC subsection Calcul efficace du résultant-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc44">4.5</A>  Calcul efficace du résultant</H3><!--SEC END --><P>
On dispose essentiellement de deux stratégies avec des sous-stratégies :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Calcul comme un déterminant.
On peut utiliser des méthodes modulaires ou <I>p</I>-adiques (par exemple
si <I>A</I> et <I>B</I> sont à coefficients entiers), ou/et de l’interpolation
(si <I>A</I> et <I>B</I> sont à coefficients polynomiaux), ou la méthode
de Gauss-Bareiss, ou le développement de Laplace. Il suffit
de forcer une stratégie dans l’appel à <CODE>det</CODE> sur
<CODE>sylvester(A,B)</CODE>
</LI><LI CLASS="li-itemize">Algorithme du sous-résultant<BR>
C’est cet algorithme qui est utilisé par Xcas.
Il peut aussi se décliner en méthode modulaire ou avec interpolation.
</LI></UL><P>
Exemple de comparaison :<BR>
<CODE>n:=100; A:=randpoly(n):; B:=randpoly(n):;</CODE><BR>
<CODE>time(resultant(A,B)); time(det(sylvester(A,B)))</CODE></P><!--TOC section Localisation des racines-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc45">5</A>  Localisation des racines</H2><!--SEC END --><P> <A NAME="sec:racines"></A>
</P><!--TOC subsection Majoration-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc46">5.1</A>  Majoration</H3><!--SEC END --><P>
On a vu au lemme <A HREF="#lemme:majoration">4</A>, 
que si <I>z</I> est une racine complexe d’un polynôme <I>P</I> 
de coefficient dominant <I>p</I><SUB><I>n</I></SUB> alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>z</I>| ≤ 1 + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">|<I>P</I>|<SUB>∞</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">|<I>p</I><SUB><I>n</I></SUB>|</TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Les suites de Sturm.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc47">5.2</A>  Les suites de Sturm.</H3><!--SEC END --><P><A NAME="@default59"></A>
L’algorithme du sous-résultant appliqué à un polynôme sans
racine multiple <I>P</I> et à sa dérivée
permet, à condition de changer les signes dans la suite des restes, 
de connaitre le nombre de racines réelles d’un polynôme 
à coefficients réels dans un 
intervalle. Ceci est trè utile pour par exemple simplifier des valeurs
absolues de polynômes dans un intervalle.</P><P>On définit donc la suite de polynômes <I>A</I><SUB>0</SUB>=<I>P</I>, <I>A</I><SUB>1</SUB>=<I>P</I>′, ..., <I>A</I><SUB><I>k</I></SUB>,0
par :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:sturm"></A>
<I>A</I><SUB><I>i</I></SUB> = <I>A</I><SUB><I>i</I>+1</SUB> <I>Q</I><SUB><I>i</I>+2</SUB> − <I>A</I><SUB><I>i</I>+2</SUB> 
    (12)</TD></TR>
</TABLE><P>
avec <I>A</I><SUB><I>k</I></SUB>, le dernier reste non nul, un polynôme constant puisque
<I>P</I> n’a pas de racine multiple. On utilise plutot l’algorithme du 
sous-résultant que l’algorithme d’Euclide, il faut alors
s’assurer que les signes de <I>A</I><SUB><I>i</I></SUB> et <I>A</I><SUB><I>i</I>+2</SUB> sont opposés lorsque
<I>A</I><SUB><I>i</I>+1</SUB>  s’annule quitte à changer le signe de <I>A</I><SUB><I>i</I>+2</SUB> en fonction
du signe du coefficient dominant de <I>A</I><SUB><I>i</I>+1</SUB>, de la parité de
la différence des degrés et du signe du coefficient <I>gh</I><SUP>1−δ</SUP>.</P><P>On définit <I>s</I>(<I>a</I>) comme étant le nombre de changements de signes
de la suite <I>A</I><SUB><I>i</I></SUB>(<I>a</I>) en ignorant les 0.
On a alors le 
</P><DIV CLASS="theorem"><B>Théorème 10</B>  <EM>
Le nombre de racines réelles de </EM><EM><I>A</I></EM><SUB><EM>0</EM></SUB><EM>=<I>P</I></EM><EM> sur l’intervalle
</EM><EM>]<I>a</I>,<I>b</I>]</EM><EM> est égal à </EM><EM><I>s</I>(<I>a</I>)−<I>s</I>(<I>b</I>)</EM><EM>.
</EM></DIV><P><B>Preuve</B><BR>
Par continuité de la suite des polynômes, <I>s</I> ne peut varier que
si l’un des polynômes s’annule.
On considére la suite des signes en un point : elle ne peut contenir
deux 0 successifs (sinon toute la suite vaudrait 0 en ce point en appliquant
(<A HREF="#eq:sturm">12</A>), or <I>A</I><SUB><I>k</I></SUB> est constant non nul). Elle ne peut pas
non plus contenir +,0,+ ni -,0,- à cause de la convention de signe
sur les restes de (<A HREF="#eq:sturm">12</A>). Donc une racine <I>b</I>
de <I>A</I><SUB><I>i</I></SUB> pour 0&lt;<I>i</I>&lt;<I>k</I>, n’influe pas sur la valeur de <I>s</I> au voisinage
de <I>b</I> (il y a toujours un changement de signe entre les positions
<I>i</I>−1 et <I>i</I>+1). Comme <I>A</I><SUB><I>k</I></SUB> est constant, seules les racines de <I>A</I><SUB>0</SUB>=<I>P</I>
sont susceptibles de faire varier <I>s</I>. Comme <I>A</I><SUB>1</SUB>=<I>P</I>′, le sens de
variations de <I>A</I><SUB>0</SUB> au voisinage d’une racine de <I>A</I><SUB>0</SUB> est déterminé
par le signe de <I>A</I><SUB>1</SUB>, donc les possibilités sont -,+ vers +,+
ou +,- vers -,-, ce qui diminue <I>s</I> d’une unité.</P><!--TOC subsection Autres algorithmes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc48">5.3</A>  Autres algorithmes</H3><!--SEC END --><P> <A NAME="sec:autres_algorithmes"></A>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
On peut localiser les racines réelles par dichotomie : on
sait que toutes les racines sont situées dans l’intervalle
[−<I>C</I>,<I>C</I>] avec <I>C</I>=|<I>P</I>|<SUB>∞</SUB>/|lcoeff(<I>P</I>)|. On coupe
l’intervalle en deux, on calcule le nombre de racines
dans chaque partie, et on continue en conservant uniquement
les intervalles contenant au moins une racine. Lorsqu’un
intervalle contient une seule racine, on passe à la dichotomie
classique (changement de signe), ou à la méthode de Newton
(avec évaluation exacte du polymôme et arrondi du dénominateur
à une puissance de 2). C’est ce qui est utilisé par
l’instruction <CODE>realroot</CODE> de Giac.
</LI><LI CLASS="li-itemize">Il existe un autre algorithme de localisation de racines
réelles dû à <B>Vincent, Akritas et 
Strzebonski</B><A NAME="@default60"></A><A NAME="@default61"></A><A NAME="@default62"></A>, cf. la
commande <CODE>VAS</CODE> de Xcas. Cet algorithme est très
efficace pour donner des intervalles d’<B>isolation</B><A NAME="@default63"></A> des racines
(sur lesquels on peut faire de la dichotomie).
</LI><LI CLASS="li-itemize">Ces suites se générallisent dans le plan complexe, on
peut déterminer le nombre de racines contenues dans un
rectangle du plan complexe (cf. par exemple l’article
de Mickael Eiserman sur <CODE>www-fourier.ujf-grenoble.fr/~eiserm</CODE>). 
Malheureusement, il faut calculer une nouvelle suite de Sturm
pour chaque rectangle (alors que dans ℝ on peut réutiliser la
même suite de Sturm). Ce qui est donc beaucoup plus couteux,
en pratique on ne peut guère aller au-delà du degré 10 avec
l’instruction <CODE>complexroot</CODE> de Giac, analogue de <CODE>realroot</CODE>.
</LI><LI CLASS="li-itemize">Une autre méthode dans le cas complexe, 
peut-être plus prometteuse, consisterait à utiliser
un hybride numérique-exact. Les racines d’un polynôme <I>Q</I>
sont aussi les valeurs
propres complexes de sa matrice companion <I>M</I>. On peut alors 
par une méthode itérative (on pose <I>A</I><SUB>0</SUB>=<I>M</I>, puis on 
factorise <I>A</I><SUB><I>n</I></SUB>=<I>QR</I> par la méthode de Hessenberg et on définit
<I>A</I><SUB><I>n</I>+1</SUB>=<I>RQ</I>), factoriser cette matrice 
sous forme de Schur: <I>M</I>=<I>P</I><SUP>−1</SUP> <I>S</I> <I>P</I> où <I>P</I> est unitaire
et S diagonale supérieure aux erreurs d’arrondis près. 
On peut calculer un minorant de <I>m</I> ≤ |<I>Q</I>′(<I>z</I>)/<I>Q</I>(<I>z</I>)| 
pour <I>z</I> racine complexe approchée (coefficient
diagonal de <I>Q</I>). On a alors au moins
une racine de <I>Q</I> dans le disque de centre <I>z</I> 
et de rayon degre(<I>Q</I>)/<I>m</I>, car
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>Q</I>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>Q</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>z</I>)= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>z</I>−<I>z</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE>
donc si |<I>z</I>−<I>z</I><SUB><I>k</I></SUB>| &gt; degre(<I>Q</I>)/<I>m</I> pour toutes les racines <I>z</I><SUB><I>k</I></SUB> alors
|<I>Q</I>′/<I>Q</I>(<I>z</I>)| &gt; <I>m</I> contradiction. Si les disques obtenus sont
disjoints, on a ainsi une localisation des racines complexes.
On peut aussi utiliser l’arithmétique d’intervalles pour
essayer de trouver un petit rectangle autour d’une racine approchée
qui est conservé par la méthode de Newton <I>g</I>(<I>x</I>)=<I>x</I>−<I>f</I>(<I>x</I>)/<I>f</I>′(<I>x</I>),
le théorème du point fixe de Brouwer assure alors qu’il admet
un point fixe qui n’est autre qu’une racine de <I>g</I>.
</LI></UL><!--TOC section Exercices (PGCD, résultant, ...)-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc49">6</A>  Exercices (PGCD, résultant, ...)</H2><!--SEC END --><!--TOC subsection Instructions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc50">6.1</A>  Instructions</H3><!--SEC END --><P>
Elles sont dans les menus
Cmds-&gt;Integer et Cmds-&gt;Polynomes de <CODE>Xcas</CODE>.
</P><!--TOC subsubsection Entiers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc51">6.1.1</A>  Entiers</H4><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>chrem</CODE> :
restes chinois (entier)
</LI><LI CLASS="li-itemize"><CODE>divisors</CODE>
(en maple <CODE>numtheory::divisors</CODE> :
liste des diviseurs d’un entier
</LI><LI CLASS="li-itemize"><CODE>gcd, lcm</CODE> : PGCD et PPCM
</LI><LI CLASS="li-itemize"><CODE>igcdex</CODE>: Bézout pour des entiers
</LI><LI CLASS="li-itemize"><CODE>iquo</CODE> et <CODE>irem</CODE> quotient et reste de la division 
euclidienne de deux entiers
</LI><LI CLASS="li-itemize"><CODE>isprime</CODE> test de primalité. 
Utiliser <CODE>is_pseudoprime</CODE> pour effectuer un test plus rapide
de pseudo-primalité.
</LI><LI CLASS="li-itemize"><CODE>mods</CODE>: reste euclidien symétrique
</LI><LI CLASS="li-itemize"><CODE>nextprime</CODE> et <CODE>prevprime</CODE> 
nombre premier suivant ou précédent
</LI><LI CLASS="li-itemize"><CODE>powmod(a,b,n)</CODE> calcul de <I>a</I><SUP><I>b</I></SUP> (mod <I>n</I> ) par
l’algorithme de la puissance rapide
</LI></UL><!--TOC subsubsection Polynômes-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc52">6.1.2</A>  Polynômes</H4><!--SEC END --><P>
On peut représenter les polynômes par leur écriture symbolique
(par exemple <CODE>x^2+1</CODE>), ou par des listes (représentation dense
ou creuse, récursive ou distribuée). 
Xcas propose deux types
de représentation, dense à une variable (<CODE>poly1[ ]</CODE>), ou
distribuée (<CODE>%%%{ }%%%</CODE>) et des instructions de conversion
(<CODE>poly2symb</CODE> et <CODE>symb2poly</CODE>) entre représentations.
L’intérêt d’une représentation
non symbolique est l’efficacité des opérations polynomiales, (et la
possibilité de chronométrer des opérations comme le produit
de 2 polynômes).</P><P>Les instructions qui suivent
utilisent la représentation symbolique, certaines acceptent
les autres représentations.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>coeff</CODE> coefficient(s) d’un polynôme, 
</LI><LI CLASS="li-itemize"><CODE>coeffs</CODE> liste des coefficients d’un polynôme
(à développer auparavant, en mupad on utilise <CODE>coeff</CODE>)
</LI><LI CLASS="li-itemize"><CODE>content</CODE> contenu (pgcd des coefficients)
</LI><LI CLASS="li-itemize"><CODE>degree</CODE> degré
</LI><LI CLASS="li-itemize"><CODE>divide</CODE> division euclidienne, 
</LI><LI CLASS="li-itemize"><CODE>gcd, lcm</CODE> PGCD et PPCM
</LI><LI CLASS="li-itemize"><CODE>gcdex</CODE> Bézout, 
</LI><LI CLASS="li-itemize"><CODE>genpoly</CODE> :
crée un polynôme à partir de la
représentation <I>z</I>-adique d’un entier (utile pour le PGCD heuristique) 
</LI><LI CLASS="li-itemize"><CODE>icontent</CODE>: contenu entier pour un polynôme à plusieurs
variables
</LI><LI CLASS="li-itemize"><CODE>indets</CODE>: 
liste des noms de variables d’une expression
</LI><LI CLASS="li-itemize"><CODE>lcoeff</CODE>: coefficient dominant d’un polynôme
</LI><LI CLASS="li-itemize"><CODE>ldegree</CODE>: valuation
</LI><LI CLASS="li-itemize"><CODE>primpart</CODE>: partie primitive d’un polynôme
</LI><LI CLASS="li-itemize"><CODE>quo</CODE>, <CODE>rem</CODE> quotient et reste euclidien
</LI><LI CLASS="li-itemize"><CODE>tcoeff</CODE>: coefficient de plus bas degré d’un polynôme
</LI><LI CLASS="li-itemize"><CODE>interp</CODE> 
interpolation de Lagrange
</LI><LI CLASS="li-itemize"><CODE>convert(.,sqrfree)</CODE> 
décomposition en facteurs n’ayant pas de racine multiples
</LI><LI CLASS="li-itemize"><CODE>convert(.,parfrac)</CODE> 
décomposition en éléments simples
</LI><LI CLASS="li-itemize"><CODE>resultant</CODE> :
calcule le résultant de 2 polynômes par rapport à une variable.
</LI><LI CLASS="li-itemize"><CODE>sturm~</CODE>: suites de Sturm, <CODE>sturmab</CODE> :
nombre de racines dans un intervalle réel ou un rectangle
du plan complexe.
</LI></UL><P>Notez aussi que le menu <CODE>Exemples-&gt;poly-&gt;pgcd.xws</CODE> de Xcas contient 
des exemples de programmes de calcul de pgcd de type Euclide.</P><!--TOC subsubsection Calculs modulo <I>n</I>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc53">6.1.3</A>  Calculs modulo <I>n</I></H4><!--SEC END --><P>
Pour travailler dans ℤ/<I>n</I>ℤ[<I>X</I>] :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
avec <CODE>Xcas</CODE> on utilise la notation % comme en C, par
exemple <TT>gcd(P % 3, Q % 3)</TT>. On peut aussi utiliser la notation
Maple en mode “syntaxe Maple” (cf. ci-dessous)
</LI><LI CLASS="li-itemize">en mode compatible Maple,
on utilise les formes inertes des instructions (qui renvoient l’instruction
non évaluée), dont le nom est le même que le nom de commande
habituel mais précédé par une majuscule, puis on indique
<CODE>mod n</CODE>, par exemple <CODE>Gcd(P,Q) mod 11</CODE>.
</LI></UL><!--TOC subsection Exercices PGCD-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc54">6.2</A>  Exercices PGCD</H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Calculez le pgcd de <I>x</I><SUP>202</SUP>+<I>x</I><SUP>101</SUP>+1
et sa dérivée modulo 3 et modulo 5. Conclusion?</LI><LI CLASS="li-enumerate"><I>P</I>=51<I>x</I><SUP>3</SUP>−35<I>x</I><SUP>2</SUP>+39<I>x</I>−115 et <I>Q</I>=17<I>x</I><SUP>4</SUP>−23<I>x</I><SUP>3</SUP>+34<I>x</I><SUP>2</SUP>+39<I>x</I>−115.
Calculez le pgcd de <I>P</I> et <I>Q</I> modulo 5, 7 et 11. En déduire
le pgcd de <I>P</I> et <I>Q</I> par le théorème des restes chinois. Pourquoi
ne doit-on pas essayer modulo 17?</LI><LI CLASS="li-enumerate">Écrire un programme qui détermine le degré probable
du pgcd de 2 polynômes en une variable en utilisant le pgcd modulaire 
(on considère le degré probable déterminé lorsqu’on trouve
deux nombres premiers réalisant le minimum des degrés trouvés)</LI><LI CLASS="li-enumerate">Détaillez l’algorithme du PGCD heuristique pour les
polynômes <I>P</I>=(<I>x</I>+1)<SUP>7</SUP>−(<I>x</I>−1)<SUP>6</SUP> et sa dérivée. Comparez avec l’algorithme
d’Euclide naïf.</LI><LI CLASS="li-enumerate">Écrire un programme mettant en oeuvre le pgcd heuristique
pour des polynômes à une variable.</LI><LI CLASS="li-enumerate">On veut comprendre comment un logiciel de calcul formel calcule
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>6</SUP>+2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>x</I><SUP>3</SUP>+1)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dx</I> </TD></TR>
</TABLE>
On se ramène d’abord à une fraction propre (numérateur <I>N</I> de degré 
inférieur au dénominateur),
Soit <I>P</I>=<I>x</I><SUP>3</SUP>+1, calculez le PGCD de <I>P</I> et <I>P</I>′, puis
deux polynômes <I>U</I> et <I>V</I> tels que  <I>N</I>=<I>UP</I>+<I>VP</I>′ .
On décompose alors l’intégrale en deux morceaux :<BR>
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>U</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  + </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><I>V</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD></TR>
</TABLE>
Faites une intégration par parties sur le deuxième terme
et en déduire la valeur de l’intégrale du départ.</LI><LI CLASS="li-enumerate">Écrire un programme qui détermine le degré probable du PGCD 
par rapport à toutes les
variables de 2 polynôme à plusieurs variables
en utilisant l’évaluation en toutes les variables
sauf une.</LI><LI CLASS="li-enumerate">Calculer le pgcd par une méthode modulaire de
(<I>xy</I>−<I>x</I>+1)(<I>xy</I>+<I>x</I><SUP>2</SUP>+1) et (<I>xy</I>−<I>x</I>−<I>y</I>)(<I>xy</I>−<I>x</I>+1)</LI><LI CLASS="li-enumerate">En utilisant uniquement l’instruction de calcul de PGCD
déterminer la multiplicité maximale d’un facteur irréductible
de 
<I>x</I><SUP>14</SUP>−<I>x</I><SUP>13</SUP>−14<I>x</I><SUP>12</SUP>+12<I>x</I><SUP>11</SUP>+78<I>x</I><SUP>10</SUP>−54<I>x</I><SUP>9</SUP>−224<I>x</I><SUP>8</SUP>+116<I>x</I><SUP>7</SUP>+361<I>x</I><SUP>6</SUP>−129<I>x</I><SUP>5</SUP>−330<I>x</I><SUP>4</SUP>+72<I>x</I><SUP>3</SUP>+160<I>x</I><SUP>2</SUP>−16<I>x</I>−32</LI></OL><!--TOC subsection Exercices (résultant)-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc55">6.3</A>  Exercices (résultant)</H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Pour quelles valeurs de <I>p</I> le polynôme <I>X</I><SUP>5</SUP>+<I>X</I><SUP>3</SUP>−<I>pX</I>+1 admet-il
une racine multiple?
</LI><LI CLASS="li-enumerate">Résoudre le système en éliminant successivement les
variables grâce au résultant :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎧<BR>
⎪<BR>
⎨<BR>
⎪<BR>
⎩</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>a</I><SUP>3</SUP>+<I>b</I><SUP>3</SUP>+<I>c</I><SUP>3</SUP></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>8 </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>a</I><SUP>2</SUP>+<I>b</I><SUP>2</SUP>+<I>c</I><SUP>2</SUP></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>6 </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>a</I>+<I>b</I>+2<I>c</I></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>4</TD></TR>
</TABLE></TD></TR>
</TABLE>
</LI><LI CLASS="li-enumerate">Déterminer l’intersection de <I>xy</I>=4 et  <I>y</I><SUP>2</SUP>=(<I>x</I>−3)(<I>x</I><SUP>2</SUP>−16),
repésenter graphiquement les courbes. Discuter la multiplicité
et le nombre d’intersections.<BR>
Même question pour (<I>x</I>−2)<SUP>2</SUP>+<I>y</I><SUP>2</SUP>=4 et <I>y</I><SUP>2</SUP>=(<I>x</I>−3)(<I>x</I><SUP>2</SUP>−16).
</LI><LI CLASS="li-enumerate">Donner le détail des calculs avec Bézout de la décomposition
en éléments simples de :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>x</I><SUP>2</SUP>−1)<SUP>2</SUP>(<I>x</I>+2)</TD></TR>
</TABLE></TD></TR>
</TABLE>
puis calculer le coefficient de <I>x</I><SUP><I>n</I></SUP> du développement en séries
entières de cette fraction en 0.
</LI><LI CLASS="li-enumerate">Calculer 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1−<I>x</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+<I>x</I><SUP>4</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dx</I> </TD></TR>
</TABLE>
en utilisant le résultant pour calculer les logarithmes.
</LI><LI CLASS="li-enumerate">Courbe paramétrique dépendant d’un paramètre :
on considère la courbe <I>C</I><SUB><I>m</I></SUB> dépendant du réel <I>m</I> :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>(<I>t</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I>+<I>m</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP>+1+<I>m</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">,    <I>y</I>(<I>t</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I>−<I>m</I></TD></TR>
</TABLE></TD></TR>
</TABLE>
Représenter la courbe pour quelques valeurs de <I>m</I> (on pourra
utiliser dans un niveau de géométrie, le menu Edit, Ajouter un
paramètre pour créer un curseur représentant <I>m</I>, puis 
<CODE>plotparam</CODE>). Donner l’équation cartésienne de <I>C</I><SUB><I>m</I></SUB>.
Déterminer les valeurs de <I>m</I> pour lesquelles
la courbe admet un point singulier, représenter le graphe dans ce(s)
cas et faire l’étude de la courbe.
</LI></OL><!--TOC subsection Exercice (Bézout modulaire)-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc56">6.4</A>  Exercice (Bézout modulaire)</H3><!--SEC END --><P>
Soit <I>A</I> et <I>B</I> deux polynômes à coefficients entiers et premiers
entre eux. Soit <I>c</I> ∈ ℤ<SUP>*</SUP>  le résultant de <I>A</I> et <I>B</I>,
on va calculer les polynômes <I>U</I> et <I>V</I> de l’identité de Bézout 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:bezoutmod"></A>
<I>A</I> <I>U</I> + <I>B</I> <I>V</I> = <I>c</I> ,    deg(<I>U</I>)&lt;deg(<I>B</I>), deg(<I>V</I>)&lt;deg(<I>A</I>)
    (13)</TD></TR>
</TABLE><P>
par une méthode modulaire.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Montrer, en utilisant les formules de Cramer,
que les coefficients de <I>U</I> et <I>V</I> sont des entiers de
valeur absolue inférieure ou égale à la borne de Hadamard <I>h</I> de
la matrice de Sylvester de <I>A</I> et <I>B</I> (dont le déterminant est <I>c</I>,
le résultant de <I>A</I> et <I>B</I>). Calculer <I>h</I> en fonction
de la norme euclidienne de <I>A</I>, <I>B</I> et de leurs degrés. 
</LI><LI CLASS="li-enumerate">On calcule <I>c</I> ∈ ℤ<SUP>*</SUP> puis on
résoud (<A HREF="#eq:bezoutmod">13</A>) dans ℤ/<I>p</I><SUB><I>i</I></SUB> <I>Z</I>[<I>X</I>] pour
plusieurs nombres premiers <I>p</I><SUB><I>i</I></SUB> (choisis si possible inférieurs 
à √<SPAN style="text-decoration:overline">2</SPAN><SUP><SPAN style="text-decoration:overline">31</SPAN></SUP> pour des raisons d’efficacité), puis on calcule par le
théorème des restes chinois (<A HREF="#eq:bezoutmod">13</A>) 
dans ℤ/∏<I>p</I><SUB><I>i</I></SUB> <I>Z</I>[<I>X</I>]. Donner une minoration de 
∏<SUB><I>i</I></SUB> <I>p</I><SUB><I>i</I></SUB> faisant intervenir <I>h</I> qui permette de garantir
que l’écriture en représentation symétrique de (<A HREF="#eq:bezoutmod">13</A>)
dans ℤ/∏<I>p</I><SUB><I>i</I></SUB> <I>Z</I>[<I>X</I>] est identique à (<A HREF="#eq:bezoutmod">13</A>) dans ℤ[<I>X</I>].
</LI><LI CLASS="li-enumerate">Application : résoudre de cette manière l’équation de
Bézout pour 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=(<I>X</I>+1)<SUP>4</SUP>(<I>X</I>−3),    <I>B</I>=(<I>X</I>−1)<SUP>4</SUP>(<I>X</I>+2)</TD></TR>
</TABLE> 
(vous pouvez utiliser
sans justifications l’instruction de calcul de résultant,
des coefficients de Bézout dans ℤ/<I>p</I><SUB><I>i</I></SUB><I>Z</I>[<I>X</I>] et 
de reste chinois de votre logiciel).
</LI><LI CLASS="li-enumerate">Écrire une fonction mettant en oeuvre cet algorithme.
</LI><LI CLASS="li-enumerate">Que pensez-vous de l’intérêt de cet algorithme par rapport à
l’algorithme d’Euclide étendu dans ℤ[<I>X</I>]?
</LI></OL><!--TOC subsection Exercice (Géométrie et résultants).-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc57">6.5</A>  Exercice (Géométrie et résultants).</H3><!--SEC END --><P>
On cherche une relation algébrique entre les coordonnées de 4 points
<I>A</I>,<I>B</I>,<I>C</I>,<I>D</I> qui traduise le fait que ces 4 points sont cocycliques. Cette
condition étant invariante par translation, on cherche une
relation entre les 6 coordonnées des 3 vecteurs <I>v</I><SUB>1</SUB>=(<I>x</I><SUB>1</SUB>,<I>y</I><SUB>1</SUB>), 
<I>v</I><SUB>2</SUB>=(<I>x</I><SUB>2</SUB>,<I>y</I><SUB>2</SUB>) et <I>v</I><SUB>3</SUB>=(<I>x</I><SUB>3</SUB>,<I>y</I><SUB>3</SUB>) 
d’origine <I>A</I> et d’extrémité <I>B</I>, <I>C</I> et <I>D</I>.
On peut supposer quitte à translater que le centre du cercle est
l’origine, on a donc 5 paramètres : le rayon du cercle <I>R</I> et les
4 angles des points sur le cercle θ<SUB>0</SUB>, θ<SUB>1</SUB>, θ<SUB>2</SUB> et
θ<SUB>3</SUB>. La relation cherchée va s’obtenir en éliminant les
5 paramètres des expressions des 6 coordonnées en fonction de
ces paramètres.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Exprimer les 6 coordonnées en fonction de 
<I>R</I> et <I>a</I>=tan(θ<SUB>0</SUB>/2), <I>b</I>=tan(θ<SUB>1</SUB>/2), <I>c</I>=tan(θ<SUB>2</SUB>/2)
et <I>d</I>=tan(θ<SUB>3</SUB>/2). On obtient ainsi 6 équations, par exemple les
deux premières sont de la forme
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I><SUB>1</SUB>− <I>F</I>(<I>R</I>,<I>a</I>,<I>b</I>)= 0,    <I>y</I><SUB>1</SUB>− <I>G</I>(<I>R</I>,<I>a</I>,<I>b</I>)= 0 </TD></TR>
</TABLE>
où <I>F</I> et <I>G</I> sont deux fractions rationnelles.
</LI><LI CLASS="li-enumerate">En réduisant au même dénominateur, calculer 6 
polynômes, fonction de
<I>x</I><SUB>1</SUB>,<I>y</I><SUB>1</SUB>,<I>x</I><SUB>2</SUB>,<I>y</I><SUB>2</SUB>,<I>x</I><SUB>3</SUB>,<I>y</I><SUB>3</SUB>,<I>R</I>,<I>a</I>,<I>b</I>,<I>c</I>,<I>d</I>, qui doivent s’annuler
pour que les points soient cocycliques
(Vous pouvez utiliser l’instruction <CODE>numer</CODE> pour obtenir le
numérateur d’une fraction rationnelle).
</LI><LI CLASS="li-enumerate">Éliminer <I>b</I> des polynômes
contenant <I>x</I><SUB>1</SUB> et <I>y</I><SUB>1</SUB> et factoriser
le polynôme obtenu, faire de même avec <I>c</I>, <I>x</I><SUB>2</SUB> et <I>y</I><SUB>2</SUB>
et <I>d</I>, <I>x</I><SUB>3</SUB> et <I>y</I><SUB>3</SUB>, en déduire (en supposant que les points sont
tous distincts) 3 polynômes en <I>x</I><SUB>1</SUB>,<I>y</I><SUB>1</SUB>,<I>x</I><SUB>2</SUB>,<I>y</I><SUB>2</SUB>,<I>x</I><SUB>3</SUB>,<I>y</I><SUB>3</SUB>,<I>R</I>,<I>a</I> qui
s’annulent.
</LI><LI CLASS="li-enumerate">Éliminer <I>R</I> et <I>a</I>, en déduire la relation cherchée.
</LI><LI CLASS="li-enumerate">Vérifier que cette relation est équivalente à la nullité
de la partie imaginaire du birapport des affixes α, β, γ,
δ des 4 points :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ℑ </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">α−β</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">α−γ</TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">δ−γ</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">δ−β</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">= 0</TD></TR>
</TABLE>
</LI></OL><!--TOC subsection Décalage entier entre racines.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc58">6.6</A>  Décalage entier entre racines.</H3><!--SEC END --><P>
Soit <I>P</I> un polynôme à coefficients entiers sans racines multiples. 
On dira que <I>P</I> a la propriété <FONT COLOR=red><I>I</I></FONT> si
deux des racines de <I>P</I> sont décalées d’un entier. 
En d’autres termes, si <I>r</I><SUB>1</SUB>,...,<I>r</I><SUB><I>n</I></SUB> désignent
les racines complexes distinctes de <I>P</I>, <I>P</I> possède la
propriété <FONT COLOR=red><I>I</I></FONT>
s’il existe 
au moins un entier parmi les différences <I>r</I><SUB><I>i</I></SUB>−<I>r</I><SUB><I>j</I></SUB> pour <I>i</I> ≠ <I>j</I>. 
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Soit
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>R</I>(<I>t</I>)=resultant<SUB><I>x</I></SUB>(<I>P</I>(<I>x</I>),<I>P</I>(<I>x</I>+<I>t</I>)) </TD></TR>
</TABLE>
Montrer que <I>R</I> est à coefficients entiers.
Montrer que la propriété <FONT COLOR=red><I>I</I></FONT> est équivalente à
la propriété “<I>R</I> possède une racine entière non nulle”.
On va maintenant construire un algorithme déterminant les racines
entières du polynôme <I>R</I>.
</LI><LI CLASS="li-enumerate">Après division de <I>R</I> par une puissance de <I>t</I>, on peut
supposer que <I>R</I> a un coefficient constant non nul. Après division de
<I>R</I> par son contenu, on peut aussi supposer
que le contenu de <I>R</I> est 1. En effectuant ensuite une factorisation
square-free de <I>R</I>, on peut se ramener au cas où <I>R</I> et <I>R</I>′ sont
premiers entre eux.
Soit <I>a</I> une racine de <I>R</I>.
<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
Donner une majoration de |<I>a</I>| 
en fonction du coefficient constant de <I>R</I>.
</LI><LI CLASS="li-enumerate">Soit <I>p</I> un nombre premier ne divisant pas le coefficient dominant
de <I>R</I> et tel que <I>R</I> et <I>R</I>′ soient premiers entre eux modulo <I>p</I>. 
On peut calculer <I>a</I> à partir d’une racine
de <I>R</I> modulo <I>p</I> en la “remontant” modulo <I>p</I><SUP><I>k</I></SUP> pour <I>k</I>
assez grand (algorithme p-adique). Pour quelle valeur de <I>k</I> peut-on
reconstruire toutes les racines entières de <I>R</I> ? 
</LI><LI CLASS="li-enumerate">Comparer l’algorithme ci-dessus avec les algorithmes suivants :
la factorisation de <I>R</I> sur ℤ, 
la recherche numérique des racines complexes de <I>R</I>,
la recherche des racines entières de <I>R</I> parmi les diviseurs 
entiers du coefficient constant de <I>R</I> et leurs opposés.
</LI></OL>
</LI><LI CLASS="li-enumerate">Une fois les racines entières de <I>R</I> connues, comment
peut-on en déduire les facteurs de <I>P</I> dont les racines diffèrent
de cet(ces) entier(s)?
</LI><LI CLASS="li-enumerate">Soit 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>x</I>)=<I>x</I><SUP>6</SUP>+9<I>x</I><SUP>5</SUP>+29<I>x</I><SUP>4</SUP>+41<I>x</I><SUP>3</SUP>+37 <I>x</I><SUP>2</SUP>+59<I>x</I>+31</TD></TR>
</TABLE>
Montrer que <I>P</I> a la propriété <FONT COLOR=red><I>I</I></FONT>. Calculer
la ou les racines entières de <I>R</I> et donner la factorisation
correspondante de <I>P</I>. 
</LI><LI CLASS="li-enumerate">Écrire un programme qui effectue cet algorithme sur un
polynôme quelconque. On pourra utiliser la fonction 
<CODE>rationalroot</CODE> de Xcas pour déterminer les racines
entières de <I>R</I>.
</LI><LI CLASS="li-enumerate">Application : on cherche à calculer
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq"></A>
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−9<I>x</I><SUP>2</SUP>−27<I>x</I>−30</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I>(<I>x</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">
    (14)</TD></TR>
</TABLE>
Décomposer cette fraction
en éléments simples (donner le détail des calculs en utilisant
la factorisation précédente et l’identité de Bezout 
<CODE>abcuv</CODE> en Xcas). 
</LI><LI CLASS="li-enumerate">Calculer la somme précédente (<A HREF="#eq">14</A>).
On pourra remarquer que pour <I>k</I> entier strictement positif,
1/<I>f</I>(<I>x</I>+<I>k</I>)−1/<I>f</I>(<I>x</I>)
s’exprime comme une somme de différences 
1/<I>f</I>(<I>x</I>+<I>j</I>+1)−1/<I>f</I>(<I>x</I>+<I>j</I>).
</LI><LI CLASS="li-enumerate">Écrire un programme effectuant ce calcul avec une fraction
quelconque, lorsque cela est possible.
</LI></OL><!--TOC subsection Exemple de correction de géométrie et résultant-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc59">6.7</A>  Exemple de correction de géométrie et résultant</H3><!--SEC END --><PRE CLASS="verbatim">e1:=x1-R*((1-b^2)/(1+b^2)-(1-a^2)/(1+a^2));
e2:=y1-R*(2b/(1+b^2)-2*a/(1+a^2));
e3:=x2-R*((1-c^2)/(1+c^2)-(1-a^2)/(1+a^2));
e4:=y2-R*(2c/(1+c^2)-2*a/(1+a^2));
e5:=x3-R*((1-d^2)/(1+d^2)-(1-a^2)/(1+a^2));
e6:=y3-R*(2d/(1+d^2)-2*a/(1+a^2));
f1:=factor(resultant(numer(e1),numer(e2),b)/
 (-4)/(a^2+1)^3/R^2);
f2:=factor(resultant(numer(e3),numer(e4),c)/
 (-4)/(a^2+1)^3/R^2);
f3:=factor(resultant(numer(e5),numer(e6),d)/
 (-4)/(a^2+1)^3/R^2);
g1:=factor(resultant(f1,f2,R));
g2:=resultant(f1,f3,R);
r:=factor(resultant(g1/(a^2+1),g2/(a^2+1),a));
eq1:=r[1,3,1];
eq2:=numer(im((-x1-i*y1)/(-x2-i*y2)*
 (x3-x2+i*(y3-y2))/(x3-x1+i*(y3-y1))));
normal(eq1-eq2);
</PRE><!--TOC section Bases de Gröbner.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc60">7</A>  Bases de Gröbner.</H2><!--SEC END --><P> <A NAME="sec:groebner"></A> <A NAME="@default64"></A> <A NAME="@default65"></A>
</P><!--TOC subsection Ordre et réduction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc61">7.1</A>  Ordre et réduction</H3><!--SEC END --><P><A NAME="@default66"></A> <A NAME="@default67"></A>
L’anneau des polynômes à plusieurs variables n’a pas de division
euclidienne. On est donc obligé d’utiliser des outils moins
performants.
La première chose à faire est de choisir un ordre total sur les monomes,
compatible avec la multiplication des monômes 
(<I>a</I>&lt;<I>b</I> doit entrainer <I>a</I> <I>c</I>&lt;<I>b</I> <I>c</I>) et tel que si un monôme <I>a</I> divise
un autre monôme <I>b</I> alors <I>a</I>&lt;<I>b</I>. 
Exemples d’ordres utilisés
fréquemment (ce sont les 3 ordres proposés par les fonctions
de Xcas) :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
l’<B>ordre lexicographique</B> <CODE>plex</CODE><A NAME="@default68"></A>
(<I>a</I><SUB>1</SUB>,<I>a</I><SUB>2</SUB>,..,<I>a</I><SUB><I>n</I></SUB>)&gt;(<I>b</I><SUB>1</SUB>,...,<I>b</I><SUB><I>n</I></SUB>) si <I>a</I><SUB>1</SUB>&gt;<I>b</I><SUB>1</SUB> ou si <I>a</I><SUB>1</SUB>=<I>b</I><SUB>1</SUB> et
<I>a</I><SUB>2</SUB>&gt;<I>b</I><SUB>2</SUB> ou si <I>a</I><SUB>1</SUB>=<I>b</I><SUB>1</SUB>, <I>a</I><SUB>2</SUB>=<I>b</I><SUB>2</SUB> et <I>a</I><SUB>3</SUB>&gt;<I>b</I><SUB>3</SUB>, etc.
</LI><LI CLASS="li-itemize">le degré total <CODE>tdeg</CODE>: 
on commence par comparer le degré
total, et en cas d’égalité on utilise l’ordre lexicographique
</LI><LI CLASS="li-itemize"><CODE>revlex</CODE><A NAME="@default69"></A>: on commence par comparer le degré
total, et en cas d’égalité on renvoie le contraire
de l’ordre lexicographique (attention, cela ne veut
pas dire inverser l’ordre des variables!)
</LI></UL><P>
On remarque sur ces 3 exemples qu’il ne peut exister de suite strictement
décroissante infinie pour l’ordre &gt;. Lorsque le degré total est
le premier critère, c’est évident, puisque le nombre de monomes &lt;
à un monome donné est fini. Pour l’ordre lexicographique, on
raisonne par l’absurde.
On regarde d’abord le premier indice, comme la suite est décroissante,
tous les monômes ont un indice inférieur ou égal au premier indice
du premier monôme. On peut donc extraire une sous-suite strictement
décroissante et infinie de monômes dont le 1er indice est constant. 
On passe alors au 2ème indice, et ainsi de suite jusqu’au dernier indice
qui donne une contradiction. On fait donc dans la suite l’hypothèse
qu’il n’existe pas de suite strictement décroissante infinie pour 
l’ordre &gt;.</P><P>On peut alors effectuer une sorte de remplacement de la division
euclidienne de <I>A</I> par <I>B</I>, appelée réduction qui consiste à comparer le
terme dominant de <I>B</I> au sens de l’ordre (noté <I>LT</I>(<I>B</I>)) aux monomes
de <I>A</I> par ordre décroissant, si l’un
des monomes de <I>A</I> a <B>toutes</B> ses puissances
plus grandes que <I>LT</I>(<I>B</I>), alors on élimine ce terme, 
disons <I>A</I><SUB><I>k</I></SUB>, en retranchant
à <I>A</I> le polynôme <I>A</I><SUB><I>k</I></SUB>/<I>LT</I>(<I>B</I>) <I>B</I>. Ceci ne modifie pas le début
de <I>A</I> jusqu’au monôme <I>A</I><SUB><I>k</I></SUB>. Les termes retranchés peuvent eux-même
donner lieu à une réduction par <I>B</I>, par exemple <I>A</I><SUB><I>k</I></SUB>/<I>LT</I>(<I>B</I>) <I>B</I><SUB>2</SUB> peut
être divisible par <I>LT</I>(<I>B</I>). Le procédé de réduction
doit toutefois s’arrêter,
sinon on pourrait construire une suite décroissante infinie pour
l’ordre &gt; avec les <I>A</I><SUB><I>k</I></SUB>.
On peut même diviser <I>A</I> par plusieurs polynômes <I>B</I>,<I>C</I>,.. en utilisant
cet algorithme.</P><!--TOC subsection Idéaux-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc62">7.2</A>  Idéaux</H3><!--SEC END --><P><A NAME="@default70"></A>
En dimension 1, les idéaux sont engendrés par un polynôme <I>P</I> et
c’est la division euclidienne par <I>P</I> qui permet de savoir si on est
dans l’idéal. En dimension plus grande, l’analogue est la base
de Gröbner de l’idéal (relativement à un ordre monomial &lt;)
et on utilise la réduction par rapport aux polynômes de l’idéal
pour savoir si on est dans l’idéal.
On commence par montrer que les idéaux de monomes
sont engendrés par 
les monômes minimaux, qui ne sont divisibles par aucun
autre monôme de l’idéal. Supposons qu’ils soient en nombre infini.
Considérons le premier indice des monomes, s’il est borné, on 
aura une infinité de monomes ayant le même indice, sinon on
aura une suite infinie de monômes d’indice croissant, dans
les deux cas on peut extraire une suite infinie dont la première
composante est croissante au sens large. On fait le même
raisonnement sur la suite extraite pour la 2ème composante, etc.
et on aboutit à une suite infinie de monômes qui se divisent les
uns les autres ce qui est absurde. Donc les monômes minimaux
sont en nombre fini.</P><P>Une base de Gröbner s’obtient en prenant
des polynômes correspondant aux monômes minimaux 
de l’idéal de monômes <I>LT</I>(<I>I</I>) 
des coefficients dominants de <I>I</I>. La réduction
par rapport aux éléments de cette base donne alors 0
pour tous les éléments de <I>I</I>, ce qui montre que
<I>I</I> est engendré par cette base.</P><P>On appelle <B>“s-polynôme”</B><A NAME="@default71"></A> d’une paire de polynômes
<I>A</I> et <I>B</I>
le polynôme obtenu en calculant le monôme PPCM <I>L</I> de <I>LT</I>(<I>A</I>) 
et <I>LT</I>(<I>B</I>) et en créant la différence
qui annule ce monôme PPCM <I>L</I>/<I>LT</I>(<I>A</I>)<I>A</I> −<I>L</I>/<I>LT</I>(<I>B</I>)<I>B</I>.</P><P>On peut montrer que la base de Gröbner peut se calculer
à partir d’une famille génératrice en effectuant
la boucle suivante :
on calcule tous les s-polynômes de la famille génératrice
courante, on les réduit par rapport à la famille génératrice
courante, si tous les s-polynomes sont nuls la famille
courante est la base cherchée, sinon 
on garde les s-polynômes réduits non nuls, on réduit
la famille génératrice courante par rapport à ces s-polynômes réduits
non nuls et on fusionne les polynômes non nuls en la famille
génératrice courante pour l’itération suivante de la boucle.</P><P>Le problème est que cela devient très vite très long. Il existe
des méthodes permettant d’accélérer l’algorithme, par exemple
on peut savoir à l’avance qu’un s-polynôme se réduit à 0
(règles de Gebauer-Möller) il est donc inutile de le calculer.
On peut aussi précalculer tous les multiples des polynômes
par rapport auxquels on réduit et réduire simultanément
tous les polynômes à réduire en ramenant la réduction
à un algorithme de pivot de Gauß (c’est la partie
algèbre linéaire de l’algorithme F4). L’ordre choisi
est aussi très important pour l’efficacité. Enfin, pour le cas des
coefficients entiers, des méthodes modulaires permettent
d’accélérer les calculs. Xcas implémente un algorithme modulaire
très compétitif pour l’ordre <TT>revlex</TT>, présenté
dans l’article en anglais qui suit.</P><P>Les instructions Xcas correspondantes sont <TT>gbasis, greduce</TT>.</P><!--TOC subsection Introduction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc63">7.3</A>  Introduction</H3><!--SEC END --><P>
During the last decades, considerable improvements have been made 
in CAS like Maple or specialized systems like Magma, Singular, 
Cocoa, Macaulay... to compute Groebner basis. 
They were driven by
implementations of new algorithms speeding up the original Buchberger 
([<A HREF="#buchberger1985grobner"></A>])
algorithm: Gebauer and Möller criterion ([<A HREF="#Gebauer1988275"></A>]), F4 and F5
algorithms from J.-C. Faugère ([<A HREF="#F99a"></A>], [<A HREF="#Fau02a"></A>]), and are widely described in the
literature if the base field is a finite field.
Much less was said about computing over ℚ. It seems that
implementers are using the same algorithm as for finite fields,
this time working with coefficients in ℚ or in ℤ (sometimes
with fast integer linear algebra), 
despite the fact that an efficient p-adic or Chinese remaindering
algorithm were described as soon as in year 2000 by E. Arnold
([<A HREF="#Arnold2003403"></A>]). 
The reason might well be that these modular algorithms suffer from a
time-consuming step at the end: checking that the reconstructed
Groebner basis is indeed the correct Groebner basis.</P><P>Section <A HREF="#sec:probagb">7.4</A>
will show that if one accepts a small error probability, this check 
may be fast, so we can let the user choose between a fast conjectural
Groebner basis to make his own conjectures and a slower certified
Groebner basis once he needs a mathematical proof.</P><P>Section <A HREF="#sec:learning">7.5</A>
will explain learning, a process that can accelerate the
computation of a Groebner basis modulo a prime <I>p</I><SUB><I>k</I></SUB> once the
same computation but modulo another prime <I>p</I> has already been
done ; learning is an alternative to the F5 algorithm
in order to avoid computing useless critical pairs that reduce to 0. The
idea is similar to <TT>F4remake</TT> by Joux-Vitse ([<A HREF="#joux2011variant"></A>]) 
used in the context of computing Groebner basis in large finite fields.</P><P>Section <A HREF="#sec:giacf4">7.6</A> 
will show in more details how the gbasis algorithm is implemented
in Giac/Xcas ([<A HREF="#giac"></A>]) and show that - at least for the classical academic
benchmarks Cyclic and Katsura - the deterministic modular algorithm
is competitive or faster than the best open-source implementations
and the modular probabilistic algorithm is comparable to Maple
and slower than Magma on one processor (at least for moderate integer coefficient
size) and may be faster than Magma on multi-processors, 
while computation modulo <I>p</I> are faster for characteristics in the
24-31 bits range.
Moreover the modular algorithm memory usage is essentially
twice the memory required to store the basis on ℚ, sometimes
much less than the memory required by other algorithms.</P><!--TOC subsection Checking a reconstructed Groebner basis-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc64">7.4</A>  Checking a reconstructed Groebner basis</H3><!--SEC END --><P> <A NAME="sec:probagb"></A>
Let <I>f</I><SUB>1</SUB>,..,<I>f</I><SUB><I>m</I></SUB> be polynomials in ℚ[<I>x</I><SUB>1</SUB>,..,<I>x</I><SUB><I>n</I></SUB>], <I>I</I>=&lt;<I>f</I><SUB>1</SUB>,...,<I>f</I><SUB><I>m</I></SUB>&gt;
be the ideal generated by <I>f</I><SUB>1</SUB>,...,<I>f</I><SUB><I>n</I></SUB>. Without loss of generality, we may
assume that the <I>f</I><SUB><I>i</I></SUB> have coefficients in ℤ by multiplying
by the least common multiple of the denominators of the coefficients
of <I>f</I><SUB><I>i</I></SUB>. We may also assume that the <I>f</I><SUB><I>i</I></SUB> are primitive by dividing
by their content.</P><P>Let &lt; be a total monomial ordering (for example <TT>revlex</TT> the
total degree reverse lexicographic ordering). We want to compute
the Groebner basis <I>G</I> of <I>I</I> over ℚ (and more precisely
the inter-reduced Groebner basis, sorted with respect to &lt;).
Now consider the ideal <I>I</I><SUB><I>p</I></SUB> generated by the same <I>f</I><SUB><I>i</I></SUB> but with
coefficients in ℤ/<I>p</I>ℤ for a prime <I>p</I>. Let <I>G</I><SUB><I>p</I></SUB> be the Groebner basis of <I>I</I><SUB><I>p</I></SUB>
(also assumed to be inter-reduced, sorted with respect to &lt;, and with
all leading coefficients equal to 1).</P><P>Assume we compute <I>G</I> by the Buchberger
algorithm with Gebauer and Möller criterion, and we reduce in ℤ
(by multiplying the s-poly to be reduced by appropriate leading
coefficients), if no leading coefficient in the polynomials are
divisible by <I>p</I>, we will get by the same process but computing modulo
<I>p</I> the <I>G</I><SUB><I>p</I></SUB> Groebner basis. Therefore the computation can be
done in parallel in ℤ and in ℤ/<I>p</I>ℤ except for a finite 
set of <EM>unlucky</EM> primes (since the number of intermediate polynomials
generated in the algorithm is finite). If we are choosing our primes
sufficiently large (e.g. about 2<SUP>31</SUP>), the probability to fall on
an unlucky prime is very small (less than the number of generated
polynomials divided by about 2<SUP>31</SUP>, even for really large 
examples like Cyclic9 where there are a few 10<SUP>4</SUP> polynomials 
involved, it would be about <TT>1e-5</TT>).</P><P>The Chinese remaindering algorithm is as follow: compute <I>G</I><SUB><I>p</I></SUB> for
several primes, for all primes that have the same leading monomials
in <I>G</I><SUB><I>p</I></SUB> (i.e. if coefficient values are ignored), reconstruct
<I>G</I><SUB>∏<I>p</I><SUB><I>j</I></SUB></SUB> by Chinese remaindering, then reconstruct a
candidate Groebner basis <I>G</I><SUB><I>c</I></SUB> in ℚ by Farey reconstruction. Once it
stabilizes, do the checking step described below, and return <I>G</I><SUB><I>c</I></SUB>
on success.</P><P><B>Checking step</B> : check that the original <I>f</I><SUB><I>i</I></SUB> polynomials reduce
to 0 with respect to <I>G</I><SUB><I>c</I></SUB> and check that <I>G</I><SUB><I>c</I></SUB> is a Groebner basis.</P><DIV CLASS="theorem"><B>Théorème 11</B>  <EM> (Arnold)
If the checking step succeeds, then </EM><EM><I>G</I></EM><SUB><EM><I>c</I></EM></SUB><EM> is the Groebner basis of </EM><EM><I>I</I></EM><EM>.
</EM></DIV><P>This is a consequence of ideal inclusions (first check) and dimensions (second
check), for a complete proof, see [<A HREF="#Arnold2003403"></A>].</P><P><B>Probabilistic checking algorithm</B>: instead of checking that s-polys
of critical
pairs of <I>G</I><SUB><I>c</I></SUB> reduce to 0, check that the s-polys reduce to 0 
modulo several primes that do not divide the leading coefficients of
<I>G</I><SUB><I>c</I></SUB> and stop
as soon as the inverse of the product of these primes is less than a
fixed ε&gt;0.</P><P><B>Deterministic checking algorithm</B>: check that all s-polys
reduce to 0 over ℚ. This can be done either by integer computations
(or even by rational computations, I have not tried that),
or by reconstruction of the quotients using modular reduction to 0
over ℤ/<I>p</I>ℤ for sufficiently many primes. Once the reconstructed
quotients stabilize, we can check the 0-reduction identity, and this
can be done without computing the products quotients by elements of <I>G</I><SUB><I>c</I></SUB>
if we have enough primes (with appropriate bounds on
the coefficients of <I>G</I><SUB><I>c</I></SUB> and the lcm of the denominators of the
reconstructed quotients).</P><!--TOC subsection Speeding up by learning from previous primes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc65">7.5</A>  Speeding up by learning from previous primes</H3><!--SEC END --><P> <A NAME="sec:learning"></A>
Once we have computed a Groebner basis modulo an initial prime <I>p</I>, if <I>p</I> is
not an unlucky prime, then we can speedup computing Groebner basis
modulo other lucky primes. Indeed, if one s-poly reduce to 0 modulo
<I>p</I>, then it reduces most certainly to 0 on ℚ (non zero s-poly have
in general several terms, cancellation of one term mod <I>p</I> has
probability 1/<I>p</I>, simultaneous cancellation of several terms of a non-zero
s-poly modulo <I>p</I> is highly improbable), and we discard this s-poly in the
next primes computations. We name this speedup process <EM>learning</EM>. 
It can also
be applied on other parts of the Groebner basis computation, like the
symbolic preprocessing of the F4 algorithm, where we can reuse the
same collection of monomials that were used for the first prime <I>p</I> 
to build matrices for next primes (see Buchberger Algorithm with F4 
linear algebra in the next section).</P><P>If we use learning, we have no certification that the computation ends up
with a Groebner basis modulo the new primes. But this is not a problem,
since it is not required by the checking correctness proof, the only
requirement is that the new generated ideal is contained in the
initial ideal modulo all primes (which is still true) and 
that the reconstructed <I>G</I><SUB><I>c</I></SUB> is a Groebner basis.</P><!--TOC subsection Giac/Xcas implementation and experimentation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc66">7.6</A>  Giac/Xcas implementation and experimentation</H3><!--SEC END --><P> <A NAME="sec:giacf4"></A>
We describe here briefly some details of the Giac/Xcas gbasis implementation
and give a few benchmarks.</P><P>The optimized algorithm runs with revlex as &lt; ordering
if the polynomials have at most 15
variables (it’s easy to modify for more variables, adding multiples of
4, but this will increase a little memory required and
slow down a little).
Partial and total degrees are coded as 16 bits integers (hence the 15
variables limit, since 1 slot of 16 bits is kept for total degree). 
Modular coefficients are coded as 31 bit integers (or 24).</P><P>The Buchberger algorithm with linear algebra 
from the F4 algorithm is implemented modulo primes smaller than 2<SUP>31</SUP>
using total degree as selection criterion for critical pairs.<BR>
<B>Buchberger algorithm with F4 linear algebra modulo a prime</B>
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Initialize the basis to the empty list, and a list of critical
pairs to empty
</LI><LI CLASS="li-enumerate">Add one by one all the <I>f</I><SUB><I>i</I></SUB> to the basis and update
the list of critical pairs with Gebauer and Möller criterion, 
by calling the gbasis update procedure (described below step 9)
</LI><LI CLASS="li-enumerate">Begin of a new iteration:<BR>
All pairs of minimal total degree are
collected to be reduced simultaneously, they are removed from
the list of critical pairs.
</LI><LI CLASS="li-enumerate">The symbolic preprocessing step begins by creating 
a list of monomials, gluing
together all monomials of the corresponding s-polys (this
is done with a heap data structure). 
</LI><LI CLASS="li-enumerate">The list of monomials is “reduced” by division with respect 
to the current basis,
using heap division (like Monagan-Pearce [<A HREF="#monagan2011sparse"></A>]) 
without taking care
of the real value of coefficients. This gives a list of all possible remainder
monomials and a list of all possible quotient monomials and a list
of all quotient times corresponding basis element monomial products.
This last list together with the remainder monomial list is the
list of all possible monomials that may be generated reducing
the list of critical pairs of maximal total degree, 
it is ordered with respect to &lt;. We
record these lists for further primes during the first prime computation.
</LI><LI CLASS="li-enumerate">The list
of quotient monomials is multiplied by the corresponding elements of the current
basis, this time doing the coefficient arithmetic.
The result is recorded in a sparse matrix, each row has a pointer
to a list of coefficients (the list of coefficients 
is in general shared by many rows, the rows have the
same reductor with a different monomial shift), 
and a list of monomial indices (where the index 
is relative to the ordered list of possible monomials). We sort
the matrix by decreasing order of leading monomial.
</LI><LI CLASS="li-enumerate">Each s-polynomial is written as a dense vector with respect to the
list of all possible monomials, and reduced with respect to the
sparse matrix, by decreasing order with respect to &lt;.
(To avoid reducing modulo <I>p</I> each time, we are using a dense
vector of 128 bits integers on 64 bits architectures, 
and we reduce mod <I>p</I> only at the end of the reduction. If
we work on 24 bit signed integers, we can use a dense vector 
of 63 bits signed integer and reduce the vector if the number
of rows is greater than 2<SUP>15</SUP>).
</LI><LI CLASS="li-enumerate">Then inter-reduction happens on all the dense vectors representing
the reduced s-polynomials, this is dense row
reduction to echelon form (0 columns are removed first). 
Care must be taken at this step
to keep row ordering when learning is active.
</LI><LI CLASS="li-enumerate">gbasis update procedure<BR>
Each non zero row will bring a new entry in the current
basis (we record zero reducing pairs during the first prime iteration,
this information will be used during later iterations with other
primes to avoid computing and reducing
useless critical pairs). 
New critical pairs are created with this new entry (discarding useless
pairs by applying Gebauer-Möller criterion).
An old entry in the basis may be removed if it’s leading monomial
has all partial degrees greater or equal to the leading monomial
corresponding degree of the new entry.
Old entries may also be reduced with respect to the new entries 
at this step or at the end of the main loop.
</LI><LI CLASS="li-enumerate">If there are new critical pairs remaining start a new iteration
(step 3). Otherwise the current basis is the Groebner basis.
</LI></OL><P><B>Modular algorithm</B>
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Set a list of reconstructed basis to empty.
</LI><LI CLASS="li-enumerate">Learning prime: Take a prime number of 31 bits 
or 29 bits for pseudo division, run the Buchberger algorithm modulo this
prime recording symbolic preprocessing data and the list of critical pairs
reducing to 0.
</LI><LI CLASS="li-enumerate">Loop begin:
Take a prime of 29 bits size or a list of <I>n</I> primes if <I>n</I> processors
are available. Run the Buchberger algorithm.
Check if the output has the same leading terms than one of the
chinese remainder reconstructed outputs from previous primes,
if so combine them by Chinese remaindering and go to step 4, otherwise add
a new entry in the list of reconstructed basis and continue with
next prime at step 3 (clearing all learning data is probably a good
idea here).
</LI><LI CLASS="li-enumerate">If the Farey ℚ-reconstructed basis is not 
identical to the previous one, go to the loop iteration step 3
(a fast way to check that is to reconstruct with all primes
but the last one, and check the value modulo the last prime).
If they are identical, run the final check : the initial polynomials <I>f</I><SUB><I>i</I></SUB> must reduce
to 0 modulo the reconstructed basis and
the reconstructed basis s-polys must reduce to 0 (this is
done on ℚ either directly or by modular reconstruction
for the deterministic algorithm, or checked modulo several primes
for the probabilistic algorithm). On success output the ℚ
Groebner basis, otherwise continue with next prime at step 3.
</LI></OL><P><B>Benchmarks</B><BR>
Comparison of giac (1.1.0-26) with Singular 3.1 (from sage 5.10) 
on Mac OS X.6, Dual Core i5 2.3Ghz, RAM 2*2Go:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Mod timings were computed modulo <CODE>nextprime(2^24)</CODE>
and modulo 1073741827 (<CODE>nexprime(2^30)</CODE>).
</LI><LI CLASS="li-itemize">Probabilistic check on ℚ depends linearly on log of precision, two
timings are reported, one with error probability less than <CODE>1e-7</CODE>, and
the second one for <CODE>1e-16</CODE>.
</LI><LI CLASS="li-itemize">Check on ℚ in giac can be done with integer or modular computations
hence two times are reported.
</LI><LI CLASS="li-itemize"><CODE>&gt;&gt;</CODE> means timeout (3/4h or more) or memory exhausted
(Katsura12 modular <CODE>1e-16</CODE> check with giac) or test not done because
it would obviously timeout (e.g. Cyclic8 or 9 on ℚ with Singular)
</LI></UL><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>giac mod <I>p</I></TD><TD ALIGN=center NOWRAP>giac</TD><TD ALIGN=center NOWRAP>singular</TD><TD ALIGN=center NOWRAP>giac ℚ prob.</TD><TD ALIGN=center NOWRAP>giac ℚ</TD><TD ALIGN=center NOWRAP>singular</TD></TR>
<TR><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>24, 31 bits</TD><TD ALIGN=center NOWRAP>run2</TD><TD ALIGN=center NOWRAP>mod <I>p</I></TD><TD ALIGN=center NOWRAP><CODE>1e-7</CODE>, <CODE>1e-16</CODE></TD><TD ALIGN=center NOWRAP>certified</TD><TD ALIGN=center NOWRAP>ℚ</TD></TR>
<TR><TD ALIGN=center NOWRAP>Cyclic7</TD><TD ALIGN=center NOWRAP>0.5, 0.58</TD><TD ALIGN=center NOWRAP>0.1</TD><TD ALIGN=center NOWRAP>2.0</TD><TD ALIGN=center NOWRAP>3.5, 4.2</TD><TD ALIGN=center NOWRAP>21, 29.3</TD><TD ALIGN=center NOWRAP>&gt;2700</TD></TR>
<TR><TD ALIGN=center NOWRAP>Cyclic8</TD><TD ALIGN=center NOWRAP>7.2, 8.9</TD><TD ALIGN=center NOWRAP>1.8</TD><TD ALIGN=center NOWRAP>52.5</TD><TD ALIGN=center NOWRAP>103, 106</TD><TD ALIGN=center NOWRAP>258, 679</TD><TD ALIGN=center NOWRAP>&gt;&gt;</TD></TR>
<TR><TD ALIGN=center NOWRAP>Cyclic9</TD><TD ALIGN=center NOWRAP>633, 1340</TD><TD ALIGN=center NOWRAP>200</TD><TD ALIGN=center NOWRAP>?</TD><TD ALIGN=center NOWRAP>1 day</TD><TD ALIGN=center NOWRAP>&gt;&gt;</TD><TD ALIGN=center NOWRAP>&gt;&gt;</TD></TR>
<TR><TD ALIGN=center NOWRAP>Kat8</TD><TD ALIGN=center NOWRAP>0.063, 0.074</TD><TD ALIGN=center NOWRAP>0.009</TD><TD ALIGN=center NOWRAP>0.2</TD><TD ALIGN=center NOWRAP>0.33, 0.53</TD><TD ALIGN=center NOWRAP>6.55, 4.35</TD><TD ALIGN=center NOWRAP>4.9</TD></TR>
<TR><TD ALIGN=center NOWRAP>Kat9</TD><TD ALIGN=center NOWRAP>0.29, 0.39</TD><TD ALIGN=center NOWRAP>0.05</TD><TD ALIGN=center NOWRAP>1.37</TD><TD ALIGN=center NOWRAP>2.1, 3.2</TD><TD ALIGN=center NOWRAP>54, 36</TD><TD ALIGN=center NOWRAP>41</TD></TR>
<TR><TD ALIGN=center NOWRAP>Kat10</TD><TD ALIGN=center NOWRAP>1.53, 2.27</TD><TD ALIGN=center NOWRAP>0.3</TD><TD ALIGN=center NOWRAP>11.65</TD><TD ALIGN=center NOWRAP>14, 20.7</TD><TD ALIGN=center NOWRAP>441, 335</TD><TD ALIGN=center NOWRAP>480</TD></TR>
<TR><TD ALIGN=center NOWRAP>Kat11</TD><TD ALIGN=center NOWRAP>10.4, 13.8</TD><TD ALIGN=center NOWRAP>2.8</TD><TD ALIGN=center NOWRAP>86.8</TD><TD ALIGN=center NOWRAP>170, 210</TD><TD ALIGN=center NOWRAP>4610</TD><TD ALIGN=center NOWRAP>?</TD></TR>
<TR><TD ALIGN=center NOWRAP>Kat12</TD><TD ALIGN=center NOWRAP>76, 103</TD><TD ALIGN=center NOWRAP>27</TD><TD ALIGN=center NOWRAP>885</TD><TD ALIGN=center NOWRAP>1950, RAM</TD><TD ALIGN=center NOWRAP>RAM</TD><TD ALIGN=center NOWRAP>&gt;&gt;</TD></TR>
<TR><TD ALIGN=center NOWRAP>alea6</TD><TD ALIGN=center NOWRAP>0.83, 1.08</TD><TD ALIGN=center NOWRAP>.26</TD><TD ALIGN=center NOWRAP>4.18</TD><TD ALIGN=center NOWRAP>202, 204</TD><TD ALIGN=center NOWRAP>738, &gt;&gt;</TD><TD ALIGN=center NOWRAP>&gt;1h</TD></TR>
</TABLE><P><BR>
This leads to the following observations :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Computation modulo <I>p</I> for 24 to 31 bits is faster that Singular, but seems also
faster than magma (and maple). For smaller primes, magma is 2 to 3
times faster.
</LI><LI CLASS="li-itemize">The probabilistic algorithm on ℚ is much faster than Singular on these examples.
Compared to maple16, it is reported to be faster for Katsura10, 
and as fast for Cyclic8. Compared to magma, it is about 3 to 4
times slower. 
</LI><LI CLASS="li-itemize">If [<A HREF="#magma"></A>] is up to date (except about giac), giac is the third software and first
open-source software to solve Cyclic9 on ℚ. It requires 378
primes of size 29 bits, takes a little more than 1 day, requires 5Gb
of memory on 1 processor, while with 6 processors it takes
8h30 (requires 16Gb). The answer has integer coefficients of about 1600 digits
(and not 800 unlike in J.-C. Faugère F4 article), for a little
more than 1 milliion monomials, that’s about 1.4Gb of RAM.
</LI><LI CLASS="li-itemize">The deterministic modular algorithm is much faster than Singular for Cyclic examples,
and as fast for Katsura examples. 
</LI><LI CLASS="li-itemize">For the random last example, the speed is comparable between
magma and giac. This is where there are less pairs reducing to
0 (learning is not as efficient as for Cyclic or Katsura) and larger
coefficients. This would suggest that advanced algorithms 
like f4/f5/etc. are probably
not much more efficient than Buchberger algorithm for these kind
of inputs without symmetries.
</LI><LI CLASS="li-itemize">Certification is the most time-consuming part of the process (except
for Cyclic8). Integer certification is significantly faster than modular certification
for Cyclic examples, and almost as fast for Katsura.
</LI></UL><P>Example of Giac/Xcas code:
</P><PRE CLASS="verbatim">alea6 := [5*x^2*t+37*y*t*u+32*y*t*v+21*t*v+55*u*v,
39*x*y*v+23*y^2*u+57*y*z*u+56*y*u^2+10*z^2+52*t*u*v,
33*x^2*t+51*x^2+42*x*t*v+51*y^2*u+32*y*t^2+v^3,
44*x*t^2+42*y*t+47*y*u^2+12*z*t+2*z*u*v+43*t*u^2,
49*x^2*z+11*x*y*z+39*x*t*u+44*x*t*u+54*x*t+45*y^2*u,
48*x*z*t+2*z^2*t+59*z^2*v+17*z+36*t^3+45*u];
l:=[x,y,z,t,u,v];
p1:=prevprime(2^24); p2:=prevprime(2^29);
time(G1:=gbasis(alea6 % p1,l,revlex));
time(G2:=gbasis(alea6 % p2,l,revlex));
threads:=2; // set the number of threads you want to use
// debug_infolevel(1); // uncomment to show intermediate steps
proba_epsilon:=1e-7; // probabilistic algorithm.
time(H0:=gbasis(alea6,indets(cyclic5),revlex));
proba_epsilon:=0; // deterministic
time(H1:=gbasis(alea6,indets(cyclic5),revlex));
time(H2:=gbasis(alea6,indets(cyclic5),revlex,modular_check));
size(G1),size(G2),size(H0),size(H1),size(H2);
write("Halea6",H0);
</PRE><P>Note that for small examples (like Cyclic5), the system performs always the deterministic
check (this is the case if the number of elements of the reconstructed basis
to 50).</P><!--TOC subsection Conclusion-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc67">7.7</A>  Conclusion</H3><!--SEC END --><P>
I have described some enhancements to a modular algorithm
to compute Groebner basis over ℚ which, combined to 
linear algebra from F4, gives
a sometimes much faster open-source implementation 
than state-of-the-art open-source implementations 
for the deterministic algorithm. 
The probabilistic algorithm is also not ridiculous
compared to the best publicly available closed-source implementations,
while being much easier to implement
(about 10K lines of code, while Fgb is said to be 200K lines of code,
no need to have highly optimized sparse linear algebra).</P><P>This should speed up conjectures with the probabilistic algorithm
and automated proofs using the deterministic
algorithm (e.g. for the Geogebra theorem prover
[<A HREF="#botanaimplementing"></A>]), 
either using Giac/Xcas (or one of it’s interfaces
to java and python) or adapting it’s implementation
to other open-source systems.
With fast closed-source implementations (like maple or magma), 
there is no certification that the result is a Groebner basis :
there might be some hidden probabilistic
step somewhere, in integer linear system reduction for example. I have
no indication that it’s the case but one can never know if the code is
not public, and at least for my implementation, certification
might take a lot more time than computation. </P><P>There is still room for additions and improvements
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the checking step can certainly be improved using
knowledge on how the basis element modulo <I>p</I> where
built.
</LI><LI CLASS="li-itemize">checking could also benefit from parallelization.
</LI><LI CLASS="li-itemize">As an alternative to the modular algorithm,
a first learning run could be done modulo a 24 bits prime, and
the collected info used for f4 on ℚ as a probabilistic alternative
to F5.
</LI><LI CLASS="li-itemize">FGLM conversion is still not optimized and therefore
slow in Giac/Xcas, 
</LI></UL><P><B>Acknowledgements</B><BR>
Thanks to Frédéric Han for interfacing giac with Python.
Thanks to Vanessa Vitse for insightfull discussions.</P><!--TOC subsection Représentation rationnelle univariée 
(rur).-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc68">7.8</A>  Représentation rationnelle univariée 
(rur<A NAME="@default72"></A><A NAME="@default73"></A><A NAME="@default74"></A>).</H3><!--SEC END --><P>
<A NAME="sec:rur"></A>
Lorsqu’on résoud un système polynomial, on a (en général) autant
d’équations que d’inconnues et en principe un nombre fini de solutions.
On peut utiliser une base de Groebner dans l’ordre lexicographique,
résoudre par rapport à la dernière variable, puis remonter, mais
d’une part le calcul d’une base de Groebner dans l’ordre lexicographique
est significativement plus long que dans l’ordre revlex, et d’autre
part il faut calculer des PGCD et 
factoriser des polynômes sur des extensions algébriques
dont la taille peut augmenter au fur et à mesure que l’on remonte (ou faire
des calculs approchés...). Il serait plus intéressant de calculer
d’un seul coup une extension algébrique de ℚ qui permette
d’exprimer toutes les variables. Ceci peut se faire si on arrive à
trouver une forme linéaire en les variables qui sépare
les solutions (la valeur de la forme est distincte si les points
solutions sont distincts). On rajoute cette variable et on résoud
l’équation obtenue en cette variable, pour chaque solution on aura
une unique solution en remontant les autres variables. La représentation
univariée rationnelle fait précisément cela, et donne même les
autres variables comme polynôme en la forme linéaire séparante.</P><P>La présentation classique de la représentation univariée rationnelle 
utilise des calculs de trace (cf. par exemple le rapport de l’Inria 1998
de Fabrice Rouillier), l’algorithme
implémenté dans Giac/Xcas (versions 1.1.1 et ultérieures)
est un algorithme modulaire. On commence par se ramener
au cas d’un idéal radical (c’est-à-dire que les
points solutions du système sont de multiplicité 1)
en ajoutant aux générateurs de l’idéal 
les parties squarefree des polynômes
minimaux de toutes les variables. Pour un idéal radical,
on montre qu’il existe une forme linéaire séparante, le degré
du polynôme minimal de cette forme linéaire séparante est
exactement égal à la dimension du quotient de 
l’anneau de polynômes par l’idéal radical. On peut donc tester si une forme
linéaire est séparante en calculant son polynôme minimal. En pratique,
on commence par calculer une base de Groebner pour l’ordre revlex 
(le plus efficace). On génère la liste des monomes du quotient
en commençant par majorer les degrés en chacune des variables,
puis on élimine parmi les monomes possibles 
ceux qui sont divisibles par le monome dominant d’un élément
de la base de Groebner. On calcule ensuite la classe d’un polynôme
dans le quotient en effectuant une réduction par la base
de Groebner, on obtient un vecteur de coordonnées dans cette base de monome.
Le calcul du polynôme minimal d’une forme linéaire
devient ainsi un problème d’algèbre linéaire.
Le calcul de chaque variable en fonction des puissances d’une forme linéaire
séparante est également un problème d’algèbre linéaire (on le fait
simultanément pour toutes les variables, si on veut optimiser on
peut même faire une décomposition LU lors du calcul du polynôme minimal
et la réutiliser). Pour éviter les problèmes de croissance de coefficients
dans les calculs intermédiaires,
ce calcul est effectué modulo plusieurs nombres premiers dans giac,
jusqu’à pouvoir reconstruire par les restes chinois le polynôme minimal
de la forme séparante sur ℚ et les expressions des variables comme
polynôme de la forme séparante (on n’a alors pas besoin
de reconstruire la base de Groebner sur ℚ). Bien entendu,
il faut traiter le cas des mauvaises réductions, pour cela
on regarde si les monomes de la base du quotient de l’anneau par l’idéal
sont indépendants du nombre premier choisi, en cas de différence,
il faut conserver le nombre premier correspondant à la liste
de monômes la plus grande (l’autre nombre premier est de mauvaise
réduction), ou rejeter les deux nombres premiers si aucune
des deux listes de monomes ne contient l’autre.</P><P>Les fonctions <CODE>solve</CODE>, <CODE>fsolve</CODE> et <CODE>cfsolve</CODE> 
utilisent cet algorithme
pour des systèmes polynomiaux qui s’y prêtent (en cherchant une
forme séparante d’abord parmi les variables puis avec des combinaisons
linéaires aléatoires à petits coefficients entiers),
<CODE>solve</CODE> essaie de renvoyer des solutions exactes
si le polynome minimal de la forme linéaire séparante
se factorise sur ℚ, <CODE>fsolve</CODE> (en mode réel)
localise les racines réelles par la méthode d’Akritas,
<CODE>cfsolve</CODE> localise les racines complexes par
factorisation de Schur de la matrice companion. La fonction
<CODE>gbasis(eqs,vars,rur)</CODE> avec comme paramètre optionnel <CODE>rur</CODE>
effectue le calcul de la représentation univariée rationnelle
et renvoie une liste contenant le polynôme minimal <I>P</I>
(exprimée arbitrairement en fonction de la 1ère variable du système),
sa dérivee <I>P</I>′ et les <I>P</I><SUB>1</SUB>,...,<I>P</I><SUB><I>n</I></SUB> qui permettent d’exprimer
la <I>i</I>-ème variable d’une solution comme étant <I>P</I><SUB><I>i</I></SUB>(<I>r</I>)/<I>P</I>′(<I>r</I>)
avec <I>r</I> racine de <I>P</I>. On peut alors
vérifier que l’on a bien une solution en remplaçant la variable
<I>x</I><SUB><I>i</I></SUB> par <I>P</I><SUB><I>i</I></SUB>/<I>P</I>′ dans les équations, le reste de la division
euclidienne du numérateur de la fraction obtenue par le polynome 
minimal <I>P</I> doit donner 0.</P><P>La représentation rationnelle univariée a des applications
au-delà de la seule résolution de systèmes polynomiaux.
On peut s’en servir pour trouver une extension algébrique unique de
ℚ permettant de calculer toutes les racines d’un polynôme, 
il suffit de poser le système formé par les relations
racines-coefficients de ce polynôme et d’en chercher la
représentation rationnelle univariée, cf. la section 
<A HREF="#sec:factorisation_extension">16.6</A>.
On peut également s’en servir pour trouver une 
<B>extension
algébrique</B><A NAME="@default75"></A><A NAME="@default76"></A> 
unique contenant plusieurs extensions de ℚ
dont on a le polynôme minimal. Par exemple pour
travailler dans ℚ[√<SPAN style="text-decoration:overline">2</SPAN>,√<SPAN style="text-decoration:overline">3</SPAN>,√<SPAN style="text-decoration:overline">5</SPAN>], on pose<BR>
<CODE>G:=gbasis([a^2-2,b^2-3,c^2-5],[a,b,c],rur)</CODE>,<BR>
on a alors ± √<SPAN style="text-decoration:overline">2</SPAN>=<CODE>rootof(G[4],G[2])/rootof(G[3],G[2])</CODE>,<BR>
± √<SPAN style="text-decoration:overline">3</SPAN>=<CODE>rootof(G[5],G[2])/rootof(G[3],G[2])</CODE>,<BR>
± √<SPAN style="text-decoration:overline">5</SPAN>=<CODE>rootof(G[6],G[2])/rootof(G[3],G[2])</CODE><BR>
(on peut utiliser <CODE>normal</CODE> ou <CODE>evalf</CODE> pour décider du signe).</P><!--TOC section Courbes paramétriques et polaires-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc69">8</A>  Courbes paramétriques et polaires</H2><!--SEC END --><P> <A NAME="sec:courbes"></A>
Remarque : dans ce cours sur les courbes, le lecteur
pourra s’étonner de ne voir aucune figure.
Ceci est volontaire. À la place des figures qu’on trouverait
pour illustrer un cours classique, de nombreuses
commandes Xcas sont indiquées, le lecteur est invité
à les exécuter telles quelles, puis à les modifier
afin d’illustrer lui-même de manière active le cours.</P><!--TOC subsection Introduction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc70">8.1</A>  Introduction</H3><!--SEC END --><P>
Le graphe d’une fonction <I>f</I>: <I>I</I> ↦ ℝ (<I>I</I> un intervalle)
est un exemple de courbe du plan, mais il
n’est pas assez général pour représenter tous les types de
courbe du plan, par exemple un segment de droite vertical, ou
un cercle, car deux points distincts d’un graphe doivent avoir
des abscisses différentes. D’autre part, il apparait naturellement
d’autres types de courbes que les graphes de fonction, par exemple
la trajectoire d’un mobile dans le plan dont les coordonnées <I>x</I>,<I>y</I>
dépendent du temps (selon une équation différentielle ou
un système différentiel), ce sont les courbes paramétriques,
ou des courbes vérifiant une
équation cartésienne (par exemple en géométrie
le cercle <I>x</I><SUP>2</SUP>+<I>y</I><SUP>2</SUP>=1, ou en cinématique des courbes
de niveau de l’énergie totale dans le plan position-impulsion)
ce sont les courbes implicites.</P><P>Dans cette section, on va étudier les courbes en paramétriques,
donnée par un couple de fonctions (<I>x</I>(<I>t</I>),<I>y</I>(<I>t</I>)) définies 
pour <I>t</I> dans un sous-ensemble des réels et à valeurs dans ℝ.
(Ceci ne restreint pas trop la généralité,
on peut montrer sous des hypothèses assez générales 
que l’allure locale d’une courbe implicite est identique à celle
d’une courbe paramétrique, sauf en certains points dits singuliers,
c’est le théorème des fonctions implicites).</P><P>Exemples :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
le graphe d’une fonction <I>y</I>=<I>f</I>(<I>x</I>) est une courbe paramétré
d’équation (<I>x</I>(<I>t</I>),<I>y</I>(<I>t</I>))=(<I>t</I>,<I>f</I>(<I>t</I>)) (<I>x</I> est le temps). 
On aurait aussi pu choisir
(<I>x</I>(<I>t</I>),<I>y</I>(<I>t</I>))=(<I>t</I>−1,<I>f</I>(<I>t</I>−1)) (ce qui revient à changer l’origine des
temps) ou d’autres paramétrages.
Exemple : <CODE>plotfunc(sin(x)),x</CODE> 
<CODE>plotparam([t-1,sin(t-1)],t)</CODE>
</LI><LI CLASS="li-itemize">une droite d’équation <I>y</I>=<I>ax</I>+<I>b</I> est le graphe d’une fonction,
donc paramétrable comme ci-dessus. Une droite verticale <I>x</I>=<I>a</I> peut
se paramétrer par (<I>x</I>(<I>t</I>),<I>y</I>(<I>t</I>))=(<I>a</I>,<I>t</I>)
</LI><LI CLASS="li-itemize">le cercle de centre l’origine et de rayon 1 peut se paramétrer
par (<I>x</I>(<I>t</I>),<I>y</I>(<I>t</I>))=(cos(<I>t</I>),<I>sin</I>(<I>t</I>)), <I>t</I> ∈ [0,2π[. On peut bien sur
le paramétrer par <I>t</I> ∈ ℝ, mais dans ce cas on parcourt plusieurs
fois le cercle (périodicité). On peut aussi paramétrer tout le
cercle sauf un point avec le paramétrage rationnel
(<I>x</I>(<I>t</I>),<I>y</I>(<I>t</I>))=(1−<I>t</I><SUP>2</SUP>/1+<I>t</I><SUP>2</SUP>,2<I>t</I>/1+<I>t</I><SUP>2</SUP>), <I>t</I> ∈ ℝ. Ce
paramétrage permet de calculer plus facilement des points
du cercle, mais contrairement au paramétrage trigonométrique,
il n’est pas “uniforme”.<BR>
Exemple <CODE>plotparam([cos(t),sin(t)],t=0..2*pi)</CODE><BR>
<CODE>plotparam([(1-t^2)/(1+t^2),2t/(1+t^2)],t=-10..10)</CODE><BR>
ou avec les nombres complexes<BR>
<CODE>plotparam((1+i*t)/(1-i*t),t=-10..10)</CODE>
</LI></UL><!--TOC subsection Représentation graphique-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc71">8.2</A>  Représentation graphique</H3><!--SEC END --><P> 
La plupart des calculatrices graphiques
et de nombreux logiciels de maths permettent de
représenter graphiquement un arc de courbe en donnant des valeurs
extrêmes <I>t</I><SUB>−</SUB> et <I>t</I><SUB>+</SUB> (souvent notées <CODE>tmin</CODE> et
<CODE>tmax</CODE>) et un pas Δ <I>t</I> (<CODE>tstep</CODE>). Le logiciel évalue
la valeur de <I>x</I>(<I>t</I>) et <I>y</I>(<I>t</I>) en <I>t</I><SUB>−</SUB>, <I>t</I><SUB>−</SUB>+Δ <I>t</I>, <I>t</I><SUB>−</SUB>+2Δ
<I>t</I>, ... puis relie les points de la courbe obtenue par des segments
(parfois avec des autres arcs de courbes). La plupart du temps
cela donne une bonne idée de la courbe, mais parfois on peut
manquer un détail intéressant (valeur de Δ <I>t</I> trop
grande), ou un morceau de courbe (mauvaises
valeurs de <I>t</I><SUB>−</SUB> et <I>t</I><SUB>+</SUB>).</P><P>Il peut être nécessaire d’ajuster le cadrage graphique
à l’affichage (<CODE>xmin</CODE>, <CODE>xmax</CODE>, <CODE>ymin</CODE>, <CODE>ymax</CODE>) ou
de l’affiner avec un menu de <CODE>zoom</CODE>. Sur les calculatrices
les opérations de changement de cadrage graphique
provoquent un nouveau calcul complet qui peut durer une
dizaine de secondes.</P><P>Mise en oeuvre :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
avec Xcas: on utilise la commande <CODE>plotparam</CODE>
dans le menu <CODE>Graphe, Courbes</CODE>. Le cadrage
graphique est calculé automatiquement et peut être
modifié par les touches menus à droite du graphe.
On peut spécifier le pas avec l’argument optionnel <CODE>tstep=</CODE>.
</LI><LI CLASS="li-itemize">sur les calculatrices : il faut sélectionner le mode
de tracé paramétrique (par exemple avec une touche MODE,
ou en sélectionnant une application par une touche 
APPS ou MENU), puis l’écran de définition
de <I>x</I>(<I>t</I>),<I>y</I>(<I>t</I>) apparait, éventuellement après appui
sur une touche <CODE>Y=</CODE>. Si les réglages graphiques
ne sont pas directement fournis, la touche <CODE>WINDOW</CODE>
permet d’y accéder, puis la touche <CODE>GRAPH</CODE> lance
le tracé.
</LI></UL><P>Exemples : essayez de tracer quelques courbes en paramétriques
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(2cos(<I>t</I>),3sin(<I>t</I>)),    (cos(2<I>t</I>),sin(3<I>t</I>)),    (<I>t</I><SUP>2</SUP>,<I>t</I><SUP>3</SUP>),
   (<I>t</I>+1/<I>t</I>, <I>t</I><SUP>2</SUP>+2/<I>t</I>),    (</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>t</I>−1</TD></TR>
</TABLE></TD><TD CLASS="dcell">,</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>2−<I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">) </TD></TR>
</TABLE><!--TOC subsection Paramétrage-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc72">8.3</A>  Paramétrage</H3><!--SEC END --><P>
On adoptera souvent la convention d’appeler temps le paramétre <I>t</I>.
Mais cela ne signifie pas que le paramétrage est réellement le
temps mesuré en secondes. On peut très bien paramétrer une
courbe avec un paramètre autre, qui peut être un multiple 
constant ou variable du temps (c’est d’ailleurs conforme au
principe de la relativité). Le paramétrage n’est jamais unique,
on peut changer de paramétrage pourvu que la fonction donnant
le nouveau en fonction de l’ancien paramétrage soit une bijection
(qui peut même renverser le sens de déroulement du temps
c’est-à-dire le sens de parcours de la courbe). On utilisera
d’ailleurs plus loin un paramétrage par la longueur,
où la courbe est parcourue à vitesse constante égale à 1.</P><P>Le choix d’un paramétrage est ce qui fait la différence
entre la cinématique (on prend le temps comme paramètre) et la 
géométrie
(où on cherche à décrire les propriétés intrinséques
de la courbe indépendamment
du paramétrage). Ainsi, l’équation cartésienne d’une courbe
est une propriété géométrique, indépendante du choix
de paramétrage choisi pour l’obtenir. </P><P>On observe aussi que l’opération
inverse, trouver un paramétrage à partir d’une équation
cartésienne de courbe n’est pas possible de manière
explicite, sauf dans quelques cas particuliers. C’est pour cette
raison qu’il est beaucoup plus difficile (et couteux en temps)
d’obtenir une représentation graphique d’une courbe donnée
par son équation cartésienne.</P><!--TOC subsection Étude analytique d’une courbe en paramétrique-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc73">8.4</A>  Étude analytique d’une courbe en paramétrique</H3><!--SEC END --><P>
<A NAME="@default77"></A>
On supposera dans toute la suite que les fonctions <I>x</I>(<I>t</I>) et <I>y</I>(<I>t</I>)
sont continument dérivables au moins 2 fois, sauf peut-être
en un nombre fini de réels d’un intervalle <I>I</I> de ℝ.</P><P>On commence par déterminer le domaine de définition de <I>x</I>(<I>t</I>)
et de <I>y</I>(<I>t</I>), et on essaie de le réduire si possible, soit par
périodicité (par exemple pour le cercle ci-dessus, <I>t</I> ∈ [0,2 π])
soit par l’existence de symétries si les fonctions
<I>x</I>(<I>t</I>) et <I>y</I>(<I>t</I>) sont paires ou impaires. Par exemple, si <I>x</I> et <I>y</I>
sont paires, alors on parcourt deux fois le même arc de courbe
sur ℝ<SUP>+</SUP> et ℝ<SUP>−</SUP>, on peut restreindre le domaine d’étude
à <I>t</I>≥ 0. Si <I>x</I> est pair et <I>y</I> impair, alors 
(<I>x</I>(−<I>t</I>),<I>y</I>(−<I>t</I>))=(<I>x</I>(<I>t</I>),−<I>y</I>(<I>t</I>)), il y a une symétrie par rapport à
l’axe des <I>x</I>, on se restreint à <I>t</I> ∈ <I>R</I><SUP>+</SUP>.
Dans le cas périodique, on peut tester des symétries correspondant
à des demi (voire quart) de période.
Exemple : (3cos(<I>t</I>)+2cos(3<I>t</I>),3sin(<I>t</I>)−2sin(3<I>t</I>)) </P><!--TOC subsubsection Branches infinies-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc74">8.4.1</A>  Branches infinies</H4><!--SEC END --><P><A NAME="@default78"></A>
On s’intéresse ensuite aux bornes du domaine de définition
et aux points où <I>x</I> ou/et <I>y</I> ne sont pas définis.
Si <I>x</I> et <I>y</I> admettent une limite finie, on peut prolonger la
courbe. Si les limites existent mais ne sont pas finies, 
on a une branche infinie (<I>x</I> ou <I>y</I>). Si l’une des deux
valeurs tend vers l’infini, l’autre restant finie, on a une
asymptote (horizontale si <I>x</I> tend vers l’infini, verticale
si <I>y</I> tend vers l’infini), on peut déterminer la position
de l’arc de courbe par rapport à l’asymptote en
cherchant le signe de <I>y</I>−<I>l</I> ou <I>x</I>−<I>l</I> lorsque <I>t</I> tend
vers la valeur particulière (limite à droite et limite
à gauche). Enfin si <I>x</I> et <I>y</I> tendent vers l’infini
tous les deux, on cherche la limite de <I>y</I>/<I>x</I>,
Si <I>y</I>/<I>x</I> → <I>a</I> ≠ 0, on a une <B>branche
parabolique</B><A NAME="@default79"></A> 
de <B>direction asymptotique</B><A NAME="@default80"></A> <I>y</I>=<I>ax</I>,
on cherche alors la limite
<I>y</I>−<I>ax</I>, si cette limite est finie et vaut <I>b</I> 
on a une asymptote<A NAME="@default81"></A> oblique <I>y</I>=<I>ax</I>+<I>b</I> (on peut déterminer
la position en cherchant le signe de <I>y</I>−(<I>ax</I>+<I>b</I>).</P><P>Exemples : 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I>+1</TD></TR>
</TABLE></TD><TD CLASS="dcell">,<I>t</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP>+1</TD></TR>
</TABLE></TD><TD CLASS="dcell">), 
(<I>t</I><SUP>2</SUP>,<I>t</I><SUP>3</SUP>), 
(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP>+1</TD></TR>
</TABLE></TD><TD CLASS="dcell">,<I>t</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP>+2</TD></TR>
</TABLE></TD><TD CLASS="dcell">), 
(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP>−1</TD></TR>
</TABLE></TD><TD CLASS="dcell">,</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I>+1</TD></TR>
</TABLE></TD><TD CLASS="dcell">), </TD></TR>
</TABLE><P>
On peut utiliser la commande <CODE>limit</CODE> dans Xcas pour étudier
une asymptote, par exemple dans le premier cas, pour étudier la
branche infinie pour <I>t</I> → +∞,<BR>
<CODE>x(t):=t^2/(t+1); y(t):=t+1/(t^2+1);</CODE><BR>
<CODE>a:=limit(y(t)/x(t),t=inf); limit(y(t)-a*x(t),t=inf)</CODE></P><!--TOC subsubsection Étude locale-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc75">8.4.2</A>  Étude locale</H4><!--SEC END --><P>
On se place en une valeur de <I>t</I><SUB>0</SUB> où <I>x</I> et <I>y</I> sont continument
dérivables au moins deux fois. On notera la dérivation par rapport 
au paramètre par le signe ’ (en physique on utilise aussi le point).
On a alors un développement de Taylor à l’ordre 2
du vecteur
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>M</I>(<I>t</I><SUB>0</SUB>)<I>M</I>(<I>t</I><SUB>0</SUB>+<I>h</I>)</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>(<I>x</I>(<I>t</I><SUB>0</SUB>+<I>h</I>)−<I>x</I>(<I>t</I><SUB>0</SUB>),<I>y</I>(<I>t</I><SUB>0</SUB>+<I>h</I>)−<I>y</I>(<I>t</I><SUB>0</SUB>)) </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>h</I>
(<I>x</I>′(<I>t</I><SUB>0</SUB>),<I>y</I>′(<I>t</I><SUB>0</SUB>))+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>x</I>′′(<I>t</I><SUB><I>x</I></SUB>),<I>y</I>′′(<I>t</I><SUB><I>y</I></SUB>))</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
où <I>t</I><SUB><I>x</I></SUB> et <I>t</I><SUB><I>y</I></SUB> sont compris entre <I>t</I><SUB>0</SUB> et <I>t</I><SUB>0</SUB>+<I>h</I>.
Si le vecteur vitesse <I>v</I>=(<I>x</I>′(<I>t</I><SUB>0</SUB>),<I>y</I>′(<I>t</I><SUB>0</SUB>)) est non nul, on en déduit
un équivalent
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>M</I>(<I>t</I><SUB>0</SUB>)<I>M</I>(<I>t</I><SUB>0</SUB>+<I>h</I>)</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">≡ <I>h</I> (<I>x</I>′(<I>t</I><SUB>0</SUB>),<I>y</I>′(<I>t</I><SUB>0</SUB>))</TD></TR>
</TABLE><P>
Lorsque <I>h</I> est proche de 0, le vecteur <I>M</I>(<I>t</I><SUB>0</SUB>)<I>M</I>(<I>t</I><SUB>0</SUB>+<I>h</I>)
est équivalent à un vecteur colinéaire à <I>v</I>=(<I>x</I>′(<I>t</I><SUB>0</SUB>),<I>y</I>′(<I>t</I><SUB>0</SUB>)),
qui est donc vecteur tangent à la courbe en (<I>x</I>(<I>t</I><SUB>0</SUB>),<I>y</I>(<I>t</I><SUB>0</SUB>)).</P><DIV CLASS="theorem"><B>Définition 12</B>  <EM>
On appelle </EM><EM><B>point régulier</B></EM><A NAME="@default82"></A><EM> d’une courbe paramétrique
un point où la vitesse </EM><EM><I>v</I>(<I>t</I>)=(<I>x</I>′(<I>t</I>),<I>y</I>′(<I>t</I>))</EM><EM> est non nulle.
En un point régulier, la courbe est tangente au vecteur vitesse
(la direction du vecteur vitesse est donc une propriété
géométrique, alors que le vecteur vitesse est une propriété
cinématique).
On notera en particulier que la tangente est horizontale si </EM><EM><I>y</I>′=0</EM><EM>
et verticale si </EM><EM><I>x</I>′=0</EM><EM>.</EM><P><EM>On appelle </EM><EM><B>point singulier</B></EM><A NAME="@default83"></A><EM> 
un point où la vitesse s’annulle.
</EM></P></DIV><P>
On verra dans la suite comment étudier la tangente en un point
singulier d’une courbe. Génériquement, une courbe n’a pas
de points singuliers, car il faut annuler simultanément les
deux dérivées, or on n’a qu’un seul paramètre libre <I>t</I>. Par contre
une famille de courbes (<I>x</I><SUB><I>m</I></SUB>(<I>t</I>),<I>y</I><SUB><I>m</I></SUB>(<I>t</I>)) dépendant d’un paramètre
<I>m</I> (par exemple <I>x</I><SUB><I>m</I></SUB>(<I>t</I>)=<I>t</I><SUP>2</SUP>−<I>mt</I>, <I>y</I><SUB><I>m</I></SUB>(<I>t</I>)=<I>m</I>/(1+<I>t</I><SUP>2</SUP>)+<I>t</I>)
possède en général un nombre discret de valeurs du
paramètre pour lesquelles la courbe admet un point singulier.
Dans l’exemple, <I>x</I><SUB><I>m</I></SUB>′=2<I>t</I>−<I>m</I>, <I>y</I><SUB><I>m</I></SUB>′=−2<I>mt</I>/(1+<I>t</I><SUP>2</SUP>)<SUP>2</SUP>+1, les deux 
dérivées s’annulent si <I>m</I>=−2 
(en <I>t</I>=−1, <I>x</I>=−1, <I>y</I>=−2) ou <I>m</I>=2 (en <I>t</I>=1).
Commandes Xcas :
<CODE>x:=t^2-m*t; y:=m/(1+t^2)+t;</CODE><BR>
<CODE>solve([diff(x,t),diff(y,t)],[m,t])</CODE><BR>
<CODE>supposons(m=[-2.0,-5,5,0.1])</CODE><BR>
<CODE>plotparam([x,y],t=((-3) .. 3))</CODE></P><P>Remarque : en cinématique, si la vitesse est nulle en un point
et que les équations ne dépendent pas explicitement du temps,
on reste indéfiniment en ce point qui est un point d’équilibre,
la notion de tangente à la courbe n’a alors pas de sens.
On peut aussi suivre une trajectoire qui se rapproche 
de plus en plus d’un point d’équilibre (la limite de (<I>x</I>(<I>t</I>),<I>y</I>(<I>t</I>))
est alors ce point, pour <I>t</I> → +∞ si l’équilibre
est stable ou <I>t</I> → − ∞ si l’équilibre est instable).
L’étude des points singuliers est donc plus du domaine de la
géométrie que de la cinématique.</P><P>Pour faire une étude locale plus précise dans le cas d’un point
régulier, ou pour déterminer la tangente en un point singulier,
il faut poursuivre le développement de Taylor à un ordre plus
grand. Á l’ordre 2, si <I>x</I> et <I>y</I> sont 3 fois continument
dérivables, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>M</I>(<I>t</I><SUB>0</SUB>)<I>M</I>(<I>t</I><SUB>0</SUB>+<I>h</I>)</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">= 
<I>h</I> (<I>x</I>′(<I>t</I><SUB>0</SUB>),<I>y</I>′(<I>t</I><SUB>0</SUB>))+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>x</I>′′(<I>t</I><SUB>0</SUB>),<I>y</I>′′(<I>t</I><SUB>0</SUB>))
+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I><SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>x</I>′′′(<I>t</I><SUB><I>x</I></SUB>),<I>y</I>′′′(<I>t</I><SUB><I>y</I></SUB>))
</TD></TR>
</TABLE><P>
Si les vecteurs vitesse <I>v</I>=(<I>x</I>′(<I>t</I><SUB>0</SUB>),<I>y</I>′(<I>t</I><SUB>0</SUB>))
et accélération <I>a</I>=(<I>x</I>′′(<I>t</I><SUB>0</SUB>),<I>y</I>′′(<I>t</I><SUB>0</SUB>))
ne sont pas colinéaires, 
alors {<I>v</I>,<I>a</I>} forme 
une base, et dans cette base <I>M</I>(<I>t</I><SUB>0</SUB>)<I>M</I>(<I>t</I><SUB>0</SUB>+<I>h</I>)
a pour coordonnées (<I>h</I>,<I>h</I><SUP>2</SUP>/2)+<I>O</I>(<I>h</I><SUP>3</SUP>), l’arc
de courbe est identique à un arc de parabole à l’ordre 2. 
On parle de <B>point birégulier</B><A NAME="@default84"></A>.
Si {<I>v</I>,<I>a</I>} est une base directe,
l’arc est convexe (la vitesse
“tourne” dans le sens trigonométrique),
sinon il est concave. On peut tester cela en calculant
le déterminant des coordonnées de {<I>v</I>,<I>a</I>} ou le sens
de variations de la pente de la tangente 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>m</I>=<I>y</I>′/<I>x</I>′,    <I>m</I>′=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I>′<I>y</I>′′−<I>x</I>′′<I>y</I>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>′<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><DIV CLASS="theorem"><B>Théorème 13</B>  <EM>
Si </EM><EM><I>x</I>′<I>y</I>′</EM><EM>′</EM><EM>−<I>x</I>′</EM><EM>′</EM><EM><I>y</I>′&gt;0</EM><EM> [resp </EM><EM>&lt;0</EM><EM>] sur un intervalle du domaine de définition,
la courbe n’a que des points réguliers, la direction de la tangente en un point
est donnée par le vecteur vitesse, et la courbe est </EM><EM><B>convexe</B></EM><A NAME="@default85"></A><EM>
[resp. concave].
Si </EM><EM><I>x</I>′<I>y</I>′</EM><EM>′</EM><EM>−<I>x</I>′</EM><EM>′</EM><EM><I>y</I>′=0</EM><EM>, on parle de point d’</EM><EM><B>inflexion</B></EM><A NAME="@default86"></A><EM> analytique.
</EM></DIV><P>Exemple : point d’inflexion en <I>t</I>=0 de
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP>+1</TD></TR>
</TABLE></TD><TD CLASS="dcell">,<I>t</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP>+2</TD></TR>
</TABLE></TD><TD CLASS="dcell">) </TD></TR>
</TABLE><P>
La courbe admet deux autres points d’inflexion (<I>t</I>=−3.16... et
<I>t</I>=1.31...) qu’on peut déterminer avec les commandes Xcas suivantes :<BR>
<CODE>X:=x^3/(x^2+1); Y:=x+1/(x^2+2); fsolve(X'*Y''-X''*Y',x)</CODE><BR>
Note : on note <CODE>x</CODE> comme paramètre pour pouvoir 
utiliser la notation <CODE>'</CODE> pour dériver, si on utilise <CODE>t</CODE>
comme paramètre, il faut utiliser <CODE>diff(.,t)</CODE> pour calculer
la dérivée par rapport à <I>t</I>.</P><P>On observe que la convexité est presque une propriété géométrique,
en effet si on change de paramétrage
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>′=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> =</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>s</I>′ </TD></TR>
</TABLE><P>
on dérive par rapport à <I>t</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>′′ = (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>s</I>′)′=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I><SUP>2</SUP><I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>s</I>′<SUP>2</SUP> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">
<I>s</I>′′ </TD></TR>
</TABLE><P>
puis :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>′<I>y</I>′′− <I>y</I>′ <I>x</I>′′ = 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>s</I>′ (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I><SUP>2</SUP><I>y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>s</I>′<SUP>2</SUP> +</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dy</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>s</I>′′ ) − 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dy</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>s</I>′ (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I><SUP>2</SUP><I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>s</I>′<SUP>2</SUP> +</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>s</I>′′ ) 
= <I>s</I>′<SUP>3</SUP> (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I><SUP>2</SUP><I>y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> − 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dy</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I><SUP>2</SUP><I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> )
</TD></TR>
</TABLE><P>
on retrouve en facteur <I>s</I>′<SUP>3</SUP> qui est positif si on parcourt la courbe
dans le même sens ou négatif sinon.</P><P>La convexité décrit qualitativement la géométrie
de la courbe à l’ordre 1. On verra plus loin que le rayon de courbure décrit
quantitativement la géométrie de la courbe à l’ordre
2 (comme la tangente décrit la géométrie de la courbe
à l’ordre 1).</P><P>Dans le cas d’un point singulier (<I>v</I>=0), si 
<I>a</I>≠ 0, alors la
tangente est portée par <I>a</I>. L’étude complète
de la nature
d’un point singulier ou de la convexité d’un point régulier
tel que <I>a</I> est colinéaire à <I>v</I> 
nécessite de faire un
développement de Taylor en <I>t</I>=<I>t</I><SUB>0</SUB>
jusqu’au premier ordre <I>q</I> où l’on a : 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
les dérivées d’ordre 1, .., <I>p</I>−1 de (<I>x</I>,<I>y</I>) s’annulent
</LI><LI CLASS="li-itemize">la dérivée d’ordre <I>p</I>&gt;0 est non nulle, on la note <I>T</I>
</LI><LI CLASS="li-itemize">les dérivées d’ordre <I>p</I>+1,...,<I>q</I>−1 sont colinéaires
à la dérivée d’ordre <I>p</I> (ce qui inclus le cas où elles
sont nulles)
</LI><LI CLASS="li-itemize">la dérivée d’ordre <I>q</I> est non colinéaire à <I>p</I>,
on la note <I>A</I>.
</LI></UL><P>
Dans la base { <I>T</I>,<I>A</I>}, les
composantes de <I>M</I>(<I>t</I><SUB>0</SUB>)<I>M</I>(<I>t</I>)
sont alors respectivement équivalentes à <I>h</I><SUP><I>p</I></SUP>/<I>p</I>! et <I>h</I><SUP><I>q</I></SUP>/<I>q</I>!
où <I>h</I>=<I>t</I>−<I>t</I><SUB>0</SUB>.
On en déduit que la tangente à la courbe est portée par
<I>T</I>.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
si <I>p</I> est pair, on a un <B>rebroussement</B><A NAME="@default87"></A> 
de première espèce 
si <I>q</I> est impair (cas générique d’un point singulier, <I>p</I>=2, <I>q</I>=3)
ou de deuxième espèce si <I>q</I> est pair. On ne peut pas
régulariser le point singulier par changement de paramétrage.
</LI><LI CLASS="li-itemize">Si <I>p</I> est impair, on peut reparamétriser la courbe
pour rendre le point non singulier (prendre <I>t</I>′=(<I>t</I>−<I>t</I><SUB>0</SUB>)<SUP>1/<I>p</I></SUP>)
mais au risque de perdre de la régularité,
</LI><LI CLASS="li-itemize">Si <I>p</I> est impair et <I>q</I> impair on a un point d’inflexion 
géométrique (changement de sens de convexité).
</LI></UL><P>Exemples de points singuliers en <I>t</I>=0 : 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>t</I><SUP>2</SUP>,<I>t</I><SUP>3</SUP>),  (<I>t</I><SUP>2</SUP>+<I>t</I><SUP>4</SUP>,<I>t</I><SUP>4</SUP>+<I>t</I><SUP>5</SUP>),  (<I>t</I><SUP>3</SUP>,<I>t</I><SUP>4</SUP>),  (<I>t</I><SUP>3</SUP>,<I>t</I><SUP>5</SUP>) </TD></TR>
</TABLE><P>
Les deux derniers cas peuvent être reparamétrés (au prix
de la perte de dérivabilité seconde) en posant <I>t</I>′=<I>t</I><SUP>1/3</SUP>.
Pour faire l’étude d’un point singulier avec Xcas, on peut utiliser
la fonction <CODE>series</CODE> sur <I>x</I>(<I>t</I>) et <I>y</I>(<I>t</I>) (ici c’est inutile,
le développement de Taylor est déjà fait).</P><!--TOC subsection Plan d’étude d’une courbe-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc76">8.5</A>  Plan d’étude d’une courbe</H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
On détermine et on restreint le domaine de définition
(périodicité, symétries). 
</LI><LI CLASS="li-enumerate">On étudie les branches infinies (point exclus du domaine,
± ∞) : asymptotes horizontales, verticales, directions
asymptotiques, asymptotes obliques.
</LI><LI CLASS="li-enumerate">Recherche de <I>x</I>′ et <I>y</I>′, on étudie l’annulation conjointe
des deux (points singuliers).
</LI><LI CLASS="li-enumerate">Signe de <I>x</I>′ et <I>y</I>′, double tableau de variations faisant
apparaitre <I>x</I>,<I>x</I>′,<I>y</I>,<I>y</I>′ et mise
en évidence des tangentes horizontales et verticales
</LI><LI CLASS="li-enumerate">Pour préciser le tracé, on peut chercher la convexité
en étudiant le signe de <I>x</I>′<I>y</I>′′−<I>x</I>′′<I>y</I>′.
</LI><LI CLASS="li-enumerate">Tracé des points remarquables et des asymptotes et
on les relie entre eux en suivant les sens de variations
du tableau de variations.
</LI></OL><!--TOC subsection Courbes en polaires-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc77">8.6</A>  Courbes en polaires</H3><!--SEC END --><P><A NAME="@default88"></A>
Une courbe en polaire est essentiellement
donnée par la distance au centre <I>O</I> d’un
point <I>M</I> de la courbe en fonction de l’angle θ 
entre la direction <I>Ox</I> et le vecteur <I>OM</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>OM</I> = <I>r</I>(θ)</TD></TR>
</TABLE><P> 
On s’autorise toutefois des valeurs négatives pour <I>r</I>,
si c’est le cas, on prend alors le symétrique par rapport
à l’origine du point situé à distance −<I>r</I> et d’angle θ.</P><P>Représentation graphique : avec Xcas, on utilise
la commande <CODE>plotpolar</CODE>, sur calculatrices
graphiques, sélectionner le mode de tracé en polaire.
Par exemple <CODE>plotpolar(cos(2x),x=0..2*pi)</CODE>.</P><P>Exemples de courbes en polaire :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>r</I>=1,  <I>r</I>=θ,  <I>r</I>=cos(2θ),  <I>r</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2+cos(θ)</TD></TR>
</TABLE></TD><TD CLASS="dcell">,
 <I>r</I> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+2cos(θ)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>C’est un cas particulier de courbe en paramétriques puisque
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>x</I>,<I>y</I>)=(<I>r</I>(θ) cos(θ), <I>r</I>(θ) sin(θ))</TD></TR>
</TABLE><P>
mais on préfère souvent faire l’étude directement sur la
fonction <I>r</I>. Le plan d’étude est calqué sur celui
d’une courbe en paramétrique, mais on n’a qu’une seule fonction
<I>r</I> à étudier.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
domaine de définition de <I>r</I>, recherche
de périodicités et symétries (θ → −θ
ou ajout d’une demi ou d’un quart de période).
Si la période n’est pas un multiple de 2π, cela correspond
à obtenir un arc de la courbe par rotation à partir d’un autre arc
de la courbe.
</LI><LI CLASS="li-itemize">branches infinies pour θ<SUB>0</SUB> (non infini)
où <I>r</I> n’est pas défini. La branche a pour direction
asymptotique la droite faisant un angle θ<SUB>0</SUB> avec
l’axe des <I>x</I>. On calcule alors la limite si elle existe de 
<I>r</I> sin(θ−θ<SUB>0</SUB>)), c’est l’ordonnée dans
le repère obtenu par rotation d’angle θ<SUB>0</SUB>, si la limite
est finie et vaut <I>l</I>
on a une asymptote (d’équation <I>Y</I>=<I>l</I> dans le repère tourné).
</LI><LI CLASS="li-itemize">si la fonction n’est pas périodique, il y a lieu
d’étudier l’existence de limites de <I>r</I> en ± ∞, si la limite
est nulle on s’approche en spiralant de l’origine, si
elle est finie, il y a un cercle asymptote, si elle est
infinie une spirale.
</LI><LI CLASS="li-itemize">comme <I>OM</I>=<I>r</I> <I>e</I><SUB><I>r</I></SUB>, 
<I>e</I><SUB><I>r</I></SUB>=(cos(θ),sin(θ)), 
la vitesse (si le temps est θ) est donnée par 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>v</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">= <I>r</I>′ <I>e</I><SUB><I>r</I></SUB> + <I>r</I> <I>e</I><SUB>θ</SUB></TD></TR>
</TABLE>
où { <I>e</I><SUB><I>r</I></SUB>,<I>e</I><SUB>θ</SUB>} est une base orthonormée directe.<BR>
Donc si <I>r</I>≠ 0 ou <I>r</I>′ ≠ 0, le point est régulier et
l’angle <I>V</I> de la tangente avec <I>e</I><SUB><I>r</I></SUB> vérifie 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">tan(<I>V</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>r</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I>′</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ∈ ℝ ⋃ { ± ∞ } </TD></TR>
</TABLE>
(si <I>r</I> ≠ 0 et <I>r</I>′=0, la tangente est portée par <I>e</I><SUB>θ</SUB>).
Si <I>r</I>=0, la tangente est portée par <I>e</I><SUB><I>r</I></SUB>.<SUP><A NAME="text7" HREF="#note7">7</A></SUP>
</LI><LI CLASS="li-itemize">On ne peut avoir un point singulier que pour <I>r</I>=0. On ne fait
pas leur étude comme en paramétriques, en effet la tangente est
toujours portée par <I>e</I><SUB><I>r</I></SUB>, si <I>r</I> change de signe la courbe
a la même allure que pour un point régulier, si <I>r</I> ne change pas
de signe on a un rebroussement de première espèce (puisqu’on
traverse la tangente lorsque θ augmente)
</LI><LI CLASS="li-itemize">Convexité : pour avoir un point d’inflexion, il faut que 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">′′=0
⇔
<I>r</I><SUP>2</SUP>+2<I>r</I>′<SUP>2</SUP>−<I>rr</I>′′=0
</TD></TR>
</TABLE>
On peut le montrer en calculant la dérivée de
θ+arctan(<I>r</I>/<I>r</I>′) 
ou avec Xcas de la manière suivante<BR>
<CODE>X:=r(x)*cos(x); Y:=r(x)*sin(x); simplify(X'*Y''-Y'*X'')</CODE><BR>
<CODE>simplify(1/r(x)+(1/r(x))'')</CODE><BR>
où on a noté <I>x</I> l’angle θ pour pouvoir dériver avec <CODE>'</CODE>
et <I>X</I> et <I>Y</I> les deux coordonnées.
</LI><LI CLASS="li-itemize">de même on calcule la courbure définie en section <A HREF="#sec:courbure">9.2</A>
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">κ = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>r</I><SUP>2</SUP>+2<I>r</I>′<SUP>2</SUP>−<I>rr</I>′′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>r</I><SUP>2</SUP>+<I>r</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP>3</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE>
</LI></UL><!--TOC subsection Coniques-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc78">8.7</A>  Coniques</H3><!--SEC END --><P><A NAME="@default89"></A>
Les coniques sont des courbes implicites dont l’équation
cartésienne est du second degré 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>ax</I><SUP>2</SUP>+<I>cy</I><SUP>2</SUP>+<I>bxy</I>+<I>dx</I>+<I>ey</I>+<I>f</I>=0</TD></TR>
</TABLE><P>
On va voir qu’elles sont de trois types : ellipses, hyperbole,
parabole<SUP><A NAME="text8" HREF="#note8">8</A></SUP> 
et on va les paramétriser, à partir de leur équation
cartésienne ou à partir de leurs éléments géométriques
(le calcul des éléments géométrique à partir de l’équation
cartésienne fait intervenir l’étude des formes quadratiques, il ne
sera pas abordé dans ce cours).
Les coniques sont des courbes importantes en géométrie, 
ce qui a un intérêt en optique 
(parabole), mais aussi en cinématique (première loi de Kepler :
l’orbite décrite par une planète est une ellipse dont
le Soleil occupe un foyer).</P><!--TOC subsubsection Paramétrisation rationnelle-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc79">8.7.1</A>  Paramétrisation rationnelle</H4><!--SEC END --><P>
Si on connait un point d’une conique, on peut effectuer
un changement d’origine en ce point, l’équation cartésienne
devient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>x</I>,<I>y</I>)=<I>ax</I><SUP>2</SUP>+<I>bxy</I>+<I>cy</I><SUP>2</SUP>+<I>dx</I>+<I>ey</I>=0</TD></TR>
</TABLE><P>
On suppose que (<I>d</I>,<I>e</I>)≠(0,0)<SUP><A NAME="text9" HREF="#note9">9</A></SUP>.
On cherche alors l’intersection de la conique avec la droite <I>y</I>=<I>tx</I>
(de pente <I>t</I>), on va voir que la droite coupe en général la
conique en deux points, l’origine et un autre point dont on
calcule les coordonnées en fonction de <I>t</I><SUP><A NAME="text10" HREF="#note10">10</A></SUP>.
Graphiquement, par exemple<BR>
<CODE>t:=2; implicitplot(x^2+3y^2-x*y+3x+y); droite(y=t*x)</CODE><BR>
puis faire varier la valeur de <I>t</I> ou d’un des coefficients de l’équation.
En effet on obtient une équation du second degré en <I>x</I>,
qui se factorise par <I>x</I>, l’autre solution donne alors <I>x</I> comme
fraction rationnelle en <I>t</I>, puis <I>y</I>=<I>tx</I>.
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>ax</I>+<I>btx</I>+<I>ct</I><SUP>2</SUP><I>x</I>+<I>d</I>+<I>et</I>)<I>x</I>=0 ⇒ <I>x</I>=0, <I>x</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−<I>d</I>−<I>et</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ct</I><SUP>2</SUP>+<I>bt</I>+<I>a</I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Comme dans le premier exemple sur le cercle trigonométrique,
on n’obtient pas toujours toute la conique (s’il existe un autre
point d’abscisse <I>x</I>=0).</P><P>Si on cherche les points où le dénominateur en <I>t</I> s’annule, on doit
calculer (pour <I>c</I>≠ 0 et en supposant que la fraction
−<I>d</I>−<I>et</I>/<I>ct</I><SUP>2</SUP>+<I>bt</I>+<I>a</I> est irréductible<SUP><A NAME="text11" HREF="#note11">11</A></SUP>)
le discriminant<SUP><A NAME="text12" HREF="#note12">12</A></SUP> 
de l’équation du second degré
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">Δ= <I>b</I><SUP>2</SUP>−4<I>ac</I></TD></TR>
</TABLE><P>
Il y a trois cas possibles: 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
si <I>b</I><SUP>2</SUP>&lt;4<I>ac</I>, il n’y a pas de racine, le
paramétrage est défini pour tout <I>t</I> et les limites en ±
∞ de <I>x</I> sont nulles (car <I>c</I> ≠ 0 puisque 4<I>ac</I>&gt;<I>b</I><SUP>2</SUP>),
la conique est bornée, c’est une ellipse.
</LI><LI CLASS="li-itemize">si <I>b</I><SUP>2</SUP>=4<I>ac</I>, il y a une racine double, qui engendre
une étude de branche infinie en <I>t</I>=−<I>b</I>/(2<I>c</I>), on
obtient une parabole (deux branches selon que <I>t</I> tend
vers −<I>b</I>/(2<I>c</I>) par la droite ou la gauche).
</LI><LI CLASS="li-itemize">si <I>b</I><SUP>2</SUP>&gt;4<I>ac</I>, il y a deux racines distinctes <I>t</I><SUB>±</SUB> , 
donc deux valeurs de <I>t</I> où il faut faire une étude
de branche infinie, on a alors une
<B>hyperbole</B><A NAME="@default90"></A>
avec 4 branches infinies et deux asymptotes parallèles à
<I>y</I>=<I>t</I><SUB>±</SUB><I>x</I> (en effet le rapport <I>y</I>/<I>x</I>=<I>t</I> tend bien
vers <I>t</I><SUB>±</SUB> et <I>y</I>−<I>t</I><SUB>±</SUB><I>x</I> a une limite car la racine au
dénominateur de <I>x</I> et <I>y</I> est simple 
donc elle se simplifie avec le numérateur)
</LI></UL><P><B>Exercice</B> : paramétrer et faire l’étude des coniques :<BR>
<I>x</I><SUP>2</SUP>+4<I>y</I><SUP>2</SUP>+2<I>xy</I>=4, <I>x</I><SUP>2</SUP>−3<I>y</I><SUP>2</SUP>+2<I>xy</I>=4</P><!--TOC subsubsection Ellipse-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc80">8.7.2</A>  Ellipse</H4><!--SEC END --><P><A NAME="@default91"></A>
</P><DIV CLASS="theorem"><B>Définition 14</B>  <EM>
L’ellipse </EM><EM><I>E</I></EM><EM> de foyers </EM><EM><I>F</I></EM><SUB><EM>1</EM></SUB><EM> et </EM><EM><I>F</I></EM><SUB><EM>2</EM></SUB><EM> de demi-grand axe
</EM><EM><I>a</I></EM><EM> est l’ensemble des points </EM><EM><I>M</I></EM><EM> du plan tels que 
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><I>MF</I></EM><SUB><EM>1</EM></SUB><EM>+<I>MF</I></EM><SUB><EM>2</EM></SUB><EM>=2<I>a</I></EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>
Exemple : ouvrir un niveau de géométrie 2d dans Xcas,
choisir le mode ellipse cliquer 2 points (ce sont les foyers)
puis un 3ème point (point de l’ellipse), passer en mode
pointeur et faire bouger l’un des points, observer la forme
de l’ellipse qui en résulte. Ou dans une ligne de commande
normale taper la commande <CODE>ellipse()</CODE> avec
en arguments les 2 points foyers et un point de l’ellipse
ou l’équation cartésienne de l’ellipse, par exemple
<CODE>ellipse(-1,1,3+i)</CODE> trace l’ellipse de foyers (−1,0), (1,0)
et passant par le point (3,1).</P><P>On note 2<I>c</I>=<I>F</I><SUB>1</SUB><I>F</I><SUB>2</SUB> la distance entre les deux foyers, qui doit être
plus petite que 2<I>a</I> pour que l’ellipse soit non vide.
L’excentricité de l’ellipse est définie par <I>e</I>=<I>c</I>/<I>a</I> &lt; 1. Si <I>e</I>=0,
on obtient un cercle de centre <I>F</I><SUB>1</SUB>=<I>F</I><SUB>2</SUB> et de rayon <I>a</I>. Si <I>e</I>≠ 0,
on va voir qu’il s’agit d’un cercle contracté
selon l’axe perpendiculaire à <I>F</I><SUB>1</SUB><I>F</I><SUB>2</SUB> dans un rapport de 
√<SPAN style="text-decoration:overline">1−<I>e</I></SPAN><SUP><SPAN style="text-decoration:overline">2</SPAN></SUP>. On va également calculer l’équation en
coordonnées polaires de <I>E</I> (c’est sous cette forme
que l’on montre que la Terre décrit une ellipse 
dont le Soleil occupe un foyer).</P><P>Soit <I>O</I> le milieu de <I>F</I><SUB>1</SUB> et <I>F</I><SUB>2</SUB>, on se place dans le repère 
orthonormé
dont le premier axe <I>Ox</I> contient <I>F</I><SUB>1</SUB> et <I>F</I><SUB>2</SUB> donc les
coordonnées de <I>F</I><SUB>1</SUB> sont (<I>c</I>,0) et celles de <I>F</I><SUB>2</SUB> sont (−<I>c</I>,0). 
Soit <I>M</I>(<I>x</I>,<I>y</I>) un
point de l’ellipse, on a d’une part :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>MF</I><SUB>1</SUB><SUP>2</SUP> − <I>MF</I><SUB>2</SUB><SUP>2</SUP> = (<I>x</I>−<I>c</I>)<SUP>2</SUP>−(<I>x</I>+<I>c</I>)<SUP>2</SUP> = −4<I>cx</I> </TD></TR>
</TABLE><P>
et d’autre part :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>MF</I><SUB>1</SUB><SUP>2</SUP> − <I>MF</I><SUB>2</SUB><SUP>2</SUP> = (<I>MF</I><SUB>1</SUB> + <I>MF</I><SUB>2</SUB>)(<I>MF</I><SUB>1</SUB> − <I>MF</I><SUB>2</SUB> ) = 2<I>a</I> (<I>MF</I><SUB>1</SUB> − <I>MF</I><SUB>2</SUB> )</TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>MF</I><SUB>1</SUB> − <I>MF</I><SUB>2</SUB> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−2<I>cx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
en additionnant avec <I>MF</I><SUB>1</SUB>+<I>MF</I><SUB>2</SUB>=2<I>a</I> et en appliquant <I>c</I>=<I>ea</I>, on en déduit :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:MF1"></A>
<I>MF</I><SUB>1</SUB> = <I>a</I> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>cx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = <I>a</I>−<I>ex</I> 
    (15)</TD></TR>
</TABLE><P>
En prenant le carré, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>x</I>−<I>ea</I>)<SUP>2</SUP> + <I>y</I><SUP>2</SUP> = (<I>a</I>−<I>ex</I>)<SUP>2</SUP></TD></TR>
</TABLE><P>
d’où :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I><SUP>2</SUP> + <I>x</I><SUP>2</SUP> (1−<I>e</I><SUP>2</SUP>) = <I>a</I><SUP>2</SUP>(1−<I>e</I><SUP>2</SUP>) </TD></TR>
</TABLE><P>
finalement :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I><SUP>2</SUP> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1−<I>e</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = <I>a</I><SUP>2</SUP> </TD></TR>
</TABLE><P>
qui est bien la contraction selon <I>Oy</I> de rapport √<SPAN style="text-decoration:overline">1−<I>e</I></SPAN><SUP><SPAN style="text-decoration:overline">2</SPAN></SUP> du
cercle de centre <I>O</I> et de rayon <I>a</I> (appelé grand cercle de
l’ellipse).</P><P>En coordonnées paramétriques, on peut utiliser le paramétrage suivant :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>x</I>,<I>y</I>)=(<I>a</I>cos(<I>t</I>),<I>b</I>sin(<I>t</I>))</TD></TR>
</TABLE><P>En coordonnées polaires, on note ρ la distance de <I>F</I><SUB>1</SUB> à
<I>M</I>, et θ l’angle entre l’axe <I>Ox</I> et <I>F</I><SUB>1</SUB><I>M</I>. L’abscisse de <I>M</I>
est donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>= <I>ea</I> + ρ cos(θ)</TD></TR>
</TABLE><P>
que l’on combine avec (<A HREF="#eq:MF1">15</A>) pour obtenir :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ρ = <I>a</I>−<I>ex</I> =<I>a</I>(1−<I>e</I><SUP>2</SUP>) − <I>e</I> ρ cos(θ) </TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ρ = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I>(1−<I>e</I><SUP>2</SUP>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+<I>e</I>cos(θ)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P><B>Remarques</B> :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
La première loi de Képler dit que l’orbite d’une planète
autour du Soleil est une ellipse dont le Soleil occupe un des foyers.
La troisième loi de Képler donne la relation suivante entre le
demi-grand axe <I>a</I>, la période de révolution <I>T</I> et µ
le produit de la masse du Soleil<SUP><A NAME="text13" HREF="#note13">13</A></SUP> par la constante de gravitation :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>T</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">µ</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4π<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE>
</LI><LI CLASS="li-itemize">Attention, <I>t</I>≠ θ. Et dans le cas de l’orbite
de la Terre autour du Soleil, aucun de ces deux paramétrages n’est
le temps τ. Le paramétrage par le temps se déduit de la loi
des aires
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>r</I><SUP>2</SUP> <I>d</I>θ =  <I>L</I> <I>d</I>τ ,   
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>L</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">µ</TD></TR>
</TABLE></TD><TD CLASS="dcell">= <I>a</I>(1−<I>e</I><SUP>2</SUP>) </TD></TR>
</TABLE>
Il nécessite de résoudre
une équation , cf. l’équation du temps dans le cours :<BR>
<CODE>www-fourier.ujf-grenoble.fr/~parisse/climat/orbite.html</CODE><BR>
L’excentricité de la Terre est faible, <I>e</I>=0.0167 en
ce moment, elle est responsable d’une petite différence 
de durée des saisons, elle varie très lentement au cours des siècles sous
l’action des autres planètes du système solaire, cette lente variation
est une des raisons des glaciations du quartenaire.
</LI><LI CLASS="li-itemize">On peut aussi définir géométriquement l’ellipse
par un foyer <I>F</I> et une directrice <I>D</I>, c’est l’ensemble des <I>M</I> tels
que <I>d</I>(<I>M</I>,<I>F</I>)=<I>ed</I>(<I>M</I>,<I>D</I>). Dans le repère d’origine <I>O</I>, <I>D</I>
a pour équation <I>x</I>=<I>a</I>/<I>e</I> (dans le repère d’origine <I>F</I>, c’est
<I>x</I>=<I>a</I>/<I>e</I>−<I>e</I>=<I>a</I>(1−<I>e</I><SUP>2</SUP>)/<I>e</I>). En effet <I>MF</I>=<I>a</I>−<I>ex</I>=<I>e</I>(<I>a</I>/<I>e</I>−<I>x</I>).
</LI></UL><!--TOC subsubsection Parabole-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc81">8.7.3</A>  Parabole</H4><!--SEC END --><P><A NAME="@default92"></A>
Si <I>F</I> est un point et <I>D</I> une droite ne passant pas par <I>F</I>, la
parabole de foyer <I>F</I> et directrice <I>D</I> est l’ensemble des points
équidistants de <I>F</I> et <I>D</I>.
En choisissant un repère tel que la droite <I>D</I> ait pour équation
<I>y</I>=0 et en prenant <I>F</I>(0,1), <I>M</I>(<I>x</I>,<I>y</I>) appartient à la parabole
si 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>y</I>|=<I>d</I>(<I>M</I>,<I>D</I>)=<I>d</I>(<I>M</I>,<I>F</I>)=</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>(<I>y</I>−1)<SUP>2</SUP>+<I>x</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
donc en passant au carré :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I><SUP>2</SUP>=(<I>y</I>−1)<SUP>2</SUP>+<I>x</I><SUP>2</SUP> ⇒ <I>y</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2</SUP>+1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
La parabole est donc (ici) un graphe de fonction, donc
un cas particulier de courbe paramétrique.
On peut trouver son équation en polaire,
en prenant <I>F</I> comme origine et la directrice
verticale (donc l’équation de la droite
devient par exemple <I>y</I>=−1) sous la forme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ρ=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+sin(θ)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
cf. l’exercice sur les coniques données par foyer et directrice,
qui traite aussi le cas des hyperboles. On peut aussi faire à
titre d’exercice l’étude de la courbe en polaire :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ρ = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>A</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+<I>e</I>cos(θ)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
lorsque <I>e</I>=1 et <I>e</I>&gt;1.</P><P>Un intérêt majeur de la parabole en optique est que
les rayons incidents perpendiculaires à la directrice
se réfléchissent en passant par le
foyer (on peut même montrer que cela caractérise
une parabole). Illustration-démonstration
avec Xcas dans un niveau de géométrie taper les commandes
</P><PRE CLASS="verbatim">P:=plotfunc(x^2/2+1/2,x=-5..5);
supposons(a=[-1.4,-5,5,0.1]);
D:=droite(x=a);
M:=inter_unique(P,D);
T:=tangent(P,M);
R:=symetrie(T,D);
trace(R);
</PRE><P>puis faire varier <I>a</I> en cliquant sur les flèches. Noter
la valeur<BR>
<CODE>inter_unique(R,droite(x=0))</CODE><BR>
elle est indépendante de <I>a</I> et est le foyer. On peut
montrer qu’une courbe ayant cette propriété est
une parabole.</P><!--TOC subsubsection Hyperbole-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc82">8.7.4</A>  Hyperbole</H4><!--SEC END --><P>
Une hyperbole de foyers <I>F</I> et <I>F</I>′ est définie comme l’ensemble
des points <I>M</I> tels que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>MF</I>−<I>MF</I>′|=2<I>a</I></TD></TR>
</TABLE><P>
où <I>a</I> est une constante telle que 2<I>a</I>&gt;2<I>c</I>=<I>FF</I>′, avec une excentricité
<I>e</I>=<I>c</I>/<I>a</I>&gt;1.</P><P>En physique, les hyperboles interviennent dans les trajectoires non
périodiques en mécanique céleste, mais aussi comme courbes 
de déphasage constant entre deux sources situées aux deux foyers
(les figures d’interférence font apparaitre des hyperboles).</P><P>On peut faire un calcul analogue à celui de l’ellipse, 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>MF</I>−<I>MF</I>′=± 2<I>a</I>,  <I>MF</I>+<I>MF</I>′=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>MF</I><SUP>2</SUP>−<I>MF</I>′<SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>MF</I>−<I>MF</I>′</TD></TR>
</TABLE></TD><TD CLASS="dcell">=−± 2<I>ex</I></TD></TR>
</TABLE><P>
on en déduit que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>MF</I>=± (<I>a</I>−<I>ex</I>)</TD></TR>
</TABLE><P>
l’équation cartésienne de l’hyperbole dans le repère centré au milieu
des foyers, d’axe <I>Ox</I> l’axe des foyers est donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUP>2</SUP>(<I>e</I><SUP>2</SUP>−1)</TD></TR>
</TABLE></TD><TD CLASS="dcell">=1</TD></TR>
</TABLE><P>
On peut paramétrer les deux branches de l’hyperbole par
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>(<I>t</I>)=± <I>a</I>cosh(<I>t</I>), <I>y</I>(<I>t</I>)=<I>a</I></TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>e</I><SUP>2</SUP>−1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> sinh(<I>t</I>)</TD></TR>
</TABLE><P>
et en polaires
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ρ=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I>(1−<I>e</I><SUP>2</SUP>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+<I>e</I>cos(θ)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Exercice : faire l’étude de la courbe paramétrée et montrer que
l’hyperbole admet deux asymptotes d’équation <I>y</I> = ± <I>b</I>/<I>a</I> <I>x</I>.</P><!--TOC section Propriétés métriques des courbes.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc83">9</A>  Propriétés métriques des courbes.</H2><!--SEC END --><P> <A NAME="sec:courbes_m"></A>
</P><!--TOC subsection Longueur d’arc-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc84">9.1</A>  Longueur d’arc</H3><!--SEC END --><P>
La longueur <I>ds</I> d’un morceau de courbe régulier parcouru
pendant un petit intervalle de temps <I>dt</I> est égal
au premier ordre à la longueur du segment tangent parcouru,
ou encore au produit de la norme de la vitesse instantanée 
par <I>dt</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>ds</I>=</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>x</I>′<SUP>2</SUP>+<I>y</I>′<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>dt</I></TD></TR>
</TABLE><P>
On remarque que cette quantité est invariante par changement de 
paramétrage, si <I>t</I>=<I>t</I>(τ) alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>ds</I></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP>2</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dy</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:8em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>d</I>τ</TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP>2</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dy</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>d</I>τ</TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP>2</SUP></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I>τ</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">2</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> |</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>d</I>τ</TD></TR>
</TABLE></TD><TD CLASS="dcell">| <I>d</I>τ </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>d</I>τ</TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP>2</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dy</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>d</I>τ</TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>d</I>τ</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On en déduit
</P><DIV CLASS="theorem"><B>Proposition 15</B>  <EM> 
La longueur d’un arc de courbe entre les points
de paramètre </EM><EM><I>t</I></EM><SUB><EM>0</EM></SUB><EM> et </EM><EM><I>t</I></EM><SUB><EM>1</EM></SUB><EM> vaut
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><FONT SIZE=6>∫</FONT></EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><EM><EM><I>t</I></EM><SUB><EM>1</EM></SUB></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><BR>
<BR>
</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><EM><I>t</I></EM><SUB><EM>0</EM></SUB></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> </EM></TD><TD CLASS="dcell"><EM><FONT SIZE=5>√</FONT></EM></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD ALIGN=center NOWRAP><EM><I>x</I>′</EM><SUP><EM>2</EM></SUP><EM>+<I>y</I>′</EM><SUP><EM>2</EM></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> <I>dt</I></EM></TD></TR>
</TABLE><EM><BR>
En coordonnées polaires :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><FONT SIZE=6>∫</FONT></EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><EM><EM>θ</EM><SUB><EM>1</EM></SUB></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><BR>
<BR>
</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><EM>θ</EM><SUB><EM>0</EM></SUB></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> </EM></TD><TD CLASS="dcell"><EM><FONT SIZE=5>√</FONT></EM></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD ALIGN=center NOWRAP><EM><I>r</I>′</EM><SUP><EM>2</EM></SUP><EM>+<I>r</I></EM><SUP><EM>2</EM></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> <I>d</I>θ</EM></TD></TR>
</TABLE><EM>
</EM></DIV><P><B>Remarque</B> : il est très rare que l’on puisse effectuer
le calcul explicite d’une primitive de √<SPAN style="text-decoration:overline"><I>x</I>′</SPAN><SUP><SPAN style="text-decoration:overline">2</SPAN></SUP><SPAN style="text-decoration:overline">+<I>y</I>′</SPAN><SUP><SPAN style="text-decoration:overline">2</SPAN></SUP>,
il faut alors se contenter d’une valeur approchée de l’intégrale
lorsque <I>t</I><SUB>0</SUB> et <I>t</I><SUB>1</SUB> ont des valeurs numériques, calculée
par des méthodes numériques qui généralisent la méthode
des rectangles (cf. le cours de mat249).
Ce calcul se fait avec Xcas (ou une calculatrice formelle) en donnant
une valeur approchée à l’une des bornes.
Il y a quelques exceptions  par exemple la longueur d’un arc de 
parabole se calcule avec une formule explicite (essayez la
commande <CODE>int(sqrt(1+4t^2),t,t0,t1)</CODE> ou
<CODE>arcLen([t,t^2],t,t0,t1)</CODE>). La 
<B>cycloïde</B><A NAME="@default93"></A><SUP><A NAME="text14" HREF="#note14">14</A></SUP> 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>(<I>t</I>)=<I>R</I>(<I>t</I>−sin(<I>t</I>)), <I>y</I>(<I>t</I>)=<I>R</I>(1−cos(<I>t</I>))</TD></TR>
</TABLE><P>
admet aussi une formule simple pour sa longueur (exercice, pour
vérifier le résultat avec Xcas, on peut utiliser 
la commande <CODE>halftan</CODE>).
Par contre, la
longueur d’un arc d’ellipse ne se calcule pas avec les fonctions
usuelles (on pourrait le faire mais en introduisant des fonctions spéciales
adaptées, appelées intégrales elliptiques) :<BR>
<CODE>a:=int(sqrt(sin(t)^2+4*cos(t)^2),t,0,2*pi); evalf(a)</CODE></P><!--TOC subsection Courbure, repère de Frenet, accélération normale et
tangentielle.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc85">9.2</A>  Courbure, repère de Frenet, accélération normale et
tangentielle.</H3><!--SEC END --><P> <A NAME="sec:courbure"></A>
Si on choisit la longueur d’arc comme nouveau paramètre de temps, 
la longueur parcourue est égale au temps, donc la vitesse instantannée
est de norme 1. On peut aussi le voir en notant <I>M</I>(<I>t</I>)=(<I>x</I>,<I>y</I>) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dM</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> =</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dM</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
⇒ || </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dM</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> || = || </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dM</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> || |</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">|</TD></TR>
</TABLE><P>
donc || <I>dM</I>/<I>ds</I> ||=1 les deux autres termes étant égaux.</P><P>Calculons maintenant l’accélération avec ce nouveau paramètre. Comme
la vitesse est de norme constante égale à 1, donc de carré 1, 
en dérivant (<I>dM</I>/<I>ds</I>)<SUP>2</SUP> par rapport à <I>s</I>,
on vérifie que l’accélération est perpendiculaire à la vitesse
pour ce paramétrage par la longueur d’arc <I>s</I>. 
L’accélération est donc portée par la normale à la trajectoire,
et sa mesure algébrique est appelé courbure (signée), notée κ,
la valeur absolue de l’inverse de κ est appelé le rayon de courbure
(la direction de l’accélération pointe vers le centre
de courbure). Si on se déplace sur un cercle de centre <I>O</I>
et de rayon <I>R</I> à vitesse 1, alors <I>x</I>(<I>t</I>)+<I>iy</I>(<I>t</I>)=<I>Re</I><SUP><I>it</I>/<I>R</I></SUP>, la vitesse
est donnée par <I>x</I>′+<I>iy</I>′=<I>ie</I><SUP><I>it</I>/<I>R</I></SUP> donc de norme 1, et l’accélération
par <I>x</I>″+<I>iy</I>″=−1/<I>R</I> <I>e</I><SUP><I>it</I>/<I>R</I></SUP>, sa norme vaut 1/<I>R</I> et sa direction
pointe vers le centre du cercle. Donc la courbe est, 
à l’ordre 2 au point considéré, identique à un cercle de rayon <I>R</I>.</P><P>Revenons au paramètrage initial <I>t</I>. Dérivons par rapport à <I>t</I> la vitesse
 <I>dM</I>/<I>dt</I> = ||<I>v</I>|| <I>dM</I>/<I>ds</I>, on obtient :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>a</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I><SUP>2</SUP><I>M</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>d</I>||</TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>v</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">||</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dM</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
+ ||</TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>v</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">|| </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I><SUP>2</SUP><I>M</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>d</I>||</TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>v</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">||</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dM</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + <I>v</I><SUP>2</SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I><SUP>2</SUP><I>M</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
L’accélération se décompose donc en deux parties 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
le premier
terme colinéaire au vecteur tangent est <B>l’accélération 
tangentielle</B><A NAME="@default94"></A>, 
de norme ||<I>v</I>||′, 
</LI><LI CLASS="li-itemize">le second terme perpendiculaire au vecteur tangent
est <B>l’accélération normale</B><A NAME="@default95"></A>, 
dont la norme est <I>v</I><SUP>2</SUP>/<I>R</I>,
où <I>R</I> est le <B>rayon de courbure</B><A NAME="@default96"></A>
</LI></UL><P>Autre formule de calcul : l’accélération normale <I>a</I><SUB><I>n</I></SUB> vaut <I>v</I><SUP>2</SUP>/<I>R</I> donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>a</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">∧ </TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>v</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">|=
<I>a</I><SUB><I>n</I></SUB> ||</TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>v</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">||=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">||</TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>v</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">||<SUP>3</SUP></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>R</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
⇒ <I>R</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">||</TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>v</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">||<SUP>3</SUP></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">|<I>a</I> ∧ </TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>v</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">|</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>x</I>′<SUP>2</SUP>+<I>y</I>′<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP>3</SUP></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">|<I>x</I>′<I>y</I>′′−<I>y</I>′<I>x</I>′′|</TD></TR>
</TABLE></TD></TR>
</TABLE><DIV CLASS="theorem"><B>Proposition 16</B>  <EM>
On appelle repère de </EM><EM><B>Frenet</B></EM><A NAME="@default97"></A><EM> 
en un point </EM><EM><I>M</I></EM><EM> régulier d’une courbe, 
le repère orthonormé direct formé par
le point de la courbe, le vecteur tangent </EM><EM><I>T</I></EM><EM> 
et le vecteur normal </EM><EM><I>N</I></EM><EM>. On a alors
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;"><EM>▸</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM><I>v</I></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM> </EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>=<I>v</I> </EM></TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;"><EM>▸</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM><I>T</I></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM> </EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>=</EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>ds</I></EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>dt</I></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;"><EM>▸</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM><I>T</I></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM> </EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>,    </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><EM><I>d</I>
</EM></TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;"><EM>▸</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM><I>T</I></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM> </EM></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>ds</I></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>=κ </EM></TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;"><EM>▸</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM><I>N</I></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM> </EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>, 
</EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><EM><I>d</I></EM></TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;"><EM>▸</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM><I>N</I></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM> </EM></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>ds</I></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>=−κ </EM></TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;"><EM>▸</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM><I>T</I></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM> </EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>,
   <I>R</I>=±</EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM>1</EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM>κ</EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>, 
</EM></TD></TR>
</TABLE><EM>
(l’avant-dernière formule vient du fait que </EM><EM>{ <I>T</I>
,<I>N</I> }</EM><EM> est une base orthonormée directe, le signe
</EM><EM>±</EM><EM> est déterminé par la convexité de la courbe), et :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;"><EM>▸</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM><I>a</I></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM> </EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>=</EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><EM><I>d</I></EM></TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;"><EM>▸</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM><I>v</I></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM> </EM></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>dt</I></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>=</EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>dv</I></EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>dt</I></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> </EM></TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;"><EM>▸</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM><I>T</I></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM> </EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>±
</EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>v</I></EM><SUP><EM>2</EM></SUP></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>R</I></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> </EM></TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;"><EM>▸</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM><I>N</I></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><EM> </EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>,   
<I>R</I>=</EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><EM><FONT SIZE=5>√</FONT></EM></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD ALIGN=center NOWRAP><EM><I>x</I>′</EM><SUP><EM>2</EM></SUP><EM>+<I>y</I>′</EM><SUP><EM>2</EM></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP><EM>3</EM></SUP></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM>|<I>x</I>′<I>y</I>′</EM><EM>′</EM><EM>−<I>y</I>′<I>x</I>′</EM><EM>′</EM><EM>|</EM></TD></TR>
</TABLE></TD></TR>
</TABLE><EM>
On appelle centre de courbure le point </EM><EM>Ω=<I>M</I>+</EM><EM>1/κ</EM><EM><I>N</I></EM><EM>. Le cercle de centre </EM><EM>Ω</EM><EM> passant par </EM><EM><I>M</I></EM><EM>
(de rayon </EM><EM><I>R</I></EM><EM>)
est appelé </EM><EM><B>cercle osculateur</B></EM><A NAME="@default98"></A><EM> en </EM><EM><I>M</I></EM><EM> à la courbe.
</EM></DIV><P>
<B>Exemple</B> : calcul du cercle osculateur en un point d’une parabole
(<I>t</I>,<I>t</I><SUP>2</SUP>).
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>′=1, <I>y</I>′=2<I>t</I>,  
</TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>T</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">=(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+4<I>t</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">,</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>t</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+4<I>t</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">),   
<I>y</I>′′=2   <I>R</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+4<I>t</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP>3</SUP></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Tracé par exemple pour <I>t</I>=1:<BR>
<CODE>G:=plotparam([t,t^2],t=-2..2,color=red); </CODE><BR>
<CODE>t0:=1;</CODE><BR>
<CODE>M:=point(t0,t0^2,affichage=point_croix+epaisseur_point_3);</CODE><BR>
<CODE>T:=tangent(G,M):;</CODE><BR>
<CODE>N:=normalize([-pente(T),1]); R:=(1+4t0^2)^(3/2)/2; </CODE><BR>
<CODE>C:=cercle(M+R*N,R);</CODE><BR>
ou avec Xcas version 1.1.1-18 ou supérieure<BR>
<CODE>C:=cercle_osculateur(G,M)</CODE></P><P><B>Remarques </B>: 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
La <B>courbure</B><A NAME="@default99"></A> est aussi la dérivée par
rapport à l’abscisse curviligne de 
l’angle θ fait par la
tangente avec une direction fixe, par exemple l’axe <I>Ox</I>.
En effet <I>T</I>=(cos(θ),sin(θ)),
dont la dérivée est le produit de θ′ par le vecteur
normal <I>N</I>.
</LI><LI CLASS="li-itemize">Génériquement, une courbe reste du même coté de
sa tangente (car le terme suivant dans le développement est d’ordre
2, de signe constant en 0), les exceptions sont les points
d’inflexion. Par contre,
génériquement une courbe traverse son cercle osculateur (en y
rentrant ou en en sortant), car le terme suivant dans le
développement de la différence entre les points des deux courbes 
est d’ordre 3 et change donc de signe en 0. Les exceptions
(tangeance courbe-cercle osculateur d’ordre 3 au lieu de 2)
sont appelés sommets d’une courbe, par exemple le sommet d’une
parabole.
</LI><LI CLASS="li-itemize">on peut calculer les coordonnées du centre du cercle
osculateur de manière algébrique à partir des
coordonnées paramétriques de <I>M</I> et de ses dérivées
(sans introduire de racines carrées)
</LI><LI CLASS="li-itemize">la courbe <I>D</I> décrite par les Ω lorsque <I>M</I> parcourt
la courbe étudiée <I>C</I> est appelée
<B>développée</B><A NAME="@default100"></A> 
de la courbe <I>C</I>. 
La vitesse de Ω vaut
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>M</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">κ</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>N</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">)=<I>v</I></TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>T</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">+
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>d</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">κ</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>N</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">κ</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>v</I>(−κ
</TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>T</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">)
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>d</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">κ</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>N</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD></TR>
</TABLE>
on en déduit que la tangente à la développée en Ω a
pour direction la normale <I>N</I>. 
<EM>L’enveloppe</EM><A NAME="@default101"></A><SUP><A NAME="text15" HREF="#note15"><EM>15</EM></A></SUP><EM> 
des normales à une courbe est donc sa développée.</EM><BR>
Exemple : développée de l’ellipse (2cos(<I>t</I>),sin(<I>t</I>))<BR>
Ouvrir un niveau de géométrie 2d dans Xcas, taper une commande
par ligne<BR>
<CODE>G:=plotparam([2*cos(t),sin(t)],t=0..2*pi)</CODE><BR>
<CODE>M:=element(G)</CODE><BR>
<CODE>T:=tangent(M)</CODE><BR>
<CODE>N:=perpendiculaire(M,T)</CODE><BR>
<CODE>trace(N)</CODE><BR>
passer en mode pointeur (menu mode du niveau
de géométrie) et faire bouger le point <I>M</I> le long
d’un quart de l’ellipse, ceci trace un faisceau de normales
à l’ellipse, dont on voit apparaitre l’enveloppe (limite
entre la région couverte et non couverte par des points
du faisceau de normales), cette enveloppe est
la développée de l’ellipse (vous pouvez utiliser 
le menu M à droite
du dessin pour effacer les traces). Avec Xcas version 1.1.1-18
ou ultérieure on peut tracer la développée avec
la commande <CODE>developpee(G)</CODE>.<BR>
Cf. aussi les animations de l’article Développée de wikipedia.<BR>
<B>Exercice</B> : calculer le repère de Frenet pour une ellipse <I>E</I>,
par exemple <I>x</I>(<I>t</I>)=4cos(<I>t</I>), <I>y</I>(<I>t</I>)=3sin(<I>t</I>)
puis le rayon de courbure, puis la développée <I>A</I>
(on obtient une courbe image par affinité
d’une <B>astroïde</B><A NAME="@default102"></A>). Donner une équation
paramétrique simple de <I>A</I>.<BR>
Vérification avec Xcas (version à jour) :<BR>
<CODE>E:=plotparam([4cos(t),3sin(t)],t,0,2pi); A:=developpee(E);</CODE><BR>
<CODE>eq:=simplify(parameq(A)); trigcos(re(eq)); im(eq)</CODE>
</LI><LI CLASS="li-itemize">De plus, comme <I>N</I> est normé,
la longueur d’arc de courbe de la développée est donnée par :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>d</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">κ</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD><TD CLASS="dcell"> <I>dt</I> = 
</TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD><TD CLASS="dcell">⎡<BR>
⎢<BR>
⎢<BR>
⎣</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">κ</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎤<BR>
⎥<BR>
⎥<BR>
⎦</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD><TD CLASS="dcell">
= |<I>R</I>(<I>t</I><SUB>1</SUB>)−<I>R</I>(<I>t</I><SUB>0</SUB>)|
</TD></TR>
</TABLE><BR>
Conséquence : si on enroule un fil sur la développée <I>D</I>,
que ce fil est tendu et que son extrémité coïncide, avant de
commencer à le dérouler, avec un point de la courbe <I>C</I> 
alors dans la suite du déroulé, l’extrémité parcoura la courbe
<I>C</I> (on dit que <I>C</I> est une développante de <I>D</I>).
</LI><LI CLASS="li-itemize">La développée peut servir à calculer une caustique en
optique. On envoie des rayons lumineux parallèle à une
direction fixée vers un miroir ayant la forme de la courbe <I>C</I>
la <B>caustique</B><A NAME="@default103"></A> 
est l’enveloppe des rayons lumineux réfléchis
(que l’on observe par une plus grande intensité lumineuse).
On peut montrer que la caustique est la développée 
de l’anticaustique de <I>C</I> par rapport à une droite perpendiculaire
aux rayons lumineux (pour déterminer 
l’anticaustique d’une courbe par rapport
à une droite, on prend un point de la courbe, on le projète sur
la droite puis on prend le symétrique du projeté par rapport à la
tangente à la courbe au point choisi, 
l’anticaustique est le lieu de ces symétriques). 
Cf. dans Xcas la session exemple du
menu <CODE>Exemple, geometrie, caustique</CODE>.
Les développées peuvent aussi servir dans le calcul de caustiques
par réfraction :
<CODE>http://www.mathcurve.com/courbes2d/caustic/caustic.htm</CODE>
</LI><LI CLASS="li-itemize">On peut faire une étude analogue pour une courbe dans
l’espace, dans ce cas la dérivée de <I>N</I>
par rapport à l’abscisse curviligne <I>s</I> fait intervenir une
composante sur le troisième vecteur du repère direct
<I>T</I> ∧<I>N</I>=<I>B</I> 
(<I>B</I> comme binormal), appelé
torsion.
</LI><LI CLASS="li-itemize"><B>Équation intrinsèque d’une courbe :</B><BR>
Il s’agit de trouver une courbe vérifiant une relation entre la
courbure (ou rayon de courbure) et l’abscisse curviligne, par exemple
la relation <I>Rs</I>=<I>b</I><SUP>2</SUP> avec <I>b</I>&gt;0 fixé.<SUP><A NAME="text16" HREF="#note16">16</A></SUP>
Pour trouver une telle courbe, on la paramètre par l’abscisse
curviligne <I>s</I>, donc la vitesse <I>dM</I>/<I>ds</I> est de norme 1 et caractérisée
par l’angle φ(<I>s</I>) fait avec une direction fixe, on a alors
φ′(<I>s</I>)=1/<I>R</I> et on en tire φ(<I>s</I>) puis <I>M</I>(<I>s</I>). 
Dans l’exemple, on a φ′(<I>s</I>)=<I>s</I>/<I>b</I><SUP>2</SUP>, donc φ(<I>s</I>)=<I>s</I><SUP>2</SUP>/(2<I>b</I><SUP>2</SUP>) (en
choisissant la direction fixe pour annuler la constante
d’intégration), puis :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dM</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ds</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">cos</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>s</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>b</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">,sin</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>s</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>b</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE>
puis en choisissant l’origine du repère :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I>(<I>s</I>)=</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>s</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> cos</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>b</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"> <I>du</I> ,
</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>s</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> sin</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>b</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
 <I>du</I>
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE>
en posant <I>u</I>=√<SPAN style="text-decoration:overline">2</SPAN><I>b</I> <I>v</I> on a aussi
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I>(<I>s</I>)=</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>b</I> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>s</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>b</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> cos(<I>v</I><SUP>2</SUP>)  <I>dv</I> ,
</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>s</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>b</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> sin(<I>v</I><SUP>2</SUP>)  <I>dv</I>
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE>
</LI></UL><!--TOC section Représentation des courbes implicites.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc86">10</A>  Représentation des courbes implicites.</H2><!--SEC END --><P> <A NAME="sec:implicite"></A>
Certaines représentations graphiques nécessitent peu d’outillage
mathématique, ainsi les fonctions, les courbes paramétrique
et polaires peuvent être représentées en échantillonant 
une ou plusieurs expressions
selon une discrétisation donnée explicitement par l’utilisateur
ou par des paramètres par défaut, les points obtenus
étant ensuite reliés par des segments.
On pourrait bien sur automatiser avec le calcul
formel l’étude de la courbe (tableaux de variations,
asymptotes, points singuliers, etc.).</P><P>Par contre les courbes données par une équation implicite
font intervenir des algorithmes et des mathématiques
plus intéressantes. En dimension 2, on se donne donc
une équation <I>f</I>(<I>x</I>,<I>y</I>)=0 et on suppose <I>f</I> suffisamment
régulière. Supposons la courbe non vide, soit (<I>x</I><SUB>0</SUB>,<I>y</I><SUB>0</SUB>)
un point de cette courbe, si (∂<SUB><I>x</I></SUB> <I>f</I>,∂<SUB><I>y</I></SUB> <I>f</I>)(<I>x</I><SUB>0</SUB>,<I>y</I><SUB>0</SUB>) ≠
0 on peut appliquer le théorème des fonctions implicites
et la courbe est localement comme une courbe de fonction (en <I>x</I> ou
en <I>y</I>). On en calcule la tangente et on peut suivre cette tangente
un pas de discrétisation puis utiliser une méthode numérique
de recherche de solution près de la tangente. Ces points
sont appelés <B>points réguliers</B><A NAME="@default107"></A><A NAME="@default108"></A></P><P>Les points où (∂<SUB><I>x</I></SUB> <I>f</I>,∂<SUB><I>y</I></SUB> <I>f</I>)=0 sont
les <B>points singuliers</B><A NAME="@default109"></A><A NAME="@default110"></A>. 
Génériquement, il n’y en a pas puisque
cela donne 3 équations à 2 inconnues, par contre si on
s’intéresse à une famille de courbes dépendant d’un
paramètre, il en apparait. En ces points, on calcule le
développement de Taylor et on recherche le premier
terme homogène non nul (homogène après translation bien sur), 
par exemple
<I>P</I><SUB>2</SUB>=<I>x</I><SUP>2</SUP>−<I>y</I><SUP>2</SUP> pour <I>x</I><SUP>3</SUP>+<I>x</I><SUP>2</SUP>−<I>y</I><SUP>2</SUP> en (0,0). 
Supposons que le polynôme
correspondant <I>P</I><SUB><I>m</I></SUB> est sans racines multiples, et (quitte
à faire une rotation) que le coefficient de <I>y</I><SUP><I>m</I></SUP> est non nul.
<I>P</I><SUB><I>m</I></SUB> est un polynôme homogène 
donc se factorise au moins numériquement
(en remplaçant une des variables par 1, on est ramené en dimension 1),
et on montre qu’il y a <I>m</I> arcs de courbe complexes tangents
aux droites d’équations ces <I>m</I> facteurs (et au plus
<I>m</I> arcs de courbe réels si on ne garde
que les racines réelles). En effet, on pose <I>y</I>=<I>xY</I> et on 
est amené à résoudre
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>x</I>,<I>xY</I>)=0=<I>x</I><SUP><I>m</I></SUP><I>P</I><SUB><I>m</I></SUB>(1,<I>Y</I>) + <I>x</I><SUP><I>m</I>+1</SUP> <I>g</I>(<I>x</I>,<I>Y</I>)</TD></TR>
</TABLE><P>
où <I>g</I> est un polynôme si <I>f</I> est un polynôme 
(plus généralement a la même régularité que <I>f</I>). 
Après simplification par <I>x</I><SUP><I>m</I></SUP>, on peut appliquer le théorème des
fonctions implicites pour déterminer <I>Y</I> en fonction de <I>x</I> au
voisinage de <I>x</I>=0 et de chacune des racines de <I>P</I><SUB><I>m</I></SUB>(1,<I>Y</I>) en <I>Y</I>
(puisque les racines sont simples).
Le point 
est dit <B>singulier-régulier</B><A NAME="@default111"></A> ou
singulier ordinaire<A NAME="@default112"></A>. 
C’est ce que fait la commande <CODE>implicitplot</CODE><A NAME="@default113"></A><A NAME="@default114"></A> de Xcas
(affichage des informations intermédiaires).</P><P>Si le point singulier n’est pas ordinaire, l’équation devient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>Y</I>−<I>t</I>)<SUP><I>k</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>Y</I>−<I>t</I><SUB><I>i</I></SUB>) + <I>xg</I>(<I>x</I>,<I>Y</I>)=0,    <I>k</I>&gt;1</TD></TR>
</TABLE><P>
et il faut faire intervenir des puissances fractionnaires en <I>x</I>
(dépendant de termes supérieurs du développement de Taylor
de <I>f</I> en (0,0))
pour désingulariser les <I>k</I> arcs de courbes ayant même tangente
<I>y</I>=<I>tx</I> en (0,0). Par exemple si <I>g</I>(0,<I>t</I>) ≠ 0, 
on pose <I>X</I>=<I>x</I><SUP>1/<I>k</I></SUP>, <I>Y</I>=<I>t</I>+<I>XZ</I>
qui donne 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Z</I><SUP><I>k</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>t</I>−<I>t</I><SUB><I>i</I></SUB>+<I>XZ</I>) + <I>g</I>(<I>X</I><SUP><I>k</I></SUP>,<I>t</I>+<I>XZ</I>)=0</TD></TR>
</TABLE><P>
pour <I>X</I>=0 on a alors <I>k</I> solutions non nulles <I>Z</I> qui
se prolongent au voisinage de <I>X</I>=0 par le théorème des
fonctions implicites.</P><P>Certains cas particuliers peuvent être traités en
transformant la courbe implicite en courbe paramétrique,
c’est le cas des courbes algébriques de degré 2, qui
sont des <B>coniques</B><A NAME="@default115"></A>. On peut les paramétrer rationnellement
si on en connait un point (en prenant la droite passant par ce point
de pente <I>m</I> et en cherchant l’autre point d’intersection
avec la conique (il y en a forcément un et un seul autre,
parce que l’équation correspondant aux points
d’intersection est de degré 2
et on connait déjà une solution), cette paramétrisation
est intéressante pour faire du calcul formel, mais moins
pour des représentations graphiques, on lui préferera
une paramétrisation trigonométrique pour une conique
ou exponentielle pour une hypebole, par exemple
(cos(<I>t</I>),sin(<I>t</I>)) plutot que 1+<I>it</I>/1−<I>it</I> pour
le cercle unité, paramétrisation obtenue en calculant
les éléments propres de la conique (<CODE>conique_reduite</CODE>). 
Pour les courbes algébriques de degré
plus grand, on commence par factoriser le polynôme,
c’est une factorisation absolue (section <A HREF="#sec:factorisation_absolue">16.7</A>) qui est nécessaire (ou
au moins numérique dans ℂ[<I>x</I>,<I>y</I>]). Pour le moment,
Xcas fait simplement une factorisation sur le corps
des coefficients, et repère les équations de coniques.</P><!--TOC section Formes différentielles et intégrales curvilignes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc87">11</A>  Formes différentielles et intégrales curvilignes</H2><!--SEC END --><P> 
<A NAME="sec:diff"></A>
Il s’agit dans cette section de calculer des intégrales
le long de l’arc. Cela intervient
par exemple pour calculer le travail d’une force au cours d’un
déplacement le long d’une courbe 
ou la quantité de chaleur/travail pendant
un cycle en thermodynamique (le long d’une courbe
dans le plan défini par deux coordonnées indépendantes 
comme par exemple pression-température ou pression-volume). 
Dans les cas favorables, on a un analogue des primitives, on peut
calculer un potentiel et faire la différence de potentiel entre les
deux extrémités du chemin pour calculer l’intégrale curviligne.
On va d’abord définir ce
qu’on peut intégrer le long d’une courbe, à savoir une
forme différentielle (aussi appelée 1-forme), puis on
donnera quelques résultats sur les formes fermées et
exactes (c’est le cas favorable, il correspond aux forces
conservatives en mécanique ou aux différentielles totales
de fonctions d’état en thermodynamique).</P><!--TOC subsection Forme différentielle-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc88">11.1</A>  Forme différentielle</H3><!--SEC END --><P>
Soit <I>V</I>(<I>x</I>,<I>y</I>) une fonction de deux variables continument dérivable.
On s’intéresse aux variations de <I>V</I> lorsqu’on se déplace dans le
plan depuis le point <I>M</I>(<I>x</I>,<I>y</I>) dans une direction donnée à
la vitesse <I>w</I>.
On a alors une formule équivalente à celle de 
la dérivée d’une fonction d’une variable :
</P><DIV CLASS="theorem"><B>Proposition 17</B>  <EM>
Pour tout vecteur </EM><EM><I>w</I>=(<I>w</I></EM><SUB><EM>1</EM></SUB><EM>,<I>w</I></EM><SUB><EM>2</EM></SUB><EM>)</EM><EM>, la dérivée de </EM><EM><I>V</I></EM><EM> en </EM><EM>(<I>x</I>,<I>y</I>)</EM><EM>
dans la direction </EM><EM><I>w</I></EM><EM> est donnée par :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM>&nbsp;</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM>lim</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><EM><I>h</I>→ 0</EM></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>V</I>((<I>x</I>,<I>y</I>)+<I>wh</I>)−<I>V</I>(<I>x</I>,<I>y</I>)</EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>h</I></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>=
∂</EM><SUB><EM><I>x</I></EM></SUB><EM><I>Vw</I></EM><SUB><EM>1</EM></SUB><EM>+∂</EM><SUB><EM><I>y</I></EM></SUB><EM><I>V</I> <I>w</I></EM><SUB><EM>2</EM></SUB></TD></TR>
</TABLE><EM>
On appelle </EM><EM><B>différentielle</B></EM><A NAME="@default116"></A><EM> 
de </EM><EM><I>V</I></EM><EM> et on note </EM><EM><I>dV</I></EM><EM> l’application
qui en un point </EM><EM>(<I>x</I>,<I>y</I>)</EM><EM> associe au vecteur </EM><EM><I>w</I></EM><EM> la valeur de la
dérivée directionnelle de </EM><EM><I>V</I></EM><EM> en </EM><EM>(<I>x</I>,<I>y</I>)</EM><EM> selon </EM><EM><I>w</I></EM><EM>
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><I>dV</I>(<I>w</I>)=∂</EM><SUB><EM><I>x</I></EM></SUB><EM><I>V</I> <I>w</I></EM><SUB><EM>1</EM></SUB><EM>+∂</EM><SUB><EM><I>y</I></EM></SUB><EM><I>V</I> <I>w</I></EM><SUB><EM>2</EM></SUB></TD></TR>
</TABLE><EM>
Cette application est linéaire par rapport à </EM><EM><I>w</I></EM><EM>.
</EM></DIV><P>
En effet :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>V</I>(<I>x</I>+<I>w</I><SUB>1</SUB><I>h</I>,<I>y</I>+<I>w</I><SUB>2</SUB><I>h</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>V</I>(<I>x</I>+<I>w</I><SUB>1</SUB><I>h</I>,<I>y</I>)+∂<SUB><I>y</I></SUB><I>V</I>(<I>x</I>+<I>w</I><SUB>1</SUB><I>h</I>,<I>y</I>) <I>w</I><SUB>2</SUB><I>h</I> + <I>o</I>(<I>h</I>)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>V</I>(<I>x</I>,<I>y</I>)+∂<SUB><I>x</I></SUB><I>V</I>(<I>x</I>,<I>y</I>) <I>w</I><SUB>1</SUB> <I>h</I> + ∂<SUB><I>y</I></SUB><I>V</I>(<I>x</I>+<I>w</I><SUB>1</SUB><I>h</I>,<I>y</I>) <I>w</I><SUB>2</SUB><I>h</I> + <I>o</I>(<I>h</I>)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>V</I>(<I>x</I>+<I>w</I><SUB>1</SUB><I>h</I>,<I>y</I>+<I>w</I><SUB>2</SUB><I>h</I>)−<I>V</I>(<I>x</I>,<I>y</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>∂<SUB><I>x</I></SUB><I>V</I>(<I>x</I>,<I>y</I>) <I>w</I><SUB>1</SUB> + ∂<SUB><I>y</I></SUB><I>V</I>(<I>x</I>+<I>w</I><SUB>1</SUB><I>h</I>,<I>y</I>) <I>w</I><SUB>2</SUB> +<I>o</I>(1) </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>→<SUB><I>h</I>→ 0</SUB></TD><TD ALIGN=left NOWRAP>∂<SUB><I>x</I></SUB><I>V</I>(<I>x</I>,<I>y</I>) <I>w</I><SUB>1</SUB>
+ ∂<SUB><I>y</I></SUB><I>V</I>(<I>x</I>,<I>y</I>) <I>w</I><SUB>2</SUB> </TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>Exemples </B>: 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
la dérivée de <I>V</I> selon la direction (1,0) (axe des <I>x</I>)
est ∂<SUB><I>x</I></SUB><I>V</I> et selon la direction (0,1) (axe des <I>y</I>)
est ∂<SUB><I>y</I></SUB> <I>V</I>.
</LI><LI CLASS="li-itemize">Soit <I>A</I>(<I>a</I>,<I>b</I>) et <I>V</I>(<I>x</I>,<I>y</I>)=√<SPAN style="text-decoration:overline">(<I>x</I>−<I>a</I>)</SPAN><SUP><SPAN style="text-decoration:overline">2</SPAN></SUP><SPAN style="text-decoration:overline">+(<I>y</I>−<I>b</I>)</SPAN><SUP><SPAN style="text-decoration:overline">2</SPAN></SUP> 
la distance de <I>A</I> au point <I>M</I>(<I>x</I>,<I>y</I>).
Alors <I>dV</I> existe en tout point <I>M</I> différent de <I>A</I>
et (∂<SUB><I>x</I></SUB> <I>V</I>,∂<SUB><I>y</I></SUB> <I>V</I>)=(<I>x</I>−<I>a</I>,<I>y</I>−<I>b</I>)/<I>AM</I> est le vecteur
unitaire porté par →<I>AM</I>.
</LI></UL><P><B>Remarque : Différentielle et gradient</B><BR>
La différentielle <I>dV</I> a les mêmes composantes que
le <B>gradient</B><A NAME="@default117"></A> de <I>V</I> (<CODE>gradient(V,[x,y])</CODE> avec Xcas), 
mais ce ne sont pas les mêmes objets : 
en un point donné
<I>dV</I> est une application linéaire (qui a un sens indépendamment
de la définition d’un produit scalaire)
alors que ∇ <I>V</I> est un vecteur (dont la relation
avec la dérivée directionnelle dépend du produit scalaire), 
on a pour tout vecteur <I>w</I> la relation 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>dV</I>(<I>w</I>)=∇ <I>V</I>. <I>w</I> </TD></TR>
</TABLE><P>
On a la même relation entre le travail d’une force (qui est une
forme linéaire qui s’applique sur les vecteurs déplacement) 
et la force correspondante (qui est un vecteur
défini à l’aide du produit scalaire). On parle parfois de vecteur
covariant pour la différentielle (et vecteur contravariant pour le
gradient).</P><P><B>Applications </B>: 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Tangente à une courbe de niveau :<BR>
le vecteur tangent en un point <I>M</I> d’une courbe de niveau de <I>V</I>
est dans le noyau de l’application linéaire <I>dV</I> en ce point
(puisque <I>V</I> est constant le long de le courbe), ou de
manière équivalente ∇ <I>V</I> est orthogonal à la
courbe de niveau.
</LI><LI CLASS="li-itemize">Calcul du gradient en coordonnées polaires.<BR>
le repère {<I>e</I><SUB><I>r</I></SUB>,<I>e</I><SUB>θ</SUB>} est orthonormé, pour
connaitre les coordonnées de ∇ <I>V</I> dans ce repère
il suffit de calculer la dérivée directionnelle de <I>V</I>
dans les directions <I>e</I><SUB><I>r</I></SUB> et <I>e</I><SUB>θ</SUB> car : 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">∇ <I>V</I>. <I>e</I><SUB><I>r</I></SUB> = <I>dV</I>(<I>e</I><SUB><I>r</I></SUB>),    ∇ <I>V</I>.<I>e</I><SUB>θ</SUB>=<I>dV</I>(<I>e</I><SUB>θ</SUB>)</TD></TR>
</TABLE> 
Or la dérivée directionnelle selon <I>e</I><SUB><I>r</I></SUB> est
la dérivée partielle de <I>V</I> par rapport à <I>r</I>, et la dérivée
directionnelle selon <I>e</I><SUB>θ</SUB> est la dérivée partielle de <I>V</I>
par rapport à θ divisée par <I>r</I> (il faut diviser par <I>r</I>
parce qu’on se déplace tangentiellement au cercle de rayon <I>r</I>), donc
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">∇ <I>V</I> = ∂<SUB><I>r</I></SUB> <I>V</I> <I>e</I><SUB><I>r</I></SUB> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ∂<SUB>θ</SUB><I>V</I> <I>e</I><SUB>θ</SUB></TD></TR>
</TABLE>
</LI><LI CLASS="li-itemize">Tangente et la normale en un point <I>M</I> d’une ellipse :<BR>
Ce sont la bissectrice extérieure et intérieure issues de <I>M</I> 
du triangle défini par <I>M</I> et les foyers. 
Cela vient du fait que le gradient de la
distance <I>FM</I> est le vecteur unitaire porté par
<I>FM</I>
et que l’ellipse est courbe de niveau de la somme des distances aux
foyers. On retrouve ainsi qu’un rayon lumineux issu d’un foyer
se réfléchit sur l’ellipse en passant par l’autre foyer.
</LI><LI CLASS="li-itemize">De même on peut déterminer géométriquement la
tangente et la normale à une parabole,
ce sont les bissectrices issues de <I>M</I> 
de la droite <I>MF</I> (où <I>F</I> est le foyer) et de la
perpendiculaire en <I>M</I> à la directrice de la parabole,
on retrouve ainsi que les rayons lumineux perpendiculaires
à la directrice se réflechissent sur la parabole en passant
par le foyer) et à une hyperbole (comme pour une ellipse).
</LI></UL><P>On note donc <I>dx</I> [resp. <I>dy</I>] la différentielle de
<I>V</I>(<I>x</I>,<I>y</I>)=<I>x</I> [resp. <I>V</I>(<I>x</I>,<I>y</I>)=<I>y</I>]<SUP><A NAME="text17" HREF="#note17">17</A></SUP>
on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>dV</I>=∂<SUB><I>x</I></SUB><I>V</I> <I>dx</I> + ∂<SUB><I>y</I></SUB><I>V</I> <I>dy</I></TD></TR>
</TABLE><P>Une <B>forme 
différentielle</B><A NAME="@default118"></A><A NAME="@default119"></A>
ω est la généralisation
de la différentielle d’une fonction, elle s’écrit sous la forme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ω=<I>M</I>(<I>x</I>,<I>y</I>) <I>dx</I> + <I>N</I>(<I>x</I>,<I>y</I>) <I>dy</I></TD></TR>
</TABLE><P>
où <I>M</I> et <I>N</I> sont des fonctions 
des deux variables <I>x</I>,<I>y</I>, mais pas forcément les dérivées
partielles d’une fonction <I>V</I>.</P><P>La définition géométrique d’une forme différentielle ω
est la donnée en tout point du plan (ou d’un domaine ouvert
du plan) d’une application linéaire de ℝ<SUP>2</SUP> à valeur dans ℝ
<SUP><A NAME="text18" HREF="#note18">18</A></SUP>
(ou en tout point de l’espace d’une application linéraire de ℝ<SUP>3</SUP>
à valeurs dans ℝ pour une courbe de ℝ<SUP>3</SUP>). 
Si on prend la base canonique de ℝ<SUP>2</SUP>,
une application linéaire de ℝ<SUP>2</SUP> dans ℝ est caractérisée
par sa matrice qui possède une ligne et deux colonnes et
a donc deux coefficients <I>M</I> et <I>N</I>, une forme différentielle
équivaut donc bien à la donnée d’un couple de fonction 
<I>M</I>(<I>x</I>,<I>y</I>),<I>N</I>(<I>x</I>,<I>y</I>).</P><!--TOC subsection Intégrale curviligne-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc89">11.2</A>  Intégrale curviligne</H3><!--SEC END --><P>
Ceci permet de donner la :
</P><DIV CLASS="theorem"><B>Définition 18</B>  <EM>
Pour calculer </EM><EM><B>l’intégrale 
curviligne</B></EM><A NAME="@default120"></A><A NAME="@default121"></A><EM>
d’une forme différentielle 
le long d’un arc de courbe orienté,
on choisit un paramétrage de l’arc continument dérivable par morceaux
(on suppose qu’il en existe un), 
et on calcule l’intégrale usuelle par rapport au paramètre
de la forme différentielle appliquée au vecteur tangent entre les
deux valeurs du paramètre correspondant à l’origine
et extrémité de l’arc de courbe :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><FONT SIZE=6>∫</FONT></EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><EM>&nbsp;</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><BR>
<BR>
</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><EM>γ</EM></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>ω = </EM></TD><TD CLASS="dcell"><EM><FONT SIZE=6>∫</FONT></EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><EM><EM><I>t</I></EM><SUB><EM>1</EM></SUB></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><BR>
<BR>
</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><EM><I>t</I></EM><SUB><EM>0</EM></SUB></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>
ω</EM></TD><TD CLASS="dcell"><EM>⎛<BR>
⎜<BR>
⎜<BR>
⎝</EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>d</I>γ(<I>t</I>)</EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>dt</I></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>⎞<BR>
⎟<BR>
⎟<BR>
⎠</EM></TD><TD CLASS="dcell"><EM><I>dt</I> </EM></TD></TR>
</TABLE><EM>
En coordonnées,
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><FONT SIZE=6>∫</FONT></EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><EM>&nbsp;</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><BR>
<BR>
</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><EM>γ</EM></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>ω =</EM></TD><TD CLASS="dcell"><EM><FONT SIZE=6>∫</FONT></EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><EM><EM><I>t</I></EM><SUB><EM>1</EM></SUB></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><BR>
<BR>
</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><EM><I>t</I></EM><SUB><EM>0</EM></SUB></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> 
(<I>M</I>(<I>x</I>(<I>t</I>),<I>y</I>(<I>t</I>)) </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>dx</I></EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>dt</I></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> + <I>N</I>(<I>x</I>(<I>t</I>),<I>y</I>(<I>t</I>) </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>dy</I></EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>dt</I></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>)  <I>dt</I></EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>
Exemple: on prend ω=<I>ydx</I> et on calcule l’intégrale
curviligne le long de l’arc de parabole (<I>t</I>,<I>t</I><SUP>2</SUP>) pour <I>t</I>∈[0,1],
on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>t</I><SUP>2</SUP>  <I>dt</I> =</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
En paramétrant par (<I>u</I><SUP>2</SUP>,<I>u</I><SUP>4</SUP>) avec <I>u</I>∈[0,1]
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>u</I><SUP>4</SUP> (2<I>u</I>  <I>du</I>) = </TD><TD CLASS="dcell">⎡<BR>
⎢<BR>
⎢<BR>
⎣</TD><TD CLASS="dcell">2</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUP>6</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎤<BR>
⎥<BR>
⎥<BR>
⎦</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
on retrouve le même résultat.</P><P>La valeur de l’intégrale est bien définie
indépendamment du paramétrage, 
en effet si on change de paramétrage avec une bijection
<I>t</I> → <I>u</I>(<I>t</I>) envoyant [<I>t</I><SUB>0</SUB>,<I>t</I><SUB>1</SUB>] sur [<I>u</I><SUB>0</SUB>,<I>u</I><SUB>1</SUB>], on a (en
utilisant la linéarité de ω à la deuxième ligne) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>u</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>u</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ω</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I>γ(<I>u</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>du</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><I>du</I></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ω</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>du</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I>γ(<I>t</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>du</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>du</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ω</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I>γ(<I>t</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>du</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">  ω</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I>γ(<I>t</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><I>dt</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Attention à l’orientation, si on change d’orientation, on change le
signe, par exemple si on parcourt l’arc de parabole de (1,1)
vers (0,0), en utilisant le paramétrage (1−<I>t</I>,(1−<I>t</I>)<SUP>2</SUP>), <I>t</I> ∈
[0,1], on obtient l’opposé :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (1−<I>t</I>) (−<I>dt</I>) = </TD><TD CLASS="dcell">⎡<BR>
⎢<BR>
⎢<BR>
⎣</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>t</I>−1)<SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎤<BR>
⎥<BR>
⎥<BR>
⎦</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> = −</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Remarque : le travail d’une force <I>F</I>=(<I>F</I><SUB><I>x</I></SUB>,<I>F</I><SUB><I>y</I></SUB>) le 
long d’un arc de courbe est donné par l’intégrale curviligne de la forme
différentielle <I>F</I><SUB><I>x</I></SUB> <I>dx</I>+<I>F</I><SUB><I>y</I></SUB><I>dy</I>. </P><!--TOC subsection Forme différentielle exacte-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc90">11.3</A>  Forme différentielle exacte</H3><!--SEC END --><P><A NAME="@default122"></A>
Voyons maintenant à quelle condition il existe un analogue du calcul
avec une primitive. On a:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">γ</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>dV</I>=<I>V</I>(γ(<I>t</I><SUB>1</SUB>))−<I>V</I>(γ(<I>t</I><SUB>0</SUB>)), </TD></TR>
</TABLE><P>
En effet, si on est sur un morceau d’arc où on peut paramétrer 
par <I>x</I> alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">γ</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>dV</I>=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>x</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ∂<SUB><I>x</I></SUB> <I>V</I>  <I>dx</I> =
<I>V</I>(γ(<I>t</I><SUB>1</SUB>))−<I>V</I>(γ(<I>t</I><SUB>0</SUB>))</TD></TR>
</TABLE><P>
De même si on peut paramétrer par <I>y</I>. On recolle
alors les morceaux d’arcs (on peut paramétrer par <I>x</I>
ou par <I>y</I> en tout point régulier de γ).</P><P>Pour une force qui dérive d’un potentiel,
on a donc montré que le travail de la force se calcule 
en faisant la différence
de potentiel entre les deux extrémités. Cette propriété, 
analogue au calcul d’intégrale classique en utilisant une primitive
n’est pas automatique, car elle implique que l’intégrale curviligne
ne dépend pas du chemin choisi pour relier les deux points.
Or en thermodynamique, la
chaleur est modélisée par une forme différentielle, 
mais la chaleur échangée dépend du chemin
suivi (c’est vrai aussi en mécanique pour le travail de forces non
conservatives comme les forces de frottement).
En mathématiques, on parle de forme différentielle exacte ou non exacte.
</P><DIV CLASS="theorem"><B>Définition 19</B>  <EM>
Une forme différentielle </EM><EM>ω</EM><EM> est exacte s’il existe une
fonction </EM><EM><I>V</I></EM><EM> telle que sur tout arc de courbe </EM><EM>γ</EM><EM> d’origine </EM><EM><I>A</I></EM><EM> et 
extrémité </EM><EM><I>B</I></EM><EM>
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><FONT SIZE=6>∫</FONT></EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><EM>&nbsp;</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><BR>
<BR>
</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><EM>γ</EM></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>ω = <I>V</I>(<I>B</I>)−<I>V</I>(<I>A</I>)</EM></TD></TR>
</TABLE><EM>
Attention la convention de signe est opposée à celle utilisée
pour le </EM><EM><B>potentiel</B></EM><A NAME="@default123"></A><EM> d’une force en physique.
</EM></DIV><P>
Si on choisit comme chemin un segment entre deux points <I>A</I> et <I>B</I>
d’ordonnées identiques <I>y</I> et d’abscisses <I>x</I> et <I>x</I>+<I>h</I>, alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>x</I>+<I>h</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>M</I> <I>dx</I>+<I>Ndy</I> = <I>V</I>(<I>x</I>+<I>h</I>,<I>y</I>)−<I>V</I>(<I>x</I>,<I>y</I>) </TD></TR>
</TABLE><P>
en faisant tendre <I>h</I> vers 0, on a 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">lim</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>h</I>→ 0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>V</I>(<I>x</I>+<I>h</I>,<I>y</I>)−<I>V</I>(<I>x</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = ∂<SUB><I>x</I></SUB> <I>V</I></TD></TR>
</TABLE><P>
De même <I>N</I>=∂<SUB><I>y</I></SUB> <I>V</I>.
Réciproquement, si <I>M</I>=∂<SUB><I>x</I></SUB> <I>V</I> et <I>N</I>=∂<SUB><I>y</I></SUB> <I>V</I> alors
ω=<I>dV</I> donc ∫<SUB>γ</SUB>ω=<I>V</I>(<I>B</I>)−<I>V</I>(<I>A</I>)
</P><DIV CLASS="theorem"><B>Proposition 20</B>  <EM>
Une forme différentielle </EM><EM>ω</EM><EM> est exacte si et seulement si il 
existe une fonction </EM><EM><I>V</I></EM><EM> telle que :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>ω=∂</EM><SUB><EM><I>x</I></EM></SUB><EM> <I>V</I> <I>dx</I> + ∂</EM><SUB><EM><I>y</I></EM></SUB><EM> <I>V</I> <I>dy</I>=<I>dV</I></EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>
Si <I>V</I> est deux fois continument différentiable alors
∂<SUB><I>yx</I></SUB> <I>V</I> = ∂<SUB><I>xy</I></SUB> <I>V</I>. D’où
une condition nécessaire pour que ω soit exacte :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">∂<SUB><I>y</I></SUB> <I>M</I> = ∂<SUB><I>yx</I></SUB> <I>V</I> = ∂<SUB><I>xy</I></SUB> <I>V</I> = ∂<SUB><I>x</I></SUB> <I>N</I></TD></TR>
</TABLE><DIV CLASS="theorem"><B>Définition 21</B>  <EM>
On appelle forme différentielle
fermée</EM><A NAME="@default124"></A><EM> une forme
différentielle </EM><EM>ω=<I>Mdx</I>+<I>Ndy</I></EM><EM> telle que
</EM><EM>∂</EM><SUB><EM><I>y</I></EM></SUB><EM> <I>M</I>=∂</EM><SUB><EM><I>x</I></EM></SUB><EM> <I>N</I></EM><EM> 
</EM></DIV><P>
Une forme exacte est toujours fermée, mais la réciproque n’est pas
toujours vraie, une forme fermée n’est pas forcément exacte, cela
dépend où elle est définie. Si elle est définie dans un
domaine ouvert de ℝ<SUP>2</SUP> sans trou (ℝ<SUP>2</SUP> tout entier,
un rectangle, un disque, etc.), 
on peut montrer qu’une forme 
fermée est une forme exacte, en appliquant le théorème 
de Stokes (voir section suivante). Sinon, il existe des
contre-exemples, comme sur le cercle unité
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ω=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>ydx</I>−<I>xdy</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2</SUP>+<I>y</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
La forme est fermée :<BR>
<CODE>simplify(diff(y/(x^2+y^2),y)-diff(-x/(x^2+y^2),x))</CODE><BR>
mais elle n’est pas exacte :<BR>
<CODE>x:=cos(t); y:=sin(t);</CODE><BR>
<CODE>int((y*diff(x,t)-x*diff(y,t))/(x^2+y^2),t,0,2*pi)</CODE></P><P>Pour trouver le potentiel<A NAME="@default125"></A> 
<I>V</I> dont une forme différentielle fermée
ω=<I>M</I> <I>dx</I>+<I>Ndy</I> est la différentielle, on résoud d’abord par exemple 
 <I>M</I> = ∂<SUB><I>x</I></SUB> <I>V</I> 
en intégrant <I>M</I> par rapport à <I>x</I>, <I>y</I> étant considéré
comme un paramètre, on obtient <I>V</I> à une constante d’intégration
près, cette constante d’intégration en <I>x</I> peut dépendre
de <I>y</I>, c’est donc une fonction <I>C</I>(<I>y</I>), 
on remplace dans <I>N</I>=∂<SUB><I>y</I></SUB> <I>V</I> et on intègre
en <I>y</I> pour trouver la valeur de <I>C</I>(<I>y</I>) (à une constante près).
Cette opération est executée par la commande <CODE>potential()</CODE>
de Xcas.</P><P>Si une forme n’est pas fermée, elle n’est pas exacte, et on ne peut
pas calculer une intégrale curviligne par différence de potentiel.
Il peut arriver qu’en multipliant la forme par une fonction, on trouve
une nouvelle forme qui elle est fermée, on parle alors de facteur
intégrant. Par exemple en thermodynamique, la forme chaleur
n’est pas fermée, mais en divisant par la température on
obtient une forme fermée dont le potentiel est l’entropie.
Cela peut aussi servir à trouver des constantes du mouvement
pour certaines équations différentielles. En effet, si on
se déplace le long d’une courbe de niveau du potentiel
d’une forme exacte, alors le long de cette courbe le potentiel
est constant, donc la forme appliquée au vecteur tangent
est nulle, on dit que la courbe de niveau est une courbe
intégrale de la forme différentielle (exacte).</P><!--TOC subsection Intégrale curviligne et intégrales doubles.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc91">11.4</A>  Intégrale curviligne et intégrales doubles.</H3><!--SEC END --><P>
Terminons ce chapitre par le lien entre intégrale curviligne
sur un lacet (chemin fermé) et intégrale double à l’intérieur 
du lacet. C’est évidemment surtout intéressant pour les
formes non exactes, car si γ est un lacet et ω
une forme exacte, alors ∫<SUB>γ</SUB>ω=0.
On a le théorème de <B>Stokes</B><A NAME="@default126"></A>, 
aussi appelé en dimension 2 
formule de <B>Green-Riemann</B><A NAME="@default127"></A> :
</P><DIV CLASS="theorem"><B>Théorème 22</B>  <EM>
Si </EM><EM><I>U</I></EM><EM> est un domaine de frontière orientée
</EM><EM>γ</EM><EM> continument dérivable 
(</EM><EM>γ</EM><EM> est donc un chemin fermé parcouru une fois que
l’on oriente dans le sens trigonométrique), et si 
</EM><EM>ω=<I>Mdx</I> + <I>N</I> <I>dy</I></EM><EM> est une forme
différentielle continument dérivable alors :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><FONT SIZE=6>∫</FONT></EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><EM>&nbsp;</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><BR>
<BR>
</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><EM>γ</EM></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>ω = </EM></TD><TD CLASS="dcell"><EM><FONT SIZE=6>∫</FONT></EM></TD><TD CLASS="dcell"><EM><FONT SIZE=6>∫</FONT></EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><EM>&nbsp;</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><BR>
<BR>
</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><EM><I>U</I></EM></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> <I>d</I>ω := 
</EM></TD><TD CLASS="dcell"><EM><FONT SIZE=6>∫</FONT></EM></TD><TD CLASS="dcell"><EM><FONT SIZE=6>∫</FONT></EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><EM>&nbsp;</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><BR>
<BR>
</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><EM><I>U</I></EM></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> (∂</EM><SUB><EM><I>x</I></EM></SUB><EM> <I>N</I> −∂</EM><SUB><EM><I>y</I></EM></SUB><EM> <I>M</I>)  <I>dx</I> <I>dy</I></EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>
Idée de la preuve : on commence par le cas où <I>U</I> est un
rectangle [<I>a</I>,<I>b</I>] × [α,β], on peut alors calculer 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>U</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ∂<SUB><I>x</I></SUB> <I>N</I>   <I>dx</I> <I>dy</I> 
= </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell">(</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>b</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>a</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ∂<SUB><I>x</I></SUB> <I>N</I>   <I>dx</I>) <I>dy</I>
= </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>N</I>(<I>b</I>,<I>y</I>)−<I>N</I>(<I>a</I>,<I>y</I>)) <I>dy</I> </TD></TR>
</TABLE><P>
on compare avec les intégrales curvilignes sur les segments verticaux
{(<I>a</I>,<I>y</I>), <I>y</I> ∈ [α,β]} et {(<I>b</I>,<I>y</I>), <I>y</I> ∈ [β,α]}.
De même pour <I>M</I> et les segments horizontaux.</P><P>Pour le cas d’un domaine d’intégration <I>U</I> plus général, on approche <I>U</I>
par une réunion disjointe de petits rectangles.</P><P><B>Application </B>: pour calculer l’aire d’un domaine <I>U</I> de frontière
γ, il suffit de
calculer l’une des intégrales curvilignes :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">γ</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>y</I> <I>dx</I>= </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">γ</TD></TR>
</TABLE></TD><TD CLASS="dcell">−<I>x</I> <I>dy</I> = </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">γ</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I> <I>dx</I> − <I>x</I>
<I>dy</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Par exemple, l’aire à l’intérieur de l’ellipse <I>x</I>=<I>a</I>cos(<I>t</I>),
<I>y</I>=<I>b</I>sin(<I>t</I>) vaut
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">2π</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>b</I> sin(<I>t</I>) <I>d</I>(<I>a</I>cos(<I>t</I>)) − <I>a</I>cos(<I>t</I>)
<I>d</I>(<I>b</I>sin(<I>t</I>))</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> = <I>ab</I>π </TD></TR>
</TABLE><P>On peut aussi calculer des moments d’<B>inertie</B><A NAME="@default128"></A> 
ou la position d’un <B>centre de gravité</B><A NAME="@default129"></A>
en se ramenant à une intégrale curviligne.<BR>
<B>Exemple </B>: Calculer la position du centre d’inertie d’un quart
de cercle <I>C</I>={(cos(<I>t</I>),sin(<I>t</I>)),  <I>t</I> ∈ [0,π/2]}.<BR>
On a donc <I>U</I> délimité par γ, réunion de {(<I>x</I>,0),  <I>x</I>
∈ [0,1]} , <I>C</I> et {(0,<I>y</I>), <I>y</I> ∈ [1,0]}.
Pour trouver la position du centre
d’inertie en <I>x</I> (en <I>y</I> c’est identique), on doit calculer
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>U</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I>  <I>dx</I> <I>dy</I> = </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">γ</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUP>2</SUP>  <I>dy</I>
= 0 + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> cos(<I>t</I>)<SUP>2</SUP> cos(<I>t</I>)  <I>dt</I> + 0= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
et on divise par π/4 l’aire du quart de cercle, on trouve
donc (4/3π,4/3π), on peut visualiser avec
la commande <CODE>cercle(0,1); G:=point(4/(3*pi),4/(3*pi))</CODE></P><!--TOC section Équations et systèmes différentiels.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc92">12</A>  Équations et systèmes différentiels.</H2><!--SEC END --><P> <A NAME="sec:ode"></A></P><!--TOC subsection Introduction et représentation graphique.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc93">12.1</A>  Introduction et représentation graphique.</H3><!--SEC END --><P>
On s’intéresse à l’équation différentielle
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:diff"></A>
<I>y</I>′=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dy</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">=<I>f</I>(<I>y</I>,<I>t</I>)
    (16)</TD></TR>
</TABLE><P>
où <I>y</I> ∈ ℝ<SUP><I>n</I></SUP> et <I>f</I>: ℝ<SUP><I>n</I></SUP> × ℝ → ℝ<SUP><I>n</I></SUP>.
Si <I>n</I>=1, c’est une équation différentielle, si <I>n</I>&gt;1 c’est
un système différentiel.</P><P>Exemple : en dimension <I>n</I>=1, <I>y</I>′=<I>f</I>(<I>y</I>,<I>t</I>)=<I>ay</I>. On sait résoudre cette
équation, les solutions sont de la forme <I>y</I>(<I>t</I>)=<I>Ce</I><SUP><I>at</I></SUP>. Si on trace
la courbe représentative de ces solutions (appelée
courbe intégrale), on observe que par
tout point du plan, il passe une solution unique. La tangente
à une courbe intégrale a pour pente <I>y</I>′=<I>ay</I> donc pour
vecteur directeur le vecteur de composantes (1,<I>ay</I>).</P><P>C’est vrai de manière plus générale, le vecteur directeur
de la tangente à une courbe intégrale est (1,<I>f</I>(<I>y</I>,<I>t</I>)). Si
on représente dans le plan selon un quadrillage régulier
les vecteurs (1,<I>f</I>(<I>y</I>,<I>t</I>)), une courbe intégrale doit être
tangente à ces vecteurs chaque fois qu’elle passe en un point
du quadrillage, (et à peu près tangente si elle passe à
proximité). Un tel quadrillage est appelé champ des tangentes
(commande <CODE>plotfield</CODE> en Xcas, mode également disponible
sur certaines calculatrices).</P><P>Exercice : tracer le champ des tangentes et quelques solutions
pour quelques exemples de fonction <I>f</I>(<I>y</I>,<I>t</I>), avec Xcas créer
une figure 2d, puis choisir le mode Champ des tangentes
du menu Geo, Graphe, entrer la fonction, puis cliquer en quelques
points pour faire tracer la solution passant par ces points.</P><P>L’équation (<A HREF="#eq:diff">16</A>) est d’ordre 1, or certaines équations
différentielles se présentent naturellement comme des
équations d’ordre 2, par exemple l’équation fondementale
de la dynamique (accélération=somme des forces divisée par
la masse). Mais on peut facilement se ramener à un
système différentiel d’ordre
1, en augmentant la dimension de <I>y</I>. Par exemple, si
on pose <I>y</I>=(<I>x</I>(<I>t</I>),<I>v</I>(<I>t</I>)), où <I>x</I>(<I>t</I>) est la position
et <I>v</I>(<I>t</I>) la vitesse, alors l’équation devient un système d’ordre 1
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>x</I>(<I>t</I>) </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>v</I>(<I>t</I>) </TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
= </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>v</I>(<I>t</I>) </TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>F</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
où <I>F</I> est la force, qui dépend de la position <I>x</I>(<I>t</I>) 
(champ électrique, gravitation...) et
éventuellement de la vitesse (force de frottement, champ magnétique...).
On utilise aussi assez fréquemment <I>y</I>=(<I>q</I>(<I>t</I>),<I>p</I>(<I>t</I>))
où <I>q</I>(<I>t</I>) est la position, et <I>p</I>(<I>t</I>) la quantité de mouvement
(qui dépend de la vitesse, linéairement en mécanique classique).</P><P>Représentation graphique : comme précédemment,
on peut se placer dans l’espace
des (<I>t</I>,<I>x</I>,<I>v</I>) (si <I>x</I> est en dimension 1), mais il est souvent
plus difficile d’observer des phénomènes sur un graphe
en 3-d que dans le plan, on préfère ne pas représenter explicitement le
temps <I>t</I>, mais uniquement (<I>x</I>,<I>v</I>), on est donc naturellement
ramené à représenter une solution (une courbe intégrale)
par une courbe paramétrique en (<I>x</I>,<I>v</I>) (ou en position
impulsion). On a encore la notion de champ des tangentes
si <I>f</I>(<I>y</I>,<I>t</I>)=<I>f</I>(<I>y</I>) ne dépend pas explicitement du temps
(on dit que le système est <EM>autonome</EM>), dans ce
cas une courbe intégrale a pour tangente en <I>y</I>∈ ℝ<SUP>2</SUP> 
de direction portée par le vecteur <I>f</I>(<I>y</I>) ∈ ℝ<SUP>2</SUP>.<BR>
<B>Exemple</B> : (<I>x</I>,<I>v</I>)′=5(−<I>v</I>,<I>x</I>). La commande<BR>
<CODE>plotfield(5*[-y,x],[x=-1..1,y=-1..1],normalize)</CODE><BR>
permet d’en représenter le champ des tangentes
et d’avoir une idée approximative de l’allure des solutions.
On sait résoudre ce système différentiel, soit en appliquant
une technique matricielle présentée ci-dessous, 
soit en se ramenant à une équation
linéaire d’ordre 2 à coefficients constants:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>′′=−5<I>v</I>′=−25<I>x</I></TD></TR>
</TABLE><P>
donc <I>x</I>(<I>t</I>)=<I>A</I>cos(5<I>t</I>)+<I>B</I>sin(5<I>t</I>), <I>A</I>, <I>B</I> étant déterminés
par les conditions initiales sur (<I>x</I>,<I>v</I>).</P><P>Une équation donnée sous la forme (<A HREF="#eq:diff">16</A>) 
est appelée une équation résolue en <I>y</I>,
car on a exprimé la dérivée en fonction de <I>y</I> et de <I>t</I>. Il
existe (plus fréquemment en mathématiques) d’autres formes d’équations
différentielles (non résolues) où le premier travail de résolution
peut consister à exprimer
<I>y</I>′ en fonction de <I>y</I> et <I>t</I> (ce qui n’est pas toujours possible 
explicitement).</P><P>Exemple : en dimension 1, <I>ty</I>′=<I>y</I>, on sait résoudre exactement
cette équation à variables séparables, les solutions sont de la 
forme <I>Ct</I>. On observe que contrairement à <I>y</I>′=<I>ay</I>
où passe une solution et une seule par chaque point du plan,
ici toutes les solutions valent 0 en <I>t</I>=0 : il passe une
infinité de solutions par le point (0,0) et il n’en passe aucune
par (0,<I>a</I>),  <I>a</I> ≠ 0. Ce phénomène de non unicité/non
existence vient de la mise sous forme résolue <I>y</I>′=<I>y</I>/<I>t</I> qui
fait apparaitre une singularité de <I>f</I>(<I>y</I>,<I>t</I>) en <I>t</I>=0.</P><P>On présente dans la suite de cette section 
des résultats qualitatifs sur les équations sous forme résolue
lorsqu’on ne sait pas les résoudre, ainsi que 
quelques méthodes explicites
pour certaines équations différentielles que l’on sait
résoudre.</P><!--TOC subsection Existence et unicité-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc94">12.2</A>  Existence et unicité</H3><!--SEC END --><P> <A NAME="sec:existence"></A>
Il s’agit ici de préciser dans quelles conditions le résultat
intuitif suivant est vrai : étant donné une condition initiale
<I>y</I>(<I>t</I><SUB>0</SUB>)=<I>y</I><SUB>0</SUB>, il y a une et une seule évolution possible, donc
une solution unique <I>y</I>(<I>t</I>) de l’équation ou du système
(<A HREF="#eq:diff">16</A>).</P><P>On a le :
</P><DIV CLASS="theorem"><B>Théorème 23</B>  <EM> </EM><A NAME="thm:eqdiff"></A><EM> (Cauchy-Lipschitz)
Si </EM><EM><I>f</I></EM><EM> est continument dérivable en </EM><EM><I>y</I></EM><EM> et </EM><EM><I>t</I></EM><EM> sur </EM><EM>ℝ</EM><SUP><EM><I>n</I></EM></SUP><EM> × </EM><EM>ℝ</EM><EM>
ou sur un domaine ouvert </EM><EM><I>D</I></EM><EM> inclus dans </EM><EM>ℝ</EM><SUP><EM><I>n</I></EM></SUP><EM> × </EM><EM>ℝ</EM><EM>, alors l’équation
(ou le système) résolu (</EM><A HREF="#eq:diff"><EM>16</EM></A><EM>) admet pour toute condition
initiale </EM><EM><I>y</I>(<I>t</I></EM><SUB><EM>0</EM></SUB><EM>)=<I>y</I></EM><SUB><EM>0</EM></SUB><EM> une solution unique
sur un intervalle maximal ouvert en temps contenant </EM><EM><I>t</I></EM><SUB><EM>0</EM></SUB><EM>.
</EM></DIV><P>
<B>Remarques</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Attention, l’existence d’une solution ne signifie absolument pas que
l’on sait calculer explicitement <I>y</I>(<I>t</I>).
</LI><LI CLASS="li-itemize">L’existence et l’unicité d’une solution permet d’affirmer le
caractère déterministe de l’équation. Mais la méconnaissance
précise de la condition initiale peut au cours du temps
provoquer une erreur tellement grande sur <I>y</I>(<I>t</I>)
que celle-ci devient imprédictible.
</LI><LI CLASS="li-itemize">Le théorème ne dit rien sur la taille de l’intervalle
d’existence de la solution (en temps). Certaines solutions
peuvent exploser en temps fini, par exemple<BR>
<CODE>desolve([y'=y^2,y(0)=1])</CODE><BR>
Bien entendu, si on modélise une quantité physique par <I>y</I>, dire
que <I>y</I> explose (en temps fini ou infini du reste)
signifie que les approximations utilisées pour la modélisation
ne sont plus valable bien avant.
</LI></UL><P>
On admettra ce théorème, voici quelques idées heuristiques
de la preuve. L’équation <I>y</I>′=<I>f</I>(<I>y</I>,<I>t</I>) peut se réécrire sous la forme
intégrale équivalente 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>(<I>t</I>)=<I>y</I>(<I>t</I><SUB>0</SUB>)+</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>y</I>′(<I>u</I>)  <I>du</I> =
<I>y</I>(<I>t</I><SUB>0</SUB>)+</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>y</I>(<I>u</I>),<I>u</I>) <I>du</I> </TD></TR>
</TABLE><P> 
Si <I>t</I> est assez proche de <I>t</I><SUB>0</SUB>, on peut approcher l’intégrale par 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>(<I>t</I>) = <I>y</I>(<I>t</I><SUB>0</SUB>) + (<I>t</I>−<I>t</I><SUB>0</SUB>) <I>f</I>(<I>y</I>(<I>t</I><SUB>0</SUB>),<I>t</I><SUB>0</SUB>) + petite erreur</TD></TR>
</TABLE><P>
C’est exactement ce qu’on fait en suivant le champ des tangentes
pour approcher une courbe intégrale graphiquement, et si on
discrétise le temps avec un pas petit, cette méthode
d’approximation est appelée méthode d’Euler. On peut
bien sur utiliser d’autres approximations (meilleures) de
l’intégrale pour avoir une meilleure approximation de la solution,
et les méthodes dites de Runge-Kutta utilisent cette idée. D’un
point de vue théorique, la preuve repose plutôt sur ce qu’on
appelle le théorème du point fixe, on met la valeur approchée
de <I>y</I>(<I>t</I>) trouvée dans l’équation intégrale pour avoir
une nouvelle valeur approchée de <I>y</I>(<I>t</I>), on recommence,
ainsi de suite, et on montre que
le processus converge (il s’agit mathématiquement parlant
d’une suite récurrente de fonctions, la preuve rigoureuse
de la convergence nécessite des outils mathématiques 
de niveau L3-M1 de maths, c’est l’analogue des suites
récurrentes de réels qui permettent de résoudre
numériquement des équations comme <I>x</I>=cos(<I>x</I>)
abordées en mat249).</P><P><B>Conséquence du théorème </B><A HREF="#thm:eqdiff"><B>23</B></A> : 
deux courbes intégrales de la même équation
différentielle ne peuvent se couper dans <I>D</I>. Donc si on connait
une courbe intégrale <I>C</I> de <I>D</I> et qu’on prend une condition initiale
en-dehors de cette courbe, la courbe intégrale unique passant
par cette condition initiale restera du même coté de <I>D</I>. Si on
connait deux courbes intégrales de <I>D</I>, une courbe intégrale
passant par une condition initiale entre les deux courbes restera
entre les deux courbes.</P><P><B>Exemple</B> : <I>y</I>′=<I>y</I>(1−<I>y</I>). Cette équation autonome admet deux solutions
évidentes <I>y</I>=0 et <I>y</I>=1. Donc pour toute condition initiale <I>y</I>(<I>t</I><SUB>0</SUB>)
∈ ]0,1[, on a <I>y</I>(<I>t</I>) ∈ ]0,1[<SUP><A NAME="text19" HREF="#note19">19</A></SUP>. 
On en déduit que <I>y</I>′=<I>y</I>(1−<I>y</I>)&gt;0
donc la solution <I>y</I> est strictement croissante, comme elle est
bornée par 0 et 1, elle admet une limite pour <I>t</I> → ±
∞, donc <I>y</I>′ tend vers 0 pour <I>t</I> → ±
∞, donc <I>y</I> tend vers 0 ou 1, et comme <I>y</I> croit, 
<I>y</I> → 0 en <I>t</I>=−∞ et <I>y</I> → 1 en <I>t</I>=+∞.
Le comportement à l’infini est donc indépendant de la valeur
précise de la condition initiale, pourvu qu’elle soit dans ]0,1[.</P><P><B>Exercice </B>: toujours pour <I>y</I>′=<I>y</I>(1−<I>y</I>) que se passe-t-il pour une
condition initiale <I>y</I>(<I>t</I><SUB>0</SUB>)&gt;1 ?</P><!--TOC subsection Quelques méthodes de résolution explicite.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc95">12.3</A>  Quelques méthodes de résolution explicite.</H3><!--SEC END --><!--TOC subsubsection Équations à variables
séparables-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc96">12.3.1</A>  Équations à variables
séparables</H4><!--SEC END --><P><A NAME="@default130"></A><A NAME="@default131"></A>
Si on peut factoriser <I>f</I>(<I>y</I>,<I>t</I>) en termes ne dépendant que
de <I>y</I> ou ne dépendant que de <I>t</I>, on dit que l’équation
est à variable séparable, et on intègre
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>′=<I>f</I>(<I>y</I>,<I>t</I>)=<I>g</I>(<I>t</I>)<I>h</I>(<I>y</I>) ⇒ </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dy</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>h</I>(<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><I>g</I>(<I>t</I>) 
<I>dt</I></TD></TR>
</TABLE><P>
On obtient une équation implicite de la forme <I>H</I>(<I>y</I>)=<I>G</I>(<I>t</I>)+<I>C</I> où
<I>G</I> est une primitive de <I>g</I>, <I>H</I> de 1/<I>h</I> et <I>C</I> une constante
arbitraire. Dans les cas favorables, on peut exprimer <I>y</I> en fonction
de <I>t</I> (par exemple si l’équation est linéaire sans second membre,
on a <I>h</I>(<I>y</I>)=<I>y</I> donc <I>H</I> est le log que l’on sait
inverser). Dans les cas moins favorables, on peut exprimer <I>y</I> et
<I>t</I> en fonction d’un paramètre <I>u</I> : la courbe intégrale est
une courbe paramétrée. Dans les cas défavorables, on reste
sous forme implicite.</P><P><B>Exercice </B>: résoudre explicitement l’équation <I>y</I>′=<I>y</I>(1−<I>y</I>)
et retrouver les résultats qualitatifs de la section précédente.</P><!--TOC subsubsection Équations linéaires-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc97">12.3.2</A>  Équations linéaires</H4><!--SEC END --><P><A NAME="@default132"></A><A NAME="@default133"></A>
On commence par résoudre l’équation sans second membre
(aussi appelée homogène)
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>n</I></SUB>(<I>t</I>) <I>y</I><SUP>[<I>n</I>]</SUP> +...+<I>a</I><SUB>1</SUB>(<I>t</I>)<I>y</I>′+<I>a</I><SUB>0</SUB>(<I>t</I>)=0</TD></TR>
</TABLE><P>
L’ensemble
des solutions est un espace vectoriel (car l’équation
est linéaire) et de dimension l’ordre de
l’équation : pour le prouver on peut appliquer le théorème
de Cauchy-Lipschitz au système d’ordre 1 équivalent, ce
système est tel que <I>y</I> est un vecteur de ℝ<SUP><I>n</I></SUP>, on a ensuite
un isomorphisme entre les solutions et la condition initiale.</P><P>Si l’ordre est 1, on a une équation à variables séparables
 <I>y</I>′/<I>y</I>=−<I>a</I><SUB>0</SUB>(<I>t</I>)/<I>a</I><SUB>1</SUB>(<I>t</I>) et la solution est une exponentielle :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>(<I>t</I>)=<I>Ce</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUB>0</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
<B>Exemple</B> : <I>y</I>′−<I>ty</I>=0, on a <I>y</I>(<I>t</I>)=<I>Ce</I><SUP>∫<I>t</I>  <I>dt</I></SUP>=<I>Ce</I><SUP><I>t</I><SUP>2</SUP>/2</SUP></P><P>Si l’ordre est plus grand que 1, on n’a en général pas de solution
explicitable avec les fonctions usuelles et des primitives, 
pour certaines équations importantes en physique, 
des fonctions spéciales
ont été créées pour exprimer les solutions, par
exemple les fonctions de Bessel. Il existe quelques
cas particuliers où le calcul explicite est possible, dont
le cas où les coefficients sont constants (section suivante).
Si on connait une solution <I>w</I> d’une équation linéaire, alors 
en posant <I>y</I>=<I>wz</I>, la fonction <I>z</I>′ vérifie une équation linéaire
d’ordre un de moins, ainsi si on connait une solution d’une équation
linéaire d’ordre 2, on peut la résoudre complètement.</P><P>Le calcul d’une solution particulière 
d’une équation linéaire avec second
membre se fait en faisant varier les constantes d’intégration :
on prend la forme générale de la solution de l’équation
homogène,
on remplace les constantes d’intégration par des fonctions inconnues,
on remplace dans l’équation avec second membre et on
résoud en les fonctions inconnues.
La solution générale est la somme d’une solution particulière
et de la solution générale de l’équation sans second membre.</P><P><B>Exemple </B>: <I>y</I>′−<I>ty</I>=−<I>t</I>, solution générale de l’équation
homogène <I>y</I>(<I>t</I>)=<I>Ce</I><SUP><I>t</I><SUP>2</SUP>/2</SUP>, variation de la constante
on remplace <I>y</I>(<I>t</I>)=<I>C</I>(<I>t</I>)<I>e</I><SUP><I>t</I><SUP>2</SUP>/2</SUP> dans <I>y</I>′−<I>ty</I>=−<I>t</I> et on obtient
<I>C</I>′ <I>e</I><SUP><I>t</I><SUP>2</SUP>/2</SUP>=−<I>t</I>, donc <I>C</I>′=−<I>te</I><SUP>−<I>t</I><SUP>2</SUP>/2</SUP> et <I>C</I>=<I>e</I><SUP>−<I>t</I><SUP>2</SUP>/2</SUP>+<I>K</I>,
d’où la solution générale <I>y</I>(<I>t</I>)=(<I>e</I><SUP>−<I>t</I><SUP>2</SUP>/2</SUP>+<I>K</I>)<I>e</I><SUP><I>t</I><SUP>2</SUP>/2</SUP>=1+<I>Ke</I><SUP><I>t</I><SUP>2</SUP>/2</SUP>.</P><!--TOC subsubsection Équations linéaires à coefficients constants-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc98">12.3.3</A>  Équations linéaires à coefficients constants</H4><!--SEC END --><P>
On peut chercher des solutions de l’équation sans second membre
sous la forme d’exponentielles
<I>e</I><SUP><I>rt</I></SUP>, <I>r</I> doit alors vérifier une équation polynomiale <I>P</I>(<I>r</I>)=0
appelée <B>équation caractéristique</B><A NAME="@default134"></A><A NAME="@default135"></A>,
de degré le degré de l’équation différentielle. 
Plus précisément, si on remplace <I>e</I><SUP><I>rt</I></SUP> dans
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>n</I></SUB> <I>y</I><SUP>[<I>n</I>]</SUP>+...+<I>a</I><SUB>1</SUB> <I>y</I>′+<I>a</I><SUB>0</SUB><I>y</I>=0</TD></TR>
</TABLE><P> alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>n</I></SUB> <I>r</I><SUP><I>n</I></SUP> +...+<I>a</I><SUB>1</SUB><I>r</I> +<I>a</I><SUB>0</SUB>=<I>P</I>(<I>r</I>)=0</TD></TR>
</TABLE><P>
Si <I>P</I> n’a que des racines simples <I>r</I><SUB>1</SUB>,...,<I>r</I><SUB><I>n</I></SUB> ∈ ℂ, 
l’ensemble des solutions
est alors l’espace vectoriel engendré par 
{ <I>e</I><SUP><I>r</I><SUB>1</SUB><I>t</I></SUP>, ... , <I>e</I><SUP><I>r</I><SUB><I>n</I></SUB><I>t</I></SUP> }.
En effet, on a le bon nombre
d’éléments (<I>n</I>), il suffit donc de montrer 
qu’il s’agit d’une famille libre. Cela se fait
par récurrence. Au rang <I>n</I>=1 c’est évident.
Si <I>n</I>&gt;1 et si (λ<SUB>1</SUB>,...,λ<SUB><I>n</I></SUB>) vérifient :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> λ<SUB><I>j</I></SUB> <I>e</I><SUP><I>r</I><SUB><I>j</I></SUB><I>t</I></SUP> = 0</TD></TR>
</TABLE><P>
on factorise <I>e</I><SUP><I>r</I><SUB><I>n</I></SUB> <I>t</I></SUP> et on dérive, on a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> λ<SUB><I>j</I></SUB> (<I>r</I><SUB><I>j</I></SUB>−<I>r</I><SUB><I>n</I></SUB>) <I>e</I><SUP>(<I>r</I><SUB><I>j</I></SUB>−<I>r</I><SUB><I>n</I></SUB>)<I>t</I></SUP> =0 </TD></TR>
</TABLE><P>
on est ramené à l’identité précédente au rang <I>n</I>−1
donc par récurrence, λ<SUB><I>j</I></SUB> (<I>r</I><SUB><I>j</I></SUB>−<I>r</I><SUB><I>n</I></SUB>)=0 et λ<SUB><I>j</I></SUB>=0
si <I>j</I> ≠ <I>n</I>, puis λ<SUB><I>n</I></SUB>=0 avec la relation du départ.</P><P>Si <I>P</I> a des racines multiples, on peut montrer que pour chaque
racine <I>r</I><SUB><I>k</I></SUB> de multiplicité <I>m</I>&gt;1, il faut rajouter
{ <I>te</I><SUP><I>r</I><SUB><I>k</I></SUB><I>t</I></SUP>, ..., <I>t</I><SUP><I>m</I>−1</SUP> <I>e</I><SUP><I>r</I><SUB><I>k</I></SUB><I>t</I></SUP> } pour former une base
de solutions. En effet
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>ty</I>)<SUP>[<I>j</I>]</SUP> = <I>t</I> <I>y</I><SUP>[<I>j</I>]</SUP> + <I>j</I> <I>y</I><SUP>[<I>j</I>−1]</SUP></TD></TR>
</TABLE><P>
donc si <I>y</I> est solution de l’équation alors <I>ty</I> est encore solution
si :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>na</I><SUB><I>n</I></SUB> <I>y</I><SUP>[<I>n</I>−1]</SUP> + (<I>n</I>−1)<I>a</I><SUB><I>n</I>−1</SUB> <I>y</I><SUP>[<I>n</I>−2]</SUP>+...+<I>a</I><SUB>1</SUB>=0</TD></TR>
</TABLE><P>
on reconnait l’équation différentielle linéaire à coefficients
constants dont l’équation caractéristique est <I>P</I>′.
L’indépendance linéaire de ces fonctions
se montre en faisant <I>t</I>=0 (on est ramené au cas précédent), 
puis en divisant par <I>t</I> et en faisant <I>t</I>=0, etc.</P><P>Si <I>P</I> est à coefficients réels et admet une racine non réelle
<I>z</I> alors <SPAN style="text-decoration:overline"><I>z</I></SPAN> est encore racine, on peut réécrire 
avec des fonctions trigonométriques
les combinaisons linéaires de <I>e</I><SUP><I>zt</I></SUP> et <I>e</I><SUP><SPAN style="text-decoration:overline"><I>z</I></SPAN><I>t</I></SUP> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(α + <I>i</I> β) <I>e</I><SUP>(<I>a</I>+<I>ib</I>)<I>t</I></SUP> + (α − <I>i</I> β)  <I>e</I><SUP>(<I>a</I>−<I>ib</I>)<I>t</I></SUP>
=  <I>e</I><SUP><I>at</I></SUP> ( 2 α cos(<I>bt</I>) − 2 β sin(<I>bt</I>) )</TD></TR>
</TABLE><P><B>Exemples </B>: 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<I>y</I>′′+3<I>y</I>′−4<I>y</I>=0, équation caractéristique <I>r</I><SUP>2</SUP>+3<I>r</I>−4=0,
deux racines distinctes <I>r</I>=1, <I>r</I>=−4, donc <I>y</I>(<I>t</I>)=α <I>e</I><SUP><I>t</I></SUP>+β <I>e</I><SUP>−4<I>t</I></SUP>
</LI><LI CLASS="li-itemize"><I>y</I>′′+2<I>y</I>′+<I>y</I>=0, équation caractéristique <I>r</I><SUP>2</SUP>+2<I>r</I>+1=0,
a une racine double <I>r</I>=−1, donc <I>y</I>(<I>t</I>)=α <I>e</I><SUP>−<I>t</I></SUP>+β <I>t</I> <I>e</I><SUP>−<I>t</I></SUP>
</LI><LI CLASS="li-itemize"><I>y</I>′′+2<I>y</I>′+2<I>y</I>=0, équation caractéristique <I>r</I><SUP>2</SUP>+2<I>r</I>+2=0,
deux racines conjuguées <I>r</I>=−1± <I>i</I>, donc
<I>y</I>(<I>t</I>)=<I>e</I><SUP>−<I>t</I></SUP>(α cos(<I>t</I>)+β sin(<I>t</I>))
</LI></UL><P>On peut trouver une solution particulière de l’équation avec
second membre comme dans le cas général (méthode de variation
des constantes). Si la solution générale est engendrée par
<I>y</I><SUB>1</SUB>,...,<I>y</I><SUB><I>n</I></SUB>, on pose :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> λ<SUB><I>i</I></SUB> <I>y</I><SUB><I>i</I></SUB></TD></TR>
</TABLE><P>
On pose
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> λ<SUB><I>i</I></SUB>′ <I>y</I><SUB><I>i</I></SUB>=0  ⇒  
<I>y</I>′=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> λ<SUB><I>i</I></SUB> <I>y</I><SUB><I>i</I></SUB>′</TD></TR>
</TABLE><P>
et ainsi de suite jusqu’à la dérivée d’ordre <I>n</I> de <I>y</I>, ces
<I>n</I>−1 équations et léquation différentielle donnent 
alors un système linéaire <I>n</I>,<I>n</I> en
les λ<SUB><I>i</I></SUB>′.</P><P>Pour des second membre combinaison linéaire
de termes <I>b</I>(<I>t</I>)<I>e</I><SUP><I>rt</I></SUP> avec <I>b</I> polynôme,
on peut chercher une solution particulière
combinaison linéaire de <I>a</I>(<I>t</I>)<I>e</I><SUP><I>rt</I></SUP> où <I>a</I> est de même
degré que <I>b</I> si <I>r</I> n’est pas racine de <I>P</I>, ou de degré le
degré de <I>b</I> plus la multiplicité de <I>r</I> comme racine de <I>P</I>.
On peut aussi utiliser la transformation de Laplace et son inverse.</P><!--TOC subsubsection Systèmes différentiels linéaires à coefficients
constants d’ordre 1.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc99">12.3.4</A>  Systèmes différentiels linéaires à coefficients
constants d’ordre 1.</H4><!--SEC END --><P><A NAME="@default136"></A>
Il s’agit donc de systèmes de la forme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>′=<I>Ay</I>+<I>b</I>(<I>t</I>)</TD></TR>
</TABLE><P>
où <I>y</I>(<I>t</I>)∈ ℝ<SUP><I>n</I></SUP>, <I>A</I> est une matrice carrée de taille <I>n</I> 
indépendante du temps, et <I>b</I>(<I>t</I>) ∈ ℝ<SUP><I>n</I></SUP>.</P><P>On commence par résoudre l’équation homogène <I>y</I>′=<I>Ay</I>.
Si la matrice <I>A</I> est diagonalisable, alors <I>A</I>=<I>PDP</I><SUP>−1</SUP> où
<I>D</I>=diag(<I>d</I><SUB>1</SUB>,...,<I>d</I><SUB><I>n</I></SUB>) est diagonale et <I>P</I> inversible, le système devient :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>′=<I>PDP</I><SUP>−1</SUP> <I>y</I></TD></TR>
</TABLE><P>
donc en posant <I>y</I>=<I>Pz</I>, on a (puisque <I>P</I> est indépendant du temps) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>z</I>′=<I>Dz</I>    ⇔    <I>z</I><SUB><I>k</I></SUB>′=<I>d</I><SUB><I>k</I></SUB><I>z</I><SUB><I>k</I></SUB>,  <I>k</I>=1..<I>n</I></TD></TR>
</TABLE><P>
donc <I>z</I><SUB><I>k</I></SUB>=<I>c</I><SUB><I>k</I></SUB> <I>e</I><SUP><I>d</I><SUB><I>k</I></SUB><I>t</I></SUP>, puis la solution générale
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>(<I>t</I>)=<I>P</I></TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>c</I><SUB>1</SUB> <I>e</I><SUP><I>d</I><SUB>1</SUB><I>t</I></SUP> </TD></TR>
<TR><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>c</I><SUB><I>n</I></SUB> <I>e</I><SUP><I>d</I><SUB><I>n</I></SUB><I>t</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
Le calcul avec Xcas se fait en utilisant la commande <CODE>desolve</CODE>,
par exemple<BR>
<CODE>desolve(y'=[[1,2],[2,1]]*y)</CODE><BR>
ou avec conditions initiales<BR>
<CODE>desolve([y'=[[1,2],[2,1]]*y,y(0)=[1,2]])</CODE><BR>
On peut aussi utiliser la fonction <CODE>exp</CODE>
avec comme argument <I>At</I> (on généralise ainsi 
la notation <I>e</I><SUP><I>at</I></SUP> 
de la dimension 1), multiplié par la condition initiale :<BR>
<CODE>exp([[1,2],[2,1]]*t)*[1,2]</CODE><BR>
Les calculs intermédiaires pour diagonaliser la matrice <I>A</I> sont
exécutés par les commandes <CODE>eigenvals</CODE>, <CODE>eigenvects</CODE>,
<CODE>jordan</CODE>.</P><P>On peut ensuite calculer une solution particulière par la méthode
de variation des constantes, ou encore en résolvant 
<I>z</I>′=<I>Dz</I>+<I>P</I><SUP>−1</SUP><I>b</I>(<I>t</I>) composante par composante (ou par transformation
de Laplace). Avec Xcas,
il suffit d’ajouter le second membre dans la commande <CODE>desolve</CODE><BR>
<CODE>desolve(y'=[[1,2],[2,1]]*y+[x,x+1])</CODE></P><P>Si la matrice <I>A</I> n’est pas diagonalisable (ce qui entraine
qu’elle a au moins une valeur propre de
multiplicité plus grande que 1), on peut alors
la trigonaliser, on se ramene à résoudre un système
triangulaire, ce qui revient à résoudre pour chaque
composante une équation
différentielle linéaire d’ordre 1 avec un éventuel 
second membre. </P><P><B>Remarque </B>: il y a un lien avec la section
précédente. En effet une équation d’ordre <I>n</I> peut
s’écrire comme un système différentiel d’ordre 1,
on peut calculer le polynôme caractéristique de la matrice
on retrouve alors l’équation caractéristique. Inversement,
toute matrice <I>A</I> admet un polynôme <I>P</I>
annulateur tel que <I>P</I>(<I>A</I>)=0<SUP><A NAME="text20" HREF="#note20">20</A></SUP>,
le polynôme caractéristique de <I>A</I> est un polynôme annulateur
(théorème de Cayley-Hamilton).
Les composantes des solutions du système différentiel sont des 
solutions de l’équation différentielle dont l’équation
caractéristique est <I>P</I>(<I>x</I>)=0. En effet :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">0=<I>P</I>(<I>A</I>)<I>y</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>p</I><SUB><I>k</I></SUB> <I>A</I><SUP><I>k</I></SUP> <I>y</I> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>p</I><SUB><I>k</I></SUB> <I>y</I><SUP>[<I>k</I>]</SUP></TD></TR>
</TABLE><P><B>Exemple en dimension 2.</B>
Soit <I>A</I>=(</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>a</I></TD><TD ALIGN=center NOWRAP><I>b</I> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>c</I></TD><TD ALIGN=center NOWRAP><I>d</I></TD></TR>
</TABLE><P>) . Si <I>b</I>=0 alors <I>y</I><SUB>1</SUB>′=<I>ay</I><SUB>1</SUB> on en déduit
<I>y</I><SUB>1</SUB> puis <I>y</I><SUB>2</SUB>. Supposons donc <I>b</I>≠ 0, alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>x</I>)=<I>x</I><SUP>2</SUP> − <I>x</I> (<I>a</I>+<I>d</I>) +<I>a</I> <I>d</I>−<I>b</I> <I>c</I></TD></TR>
</TABLE><P>
(on peut vérifier que <I>P</I>(<I>A</I>)=0)
donc si <I>y</I>′=<I>Ay</I> alors 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I><SUB>1</SUB>′′−(<I>a</I>+<I>d</I>)<I>y</I><SUB>1</SUB>′+<I>ad</I>−<I>bc</I>=0</TD></TR>
</TABLE><P>
et <I>y</I><SUB>2</SUB> s’en déduit avec <I>y</I><SUB>1</SUB>′−<I>ay</I><SUB>1</SUB>=<I>by</I><SUB>2</SUB> (on peut du reste
partir de cette relation pour établir l’équation d’ordre 2
vérifiée par <I>y</I><SUB>1</SUB>). On peut ainsi
résoudre tous les systèmes de dimension 2, même
si la matrice <I>A</I> n’est pas diagonalisable.</P><P><B>Exercice </B>: Résoudre de cette manière le système<BR>
<CODE>desolve([y'=[[1,2],[2,1]]*y,y(0)=[1,2]])</CODE></P><P><B>Remarque :</B> allure des courbes en dimension 2.<BR>
Si on se place dans le repère propre (en prenant les vecteurs
propres comme vecteurs de base), et si <I>A</I> a deux valeurs
propres distinctes (<I>A</I> est alors diagonalisable),
alors chaque coordonnée suit une exponentielle, dans ce repère
<I>y</I>(<I>t</I>)=(α <I>e</I><SUP><I>at</I></SUP>, β <I>e</I><SUP><I>bt</I></SUP>) avec <I>a</I> ≠ <I>b</I>. Si <I>a</I> et <I>b</I>
sont réels, l’une des exponentielles domine l’autre lorsque
<I>t</I>→ +∞ et c’est l’inverse lorsque <I>t</I>→
−∞, la courbe est donc asymptote aux directions propres.
Si <I>a</I> et <I>b</I> sont complexes conjugués de partie réelle non nulle, 
on a une spirale qui
tend vers 0 d’un coté et vers l’infini de l’autre (selon le signe
de la partie réelle). Si <I>A</I> est
symétrique, alors <I>a</I> et <I>b</I> sont réels, ce cas ne peut
pas se produire, de plus on peut choisir un repère propre
orthonormé, les courbes ressemblent à des hyperboles.
Ce sont des hyperboles si trace(<I>A</I>)=0 (la somme des valeurs
propres vaut 0 donc le produit des coordonnées dans
le repère propre vaut une constante),
ces hyperboles sont équilatères si <I>A</I> est symétrique.</P><P><B>Remarque :</B>pour un système différentiel à coefficients
non constants, il n’existe pas de méthode générale de
résolution. Il arrive que dans certains cas particuliers,
on puisse résoudre le système, par exemple si on trouve
une matrice de passage indépendante du temps ramenant
le système à un système diagonal ou triangulaire :
un exemple avec
<I>A</I>=(</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>cc</I> 1+<I>t</I></TD><TD ALIGN=center NOWRAP>−<I>t</I> </TD></TR>
<TR><TD ALIGN=center NOWRAP>−<I>t</I></TD><TD ALIGN=center NOWRAP>1+<I>t</I></TD></TR>
</TABLE><P>).
Ou si ∫<I>A</I>(<I>t</I>)  <I>dt</I> commute avec <I>A</I>, on peut prendre 
exp(∫<I>A</I>(<I>t</I>)) comme solution.</P><!--TOC subsubsection Intégrales premières.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc100">12.3.5</A>  Intégrales premières.</H4><!--SEC END --><P><A NAME="@default137"></A><A NAME="@default138"></A>
Lorsqu’on ne sait pas résoudre explicitement une équation
ou un système différentiel, il peut arriver qu’on connaisse
une ou des constantes du mouvement en cinématique, appelées
aussi intégrales premières. </P><P>C’est le cas par exemple de
l’énergie totale (mécanique plus cinétique) pour des forces
conservatives. En dimension un, la connaissance de l’intégrale 
première énergie
totale permet de ramener l’équation fondamentale de la
dynamique d’ordre 2 à une équation
du premier ordre à variables séparables :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>m</I> <I>x</I>′<SUP>2</SUP>+ <I>V</I>(<I>x</I>) = <I>C</I> </TD></TR>
</TABLE><P>
En dimension plus grande, cela peut permettre de 
connaitre la forme de la courbe intégrale et même
parfois de résoudre complètement l’équation (cas du problème
à deux corps ci-dessous).</P><P>Autre exemple, la découverte d’un facteur 
intégrant pour la forme différentielle <I>Mdx</I>+<I>Ndy</I>
donne une intégrale première pour l’équation <I>dy</I>/<I>dx</I>=<I>M</I>/<I>N</I>,
en effet ω=φ(<I>Mdx</I>+<I>Ndy</I>)=<I>dV</I>(<I>x</I>,<I>y</I>) est nul
sur une courbe intégrale, donc <I>V</I>(<I>x</I>,<I>y</I>)
est constant, les courbes intégrales sont donc 
les courbes de niveau de <I>V</I>(<I>x</I>,<I>y</I>). Une équation à variables
séparables est un cas particulier, avec <I>M</I> ne dépendant que de
<I>x</I> et <I>N</I> de <I>y</I>.</P><P>Pour un système autonome, <I>E</I> est une intégrale première si
grad(<I>E</I>).<I>f</I>=0, en effet
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>E</I>(<I>y</I>(<I>t</I>))= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>E</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ <I>y</I><SUB><I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I><SUB><I>j</I></SUB></TD></TR>
</TABLE><P><B>Problème à deux corps </B> 
Cas d’un point de ℝ<SUP>3</SUP>
soumis à une <B>force centrale</B><A NAME="@default139"></A><A NAME="@default140"></A>
comme la gravité ou la force coulombienne :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>d</I><SUP>2</SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>r</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">=−µ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>r</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I><SUP>3</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P> 
on montre
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
la conservation du moment cinétique 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>L</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">=
</TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>r</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">∧ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>d</I> </TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>r</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD></TR>
</TABLE>
(vérification immédiate en dérivant).
Ceci entraine que
le mouvement est dans un plan orthogonal à 
<I>L</I>=<I>L</I><I>k</I>
et la loi des aires (où θ est l’angle formé par 
<I>r</I> avec une direction fixe du plan) :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>r</I><SUP>2</SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I>θ</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">=<I>L</I></TD></TR>
</TABLE>
(ceci est vrai dès que la force est centrale, indépendamment
de la norme de la force)
</LI><LI CLASS="li-itemize">la conservation du vecteur excentricité défini par :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>E</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">µ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>d</I></TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>r</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ∧ 
</TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>L</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">− </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>r</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>L</I> </TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">µ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>d</I></TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>r</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ∧ 
</TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">− </TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>e</I><SUB><I>r</I></SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD></TR>
</TABLE>
En effet <I>d</I> <I>e</I><SUB><I>r</I></SUB>/<I>dt</I>=<I>d</I>θ/<I>dt</I>
<I>e</I><SUB>θ</SUB> où { <I>e</I><SUB><I>r</I></SUB>,
<I>e</I><SUB>θ</SUB>, <I>k</I> } est orthonormé direct
et <I>L</I>=<I>r</I><SUP>2</SUP> <I>d</I>θ/<I>dt</I>.
</LI></UL><P>
Si on prend l’axe des <I>x</I> porté par <I>E</I>,
en faisant le produit scalaire avec <I>r</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>rE</I> cos(θ)=</TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>r</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">.</TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>E</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">µ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>d</I></TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>r</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ∧ </TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>L</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">) . </TD><TD CLASS="dcell"><TABLE CLASS="display" STYLE="width:100%;"><TR><TD CLASS="dcell" ALIGN="center" STYLE="width:90%;"><HR CLASS="hbar"></TD><TD CLASS="dcell" ALIGN="center" STYLE="width:10%;">▸</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"><I>r</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center" COLSPAN="2"> </TD></TR>
</TABLE></TD><TD CLASS="dcell">− <I>r</I></TD></TR>
</TABLE><P>
on obtient en appliquant les propriétés du produit mixte et la
définition de <I>L</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>r</I> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>L</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">µ(1+<I>E</I> cos(θ))</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
la courbe intégrale est donc une conique d’excentricité <I>E</I>
ayant l’origine pour foyer et parcourue selon la loi des aires
(l’aire balayée par le segment origine-point mobile est
proportionnelle au temps).</P><!--TOC subsubsection Quelques autres méthodes-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc101">12.3.6</A>  Quelques autres méthodes</H4><!--SEC END --><P>
On peut encore citer : 
changement de fonction, changement de variables, 
équation homogène, équations de Bernoulli,
de Clairault, de Ricatti, développements en séries
entières..., certaines de ces méthodes sont
implémentées par les logiciels de calcul formel.</P><!--TOC subsection Comportement asymptotique des solutions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc102">12.4</A>  Comportement asymptotique des solutions</H3><!--SEC END --><P>
Les équations de la physique sont souvent des équations
autonomes sans second membre (pas de dépendance explicite en temps) 
ou avec un second membre
qui est le seul terme de l’équation dépendant du temps (il
s’agit d’un forçage extérieur). Dans le premier cas,
les solutions doivent rester bornées (par exemple en énergie), donc
ne peuvent pas tendre vers l’infini. Dans le second cas,
une question naturelle
est alors la suivante : le système atteint-il un équilibre,
peut-on décomposer la solution en deux parties : un régime
permanent et un régime transitoire ?</P><P>On a déjà fait une étude de comportement asymptotique
pour l’équation <I>y</I>′=<I>y</I>(1−<I>y</I>), la solution <I>y</I>=0 se comporte
comme un point déquilibre instable, si on en dévie même
légèrement, on s’en éloigne définitivement, alors que <I>y</I>=1 se
comporte comme un point déquilibre stable.
Nous allons généraliser cette étude, pour les équations
linéaires à coefficients constants (avec ou sans second membre,
perturbation dépendant du temps),
les équations autonomes sans second membre,
et dans le cas de systèmes différentiels linéaires à
coefficients constants.</P><!--TOC subsubsection Équations linéaires à coefficients constants 
d’ordre 1 et 2-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc103">12.4.1</A>  Équations linéaires à coefficients constants 
d’ordre 1 et 2</H4><!--SEC END --><P>
Pour les équations homogènes d’ordre 1 <I>y</I>′+<I>ay</I>=0, 
la solution générale est <I>y</I>(<I>t</I>)=<I>Ce</I><SUP>−<I>at</I></SUP>, le comportement
asymptotique lorsque <I>t</I> → +∞ dépend du signe
de <I>a</I>, si <I>a</I>&gt;0 la limite est 0 et la solution décroit
exponentiellement vite. Donc si <I>a</I>&gt;0, quelle
que soit la condition initiale, toutes les solutions de 
l’équation avec second membre <I>y</I>′+<I>ay</I>=<I>f</I>(<I>t</I>) ont
le même comportement asymptotique, celui
d’une solution particulière de l’équation :on a donc
un régime transitoire exponentiellement décroissant
et un régime permanent.</P><P>Pour les équations homogènes d’ordre 2 <I>ay</I>′′+<I>by</I>′+<I>cy</I>=0,
la solution générale est <I>y</I>(<I>t</I>)=<I>Ae</I><SUP><I>r</I><SUB>1</SUB><I>t</I></SUP>+<I>Be</I><SUP><I>r</I><SUB>2</SUB><I>t</I></SUP>
si <I>r</I><SUB>1</SUB> et <I>r</I><SUB>2</SUB> sont les deux racines simples de <I>ar</I><SUP>2</SUP>+<I>br</I>+<I>c</I>=0
ou <I>y</I>(<I>t</I>)=<I>e</I><SUP><I>r</I><SUB>1</SUB><I>t</I></SUP>(<I>A</I>+<I>Bt</I>) si l’équation caractéristique admet
une racine double. Le comportement à l’infini dépend
du signe de la partie réelle de <I>r</I><SUB>1</SUB> et <I>r</I><SUB>2</SUB>. Il faut que
les deux parties réelles soient strictement négatives pour que 
la solution tende vers 0, à vitesse exponentielle, si l’une au moins
des parties réelles est positive ou nulle, alors il n’y a pas
convergence vers 0. Plus précisément
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si Δ=<I>b</I><SUP>2</SUP>−4<I>ac</I>&lt;0, il y a deux racines complexes
conjuguées distinctes de partie réelle −<I>b</I>/(2<I>a</I>), donc la
solution décroit exponentiellement vers 0 si <I>b</I>/<I>a</I>&gt;0,
comme <I>e</I><SUP>−<I>b</I>/(2<I>a</I>)<I>t</I></SUP>, avec des oscillations périodiques
en <I>e</I><SUP><I>i</I>√<SPAN style="text-decoration:overline">−Δ</SPAN>/(2<I>a</I>)<I>t</I></SUP>, de période <I>T</I>=4π
<I>a</I>/√<SPAN style="text-decoration:overline">−Δ</SPAN> (régime oscillatoire amorti enveloppé
par <I>e</I><SUP>−<I>b</I>/(2<I>a</I>)<I>t</I></SUP>). 
Si <I>b</I>=0, la solution ne tend pas vers 0, reste de taille bornée,
elle est périodique de période <I>T</I>=4π <I>a</I>/√<SPAN style="text-decoration:overline">−Δ</SPAN>
(régime oscillatoire)
</LI><LI CLASS="li-itemize">Si Δ=<I>b</I><SUP>2</SUP>−4<I>ac</I>&gt;0, on a deux racines réelles distinctes,
qui sont toutes les deux strictement négatives si l’opposé de
leur somme et leur produit sont positifs : <I>b</I>/<I>a</I>&gt;0, <I>c</I>/<I>a</I>&gt;0
(régime amorti équivalent à la plus grande des deux
exponentielles)
</LI><LI CLASS="li-itemize">Si Δ=<I>b</I><SUP>2</SUP>−4<I>ac</I>=0, on a une racine double −<I>b</I>/(2<I>a</I>),
il y a convergence vers 0 si <I>b</I>/<I>a</I>&gt;0.
</LI><LI CLASS="li-itemize">Dans tous les autres cas, la partie réelle d’une
des racines est positive ou nulle et il n’y a pas de convergence
vers 0 de la solution générale. Si on a deux racines
imaginaires pures conjuguées, la solution est périodique,
sinon la solution tend vers l’infini pour une condition initiale
générique.
</LI></UL><P><B>Exemples </B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<I>y</I>′′+<I>y</I>=0, deux racines imaginaires pures conjuguées,
solution générale <I>a</I>sin(<I>x</I>)+<I>b</I>cos(<I>x</I>) périodique
</LI><LI CLASS="li-itemize"><I>y</I>′′+<I>y</I>′+<I>y</I>=0, deux racines complexes conjuguées de partie
réelle négative, il y a convergence exponentielle vers 0 avec
des oscillations, la
solution générale est <I>e</I><SUP>−<I>x</I>/2</SUP>(<I>a</I> cos(√<SPAN style="text-decoration:overline">3</SPAN><I>x</I>/2) + <I>b</I>
sin(√<SPAN style="text-decoration:overline">3</SPAN><I>x</I>/2)).
</LI><LI CLASS="li-itemize"><I>y</I>′′−2<I>y</I>′−3<I>y</I>=0, deux racines réelles, une positive, une
négative. La solution générale est <I>ae</I><SUP><I>x</I></SUP>+<I>be</I><SUP>−3<I>x</I></SUP>, elle
tend génériquement vers l’infini (sauf condition initiale annulant
<I>a</I>).
</LI><LI CLASS="li-itemize">...
</LI></UL><P>On peut généraliser à un ordre quelconque.
Si toutes les racines de l’équation caractéristique sont
de partie réelle négative, la solution générale
de l’équation homogène tend vers 0 à l’infini,
elle est appelée régime transitoire. Quelle que
soit la condition initiale, on tend vers la solution particulière
appelée régime permanent.</P><!--TOC subsubsection Forçage périodique-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc104">12.4.2</A>  Forçage périodique</H4><!--SEC END --><P><A NAME="@default141"></A>
Il arrive souvent qu’un système physique soit soumis à
un forçage extérieur périodique, par exemple
pour la température à échelle fine, l’alternance jour-nuit,
ou à grande échelle, l’alternance des saisons, ou
circuit RCL soumis à un courant périodique. Il est donc
utile de déterminer les caractéristiques de la solution
en régime permanent.</P><P>Exemple : ordre 1
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>′+<I>ay</I>=<I>A</I> <I>e</I><SUP><I>i</I>ω <I>t</I></SUP>,    <I>a</I>&gt;0</TD></TR>
</TABLE><P>
On sait qu’une solution particulière est donnée par
 <I>B</I> <I>e</I><SUP><I>i</I> ω <I>t</I></SUP>, on remplace et on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>B</I>(<I>i</I>ω +<I>a</I>)=<I>A</I> ⇒ <I>B</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>A</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I>+<I>i</I>ω</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
L’amplitude de la solution particulière est donc l’amplitude
du second membre divisée par le module 
|<I>a</I>+<I>i</I>ω|=√<SPAN style="text-decoration:overline"><I>a</I></SPAN><SUP><SPAN style="text-decoration:overline">2</SPAN></SUP><SPAN style="text-decoration:overline">+ω</SPAN><SUP><SPAN style="text-decoration:overline">2</SPAN></SUP>, et l’exponentielle subit
un déphasage donné par l’argument de <I>B</I> soit
−arctan(ω/<I>a</I>) ∈ ]−π/2,0[. La solution
particulière suit donc le second membre, avec un déphasage
compris entre 0 et un quart de période, selon la valeur de <I>a</I>.
Si le système a une forte inertie intrinsèque (<I>a</I> petit
pour avoir une exponentielle décroissant lentement), on s’approche
du quart de période, c’est pour cette raison que la température
près de la mer atteint son maximum en été environ 2 mois
après le solstice, alors que dans les terres, c’est plutot 3
semaines après (le maximum d’un quart de période
étant presque réalisé par la banquise qui atteint son
minimum d’extend presque 3 mois après le solstice).</P><P>À l’ordre 2, on peut faire la même étude, cette fois l’amplitude
est divisée par
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|−<I>a</I>ω<SUP>2</SUP>+<I>ib</I>ω+<I>c</I>|
=</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP> <I>b</I><SUP>2</SUP>ω<SUP>2</SUP>+(<I>a</I>ω<SUP>2</SUP>−<I>c</I>)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
=ω<SUP>2</SUP> </TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> <I>b</I><SUP>2</SUP>+(<I>a</I>ω−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>c</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ω</TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsubsection Équation autonome sans second membre-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc105">12.4.3</A>  Équation autonome sans second membre</H4><!--SEC END --><P><A NAME="@default142"></A>
Il s’agit d’une équation de la forme <I>y</I>′=<I>f</I>(<I>y</I>) où on
suppose <I>f</I> continument dérivable. Les solutions
stationnaires sont données par les racines de <I>f</I> (les
<I>r</I> telles que <I>f</I>(<I>r</I>)=0). Pour toute condition initiale entre
deux racines consécutive de <I>f</I>, la solution va rester entre
ces deux racines consécutives. Comme <I>f</I> ne s’annule pas
entre deux racines consécutives, <I>f</I> est de signe constant
donc la solution est monotone,
et tend vers une des racines lorsque <I>t</I> → ± ∞
<SUP><A NAME="text21" HREF="#note21">21</A></SUP>.
Si <I>f</I>&gt;0, on tend vers la plus grande des racines lorsque <I>t</I>
→ +∞, sinon vers la plus petite. Si la condition 
initiale est au-delà de la plus grande racine ou en-deça
de la plus petite racine, on tend soit vers l’infini, soit vers la racines.</P><P>On peut préciser
la vitesse de convergence. Si <I>f</I>(<I>y</I>)=<I>c</I>(<I>y</I>−<I>r</I>), <I>c</I>&lt;0, (<I>f</I> linéaire)
la convergence vers <I>r</I> se fait comme <I>e</I><SUP><I>ct</I></SUP> pour <I>t</I> →
+∞. Dans le cas
général, si <I>f</I>′(<I>r</I>) ≠ 0, 
ce résultat est encore valable, heuristiquement :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>y</I>)=(<I>y</I>−<I>r</I>)(<I>f</I>′(<I>r</I>)+<I>o</I>(1)) ⇒ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>f</I>(<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">=
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>f</I>′(<I>r</I>)(<I>y</I>−<I>r</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+<I>o</I>(1)</TD></TR>
</TABLE></TD><TD CLASS="dcell">
=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>f</I>′(<I>r</I>)(<I>y</I>−<I>r</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">(1 + <I>o</I>(1))</TD></TR>
</TABLE><P>
où <I>o</I>(1) est une fonction qui tend vers 0 lorsque <I>y</I> tend vers
<I>r</I>, donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dy</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>f</I>(<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dy</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>f</I>′(<I>r</I>)(<I>y</I>−<I>r</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">(1 + <I>o</I>(1)) <I>dy</I> 
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">ln|<I>y</I>−<I>r</I>|</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>f</I>′(<I>r</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (1 + <I>o</I>(1)) = </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"> <I>dt</I> = <I>t</I>+<I>K</I>  </TD></TR>
</TABLE><P>
d’où le résultat (pour une justification plus rigoureuse
il faut appliquer le théorème des fonctions implicites
pour déterminer <I>y</I> et vérifier que <I>o</I>(1) s’intègre).</P><DIV CLASS="theorem"><B>Théorème 24</B>  <EM>
On considère l’équation différentielle </EM><EM><I>y</I>′=<I>f</I>(<I>y</I>)</EM><EM> où
</EM><EM><I>f</I></EM><EM> est continument dérivable, et a des racines réelles
classées par ordre croissant </EM><EM>...,<I>r</I></EM><SUB><EM><I>k</I></EM></SUB><EM>,...</EM><EM>. Si la condition
initiale </EM><EM><I>y</I>(<I>t</I></EM><SUB><EM>0</EM></SUB><EM>)</EM><EM> est
située entre deux racines, la solution est monotone entre
ces deux racines et tend vers une des racines lorsque </EM><EM><I>t</I>→
± ∞</EM><EM>. Si </EM><EM><I>y</I>(<I>t</I></EM><SUB><EM>0</EM></SUB><EM>)</EM><EM> est situé au-delà de la dernière racine
ou en-decà de la première racine (si elles existent), 
la solution est monotone et
tend vers cette racine lorsque </EM><EM><I>t</I>→ ± ∞</EM><EM>
ou diverge (en temps fini ou infini).</EM><P><EM>Si </EM><EM><I>f</I>′(<I>r</I></EM><SUB><EM><I>k</I></EM></SUB><EM>) &lt; 0</EM><EM>, la solution </EM><EM><I>y</I>=<I>r</I></EM><SUB><EM><I>k</I></EM></SUB><EM> est appelée équilibre
stable : pour toute condition initiale situé entre </EM><EM><I>r</I></EM><SUB><EM><I>k</I>−1</EM></SUB><EM> et </EM><EM><I>r</I></EM><SUB><EM><I>k</I>+1</EM></SUB><EM>
la solution tend vers </EM><EM><I>r</I></EM><SUB><EM><I>k</I></EM></SUB><EM> lorsque </EM><EM><I>t</I> → +∞</EM><EM> 
et la convergence se fait à vitesse
exponentielle, comme </EM><EM><I>Ce</I></EM><SUP><EM><I>f</I>′(<I>r</I></EM><SUB><EM><I>k</I></EM></SUB><EM>)<I>t</I>(1+<I>o</I>(1))</EM></SUP><EM>.
</EM></P></DIV><P><B>Exemple </B>: pour l’équation logistique <I>y</I>′=<I>y</I>(1−<I>y</I>),
<I>f</I>(<I>r</I>)=<I>r</I>(1−<I>r</I>)=<I>r</I>−<I>r</I><SUP>2</SUP>, <I>f</I>′(<I>r</I>)=1−2<I>r</I>, 
il y a deux équilibres <I>r</I><SUB>0</SUB>=0 et <I>r</I><SUB>1</SUB>=1, avec <I>f</I>′(<I>r</I><SUB>0</SUB>)=1&gt;0
et <I>f</I>′(<I>r</I><SUB>1</SUB>)=−1&lt;0 donc un équilibre stable en 1, et un équilibre
instable en 0.</P><!--TOC subsubsection Systèmes linéaires-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc106">12.4.4</A>  Systèmes linéaires</H4><!--SEC END --><P><A NAME="@default143"></A>
<B>Cas linéaire</B><BR>
L’évolution du système est gouvernée par les valeurs propres
de la matrice <I>A</I> du système, exactement comme pour les équations
linéaires où ce sont les racines de l’équation
caractéristique.
La solution générale tend vers 0 si toutes les valeurs propres
ont une partie réelle strictement négative. S’il y a des paires
de valeurs propres conjuguées de partie réelle négative,
des phénomènes cycliques amortis apparaissent.
Si les valeurs propres sont négatives ou nulles mais distinctes, la solution
reste bornée (avec des composantes qui peuvent être
périodiques).
Si une des valeurs propres a une partie réelle strictement positive,
alors pour une condition initiale générique, la solution tend vers
l’infini.</P><P><B>Exemples </B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>[Y]:=desolve([y'=A*y,y(0)=[1,0,0]])</CODE> pour<BR>
<CODE>A:=[[1,2,3],[4,5,6],[7,8,9]]</CODE>, 
puis <CODE>plot(Y[0],x=0..4)</CODE> la solution tend vers l’infini,
à vitesse exponentielle comme on peut
le voir avec <CODE>plot(ln(Y[0]),x=0..4)</CODE>.
En effet 16.12... est valeur propre de <I>A</I>
(<CODE>eigenvalues(approx(A))</CODE>). On observe le même
comportement en remplaçant <I>A</I> par −<I>A</I> (ceci
diffère de la dimension 1, où en changeant le sens
du temps une solution divergente devient convergente).
On peut représenter le graphe de la courbe décrite
dans l’espace par exemple avec <CODE>plotparam(Y,x=0..2)</CODE>
</LI><LI CLASS="li-itemize"><CODE>[Y]:=desolve([y'=A*y,y(0)=[1,0]])</CODE> pour 
<CODE>A:=[[-3,1],[1,-5]]</CODE>, la courbe dans le plan est
obtenue par <CODE>plotparam(Y,x=0..10)</CODE>, en faisant
plusieurs zoom out, on voit la courbe partir de la condition
initiale le point (1,0) et aboutir (presque) en l’origine.
Les valeurs propres sont en effet −4± √<SPAN style="text-decoration:overline">2</SPAN>&lt;0.
</LI><LI CLASS="li-itemize">Même chose avec <CODE>A:=[[-1,2],[-2,-1]];</CODE>.
La courbe part toujours du point (1,0) pour
aboutir presque en l’origine, cette fois en spiralant
(car les valeurs propres sont complexes conjuguées)
</LI><LI CLASS="li-itemize">Pour <CODE>A:=[[0,2],[-2,0]];</CODE>, les valeurs
propres sont imaginaires pures, la courbe est un cercle
décrite de manière périodique.
</LI></UL><P><B>Cas autonome</B><A NAME="@default144"></A><BR>
On ne sait pas intégrer un système <I>y</I>′=<I>f</I>(<I>y</I>) sans plus
de précision sur <I>f</I> (ce n’est plus une équation à
variables séparables et il n’y a pas d’ordre dans ℝ<SUP><I>n</I></SUP>,
donc pas de monotonie des solutions à attendre).
On ne peut donc
espérer un résultat général que si la condition initiale 
est proche d’un point d’équilibre (une solution de <I>f</I>(<I>r</I>)=0).
Dans la plupart des cas, on peut conclure sur la stabilité
ou l’instabilité du point déquilibre en fonction de la partie
réelle des valeurs propres de <I>f</I>′(<I>r</I>), un peu comme en dimension 1.
Si toutes les valeurs propres ont des parties strictement négative
on peut montrer que
le système revient à l’équilibre exponentiellement vite, si
l’une des parties réelles est strictement positive,
pour une condition initiale générique, le système s’en
éloigne, et s’il y a des parties réelles nulles, on ne peut pas conclure/</P><!--TOC subsubsection Forçage près d’un point d’équilibre de système.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc107">12.4.5</A>  Forçage près d’un point d’équilibre de système.</H4><!--SEC END --><P>
Si on ajoute un terme dépendant du temps <I>y</I>′=<I>f</I>(<I>y</I>)+<I>g</I>(<I>t</I>),
on ne sait plus résoudre l’équation ni décrire
son comportement qualitatif en toute généralité. Si
la condition initiale est proche d’un équilibre stable, et si
la perturbation est “petite” (en tenant compte de l’échelle
de temps des exponentielles du système linéarisé)
on peut alors linéariser et espérer que
la solution se comporte comme la solution de
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>′=<I>f</I>′(<I>r</I><SUB><I>k</I></SUB>)(<I>y</I>−<I>r</I><SUB><I>k</I></SUB>) + <I>g</I>(<I>t</I>)</TD></TR>
</TABLE><P>
au moins pendant un certain intervalle de temps.</P><P><B>Exemple</B> : modèle couplé d’évolution température-CO2.<BR>
On modélise l’évolution de la température
<I>T</I> de la Terre par
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dT</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = <I>k</I> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">6 ln(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>CO</I>2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">280</TD></TR>
</TABLE></TD><TD CLASS="dcell">) − σ (<I>T</I><SUP>4</SUP>−<I>T</I><SUB><I>e</I></SUB><SUP>4</SUP>) </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
où <I>T</I><SUB><I>e</I></SUB>=288<I>K</I> est la température d’équiibre de la Terre et 
<I>CO</I>2(<I>t</I>) la concentration en ppm de gaz carbonique, <I>k</I> modélise
la capacité calorifique de la Terre (on peut estimer <I>k</I>=0.0025<I>K</I>/<I>yr</I>),
σ la constante de Stefan-Boltzmann (5.67e-8 S.I.).</P><P>Le taux de CO2 de l’atmosphère peut être considéré comme
un forçage extérieur (dépendant de scénarios d’émissions
de CO2) mais il dépend aussi de la température de l’océan,
on peut donc modéliser l’évolution conjointe des deux
variables par un système différentiel autonome auquel on
ajoute une composante dépendant du temps (émissions
anthropiques).</P><P>On peut raffiner ce modèle en ajoutant par exemple la glace
et ses interactions avec la température (si la température
monte, la glace fond, si la glace fond, l’albédo de la Terre diminue
ce qui va faire monter la température), ce qui amène à un
système différentiel en dimension 3
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>T</I> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>G</I> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>C</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">=
<I>F</I>(<I>T</I>,<I>G</I>,<I>C</I>) = </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>k</I> (σ(<I>T</I><SUB>0</SUB><SUP>4</SUP>−<I>T</I><SUP>4</SUP>)+6 ln(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>C</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">280</TD></TR>
</TABLE></TD><TD CLASS="dcell">) − β <I>G</I><SUP>2/3</SUP> ) </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>f</I>(<I>T</I>) </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>g</I>(<I>C</I>,<I>T</I>) + <I>a</I>(<I>t</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
où <I>f</I> est une fonction décroissante, ∂<SUB><I>T</I></SUB> <I>g</I> est positif,
et <I>a</I>(<I>t</I>) représente la perturbation anthropique (la puissance deux
tiers appliquée à la masse de glace sert à passer d’un volume
à une surface pour représenter l’effet de la variation de volume
de glace sur l’albédo).</P><!--TOC subsection Résolution numérique-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc108">12.5</A>  Résolution numérique</H3><!--SEC END --><!--TOC subsubsection Méthodes à un pas-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc109">12.5.1</A>  Méthodes à un pas</H4><!--SEC END --><P>
On considère l’équation différentielle 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>′=<I>f</I>(<I>t</I>,<I>y</I>),    <I>t</I> ∈ ℝ,    <I>y</I>(<I>t</I>) ∈ ℝ<SUP><I>d</I></SUP>, <I>y</I>(0)=<I>y</I><SUB>0</SUB></TD></TR>
</TABLE><P> 
où <I>y</I>(<I>t</I>) est la fonction inconnue cherchée
et où <I>f</I> est une fonction régulière de <I>t</I> et <I>y</I> (par exemple
<I>C</I><SUP>1</SUP> sur un domaine pour avoir existence et non recoupement des courbes
intégrales dans ce domaine). On cherche
à approcher numériquement <I>y</I>(<I>t</I>) pour <I>t</I>&gt;0. 
On présente ici des méthodes de résolution numérique à un pas,
dont le principe consiste à discrétiser l’intervalle [0,<I>t</I>] en des
subdivisions en temps de petite taille [0,<I>t</I><SUB>1</SUB>], [<I>t</I><SUB>1</SUB>,<I>t</I><SUB>2</SUB>], ..., 
[<I>t</I><SUB><I>n</I>−1</SUB>,<I>t</I><SUB><I>n</I></SUB>=<I>t</I>]. Si <I>y</I><SUB><I>i</I></SUB> est une valeur approchée de <I>y</I>(<I>t</I><SUB><I>i</I></SUB>)
la méthode à un pas se traduit par une relation de récurrence entre
<I>y</I><SUB><I>i</I></SUB> et <I>y</I><SUB><I>i</I>+1</SUB> qui reflète une méthode d’intégration
approchée de
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>(<I>t</I><SUB><I>i</I>+1</SUB>)=<I>y</I>(<I>t</I><SUB><I>i</I></SUB>)+</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB><I>i</I>+1</SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB><I>i</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>t</I>,<I>y</I>(<I>t</I>))  <I>dt</I></TD></TR>
</TABLE><P>
Par exemple, la <B>méthode d’Euler explicite</B><A NAME="@default145"></A> 
utilise la méthode des
rectangles à gauche
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I><SUB><I>i</I>+1</SUB> = <I>y</I><SUB><I>i</I></SUB> + (<I>t</I><SUB><I>i</I>+1</SUB>−<I>t</I><SUB><I>i</I></SUB>) <I>f</I>(<I>t</I><SUB><I>i</I></SUB>,<I>y</I><SUB><I>i</I></SUB>)=<I>y</I><SUB><I>i</I></SUB>+<I>hf</I>(<I>t</I><SUB><I>i</I></SUB>,<I>y</I><SUB><I>i</I></SUB>)</TD></TR>
</TABLE><P>
où <I>h</I>=<I>t</I><SUB><I>i</I>+1</SUB>−<I>t</I><SUB><I>i</I></SUB><SUP><A NAME="text22" HREF="#note22">22</A></SUP> 
alors que la méthode d’Euler implicite utilise la méthode 
des rectangles à droite
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I><SUB><I>i</I>+1</SUB> = <I>y</I><SUB><I>i</I></SUB> + (<I>t</I><SUB><I>i</I>+1</SUB>−<I>t</I><SUB><I>i</I></SUB>) <I>f</I>(<I>t</I><SUB><I>i</I>+1</SUB>,<I>y</I><SUB><I>i</I>+1</SUB>)=<I>y</I><SUB><I>i</I></SUB>+<I>hf</I>(<I>t</I><SUB><I>i</I></SUB>+<I>h</I>,<I>y</I><SUB><I>i</I>+1</SUB>)</TD></TR>
</TABLE><P>
cette dernière relation nécéssite de résoudre une équation pour
déterminer <I>y</I><SUB><I>i</I>+1</SUB> d’où son nom de méthode implicite.
Plus généralement, la méthode de résolution revient à
se donner une fonction Φ(<I>t</I>,<I>y</I>,<I>h</I>) et à poser :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I><SUB><I>i</I>+1</SUB>=<I>y</I><SUB><I>i</I></SUB>+<I>h</I>Φ(<I>t</I><SUB><I>i</I></SUB>,<I>y</I><SUB><I>i</I></SUB>,<I>h</I>)</TD></TR>
</TABLE><P>
pour la méthode d’Euler explicite, Φ(<I>t</I>,<I>y</I>,<I>h</I>)=<I>f</I>(<I>t</I>,<I>y</I>), pour
la méthode d’Euler implicite, Φ s’obtient en résolvant une 
équation (par exemple avec la méthode du point fixe, pour <I>h</I>
suffisamment petit).</P><P>Lorsqu’on compare la solution de l’équation et une valeur
approchée obtenue par une méthode à un pas, il faut distinguer 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
l’erreur locale (ou erreur de consistance)
de la méthode qui est une majoration
de |<I>y</I><SUB>1</SUB>−<I>y</I>(<I>t</I><SUB>1</SUB>)| en fonction du pas <I>h</I>=<I>t</I><SUB>1</SUB>−<I>t</I><SUB>0</SUB>, on dit 
qu’une méthode est d’ordre au moins <I>n</I> si |<I>y</I><SUB>1</SUB>−<I>y</I>(<I>t</I><SUB>1</SUB>)|≤
<I>C</I><SUB><I>n</I></SUB> <I>h</I><SUP><I>n</I>+1</SUP> (cette notion est reliée à l’ordre
de la méthode numérique d’intégration approchée utilisée).
</LI><LI CLASS="li-itemize">l’erreur globale de la méthode, qui accumule deux phénomènes,
l’erreur locale à chaque pas et l’erreur sur la condition initiale
pour les subdivisions [<I>t</I><SUB><I>i</I></SUB>,<I>t</I><SUB><I>i</I>+1</SUB>], <I>i</I>&gt;0, conséquence des erreurs
précédentes (en pratique il faudrait aussi ajouter les erreurs
d’arrondis et l’erreur
éventuelle sur la condition initiale). Pour majorer cette erreur,
il est nécessaire de supposer que la fonction <I>f</I> est lipschitzienne
par rapport à la variable <I>y</I>, l’erreur globale fera alors intervenir
un terme en <I>e</I><SUP><I>Ct</I></SUP> multiplié par l’erreur locale
(accumulation exponentielle des erreurs au cours du temps).
</LI></UL><P>
Plus précisément, on a le résultat suivant :
</P><DIV CLASS="theorem"><B>Théorème 25</B>  <EM>
Soit </EM><EM><I>y</I>(<I>t</I>)</EM><EM> la solution de </EM><EM><I>y</I>′=<I>f</I>(<I>t</I>,<I>y</I>), <I>y</I>(<I>t</I></EM><SUB><EM>0</EM></SUB><EM>)=<I>y</I></EM><SUB><EM>0</EM></SUB><EM> sur </EM><EM>[<I>t</I></EM><SUB><EM>0</EM></SUB><EM>,<I>T</I>]</EM><EM>.
On considére une méthode de résolution à un pas :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><I>y</I></EM><SUB><EM><I>i</I>+1</EM></SUB><EM>=<I>y</I></EM><SUB><EM><I>i</I></EM></SUB><EM>+<I>h</I></EM><SUB><EM><I>i</I></EM></SUB><EM>Φ(<I>t</I></EM><SUB><EM><I>i</I></EM></SUB><EM>,<I>y</I></EM><SUB><EM><I>i</I></EM></SUB><EM>,<I>h</I></EM><SUB><EM><I>i</I></EM></SUB><EM>)</EM></TD></TR>
</TABLE><EM> 
Si la méthode est d’ordre </EM><EM><I>p</I></EM><EM>, i.e. si pour </EM><EM><I>h</I>=<I>max</I>(<I>h</I></EM><SUB><EM><I>i</I></EM></SUB><EM>)</EM><EM> 
l’erreur locale satisfait 
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>|<I>y</I>(<I>t</I>) + <I>h</I>Φ(<I>t</I>,<I>y</I>(<I>t</I>),<I>h</I>)−<I>y</I>(<I>t</I>+<I>h</I>)|≤ <I>C</I></EM><SUB><EM><I>p</I></EM></SUB><EM> <I>h</I></EM><SUP><EM><I>p</I>+1</EM></SUP><EM>,    ∀ <I>t</I> ∈ [<I>t</I></EM><SUB><EM>0</EM></SUB><EM>,<I>T</I>], <I>h</I> ≤ <I>H</I> </EM></TD></TR>
</TABLE><EM> 
et si la fonction </EM><EM>Φ</EM><EM> est 
lipschitzienne en </EM><EM><I>y</I></EM><EM> de constante </EM><EM>Λ</EM><EM> pour </EM><EM><I>h</I>≤ <I>H</I></EM><EM> et </EM><EM><I>y</I></EM><EM> dans un 
voisinage de la solution </EM><EM><I>y</I>(<I>t</I>)</EM><EM>, 
i.e. si
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>|Φ(<I>t</I>,<I>z</I>,<I>h</I>)−Φ(<I>t</I>,<I>y</I>,<I>h</I>)| ≤ Λ |<I>z</I>−<I>y</I>| </EM></TD></TR>
</TABLE><EM>
alors l’erreur globale vérifie
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>|<I>y</I>(<I>t</I></EM><SUB><EM><I>n</I></EM></SUB><EM>)−<I>y</I></EM><SUB><EM><I>n</I></EM></SUB><EM>| ≤ <I>h</I></EM><SUP><EM><I>p</I></EM></SUP><EM> </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>C</I></EM><SUB><EM><I>p</I></EM></SUB></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM>Λ</EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>
(<I>e</I></EM><SUP><EM>Λ(<I>t</I></EM><SUB><EM><I>n</I></EM></SUB><EM>−<I>t</I></EM><SUB><EM>0</EM></SUB><EM>)</EM></SUP><EM>−1)</EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>
Par exemple, pour Euler explicite, Φ(<I>t</I>,<I>y</I>,<I>h</I>)=<I>f</I>(<I>t</I>,<I>y</I>), la constante
Λ est la constante de Lipschitz de <I>f</I>, et on prendra pour
<I>C</I><SUB>1</SUB> un majorant de 1/2|∂<SUB><I>y</I></SUB> <I>f</I>(<I>t</I>,<I>y</I>)| dans un voisinage de la
solution <I>y</I>(<I>t</I>) pour <I>t</I> ∈ [<I>t</I><SUB>0</SUB>,<I>t</I><SUB><I>n</I></SUB>].</P><P>Pour prouver ce résultat, il faut déterminer comment se propagent
les erreurs locales introduites à chaque pas.
Par exemple, on a une erreur locale au pas 1 <I>y</I>(<I>t</I><SUB>1</SUB>)−<I>y</I><SUB>1</SUB> donc une
condition initiale modifiée pour le pas 2 <I>y</I><SUB>1</SUB> au lieu de <I>y</I>(<I>t</I><SUB>1</SUB>).
Cette erreur se propage au pas 2 en une erreur 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>y</I><SUB>1</SUB>−<I>y</I>(<I>t</I><SUB>1</SUB>)+<I>h</I><SUB>1</SUB>(Φ(<I>t</I><SUB>1</SUB>,<I>y</I><SUB>1</SUB>,<I>h</I><SUB>1</SUB>)−Φ(<I>t</I><SUB>1</SUB>,<I>y</I>(<I>t</I><SUB>1</SUB>),<I>h</I><SUB>1</SUB>)| 
≤ (1+<I>h</I><SUB>1</SUB> Λ)|<I>y</I><SUB>1</SUB>−<I>y</I>(<I>t</I><SUB>1</SUB>)| ≤ <I>e</I><SUP><I>h</I><SUB>1</SUB> Λ</SUP> |<I>y</I><SUB>1</SUB>−<I>y</I>(<I>t</I><SUB>1</SUB>)|</TD></TR>
</TABLE><P>
De même aux pas suivants, donc au pas <I>n</I> l’erreur locale au pas 1
s’est propagée en une erreur inférieure ou égale à 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>e</I><SUP><I>h</I><SUB><I>n</I>−1</SUB> Λ</SUP>... <I>e</I><SUP><I>h</I><SUB>2</SUB> Λ</SUP> <I>e</I><SUP><I>h</I><SUB>1</SUB> Λ</SUP> |<I>y</I><SUB>1</SUB>−<I>y</I>(<I>t</I><SUB>1</SUB>)|
= <I>e</I><SUP>Λ (<I>t</I><SUB><I>n</I></SUB>−<I>t</I><SUB>0</SUB>)</SUP> |<I>y</I><SUB>1</SUB>−<I>y</I>(<I>t</I><SUB>1</SUB>)| ≤ <I>C</I><SUB><I>p</I></SUB><I>h</I><SUB>0</SUB><SUP><I>p</I>+1</SUP> <I>e</I><SUP>Λ (<I>t</I><SUB><I>n</I></SUB>−<I>t</I><SUB>0</SUB>)</SUP></TD></TR>
</TABLE><P>
Il faut ensuite sommer les erreurs locales propagées de chaque pas
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>C</I><SUB><I>p</I></SUB> <I>h</I><SUB><I>i</I></SUB><SUP><I>p</I>+1</SUP> <I>e</I><SUP>Λ (<I>t</I><SUB><I>n</I></SUB>−<I>t</I><SUB><I>i</I></SUB>)</SUP> 
≤ <I>C</I><SUB><I>p</I></SUB> <I>h</I><SUP><I>p</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>h</I><SUB><I>i</I></SUB> <I>e</I><SUP>Λ (<I>t</I><SUB><I>n</I></SUB>−<I>t</I><SUB><I>i</I></SUB>)</SUP> </TD></TR>
</TABLE><P>
Comme <I>e</I><SUP>Λ(<I>t</I><SUB><I>n</I></SUB>−<I>t</I>)</SUP> est positive décroissante sur
[<I>t</I><SUB>0</SUB>,<I>t</I><SUB><I>n</I></SUB>], on peut majorer la somme par l’intégrale
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>C</I><SUB><I>p</I></SUB> <I>h</I><SUP><I>p</I></SUP> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB><I>n</I></SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>Λ (<I>t</I><SUB><I>n</I></SUB>−<I>t</I>)</SUP>  <I>dt</I> </TD></TR>
</TABLE><P>
d’où le résultat.</P><P>On observe qu’on peut atteindre n’importe quelle précision pourvu
que <I>h</I> soit suffisamment petit. Mais en pratique, ce n’est pas le cas.
En effet, le théorème ne tient pas compte des erreurs d’arrondis.
Si le pas est trop petit, les erreurs d’arrondi ne sont plus négligeables,
elles s’ajoutent aux erreurs locales et se propagent comme les erreurs
locales avec amplification exponentielle.
Il y a donc un pas optimal, et une précision maximale que l’on peut
atteindre.</P><P>Références : Hairer, Demailly.</P><!--TOC subsubsection Méthodes de Runge-Kutta (explicites)-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc110">12.5.2</A>  Méthodes de Runge-Kutta (explicites)</H4><!--SEC END --><P><A NAME="@default146"></A>
Ce sont des méthodes explicites qui 
utilisent une méthode de Newton-Cotes pour approcher
∫<I>f</I>(<I>t</I>,<I>y</I>(<I>t</I>))  <I>dt</I> sur [<I>t</I><SUB><I>i</I></SUB>,<I>t</I><SUB><I>i</I>+1</SUB>].
Pour simplifier les notations, notons <I>t</I><SUB><I>i</I></SUB>=α, <I>t</I><SUB><I>i</I>+1</SUB>=β,
on a alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>t</I>,<I>y</I>(<I>t</I>)) 
≡ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ω<SUB><I>k</I></SUB> <I>f</I>(α<SUB><I>k</I></SUB>,<I>y</I>(α<SUB><I>k</I></SUB>)))</TD></TR>
</TABLE><P>
Pour estimer la valeur de <I>f</I>(α<SUB><I>k</I></SUB>,<I>y</I>(α<SUB><I>k</I></SUB>)), il est nécessaire
d’approcher <I>y</I>(α<SUB><I>k</I></SUB>) ce qui se fait par une méthode
de Newton-Cotes, en utilisant les estimations des
valeurs des <I>y</I>(α<SUB><I>j</I></SUB>), <I>j</I>&lt;<I>k</I>. On a 
donc des méthodes de Newton-Cotes avec un sous-ensemble croissant
de points d’interpolation, donc pour chaque valeur de <I>k</I> une
suite de coefficients ω<SUB><I>j</I>,<I>k</I></SUB>, <I>j</I>&lt;<I>k</I> correspondant à la
méthode de Newton-Cotes utilisée. Il faut aussi indiquer la valeur de
α<SUB><I>k</I></SUB> en donnant un coefficient <I>c</I><SUB><I>k</I></SUB> ∈ [0,1] tel que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">α<SUB><I>k</I></SUB> = <I>t</I><SUB><I>i</I></SUB> + <I>c</I><SUB><I>k</I></SUB> (<I>t</I><SUB><I>i</I>+1</SUB>−<I>t</I><SUB><I>i</I></SUB>) = <I>t</I><SUB><I>i</I></SUB>+<I>c</I><SUB><I>k</I></SUB> <I>h</I></TD></TR>
</TABLE><P>En pratique on stocke un tableau dont les lignes donnent <I>c</I><SUB><I>k</I></SUB> et les <I>c</I><SUB><I>k</I></SUB>ω<SUB><I>j</I>,<I>k</I></SUB>, <I>j</I>&lt;<I>k</I>,
et le calcul de <I>y</I>(α<SUB><I>k</I></SUB>) se fait ligne par ligne
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>(α<SUB><I>k</I></SUB>) ≈ <I>Y</I><SUB><I>k</I></SUB>=<I>y</I>(α<SUB>0</SUB>) +
<I>h</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>c</I><SUB><I>k</I></SUB>ω<SUB><I>j</I>,<I>k</I></SUB> <I>f</I>(α<SUB><I>j</I></SUB>,<I>y</I>(α<SUB><I>j</I></SUB>)) </TD></TR>
</TABLE><P>.
Par exemple pour la méthode d’Euler explicite, il y a deux lignes
contenant 0 et un seul coefficient :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>:</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>:</TD><TD ALIGN=center NOWRAP>1</TD></TR>
</TABLE></TD></TR>
</TABLE><P>.
Pour la méthode du point milieu, il y a trois lignes, la deuxière
ligne exprime comment on estime <I>y</I>(<I>t</I><SUB><I>i</I></SUB>+<I>h</I>/2), la troisième
<I>y</I>(<I>t</I><SUB><I>i</I>+1</SUB>)=<I>y</I>(<I>t</I><SUB><I>i</I></SUB>+<I>h</I>) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>:</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>:</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>:</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
on a donc 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>(<I>t</I><SUB><I>i</I></SUB>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>h</I>) ≈ <I>Y</I><SUB>1</SUB>=<I>y</I>(<I>t</I><SUB><I>i</I></SUB>)+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>hf</I>(<I>t</I><SUB><I>i</I></SUB>,<I>y</I>(<I>t</I><SUB><I>i</I></SUB>))</TD></TR>
</TABLE><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>(<I>t</I><SUB><I>i</I></SUB>+<I>h</I>) ≈ <I>Y</I><SUB>2</SUB>=<I>y</I>(<I>t</I><SUB><I>i</I></SUB>)+<I>hf</I>(<I>t</I><SUB><I>i</I></SUB>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">,<I>Y</I><SUB>1</SUB>)=<I>y</I>(<I>t</I><SUB><I>i</I></SUB>)+<I>hf</I>(<I>t</I><SUB><I>i</I></SUB>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">,<I>y</I>(<I>t</I><SUB><I>i</I></SUB>)+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>f</I>(<I>t</I><SUB><I>i</I></SUB>,<I>y</I>(<I>t</I><SUB><I>i</I></SUB>)))</TD></TR>
</TABLE><P>La suite des temps α<SUB><I>k</I></SUB> est croissante, mais pas forcément
de manière stricte, on peut avoir α<SUB><I>k</I></SUB>=α<SUB><I>k</I>+1</SUB>, la valeur
de <I>y</I>(α<SUB><I>k</I></SUB>) n’étant pas estimée par la même méthode de Newton-Cotes
que <I>y</I>(α<SUB><I>k</I>+1</SUB>).
La valeur des coefficients est ensuite déterminée pour obtenir un ordre
le plus grand possible pour l’erreur locale (ce qui peut nécessiter
la résolution de systèmes avec pas mal d’inconnues).</P><P>Ainsi, la méthode RK4 utilise le tableau suivant
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>:</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>:</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>:</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>:</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>:</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Ce qui se traduit par
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>Y</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>(<I>t</I><SUB>0</SUB>)+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>f</I>(<I>t</I><SUB>0</SUB>,<I>y</I><SUB>0</SUB>) </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><I>Y</I><SUB>2</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>(<I>t</I><SUB>0</SUB>)+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>f</I>(<I>t</I><SUB>0</SUB>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">,<I>Y</I><SUB>1</SUB>) </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><I>Y</I><SUB>3</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>y</I>(<I>t</I><SUB>0</SUB>)+<I>h</I> <I>f</I>(<I>t</I><SUB>0</SUB>+<I>h</I>,<I>Y</I><SUB>2</SUB>) </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>Y</I><SUB>4</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>(<I>t</I><SUB>0</SUB>) + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><I>f</I>(<I>t</I><SUB>0</SUB>,<I>y</I>(<I>t</I><SUB>0</SUB>))+
2<I>f</I>(<I>t</I><SUB>0</SUB>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">,<I>Y</I><SUB>1</SUB>)+2<I>f</I>(<I>t</I><SUB>0</SUB>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">,<I>Y</I><SUB>2</SUB>)+<I>f</I>(<I>t</I><SUB>0</SUB>+<I>h</I>,<I>Y</I><SUB>3</SUB>)</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Les méthodes de Newton-Cotes utilisées sont les rectangles à
gauche puis à droite pour estimer le point milieu, et la méthode
de Simpson (en prenant la moyenne des deux estimations pour le
point milieu).
On peut montrer qu’elle est d’ordre 4 (erreur locale en <I>O</I>(<I>h</I><SUP>5</SUP>))</P><P>Les méthodes de résolution numériques implémentées dans Xcas sont
des méthodes explicites de Runge-Kutta emboitées avec pas adaptatif, 
(le pas adaptatif est calculé en estimant l’erreur 
avec 2 méthodes emboitées RK4 et
Prince-Dormand, cf. Hairer).</P><!--TOC section Introduction au calcul variationnel-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc111">13</A>  Introduction au calcul variationnel</H2><!--SEC END --><P> <A NAME="sec:lagrangien"></A>
La recherche de minimas/maximas est une des application 
du calcul différentiel : en dimension 1, la dérivée s’annule
lorsque la fonction est maximale ou minimale, en dimension plus
grande c’est le gradient qui s’annule. Le calcul variationnel
est une généralisation du principe précédent lorsque
l’inconnue n’est pas l’endroit <I>x</I> où l’extrêmum est atteint
(un réel ou un point), mais une fonction. Par exemple, si on recherche
le plus court chemin entre 2 points de l’espace, ou entre 2 points
situé sur une sphère ou une surface : dans ce cas l’inconnue
est le chemin, que l’on peut représenter par une courbe 
paramétrée. On obtient alors une équation différentielle
qui permet de déterminer le chemin, de même que l’équation
<I>f</I>′(<I>x</I>)=0 ou ∇ <I>f</I>=0 permettait de trouver la position
d’un extrêmum. Réciproquement, certaines équations
différentielles de la physique peuvent se mettre sous la forme minimiser une
fonction dépendant d’un chemin, le chemin étant la courbe
intégrale de l’équation différentielle. C’est le cas par
exemple des équations de la dynamique en mécanique
classique aussi bien qu’en relativité. Un des intérêts d’une
formulation variationnelle de ces équations, c’est que ce type
de formulation est plus intrinsèque (plus géométrique) 
elle ne dépend pas des coordonnées.</P><P>Le problème est donc le suivant : on se donne un 
<B>lagrangien</B><A NAME="@default147"></A>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>L</I>(<I>x</I>,ẋ,<I>t</I>): ℝ<SUP><I>n</I></SUP> × ℝ<SUP><I>n</I></SUP> × ℝ → ℝ</TD></TR>
</TABLE><P> 
où :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<I>L</I> est une fonction dépendant de la position <I>x</I> ∈ ℝ<SUP><I>n</I></SUP>,
de la vitesse ẋ ∈ ℝ<SUP><I>n</I></SUP> et du temps <I>t</I>,
deux fois continument dérivable,
</LI><LI CLASS="li-itemize"><I>A</I> et <I>B</I> ∈ ℝ<SUP><I>n</I></SUP> sont deux points
</LI></UL><P>
et on cherche parmi les courbes paramétrées
deux fois continument dérivables
γ(<I>t</I>) d’origine γ(<I>t</I><SUB>0</SUB>)=<I>A</I> 
et extrémité γ(<I>t</I><SUB>1</SUB>)=<I>B</I> le(s) chemin(s) réalisant le
minimum (s’il existe) de l’<B>action</B><A NAME="@default148"></A> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>S</I>=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>L</I>(γ(<I>t</I>),</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I>γ(<I>t</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">,<I>t</I>) <I>dt</I> </TD></TR>
</TABLE><P>Exemples : 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
longueur minimale dans le plan, <I>n</I>=2 et 
<I>L</I>(<I>x</I>,ẋ,<I>t</I>)=|| ẋ ||=√<SPAN style="text-decoration:overline">x_1</SPAN><SUP><SPAN style="text-decoration:overline">2</SPAN></SUP><SPAN style="text-decoration:overline">+x_2</SPAN><SUP><SPAN style="text-decoration:overline">2</SPAN></SUP>.
</LI><LI CLASS="li-itemize">lagrangien de la mécanique classique (<I>n</I>=1,2 ou 3, dans un
référentiel galiléen) :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>L</I>(<I>x</I>,ẋ,<I>t</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>m</I>ẋ<SUP>2</SUP>−<I>V</I>(<I>x</I>,<I>t</I>)</TD></TR>
</TABLE>
</LI><LI CLASS="li-itemize">lagrangien en relativité restreinte :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>L</I>(<I>x</I>,ẋ,<I>t</I>)=−<I>mc</I><SUP>2</SUP></TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">1−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">ẋ<SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>c</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">−<I>V</I>(<I>x</I>,<I>t</I>)</TD></TR>
</TABLE>
</LI></UL><DIV CLASS="theorem"><B>Proposition 26</B>  <EM>
Équations d’</EM><EM><B>Euler-Lagrange</B></EM><A NAME="@default149"></A><EM> : 
ce sont des conditions nécessaires
pour que </EM><EM>γ(<I>t</I>)</EM><EM> soit un extrêmum, si
</EM><EM><I>x</I>=(<I>x</I></EM><SUB><EM>1</EM></SUB><EM>,...,<I>x</I></EM><SUB><EM><I>n</I></EM></SUB><EM>)</EM><EM> est un système de coordonnées (pas
forcément dans un repère orthonormé),
elles sont données par :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>d</I></EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>dt</I></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM>∂ <I>L</I></EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM>∂ x_i</EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> = 
</EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM>∂ <I>L</I></EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM>∂ <I>x</I></EM><SUB><EM><I>i</I></EM></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>    </EM><EM>pour </EM><EM> <I>i</I>=1,...,<I>n</I></EM></TD></TR>
</TABLE><EM>
(On vérifie que cette équation a la bonne homogénéité.)
</EM></DIV><P>Sur les exemples, on obtient
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
pour la longueur minimale dans le plan, on a 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ <I>x</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">=0,   
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ x_1</TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">x_1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>x_1<SUP>2</SUP>+x_2<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE>
qui est la première composante du vecteur tangent,
de même pour la deuxième composante, 
donc le long de la courbe le vecteur tangent a sa dérivée
nulle, donc est constant. Une
courbe réalisant un extrêmum de la distance entre deux points
dans le plan est donc portée par une droite, c’est le segment
reliant ces deux points.
</LI><LI CLASS="li-itemize">Pour le deuxième exemple
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ <I>x</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">=−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>V</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ <I>x</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">,
   </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ <I>x</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">=<I>m</I>x_1
</TD></TR>
</TABLE>
c’est-à-dire la composante sur <I>x</I><SUB>1</SUB> de la force et
de la quantité de mouvement, donc l’équation d’Euler-Lagrange
donne l’équation fondamentale de la dynamique.
</LI><LI CLASS="li-itemize">Pour le troisième exemple, on a
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ <I>x</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">=−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>V</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ <I>x</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">,
   </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ <I>x</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">=<I>m</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">x_1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">1− 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">ẋ<SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>c</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE>
c’est-à-dire la composante sur <I>x</I> de la force et
de la quantité de mouvement en relativité restreinte,
on retrouve donc l’équation fondamentale de la dynamique.
</LI></UL><P><B>Démonstration (idée) :</B><BR>
On fait varier le chemin en ajoutant à 
γ(<I>t</I>)=(<I>x</I><SUB>1</SUB>(<I>t</I>),...,<I>x</I><SUB><I>n</I></SUB>(<I>t</I>))
un vecteur <I>u</I> Δ(<I>t</I>) avec Δ(<I>t</I><SUB>0</SUB>)=Δ(<I>t</I><SUB>1</SUB>)=0, on obtient
une action <I>S</I>(<I>u</I>), on calcule la dérivée en <I>u</I>=0
de <I>S</I>(<I>u</I>), elle doit s’annuler pour avoir un extrêmum, et
ce quel que soit la valeur de la fonction Δ 
telle que Δ(<I>t</I><SUB>0</SUB>)=Δ(<I>t</I><SUB>1</SUB>)=0. Prenons pour commencer Δ
uniquement sur la première composante
Δ(<I>t</I>)=(δ(<I>t</I>),0,...,0), on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>S</I>(<I>u</I>) = </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">
<I>L</I>(<I>x</I><SUB>1</SUB>(<I>t</I>)+<I>u</I>δ(<I>t</I>),<I>x</I><SUB>2</SUB>(<I>t</I>),...,<I>x</I><SUB><I>n</I></SUB>,x_1+<I>u</I>δ,x_2,...,<I>x</I><SUB><I>n</I></SUB>′,<I>t</I>)   <I>dt</I></TD></TR>
</TABLE><P>
on dérive par rapport à <I>u</I> sous le signe intégrale (on peut
intervertir dérivée et intégrale car γ, δ, <I>L</I> sont
deux fois continument dérivables). Comme <I>u</I> intervient dans deux
composantes de <I>L</I>, il y a deux dérivées partielles qui
interviennent :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>S</I>′(0) =</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ <I>x</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> δ + 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ x_1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> δ </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"> <I>dt</I></TD></TR>
</TABLE><P>
On intègre par parties le deuxième terme (δ=<I>d</I>
δ/<I>dt</I>), le terme tout intégré est nul 
car δ(<I>t</I><SUB>0</SUB>)=δ(<I>t</I><SUB>1</SUB>)=0, d’où :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">0=<I>S</I>′(0)=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ <I>x</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> δ 
−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ x_1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> δ </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
<I>dt</I>
=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>t</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ <I>x</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ x_1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">δ 
<I>dt</I></TD></TR>
</TABLE><P>
Comme le résultat doit être nul
pour toute valeur de δ, on en déduit la première
équation d’Euler-Lagrange (en prenant
δ=(<I>t</I>−<I>t</I><SUB>0</SUB>)(<I>t</I><SUB>1</SUB>−<I>t</I>) (∂ <I>L</I>/∂ <I>x</I><SUB>1</SUB> 
−<I>d</I>/<I>dt</I> ∂ <I>L</I>/∂ x_1) si la régularité
est suffisante, ou sinon en raisonnant par l’absurde :
si l’équation n’est pas vérifiée
en un point, alors on prend δ non nulle seulement
au voisinage de ce point et nulle ailleurs, et on choisit δ
de même signe que l’autre facteur, l’intégrale est alors
strictement positive, absurde).</P><P>Un des intérêts de cette écriture des équations de la
mécanique, c’est de pouvoir effectuer un changement de coordonnées
plus facilement, car la propriété de rendre l’action extrêmale pour un
chemin est indépendant du choix des coordonnées.
Par exemple, si <I>n</I>=2, on peut utiliser les coordonnées polaires 
(<I>r</I>,θ), on a alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>L</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>m</I>(ṙ<SUP>2</SUP>+<I>r</I><SUP>2</SUP> θ<SUP>2</SUP>) − <I>V</I>(<I>r</I>,θ)</TD></TR>
</TABLE><P>
Si le potentiel est à symétrie sphérique, alors <I>L</I> ne
dépend pas de θ (seulement de θ) donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ θ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> = 0</TD></TR>
</TABLE><P>
on a donc une intégrale première, qui est le moment cinétique
<I>mr</I><SUP>2</SUP> θ.</P><P>Plus généralement, si <I>L</I> ne dépend pas explicitement du temps,
alors le <B>hamiltonien</B><A NAME="@default150"></A> défini par :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>H</I> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ẋ<SUB><I>i</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ ẋ<SUB><I>i</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> − <I>L</I></TD></TR>
</TABLE><P>
est une intégrale première, en effet
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dH</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>i</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂
ẋ<SUB><I>i</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ẋ<SUB><I>i</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂
<I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ ẋ<SUB><I>i</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">
− </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ <I>x</I><SUB><I>i</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dx</I><SUB><I>i</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">
+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ ẋ<SUB><I>i</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I>ẋ<SUB><I>i</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>i</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂
ẋ<SUB><I>i</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ẋ<SUB><I>i</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂  <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ <I>x</I><SUB><I>i</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">
− </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ <I>x</I><SUB><I>i</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ẋ<SUB><I>i</I></SUB>
+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ ẋ<SUB><I>i</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>i</I></SUB>
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>0</TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>Exercice</B> : calculer <I>H</I> pour le lagrangien de la mécanique
classique et de la relativité restreinte.</P><P><B>Exemple </B>: On cherche la forme d’un toboggan qui permette
de se rendre le plus rapidement possible d’un point <I>A</I> (origine
du repère) à un point <I>B</I> situé à une altitude plus basse 
sous l’action de la gravité (en négligeant les frottements). 
Si cette courbe est un graphe de fonction <I>y</I>(<I>x</I>) alors la vitesse
est donnée par 
<I>v</I>=(<I>dx</I>/<I>dt</I>,<I>dy</I>/<I>dt</I>)=<I>dx</I>/<I>dt</I>(1,<I>y</I>′).
D’autre part <I>v</I>=√<SPAN style="text-decoration:overline">−2<I>gy</I></SPAN>. Donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+<I>y</I>′<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>−2<I>gy</I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
on en déduit :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>dt</I> = <I>dx</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+<I>y</I>′<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>−2<I>gy</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
donc le temps à minimiser est
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>x</I><SUB><I>B</I></SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I><SUB><I>A</I></SUB>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>dt</I> = </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>x</I><SUB><I>B</I></SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+<I>y</I>′<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>−2<I>gy</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>dx</I></TD></TR>
</TABLE><P>
Pour se ramener au problème précédent, 
on change de notations, <I>x</I> devient un “temps virtuel”
τ et <I>y</I>′=ẏ est la dérivée de <I>y</I> par
rapport à ce temps virtuel, il faut minimiser
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">τ<SUB><I>B</I></SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>L</I>(τ,<I>y</I>,ẏ) <I>d</I>τ,    
<I>L</I>(τ,<I>y</I>,ẏ)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+ẏ<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>−2<I>gy</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
le lagrangien ne dépend pas explicitement de τ, donc le
hamiltonient correspondant
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>H</I>=ẏ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∂ <I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ẏ</TD></TR>
</TABLE></TD><TD CLASS="dcell">  − <I>L</I> </TD></TR>
</TABLE><P>
est conservé, donc indépendant de τ donc en revenant
à la notation <I>x</I> pour l’abscisse on a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>H</I></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>′  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> ∂</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+<I>y</I>′<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>−2<I>gy</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">∂ <I>y</I>′</TD></TR>
</TABLE></TD><TD CLASS="dcell">− 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+<I>y</I>′<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>−2<I>gy</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>−2<I>gy</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><I>y</I>′ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+<I>y</I>′<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> −
</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+<I>y</I>′<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>−2<I>gy</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+<I>y</I>′<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Après simplification, on obtient l’équation différentielle :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">−2<I>gH</I><SUP>2</SUP><I>y</I> (1+<I>y</I>′<SUP>2</SUP>) = 1</TD></TR>
</TABLE><P>
soit 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>′<SUP>2</SUP>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−2<I>c</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">−1,    <I>c</I>=<I>gH</I><SUP>2</SUP>   </TD></TR>
</TABLE><P>
Comme <I>y</I>≤ 0 et <I>y</I>′(0)=0, on en déduit que <I>y</I>′ est négatif :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">−<I>dy</I> = </TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−2<I>c</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">−1</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dx</I></TD></TR>
</TABLE><P>
Il s’agit d’une équation à variables séparables. En posant
<I>y</I>=−<I>c</I>+<I>cY</I>, <I>x</I>=<I>cX</I>
on obtient une équation indépendante de <I>c</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">−<I>dY</I>=</TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1−<I>Y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">−1</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dX</I>=</TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1+<I>Y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1−<I>Y</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>dX</I></TD></TR>
</TABLE><P>
Donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">−</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1−<I>Y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+<I>Y</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>dY</I> = </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><I>dX</I> </TD></TR>
</TABLE><P>
puis (pour trouver la constante d’intégration, on observe que
<I>Y</I>=1 pour <I>X</I>=0) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">−</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>Y</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">+arccos(<I>Y</I>)=<I>X</I></TD></TR>
</TABLE><P>
Si on pose <I>Y</I>=cos(<I>t</I>), <I>t</I> ∈ [0,π], on a <I>X</I>=<I>t</I> − sin(<I>t</I>),
la solution est donc une cycloïde<A NAME="@default151"></A> renversée.
On peut aussi le vérifier directement
en remplaçant dans l’équation <I>x</I> et <I>y</I>
par les équations paramétriques de la cycloïde renversée
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>=<I>c</I>(<I>t</I>−sin(<I>t</I>)),  <I>y</I>=−<I>c</I>+<I>c</I>cos(<I>t</I>)),  <I>t</I> ∈ [0,π]</TD></TR>
</TABLE><P>
on trouve pour le membre de droite :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−2<I>c</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">−1</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dx</I></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>c</I> </TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1−cos(<I>t</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">−1</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
(1−cos(<I>t</I>))  <I>dt</I></TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>c</I> </TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1+cos(<I>t</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1−cos(<I>t</I>)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">   (1−cos(<I>t</I>))  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>c</I> </TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−cos(<I>t</I>)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I></TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>c</I> sin(<I>t</I>)  <I>dt</I> </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>−<I>dy</I></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC section Corps finis.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc112">14</A>  Corps finis.</H2><!--SEC END --><P> <A NAME="sec:gf"></A><A NAME="@default152"></A><A NAME="@default153"></A>
</P><!--TOC subsection Rappels-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc113">14.1</A>  Rappels</H3><!--SEC END --><P>
Soit <I>K</I> un corps fini. Le plus petit entier <I>p</I> tel que
<I>p</I>.1=0 est la caractéristique du corps, c’est un nombre premier
(car <I>xy</I>=0 ⇒ <I>x</I>=0 ou <I>y</I>=0), et <I>K</I> est un ℤ/<I>p</I>ℤ
espace vectoriel de dimension finie <I>n</I>, donc son cardinal est <I>p</I><SUP><I>n</I></SUP>.</P><P>Les inversibles pour la multiplication forment un groupe de cardinal
<I>p</I><SUP><I>n</I></SUP>−1 et ce groupe est cyclique (sinon on construit un élément
d’ordre <I>d</I> le PPCM des ordres des éléments de <I>K</I><SUP>*</SUP>, cet ordre
est donc un diviseur strict de <I>p</I><SUP><I>n</I></SUP>−1, mais c’est impossible car
le polynôme <I>x</I><SUP><I>d</I></SUP>−<I>x</I> a alors <I>p</I><SUP><I>n</I></SUP>−1&gt;<I>d</I> racines).</P><P>L’application φ:<I>x</I> → <I>x</I><SUP><I>p</I></SUP> est une application linéaire
et le noyau de φ-id est ℤ/<I>p</I>ℤ. Si <I>P</I> est un polynôme 
irréductible à coefficients dans ℤ/<I>p</I>ℤ de degré divisant <I>n</I>, alors
<I>P</I> se décompose en produit de facteurs de degré 1 et on passe
d’une racine de <I>P</I> dans <I>K</I> à une autre en appliquant φ
(en effet <I>P</I> divise <I>x</I><SUP><I>p</I><SUP><I>n</I></SUP></SUP>−<I>x</I> modulo <I>p</I> et
<I>x</I><SUP><I>p</I><SUP><I>n</I></SUP></SUP>−<I>x</I>=∏<SUB>α ∈ <I>K</I></SUB> (<I>x</I>−α)).
Exemple : faire <CODE>GF(3,5)</CODE> pour créer le corps <I>K</I>
de cardinal 3<SUP>5</SUP>, puis 
<CODE>P:=randpoly(5) % 3; factor(P)</CODE>
et exécuter à niveau la commande jusqu’à ce que <I>P</I> soit
irréductible, puis tester <CODE>factor(P,g)</CODE>.
Evidemment, ce résultat n’est plus vrai si <I>P</I> a des coefficients
dans <I>K</I> au lieu de ℤ/<I>p</I>ℤ (essayer avec <CODE>P:=randpoly(5,g)</CODE>).</P><!--TOC subsection Représentation des corps non premiers.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc114">14.2</A>  Représentation des corps non premiers.</H3><!--SEC END --><!--TOC subsubsection Cas général.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc115">14.2.1</A>  Cas général.</H4><!--SEC END --><P>
Pour représenter <I>K</I>, on utilise généralement la
représentation dite additive, c’est-à-dire que <I>K</I>
est isomorphe à ℤ/<I>p</I>ℤ[<I>X</I>]/<I>P</I>(<I>X</I>) avec <I>P</I> un polynôme
irréductible de ℤ/<I>p</I>ℤ[<I>X</I>] de degré <I>n</I>. Si la classe de <I>X</I>
est d’ordre <I>p</I><SUP><I>n</I></SUP>−1 dans <I>K</I><SUP>*</SUP> on dit que <I>P</I> est <B>primitif</B><A NAME="@default154"></A>.
Dans Xcas, c’est cette représentation qui est utilisée,
l’instruction <CODE>GF(p,n)</CODE> génère aléatoirement
un polynôme irréductible de degré <I>n</I> sur ℤ/<I>p</I>ℤ,
puis cherche un élément cyclique, calcule son polynôme
minimal (qui est donc primitif), et affiche le nom d’un
générateur (par défaut <CODE>g</CODE>), 
il suffit alors d’écrire n’importe quelle
expression symbolique polynomiale en ce générateur
pour créer un élément de <I>K</I>. En interne, Xcas stocke
les éléments de <I>K</I> comme des polynômes-listes
à coefficients dans ℤ/<I>p</I>ℤ, et les affiche comme polynôme
symbolique en fonction du générateur. On peut aussi
utiliser un entier entre 0 et <I>p</I><SUP><I>n</I></SUP>−1 dont l’écriture en base
<I>p</I> représente les coefficients du polynôme.</P><P>Pour générer un polynôme <B>irréductible</B><A NAME="@default155"></A>, on utilise
un génerateur aléatoire d’entiers dans [0,<I>p</I>[,
on crée un polynôme unitaire de degré <I>n</I>, et
on teste son irréductibilité en calculant le PGCD
de <I>P</I> avec les <I>x</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>−<I>x</I> pour <I>k</I> de 1 jusque <I>n</I>/2.
En pratique, on calcule les <CODE>powmod(x,p^k,p,P)</CODE>
(en prenant la puissance modulaire <I>p</I>-ième
du précédent), on retire <I>x</I> et on calcule le pgcd avec <I>P</I>,
si on trouve un résultat différent de 1, on passe au polynôme
suivant (généré aléatoirement).
On peut calculer la probabilité de réussir en dénombrant
les polynômes irréductibles de degré <I>n</I> à l’aide
de la formule <I>x</I><SUP><I>p</I><SUP><I>n</I></SUP></SUP>−<I>x</I>=∏<SUB><I>P</I>  irréductible unitaire / deg(<I>P</I>) divise  <I>n</I></SUB> <I>P</I>.</P><P>Trouver un élément <B>cyclique</B><A NAME="@default156"></A> se fait aussi au hasard
(<CODE>rand(g)</CODE> en Xcas si <CODE>g</CODE> est le générateur
d’un corps fini), la
probabilité se calcule à l’aide de l’indicatrice d’Euler de
<I>p</I><SUP><I>n</I></SUP>−1. Déterminer le polynome minimal d’un élément
est alors un problème d’algèbre linéaire, il se résoud
en calculant le noyau de la matrice dont les colonnes sont
les coefficients des puissances de l’élément (instruction
<CODE>pmin</CODE> en Xcas).</P><P>La représentation additive est pratique pour additionner
ou soustraire des éléments de <I>K</I>, multiplier
nécessite de faire une division euclidienne par <I>P</I> et prendre
le reste, inverser nécessite de faire une identité de Bézout
avec <I>P</I>. Il existe une représentation alternative, dite
multiplicative, on représente alors un élément <I>g</I><SUP><I>k</I></SUP> de <I>K</I><SUP>*</SUP>
par la puissance <I>k</I> ∈ [0,<I>p</I><SUP>−</SUP>2] du générateur <I>g</I>, et on
représente 0<SUB><I>K</I></SUB> par -1 ou par <I>p</I><SUP><I>n</I></SUP>−1. Mais l’addition
est alors difficile sauf si on dispose d’une table passant
de la représentation additive à la représentation
multiplicative.</P><!--TOC subsubsection Corps de petit cardinal, cas de la caractéristique 2-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc116">14.2.2</A>  Corps de petit cardinal, cas de la caractéristique 2</H4><!--SEC END --><P>
Si le cardinal du corps n’est pas trop grand (par exemple
moins que quelques milliers), il est intéressant de construire
une table de passage entre représentation additive et
multiplicative, c’est-à-dire une permutation de [0,<I>p</I><SUP><I>n</I></SUP>−1]
si on utilise des entiers pour la représentation additive.
On calcule donc une fois pour toutes la représentation additive
de toutes les puissances de <I>g</I> ce qui fournit la table de passage
multiplicatif vers additif, puis la permutation inverse, on peut alors
effectuer toutes les opérations sur le corps <I>K</I> très
rapidement : la multiplication devient un test si l’un
des éléments vaut <I>p</I><SUP><I>n</I></SUP>−1 suivi d’une addition modulo <I>p</I><SUP><I>n</I></SUP>−1 si
ce n’est pas le cas, l’addition une écriture en base <I>p</I> et <I>n</I>
additions dans ℤ/<I>p</I>ℤ.</P><P>En caractéristique 2, l’addition est encore plus simple, il s’agit
d’un ou exclusif bit à bit (sur un type entier court 8 ou 16 ou 32 bits). 
De plus le calcul de la permutation
de passage est très rapide, pour trouver <I>g</I><SUP><I>k</I>+1</SUP> en fonction
de <I>g</I><SUP><I>k</I></SUP> il faut multiplier par <I>g</I> ce qui est un décalage
de bit vers la gauche, tester si l’entier est supérieur à 2<SUP><I>n</I></SUP>
et si oui faire un ou exclusif avec l’entier représentant le
polynôme minimal de <I>g</I>. Si le cardinal du corps est assez petit
(par exemple 2<SUP>8</SUP>, ou disons moins que 2<SUP>13</SUP>),
la permutation et son inverse tiennent dans le cache du
microprocesseur et les opérations sur le corps <I>K</I> se font
en une dizaine de cycles du microprocesseur.</P><!--TOC subsection Exercices-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc117">14.3</A>  Exercices</H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Trouver un polynôme irréductible <I>P</I> de degré 5 sur ℤ/7ℤ.
En déduire une représentation de <CODE>GF(7,5)</CODE>. Factoriser 
le polynôme <I>P</I> sur votre représentation de <CODE>GF(7,5)</CODE> (on pourra utiliser
l’application <I>x</I> → <I>x</I><SUP>7</SUP>).
</LI><LI CLASS="li-enumerate">Déterminer le polynôme minimal de quelques éléments
de <CODE>GF(7,5)</CODE> en utilisant votre représentation ou celle de Xcas.
Même question mais en degré 4 avec la représentation de Xcas.
</LI><LI CLASS="li-enumerate">Factoriser avec Xcas <I>x</I><SUP>16</SUP>−<I>x</I> modulo 2 (on pourra utiliser
<CODE>factors()</CODE>, <CODE>% 2</CODE> et <CODE>% 0</CODE>). 
En déduire les polynômes irréductibles de degré 4 sur
ℤ/2ℤ, déterminez les polynômes irréductibles
primitif de degré 4, pour l’un d’entre eux construire une table entre représentation
multiplicative et additive de <CODE>GF(2,4)</CODE>.
</LI><LI CLASS="li-enumerate">Écrire une fonction permettant de déterminer si un
polynôme <I>A</I> est irréductible modulo <I>p</I>, en utilisant le
PGCD avec les <I>x</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>−<I>x</I> modulo <I>p</I>. Quelle est sa complexité
si <I>A</I> est irréductible de degré <I>d</I> ?
</LI></OL><!--TOC subsection Codes linéaires et polynomiaux.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc118">14.4</A>  Codes linéaires et polynomiaux.</H3><!--SEC END --><P>
<A NAME="@default157"></A> <A NAME="@default158"></A>
<A NAME="@default159"></A>
Les corps finis premiers servent dans tous les algorithmes modulaires,
on en a vu par exemple l’intérêt pour le PGCD, la factorisation...</P><P>Les corps finis premiers et non premiers servent aussi dans le
domaine de la cryptographie et des codes correcteurs d’erreurs, 
on présente ici ce dernier point.</P><P>Références : Demazure, G. Zémor, wikipedia (pour les codes de
Hamming binaires).</P><P>On appellera symbole d’information l’unité de base transmise, qu’on
supposera appartenir à un corps fini <I>K</I>, par
exemple pour un bit un élément de <I>K</I>=ℤ/2ℤ, ou pour un octet 
un élément du corps à 256 éléments <I>K</I>=<I>F</I><SUB>256</SUB>=<I>F</I><SUB><I>d</I></SUB>.</P><P>On veut coder un message de longueur <I>k</I> avec des possibilités
de détection et de correction d’erreurs, pour cela on rajoute
des symboles calculés à partir des précédents, 
on envoie un élément d’un code ayant <I>n</I> symboles.</P><!--TOC subsubsection Le bit de parité.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc119">14.4.1</A>  Le bit de parité.</H4><!--SEC END --><P><A NAME="@default160"></A>
On prend <I>k</I>=7 bits et <I>n</I>=8 bits. On compte
le nombre de 1 parmi les 7 bits envoyés, si ce nombre est pair, 
on envoie 0 comme 8ième bit, sinon 1. 
Au final le nombre de bits à 1 de l’octet (1 octet=8 bits)
est pair. On peut ainsi détecter une erreur de transmission si
à la réception le nombre de bits d’un octet est impair, mais on
ne peut pas corriger d’erreurs.
On peut aussi dire que l’octet
représente un polynôme à coefficients dans ℤ/2ℤ divisible
par <I>X</I>+1.</P><P><B>Exercice</B> :
Écrire un programme Xcas permettant de rajouter un bit de parité
à une liste composée de 7 bits. Puis un programme de vérification
qui accepte ou non un octet selon sa parité. Vous représenterez
l’octet par une liste de bits, avec le délimiteur <CODE>poly1[</CODE>
pour pouvoir effectuer des opérations arithmétiques polynomiales,
et vous effectuerez la vérification de deux manières, en comptant
le nombre de 1 ou avec l’instruction <CODE>rem</CODE>.</P><!--TOC subsubsection Codes linéaires-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc120">14.4.2</A>  Codes linéaires</H4><!--SEC END --><P>
<B>Définition</B> :
On multiplie le vecteur des <I>k</I> symboles par
une matrice <I>M</I> à coefficients dans <I>K</I> de taille <I>n</I> × <I>k</I>
et on transmet l’image.
Pour assurer qu’on peut identifier un antécédent
unique à partir d’une image, il faut que <I>M</I> corresponde 
à une application linéaire injective, ce qui entraine <I>n</I>≥ <I>k</I>. 
On dit qu’un vecteur de <I>n</I> symboles est un mot du code 
s’il est dans l’image de l’application linéaire.</P><P>Pour assurer l’injectivité tout en facilitant le décodage, 
on utilise souvent une matrice identité <I>k</I>,<I>k</I> comme sous-bloc
de la matrice <I>n</I>,<I>k</I>, par exemple on prend l’identité pour
les <I>k</I> premières lignes de <I>M</I>, on ajoute ensuite <I>n</I>−<I>k</I> lignes.</P><P>Pour savoir si un vecteur est un mot de code, il faut vérifier
qu’il est dans l’image de <I>M</I>. On peut par exemple vérifier
qu’en ajoutant la colonne de ses coordonnées à <I>M</I>, on ne change
pas le rang de <I>M</I> (qui doit être <I>k</I>) mais c’est assez couteux.
On préfère utiliser une matrice de controle <I>H</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I> ∈ Im(<I>M</I>) ⇔ <I>Hx</I>=0</TD></TR>
</TABLE><P>
Si la matrice <I>M</I> est composée de l’identité <I>I</I><SUB><I>k</I></SUB>
et d’une matrice <I>C</I> sur ses <I>n</I>−<I>k</I> dernières lignes, 
alors <I>H</I>=(−<I>C</I>,<I>I</I><SUB><I>n</I>−<I>k</I></SUB>).</P><P><B>Exercice</B> : créez une matrice <I>M</I> de taille 7,4 injective. Puis
un programme qui teste si un vecteur est un mot de code et en
extrait alors la partie avant codage. Vérifiez votre programme
avec un vecteur <I>Mv</I>, on doit obtenir un mot de code.<BR>
Instructions utiles : <CODE>idn</CODE> (matrice identité)
<CODE>ker</CODE> (noyau d’une application linéaire), <CODE>rank</CODE> (rang),
<CODE>tran</CODE> (tranposée), ... Pour créer une matrice, on peut coller
les lignes de 2 matrices <I>A</I> et <I>B</I> par <CODE>[op(A),op(B)]</CODE> ou avec
<CODE>blockmatrix</CODE>.</P><!--TOC subsubsection Codes polynomiaux-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc121">14.4.3</A>  Codes polynomiaux</H4><!--SEC END --><P>
<B>Définition</B> :
Il s’agit d’un cas particulier de codes linéaires.
On se donne un polynôme <I>g</I>(<I>x</I>) de degré <I>n</I>−<I>k</I>,
On représente le message de longueur <I>k</I> à coder par un polynôme 
<I>P</I> de degré <I>k</I>−1.
On multiplie <I>P</I> par <I>x</I><SUP><I>n</I>−<I>k</I></SUP>, on calcule le reste <I>R</I> de la division
de <I>P</I> <I>x</I><SUP><I>n</I>−<I>k</I></SUP> par <I>g</I>. On émet alors <I>P</I> <I>x</I><SUP><I>n</I>−<I>k</I></SUP>−<I>R</I> qui est divisible
par <I>g</I>. Les mots de code sont les polynômes divisibles par <I>g</I>.</P><P><B>Exercice</B> : écrire de cette façon le codage du bit de parité. Puis
une procédure Xcas de codage utilisant <I>g</I>=<I>X</I><SUP>7</SUP>+<I>X</I><SUP>3</SUP>+1 
(ce polynôme était utilisé par le Minitel).
N.B. on obtient le polynôme <I>X</I><SUP><I>n</I>−<I>k</I></SUP> sous forme
de polynome-liste dans Xcas par <TT>poly1[1,0$(n-k)]</TT>.</P><!--TOC subsubsection Détection et correction d’erreur-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc122">14.4.4</A>  Détection et correction d’erreur</H4><!--SEC END --><P><A NAME="@default161"></A>
Si le mot recu n’est pas dans l’image de l’application
linéaire il y a eu erreur de transmission. Sinon, il n’y
a pas eu d’erreur <EM>détectable</EM> (il pourrait y avoir eu plusieurs
erreurs qui se “compensent”).</P><P>Plutôt que de demander la réémission du mot mal transmis
(ce qui serait par exemple impossible en temps réel 
depuis un robot en orbite autour de Mars),
on essaie d’ajouter suffisamment d’information pour 
pouvoir corriger des erreurs en supposant
que leur nombre est majoré par <I>N</I>. 
Si les erreurs de
transmissions sont indépendantes, la probabilité d’avoir
au moins <I>N</I>+1 erreurs dans un message de longueur <I>L</I>
est ∑<SUB><I>k</I>=<I>N</I>+1</SUB><SUP><I>L</I></SUP> ( <SUB><I>k</I></SUB><SUP><I>L</I></SUP> ) є<SUP><I>k</I></SUP> (1−є)<SUP><I>L</I>−<I>k</I></SUP>, 
où є est la probabilité d’une erreur
de transmission, c’est aussi <CODE>1-binomial_cdf(L,epsilon,N)</CODE>. 
Par exemple, pour un message de 10<SUP>3</SUP> caractères,
chacun ayant une probabilité d’erreur de transmission de 10<SUP>−3</SUP>,
si on prend <I>N</I>=3, alors la probabilité d’avoir au moins 4 erreurs
est de 0.019 (arrondi par excès) :<BR>
<CODE>P(N,eps,L):=sum(comb(L,k)*eps^k*(1-eps)^(L-k),k,N+1,L):;</CODE><BR>
<CODE>P(3,1e-3,10^3)</CODE><BR>
ou directement <CODE>1-binomial_cdf(1000,1e-3,3)</CODE>.</P><P><B>Exemple</B> : On ne peut pas corriger d’erreur avec le bit de parité.</P><!--TOC subsubsection Distances-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc123">14.4.5</A>  Distances</H4><!--SEC END --><P><A NAME="@default162"></A> <A NAME="@default163"></A>
La distance de Hamming de 2 mots est le nombre de symboles qui diffèrent.
(il s’agit bien d’une distance au sens mathématique, 
elle vérifie l’inégalité triangulaire). </P><P>Exercice : écrire une procédure de calcul de la distance de Hamming
de 2 mots. En Xcas, la fonction s’appelle <TT>hamdist</TT>.</P><P>La distance d’un code est la distance de Hamming minimale
de 2 mots différents du code.
Pour un code linéaire, la distance est aussi le nombre minimal
de coefficients non nuls d’un vecteur non nul de l’image.
Pour un code polynomial, la distance du code
est le nombre minimal de coefficients non nuls d’un multiple
de <I>g</I> de degré inférieur à <I>n</I>.</P><P>Exercice : quelle est la distance du code linéaire que
vous avez créé plus haut ?</P><P><B>Majoration de la distance du code:</B><BR>
<A NAME="@default164"></A>
La distance minimale d’un code linéaire est inférieure ou 
égale à <I>n</I>−<I>k</I>+1 : en effet on écrit en ligne les coordonnées
des images de la base canonique (ce qui revient à transposer la
matrice) et on réduit par le pivot de Gauss,
comme l’application linéaire est injective, le rang de la matrice
est <I>k</I>, donc la réduction de Gauss crée <I>k</I>−1
zéros dans chaque ligne, donc le nombre de coefficients non nuls
de ces <I>k</I> lignes (qui sont toujours des mots de code) est 
au plus de <I>n</I>−<I>k</I>+1.</P><P>Exercice : si votre code linéaire n’est pas de distance 3, modifiez
les 3 dernières lignes pour réaliser un code de distance 3. On
ne peut pas obtenir une distance <I>n</I>−<I>k</I>+1=4 avec <I>n</I>=7 et <I>k</I>=4 
dans ℤ/2ℤ, essayez! Essayez sur ℤ/3ℤ et ℤ/5ℤ.</P><P>N.B. : Pour les codes non
polynomiaux, par exemple convolutifs, la distance n’est pas
forcément le
paramètre le mieux adapté à la correction d’erreurs.</P><!--TOC subsubsection Correction au mot le plus proche-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc124">14.4.6</A>  Correction au mot le plus proche</H4><!--SEC END --><P>
Une stratégie de correction basée sur la distance consiste à
trouver le mot de code le plus proche d’un mot donné.
Si la distance d’un code est supérieure ou égale
à 2<I>t</I>+1, et s’il existe un mot de code de distance inférieure
à <I>t</I> au mot donné, alors ce mot de code est unique.
On corrige alors le mot transmis en le remplaçant par le mot de code
le plus proche.</P><P>Exercice : écrivez un programme permettant de corriger une erreur
dans un mot dans votre code linéaire.</P><P>On dit qu’un code <I>t</I>-correcteur est parfait si la réunion des boules
de centre un mot de code et de rayon <I>t</I> (pour la distance de Hamming)
est disjointe et recouvre l’ensemble des mots (<I>K</I><SUP><I>n</I></SUP>).</P><P>Exercice : votre code linéaire sur ℤ/2ℤ (celui de distance 3) 
est-il un code 1-correcteur parfait ?</P><!--TOC subsubsection Codes de Hamming-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc125">14.4.7</A>  Codes de Hamming</H4><!--SEC END --><P>
Soit un code de longueur <I>n</I>, de dimension <I>k</I>, le nombre
d’informations supplémentaires est noté <I>m</I>=<I>n</I>−<I>k</I>. Un code
de Hamming permet une correction, donc la distance du code
δ est (au moins) 3. Si le code est parfait sur <I>K</I>=<I>F</I><SUB><I>d</I></SUB>, on a 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(1+<I>n</I>(<I>d</I>−1))<I>d</I><SUP><I>k</I></SUP>=<I>d</I><SUP><I>n</I></SUP> ⇒ <I>n</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I><SUP><I>m</I></SUP>−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>d</I>−1</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Par exemple si <I>d</I>=2 et <I>m</I>=4 alors <I>n</I>=15. 
Il n’y a qu’une matrice de controle possible de taille
(15,4) telle que <I>Hx</I> donne la position de l’erreur (en base 2),
elle est obtenue en écrivant les entiers de 1 à 15 en base 2
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>H</I>=</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
on déplace les colonnes de la matrice identité 
(colonnes 1, 2, 4, 8)
en fin pour écrire <I>H</I>=(−<I>C</I>,<I>I</I><SUB>4</SUB>), le code correspondant est
( <SUB><I>C</I></SUB><SUP><I>I</I><SUB>11</SUB></SUP> ), il permet de corriger une erreur,
on calcule <I>Hx</I> et si le résultat est non nul, on change le
bit d’indice <I>Hx</I> en tenant compte du déplacement des colonnes
1, 2, 4 et 8. En fait, il est plus simple de ne pas faire ce
déplacement de colonnes.</P><P>Code systématique : 
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
On repère les indices de bit en commençant
à 1
</LI><LI CLASS="li-enumerate">On écrit les indices de bit en base 2
</LI><LI CLASS="li-enumerate">Les bits dont les indices sont des puissance de 2
sont des bits de parité
</LI><LI CLASS="li-enumerate">Les autres bits sont des bits de donnée
</LI><LI CLASS="li-enumerate">Les bits de parité sont calculés pour avoir parité
paire selon les bits d’indice respectifs 1 mod 2 pour le bit de
parité p1, selon les bits d’indice divisé par 2 valant 1 mod 2 pour le bit de parité p2, etc.
</LI><LI CLASS="li-enumerate">Pour corriger une erreur, on corrige le bit dont la position
écrite en base 2 a des 1 là où la parité est fausse.
</LI></OL><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=right NOWRAP>Indice</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>3</TD><TD ALIGN=center NOWRAP>4</TD><TD ALIGN=center NOWRAP>5</TD><TD ALIGN=center NOWRAP>6</TD><TD ALIGN=center NOWRAP>7</TD><TD ALIGN=center NOWRAP>8</TD><TD ALIGN=center NOWRAP>9</TD><TD ALIGN=center NOWRAP>10</TD><TD ALIGN=center NOWRAP>11</TD><TD ALIGN=center NOWRAP>12</TD><TD ALIGN=center NOWRAP>13</TD><TD ALIGN=center NOWRAP>14</TD><TD ALIGN=center NOWRAP>15</TD></TR>
<TR><TD ALIGN=right NOWRAP>p1</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>x</TD></TR>
<TR><TD ALIGN=right NOWRAP>p2</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD></TR>
<TR><TD ALIGN=right NOWRAP>p4</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD></TR>
<TR><TD ALIGN=right NOWRAP>p8</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD><TD ALIGN=center NOWRAP>x</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>p1</TD><TD ALIGN=center NOWRAP>p2</TD><TD ALIGN=center NOWRAP>d1</TD><TD ALIGN=center NOWRAP>p4</TD><TD ALIGN=center NOWRAP>d2</TD><TD ALIGN=center NOWRAP>d3</TD><TD ALIGN=center NOWRAP>d4</TD><TD ALIGN=center NOWRAP>p8</TD><TD ALIGN=center NOWRAP>d5</TD><TD ALIGN=center NOWRAP>d6</TD><TD ALIGN=center NOWRAP>d7</TD><TD ALIGN=center NOWRAP>d8</TD><TD ALIGN=center NOWRAP>d9</TD><TD ALIGN=center NOWRAP>d10</TD><TD ALIGN=center NOWRAP>d11</TD></TR>
</TABLE><P>Autre exemple : le minitel utilisait <I>d</I>=2, <I>m</I>=7, <I>n</I>=2<SUP><I>m</I></SUP>−1.</P><!--TOC subsection Les codes de Reed-Solomon-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc126">14.5</A>  Les codes de Reed-Solomon</H3><!--SEC END --><P><A NAME="@default165"></A>
Il s’agit de codes polynomiaux qui réalisent la distance maximale
possible <I>n</I>−<I>k</I>+1. De plus la recherche du mot de code le plus
proche peut se faire par un algorithme de Bézout avec arrêt 
prématuré.</P><!--TOC subsubsection Théorie-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc127">14.5.1</A>  Théorie</H4><!--SEC END --><P>
On se donne un générateur <I>a</I> 
de <I>F</I><SUB><I>q</I></SUB><SUP>*</SUP> et le polynôme <I>g</I>(<I>x</I>)=(<I>x</I>−<I>a</I>)...(<I>x</I>−<I>a</I><SUP>2<I>t</I></SUP>) (donc <I>n</I>−<I>k</I>=2<I>t</I>). 
Typiquement <I>q</I>=2<SUP><I>m</I></SUP> avec <I>m</I>=8, 
<I>a</I> est une racine d’un polynôme irréductible
de degré <I>m</I> à coefficients dans ℤ/2 
qui ne divise pas <I>x</I><SUP><I>l</I></SUP>−1 pour <I>l</I> diviseur
strict de 2<SUP><I>m</I></SUP>−1, en pratique, on factorise le quotient de <I>x</I><SUP>2<SUP><I>m</I></SUP>−1</SUP>−1
par le ppcm des <I>x</I><SUP>(2<SUP><I>m</I></SUP>−1)/<I>p</I></SUP>−1 où <I>p</I> parcourt les
diviseurs premiers de 2<SUP><I>m</I></SUP>−1 et on en extrait un facteur de degré <I>m</I>.</P><P><B>Distance du code</B><BR>
Si la longueur <I>n</I> d’un mot vérifie
<I>n</I> ≤ 2<SUP><I>m</I></SUP>−1, alors la distance entre 2 mots du code est au moins
de 2<I>t</I>+1.
En effet, si un polynome <I>P</I> de degré &lt;<I>n</I> est un multiple de <I>g</I>
ayant moins de 2<I>t</I>+1 coefficients non nuls,
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>x</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>t</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>p</I><SUB><I>i</I><SUB><I>k</I></SUB></SUB> <I>x</I><SUP><I>i</I><SUB><I>k</I></SUB></SUP>,    <I>i</I><SUB><I>k</I></SUB>&lt;<I>n</I> </TD></TR>
</TABLE><P>
en écrivant <I>P</I>(<I>a</I>)=...=<I>P</I>(<I>a</I><SUP>2<I>t</I></SUP>)=0, on obtient
un déterminant de Van der Monde, on prouve qu’il est non nul en
utilisant la condition <I>i</I><SUB><I>k</I></SUB>&lt;<I>n</I> et le fait que la première puissance
de <I>a</I> telle que <I>a</I><SUP><I>x</I></SUP>=1 est <I>x</I>=2<SUP><I>m</I></SUP>−1.</P><P><B>Correction des erreurs</B><BR>
Soit <I>c</I>(<I>x</I>) le polynome envoyé, <I>d</I>(<I>x</I>)
le polynôme recu, on suppose qu’il y a moins de <I>t</I> erreurs
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>d</I>(<I>x</I>)−<I>c</I>(<I>x</I>)=<I>e</I>(<I>x</I>)= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">ν</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell">α<SUB><I>k</I></SUB> <I>x</I><SUP><I>i</I><SUB><I>k</I></SUB></SUP>,    ν ≤ <I>t</I></TD></TR>
</TABLE><P>
On calcule le polynome syndrome :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>s</I>(<I>x</I>)= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>t</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>d</I>(<I>a</I><SUP><I>i</I>+1</SUP>) <I>x</I><SUP><I>i</I></SUP>= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>t</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>e</I>(<I>a</I><SUP><I>i</I>+1</SUP>) <I>x</I><SUP><I>i</I></SUP> </TD></TR>
</TABLE><P>
on a donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>s</I>(<I>x</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>t</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">ν</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell">α<SUB><I>k</I></SUB> (<I>a</I><SUP><I>i</I>+1</SUP>)<SUP><I>i</I><SUB><I>k</I></SUB></SUP> <I>x</I><SUP><I>i</I></SUP> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">ν</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell">α<SUB><I>k</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>t</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>a</I><SUP><I>i</I>+1</SUP>)<SUP><I>i</I><SUB><I>k</I></SUB></SUP> <I>x</I><SUP><I>i</I></SUP></TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">ν</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell">α<SUB><I>k</I></SUB> <I>a</I><SUP><I>i</I><SUB><I>k</I></SUB></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>a</I><SUP><I>i</I><SUB><I>k</I></SUB></SUP><I>x</I>)<SUP>2<I>t</I></SUP>−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUP><I>i</I><SUB><I>k</I></SUB></SUP><I>x</I>−1</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On pose <I>l</I>(<I>x</I>) le produit des dénominateurs (que l’on appelle polynôme
localisateur, car ses racines permettent de trouver la position
des symboles à corriger), on a alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:lsw"></A>
<I>l</I>(<I>x</I>) <I>s</I>(<I>x</I>) = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">ν</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell">α<SUB><I>k</I></SUB> <I>a</I><SUP><I>i</I><SUB><I>k</I></SUB></SUP> ( (<I>a</I><SUP><I>i</I><SUB><I>k</I></SUB></SUP><I>x</I>)<SUP>2<I>t</I></SUP> −1 )
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>≠ <I>k</I>, <I>j</I> ∈ [1,ν]</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>a</I><SUP><I>i</I><SUB><I>j</I></SUB></SUP><I>x</I> −1) 
    (17)</TD></TR>
</TABLE><P>
Modulo <I>x</I><SUP>2<I>t</I></SUP>, <I>l</I>(<I>x</I>)<I>s</I>(<I>x</I>) est donc un polynôme <I>w</I> de degré inférieur
ou égal à ν −1, donc strictement inférieur à <I>t</I>.
Pour le calculer, on applique l’algorithme de Bézout à <I>s</I>(<I>x</I>)
et <I>x</I><SUP>2<I>t</I></SUP> (dans <I>F</I><SUB><I>q</I></SUB>), en s’arrêtant au premier reste <I>w</I>(<I>x</I>)
dont le degré est strictement inférieur à <I>t</I> (au lieu
d’aller jusqu’au calcul du PGCD de <I>s</I>(<I>x</I>) et <I>x</I><SUP>2<I>t</I></SUP>).
Les relations sur les degrés (cf. approximants de Padé et
la preuve ci-dessous) donnent
alors en coefficient de <I>s</I>(<I>x</I>) le polynôme <I>l</I>(<I>x</I>) de degré inférieur ou
égal à <I>t</I>. On en calcule les racines (en testant tous les éléments
du corps avec Horner), donc la place des symboles erronés.</P><P>Pour calculer les valeurs α<SUB><I>k</I></SUB>, on reprend la définition de <I>w</I>,
c’est le terme de droite de l’équation (<A HREF="#eq:lsw">17</A>) modulo <I>x</I><SUP>2<I>t</I></SUP>,
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>w</I>(<I>x</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">ν</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell">α<SUB><I>k</I></SUB> <I>a</I><SUP><I>i</I><SUB><I>k</I></SUB></SUP> (−1)
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>≠ <I>k</I>, <I>j</I> ∈ [1,ν]</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>a</I><SUP><I>i</I><SUB><I>j</I></SUB></SUP><I>x</I>−1) </TD></TR>
</TABLE><P>
Donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>w</I>(<I>a</I><SUP>−<I>i</I><SUB><I>k</I></SUB></SUP>) = − α<SUB><I>k</I></SUB> <I>a</I><SUP><I>i</I><SUB><I>k</I></SUB></SUP>  
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>≠ <I>k</I>, <I>j</I> ∈ [1,ν]</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>a</I><SUP><I>i</I><SUB><I>j</I></SUB></SUP> <I>a</I><SUP>−<I>i</I><SUB><I>k</I></SUB></SUP> −1) </TD></TR>
</TABLE><P>
Comme :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>l</I>(<I>x</I>)=(<I>a</I><SUP><I>i</I><SUB><I>k</I></SUB></SUP><I>x</I>−1)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>≠ <I>k</I>, <I>j</I> ∈ [1,ν]</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>a</I><SUP><I>i</I><SUB><I>j</I></SUB></SUP><I>x</I>−1) </TD></TR>
</TABLE><P>
on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>l</I>′(<I>a</I><SUP>−<I>i</I><SUB><I>k</I></SUB></SUP>)=<I>a</I><SUP><I>i</I><SUB><I>k</I></SUB></SUP></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>≠ <I>k</I>, <I>j</I> ∈ [1,ν]</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>a</I><SUP><I>i</I><SUB><I>j</I></SUB></SUP><I>a</I><SUP>−<I>i</I><SUB><I>k</I></SUB></SUP>−1) </TD></TR>
</TABLE><P>
Finalement :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">α<SUB><I>k</I></SUB> = −</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>w</I>(<I>a</I><SUP>−<I>i</I><SUB><I>k</I></SUB></SUP>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I>′(<I>a</I><SUP>−<I>i</I><SUB><I>k</I></SUB></SUP>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><!--TOC subsubsection Preuve du calcul de <I>l</I>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc128">14.5.2</A>  Preuve du calcul de <I>l</I></H4><!--SEC END --><P>
On avait <I>s</I>(<I>x</I>) avec deg(<I>s</I>)&lt;=2<I>t</I>−1,
il s’agissait de voir comment la solution <I>u</I>,<I>v</I>,<I>r</I> calculee par Bezout
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">   <A NAME="eq:loc"></A>
<I>u</I>(<I>x</I>)  <I>x</I><SUP>2<I>t</I></SUP>+ <I>v</I>(<I>x</I>) <I>s</I>(<I>x</I>) = <I>r</I>(<I>x</I>) 
    (18)</TD></TR>
</TABLE><P>
avec arrêt prématuré au 1er reste <I>r</I>(<I>x</I>) de degré &lt;=<I>t</I>−1 
correspondait à l’équation
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>l</I>(<I>x</I>) <I>s</I>(<I>x</I>) = <I>w</I>(<I>x</I>) <I>mod</I> <I>x</I><SUP>2<I>t</I></SUP> </TD></TR>
</TABLE><P>
avec deg(<I>l</I>)&lt;=<I>t</I> et deg(<I>w</I>)&lt;=<I>t</I>−1</P><P>On a vu que deg(<I>v</I>)&lt;=<I>t</I>.
On commence par factoriser la puissance de <I>x</I> de degré maximal <I>p</I> dans
<I>v</I>(<I>x</I>), et on simplifie (<A HREF="#eq:loc">18</A>) par <I>x</I><SUP><I>p</I></SUP>. 
Quitte à changer <I>v</I> et <I>r</I>, on se
ramene donc à:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I>(<I>x</I>)  <I>x</I><SUP>2<I>t</I>−<I>p</I></SUP>+ <I>v</I>(<I>x</I>) <I>s</I>(<I>x</I>) = <I>r</I>(<I>x</I>) </TD></TR>
</TABLE><P>
avec <I>v</I>(<I>x</I>) premier avec <I>x</I>, deg(<I>v</I>)&lt;= <I>t</I>−<I>p</I> et deg(<I>r</I>)&lt;= <I>t</I>−1−<I>p</I>.
On simplifie ensuite par le pgcd de <I>v</I>(<I>x</I>) et de <I>r</I>(<I>x</I>)
(qui divise <I>u</I>(<I>x</I>) car premier avec <I>x</I> puisqu’on a déjà traité les
puissances de <I>x</I>).
On a donc, quitte à changer de notation <I>u</I>,<I>v</I>,<I>r</I> tels que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I>(<I>x</I>)  <I>x</I><SUP>2<I>t</I>−<I>p</I></SUP>+ <I>v</I>(<I>x</I>) <I>s</I>(<I>x</I>) = <I>r</I>(<I>x</I>) </TD></TR>
</TABLE><P>
avec <I>v</I> et <I>r</I> premiers entre eux, <I>v</I> premier avec <I>x</I>,
deg(<I>v</I>)&lt;=<I>t</I>−<I>p</I> et deg(<I>r</I>)&lt;=<I>t</I>−1−<I>p</I> (N.B.: <I>p</I>=0 en general)</P><P>On observe que <I>l</I>(<I>x</I>) est premier avec <I>x</I> (0 n’est pas racine de <I>l</I>).
On raisonne modulo <I>x</I><SUP>2<I>t</I>−<I>p</I></SUP>, <I>l</I> et <I>v</I> sont inversibles modulo <I>x</I><SUP>2<I>t</I>−<I>p</I></SUP>,
donc 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>s</I>(<I>x</I>) = <I>w</I>(<I>x</I>)*<I>inv</I>(<I>l</I>) (mod  <I>x</I><SUP>2<I>t</I>−<I>p</I></SUP> ),
   <I>s</I>(<I>x</I>) = <I>r</I>(<I>x</I>)*<I>inv</I>(<I>v</I>) (mod <I>x</I><SUP>2<I>t</I>−<I>p</I></SUP> ) </TD></TR>
</TABLE><P>
donc 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>w</I>(<I>x</I>)*<I>inv</I>(<I>l</I>)=<I>r</I>(<I>x</I>)*<I>inv</I>(<I>v</I>) (mod <I>x</I><SUP>2<I>t</I>−<I>p</I></SUP> ) 
   ⇒    <I>w</I>(<I>x</I>)*<I>v</I>(<I>x</I>)=<I>r</I>(<I>x</I>)*<I>l</I>(<I>x</I>) (mod <I>x</I><SUP>2<I>t</I>−<I>p</I></SUP> ) </TD></TR>
</TABLE><P>
donc <I>w</I>(<I>x</I>)*<I>v</I>(<I>x</I>)=<I>r</I>(<I>x</I>)*<I>l</I>(<I>x</I>) à cause des majorations de degres</P><P>D’autre part par construction <I>w</I>(<I>x</I>) est premier avec <I>l</I>(<I>x</I>) (car chacun
des facteurs de <I>l</I>(<I>x</I>) divise tous les éléments de la somme définissant
<I>w</I>(<I>x</I>) sauf un), donc <I>l</I>(<I>x</I>) divise <I>v</I>(<I>x</I>), et comme <I>v</I>(<I>x</I>) est premier
avec <I>r</I>(<I>x</I>), on en déduit que <I>v</I>(<I>x</I>)=<I>C</I> <I>l</I>(<I>x</I>) où <I>C</I> est une constante non
nulle, puis <I>r</I>(<I>x</I>) = <I>C</I> <I>w</I>(<I>x</I>).</P><P>Bezout donne donc (après simplifications du couple <I>v</I>(<I>x</I>), <I>r</I>(<I>x</I>) par
son pgcd) le polynome localisateur à une constante près (donc les
racines et les positions des erreurs), et on peut calculer
les valeurs des erreurs avec <I>v</I> et <I>r</I> car la constante <I>C</I> se simplifie.</P><!--TOC subsubsection Avec Xcas-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc129">14.5.3</A>  Avec Xcas</H4><!--SEC END --><P>
Ouvrir la session <CODE>Aide-&gt;Exemples-&gt;crypto-&gt;reed_s</CODE></P><!--TOC section Factorisation des entiers et primalité.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc130">15</A>  Factorisation des entiers et primalité.</H2><!--SEC END --><P> <A NAME="sec:ifactor"></A>
<A NAME="@default166"></A>
Les principaux algorithmes utilisés dans Xcas sont les suivants :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
la division : pour les nombres premiers plus petits que 10000,
stockés dans une table. Cela permet de factoriser les entiers
plus petits que 10<SUP>10</SUP> et de détecter les premiers, on teste
si <I>k</I> divise <I>N</I> pour <I>k</I> dans la table tel que <I>k</I><SUP>2</SUP>≤ <I>N</I>.
Cela permet la factorisation partielle des entiers plus grands.
Le temps d’exécution est proportionnel au nombre de premiers
dans la table plus petits que √<SPAN style="text-decoration:overline"><I>N</I></SPAN>, multiplié par un facteur
ln(<I>N</I>) pour la factorisation partielle.<BR>
Le <B>crible</B> d’Erathosthène<A NAME="@default167"></A> permet de trouver la liste des premiers
plus petits qu’une valeur donnée. Voir le manuel de programmation
de Xcas.
</LI><LI CLASS="li-itemize">le test de pseudo-primalité de <B>Miller-Rabin</B><A NAME="@default168"></A><A NAME="@default169"></A> (voir
le manuel de programmation de Xcas) : effectué
pour 20 bases <I>a</I>, il donne en cas de réussite la primalité
pour les entiers plus petits que 10<SUP>14</SUP>, au-delà le nombre
est très probablement premier (moins de 1/4<SUP>20</SUP> malchance
d’avoir un non premier au sens où le nombre de bases <I>a</I>&lt;<I>p</I> qui passent
le test alors que le nombre <I>p</I> n’est pas premier est plus petit
que <I>p</I>/4). Si on veut certifier qu’un nombre est premier, on peut 
utiliser le test de Pocklington (voir la section
dédiée) ou le test APRCL via PARI.
</LI><LI CLASS="li-itemize">la méthode ρ de Pollard qui permet de trouver
les“petits” facteurs d’un entier <I>N</I> (plus petits que
10<SUP>10</SUP> environ). Cette méthode est détaillée plus bas.
La commande <CODE>ifactor</CODE> de PARI permet de détecter
des “petits” facteurs de plus grande taille par la méthode
des courbes elliptiques (ECM, cf. Cohen par exemple). Pollard-ρ
et ECM sont des méthodes de factorisation de type I, dont le
temps d’exécution est fonction de la taille du plus petit facteur
de l’entier à factoriser (supposé non premier).
</LI><LI CLASS="li-itemize">le crible quadratique qui permet de factoriser
en un temps raisonnable les entiers jusqu’à 10<SUP>70</SUP> environ.
Une esquisse de cette méthode est présentée plus bas.
Cette méthode est dite de type II, son temps d’exécution
est fonction de la taille de l’entier.
</LI></UL><!--TOC subsection Le test de primalité de Pocklington.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc131">15.1</A>  Le test de primalité de Pocklington.</H3><!--SEC END --><P><A NAME="@default170"></A> <A NAME="@default171"></A>
</P><DIV CLASS="theorem"><B>Théorème 27</B>  <EM>
Soit </EM><EM><I>N</I>&gt;1</EM><EM> entier. S’il existe deux entiers </EM><EM><I>a</I></EM><EM> et </EM><EM><I>q</I></EM><EM> tels que
</EM><UL CLASS="itemize"><LI CLASS="li-itemize"><EM>
</EM><EM><I>q</I></EM><EM> est un facteur premier de </EM><EM><I>N</I>−1</EM><EM> plus grand que </EM><EM>√</EM><EM><SPAN style="text-decoration:overline"><I>N</I></SPAN></EM><EM>−1</EM><EM>,
</EM></LI><LI CLASS="li-itemize"><EM><I>a</I></EM><SUP><EM><I>N</I>−1</EM></SUP><EM>=1 </EM><EM>(mod </EM><EM><I>N</I></EM><EM> )</EM><EM>
</EM></LI><LI CLASS="li-itemize"><EM><I>a</I></EM><SUP><EM>(<I>N</I>−1)/<I>q</I></EM></SUP><EM>−1</EM><EM> est premier avec </EM><EM><I>N</I></EM><EM>
</EM></LI></UL><EM>
alors </EM><EM><I>N</I></EM><EM> est premier.
</EM></DIV><P>
Preuve : Si <I>N</I> n’est pas premier, alors il a un facteur premier
<I>p</I>≤ √<SPAN style="text-decoration:overline"><I>N</I></SPAN>. Donc <I>q</I> et <I>p</I>−1 sont premiers entre eux
(car <I>q</I> est premier et <I>q</I>&gt;<I>p</I>−1). Soit <I>u</I> l’inverse de <I>q</I> modulo
<I>p</I>−1. Alors 1=<I>a</I><SUP><I>N</I>−1</SUP> (mod <I>p</I> ) car <I>p</I> divise <I>N</I>. Donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">1=<I>a</I><SUP><I>u</I>(<I>N</I>−1)</SUP> (mod <I>p</I> ) = </TD><TD CLASS="dcell">⎛<BR>
⎝</TD><TD CLASS="dcell"><I>a</I><SUP><I>uq</I></SUP></TD><TD CLASS="dcell">⎞<BR>
⎠</TD><TD CLASS="dcell"><SUP>(<I>N</I>−1)/<I>q</I></SUP> (mod <I>p</I> ) =
<I>a</I><SUP>(<I>N</I>−1)/<I>q</I></SUP> (mod <I>p</I> )</TD></TR>
</TABLE><P>
d’après le petit théorème de Fermat. Ceci contredit 
le fait que <I>a</I><SUP>(<I>N</I>−1)/<I>q</I></SUP>−1 soit premier avec <I>N</I>.</P><P>Le couple (<I>a</I>,<I>q</I>) est alors un certificat de primalité pour <I>N</I>.
Le problème c’est que trouver <I>a</I>,<I>q</I> peut être très difficile
voire impossible. Mais il existe une généralisation de ce
théorème qui est plus facile à réaliser
</P><DIV CLASS="theorem"><B>Théorème 28</B>  <EM>
Supposons que l’on sache factoriser </EM><EM><I>N</I>−1=<I>AB</I></EM><EM> comme produit de deux entiers
premiers entre eux avec </EM><EM><I>A</I>&gt;√</EM><EM><SPAN style="text-decoration:overline"><I>N</I></SPAN></EM><EM> dont la factorisation en produit
de facteurs premiers est connue. Si pour tout facteur </EM><EM><I>p</I></EM><EM> de </EM><EM><I>A</I></EM><EM> il
existe un entier </EM><EM><I>a</I></EM><SUB><EM><I>p</I></EM></SUB><EM> tel que </EM><EM><I>a</I></EM><SUB><EM><I>p</I></EM></SUB><SUP><EM><I>N</I>−1</EM></SUP><EM>=1 </EM><EM>(mod </EM><EM><I>N</I></EM><EM> )</EM><EM> et
</EM><EM><I>a</I></EM><SUB><EM><I>p</I></EM></SUB><SUP><EM>(<I>N</I>−1)/<I>p</I></EM></SUP><EM>−1</EM><EM> et </EM><EM><I>N</I></EM><EM> sont premiers entre eux, alors </EM><EM><I>N</I></EM><EM> est premier.
</EM></DIV><P>
Preuve : soit <I>v</I> un facteur premier de <I>N</I>. 
Soit <I>p</I> premier divisant <I>A</I> et <I>p</I><SUP><I>e</I></SUP> la plus grande
puissance de <I>p</I> divisant <I>A</I>. On va montrer que <I>v</I>=1 (mod <I>p</I><SUP><I>e</I></SUP> ).
Par le lemme chinois on en déduira <I>v</I>=1 (mod <I>A</I> ) puis <I>v</I>&gt;√<SPAN style="text-decoration:overline"><I>N</I></SPAN>
ce qui est impossible pour au moins un facteur premier de <I>N</I>.<BR>
Montrons donc que <I>v</I>=1 (mod <I>p</I><SUP><I>e</I></SUP> ). Soit <I>b</I>=<I>a</I><SUB><I>p</I></SUB><SUP>(<I>N</I>−1)/<I>p</I><SUP><I>e</I></SUP></SUP> (mod <I>v</I> ). Alors <I>b</I><SUP><I>p</I><SUP><I>e</I></SUP></SUP>=1 (mod <I>v</I> )
puisque <I>v</I> divise <I>N</I> et <I>b</I><SUP><I>p</I><SUP><I>e</I>−1</SUP></SUP> = <I>a</I><SUB><I>p</I></SUB><SUP>(<I>N</I>−1)/<I>p</I></SUP> (mod <I>v</I> ) ≠ 1
(mod <I>v</I> ) puisque <I>a</I><SUB><I>p</I></SUB><SUP>(<I>N</I>−1)/<I>p</I></SUP>−1 et <I>N</I> sont premiers entre eux.
Donc l’ordre de <I>b</I> modulo <I>v</I> est <I>p</I><SUP><I>e</I></SUP>, et <I>p</I><SUP><I>e</I></SUP> divise <I>v</I>−1 CQFD.</P><P>Ce test nécessite de savoir factoriser <I>N</I>−1, au moins
partiellement. Pour des <I>N</I> grands, cela peut nécessiter
de certifier que les facteurs obtenus sont eux-même premiers,
ce qui peut nécessiter une sorte d’appel récursif du test. C’est
l’étape difficile, la recherche des <I>a</I><SUB><I>p</I></SUB> n’est pas un blocage en pratique.</P><!--TOC subsection La méthode ρ de Pollard-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc132">15.2</A>  La méthode ρ de Pollard</H3><!--SEC END --><P> <A NAME="@default172"></A>
<B>Théorème des anniversaires </B>: la probabilité que <I>n</I> éléments pris au
hasard parmi <I>N</I> soient distincts 2 à 2 pour 
<I>n</I>=<I>a</I> √<SPAN style="text-decoration:overline">(</SPAN><I>N</I>)) et <I>N</I>→ ∞ 
est équivalente à <I>e</I><SUP>−<I>a</I><SUP>2</SUP>/2</SUP>, 
et peut donc être rendue arbitrairement petite.</P><P>En effet, cette probabilité vaut
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>=1(1−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)(1−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)...(1−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE><P>
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">−ln(<I>P</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> −ln(1−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)  </TD></TR>
</TABLE><P>
on reconnait une méthode de rectangles pour approcher ∫
−ln(1−<I>t</I>), fonction croissante positive sur ℝ<SUP>+</SUP> d’où l’encadrement
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> −ln(1−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)   <I>dt</I> ≤ −ln(<I>P</I>) ≤
</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> −ln(1−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)    <I>dt</I> </TD></TR>
</TABLE><P>
On intègre par parties, en posant −1=(<I>N</I>−<I>t</I>)′ 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell">−ln(1−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)   <I>dt</I> 
= (<I>N</I>−<I>t</I>) ln(1−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">) + </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"> <I>dt</I> 
= (<I>N</I>−<I>t</I>) ln(1−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">) + <I>t</I> </TD></TR>
</TABLE><P>
Si <I>t</I>/<I>N</I>=<I>o</I>(1) la primitive vaut :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>N</I>−<I>t</I>)(−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>N</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">+<I>O</I>(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUP>3</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">)+<I>t</I>
=−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + <I>O</I>(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">) </TD></TR>
</TABLE><P>
Donc pour <I>n</I>=<I>a</I>√<SPAN style="text-decoration:overline"><I>N</I></SPAN>, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">+ <I>O</I>(</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP>−1</SUP>)
≤ −ln(<I>P</I>) 
≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">+ <I>O</I>(</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP>−1</SUP>)</TD></TR>
</TABLE><P>
d’où le résultat annoncé.</P><P><B>Application </B>: si <I>N</I> est composé, on prend des entiers modulo <I>N</I>
générés par une suite 
récurrente <I>x</I><SUB><I>n</I>+1</SUB>=<I>f</I>(<I>x</I><SUB><I>n</I></SUB>) (mod <I>N</I> ), 
on espère qu’ils ont de bonne propriétés de répartition, 
et on regarde s’ils sont distincts modulo <I>p</I> où <I>p</I> est 
le plus petit facteur de <I>N</I>. Il suffira d’en générer 
<I>O</I>(√<SPAN style="text-decoration:overline"><I>p</I></SPAN>) pour avoir une bonne proba d’en trouver 
deux égaux modulo <I>p</I>. 
Comme on ne connait pas <I>p</I>, le test d’égalité modulo <I>p</I> 
se fait en calculant le pgcd des différence des 2 entiers modulo <I>N</I>
et de <I>N</I> qui doit être non trivial. 
La fonction <I>f</I> peut par exemple être <I>x</I> → <I>x</I><SUP>2</SUP>+1 
(ou <I>x</I><SUP>2</SUP>−1 ou <I>x</I><SUP>2</SUP>+3)<SUP><A NAME="text23" HREF="#note23">23</A></SUP>. 
On ne teste pas toutes les différences de paires d’entiers générés,
car ce serait trop long,
mais les <I>x</I><SUB>2<I>k</I></SUB>−<I>x</I><SUB><I>k</I></SUB> pour <I>k</I>=1,2,... 
ce qui suffit car la suite <I>x</I><SUB><I>k</I></SUB> est ultimement périodique 
(le dessin d’une suite ultimement périodique est un ρ
d’où la méthode tire son nom). 
Le calcul nécessite donc <I>O</I>(√<SPAN style="text-decoration:overline"><I>p</I></SPAN>*ln(<I>N</I>)<SUP>2</SUP>) opérations 
(ce qui est toujours mieux que la division triviale car <I>p</I> ≤ √<SPAN style="text-decoration:overline"><I>N</I></SPAN>).</P><!--TOC subsection Le crible quadratique-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc133">15.3</A>  Le crible quadratique</H3><!--SEC END --><P><A NAME="@default173"></A>
<A NAME="@default174"></A>
On cherche des relations <I>x</I><SUP>2</SUP>=<I>y</I><SUP>2</SUP> (mod <I>N</I> ), en espérant trouver un
facteur de <I>N</I> en calculant pgcd(<I>x</I>−<I>y</I>,<I>N</I>).
Problème trop difficile, à la place on va essayer de factoriser sur
une base de "petits" nombre premiers des <I>x</I><SUB><I>i</I></SUB><SUP>2</SUP>−<I>N</I> pour <I>x</I> 
proche de √<SPAN style="text-decoration:overline"><I>N</I></SPAN> (nombre friable). 
La taille de la base dépend de la taille de <I>N</I>. 
La recherche de <I>x</I><SUP>2</SUP> se fait par produit de <I>x</I><SUB><I>i</I></SUB> 
tel qu’il n’apparaisse que des carrés de la base des petits 
nombres premiers, ce qui s’obtient en résolvant 
un gros système linéaire à coefficient dans ℤ/2ℤ.
Pour trouver les <I>x</I><SUB><I>i</I></SUB> on utilise un crible: 
sachant que si on a une solution de <I>x</I><SUP>2</SUP>−<I>N</I>=0 (mod <I>p</I> ), 
alors <I>x</I>+<I>p</I>, <I>x</I>+2<I>p</I>, etc. le seront aussi, on a facilement les <I>x</I> 
tels que <I>x</I><SUP>2</SUP>−<I>N</I> est divisible par <I>p</I> à partir des 2 racines carrées 
de <I>N</I> modulo <I>p</I> si elles existent 
(sinon on ne met pas ces racines dans la base de petits premiers!). 
Le crible consiste à incrémenter de log(<I>p</I>) 
tous les éléments d’un tableau dont l’indice correspond 
à un <I>x</I> tel que <I>x</I><SUP>2</SUP>−<I>N</I> est divisible par <I>p</I>. 
Lorsqu’on a parcouru tous les premiers de la base de nombres premiers, 
on regarde dans le tableau les valeurs assez grandes 
vont correspondre à des possibilités d’entiers friables, 
on factorise alors les <I>x</I><SUB><I>i</I></SUB> correspondants pour avoir des relations. 
Dès qu’on a <I>k</I>+une marge de sécurité (par exemple 20 ou 50) 
relations où <I>k</I> est le nombre de premiers de la base 
on est sur qu’on trouvera une vingtaine ou une cinquantaine de
relations 
<I>x</I><SUP>2</SUP>=<I>y</I><SUP>2</SUP> (mod <I>N</I> ). 
Comme chaque relation a une chance sur 2 de donner un facteur de <I>N</I>, 
on pourra factoriser <I>N</I>, sauf malchance vraiment exceptionnelle!</P><!--TOC subsubsection Recherche de racine carrée modulo p-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc134">15.3.1</A>  Recherche de racine carrée modulo p</H4><!--SEC END --><P><A NAME="@default175"></A>
Pour trouver les solutions <I>x</I> de <I>x</I><SUP>2</SUP>−<I>N</I> divisible par <I>p</I>, il
faut calculer les racines carrées de <I>N</I> modulo <I>p</I>. On procède
comme suit :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
si <I>p</I>=2, alors √<SPAN style="text-decoration:overline"><I>N</I></SPAN>=<I>N</I>
</LI><LI CLASS="li-itemize">si <I>p</I>+1=0 (mod 4 ), si <I>N</I> est un carré alors <I>N</I><SUP>(<I>p</I>−1)/2</SUP>=1 (mod <I>p</I> ) 
donc ± <I>N</I><SUP>(<I>p</I>+1)/4</SUP> (mod <I>p</I> ) est la racine cherchée (calcul
effectué par l’algorithme de la puissance rapide).
</LI><LI CLASS="li-itemize">sinon on cherche le pgcd de <I>x</I><SUP>2</SUP>−<I>N</I> avec
powmod(<I>x</I>+<I>r</I>,(<I>p</I>−1)/2,<I>p</I>,<I>x</I><SUP>2</SUP>−<I>N</I>) 
où <I>r</I> est aléatoire, il y a une chance sur 2 que le pgcd soit de degré 1.<BR>
Si <I>p</I> est assez petit (disons <I>p</I>&lt; √<SPAN style="text-decoration:overline">2</SPAN><SUP><SPAN style="text-decoration:overline">31</SPAN></SUP>), il est plus rapide de
tester les carrés mod <I>p</I> de <I>k</I>=1,2,3, ..., (<I>p</I>−1)/2. Comme
(<I>k</I>+1)<SUP>2</SUP>=<I>k</I><SUP>2</SUP>+2*<I>k</I>+1 (mod <I>p</I> ), cela se résume à faire un shift (*2) une
addition, un test si ≥ <I>p</I> et dans ce cas une soustraction, puis un test
d’égalité avec <I>N</I>, le tout avec des entiers courts (32 bits) ce qui est
très rapide.
</LI></UL><!--TOC section Factorisation des polynômes.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc135">16</A>  Factorisation des polynômes.</H2><!--SEC END --><P> <A NAME="sec:factor"></A>
On présente ici quelques algorithmes utilisés pour factoriser un polynôme 
à coefficients entiers, pour la recherche de racines approchées
d’un polynôme, cf. la section <A HREF="#sec:proot">19.6</A>.
Pour un polynôme en une variable,
cele se fait en plusieurs étapes : on commence
par se ramener à un polynôme <I>P</I> dont tous les facteurs sont de multiplicité
un, ensuite on factorise <I>P</I> dans ℤ/<I>p</I>ℤ (par la méthode de Berlekamp
ou Cantor-Zassenhauss), puis on remonte à ℤ/<I>p</I><SUP><I>k</I></SUP> <I>Z</I>
pour <I>k</I> suffisamment grand (en fonction de la borne de Landau sur les
facteurs de <I>P</I>), et on recombine enfin les facteurs modulaires pour
trouver les facteurs de <I>P</I>. Lorsque <I>P</I> à plusieurs variables, on utilise
une méthode analogue à celle permettant de trouver le pgcd de polynômes
à plusieurs variables. 
</P><P><B>Rappel</B><BR>
Le pgcd des coefficients d’un polynôme est appelé contenu de ce polynôme.
Un polynôme est dit primitif si son contenu est égal à 1.</P><!--TOC subsection Les facteurs multiples-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc136">16.1</A>  Les facteurs multiples</H3><!--SEC END --><P><A NAME="@default176"></A> <A NAME="@default177"></A> <A NAME="@default178"></A>
Étant donné un polynôme <I>P</I> à coefficients entiers, on cherche à 
écrire :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>=Π<SUB><I>k</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>k</I></SUB><SUP><I>k</I></SUP> </TD></TR>
</TABLE><P>
où les <I>P</I><SUB><I>k</I></SUB> n’ont pas de facteurs multiples et sont premiers entre
eux deux à deux. Comme on est en
caractéristique 0, cela revient à dire que pgcd(<I>P</I><SUB><I>k</I></SUB>,<I>P</I><SUB><I>k</I></SUB>′)=1
et pgcd(<I>P</I><SUB><I>k</I></SUB>,<I>P</I><SUB><I>j</I></SUB>)=1. Bien entendu
on va utiliser la dérivée de <I>P</I> dans l’algorithme de recherche des <I>P</I><SUB><I>k</I></SUB> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>′=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>kP</I><SUB><I>k</I></SUB>′ <I>P</I><SUB><I>k</I></SUB><SUP><I>k</I>−1</SUP> Π<SUB><I>j</I>≠ <I>k</I></SUB> <I>P</I><SUB><I>j</I></SUB><SUP><I>j</I></SUP> </TD></TR>
</TABLE><P>
Soit <I>G</I> le pgcd de <I>P</I> et de <I>P</I>′. On a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>G</I>=Π<SUB><I>k</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>k</I></SUB><SUP><I>k</I>−1</SUP>, </TD></TR>
</TABLE><P>
en effet <I>G</I> divise <I>P</I> et <I>P</I>′ :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>W</I><SUB>1</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>G</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">=Π<SUB><I>k</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>k</I></SUB>,    
<I>Z</I><SUB>1</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>G</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>kP</I><SUB><I>k</I></SUB>′Π<SUB><I>j</I>≠ <I>k</I></SUB> <I>P</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>
il s’agit de vérifier que <I>W</I><SUB>1</SUB> et <I>Z</I><SUB>1</SUB> sont premiers entre eux. Soit <I>F</I> un
facteur irréductible du pgcd de <I>W</I><SUB>1</SUB> et <I>Z</I><SUB>1</SUB>, alors <I>F</I> divise l’un des 
<I>P</I><SUB><I>k</I></SUB>,
appelons <I>P</I><SUB><I>l</I></SUB> ce facteur. Comme <I>F</I> divise Π<SUB><I>j</I>≠ <I>k</I></SUB> <I>P</I><SUB><I>j</I></SUB> si <I>k</I>≠ <I>l</I>,
on en déduit que <I>F</I> divise le dernier terme de la somme de <I>Z</I><SUB>1</SUB>, c’est-à-dire
que <I>F</I> divise <I>lP</I><SUB><I>l</I></SUB>′Π<SUB><I>j</I>≠ <I>l</I></SUB> <I>P</I><SUB><I>j</I></SUB> donc <I>F</I> divise <I>P</I><SUB><I>l</I></SUB>′ puisque
les <I>P</I><SUB><I>k</I></SUB> sont premiers entre eux. Donc <I>P</I><SUB><I>l</I></SUB> et <I>P</I><SUB><I>l</I></SUB>′ ont un facteur
en commun, ce qui est contraire aux hypothèses.</P><P>On pose alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Y</I><SUB>1</SUB>=<I>Z</I><SUB>1</SUB>−<I>W</I><SUB>1</SUB>′=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>&gt;1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>k</I>−1)<I>P</I><SUB><I>k</I></SUB>′ Π<SUB><I>j</I>≠ <I>k</I></SUB> <I>P</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>
On définit alors par récurrence des suites de polynômes <I>W</I><SUB><I>n</I></SUB>, <I>Y</I><SUB><I>n</I></SUB> et
<I>G</I><SUB><I>m</I></SUB> par :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<I>G</I><SUB><I>m</I></SUB>=pgcd(<I>W</I><SUB><I>m</I></SUB>,<I>Y</I><SUB><I>m</I></SUB>)
</LI><LI CLASS="li-itemize"><I>W</I><SUB><I>m</I>+1</SUB>=<I>W</I><SUB><I>m</I></SUB>/<I>G</I><SUB><I>m</I></SUB> et <I>Y</I><SUB><I>m</I>+1</SUB>=<I>Y</I><SUB><I>m</I></SUB>/<I>G</I><SUB><I>m</I></SUB>−<I>W</I><SUB><I>m</I>+1</SUB>′
</LI></UL><P>
On va montrer que <I>P</I><SUB><I>m</I></SUB>=<I>G</I><SUB><I>m</I></SUB>. Commençons au rang <I>n</I>=1, on voit que <I>P</I><SUB>1</SUB>
divise <I>Y</I><SUB>1</SUB> (puisqu’il est commun à tous les Π<SUB><I>j</I>≠ <I>k</I></SUB> <I>P</I><SUB><I>j</I></SUB> car
<I>k</I>&gt;1) et divise <I>W</I><SUB>1</SUB>. Et c’est le seul facteur commun, car tout autre
facteur irréductible serait un diviseur d’un <I>P</I><SUB><I>l</I></SUB> pour <I>l</I>&gt;1, donc diviserait
(<I>l</I>−1)<I>P</I><SUB><I>l</I></SUB>′Π<SUB><I>j</I>≠ <I>l</I>,<I>j</I>&gt;1</SUB> <I>P</I><SUB><I>j</I></SUB>, donc diviserait <I>P</I><SUB><I>l</I></SUB>′.
Le raisonnement en un rang quelconque est identique, les polynômes sont
donnés par :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>G</I><SUB><I>m</I></SUB>=<I>P</I><SUB><I>m</I></SUB>,  <I>W</I><SUB><I>m</I></SUB>=Π<SUB><I>k</I>&gt;=<I>m</I></SUB> <I>P</I><SUB><I>k</I></SUB>,  
<I>Y</I><SUB><I>m</I></SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>&gt;<I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>k</I>−<I>m</I>)<I>P</I><SUB><I>k</I></SUB>′Π<SUB><I>j</I>≥ <I>m</I>, <I>j</I>≠ <I>k</I></SUB> <I>P</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>Lorsqu’on programme cet algorithme, le test d’arrêt est <I>G</I><SUB><I>m</I></SUB>=1.</P><P><B>Square-free factorisation (Algorithme de Yun)</B><BR>
Argument: un polynôme primitif <I>P</I> à coefficients entiers (ou dans ℤ[<I>i</I>]
ou dans un corps de caractéristique nulle).<BR>
Valeur renvoyée: une liste de polynômes <I>P</I><SUB><I>m</I></SUB> telle que 
<I>P</I>=Π<SUB><I>k</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>k</I></SUB><SUP><I>k</I></SUP>.<BR>
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Initialiser la liste résultat à liste vide.
</LI><LI CLASS="li-enumerate">Initialiser <I>W</I> à <I>P</I> et <I>Y</I> à <I>P</I>′. Calculer le pgcd <I>G</I> de <I>W</I> et <I>Y</I>
et simplifier <I>W</I> et <I>Y</I> par leur pgcd puis poser <I>Y</I>=<I>Y</I>−<I>W</I>′.
</LI><LI CLASS="li-enumerate">Boucle tant que <I>Y</I>≠ 0.
</LI><LI CLASS="li-enumerate">Calculer le pgcd <I>G</I> de <I>W</I> et <I>Y</I>. Ajouter <I>G</I> à la liste résultat.
</LI><LI CLASS="li-enumerate">Simplifier <I>W</I> et <I>Y</I> par <I>G</I>, puis poser <I>Y</I>=<I>Y</I>−<I>W</I>′ et passer à 
l’itération suivante.
</LI></OL><P>Remarque : lorsqu’on veut factoriser un polynôme à coefficients modulaires,
il faut aussi se ramener à un polynôme sans facteurs multiples mais
on ne peut pas utiliser cet algorithme tel quel car la caractéristique
du corps n’est pas nulle.</P><P><B>Exemple</B> :<BR>
Factorisation sans facteurs multiples de 
<I>P</I>(<I>X</I>)=(<I>X</I><SUP>3</SUP>−1)(<I>X</I>+2)<SUP>2</SUP>(<I>X</I><SUP>2</SUP>+3)<SUP>3</SUP>.
En mode interactif avec un logiciel de calcul formel, effectuons l’étape
d’initialisation :
</P><PRE CLASS="verbatim">W:=normal((x^3-1)*(x+2)^2*(x^2+3)^3);
Y:=diff(W,x);
G:=gcd(W,Y);
        x^5+2*x^4+6*x^3+12*x^2+9*x+18
W:=normal(W/G); 
        x^6+2*x^5+3*x^4+5*x^3+-2*x^2+-3*x-6
Y:=normal(Y/G);
Y:=normal(Y-diff(W,x));
        5*x^5+8*x^4+3*x^3+-5*x^2+-8*x-3
</PRE><P>On vérifie bien que <I>W</I>=(<I>x</I>+2)*(<I>x</I><SUP>3</SUP>−1)*(<I>x</I><SUP>2</SUP>+3) est le produit 
des facteurs <I>P</I><SUB><I>i</I></SUB>. On entame maintenant la boucle :
</P><PRE CLASS="verbatim">G:=gcd(W,Y);
        x^3-1   -&gt; P1
Y:=normal(Y/G);
W:=normal(W/G);
Y:=normal(Y-diff(W,x));
        2*x^2+4*x
G:=gcd(W,Y);
        x+2     -&gt; P2
Y:=normal(Y/G);
W:=normal(W/G);
Y:=normal(Y-diff(W,x));
        0
G:=gcd(W,Y);
        x^2+3   -&gt;  P3
</PRE><P>puis <I>W</I>=1 et <I>Y</I>=0 et le prochain <I>G</I> vaut 1, on a bien trouvé tous
les facteurs <I>P</I><SUB><I>i</I></SUB>.</P><!--TOC subsection Factorisation en une variable-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc137">16.2</A>  Factorisation en une variable</H3><!--SEC END --><P>
On suppose maintenant qu’on veut factoriser un polynôme <I>P</I> sans facteur
multiple (et primitif). En général on commence par simplifier <I>P</I> par
ses facteurs linéaires (détectés avec l’algorithme présenté dans le
premier article de cette série). On commence par chercher un nombre premier <I>p</I>
tel que <I>P</I> dans ℤ/<I>p</I>ℤ conserve le même degré et reste sans facteur 
multiple (donc pgcd(<I>P</I>,<I>P</I>′)=1 dans ℤ/<I>p</I>ℤ), ce qui est toujours
possible (il suffit de prendre <I>p</I> plus grand que le plus grand entier 
apparaissant dans l’algorithme du sous-résultant pour calculer
le pgcd de <I>P</I> et <I>P</I>′ dans ℤ).</P><P><B>Convention</B><BR>
Tous les polynômes ayant leurs coefficients dans un corps fini sont
supposés avoir comme coefficient dominant 1 lorsque le choix
existe (par exemple les facteurs d’un polynôme modulo <I>p</I>).</P><!--TOC subsubsection Factorisation dans ℤ/<I>p</I>ℤ[<I>X</I>]-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc138">16.2.1</A>  Factorisation dans ℤ/<I>p</I>ℤ[<I>X</I>]</H4><!--SEC END --><P>
On suppose qu’on a un polynôme <I>P</I> à coefficients dans ℤ/<I>p</I>ℤ sans
facteur multiple. Il s’agit de factoriser <I>P</I> dans ℤ/<I>p</I>ℤ[<I>X</I>].
Il existe essentiellement deux stratégies, l’une commence par factoriser par
groupes de facteurs de même degré puis casse les facteurs et l’autre 
plus directe à base d’algèbre linéaire modulaire (méthode de Berlekamp). 
Dans les deux cas, on utilise le fait que si <I>F</I> est un polynôme, 
alors les polynômes à coefficients dans ℤ/<I>p</I>ℤ
modulo <I>F</I> forment un anneau <I>A</I> qui est aussi un espace vectoriel 
sur ℤ/<I>p</I>ℤ de dimension le degré de <I>F</I> 
(si <I>F</I> est irréductible, alors <I>A</I> est un corps).
On s’intéresse alors aux propriétés de l’application 
ϕ: <I>x</I> ∈ <I>A</I> ↦ <I>x</I><SUP><I>p</I></SUP>.
On observe d’abord que cette application est une application <EM>linéaire</EM>.
Cela découle du petit théorème de Fermat pour ϕ(λ <I>x</I>)=λ
ϕ(<I>x</I>) et de la formule de Newton et de la primalité de <I>p</I> pour
ϕ(<I>x</I>+<I>y</I>)=ϕ(<I>x</I>)+ϕ(<I>y</I>).</P><P><B>Calcul de </B><B>ϕ</B><BR>
Pour mettre en oeuvre ces algorithmes, on commence par déterminer la matrice
de l’endomorphisme ϕ: <I>x</I> ↦ <I>x</I><SUP><I>p</I></SUP> dans ℤ/<I>p</I>ℤ[<I>X</I>] (mod <I>P</I>(<I>X</I>) )
muni de sa base canonique { 1, <I>X</I>,...,<I>X</I><SUP>deg(<I>P</I>)−1</SUP> }.</P><!--TOC subsubsection Distinct degree factorization-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc139">16.2.2</A>  Distinct degree factorization</H4><!--SEC END --><P> <A NAME="@default179"></A>
Cette méthode consiste à détecter les groupes de facteurs
ayant un degré donné (distinct degree factorization). Si nécessaire, 
on utilise ensuite un autre algorithme pour casser ces groupes.
On utilise ici les propriétés des itérées de l’application linéaire 
ϕ sur des espaces vectoriels de corps de base ℤ/<I>p</I>ℤ.
On va déterminer le produit <I>P</I><SUB><I>k</I></SUB> de tous les facteurs de <I>P</I> de degré <I>k</I>
en calculant le pgcd de <I>P</I> et de <I>X</I><SUP>(<I>p</I><SUP><I>k</I></SUP>)</SUP>−<I>X</I> dans ℤ/<I>p</I>ℤ[<I>X</I>].</P><P>Pour <I>k</I>=1, <I>X</I><SUP><I>p</I></SUP>−<I>X</I> est le produit des <I>X</I>−<I>k</I> pour tout <I>k</I>∈ ℤ/<I>p</I>ℤ
par le petit théorème de Fermat (<I>k</I><SUP><I>p</I></SUP>=<I>k</I> (mod <I>p</I> )), donc le pgcd
de <I>P</I> et de <I>X</I><SUP>(<I>p</I><SUP>1</SUP>)</SUP>−<I>X</I> dans ℤ/<I>p</I>ℤ[<I>X</I>] est le produit des facteurs
de <I>P</I> de degré 1.</P><P>Pour <I>k</I>&gt;1, le raisonnement se généralise de la manière suivante : on
considère un facteur irréductible <I>F</I>(<I>X</I>) de <I>P</I> de degré <I>k</I> et le corps
<I>K</I>=(ℤ/<I>p</I>ℤ)[<I>Y</I>] (mod <I>F</I>(<I>Y</I>) ). Le corps <I>K</I> est un corps fini, c’est
aussi un espace vectoriel sur ℤ/<I>p</I>ℤ de dimension <I>k</I>, donc <I>K</I> possède
<I>p</I><SUP><I>k</I></SUP> éléments et <I>K</I><SUP>*</SUP> est un groupe multiplicatif à <I>p</I><SUP><I>k</I></SUP>−1 éléments,
donc tout élément de <I>K</I><SUP>*</SUP> vérifie l’équation <I>x</I><SUP><I>p</I><SUP><I>k</I></SUP>−1</SUP>=1 donc
tout élément de <I>K</I> vérifie <I>x</I><SUP>(<I>p</I><SUP><I>k</I></SUP>)</SUP>=<I>x</I>. En particulier pour 
<I>x</I>=<I>Y</I> (mod <I>F</I>(<I>Y</I>) ) 
on trouve que <I>Y</I><SUP>(<I>p</I><SUP><I>k</I></SUP>)</SUP>=<I>Y</I> (mod <I>F</I>(<I>Y</I>) ) donc <I>F</I>(<I>X</I>) divise <I>X</I><SUP>(<I>p</I><SUP><I>k</I></SUP>)</SUP>−<I>X</I>
dans ℤ/<I>p</I>ℤ.</P><P>Réciproquement, si on se donne un facteur irréductible <I>F</I> qui divise
<I>X</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>−<I>X</I>, soit <I>K</I> le corps correspondant à <I>F</I>, 
alors le noyau de l’application linéaire
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I> ∈ <I>K</I> ↦ <I>x</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>−<I>x</I> ∈ <I>K</I> </TD></TR>
</TABLE><P>
est <I>K</I> tout entier, car <I>Y</I>=<I>Y</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP> (mod <I>F</I> )
entraine (<I>Y</I><SUP>2</SUP>)<SUP>(<I>p</I><SUP><I>k</I></SUP>)</SUP>=<I>Y</I><SUP>2 <I>p</I><SUP><I>k</I></SUP></SUP>=(<I>Y</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>)<SUP>2</SUP>=<I>Y</I><SUP>2</SUP> (mod <I>F</I> ) et de même
pour les autres puissances de <I>Y</I> qui, avec <I>Y</I><SUP>0</SUP>=1 également dans le
noyau, forment une base de l’espace vectoriel <I>K</I> sur ℤ/<I>p</I>ℤ. Donc le
nombre d’éléments de <I>K</I> est inférieur ou égal au degré du polynôme
<I>X</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>−<I>X</I> (puisque <I>X</I><SUP>(<I>p</I><SUP><I>k</I></SUP>)</SUP>−<I>X</I> est divisible par
<I>X</I>−<I>x</I> pour tout <I>x</I>∈ <I>K</I>),
donc le degré de <I>F</I> est inférieur ou égal à <I>k</I>.
(En fait le degré de <I>F</I> doit diviser <I>k</I>, en effet
on écrit l’idendité de Bézout
pour degré de <I>F</I> et <I>k</I>, on a alors
<I>u</I>deg(<I>F</I>)± <I>vk</I>=±pgcd(deg(<I>F</I>),<I>k</I>),
on change de membre les signes − pour n’avoir que des entiers positifs
on prend <I>X</I> puissance <I>p</I> à la puissance des deux membres, on en
déduit que <I>Y</I><SUP><I>p</I><SUP>gcd(<I>k</I>,deg(<I>F</I>))</SUP></SUP>=<I>Y</I> (mod <I>F</I> )  donc
degré de <I>F</I> divise <I>k</I> sinon il y a trop de solutions à l’équation
ci-dessus dans le corps).</P><P>Donc <I>P</I><SUB><I>k</I></SUB> est égal au pgcd de <I>P</I>/Π<SUB><I>j</I>&lt;<I>k</I></SUB> <I>P</I><SUB><I>j</I></SUB> avec <I>X</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>−<I>X</I>.</P><P><B>Algorithme distinct degree factorization</B><BR>
Argument: un polynôme <I>P</I> à coefficients entiers 
sans facteur multiple et primitif.<BR>
Valeur renvoyée: la liste <I>L</I> des produits des facteurs irréductibles et du
degré correspondant de <I>P</I> (ordonné par ordre croissant de degré).<BR>
On commence par initialiser <I>L</I> à vide et un polynôme auxiliaire <I>Q</I> à <I>X</I>
(il contiendra les valeurs de <I>X</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>−<I>X</I> (mod <I>P</I> )), on fait une boucle
indéfinie sur <I>k</I> commençant à 1 et incrémenté de 1 à chaque itération
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>k</I> est strictement plus grand que le degré de <I>P</I> divisé par 2,
on rajoute le couple (<I>P</I>,degre(<I>P</I>)) à <I>L</I> et on renvoie <I>L</I>
</LI><LI CLASS="li-itemize">On remplace <I>Q</I> par <I>Q</I><SUP><I>p</I></SUP> (mod <I>P</I> ) en utilisant le calcul de ϕ
modulo <I>P</I>
</LI><LI CLASS="li-itemize">On calcule le pgcd <I>G</I> de <I>Q</I>−<I>X</I> et de <I>P</I>. 
</LI><LI CLASS="li-itemize">Si <I>G</I> vaut 1, on passe à l’itération suivante
</LI><LI CLASS="li-itemize">On rajoute le couple (<I>G</I>,<I>k</I>) à la liste <I>L</I> et on remplace <I>P</I>
par le quotient de <I>P</I> par <I>G</I>.
</LI></UL><P><B>Exemple</B> :<BR>
Factorisation en degré distincts de (<I>X</I><SUP>3</SUP>+<I>X</I>+1)(<I>X</I><SUP>4</SUP>−<I>X</I>+1) dans
ℤ/5ℤ. On regarde d’abord si <I>P</I> reste sans facteur multiple après
réduction modulo 5.
</P><PRE CLASS="verbatim">P:=normal((x^3+x+1)*(x^4-x+1) mod 5);
gcd(P,diff(P,x));
    1 mod 5  -&gt; ok P est sans facteur multiple
P1:=gcd(P,(x^5-x)mod 5);
    (1 mod 5)*x -2 mod 5  -&gt; P1
P:=normal(P/P1);
P2:=gcd(P,(x^(5^2)-x)mod 5);
    1 mod 5  -&gt; pas de facteur de degre 2
P3:=gcd(P,(x^(5^3)-x)mod 5);
    (x^6+2*x^5+x^2+x+2) mod 5
</PRE><P>Donc <I>P</I> admet 3 facteurs dans ℤ/5ℤ: un de degré 1 (<I>x</I>−2) et
deux de degré 3 (dont le produit est <I>x</I><SUP>6</SUP>+2<I>x</I><SUP>5</SUP>+<I>x</I><SUP>2</SUP>+<I>x</I>+2).</P><P>Le même calcul dans ℤ/7ℤ donne
</P><PRE CLASS="verbatim">P:=normal((x^3+x+1)*(x^4-x+1) mod 7);
gcd(P,diff(P,x));
    1 mod 7  -&gt; ok P est sans facteur multiple
P1:=gcd(P,(x^7-x)mod 7);
    1 mod 7
P2:=gcd(P,(x^(7^2)-x)mod 7);
    1 mod 7
P3:=gcd(P,(x^(7^3)-x)mod 7);
    (x^3+x+1) mod 7
</PRE><P>donc <I>P</I> possède un facteur de degré 3 modulo 7, donc le facteur restant
de degré 4 est forcément irréductible.</P><P>On remarque sur cet exemple que 7 est plus intéressant que 5, car
la factorisation modulo 7 donne moins de facteurs (à recombiner pour
trouver la factorisation dans ℤ) et la factorisation est
complète modulo 7 alors que modulo 5 il faut casser le facteur de
degré 6 en deux facteurs de degré 3. La plupart des algorithmes
de factorisation effectuent la factorisation en degré distinct
modulo plusieurs entiers (ce qui peut de plus être parallélisé)
et choisissent le meilleur.</P><!--TOC subsubsection La méthode de Cantor-Zassenhaus-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc140">16.2.3</A>  La méthode de Cantor-Zassenhaus</H4><!--SEC END --><P>
<A NAME="@default180"></A>
Cet algorithme sert à casser des groupes de facteurs de même degré,
c’est une méthode probabiliste. On suppose donc qu’on a un produit <I>P</I>
d’au moins deux facteurs irréductibles de degré <I>d</I> à casser.
Soit <I>D</I> l’un des polynômes irréductibles de degré <I>d</I> à coefficients
dans ℤ/<I>p</I>ℤ, et soit <I>K</I>=ℤ/<I>p</I>ℤ[<I>Y</I>] (mod <I>D</I>(<I>Y</I>) ), on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>X</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>−<I>X</I>=Π<SUB>α ∈ <I>K</I> </SUB>(<I>X</I>−α) </TD></TR>
</TABLE><P>
puisque le corps <I>K</I> possède <I>p</I><SUP><I>d</I></SUP> éléments tous racines
de l’équation <I>X</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>=<I>X</I>.</P><P>On considère un polynôme <I>T</I> non constant, et le polynôme
<I>T</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>−<I>T</I>. En remplaçant <I>X</I> par <I>T</I> ci-dessus, on en déduit :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>T</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>−<I>T</I>=Π<SUB>α ∈ <I>K</I> </SUB>(<I>T</I>−α) </TD></TR>
</TABLE><P>
Donc pour tout élément β ∈ <I>K</I>=ℤ/<I>p</I>ℤ[<I>Y</I>] (mod <I>D</I>(<I>Y</I>) ), on a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>T</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>−<I>T</I>)(β)=Π<SUB>α ∈ <I>K</I> </SUB>(<I>T</I>(β)−α)=0</TD></TR>
</TABLE><P>
Donc <I>T</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>−<I>T</I> est divisible par <I>X</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>−<I>X</I> (puisque toutes les racines
du second sont racines du premier), donc est divisible par tout polynôme
irréductible de degré inférieur ou égal à <I>d</I> à coefficients dans <I>Z</I>/<I>p</I>ℤ.
Comme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:cantor"></A>
<I>T</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>−<I>T</I>=<I>T</I>(<I>T</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>p</I><SUP><I>d</I></SUP>−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">−1)(<I>T</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>p</I><SUP><I>d</I></SUP>−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">+1)
    (19)</TD></TR>
</TABLE><P>
et que ces trois facteurs sont premiers entre eux, on en déduit que tout 
polynôme irréductible de degré inférieur ou égal à <I>d</I> à coefficients dans 
<I>Z</I>/<I>p</I>ℤ divise l’un des trois facteurs ci-dessus. Pour casser <I>P</I>, l’idée
consiste alors à calculer le pgcd de <I>P</I> et <I>T</I><SUP><I>p</I><SUP><I>d</I></SUP>−1/2</SUP>−1
pour un polynôme pris au hasard. On sait que <I>P</I> divise le produit des
3 termes de (<A HREF="#eq:cantor">19</A>), et on espère que les facteurs irréductibles
de <I>P</I> ne diviseront pas tous le même terme.</P><P>On va montrer que si <I>T</I> est un polynôme de degré ≤ 2<I>d</I>−1 choisi au hasard,
la probabilité que deux facteurs irréductibles de <I>P</I> ne divisent pas 
<I>T</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>−<I>T</I> est proche de 0.5. Soient donc <I>A</I> et <I>B</I> deux facteurs
irréductibles de <I>P</I> de degré <I>d</I>. D’après l’identité de Bézout, tout 
polynôme <I>T</I> de degré ≤ 2<I>d</I>−1 s’écrit de manière unique sous la forme :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:bezout2"></A> 
<I>T</I> = <I>A</I> <I>U</I> + <I>B</I> <I>V</I> 
    (20)</TD></TR>
</TABLE><P>
avec degre(<I>U</I> ≤ <I>d</I>−1) et degre(<I>V</I> ≤ <I>d</I>−1) et réciproquement 
une combinaison linéaire de cette forme est un polynôme de degré ≤ 2<I>d</I>−1.
Choisir <I>T</I> au hasard revient donc à choisir un couple (<I>U</I>,<I>V</I>) de polynômes
à coefficients dans ℤ/<I>p</I>ℤ au hasard et
de manière indépendante. D’autre part, <I>A</I> et <I>B</I> étant de degré <I>d</I>, on
sait que dans <I>K</I>=ℤ/<I>p</I>ℤ[<I>Y</I>] (mod <I>D</I>(<I>Y</I>) ) ces polynômes admettent <I>d</I> racines.
Soit donc α [respectivement β] une racine de <I>A</I> [resp. <I>B</I>]
dans <I>K</I>. Alors <I>A</I> divise <I>T</I><SUP><I>p</I><SUP><I>d</I></SUP>−1/2</SUP>−1
si et seulement si <I>T</I>(α )<SUP><I>p</I><SUP><I>d</I></SUP>−1/2</SUP>=1 (et de même pour
<I>B</I> et β) car <I>T</I><SUP><I>p</I><SUP><I>d</I></SUP>−1/2</SUP>−1 a ses coefficients dans
ℤ/<I>p</I>ℤ (et non dans <I>K</I>). 
En appliquant (<A HREF="#eq:bezout2">20</A>), <I>A</I> divise <I>T</I><SUP><I>p</I><SUP><I>d</I></SUP>−1/2</SUP>−1
si et seulement si :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>B</I>(α )</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>p</I><SUP><I>d</I></SUP>−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>V</I>(α )</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>p</I><SUP><I>d</I></SUP>−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">=1 </TD></TR>
</TABLE><P>
Le premier terme de cette égalité est une constante égale à 1 ou -1, 
le second a une probabilité proche de 0.5 (égale à <I>p</I><SUP><I>d</I></SUP>−1/2<I>p</I><SUP><I>d</I></SUP>)
de valoir 1 ou -1 car, comme <I>A</I> est irréductible,
<I>V</I>(α) décrit <I>K</I> lorsque <I>V</I> décrit les 
polynômes de degré ≤ <I>d</I>−1.
De même, <I>B</I> a une probabilité proche de 0.5 de diviser 
<I>T</I><SUP><I>p</I><SUP><I>d</I></SUP>−1/2</SUP>−1, et ces 2 probabilités sont indépendantes
puisque <I>U</I> et <I>V</I> le sont, donc la probabilité que soit <I>A</I> soit <I>B</I> divise
divise <I>T</I><SUP><I>p</I><SUP><I>d</I></SUP>−1/2</SUP>−1 est proche de 0.5.</P><P><B>Algorithme de Cantor-Zassenhaus</B><BR>
Argument: Un polynôme <I>P</I> à coefficients dans ℤ/<I>p</I>ℤ de degré <I>k</I>
dont tous les facteurs irréductibles sont de degré <I>d</I>.<BR>
Valeur renvoyée: la liste des facteurs irréductibles de <I>P</I>.<BR>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>k</I>=<I>d</I> renvoyer une liste contenant <I>P</I>.
</LI><LI CLASS="li-itemize">Déterminer un polynôme <I>T</I> aléatoire de degré inférieur ou égal
à 2<I>d</I>−1 et de coefficient dominant 1. Calculer le pgcd <I>D</I> de <I>P</I>
et de <I>T</I><SUP>(<I>p</I><SUP><I>d</I></SUP>−1)/2</SUP>−1. Si le degré de <I>T</I> est égal à 0 ou à <I>k</I> 
recommencer cette étape.
</LI><LI CLASS="li-itemize">Appeler récursivement cet algorithme avec <I>T</I> et <I>P</I>/<I>T</I> et
renvoyer la liste réunion des deux listes renvoyées.
</LI></UL><P><B>Exemple</B> :<BR>
Cassons le polynôme de degré 6 obtenu dans l’exemple précédent
(modulo 5). Donc <I>P</I>:=(<I>x</I><SUP>6</SUP>+2*<I>x</I><SUP>5</SUP>+<I>x</I><SUP>2</SUP>+<I>x</I>+2) (mod 5 ) et <I>d</I>=3, 2<I>d</I>−1=5,
(<I>p</I><SUP><I>d</I></SUP>−1)/2=62.
On choisit au hasard un polynôme de degré inférieur ou égal à 5, par exemple
<I>T</I>=<I>x</I><SUP>4</SUP>−<I>x</I><SUP>3</SUP>+<I>x</I>+1, puis on calcule <I>T</I><SUP>62</SUP> modulo <I>P</I> ce qui donne
(<I>x</I><SUP>5</SUP>+<I>x</I><SUP>3</SUP>+<I>x</I><SUP>2</SUP>+1) (mod 5 ) puis le pgcd de <I>T</I><SUP>62</SUP>−1 et de <I>P</I>
qui vaut <I>x</I><SUP>3</SUP>+<I>x</I>+1 (mod 5 ), on a donc cassé <I>P</I> en deux. 
En prenant <I>T</I>:=<I>x</I><SUP>4</SUP>−<I>x</I><SUP>3</SUP>+<I>x</I>+2, on trouve <I>T</I><SUP>62</SUP>=1 (mod <I>P</I> ), donc
ce <I>T</I> n’aurait pas permis de casser <I>P</I>.</P><!--TOC subsubsection La méthode de Berlekamp-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc141">16.2.4</A>  La méthode de Berlekamp</H4><!--SEC END --><P><A NAME="@default181"></A>
Cette méthode permet de factoriser un polynôme sans facteurs multiples,
elle peut aussi servir à casser des groupes de facteurs de même degré.
Ici on travaille dans l’anneau des polynômes à coefficients dans ℤ/<I>p</I>ℤ
modulo le polynôme <I>P</I> et on s’intéresse au noyau de ϕ−<I>Id</I>
(où ϕ: <I>x</I> ↦ <I>x</I><SUP><I>p</I></SUP>). On
suppose que <I>P</I>=Π<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> <I>F</I><SUB><I>j</I></SUB> où les <I>F</I><SUB><I>j</I></SUB> sont irréductibles et
premiers entre eux. On va montrer que le noyau de ϕ−<I>Id</I> est
composé des polynômes <I>Q</I> tels que <I>Q</I> (mod <I>F</I><SUB><I>j</I></SUB> ) est constant
(dans ℤ/<I>p</I>ℤ) pour tout <I>j</I>.</P><P>Si <I>Q</I> (mod <I>F</I><SUB><I>j</I></SUB> )=<I>s</I><SUB><I>j</I></SUB> ∈ ℤ/<I>p</I>ℤ, alors <I>Q</I><SUP><I>p</I></SUP> (mod <I>F</I><SUB><I>j</I></SUB> )=<I>s</I><SUB><I>j</I></SUB><SUP><I>p</I></SUP>=<I>s</I><SUB><I>j</I></SUB>, donc
par le théorème des restes chinois, <I>Q</I>=<I>Q</I><SUP><I>p</I></SUP> (mod <I>P</I> ). </P><P>Réciproquement, si
<I>Q</I><SUP><I>p</I></SUP>−<I>Q</I>=0 (mod <I>P</I> ), en utilisant la factorisation :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>X</I><SUP><I>p</I></SUP>−<I>X</I>= Π<SUB><I>j</I> ∈ ℤ/<I>p</I>ℤ </SUB> (<I>X</I>−<I>j</I>)</TD></TR>
</TABLE><P>
on en tire <I>P</I> divise <I>Q</I><SUP><I>p</I></SUP>−<I>Q</I>=Π<SUB><I>j</I> ∈ ℤ/<I>p</I>ℤ </SUB> (<I>Q</I>(<I>X</I>)−<I>j</I>),
donc <I>F</I><SUB><I>j</I></SUB> divise l’un des facteurs et <I>Q</I>(<I>X</I>) (mod <I>F</I><SUB><I>j</I></SUB> ) ∈ ℤ/<I>p</I>ℤ.
Le noyau de ϕ −<I>Id</I>
est donc un espace vectoriel de dimension <I>n</I>, le nombre
de facteurs irréductibles de <I>P</I> et possède donc <I>p</I><SUP><I>n</I></SUP> éléments
(en effet pour tout <I>n</I> uplet de <I>s</I><SUB><I>j</I></SUB>, on peut construire un polynôme
<I>Q</I> du noyau par le théorème des restes chinois en posant <I>Q</I>(mod <I>F</I><SUB><I>j</I></SUB> )=<I>s</I><SUB><I>j</I></SUB>).</P><P>L’intérêt du noyau de ϕ−<I>Id</I> est qu’on peut le calculer sans connaitre
les <I>F</I><SUB><I>j</I></SUB>. Une fois ce calcul fait, voyons comment on peut remonter 
aux <I>F</I><SUB><I>j</I></SUB>. On connait déjà la dimension du noyau donc le nombre de facteurs
irréductibles. De plus, on remarque que le polynome constant 1 est un
élément du noyau qu’on appellera <I>T</I><SUB>1</SUB>, on note alors <I>T</I><SUB>2</SUB>,...,<I>T</I><SUB><I>n</I></SUB> les
autres polynômes unitaires d’une base du noyau. 
Ensuite, on calcule le pgcd de <I>P</I> avec <I>T</I><SUB>2</SUB>−<I>jT</I><SUB>1</SUB>
pour <I>j</I>∈ ℤ/<I>p</I>ℤ. On sait que <I>T</I><SUB>2</SUB>=<I>s</I><SUB>2,<I>k</I></SUB> (mod <I>F</I><SUB><I>k</I></SUB> ), donc pgcd(<I>P</I>,<I>T</I><SUB>2</SUB>−<I>jT</I><SUB>1</SUB>)
est égal au produit des facteurs <I>F</I><SUB><I>k</I></SUB> tels que <I>s</I><SUB>2,<I>k</I></SUB>=<I>jT</I><SUB>1</SUB>. L’un au moins
des pgcd calculés est non trivial car sinon <I>T</I><SUB>2</SUB>=<I>T</I><SUB>1</SUB> (mod <I>F</I><SUB><I>j</I></SUB> ) pour
tout <I>j</I> donc <I>T</I><SUB>2</SUB>=<I>T</I><SUB>1</SUB>. Si on a de la chance tous les <I>s</I><SUB>2,<I>j</I></SUB> seront
distincts et les pgcd non triviaux de <I>P</I> avec <I>T</I><SUB>2</SUB>−<I>jT</I><SUB>1</SUB> donneront les <I>F</I><SUB><I>k</I></SUB>.
Sinon il faudra continuer avec <I>T</I><SUB>3</SUB>−<I>jT</I><SUB>1</SUB> etc.</P><P><B>Exemple</B> :<BR>
Revenons sur la factorisation de <I>P</I>:=(<I>x</I><SUP>6</SUP>+2<I>x</I><SUP>5</SUP>+<I>x</I><SUP>2</SUP>+<I>x</I>+2) (mod 5 ).
Commençons par calculer la matrice de ϕ dans la base
{ 1,<I>x</I>,<I>x</I><SUP>2</SUP>,...,<I>x</I><SUP>5</SUP>}. On a évidemment ϕ(1)=1 et
ϕ(<I>x</I>)=<I>x</I><SUP>5</SUP>, puis ϕ(<I>x</I><SUP>2</SUP>)=<I>x</I><SUP>10</SUP>=<I>x</I><SUP>5</SUP>+<I>x</I><SUP>4</SUP>−2<I>x</I><SUP>3</SUP>+<I>x</I> (mod <I>P</I> ),
puis en multipliant par <I>x</I><SUP>5</SUP> et en divisant par <I>P</I>,
ϕ(<I>x</I><SUP>3</SUP>)=−<I>x</I><SUP>4</SUP>+2<I>x</I><SUP>3</SUP>, de la même manière on obtient 
ϕ(<I>x</I><SUP>4</SUP>)=−<I>x</I><SUP>5</SUP>+2<I>x</I><SUP>4</SUP>+<I>x</I><SUP>3</SUP>−<I>x</I><SUP>2</SUP>−2 et ϕ(<I>x</I><SUP>5</SUP>)=<I>x</I><SUP>3</SUP>+<I>x</I><SUP>2</SUP>−<I>x</I>.
La matrice de ϕ est donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I>=</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>−2</TD><TD ALIGN=center NOWRAP>0</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>−1</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>1</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>−2</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>0</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>0</TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
On calcule ensuite le noyau de ϕ−<I>Id</I> (comme matrice à coefficients
dans ℤ/5ℤ), on obtient une
base du noyau en prenant par exemple les vecteurs (−1,0,0,0,0,0)
et (0,0,−1,−1,0,−1). Donc le polynôme <I>P</I> possède 2 facteurs dans
ℤ/5ℤ[<I>X</I>]. Pour déterminer les facteurs, on calcule le pgcd de <I>P</I>
avec le polynôme <I>T</I><SUB>2</SUB>−<I>s</I> où <I>T</I><SUB>2</SUB>=−<I>x</I><SUP>5</SUP>−<I>x</I><SUP>3</SUP>−<I>x</I><SUP>2</SUP> correspond au 2ème
vecteur de la base du noyau. On obtient pour <I>s</I>=0 un pcgd non trivial
(<I>x</I><SUP>3</SUP>+<I>x</I>+1), ce qui permet de calculer les 2 facteurs. Si on avait
essayé d’autres valeurs de <I>s</I>, pour <I>s</I>=1 on obtient comme pgcd 1, pour
<I>s</I>=2 on trouve le 2ème facteur <I>x</I><SUP>3</SUP>+2<I>x</I><SUP>2</SUP>−<I>x</I>+2.</P><!--TOC subsubsection Remontée (Hensel)-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc142">16.2.5</A>  Remontée (Hensel)</H4><!--SEC END --><P> <A NAME="@default182"></A>
Il s’agit de passer d’une factorisation de <I>P</I> dans ℤ/<I>p</I>ℤ[<I>X</I>] à une
factorisation de <I>P</I> dans ℤ/<I>p</I><SUP><I>k</I></SUP> <I>Z</I>[<I>X</I>], la méthode est analogue à celle
de l’algorithme EZGCD de calcul de pgcd de polynômes.</P><P>On suppose donc que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>=Π<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>j</I></SUB> (mod <I>p</I> ) </TD></TR>
</TABLE><P>
où les <I>P</I><SUB><I>j</I></SUB> sont premiers entre eux deux à deux dans ℤ/<I>p</I>ℤ.
Il s’agit de trouver des polynômes <I>P</I><SUB><I>j</I>,<I>k</I></SUB>=<I>P</I><SUB><I>j</I></SUB> (mod <I>p</I> ) tels que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>=Π<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>j</I>,<I>k</I></SUB> (mod <I>p</I><SUP><I>k</I></SUP> ) </TD></TR>
</TABLE><P>
Commençons par le cas <I>k</I>=2. On pose
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB><I>j</I>,2</SUB>=<I>P</I><SUB><I>j</I></SUB>+<I>pQ</I><SUB><I>j</I></SUB>=<I>P</I><SUB><I>j</I></SUB> (mod <I>p</I> ) </TD></TR>
</TABLE><P>
On a alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>P</I></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>Π<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>j</I>,2</SUB> (mod <I>p</I><SUP>2</SUP> ) =Π<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> (<I>P</I><SUB><I>j</I></SUB>+<I>pQ</I><SUB><I>j</I></SUB>) (mod <I>p</I><SUP>2</SUP> )</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">Π<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>j</I></SUB> + <I>p</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Q</I><SUB><I>j</I></SUB> Π<SUB><I>k</I>≠ <I>j</I></SUB> <I>P</I><SUB><I>k</I></SUB> (mod <I>p</I><SUP>2</SUP> ) </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Q</I><SUB><I>j</I></SUB> Π<SUB><I>k</I>≠ <I>j</I></SUB> <I>P</I><SUB><I>k</I></SUB>= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I>−Π<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>j</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>p</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (mod <I>p</I> ) </TD></TR>
</TABLE><P>
On est ramené à résoudre une identité de Bézout généralisée.
On montrera dans l’appendice le :
</P><DIV CLASS="theorem"><B>Théorème 29</B>  <EM> (Identité de Bézout généralisée)
Soit </EM><EM><I>P</I></EM><SUB><EM>1</EM></SUB><EM>, ..., </EM><EM><I>P</I></EM><SUB><EM><I>n</I></EM></SUB><EM> (</EM><EM><I>n</I>≥ 2</EM><EM>) des polynômes premiers entre eux deux 
à deux modulo </EM><EM><I>p</I></EM><EM>. Alors pour tout polynôme </EM><EM><I>Q</I></EM><EM>, il existe des polynômes 
</EM><EM><I>Q</I></EM><SUB><EM>1</EM></SUB><EM>, ..., </EM><EM><I>Q</I></EM><SUB><EM><I>n</I></EM></SUB><EM> tels que :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><EM><I>n</I></EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><FONT SIZE=6>∑</FONT></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><EM><I>j</I>=1</EM></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> <I>Q</I></EM><SUB><EM><I>j</I></EM></SUB><EM> Π</EM><SUB><EM><I>k</I>≠ <I>j</I></EM></SUB><EM> <I>P</I></EM><SUB><EM><I>k</I></EM></SUB><EM>=<I>Q</I> </EM><EM>(mod </EM><EM><I>p</I></EM><EM> )</EM><EM> </EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>On a donc réussi à remonter l’égalité <I>P</I>=Π <I>P</I><SUB><I>j</I></SUB> (mod <I>p</I> ) à 
<I>P</I>=Π <I>P</I><SUB><I>j</I>,2</SUB> (mod <I>p</I><SUP>2</SUP> ). Le passage de <I>P</I>=Π <I>P</I><SUB><I>j</I>,<I>l</I></SUB> (mod <I>p</I><SUP><I>l</I></SUP> )
à <I>P</I>=Π <I>P</I><SUB><I>j</I>,<I>l</I>+1</SUB> (mod <I>p</I><SUP><I>l</I>+1</SUP> ) est identique, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB><I>j</I>,<I>l</I>+1</SUB>=<I>P</I><SUB><I>j</I>,<I>l</I></SUB>+<I>p</I><SUP><I>l</I></SUP><I>Q</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>
où les <I>Q</I><SUB><I>j</I></SUB> sont les solutions de l’identité de Bézout généralisée avec :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Q</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I>−Π<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>j</I>,<I>l</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>p</I><SUP><I>l</I></SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Lorsqu’on programme cet algorithme (cf. l’appendice), 
on calcule une fois pour toutes les
solutions de l’identité de Bézout pour <I>Q</I>=1, et on multiplie par <I>Q</I>.</P><P><B>Algorithme de remontée de Hensel linéaire</B><BR>
Arguments: Un polynôme <I>P</I> à coefficients entiers, la liste <I>L</I>={ <I>P</I><SUB><I>j</I></SUB> } 
de ses facteurs dans ℤ/<I>p</I>ℤ[<I>X</I>]<BR>
Valeur renvoyée: la liste des facteurs de <I>P</I> dans ℤ/<I>p</I><SUP><I>l</I></SUP> ℤ[<I>X</I>]<BR>
On calcule la borne de Landau-Mignotte<SUP><A NAME="text24" HREF="#note24">24</A></SUP> 
pour les facteurs de <I>P</I>, on multiplie
par le coefficient dominant de <I>P</I> et on calcule <I>l</I> tel que <I>p</I><SUP><I>l</I></SUP> est
strictement plus grand que deux fois cette quantité. On calcule
aussi les polynômes <I>Q</I><SUB><I>j</I></SUB> de l’identité de Bézout généralisée pour <I>Q</I>=1<BR>
Puis on fait une boucle pour <I>k</I> variant de 2 à <I>l</I>:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
On détermine <I>P</I>−Π<SUB><I>j</I></SUB> <I>P</I><SUB><I>j</I></SUB> (mod <I>p</I><SUP><I>k</I></SUP> ), on divise par <I>p</I><SUP><I>k</I>−1</SUP>
et on place le résultat dans <I>Q</I>
</LI><LI CLASS="li-itemize">On multiplie les polynômes <I>Q</I><SUB><I>j</I></SUB> de l’identité de Bézout 
généralisée (correspondants au polynôme 1) par <I>Q</I>
et on détermine le reste de la division euclidienne de <I>Q</I> <I>Q</I><SUB><I>j</I></SUB> par <I>P</I><SUB><I>j</I></SUB>,
on multiplie par <I>p</I><SUP><I>k</I>−1</SUP> et on ajoute le résultat à <I>P</I><SUB><I>j</I></SUB>.
</LI></UL><P>Il existe une version quadratique de cette méthode. On passe alors de
<I>P</I>=Π <I>P</I><SUB><I>j</I>,<I>l</I></SUB> (mod <I>p</I><SUP><I>l</I></SUP> ) à <I>P</I>=Π <I>P</I><SUB><I>j</I>,2<I>l</I></SUB> (mod <I>p</I><SUP>2<I>l</I></SUP> ). Pour
cela, il faut trouver les polynômes <I>Q</I><SUB><I>j</I></SUB> solutions de l’équation :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Q</I><SUB><I>j</I></SUB> Π<SUB><I>k</I>≠ <I>j</I></SUB> <I>P</I><SUB><I>k</I>,<I>l</I></SUB>=<I>Q</I> (mod <I>p</I><SUP><I>l</I></SUP> )</TD></TR>
</TABLE><P>
Pour <I>l</I>=1, c’est l’identité de Bézout généralisée, mais ce n’est plus le
cas pour <I>l</I>&gt;1. En fait, on résout cette égalité en remontant l’identité
de Bézout quadratiquement, plus précisément pour trouver les <I>S</I><SUB><I>j</I></SUB>
solutions de
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>S</I><SUB><I>j</I></SUB> Π<SUB><I>k</I>≠ <I>j</I></SUB> <I>P</I><SUB><I>k</I>,2<I>l</I></SUB>=<I>Q</I> (mod <I>p</I><SUP>2<I>l</I></SUP> )</TD></TR>
</TABLE><P>
on pose <I>S</I><SUB><I>j</I></SUB>=<I>Q</I><SUB><I>j</I></SUB>+<I>p</I><SUP><I>l</I></SUP> <I>R</I><SUB><I>j</I></SUB>, il s’agit donc de trouver les <I>R</I><SUB><I>j</I></SUB> solutions de
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>Q</I><SUB><I>j</I></SUB>+<I>p</I><SUP><I>l</I></SUP> <I>R</I><SUB><I>j</I></SUB>) Π<SUB><I>k</I>≠ <I>j</I></SUB> <I>P</I><SUB><I>k</I>,2<I>l</I></SUB>=<I>Q</I> (mod <I>p</I><SUP>2<I>l</I></SUP> )</TD></TR>
</TABLE><P>
soit :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>R</I><SUB><I>j</I></SUB> Π<SUB><I>k</I>≠ <I>j</I></SUB> <I>P</I><SUB><I>k</I>,<I>l</I></SUB>
=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>Q</I>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Q</I><SUB><I>j</I></SUB> Π<SUB><I>k</I>≠ <I>j</I></SUB> <I>P</I><SUB><I>k</I>,<I>l</I></SUB> </TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>p</I><SUP><I>l</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (mod <I>p</I><SUP><I>l</I></SUP> )</TD></TR>
</TABLE><P>
on en déduit les <I>R</I><SUB><I>j</I></SUB>.</P><P><B>Algorithme de remontée de Hensel quadratique</B><BR>
Arguments et valeur renvoyée identiques à l’algorithme de remontée de Hensel
linéaire ci-dessus.<BR>
On commence comme dans le cas linéaire par calculer les coefficients
de l’identité de Bézout généralisée pour <I>Q</I>=1 et la valeur de <I>l</I> telle
que <I>p</I><SUP>2<SUP><I>l</I></SUP></SUP> soit supérieur à deux fois la borne de Landau des facteurs
de <I>P</I> fois le coefficient dominant de <I>P</I>.<BR>
On fait une boucle sur <I>k</I> variant de 1 à <I>l</I>:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
On calcule <I>P</I>−Π<SUB><I>j</I></SUB> <I>P</I><SUB><I>j</I></SUB> (mod <I>p</I><SUP>2<SUP><I>k</I></SUP></SUP> ), on divise par <I>p</I><SUP>2<SUP><I>k</I>−1</SUP></SUP>
et on place le résultat dans <I>Q</I>
</LI><LI CLASS="li-itemize">On multiplie par <I>Q</I> les polynômes <I>Q</I><SUB><I>j</I></SUB> de l’identité de Bézout
généralisée (avec comme second membre le polynôme 1),
on calcule le reste euclidien du résultat par <I>P</I><SUB><I>j</I></SUB> (modulo <I>p</I><SUP>2<SUP><I>k</I>−1</SUP></SUP>), 
on multiplie par <I>p</I><SUP>2<SUP><I>k</I>−1</SUP></SUP> et on ajoute à <I>P</I><SUB><I>j</I></SUB> (avec les notations
précédentes, on passe ainsi des <I>P</I><SUB><I>j</I>,2<SUP><I>k</I>−1</SUP></SUB> aux <I>P</I><SUB><I>j</I>,2<SUP><I>k</I></SUP></SUB>)
</LI><LI CLASS="li-itemize">Si <I>k</I>=<I>l</I> on renvoie la liste des <I>P</I><SUB><I>j</I></SUB>
</LI><LI CLASS="li-itemize">On calcule 1−∑<SUB><I>j</I></SUB> <I>Q</I><SUB><I>j</I></SUB> Π<SUB><I>k</I>≠ <I>j</I></SUB> <I>P</I><SUB><I>k</I></SUB> (mod <I>p</I><SUP>2<SUP><I>k</I></SUP></SUP> ), on
divise par <I>p</I><SUP>2<SUP><I>k</I>−1</SUP></SUP> et on place le résultat dans <I>Q</I>
</LI><LI CLASS="li-itemize">On multiplie par <I>Q</I> les polynômes <I>Q</I><SUB><I>j</I></SUB> de l’identité de Bézout,
généralisée et on calcule le reste euclidien du résultat par 
<I>P</I><SUB><I>j</I></SUB> (modulo <I>p</I><SUP>2<SUP><I>k</I>−1</SUP></SUP>), on multiplie par <I>p</I><SUP>2<SUP><I>k</I>−1</SUP></SUP> et 
on ajoute à <I>Q</I><SUB><I>j</I></SUB> (ce qui ajuste les polynômes <I>Q</I><SUB><I>j</I></SUB> qui vérifient
maintenant l’identité de Bézout modulo <I>p</I><SUP>2<SUP><I>k</I></SUP></SUP>)
</LI></UL><P><B>Remarque</B><BR>
Pendant l’étape de remontée de Hensel, une optimisation classique
consiste à tester la divisibilité dans ℤ du polynôme <I>P</I> par le 
facteur lifté <I>P</I><SUB><I>j</I></SUB> (<SUP><A NAME="text25" HREF="#note25">25</A></SUP>)
lorsqu’il n’a pas subi de modification pendant 2 étapes successives
(autrement dit lorsque <I>P</I><SUB><I>j</I></SUB> (mod <I>p</I><SUP><I>l</I></SUP> )=<I>P</I><SUB><I>j</I></SUB> (mod <I>p</I><SUP><I>l</I>+1</SUP> ) (ou
(mod <I>p</I><SUP>2<I>l</I></SUP> ) pour le lift quadratique). Si la division
est exacte, on obtient un facteur irréductible de <I>P</I> dans ℤ.
On recalcule alors la borne de Landau de <I>P</I>/<I>P</I><SUB><I>j</I></SUB> pour diminuer
le nombre d’itérations à effectuer dans cette étape.</P><P><B>Exemple</B> :<BR>
Reprenons le polynôme <I>P</I>(<I>X</I>)=(<I>X</I><SUP>3</SUP>+<I>X</I>+1)(<I>X</I><SUP>4</SUP>−<I>X</I>+1)
et supposons qu’on ait choisi de le factoriser modulo 5 puis 
de remonter. On a 3 facteurs
<I>a</I>=<I>x</I>−2, <I>b</I>=<I>x</I><SUP>3</SUP>+<I>x</I>+1 et <I>c</I>=<I>x</I><SUP>3</SUP>+2<I>x</I><SUP>2</SUP>−<I>x</I>+2. Si on développe <I>P</I>, on trouve 6
coefficients non nuls de valeur absolue 1, 
on peut calculer la borne de Landau-Mignotte correspondante
sur les coefficients d’un facteur entier : 2<SUP>5</SUP> (√<SPAN style="text-decoration:overline">(</SPAN>6)+1)
soit un peu plus de 110, il suffit donc d’effectuer 3 étapes de
remontée linéaire (5<SUP>4</SUP>=625&gt;111/2).
On commence par trouver 3 polynômes <I>A</I>, <I>B</I>, <I>C</I> tels que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>A</I>(<I>x</I><SUP>3</SUP>+<I>x</I>+1)(<I>x</I><SUP>3</SUP>+2<I>x</I><SUP>2</SUP>−<I>x</I>+2)+<I>B</I>(<I>x</I>−2)(<I>x</I><SUP>3</SUP>+2<I>x</I><SUP>2</SUP>−<I>x</I>+2)+</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>+<I>C</I>(<I>x</I>−2)(<I>x</I><SUP>3</SUP>+<I>x</I>+1)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>1 (mod 5 )</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On commence par résoudre <I>D</I>(<I>x</I><SUP>3</SUP>+2<I>x</I><SUP>2</SUP>−<I>x</I>+2)+<I>C</I>(<I>x</I>−2)(<I>x</I><SUP>3</SUP>+<I>x</I>+1)=1(mod 5 ),
on trouve <I>C</I>=2<I>x</I><SUP>2</SUP>−2 et <I>D</I>=−2<I>x</I><SUP>3</SUP>−2<I>x</I><SUP>2</SUP>+2<I>x</I>+1. Puis on calcule
<I>A</I> et <I>B</I> en résolvant <I>E</I>(<I>x</I><SUP>3</SUP>+<I>x</I>+1)+<I>F</I>(<I>x</I>−2)=1 qui donne <I>E</I>=1 et 
<I>F</I>=−<I>x</I><SUP>2</SUP>−2<I>x</I> qu’on multiplie par <I>D</I>, donc <I>A</I>=<I>D</I> et <I>B</I>=2<I>x</I><SUP>5</SUP>+<I>x</I><SUP>4</SUP>+2<I>x</I><SUP>3</SUP>−2<I>x</I>.
Ce qui donne l’identité de Bézout généralisée.</P><P>Passons aux calculs de remontée. On a <I>abc</I>=<I>x</I><SUP>7</SUP>−4<I>x</I><SUP>5</SUP>+5<I>x</I><SUP>4</SUP>+−9<I>x</I><SUP>3</SUP>−<I>x</I><SUP>2</SUP>−4
et <I>P</I>=<I>x</I><SUP>7</SUP>+<I>x</I><SUP>5</SUP>+<I>x</I><SUP>3</SUP>−<I>x</I><SUP>2</SUP>+1, donc <I>Q</I>=(<I>P</I>−<I>abc</I>)/5=<I>x</I><SUP>5</SUP>−<I>x</I><SUP>4</SUP>+2<I>x</I><SUP>3</SUP>+1. On pose
alors 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>a</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>a</I>+5  (<I>QA</I> (mod <I>a</I> ))(mod 25 ), </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>b</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>b</I>+5  (<I>QB</I> (mod <I>b</I> )) (mod 25 ), </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>c</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>c</I>+5  (<I>QC</I> (mod <I>c</I> )) (mod 25 ) </TD></TR>
</TABLE></TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB>1</SUB>= <I>a</I>+5 × (−2),    <I>b</I><SUB>1</SUB>=<I>b</I>+5 × 0, 
   <I>c</I><SUB>1</SUB>=<I>c</I>+5 × (2<I>x</I><SUP>2</SUP>−<I>x</I>) </TD></TR>
</TABLE><P>
En principe, on continue encore 2 itérations de la même manière.
La 2ème itération donne : 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Q</I>=(<I>P</I>−<I>a</I><SUB>1</SUB> <I>b</I><SUB>1</SUB> <I>c</I><SUB>1</SUB>)/25= 6<I>x</I><SUP>5</SUP>−3<I>x</I><SUP>4</SUP>+7<I>x</I><SUP>3</SUP>+3<I>x</I><SUP>2</SUP>−2<I>x</I>+1</TD></TR>
</TABLE><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>a</I><SUB>2</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>a</I><SUB>1</SUB>+25  (<I>QA</I> (mod <I>a</I> )) (mod 125 ), </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>b</I><SUB>2</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>b</I><SUB>1</SUB>+25  (<I>QB</I> (mod <I>b</I> )) (mod 125 ),</TD></TR>
<TR><TD ALIGN=right NOWRAP><I>c</I><SUB>2</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>c</I><SUB>1</SUB>+25  (<I>QC</I> (mod <I>c</I> )) (mod 125 )</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB>2</SUB>=<I>a</I><SUB>1</SUB> +25(−1)=<I>x</I>−37,  <I>b</I><SUB>2</SUB>=<I>b</I><SUB>1</SUB>=<I>b</I>,  <I>c</I><SUB>2</SUB>=<I>c</I><SUB>1</SUB>+25(<I>x</I><SUP>2</SUP>+1) 
=<I>x</I><SUP>3</SUP>+37<I>x</I><SUP>2</SUP>−6<I>x</I>+27 </TD></TR>
</TABLE><P>On peut aussi observer que <I>b</I><SUB>1</SUB>=<I>b</I>, ceci laisse à penser que <I>b</I> est 
un facteur de <I>P</I> dans ℤ ce qu’on vérifie en effectuant la
division euclidienne de <I>P</I> par <I>b</I>=<I>x</I><SUP>3</SUP>+<I>x</I>+1. Comme elle tombe
juste, on est ramené à factoriser <I>x</I><SUP>4</SUP>−<I>x</I>+1 et donc à remonter
la factorisation de <I>ac</I>. La borne de Landau diminue à 8(√<SPAN style="text-decoration:overline">3</SPAN>+1)
puisque le degré est 4 et la norme euclidienne du polynôme est √<SPAN style="text-decoration:overline">3</SPAN>.
Il suffit alors de remonter dans ℤ/125 ℤ au lieu de ℤ/625 ℤ
(on gagne ainsi une itération).</P><!--TOC subsubsection Combinaison de facteurs-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc143">16.2.6</A>  Combinaison de facteurs</H4><!--SEC END --><P>
Lorsqu’on a les facteurs de <I>P</I> dans ℤ/<I>p</I><SUP><I>k</I></SUP>ℤ[<I>X</I>] avec <I>p</I><SUP><I>k</I></SUP> plus grand
que le produit du coefficient dominant de <I>P</I> multiplié par la borne
de Landau-Mignotte sur les coefficients de <I>P</I>, on commence par
tester la divisibilité dans ℤ[<I>X</I>] de <I>P</I> par chaque facteur trouvé
multiplié par le coefficient dominant de <I>P</I>. Si la division est
exacte, on a un facteur irréductible, mais si elle n’est pas exacte
il peut se produire qu’un facteur irréductible de <I>P</I> dans ℤ[<I>X</I>] soit un
produit de deux, voir plusieurs, facteurs modulaires. Il faut
donc tester la divisibilité de <I>P</I> dans ℤ[<I>X</I>] par toutes les combinaisons 
possibles de produits de facteurs modulaires (toujours multiplié par
le coefficient dominant de <I>P</I>). Cette étape peut être exponentiellement
longue si le nombre de facteurs modulaires est grand et si par
exemple <I>P</I> est irréductible, bien que les cas soient très rares. </P><P><B>Algorithme de recombinaison</B><BR>
Arguments: un polynôme à coefficients entiers, primitif et sans facteur 
multiple <I>P</I> de coefficient dominant <I>p</I><SUB><I>n</I></SUB>,
la liste <I>L</I> des facteurs de <I>P</I> dans ℤ/<I>p</I><SUP><I>l</I></SUP> <I>Z</I>[<I>X</I>] pour 
<I>l</I> assez grand et <I>p</I><SUP><I>l</I></SUP><BR>
Valeur de retour: la liste <I>F</I> des facteurs de <I>P</I> dans ℤ.<BR>
Initialiser <I>F</I> à vide, initialiser le nombre de facteurs à combine <I>c</I> 
à 1, entamer une boucle infinie :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>c</I> est strictement supérieur au cardinal de <I>L</I> divisé par 2,
ajouter le quotient de <I>P</I> par le produit des facteurs de <I>F</I> à <I>F</I> 
et retourner <I>F</I>
</LI><LI CLASS="li-itemize">Initialiser un vecteur <I>v</I>=(<I>v</I><SUB>1</SUB>,...,<I>v</I><SUB><I>c</I></SUB>) à <I>c</I> composantes à
la valeur (1,...,<I>c</I>)
</LI><LI CLASS="li-itemize">Boucle indéfinie intérieure :
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Faire le produit des facteurs de <I>F</I> d’indice <I>v</I>, multiplier
par <I>p</I><SUB><I>n</I></SUB> dans ℤ/<I>p</I><SUP><I>l</I></SUP> <I>Z</I>, écrire le facteur en représentation symétrique,
le rendre primitif et tester si c’est un facteur de <I>P</I> dans ℤ.
</LI><LI CLASS="li-enumerate">Si on a trouvé un facteur, le rajouter à la liste <I>F</I> et supprimer les
indices de <I>v</I> de la liste <I>L</I>, terminer cette boucle intérieure.
</LI><LI CLASS="li-enumerate">Sinon, incrémenter <I>v</I> de la manière suivante:<BR>
On fait une boucle sur un index <I>m</I> initialisé à la taille de <I>v</I>,
diminuant de 1 à chaque itération: on ajoute 1 à l’élement de <I>v</I>
d’indice <I>m</I>, si l’élément obtenu est inférieur ou égal
au cardinal de <I>L</I>+<I>m</I>−<I>n</I>, on arrête cette boucle, sinon on passe
à l’itération suivante. Si <I>m</I>=0 à la fin de la boucle, <I>v</I>
ne peut pas être incrémenté. 
</LI><LI CLASS="li-enumerate">Si <I>v</I> ne peut être incrémenté, on incrémente <I>c</I> et on termine
la boucle intérieure.
</LI><LI CLASS="li-enumerate">Sinon on fait une boucle à nouveau
sur <I>m</I> en partant de la valeur actuelle incrémentée de 1, et tant
que <I>m</I>≤ <I>n</I> on pose <I>v</I><SUB><I>m</I></SUB>=<I>v</I><SUB><I>m</I>−1</SUB>+1. Puis on passe à l’itération
suivante de la boucle intérieure.
</LI></OL>
</LI></UL><P>Il existe différentes méthodes
qui améliorent la complexité de cette étape :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
La recherche des degré possibles de facteurs fondée sur
la factorisation en degrés distincts pour différents nombres premiers 
permet d’éviter des tests de division si une combinaison de facteurs
est d’un degré exclu par la factorisation pour d’autres nombres premiers.
</LI><LI CLASS="li-itemize">Le test de divisibilité du coefficient dominant ou du coefficient
constant permet aussi d’éviter des divisions complètes de polynômes.
</LI></UL><P>
Mais ces astuces n’évitent pas l’énumération de toutes les combinaisons
possibles de facteurs et donc la complexité exponentielle. Lorsque
les combinaisons d’un petit nombre de facteurs (par exemple 3)
échouent, les systèmes récents utilisent
l’algorithme <B>knapsack</B><A NAME="@default183"></A> de Van Hoeij basé sur l’algorithme LLL
(recherche de base d’un réseau ayant des vecteurs de petite norme) 
qui permet d’eliminer complètement cette complexité exponentielle.</P><P><B>Exemple</B> :<BR>
Toujours le même exemple, il nous restait deux
facteurs dans ℤ/125 ℤ, le facteur <I>x</I><SUP>3</SUP>+<I>x</I>+1 ayant été
détecté comme un facteur de <I>P</I>=<I>x</I><SUP>7</SUP>+<I>x</I><SUP>5</SUP>+<I>x</I><SUP>3</SUP>−<I>x</I><SUP>2</SUP>+1 dans ℤ.
On teste chacun des facteurs <I>a</I><SUB>2</SUB>=<I>x</I>−37 et <I>c</I><SUB>2</SUB>=<I>x</I><SUP>3</SUP>+37<I>x</I><SUP>2</SUP>−6*<I>x</I>+27
séparément, sans succès. On les multiplie alors modulo 125,
ce qui donne <I>x</I><SUP>4</SUP>−<I>x</I>+1 en représentation symétrique qui est bien
un facteur de <I>P</I> (donc un facteur irréductible).</P><!--TOC subsection Factorisation à plusieurs variables-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc144">16.3</A>  Factorisation à plusieurs variables</H3><!--SEC END --><P>
Comme pour le PGCD en plusieurs variables, on se ramène d’abord en
une variable, en général on évalue toutes les variables sauf celle
correspondant au degré partiel le plus faible. On factorise ensuite
en une variable puis on remonte. A chaque étape de remontée, il peut
être à nouveau nécessaire de combiner plusieurs facteurs. Différentes
stratégies existent, comme pour le PGCD : factorisarion heuristique
(avec reconstruction <I>z</I>-adique), remontée variable par variable
ou toutes les variables en même temps comme dans EZGCD.
On va présenter ici plus en détails l’algorithme de factorisation heuristique.</P><P>Soit <I>P</I> un polynôme en <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I></SUB> à coefficients entiers avec <I>n</I>&gt;1,
on choisit une des variables par exemple <I>X</I><SUB><I>n</I></SUB>, qu’on notera <I>X</I> dans la suite.
On considère <I>P</I> comme un polynôme en <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB> à coefficients dans 
ℤ[<I>X</I>]. On suppose que <I>P</I> est primitif (quitte à extraire
son contenu qui est dans ℤ[<I>X</I>]). On calcule ensuite
<I>P</I>(<I>z</I>) pour un entier <I>z</I> tel que<SUP><A NAME="text26" HREF="#note26">26</A></SUP> |<I>z</I>| ≥ 2|<I>P</I>|+2. On factorise <I>P</I>(<I>z</I>)
dans ℤ[<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB>] :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:heu1"></A>
<I>P</I>(<I>z</I>)(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB>)=<I>c</I>(<I>z</I>) Π<SUB><I>j</I>=1</SUB><SUP><I>k</I></SUP> <I>p</I><SUB><I>j</I></SUB>(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB>)
    (21)</TD></TR>
</TABLE><P>
où <I>c</I> est le contenu du polynôme <I>P</I>(<I>z</I>) (comme polynôme en <I>n</I>−1 
variables à coefficients entiers). Il s’agit de reconstruire les facteurs
de <I>P</I> à partir des <I>p</I><SUB><I>j</I></SUB> et de <I>c</I>. Deux problèmes se posent alors,
celui de la recombinaison possible de plusieurs facteurs <I>p</I><SUB><I>j</I></SUB> pour
obtenir un facteur irréductible de <I>P</I>, et l’existence d’un facteur entier du
contenu <I>c</I> à combiner avec un ou plusieurs <I>p</I><SUB><I>j</I></SUB> pour obtenir ce
facteur irréductible. Plus précisément, si <I>P</I><SUB><I>k</I></SUB> est un facteur 
irréductible de <I>P</I>, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:heu2"></A>
<I>P</I><SUB><I>k</I></SUB>(<I>z</I>)=<I>d</I>(<I>z</I>) Π<SUB>certains  <I>j</I></SUB> <I>p</I><SUB><I>j</I></SUB>,    où  
<I>d</I>(<I>z</I>)  divise  <I>c</I>(<I>z</I>)
    (22)</TD></TR>
</TABLE><P>On a le :
</P><DIV CLASS="theorem"><B>Théorème 30</B>  <EM>
Soit </EM><EM><I>P</I>(<I>X</I></EM><SUB><EM>1</EM></SUB><EM>,...,<I>X</I></EM><SUB><EM><I>n</I>−1</EM></SUB><EM>,<I>X</I>)</EM><EM> un polynôme à coefficients 
entiers ayant au moins 2 variables. On suppose que </EM><EM><I>P</I></EM><EM> est primitif
vu comme polynôme en les variables </EM><EM><I>X</I></EM><SUB><EM>1</EM></SUB><EM>,...,<I>X</I></EM><SUB><EM><I>n</I>−1</EM></SUB><EM>
à coefficients dans </EM><EM><I>Z</I>[<I>X</I>]</EM><EM>.
Il existe une majoration </EM><EM><I>C</I></EM><EM> du contenu </EM><EM>|<I>c</I>(<I>z</I>)|</EM><EM> de </EM><EM><I>P</I></EM><EM> évalué en </EM><EM><I>X</I>=<I>z</I></EM><EM>
(plus précisément on peut trouver un entier </EM><EM><I>C</I></EM><EM> tel que </EM><EM><I>c</I>(<I>z</I>)</EM><EM> divise
</EM><EM><I>C</I></EM><EM>).<BR>
Il existe un nombre fini de </EM><EM><I>z</I></EM><EM> tels que l’un des facteurs irréductibles
</EM><EM><I>P</I></EM><SUB><EM><I>k</I></EM></SUB><EM> de </EM><EM><I>P</I></EM><EM> évalué en </EM><EM><I>X</I>=<I>z</I></EM><EM> soit
réductible (c’est-à-dire tels que (</EM><A HREF="#eq:heu2"><EM>22</EM></A><EM>) admette 
plusieurs facteurs </EM><EM><I>p</I></EM><SUB><EM><I>j</I></EM></SUB><EM> distincts)
</EM></DIV><P><B>Preuve</B><BR>
Pour déterminer <I>C</I>, on remarque que les facteurs du contenu de <I>P</I>(<I>z</I>)
sont des facteurs communs des coefficients de <I>P</I> évalués en <I>z</I>
vu comme polynôme en <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB> à coefficients dans ℤ[<I>X</I>].
Donc <I>c</I>(<I>z</I>) divise le générateur de l’idéal engendré par ces coefficients
(ce générateur est un polynôme de ℤ[<I>X</I>] qui est constant car on a supposé
<I>P</I> primitif), on peut aussi dire que deux au moins des coefficients
dans ℤ[<I>X</I>] de <I>P</I> sont premiers entre eux, alors <I>c</I>(<I>z</I>) divise le
coefficient de l’identité de Bézout de ces 2 coefficients vu
comme polynômes en <I>X</I>.</P><P>Considérons maintenant un facteur irréductible <I>P</I><SUB><I>k</I></SUB> de <I>P</I> de degré <I>d</I>
par rapport à <I>X</I>. Pour <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB> fixés, on factorise <I>P</I><SUB><I>k</I></SUB> sur ℂ :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB><I>k</I></SUB>(<I>X</I>)=<I>p</I><SUB><I>k</I></SUB> Π<SUB><I>j</I>=1</SUB><SUP><I>d</I></SUP> (<I>X</I>−<I>z</I><SUB><I>j</I></SUB>) </TD></TR>
</TABLE><P>
On va maintenant se restreindre à un domaine des <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB> sur
lequel les <I>z</I><SUB><I>j</I></SUB> ont une dépendance analytique par rapport à <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB>.
Pour cela on veut appliquer le théorème des fonctions implicites pour 
déterminer <I>z</I><SUB><I>j</I></SUB> au voisinage d’une solution donnée. On calcule donc
la dérivée <I>P</I>′<SUB><I>k</I></SUB> de <I>P</I><SUB><I>k</I></SUB> par rapport à <I>X</I>. On sait que <I>P</I> n’a pas
de facteurs multiples, donc <I>P</I><SUB><I>k</I></SUB> et <I>P</I><SUB><I>k</I></SUB>′ sont premiers entre
eux, donc d’après l’identité de Bézout, il existe un polynôme non nul <I>D</I>
dépendant de <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB> et deux polynômes <I>U</I> et <I>V</I> dépendant
de <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB>,<I>X</I> tels que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>U</I> <I>P</I><SUB><I>k</I></SUB> + <I>V</I> <I>P</I><SUB><I>k</I></SUB>′ = <I>D</I> </TD></TR>
</TABLE><P>
Si <I>D</I>(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB>) ne s’annule pas, on va pouvoir appliquer le théorème
des fonctions implicites. On se fixe <I>x</I><SUB>1</SUB>,..,<I>x</I><SUB><I>n</I>−1</SUB>,
on calcule dans ℂ les racines <I>z</I><SUB><I>j</I></SUB> du polynôme <I>P</I>(<I>x</I><SUB>1</SUB>,..,<I>x</I><SUB><I>n</I>−1</SUB>,<I>X</I>)
pour une solution <I>z</I><SUB><I>j</I></SUB> telle que <I>P</I>(<I>x</I><SUB>1</SUB>,..,<I>x</I><SUB><I>n</I>−1</SUB>,<I>z</I><SUB><I>j</I></SUB>)=0, 
comme <I>D</I> est non nul, on a <I>P</I>′(<I>x</I><SUB>1</SUB>,...,<I>x</I><SUB><I>n</I>−1</SUB>,<I>z</I><SUB><I>j</I></SUB>)≠ 0, donc on peut 
écrire au voisinage de (<I>x</I><SUB>1</SUB>,..,<I>x</I><SUB><I>n</I>−1</SUB>)
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>z</I><SUB><I>j</I></SUB>=<I>z</I><SUB><I>j</I></SUB>(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB>),    <I>P</I>(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB>,<I>z</I><SUB><I>j</I></SUB>)=0</TD></TR>
</TABLE><P> 
avec des fonctions <I>z</I><SUB><I>j</I></SUB> analytiques. 
Si <I>D</I> est constant, <I>D</I> ne s’annule pas, 
sinon quitte à permuter les variables, on peut supposer que
le degré de <I>D</I> par rapport à <I>X</I><SUB>1</SUB> est non nul.
On peut alors se restreindre à une zone <I>X</I><SUB>1</SUB> &gt;&gt; <I>X</I><SUB>2</SUB> &gt;&gt; .. &gt;&gt; <I>X</I><SUB><I>n</I>−1</SUB> &gt;&gt; 1
où <I>D</I> sera non nul ce qui permet de suivre analytiquement les <I>z</I><SUB><I>j</I></SUB>.</P><P>Supposons maintenant qu’il existe un nombre infini de <I>z</I> tels <I>P</I><SUB><I>k</I></SUB>(<I>z</I>) 
soit réductible. Alors il existe un ensemble infini <I>Z</I>
de ces valeurs de <I>z</I> pour lesquels l’un des facteurs à coefficients
entiers <I>f</I><SUB><I>j</I></SUB> de <I>P</I><SUB><I>k</I></SUB>(<I>z</I>) correspond à un même
sous-ensemble <I>R</I> des racines <I>z</I><SUB><I>j</I></SUB> de <I>P</I><SUB><I>k</I></SUB> et à un même contenu
<I>c</I> (puisqu’il y a un nombre fini de combinaisons possibles des
racines en facteur et un nombre fini de diviseurs possibles
du contenu de <I>P</I><SUB><I>k</I></SUB>). Pour <I>z</I> ∈ <I>Z</I>, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I><SUB><I>j</I></SUB>(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I></SUB>,<I>z</I>)=<I>c</I> Π<SUB><I>l</I> ∈ <I>R</I></SUB> (<I>z</I>−<I>z</I><SUB><I>j</I></SUB>),    
<I>f</I><SUB><I>j</I></SUB> ∈ ℤ[<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB>] </TD></TR>
</TABLE><P>
Soit <I>L</I>(<I>X</I>) le polynôme obtenu par interpolation de Lagrange 
en cardinal(<I>R</I>)+1 points <I>z</I> de <I>Z</I>, égal à <I>f</I><SUB><I>j</I></SUB> en <I>X</I>=<I>z</I>.
Pour des raisons de degré, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>L</I>=<I>c</I> Π<SUB><I>l</I> ∈ <I>R</I></SUB> (<I>X</I>−<I>z</I><SUB><I>j</I></SUB>) </TD></TR>
</TABLE><P>
donc <I>L</I> est un facteur de <I>P</I>.
De plus <I>L</I> est un polynôme en <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>−1</SUB>,<I>X</I> à coefficients
rationnels (par construction). Ceci vient en contradiction avec l’hypothèse 
<I>P</I><SUB><I>k</I></SUB> irréductible, car on a construit un facteur de <I>P</I><SUB><I>k</I></SUB> à coefficients
rationnels <I>L</I> de degré strictement inférieur.</P><P><B>Corollaire</B><BR>
Pour <I>z</I> assez grand, la reconstruction <I>z</I>-adique de <I>c</I>(<I>z</I>) <I>p</I><SUB><I>j</I></SUB>(<I>z</I>) est
un polynôme dont la partie primitive est un facteur irréductible de <I>P</I>.</P><P><B>Preuve du corollaire</B><BR>
On prend <I>z</I> assez grand pour que tous les facteurs irréductibles de <I>P</I>
évalués en <I>z</I> aient un seul facteur polynomial (i.e. soient de la forme 
<I>d</I>(<I>z</I>)<I>p</I><SUB><I>j</I></SUB>(<I>z</I>)). Quitte à augmenter <I>z</I>, on peut supposer que 
|<I>z</I>|&gt; 2 <I>C</I> <I>L</I>  où <I>C</I> est la majoration de |<I>c</I>(<I>z</I>)| et <I>L</I> est la borne 
de Landau sur les facteurs de <I>P</I>. Alors la reconstruction <I>z</I>-adique
de <I>c</I>(<I>z</I>)<I>p</I><SUB><I>j</I></SUB>(<I>z</I>) est <I>c</I>(<I>z</I>)/<I>d</I>(<I>z</I>)<I>P</I><SUB><I>j</I></SUB>, donc sa partie primitive est un
facteur irréductible de <I>P</I>.</P><P><B>Algorithme de factorisation heuristique à plusieurs variables</B><BR>
Argument: un polynôme <I>P</I> primitif en au moins 2 variables.<BR>
Valeur renvoyée: les facteurs irréductibles de <I>P</I><BR>
Choisir la variable <I>X</I> par rapport à laquelle <I>P</I> est de plus bas degré puis
factoriser le contenu de <I>P</I> vu comme polynôme à coefficients dans ℤ[<I>X</I>].
Initialiser un entier <I>z</I> à 2|<I>P</I>|+2 (où |<I>P</I>| est le plus grand coefficient 
entier de <I>P</I> en valeur absolue) et une liste <I>L</I> à la factorisation de
du contenu de <I>P</I>.<BR>
Boucle indéfinie :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>P</I>=1 renvoyer la liste <I>L</I> des facteurs de <I>P</I>.
</LI><LI CLASS="li-itemize">Tant que pgcd(<I>P</I>(<I>z</I>),<I>P</I>′(<I>z</I>))=0 incrémenter <I>z</I> de 1.
</LI><LI CLASS="li-itemize">Factoriser <I>P</I>(<I>z</I>)=<I>c</I>(<I>z</I>)Π <I>p</I><SUB><I>j</I></SUB>
</LI><LI CLASS="li-itemize">Pour tous les facteurs <I>p</I><SUB><I>j</I></SUB>, déterminer le polynôme <I>P</I><SUB><I>j</I></SUB> tel que 
<I>c</I>(<I>z</I>)<I>p</I><SUB><I>j</I></SUB>=<I>P</I><SUB><I>j</I></SUB>(<I>z</I>) par remontée
<I>z</I>-adique (avec les coefficients de <I>P</I><SUB><I>j</I></SUB> écrit en représentation
symétrique, de valeur absolue plus petite que |<I>z</I>|/2). Tester si
la partie primitive de <I>P</I><SUB><I>j</I></SUB> divise <I>P</I>. Si oui, rajouter un facteur
irréductible à la liste <I>L</I>, et diviser <I>P</I> par ce facteur.
</LI><LI CLASS="li-itemize">Augmenter <I>z</I>, par exemple remplacer <I>z</I> par la partie entière de
√<SPAN style="text-decoration:overline">2</SPAN><I>z</I>.
</LI></UL><!--TOC subsection Preuve de l’identité de Bézout généralisée-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc145">16.4</A>  Preuve de l’identité de Bézout généralisée</H3><!--SEC END --><P>
Elle se fait par récurrence. Pour <I>n</I>=2, c’est l’identité de Bézout usuelle. 
Pour passer
du rang <I>n</I>−1 au rang <I>n</I>, on isole <I>P</I><SUB><I>n</I></SUB> dans l’identité à résoudre :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Q</I><SUB><I>j</I></SUB> (Π<SUB>1 ≤ <I>k</I> ≤ <I>n</I>−1,<I>k</I>≠ <I>j</I></SUB> <I>P</I><SUB><I>k</I></SUB>) </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><I>P</I><SUB><I>n</I></SUB> + 
<I>Q</I><SUB><I>n</I></SUB> Π<SUB><I>k</I>≤ <I>n</I>−1</SUB> <I>P</I><SUB><I>k</I></SUB> =<I>Q</I> (mod <I>p</I> )</TD></TR>
</TABLE><P>
Comme <I>P</I><SUB><I>n</I></SUB> est premier avec Π<SUB><I>k</I>≤ <I>n</I>−1</SUB> <I>P</I><SUB><I>k</I></SUB>, en appliquant Bézout,
on trouve deux polynômes <I>Q</I><SUB><I>n</I></SUB> et <I>R</I><SUB><I>n</I></SUB> tels que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:Qn"></A>
<I>R</I><SUB><I>n</I></SUB> <I>P</I><SUB><I>n</I></SUB> + <I>Q</I><SUB><I>n</I></SUB> Π<SUB><I>k</I>≤ <I>n</I>−1</SUB> <I>P</I><SUB><I>k</I></SUB> =<I>Q</I> (mod <I>p</I> ) 
    (23)</TD></TR>
</TABLE><P>
Il reste à résoudre
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Q</I><SUB><I>j</I></SUB> Π<SUB>1 ≤ <I>k</I> ≤ <I>n</I>−1,<I>k</I>≠ <I>j</I></SUB> <I>P</I><SUB><I>k</I></SUB>=<I>R</I><SUB><I>n</I></SUB> (mod <I>p</I> )</TD></TR>
</TABLE><P>
ce que l’on peut faire par hypothèse de récurrence.</P><!--TOC subsection Algorithme de Bézout généralisé-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc146">16.5</A>  Algorithme de Bézout généralisé</H3><!--SEC END --><P><A NAME="@default184"></A>
Arguments: une liste <I>P</I><SUB>1</SUB>,...,<I>P</I><SUB><I>n</I></SUB> de polynômes premiers entre eux 2 à 2 
et un polynôme <I>Q</I> à coefficients dans ℤ/<I>p</I>ℤ<BR>
Valeur renvoyée: la liste de polynômes <I>Q</I><SUB>1</SUB>,...,<I>Q</I><SUB><I>n</I></SUB> tels que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Q</I><SUB><I>j</I></SUB> Π<SUB><I>k</I>≠ <I>j</I></SUB> <I>P</I><SUB><I>k</I></SUB>=<I>Q</I> (mod <I>p</I> ) </TD></TR>
</TABLE><P>
On peut commencer par calculer le produit de tous les <I>P</I><SUB><I>k</I></SUB> puis faire une 
boucle sur <I>j</I> pour calculer les produits des <I>P</I><SUB><I>k</I></SUB> pour <I>k</I>≠ <I>j</I> en divisant
le produit complet par <I>P</I><SUB><I>j</I></SUB> (on fait ainsi <I>n</I>−1 multiplications et
<I>n</I> divisions au lieu de <I>n</I>(<I>n</I>−1) multiplications).<BR>
Boucle indéfinie sur <I>n</I> décrémenté de 1 par itération :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>n</I>=2, on rajoute à la liste résultat les polynômes 
<I>Q</I><SUB>1</SUB> et <I>Q</I><SUB>2</SUB> de l’algorithme de Bézout usuel et on renvoie la liste
</LI><LI CLASS="li-itemize">Sinon, on calcule les polynômes <I>R</I><SUB><I>n</I></SUB> et <I>Q</I><SUB><I>n</I></SUB> vérifiant (<A HREF="#eq:Qn">23</A>),
on rajoute <I>Q</I><SUB><I>n</I></SUB> en début de liste, on remplace <I>Q</I> par <I>R</I><SUB><I>n</I></SUB>.
</LI></UL><P>
Remarquons que lorsque nous utiliserons cet algorithme, <I>Q</I> sera la différence
entre deux polynômes de même degré (le degré de <I>P</I>) et de même coefficient
dominant 1, on peut donc
remplacer les <I>Q</I><SUB><I>i</I></SUB> par le reste euclidien de <I>Q</I><SUB><I>i</I></SUB> par <I>P</I><SUB><I>i</I></SUB> sans
changer l’égalité.</P><!--TOC subsection Factorisation rationnelle et sur une extension-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc147">16.6</A>  Factorisation rationnelle et sur une extension</H3><!--SEC END --><P>
<A NAME="sec:factorisation_extension"></A>
<A NAME="@default185"></A> <A NAME="@default186"></A><A NAME="@default187"></A> 
Pour factoriser des polynômes ayant des coefficients dans des
extensions algébriques, il existe un algorithme assez simple, 
l’algorithme de Trager, qui n’est pas forcément le plus performant 
(la recherche est encore active dans ce domaine), cf. le livre de 
Henri Cohen pp. 142-144. Cet algorithme est utilisé lorsqu’on
met l’extension algébrique en deuxième argument de <CODE>factor</CODE>
dans Xcas. Pour trouver l’extension algébrique qui permet de
factoriser, on peut dans les cas simples essayer <CODE>solve</CODE>. Si
le polynôme <I>P</I> à factoriser est irréductible sur ℚ, 
on peut essayer <CODE>factor(P,rootof(P))</CODE>. Mais en général
cela ne permettra d’extraire qu’un seul facteur de degré 1. Pour
obtenir une décomposition complète si <I>P</I> est de petit
degré, on peut essayer de construire une extension en
formant une expression non symétrique à partir des racines approchées,
puis en appliquant toutes les permutations de racines à cette
expression et en construisant le polynôme ayant ces racines,
si on a suffisamment de précision sur les racines, on peut arrondir
le polynôme obtenu, le factoriser sur ℚ, et prendre un des
facteurs irréductibles de degré suffisant comme argument de
<CODE>rootof</CODE>.</P><P>Par exemple soit à factoriser <I>P</I>=<I>x</I><SUP>4</SUP>+3<I>x</I>+1 sur <SPAN style="text-decoration:overline">ℚ</SPAN>.
On entre la fonction suivante :
</P><PRE CLASS="verbatim">f(P):={
  local k,l,p,r,j;
  l:=proot(P);
  if (dim(l)!=4) return "erreur";
  k:=max(abs(l));
  k:=floor(24*log10(1+4*k))+4; // 4 chiffres de precision en plus
  l:=proot(P,k);
  p:=[0,1,2,3];
  r:=[];
  for j from 0 to 23 do
    k:=l[p[0]]-l[p[1]]+2*l[p[2]];
    r:=append(r,k);
    p:=nextperm(p);
  od;
  retourne r;
}:;
</PRE><P>puis <CODE>q:=pcoef(f(x^4+3x+1))</CODE>, on voit que les
coefficients sont presque entiers, on fait donc
<CODE>factor(x^4+3x+1,rootof(round(q)))</CODE>
qui décompose <I>x</I><SUP>4</SUP>+3<I>x</I>+1 en 4 facteurs de degré 1. Le polynôme
obtenu est de degré 24 (cas générique), si <I>P</I> est de degré
<I>n</I>, on s’attend à un degré <I>n</I>!, au-delà de <I>n</I>=5, cette
méthode est trop couteuse! Attention aussi, même pour <I>n</I>=4, il peut être
nécessaire de calculer les racines en multi-précision, 
par exemple ci-dessus les éléments
de <CODE>r</CODE> sont majorés par 4<I>R</I> où <I>R</I> est un majorant du module 
des racines de <I>P</I>, donc
les coefficients de <CODE>q</CODE> sont majorés par exemple par (1+4<I>R</I>)<SUP>24</SUP>
≈ 2<I>e</I>20 donc on prend 24 chiffres.</P><P>Autre méthode plus efficace utilisant la représentation rationnelle
univariée (section <A HREF="#sec:rur">7.8</A>) : 
on écrit le système vérifié par les relations
racines-coefficients, ici<BR>
<CODE>P:=x^4+3x+1;eq:=lcoeff(P)*pcoef([a,b,c,d])-symb2poly(P)</CODE><BR>
on vérifie qu’on obtient les 24 permutations de racines par<BR>
<CODE>cfsolve(eq,[a,b,c,d])</CODE><BR>
Le polynôme permettant de factoriser complètement <I>P</I> se lit dans<BR>
<CODE>G:=gbasis(eq,[a,b,c,d],rur);</CODE><BR>
on obtient la factorisation complète par :<BR>
<CODE>factor(x^4+3x+1,rootof(G[2]))</CODE><BR>
On peut aussi la déduire de l’expressions des racines<BR>
<CODE>Q:=product(x-rootof(G[k],G[2])/rootof(G[3],G[2]),</CODE><BR>
<CODE>   k,4,size(G)-1);normal(Q)</CODE></P><!--TOC subsection Factorisation absolue-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc148">16.7</A>  Factorisation absolue</H3><!--SEC END --><P><A NAME="@default188"></A> <A NAME="sec:factorisation_absolue"></A>
On peut aussi se demander pour un polynôme à coefficients
rationnels (squarefree) quelle extension<A NAME="@default189"></A><A NAME="@default190"></A> 
permet la factorisation la plus
complète. Par exemple <I>x</I><SUP>2</SUP>+<I>y</I><SUP>2</SUP> est irréductible sur ℚ[<I>x</I>,<I>y</I>]
mais pas sur ℚ[<I>i</I>][<I>x</I>,<I>y</I>] ou <I>x</I><SUP>4</SUP>+<I>y</I><SUP>4</SUP> est irréductible sur ℚ[<I>x</I>,<I>y</I>]
mais pas sur ℚ[√<SPAN style="text-decoration:overline">2</SPAN>][<I>x</I>,<I>y</I>]. Ceci amène à la notion
de <EM>factorisation absolue</EM> d’un polynôme. Une méthode simple
(mais pas forcément très efficace) pour déterminer une telle
extension algébrique consiste à évaluer toutes les variables
sauf une “au hasard" jusqu’à obtenir un polynôme irréductible <I>M</I>.
On factorise alors sur le corps correspondant à <I>M</I>. Mais cela
peut être très long, par exemple pour 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>x</I>,<I>y</I>)=<I>y</I><SUP>10</SUP>−2<I>x</I><SUP>2</SUP><I>y</I><SUP>4</SUP>+4<I>x</I><SUP>6</SUP><I>y</I><SUP>2</SUP>−2<I>x</I><SUP>10</SUP></TD></TR>
</TABLE><P>
on a <I>P</I>(<I>x</I>,1) irréductible, on obtient donc la factorisation
absolue par les commande<BR>
<CODE>p(x,y):=y^10-2x^2*y^4+4x^6*y^2-2x^10;</CODE><BR>
<CODE>p1:=p(1,y); factor(p1);</CODE> (vérification)<BR>
<CODE>factor(p(x,y),rootof(p1));</CODE><BR>
mais c’est beaucoup plus long que de faire <CODE>factor(p1,sqrt(2))</CODE>.</P><P>Pour un polynôme à 2 variables (on peut toujours s’y ramener) de
degrés partiels <I>m</I>,<I>n</I> en <I>x</I>,<I>y</I>,
on remarque que le degré <I>q</I> ≥ 2 de l’extension nécessaire est
égal au nombre de facteurs (chaque facteur étant conjugué d’un
facteur donné par échange des racines), qui sont donc tous de même
bi-degré <I>m</I>/<I>q</I>,<I>n</I>/<I>q</I>, en particulier <I>q</I> divise le PGCD de <I>m</I> et <I>n</I>
qui doit être non trivial. Ainsi par exemple pour 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>X</I>,<I>Y</I>)=<I>Y</I><SUP>4</SUP> +2<I>Y</I><SUP>2</SUP>*<I>X</I>+14<I>Y</I><SUP>2</SUP> −7*<I>X</I><SUP>2</SUP> +6<I>X</I>+47</TD></TR>
</TABLE><P>
<I>m</I>=2 donc <I>q</I> ne peut être égal qu’à 2, en faisant <I>Y</I>=0 on
obtient que la seule extension possible est √<SPAN style="text-decoration:overline">2</SPAN>.</P><P>Voir aussi la session <CODE>afactor.xws</CODE> du menu Exemple, poly de Xcas.</P><!--TOC subsection Compléments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc149">16.8</A>  Compléments</H3><!--SEC END --><P>
Pour factoriser sur des corps finis, on peut consulter la thèse
de Bernardin disponible sur le web (<CODE>http://www.bernardin.lu</CODE>).</P><P>On peut aussi consulter le code source de Mupad, les routines
de factorisation se trouvent dans le répertoire <CODE>lib/POLYLIB/FACLIB</CODE>
après avoir désarchivé la <CODE>lib.tar</CODE>. Le point d’entrée pour factoriser
des polynômes à plusieurs variables sur ℤ est le fichier 
<CODE>mfactor.mu</CODE>, on observera que l’algorithme utilisé par Mupad est
assez différent de celui qu’on a détaillé dans la section précédente.</P><!--TOC subsection Exercices (factorisation des polynômes)-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc150">16.9</A>  Exercices (factorisation des polynômes)</H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Déterminer le nombre de racines de −<I>x</I><SUP>7</SUP>+<I>x</I><SUP>4</SUP>+12<I>x</I>−5 comprises
entre 0 et 6 (en utilisant les suites de Sturm, on donnera les
détails des calculs).
</LI><LI CLASS="li-enumerate">Écrire un programme calculant la suite de Sturm d’un polynôme
supposé squarefree (on peut tester avec <CODE>sqrfree</CODE>), en utilisant
l’algorithme d’Euclide.
</LI><LI CLASS="li-enumerate">Prendre un polynôme de degré 100 à coefficients
aléatoires (<CODE>randpoly</CODE>), le factoriser numériquement
(<CODE>proot</CODE>) puis donner pour les premières racines
approchées renvoyées des intervalles ou disques où
on peut certifier qu’il existe une racine.
</LI><LI CLASS="li-enumerate">Calculer avec un logiciel les valeurs numériques des racines
complexes de <I>P</I>(<I>x</I>)=<I>x</I><SUP>5</SUP>+<I>x</I>+1. Trouver les combinaisons de racines
dont la somme est entière (aux arrondis près). En déduire la factorisation
en facteurs irréductibles sur ℤ de <I>P</I>.
</LI><LI CLASS="li-enumerate">Factorisation numérique sur ℂ. Écrire un programme
qui calcule une racine d’un polynôme à coefficients complexes
en utilisant une méthode itérative de type méthode de Newton 
(avec éventuellement un préfacteur lorsqu’on débute la recherche).
Les polynômes seront représentés par la liste de leurs coefficients
et l’évaluation faite par la méthode de Horner.
Trouver ensuite toutes les racines du polynôme en éliminant la
racine trouvée (toujours avec Horner). Trouver les combinaisons
de racines correspondant à un facteur à coefficients entiers.
</LI><LI CLASS="li-enumerate">Soit <I>p</I> un entier premier et <I>P</I> un polynôme à
coefficients dans ℤ/<I>p</I>ℤ. On a la relation
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>gcd</I>(<I>X</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>−<I>X</I>,<I>P</I>) = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"> <I>f</I> | <I>P</I>, deg(<I>f</I>) | <I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>, 
   <I>f</I>  irréductible </TD></TR>
</TABLE>
En utilisant cette relation, 
déterminer les degrés des facteurs de 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>x</I><SUP>3</SUP>+<I>x</I>+1)(<I>x</I><SUP>4</SUP>+<I>x</I>+1) </TD></TR>
</TABLE>
modulo 5 et 7 (sans utiliser la commande factor). 
Peut-on en déduire que <I>x</I><SUP>3</SUP>+<I>x</I>+1 et
<I>x</I><SUP>4</SUP>+<I>x</I>+1 sont irréductibles sur ℤ?
</LI><LI CLASS="li-enumerate">Utiliser les options “verbose” de votre logiciel de calcul formel
pour factoriser <I>x</I><SUP>202</SUP>+<I>x</I><SUP>101</SUP>+1 et vérifiez que vous avez compris
la méthode utilisée.
</LI><LI CLASS="li-enumerate">Trouver les facteurs de degré 1 s’ils existent de
3<I>x</I><SUP>5</SUP>+25<I>x</I><SUP>4</SUP>+67<I>x</I><SUP>3</SUP>+77<I>x</I><SUP>2</SUP>+55<I>x</I>+13 en remontant ses racines
dans ℤ/<I>pZ</I>[<I>X</I>] pour <I>p</I> premier bien choisi.
</LI><LI CLASS="li-enumerate">Factoriser le polynôme <I>x</I><SUP>5</SUP>+<I>x</I>+1 par la méthode 
de Berlekamp.
</LI><LI CLASS="li-enumerate">Montrer que 2<I>x</I>+<I>x</I><SUP>2</SUP><I>y</I>+<I>x</I><SUP>3</SUP>+2<I>x</I><SUP>4</SUP>+<I>y</I><SUP>3</SUP>+<I>x</I><SUP>5</SUP> est irréductible sur ℤ
sans utiliser l’instruction factor à 2 variables (on pourra factoriser 
pour quelques valeurs de <I>x</I> ou de <I>y</I>)</LI><LI CLASS="li-enumerate">Que se passe-t-il lorsqu’on exécute l’algorithme de Yun
dans ℤ/<I>n</I>ℤ?
</LI><LI CLASS="li-enumerate">Recherche des facteurs de degré 2 d’un polynôme à coefficients
réels sans racines réelles en utilisant la méthode de Bairstow décrite
ci-dessous.<BR>
On cherche un facteur <I>F</I>=<I>x</I><SUP>2</SUP>+<I>sx</I>+<I>p</I> de <I>P</I>, on calcule le quotient et le reste
de la division <I>P</I>=<I>FQ</I>+<I>R</I> par une méthode de type Horner, il s’agit de 
rendre <I>R</I> (vu comme un vecteur à 2 composantes) nul. On calcule
donc ∂<SUB><I>s</I>,<I>p</I></SUB> <I>R</I> (en cherchant le quotient et le reste
de <I>xQ</I> et <I>Q</I> par <I>F</I>, pourquoi?) et on pose :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>s</I>,<I>p</I>)<SUB><I>n</I>+1</SUB>=(<I>s</I>,<I>p</I>)<SUB><I>n</I></SUB>− λ (∂<SUB><I>s</I>,<I>p</I></SUB> <I>R</I>)<SUP>−1</SUP> <I>R</I> (<I>s</I>,<I>p</I>)<SUB><I>n</I></SUB></TD></TR>
</TABLE>
où λ est un préfacteur compris entre 0 et 1 et ajusté à 1 
lorsqu’on est proche du facteur.</LI></OL><!--TOC section Intégration formelle.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc151">17</A>  Intégration formelle.</H2><!--SEC END --><P><A NAME="sec:intg"></A><A NAME="@default191"></A> <A NAME="@default192"></A>
</P><!--TOC subsection Introduction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc152">17.1</A>  Introduction</H3><!--SEC END --><P>
Que peut-on espérer d’un système de calcul formel lorsqu’il s’agit
de calculer une primitive? Tout d’abord, on peut espérer qu’il
sache résoudre ce que l’on donne en exercice à nos étudiants!
Ceci suppose donc de connaitre quelques méthodes classiques, par
exemple: intégration de polynômes (!), polynômes multipliés par exponentielle
ou/et fonctions trigonométriques, de polynômes trigonométriques par
linéarisation, de fractions rationnelles,
de fractions trigonométriques, de fractions de racines carrées de 
polynômes du second ordre, de fonctions s’y ramenant par une ou plusieurs
intégrations par parties ou par
changement de fonction (par exemple reconnaissance de formes <I>F</I>(<I>u</I>)<I>u</I>′ )
ou par changement de variables, etc.</P><P>Mais au-delà de ces méthodes (qui ont l’avantage de la rapidité mais
tiennent parfois plus de la
recette de cuisine que de l’algorithme...), on peut se demander 
si la primitive d’une fonction donnée peut ou non s’exprimer en terme 
des fonctions “élémentaires”. Par exemple, tout le monde “sait”
que la fonction <I>e</I><SUP><I>x</I><SUP>2</SUP></SUP> n’admet pas de primitive “simple”, encore
faut-il donner un sens mathématique précis à cette affirmation.
Ceci nécessite de donner une définition rigoureuse du terme fonction
élémentaire. On peut alors appliquer un algorithme développé
par Risch (pour les extensions dites transcendantes, obtenue par ajout
des fonctions exponentielle et logarithme) 
qui permet de répondre à la question :
il s’agit vu de très loin d’une extension de l’algorithme d’intégration
des fractions rationnelles.</P><P>Cet article se décompose en deux parties principales :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
la section <A HREF="#sec:elem">17.2</A> présente les définitions de fonctions
élémentaires, de tour de variables, et donne deux théorèmes,
le théorème de structure de Risch qui permet d’écrire une fonction 
contenant des exponentielles et des logarithmes comme une fonction 
élémentaire par rapport à une tour de variable, et 
le théorème de Liouville qui donne la forme que peut prendre
une primitive d’une fonction élémentaire lorsqu’elle est aussi élémentaire.
</LI><LI CLASS="li-itemize">la section <A HREF="#sec:risch">17.3</A> décrit l’algorithme d’intégration de Risch
permettant de décider si une fonction élémentaire donnée possède
ou non une primitive élémentaire et de la calculer dans le premier
cas. Nous ne présentons ici l’algorithme de Risch que pour les extensions
transcendantes pures (ln et exp).
</LI></UL><P>
Le lecteur intéressé par le cas des extensions algébriques 
pourra consulter la thèse de Trager. Pour les extensions
plus générales (incluant en particulier les fonctions
tangente, arctangente), la référence est le livre de Bronstein 
donnée en section <A HREF="#sec:rischref">17.4</A>.</P><!--TOC subsection Fonctions élémentaires-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc153">17.2</A>  Fonctions élémentaires</H3><!--SEC END --><P> <A NAME="sec:elem"></A></P><!--TOC subsubsection Extensions transcendantes, tour de variables-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc154">17.2.1</A>  Extensions transcendantes, tour de variables</H4><!--SEC END --><P>
On se donne une expression <I>f</I>(<I>x</I>) dépendant de la variable <I>x</I> que l’on 
souhaite intégrer par rapport à <I>x</I>. L’algorithme de Risch s’applique à
cette expression si on peut l’écrire comme une fraction rationnelle à
plusieurs variables algébriquement indépendantes
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>, <I>f</I><SUB>1</SUB>(<I>x</I>), <I>f</I><SUB>2</SUB>(<I>x</I>,<I>f</I><SUB>1</SUB>(<I>x</I>)), ..., 
<I>f</I><SUB><I>n</I></SUB>(<I>x</I>,<I>f</I><SUB>1</SUB>(<I>x</I>),<I>f</I><SUB>2</SUB>(<I>x</I>,<I>f</I><SUB>1</SUB>(<I>x</I>)),...,<I>f</I><SUB><I>n</I>−1</SUB>(<I>x</I>,<I>f</I><SUB>1</SUB>(<I>x</I>),...,<I>f</I><SUB><I>n</I>−2</SUB>(<I>x</I>))) </TD></TR>
</TABLE><P>
où les <I>f</I><SUB><I>i</I></SUB> sont soit l’exponentielle soit le logarithme d’une fraction
rationnelle (le corps de base appelé aussi corps de
constantes ici est soit ℂ, soit une extension algébrique de ℚ ou une
extension algébrique d’un corps de fractions rationnelles s’il
y a des paramètres). 
On appelle tour de variables
la suite des <I>x</I>,<I>f</I><SUB>1</SUB>,...,<I>f</I><SUB><I>n</I></SUB> (chaque étage est donc une exponentielle
d’une fraction rationnelle ou le logarithme d’une fraction rationnelle
dépendant des étages précédents) 
et on dira que <I>f</I> est une fonction élémentaire
par rapport à cette tour de variables.</P><P>L’intérêt de l’écriture d’une expression sous forme de tour est 
qu’elle est stable par dérivation : 
si on dérive par rapport à <I>x</I>
une fonction élémentaire dépendant d’une tour de variables, on obtient encore 
une fonction élémentaire dépendant de la même tour de variables.
Autrement dit, l’ensemble des fonctions élémentaires pour une tour 
fixée est un corps différentiel.</P><P><B>Exemples: </B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<I>e</I><SUP><I>x</I><SUP>2</SUP></SUP> est bien dans ce cas, pour <I>n</I>=1, <I>f</I><SUB>1</SUB>
est l’exponentielle de <I>x</I><SUP>2</SUP> qui est algébriquement indépendant
de <I>x</I>. Les fonctions (2<I>x</I><SUP>2</SUP>−1)<I>e</I><SUP><I>x</I><SUP>2</SUP></SUP>
ou <I>x</I>/(<I>e</I><SUP><I>x</I><SUP>2</SUP></SUP>−1) sont aussi élémentaires par rapport à
la tour de variables {<I>x</I>,<I>e</I><SUP><I>x</I><SUP>2</SUP></SUP> }. 
</LI><LI CLASS="li-itemize"><I>x</I> ln(<I>x</I>) exp(<I>x</I>) est élémentaire par rapport à la tour
{ <I>x</I>, ln(<I>x</I>), exp(<I>x</I>)}, mais aussi par rapport à la tour
{ <I>x</I>, exp(<I>x</I>), ln(<I>x</I>)}.
</LI><LI CLASS="li-itemize"><I>xe</I><SUP><I>x</I> ln(<I>x</I>)</SUP> est élémentaire, en prenant <I>n</I>=2, <I>f</I><SUB>1</SUB>=ln(<I>x</I>)
et <I>f</I><SUB>2</SUB>=<I>e</I><SUP><I>x</I> <I>f</I><SUB>1</SUB></SUP>.
</LI><LI CLASS="li-itemize"><I>x</I><SUP><I>n</I></SUP>=<I>e</I><SUP><I>n</I>ln(<I>x</I>)</SUP>, où <I>n</I> est un paramètre, convient avec
comme tour {<I>x</I>, ln(<I>x</I>), <I>e</I><SUP><I>n</I> ln(<I>x</I>) </SUP>
</LI><LI CLASS="li-itemize"><I>e</I><SUP>ln(<I>x</I>)</SUP> ne convient pas car il n’est pas algébriquement
indépendant de <I>x</I>,ln(<I>x</I>) mais on peut le réécrire sous une forme
acceptable puisque <I>e</I><SUP>ln(<I>x</I>)</SUP>=<I>x</I>.
</LI><LI CLASS="li-itemize"><I>e</I><SUP>ln(<I>x</I>)/2</SUP> ne convient pas non plus car son carré est égal à <I>x</I>.
Une réécriture ne suffit pas, cet exemple est bien sûr une extension
algébrique et non transcendante.
</LI></UL><P>Dans la suite, on va s’intéresser aux tours de variables dans lesquelles 
on a effectué des simplifications évidentes.
On élimine les ln∘ exp de la manière suivante :
si <I>f</I><SUB><I>k</I></SUB>=ln(<I>g</I><SUB><I>k</I></SUB>), on regarde si <I>g</I><SUB><I>k</I></SUB> vu comme fraction 
en <I>f</I><SUB>1</SUB>,...,<I>f</I><SUB><I>k</I>−1</SUB> possède un facteur <I>f</I><SUB><I>j</I></SUB><SUP><I>m</I></SUP> (avec <I>m</I> ∈ ℤ)
lorsque <I>f</I><SUB><I>j</I></SUB>=exp(<I>g</I><SUB><I>j</I></SUB>) est une exponentielle.
Si c’est le cas, on a <I>f</I><SUB><I>k</I></SUB>= <I>m</I> <I>g</I><SUB><I>j</I></SUB> + ln(<I>g</I><SUB><I>k</I></SUB>/<I>g</I><SUB><I>j</I></SUB><SUP><I>m</I></SUP>). On change
alors de tour en remplaçant <I>f</I><SUB><I>k</I></SUB> par f<SUB><I>k</I></SUB>=ln(<I>g</I><SUB><I>k</I></SUB>/<I>g</I><SUB><I>j</I></SUB><SUP><I>m</I></SUP>)=<I>f</I><SUB><I>k</I></SUB>−<I>mg</I><SUB><I>j</I></SUB>.
On élimine aussi les exp∘ ln, si
<I>f</I><SUB><I>k</I></SUB>=exp(<I>g</I><SUB><I>k</I></SUB>), pour <I>j</I>&lt;<I>k</I> si <I>f</I><SUB><I>j</I></SUB> est un logarithme,
on regarde si <I>c</I><SUB><I>j</I></SUB>=∂<SUB><I>f</I><SUB><I>j</I></SUB></SUB><I>g</I><SUB><I>k</I></SUB>|<SUB><I>f</I><SUB><I>j</I></SUB>=0</SUB> est un entier, si
c’est le cas on remplace <I>f</I><SUB><I>k</I></SUB> par f<SUB><I>k</I></SUB>=<I>f</I><SUB><I>k</I></SUB>/<I>g</I><SUB><I>k</I></SUB><SUP><I>c</I><SUB><I>j</I></SUB></SUP>.</P><P><B>Exemples: </B>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> ln(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP><I>x</I><SUP>2</SUP></SUP>+1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP><I>x</I><SUP>2</SUP></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>→</TD><TD ALIGN=left NOWRAP>−<I>x</I><SUP>2</SUP> + ln(<I>e</I><SUP><I>x</I><SUP>2</SUP></SUP>+1) </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>e</I><SUP>3 ln(<I>x</I>)+ln(<I>x</I>)<SUP>2</SUP>+5</SUP></TD><TD ALIGN=center NOWRAP>→</TD><TD ALIGN=left NOWRAP><I>x</I><SUP>3</SUP> <I>e</I><SUP>ln(<I>x</I>)<SUP>2</SUP>+5</SUP> </TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsubsection Théorème de structure de Risch-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc155">17.2.2</A>  Théorème de structure de Risch</H4><!--SEC END --><P>
On voit donc qu’il est nécessaire de disposer d’un algorithme
pour décider si des exponentielles et logarithmes sont
algébriquement indépendants. Cet algorithme est basé sur
un théorème de structure dû à Risch :
</P><DIV CLASS="theorem"><B>Théorème 31</B>  <EM>
Soit </EM><EM><I>f</I>=</EM><EM>ln</EM><EM>(<I>g</I>(<I>x</I>))</EM><EM> le logarithme d’une fonction élémentaire
</EM><EM><I>g</I></EM><EM> par rapport à une tour de variables </EM><EM><I>T</I></EM><EM>, alors soit </EM><EM><I>f</I></EM><EM>
est algébriquement indépendant des variables de </EM><EM><I>T</I></EM><EM>, soit </EM><EM><I>f</I></EM><EM> est
élémentaire et plus précisément combinaison linéaire rationnelle
des logarithmes et des arguments des exponentielles de la tour </EM><EM><I>T</I></EM><EM>.</EM><P><EM>Soit </EM><EM><I>f</I>=</EM><EM>exp</EM><EM>(<I>g</I>)</EM><EM> l’exponentielle d’une fonction élémentaire </EM><EM><I>g</I></EM><EM>
par rapport à une tour de variables </EM><EM><I>T</I></EM><EM>, alors soit </EM><EM><I>f</I></EM><EM>
est algébriquement indépendante des variables de </EM><EM><I>T</I></EM><EM>, soit
il existe </EM><EM><I>n</I></EM><EM> tel que </EM><EM><I>f</I></EM><SUP><EM><I>n</I></EM></SUP><EM> soit élémentaire par rapport à </EM><EM><I>T</I></EM><EM> 
(on peut alors appliquer le cas précédent à </EM><EM><I>ng</I>=</EM><EM>ln</EM><EM>(<I>f</I></EM><SUP><EM><I>n</I></EM></SUP><EM>)</EM><EM>)
</EM></P></DIV><P><B>Démonstration</B> :<BR>
Commençons par le cas de l’exponentielle. On considère le polynôme minimal
de <I>f</I>=exp(<I>g</I>) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>n</I></SUB> <I>f</I><SUP><I>n</I></SUP>+...+<I>a</I><SUB>0</SUB>=0,    <I>a</I><SUB><I>n</I></SUB> ≠ 0 , <I>a</I><SUB>0</SUB> ≠ 0</TD></TR>
</TABLE><P>
où les <I>a</I><SUB><I>i</I></SUB> sont des fractions rationnelles en <I>T</I>. On dérive
et on applique <I>f</I>′=<I>g</I>′<I>f</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>a</I><SUB><I>n</I></SUB>′+<I>n</I> <I>a</I><SUB><I>n</I></SUB> <I>g</I>′) <I>f</I><SUP><I>n</I></SUP> +   ... + ( <I>a</I><SUB><I>k</I></SUB>′ + <I>ka</I><SUB><I>k</I></SUB> <I>g</I>′)<I>f</I><SUP><I>k</I></SUP> +... =0</TD></TR>
</TABLE><P>
c’est un multiple du polynôme minimal donc il existe une fraction rationnelle
<I>C</I> (par rapport à la tour de variables) telle que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">∀ <I>k</I>,    (<I>a</I><SUB><I>k</I></SUB>′+<I>k</I> <I>a</I><SUB><I>k</I></SUB> <I>g</I>′) = <I>C</I> <I>a</I><SUB><I>k</I></SUB></TD></TR>
</TABLE><P>
Comme <I>a</I><SUB><I>n</I></SUB>≠ 0, cela entraine <I>a</I><SUB><I>n</I></SUB>′/<I>a</I><SUB><I>n</I></SUB>+<I>ng</I>′=<I>C</I>. Le coefficient
constant <I>a</I><SUB>0</SUB> est aussi non nul, donc <I>a</I><SUB>0</SUB>′/<I>a</I><SUB>0</SUB>=<I>C</I> et 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>n</I> <I>g</I>′ = <I>a</I><SUB>0</SUB>′/<I>a</I><SUB>0</SUB> − <I>a</I><SUB><I>n</I></SUB>′/<I>a</I><SUB><I>n</I></SUB> ⇒ <I>ng</I>=ln(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUB>0</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">) + <I>k</I></TD></TR>
</TABLE><P>
où <I>k</I> est constant, donc <I>f</I><SUP><I>n</I></SUP>=exp(<I>ng</I>)=<I>e</I><SUP><I>k</I></SUP> <I>a</I><SUB>0</SUB>/<I>a</I><SUB><I>n</I></SUB> est élémentaire.</P><P>Passons au cas du logarithme, supposons que <I>f</I>=ln(<I>g</I>) dépende
algébriquement de la tour <I>T</I>, on va commencer par montrer que
<I>f</I> est élémentaire. On écrit :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>n</I></SUB> <I>f</I><SUP><I>n</I></SUP>+...+<I>a</I><SUB>0</SUB>=0</TD></TR>
</TABLE><P>
où les <I>a</I><SUB><I>i</I></SUB> sont des fractions rationnelles en <I>T</I>. On dérive en
appliquant <I>f</I>′=<I>g</I>′/<I>g</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>n</I></SUB>′ <I>f</I><SUP><I>n</I></SUP> + (<I>n</I> <I>a</I><SUB><I>n</I></SUB> <I>f</I>′ + <I>a</I><SUB><I>n</I>−1</SUB>′)<I>f</I><SUP><I>n</I>−1</SUP>  ... + <I>a</I><SUB>1</SUB> <I>f</I>′+<I>a</I><SUB>0</SUB> ′</TD></TR>
</TABLE><P>
Comme <I>f</I>′ est une fraction rationnelle en <I>T</I>, le polynôme
<I>a</I><SUB><I>n</I></SUB>′ <I>X</I><SUP><I>n</I></SUP> + (<I>n</I> <I>a</I><SUB><I>n</I></SUB> <I>f</I>′+<I>a</I><SUB><I>n</I>−1</SUB>′) <I>X</I><SUP><I>n</I>−1</SUP>+...+ <I>a</I><SUB>1</SUB> <I>f</I>′+<I>a</I><SUB>0</SUB>′ qui annule <I>f</I>
doit être un multiple du polynôme minimal de <I>f</I>, il existe donc
une fraction rationnelle <I>C</I> par rapport à <I>T</I> telle que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>n</I></SUB>′ = <I>C</I> <I>a</I><SUB><I>n</I></SUB>    (<I>n</I> <I>a</I><SUB><I>n</I></SUB> <I>f</I>′+<I>a</I><SUB><I>n</I>−1</SUB>′) = <I>C</I> <I>a</I><SUB><I>n</I>−1</SUB>    ... </TD></TR>
</TABLE><P>
On en déduit <I>f</I>′ :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>′=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUB><I>n</I></SUB>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUB><I>n</I>−1</SUB>−<I>a</I><SUB><I>n</I>−1</SUB>′</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I> <I>a</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = 
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−<I>a</I><SUB><I>n</I>−1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I> <I>a</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">′</TD></TR>
</TABLE><P>
donc il existe une constante <I>c</I> telle que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−<I>a</I><SUB><I>n</I>−1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I> <I>a</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">+<I>c</I></TD></TR>
</TABLE><P>
donc <I>f</I> est élémentaire par rapport à la même tour <I>T</I> que <I>g</I>.</P><P>Montrons maintenant qu’un logarithme <I>f</I>=ln(<I>g</I>) qui est élémentaire
par rapport à une tour de variable <I>T</I> est combinaison linéaire à
coefficients rationnelles des logarithmes et des arguments
des exponentielles de <I>T</I><SUP><A NAME="text27" HREF="#note27">27</A></SUP>.
Soit <I>X</I> la dernière variable de la tour <I>T</I>.
On factorise maintenant le numérateur et le dénominateur de <I>g</I> en
∏<SUB><I>j</I></SUB> <I>P</I><SUB><I>j</I></SUB><SUP><I>j</I></SUP> où les <I>P</I><SUB><I>j</I></SUB> sont sans facteurs multiples et 
premiers entre eux 2 à 2 (par rapport à <I>X</I>), il existe
<I>C</I> indépendant de <I>X</I> tel que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:g"></A>
<I>g</I>=<I>C</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> ∈ ℤ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>P</I><SUB><I>j</I></SUB><SUP><I>j</I></SUP> ⇒ 
ln(<I>g</I>)=ln(<I>C</I>)+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> ∈ ℤ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>j</I> ln(<I>P</I><SUB><I>j</I></SUB>)
    (24)</TD></TR>
</TABLE><P>
Alors <I>f</I>′=ln(<I>C</I>)′+∑<SUB><I>j</I></SUB> <I>j</I> <I>P</I><SUB><I>j</I></SUB>′/<I>P</I><SUB><I>j</I></SUB> donc ∏<I>P</I><SUB><I>j</I></SUB> <I>f</I>′ est un 
polynôme en <I>X</I>. 
Soit <I>N</I>/<I>D</I> la fraction irréductible représentant <I>f</I>, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>′=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>′ <I>D</I> −<I>N</I> <I>D</I>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
on vient donc de montrer que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:prodpj"></A>
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>P</I><SUB><I>j</I></SUB> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>′ <I>D</I> − <I>N</I> <I>D</I>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
 est un polynôme en <I>X</I>
    (25)</TD></TR>
</TABLE><P>
Soit <I>P</I> un facteur irréductible de <I>D</I> de multiplicité
<I>k</I> tel que <I>D</I>=<I>P</I><SUP><I>k</I></SUP> <I>Q</I> (donc <I>P</I> premier avec <I>Q</I>, mais <I>P</I> est aussi
premier avec <I>N</I> car <I>f</I>=<I>N</I>/<I>D</I> est irréductible). Alors en simplifiant
numérateur et dénominateur par <I>P</I><SUP><I>k</I>−1</SUP>, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:estpolynome"></A>
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>P</I><SUB><I>j</I></SUB> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>′ <I>P</I> <I>Q</I> − <I>N</I> (<I>kP</I>′<I>Q</I>+<I>PQ</I>′)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"> <I>P</I><SUP><I>k</I>+1</SUP> <I>Q</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
 est un polynôme en <I>X</I>. 
    (26)</TD></TR>
</TABLE><P>
On en déduit, après simplification d’au plus un facteur <I>P</I> au dénominateur 
avec l’un des <I>P</I><SUB><I>j</I></SUB>, que <I>P</I><SUP><I>k</I></SUP> divise 
<I>N</I>′ <I>P</I> <I>Q</I> − <I>N</I> (<I>kP</I>′<I>Q</I>+<I>PQ</I>′) donc <I>P</I> divise <I>P</I>′. Ceci n’est possible
que si <I>P</I>=1 (et donc le dénominateur de <I>f</I> est égal à 1) 
ou si la variable <I>X</I> est une exponentielle et <I>P</I>=<I>X</I>.</P><P>Montrons que ce deuxième cas est en fait exclus:
en effet si <I>P</I>=<I>X</I>=exp(<I>Y</I>) est une exponentielle, on a alors 
<I>D</I>=<I>X</I><SUP><I>k</I></SUP> et <I>Q</I>=1.
Comme <I>P</I>′=<I>Y</I>′<I>X</I>, (<A HREF="#eq:estpolynome">26</A>) devient :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>P</I><SUB><I>j</I></SUB> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>X</I> (<I>N</I>′ − <I>k</I> <I>N</I> <I>Y</I>′ )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>X</I><SUP><I>k</I>+1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
 est un polynôme en <I>X</I> </TD></TR>
</TABLE><P>
Comme <I>X</I> ne divise pas <I>N</I>, <I>N</I> possède donc un coefficient constant 
<I>a</I><SUB>0</SUB> non nul. Le coefficient constant de <I>N</I>′−<I>kNY</I>′ est <I>a</I><SUB>0</SUB>′−<I>ka</I><SUB>0</SUB> <I>Y</I>′. 
Si ce terme était nul alors <I>a</I><SUB>0</SUB>′=<I>ka</I><SUB>0</SUB> <I>Y</I>′ donc <I>a</I><SUB>0</SUB>=<I>c</I> exp(<I>kY</I>)=<I>cX</I><SUP><I>k</I></SUP> 
or <I>a</I><SUB>0</SUB> ne dépend pas de <I>X</I> donc <I>c</I>=0 donc <I>a</I><SUB>0</SUB>=0, absurde. 
Donc <I>X</I> ne divise pas <I>N</I>′−<I>kNY</I>′.
Comme <I>X</I><SUP><I>k</I>+1</SUP> divise  ∏<I>P</I><SUB><I>j</I></SUB> <I>X</I> (<I>N</I>′ − <I>k</I> <I>N</I> <I>Y</I>′ ), on en déduit que
<I>X</I><SUP><I>k</I></SUP> divise un des <I>P</I><SUB><I>j</I></SUB>. Donc <I>k</I>=1 et <I>P</I><SUB><I>j</I></SUB>=<I>XQ</I><SUB><I>j</I></SUB>. 
Revenons maintenant à (<A HREF="#eq:g">24</A>), on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>=ln(<I>g</I>) = ln(<I>C</I>)+<I>j</I> ln(<I>XQ</I><SUB><I>j</I></SUB>)+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I> ≠ <I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>l</I> ln(<I>P</I><SUB><I>l</I></SUB>) </TD></TR>
</TABLE><P>
on dérive :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>′=ln(<I>C</I>)′+<I>jY</I>′+<I>j</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>Q</I><SUB><I>j</I></SUB>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>Q</I><SUB><I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I> ≠ <I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>l</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>l</I></SUB>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>l</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
on voit qu’il n’est plus nécessaire de multiplier <I>f</I>′ par <I>P</I><SUB><I>j</I></SUB>
pour avoir un polynôme, multiplier par <I>Q</I><SUB><I>j</I></SUB> suffit, plus précisément
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I> ≠ <I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>P</I><SUB><I>l</I></SUB> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><I>Q</I><SUB><I>j</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>′ <I>D</I> − <I>N</I> <I>D</I>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
 est un polynôme en <I>X</I>. 
</TD></TR>
</TABLE><P>
donc <I>X</I><SUP><I>k</I>+1</SUP> divise 
 (∏<SUB><I>l</I> ≠ <I>j</I></SUB><I>P</I><SUB><I>l</I></SUB> ) <I>Q</I><SUB><I>j</I></SUB> <I>X</I> (<I>N</I>′ − <I>k</I> <I>N</I> <I>Y</I>′ ) 
ce qui est impossible.</P><P>Donc <I>D</I>=1 dans tous les cas et on a <I>f</I>=<I>N</I>. Donc 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>′=<I>N</I>′=ln(<I>C</I>)′+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>j</I> <I>P</I><SUB><I>j</I></SUB>′/<I>P</I><SUB><I>j</I></SUB> 
 est un polynôme par rapport à <I>X</I> </TD></TR>
</TABLE><P>
On en déduit que les <I>P</I><SUB><I>j</I></SUB> ne dépendent pas de <I>X</I> sauf si
<I>X</I> est une exponentielle et <I>P</I><SUB><I>j</I></SUB>=<I>X</I>. 
Dans les deux cas <I>N</I>′ ne
dépend pas de <I>X</I> donc le polynôme <I>N</I> est de degré 0 ou 1 en <I>X</I>
(si <I>X</I> est une exponentielle, <I>N</I> est forcément de degré 0)
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>X</I>=exp(<I>Y</I>) est une exponentielle (avec <I>Y</I> élémentaire
ne dépendant pas de <I>X</I>), alors <I>f</I>=<I>N</I> est indépendant de <I>X</I>.
On retire <I>jY</I> à <I>f</I> et on divise <I>g</I> par <I>X</I><SUP><I>j</I></SUP> 
(en posant <I>j</I>=0 si aucun des <I>P</I><SUB><I>j</I></SUB> n’est égal à <I>X</I>), 
qui devient indépendant de <I>X</I>, on conserve ainsi l’égalité <I>f</I>=ln(<I>g</I>)
mais avec une variable de moins dans la tour de variables par
rapport à laquelle <I>f</I> et <I>g</I> sont élémentaires.
</LI><LI CLASS="li-itemize">Si <I>X</I> n’est pas une exponentielle, <I>N</I>=<I>cX</I>+<I>d</I> avec <I>c</I>
dans le corps de constantes, et <I>d</I> indépendant de <I>X</I>.
Si <I>X</I>=<I>x</I>, on a <I>g</I>=exp(<I>cx</I>+<I>d</I>) qui n’est rationnel que si
<I>c</I>=0. On a alors <I>d</I> donc <I>f</I> et <I>g</I> constants.
Si <I>X</I>=ln(<I>Y</I>) est un logarithme (avec <I>Y</I> élémentaire
ne dépendant pas de <I>X</I>), alors ∀ <I>j</I>, <I>P</I><SUB><I>j</I></SUB>=1 donc <I>g</I> est élémentaire
indépendante de <I>X</I>. 
On a alors :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>=<I>N</I>=<I>c</I>ln(<I>Y</I>)+<I>d</I> = ln(<I>g</I>) </TD></TR>
</TABLE>
avec <I>c</I> dans le corps des constantes, <I>d</I> et <I>g</I> élémentaires
indépendants de <I>X</I>. On cherche maintenant la fonction
élémentaire <I>d</I>. Cette fonction n’est pas le logarithme d’une
fonction élémentaire en général car <I>c</I> n’est pas forcément entier,
mais <I>d</I>′ a les mêmes propriétés que la dérivée du logarithme
d’une fonction élémentaire.
On peut donc reprendre le même raisonnement mais avec une variable de moins
dans la tour de variables. Si la tour qu’on a choisie est normalisée,
alors <I>Y</I> ne contient au numérateur et au dénominateur aucune puissance
d’une exponentielle d’une variable de la tour donc le polynôme <I>P</I><SUB><I>j</I></SUB>
du cas précédent ne peut provenir de <I>Y</I> ce qui entraine que <I>j</I>
est bien entier dans le cas précédent (bien que <I>c</I> ne le soit
pas forcément).
</LI></UL><P>Après avoir fait une récurrence sur le nombre de variables de la tour,
on a donc <I>f</I> qui s’exprime comme combinaison linéaire à coefficients
entiers des arguments <I>g</I><SUB><I>k</I></SUB> des variables exponentielles <I>f</I><SUB><I>k</I></SUB>=exp(<I>g</I><SUB><I>k</I></SUB>)
de la tour et à coefficients a priori quelconque des variables logarithmes
<I>f</I><SUB><I>l</I></SUB>=ln(<I>g</I><SUB><I>l</I></SUB>) de la tour :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>j</I><SUB><I>k</I></SUB> <I>g</I><SUB><I>k</I></SUB> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>l</I></SUB> ln(<I>g</I><SUB><I>l</I></SUB>) = ln(<I>g</I>) </TD></TR>
</TABLE><P>
Comme <I>g</I> est élémentaire, <I>h</I>=<I>g</I>/∏<SUB><I>k</I></SUB> exp(<I>g</I><SUB><I>k</I></SUB>)<SUP><I>j</I><SUB><I>k</I></SUB></SUP>
est élémentaire de logarithme ∑<SUB><I>l</I></SUB> <I>x</I><SUB><I>l</I></SUB> ln(<I>g</I><SUB><I>l</I></SUB>) .
Montrons que si les arguments des ln sont des polynômes
sans facteurs multiples, alors
les <I>x</I><SUB><I>l</I></SUB> sont entiers. Rappelons
que les ln(<I>g</I><SUB><I>l</I></SUB>) sont algébriquement indépendants, on peut donc
construire des polynômes irréductibles <I>I</I><SUB><I>l</I></SUB> par rapport aux variables
de la tour tels que <I>I</I><SUB><I>l</I></SUB> divise une fois <I>g</I><SUB><I>l</I></SUB> mais ne divise pas les <I>g</I><SUB><I>k</I></SUB>
précédents. Soit <I>h</I>=∏<SUB><I>j</I> ∈ ℤ</SUB> <I>P</I><SUB><I>j</I></SUB><SUP><I>j</I></SUP> la factorisation
sans facteurs multiples de <I>h</I>. On dérive alors ln(<I>h</I>) ce qui donne :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>l</I></SUB> <I>g</I><SUB><I>l</I></SUB>′/<I>g</I><SUB><I>l</I></SUB> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>j</I> <I>P</I><SUB><I>j</I></SUB>′/<I>P</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>
où ∏<SUB><I>j</I></SUB> <I>P</I><SUB><I>j</I></SUB><SUP><I>j</I></SUP> est la décomposition sans facteurs multiples
de <I>h</I>. Comme <I>I</I><SUB><I>l</I></SUB> divise un et un seul des <I>P</I><SUB><I>j</I></SUB> on en déduit
que <I>x</I><SUB><I>l</I></SUB> est égal au <I>j</I> correspondant et est donc entier.
(Remarque: si on n’impose pas aux arguments des logarithmes
d’être des polynômes sans facteurs carrés, 
on obtiendrait ici des coefficients rationnels).</P><P><B>En pratique</B>:<BR>
On peut effecter l’algorithme de la manière suivante : 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
on cherche les variables généralisées de l’expression
qui dépendent de <I>x</I>.
</LI><LI CLASS="li-itemize">On ajoute les variables généralisées en commençant par
la moins longue
</LI><LI CLASS="li-itemize">Si c’est un logarithme, on extrait les puissances des
exponentielles précédentes dont il dépend.
On cherche des relations entre fonctions ln en les réécrivant
comme combinaison linéaire de ln indépendants. Pour avoir
des ln indépendants, on se ramène d’abord à des polynômes
sans facteurs multiples en utilisant la relation ln(<I>a</I>/<I>b</I>)=ln(<I>a</I>)−ln(<I>b</I>) 
et en écrivant la factorisation sans facteurs multiples 
de chaque polynôme argument, puis
on extrait le PGCD 2 à 2 des arguments de logarithmes jusqu’à
obtenir des arguments de ln premiers entre eux.
</LI><LI CLASS="li-itemize">Si c’est une exponentielle, on teste
si son argument est combinaison linéaire à coefficients rationnels :
<UL CLASS="itemize"><LI CLASS="li-itemize">
des arguments des exponentielles précédentes, 
</LI><LI CLASS="li-itemize">des ln des logarithmes précédents,
</LI><LI CLASS="li-itemize">de ln(<I>x</I>) et de <I>i</I>*π.
</LI></UL>
Pour cela on substitue les ln par des indéterminées,
et on dérive une fois par rapport à cette indéterminée, le
résultat doit être un rationnel, pour les variables exponentielles,
il faut réduire au même dénominateur et résoudre le système
linéaire obtenu en identifiant les coefficients du numérateur.
Si l’exponentielle est indépendante des précédentes, 
on extrait de l’exponentielle à rajouter la partie linéaire de la 
dépendance en les ln précédents si le coefficient correspondant est
entier. Par exemple, on réécrit :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>xe</I><SUP>2 ln(<I>x</I>)+ln(<I>x</I>)<SUP>2</SUP></SUP> = <I>x</I><SUP>3</SUP> <I>e</I><SUP>ln(<I>x</I>)<SUP>2</SUP></SUP> </TD></TR>
</TABLE>
</LI></UL><P><B>Remarque</B><BR>
On n’est pas obligé de se limiter aux seules fonctions logarithmes
et exponentielles, l’essentiel est de pouvoir tester l’indépendance
algébrique des expressions créées. Pour éviter d’avoir à introduire
des exponentielles et logarithmes complexes dans une expression
réelle, on peut autoriser
par exemple des extensions en tangente ou en arctangente.</P><!--TOC subsubsection Théorème de Liouville-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc156">17.2.3</A>  Théorème de Liouville</H4><!--SEC END --><P><A NAME="@default193"></A>
On a vu que la dérivée d’une fonction élémentaire dépendant 
d’une tour de variables est une fonction élémentaire dépendant 
de la même tour de variables.
Réciproquement, supposons qu’une fonction élémentaire admette
une primitive qui soit élémentaire, c’est-à-dire qu’elle doit
être une fraction rationelle par rapport à une tour de variables
mais pas forcément identique à celle de départ. Alors, si une telle
écriture existe, à des termes logarithmiques près, elle
ne peut dépendre que de la même tour de variables, plus précisément
on a le théorème de Liouville :
</P><DIV CLASS="theorem"><B>Théorème 32</B>  <EM>
Soit </EM><EM><I>f</I></EM><EM> une fonction élémentaire par rapport à une tour de variables </EM><EM><I>T</I></EM><EM>
et un corps de constantes </EM><EM><I>K</I></EM><EM> admettant une primitive élémentaire </EM><EM><I>F</I></EM><EM>. Alors 
il existe un nombre fini de constantes </EM><EM><I>c</I></EM><SUB><EM>1</EM></SUB><EM>,...,<I>c</I></EM><SUB><EM><I>n</I></EM></SUB><EM> et de fonctions
élémentaires </EM><EM><I>v</I></EM><SUB><EM>1</EM></SUB><EM>,...,<I>v</I></EM><SUB><EM><I>n</I></EM></SUB><EM> par rapport à </EM><EM><I>T</I></EM><EM> avec comme corps de constantes
une extension algébrique </EM><EM><I>K</I>′</EM><EM> de </EM><EM><I>K</I></EM><EM> tel que </EM><EM><I>F</I> − ∑</EM><SUB><EM><I>k</I></EM></SUB><EM> <I>c</I></EM><SUB><EM><I>k</I></EM></SUB><EM> </EM><EM>ln</EM><EM>(<I>v</I></EM><SUB><EM><I>k</I></EM></SUB><EM>) </EM><EM>
soit élémentaire par rapport à </EM><EM><I>T</I></EM><EM> et </EM><EM><I>K</I></EM><EM>.
</EM></DIV><P><B>Preuve:</B><SUP><A NAME="text28" HREF="#note28">28</A></SUP><BR>
Soit <I>f</I> élémentaire de tour <I>T</I><SUB>1</SUB> (corps <I>K</I>) et 
<I>F</I> sa primitive supposée élémentaire de tour <I>T</I><SUB>2</SUB> et de corps <I>K</I>′
une extension algébrique de <I>K</I>. 
On commence par rajouter après les élements de <I>T</I><SUB>1</SUB> les 
élements nécessaires de <I>T</I><SUB>2</SUB> pour obtenir une tour <I>T</I> par rapport
à laquelle <I>f</I> et <I>F</I> sont élémentaires (plus précisément <I>F</I> sera
élémentaire quitte à autoriser des puissances fractionnaires
des variables exponentielles de <I>T</I><SUB>1</SUB>). Le théorème de structure
de Risch permet de faire cela, en effet on regarde pour chaque
élément de <I>T</I><SUB>2</SUB> s’il est algébriquement indépendant des éléments
de <I>T</I><SUB>1</SUB> ou non. S’il l’est, on le rajoute à la tour <I>T</I>, s’il
ne l’est pas alors dans le cas d’un logarithme il est élémentaire
et dans le cas d’une exponentielle, une de ses puissances est
élémentaire. Donc <I>F</I> est bien une fraction rationnelle par rapport
aux éléments logarithmiques de <I>T</I><SUB>1</SUB>, aux racines <I>n</I>-ième
des éléments exponentiels de <I>T</I><SUB>1</SUB> et à des éléments de <I>T</I><SUB>2</SUB>
dans cet ordre (le corps des constantes étant <I>K</I>′).</P><P><B>Première étape:</B><BR>
Commençons par les éléments restant de <I>T</I><SUB>2</SUB>. Soit <I>X</I><SUB><I>k</I></SUB> l’élément
au sommet de la tour <I>T</I>. La dérivée <I>f</I> de <I>F</I> par rapport à <I>X</I><SUB><I>k</I></SUB>
ne dépend pas de <I>X</I><SUB><I>k</I></SUB>. Donc soit <I>F</I> ne dépend pas de <I>X</I><SUB><I>k</I></SUB> et
on passe à la variable suivante, soit <I>X</I><SUB><I>k</I></SUB>=ln(<I>v</I><SUB><I>k</I></SUB>) est un logarithme
et <I>F</I>=<I>c</I><SUB><I>k</I></SUB> ln(<I>v</I><SUB><I>k</I></SUB>)+<I>d</I><SUB><I>k</I></SUB> avec <I>c</I><SUB><I>k</I></SUB> ∈ <I>K</I>′ et <I>v</I><SUB><I>k</I></SUB> et <I>d</I><SUB><I>k</I></SUB> 
indépendants de <I>X</I><SUB><I>k</I></SUB>. S’il
n’y a pas d’autres éléments restants de <I>T</I><SUB>2</SUB>, on passe à la 2ème étape.
Sinon soit <I>X</I><SUB><I>k</I>−1</SUB> la variable suivante 
(juste en-dessous de <I>X</I><SUB><I>k</I></SUB> dans la tour).
En dérivant, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I>′= <I>c</I><SUB><I>k</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + <I>d</I><SUB><I>k</I></SUB>′ = <I>f</I></TD></TR>
</TABLE><P>
Supposons que <I>v</I><SUB><I>k</I></SUB> dépende de <I>X</I><SUB><I>k</I>−1</SUB>, on fait alors un raisonnement 
analogue à celui de la preuve du théorème de structure de Risch, en décomposant
<I>v</I><SUB><I>k</I></SUB> en produit/quotient de facteurs sans multiplicités <I>v</I><SUB><I>k</I></SUB>=∏<I>P</I><SUB><I>j</I></SUB><SUP><I>j</I></SUP>
et en écrivant <I>d</I><SUB><I>k</I></SUB>=<I>N</I>/<I>D</I> on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>P</I><SUB><I>j</I></SUB> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>′ <I>D</I> − <I>N</I> <I>D</I>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
est un polynôme en <I>X</I><SUB><I>k</I>−1</SUB>. On en déduit comme précédemment que
<I>D</I>=1, <I>N</I>′=<I>d</I><SUB><I>k</I></SUB>′ est indépendant de <I>X</I><SUB><I>k</I>−1</SUB>. Comme on a supposé que
<I>v</I><SUB><I>k</I></SUB> dépend de <I>X</I><SUB><I>k</I>−1</SUB>, <I>X</I><SUB><I>k</I>−1</SUB>=exp(<I>Y</I><SUB><I>k</I>−1</SUB>) est alors une 
exponentielle, <I>N</I>=<I>d</I><SUB><I>k</I></SUB> ne dépend pas de <I>X</I><SUB><I>k</I>−1</SUB> et l’un des <I>P</I><SUB><I>j</I></SUB>=<I>X</I><SUB><I>k</I>−1</SUB>
(sinon tous les <I>P</I><SUB><I>j</I></SUB> seraient constants en <I>X</I><SUB><I>k</I>−1</SUB> donc <I>v</I><SUB><I>k</I></SUB> aussi).
On élimine alors la variable <I>X</I><SUB><I>k</I>−1</SUB> en écrivant 
ln(<I>v</I><SUB><I>k</I></SUB>)=<I>jY</I><SUB><I>k</I>−1</SUB>+ln(<I>w</I><SUB><I>k</I></SUB>), avec <I>Y</I><SUB><I>k</I>−1</SUB> et <I>w</I><SUB><I>k</I></SUB> élémentaires et
indépendants de <I>X</I><SUB><I>k</I>−1</SUB>.</P><P>Si <I>v</I><SUB><I>k</I></SUB> est indépendant de <I>X</I><SUB><I>k</I>−1</SUB>, alors <I>d</I><SUB><I>k</I></SUB>′ aussi donc
soit <I>d</I><SUB><I>k</I></SUB> est indépendant de <I>X</I><SUB><I>k</I>−1</SUB> et on passe à la variable
suivante, soit <I>X</I><SUB><I>k</I>−1</SUB> est un logarithme et 
<I>d</I><SUB><I>k</I></SUB>=<I>c</I><SUB><I>k</I>−1</SUB>ln(<I>v</I><SUB><I>k</I>−1</SUB>)+<I>d</I><SUB><I>k</I>−1</SUB>.
En continuant pour toutes les variables restantes de <I>T</I><SUB>2</SUB>, on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>c</I><SUB><I>k</I></SUB> ln<I>v</I><SUB><I>k</I></SUB> +<I>d</I> </TD></TR>
</TABLE><P>
avec <I>d</I> et <I>v</I><SUB><I>k</I></SUB> élémentaires pour <I>T</I><SUB>1</SUB> (avec exponentielles
modifiées en en prenant une racine <I>n</I>-ième) et <I>K</I>′.</P><P><B>Deuxième étape</B>
Il s’agit de montrer que pour les exponentielles, il n’est en fait pas
nécessaire de prendre de racines <I>n</I>-ième. La compréhension
de cette étape demande
un peu de familiarité avec l’algorithme de Risch (cf. infra).
On va faire la preuve pour la variable au sommet de la tour <I>T</I><SUB>1</SUB> si
c’est une exponentielle. On verra dans le déroulement
de l’algorithme de Risch que pour les autres variables, il y a
appel récursif de l’algorithme d’intégration, donc traiter
la variable au sommet suffira.
Soit donc exp(<I>Y</I>) la variable au sommet de la tour <I>T</I><SUB>1</SUB>, on note
<I>X</I>=exp(<I>Y</I>/<I>n</I>) la racine <I>n</I>-ième de cette variable qui est utilisée
pour exprimer <I>F</I>=∑<I>c</I><SUB><I>k</I></SUB> ln<I>v</I><SUB><I>k</I></SUB> + <I>N</I>/<I>D</I> comme une fraction
rationnelle en <I>X</I> alors que <I>f</I>=<I>F</I>′ est une fraction rationnelle en <I>X</I><SUP><I>n</I></SUP>.
On a donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∑</FONT><I>c</I><SUB><I>k</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">′ 
=<I>f</I>=fraction rationnelle en (<I>X</I><SUP><I>n</I></SUP>) </TD></TR>
</TABLE><P>
Notons que le fait que <I>X</I> soit une exponentielle est essentiel, 
car par exemple l’intégrale d’une fraction rationnelle dépendant de <I>x</I><SUP><I>n</I></SUP> 
comme <I>x</I><SUP>3</SUP> ou 1/(<I>x</I><SUP>3</SUP>−1) ne s’exprime pas en fonction de <I>x</I><SUP>3</SUP>.
On traite d’abord la partie polynomiale généralisée de <I>f</I> en <I>X</I><SUP><I>n</I></SUP>:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>∈ ℤ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUB><I>j</I></SUB> (<I>X</I><SUP><I>n</I></SUP>)<SUP><I>j</I></SUP></TD></TR>
</TABLE><P>
Son intégrale est un polynôme généralisé, éventuellement dépendant
de <I>X</I>, soit ∑<SUB><I>j</I>∈ ℤ</SUB> <I>A</I><SUB><I>j</I></SUB> <I>X</I><SUP><I>j</I></SUP>. On dérive, et on obtient
pour <I>k</I> non multiple de <I>n</I>, <I>A</I><SUB><I>k</I></SUB> <I>Y</I>/<I>n</I>+<I>A</I><SUB><I>k</I></SUB>′=0 dont <I>A</I><SUB><I>k</I></SUB>=0 est
solution. La partie polynôme généralisé ne dépend donc que de <I>X</I><SUP><I>n</I></SUP>.
On effectue aussi les intégrations par parties pour réduire le 
dénominateur de <I>f</I> à un polynôme sans facteurs multiples (réduction
de Hermite), ce qui se fait en introduisant des fractions rationnelles 
en <I>X</I><SUP><I>n</I></SUP> uniquement. Reste la partie logarithmique. On utilise le critère
du résultant, les coefficients des logarithmes sont les racines 
<I>c</I><SUB><I>k</I></SUB> du polynôme en <I>t</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">Res<SUB><I>X</I></SUB> (<I>D</I>,<I>N</I>−<I>tD</I>′) </TD></TR>
</TABLE><P>
où ces racines doivent être indépendantes de <I>x</I> (puisque <I>F</I> existe)
et les <I>v</I><SUB><I>k</I></SUB> correspondants sont égaux à
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">gcd(<I>D</I>,<I>N</I>−<I>c</I><SUB><I>k</I></SUB> <I>D</I>′) </TD></TR>
</TABLE><P>
Or comme <I>X</I> est une exponentielle, <I>D</I>′ est un polynôme en
<I>X</I><SUP><I>n</I></SUP>, de même que <I>D</I> et <I>N</I>, donc <I>v</I><SUB><I>k</I></SUB> est un polynôme
en <I>X</I><SUP><I>n</I></SUP>.</P><P><B>Troisième étape</B>
Il reste enfin à montrer que seuls les <I>c</I><SUB><I>k</I></SUB> et <I>v</I><SUB><I>k</I></SUB> nécessitent
une extension algébrique de <I>K</I>. Ceci est encore une conséquence
de l’algorithme de Risch, la construction
de la partie polynomiale (éventuellement généralisée) et de la 
partie fractionnaire ne font en effet intervenir que des coefficients
dans le corps <I>K</I>.</P><!--TOC subsection L’algorithme de Risch-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc157">17.3</A>  L’algorithme de Risch</H3><!--SEC END --><P> <A NAME="sec:risch"></A>
On suppose dans la suite qu’on s’est ramené à une fraction rationnelle
par rapport à une tour de variables (où on a effectué les simplifications
évidentes ln∘ exp, ainsi que exp∘ ln, dans le
premier cas en extrayant les facteurs évidents en les variables
précédentes exponentielles, dans le deuxième cas en extrayant la
partie linéaire à coefficient entier en les variables logarithmes
précédentes).
On note <I>X</I> la variable au sommet de la tour et <I>N</I><SUB>0</SUB>/<I>D</I><SUB>0</SUB> l’écriture
de la fonction élémentaire comme fraction irréductible avec
<I>N</I><SUB>0</SUB> et <I>D</I><SUB>0</SUB> polynômes en <I>X</I>.</P><P><B>Exemples</B><BR>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell">(2<I>x</I><SUP>2</SUP>+1) <I>e</I><SUP><I>x</I><SUP>2</SUP></SUP></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><I>X</I>=<I>e</I><SUP><I>x</I><SUP>2</SUP></SUP></TD><TD ALIGN=left NOWRAP><I>N</I><SUB>0</SUB>=(2<I>x</I><SUP>2</SUP>+1) <I>X</I>, <I>D</I><SUB>0</SUB>=1 </TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I> ln(<I>x</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+ln(<I>x</I>)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><I>X</I>=ln(<I>x</I>)</TD><TD ALIGN=left NOWRAP><I>N</I><SUB>0</SUB>=<I>xX</I>, <I>D</I><SUB>0</SUB>=<I>x</I>+<I>X</I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>La première étape va consister à se ramener à un dénominateur sans facteurs
multiples. Elle est analogue au cas des fractions
rationnelles de <I>x</I> et est basée sur l’identité de Bézout entre
<I>P</I> et <I>P</I>′ vu comme polynômes en la variable du haut de la tour. 
Il apparait toutefois une difficulté pour les
extensions exponentielles, à savoir que <I>X</I>=<I>e</I><SUP><I>f</I></SUP> et <I>X</I>′=<I>f</I>′ <I>X</I>
ne sont pas premiers entre eux comme polynômes en <I>X</I>, on devra
traiter le pôle 0 d’une fraction rationnelle en une exponentielle <I>X</I> comme
on traite l’intégration d’un polynôme en <I>x</I>.
Si <I>P</I> est sans facteurs multiples et premier avec <I>X</I>, alors
<I>P</I>(<I>X</I>) et <I>P</I>(<I>X</I>)′=<I>f</I>′ <I>X</I> <I>P</I>′(<I>X</I>) vu comme
polynômes en <I>X</I> n’ont pas de facteurs en commun.</P><P>On commence donc, si <I>X</I> est une exponentielle et <I>D</I><SUB>0</SUB> un
multiple de <I>X</I>, par appliquer Bézout pour décomposer la fraction <I>N</I><SUB>0</SUB>/<I>D</I><SUB>0</SUB>
en :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUB>0</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">
=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>X</I><SUP><I>k</I></SUP> </TD></TR>
</TABLE></TD><TD CLASS="dcell"> ,    gcd(<I>X</I>,<I>D</I><SUB>1</SUB>)=1, <I>D</I><SUB>0</SUB>=<I>X</I><SUP><I>k</I></SUP> <I>D</I><SUB>1</SUB></TD></TR>
</TABLE><P>
On isole aussi la partie polynômiale en effectuant
la division euclidienne de <I>N</I><SUB>0</SUB> par <I>D</I><SUB>0</SUB> (ou de <I>N</I><SUB>1</SUB> par <I>D</I><SUB>1</SUB> si <I>X</I>
est une exponentielle),
on obtient alors une écriture sous la forme :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUB><I>j</I></SUB> <I>X</I><SUP><I>j</I></SUP></TD></TR>
</TABLE><P>
où la somme sur <I>j</I> est finie et porte sur des entiers positifs ou nul 
si <I>X</I> n’est pas une exponentielle, ou sur des entiers relatifs si <I>X</I>
est une exponentielle.</P><P>On effectue la même écriture sur la partie fractionnaire de <I>F</I>,
et en identifiant les parties polynomiales et éventuellement la partie
polaire en 0 si <I>X</I> est une exponentielle, on peut séparer l’intégration
en 2 parties: intégration de la partie polynomiale (généralisée)
et intégration de la partie fractionnaire propre.</P><P><B>Exemples</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 (2<I>x</I><SUP>2</SUP>+1) <I>e</I><SUP><I>x</I><SUP>2</SUP></SUP> = 0+(2<I>x</I><SUP>2</SUP>+1)<I>X</I> est un polynôme,
</LI><LI CLASS="li-itemize"><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I> ln(<I>x</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+ln(<I>x</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>xX</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+<I>X</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">=−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+<I>X</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">+<I>x</I></TD></TR>
</TABLE>
la partie polynomiale est <I>x</I> (de degré 0 en <I>X</I>), la partie fractionnaire
est −<I>x</I><SUP>2</SUP>/(<I>x</I>+<I>X</I>)
</LI><LI CLASS="li-itemize"><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I>(<I>e</I><SUP>2<I>x</I></SUP>+1)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP><I>x</I></SUP>(<I>e</I><SUP><I>x</I></SUP>+1)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I>(<I>X</I><SUP>2</SUP>+1)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>X</I>(<I>X</I>+1)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
= −</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>X</I>+1)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + <I>xX</I><SUP>−1</SUP></TD></TR>
</TABLE>
la partie polynôme généralisé est <I>xX</I><SUP>−1</SUP>
</LI></UL><!--TOC subsubsection Intégration d’une fraction propre-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc158">17.3.1</A>  Intégration d’une fraction propre</H4><!--SEC END --><P><A NAME="@default194"></A>
</P><!--TOC subsubsection Réduction sans facteurs multiples-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc159">17.3.2</A>  Réduction sans facteurs multiples</H4><!--SEC END --><P>
On factorise <I>D</I> en ∏<SUB><I>i</I></SUB> <I>P</I><SUB><I>i</I></SUB><SUP><I>i</I></SUP> avec <I>P</I><SUB><I>i</I></SUB> sans facteurs multiples 
(et les <I>P</I><SUB><I>i</I></SUB> premiers entre eux 2 à 2) et on décompose
en éléments simples relativement à cette factorisation (en appliquant
Bézout) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>&gt;0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUB><I>i</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>i</I></SUB><SUP><I>i</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
Pour chaque polynome <I>P</I><SUB><I>i</I></SUB>, on applique Bézout à <I>P</I><SUB><I>i</I></SUB> et <I>P</I>′<SUB><I>i</I></SUB> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I><SUB><I>i</I></SUB> = <I>A</I><SUB><I>i</I></SUB><I>P</I><SUB><I>i</I></SUB>+<I>B</I><SUB><I>i</I></SUB><I>P</I>′<SUB><I>i</I></SUB> ⇒ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUB><I>i</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>i</I></SUB><SUP><I>i</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>A</I><SUB><I>i</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>i</I></SUB><SUP><I>i</I>−1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB><I>i</I></SUB><I>P</I><SUB><I>i</I></SUB>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>i</I></SUB><SUP><I>i</I></SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
on intègre par parties le second terme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUB><I>i</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>i</I></SUB><SUP><I>i</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>A</I><SUB><I>i</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>i</I></SUB><SUP><I>i</I>−1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
− </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB><I>i</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>i</I>−1)<I>P</I><SUB><I>i</I></SUB><SUP><I>i</I>−1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB><I>i</I></SUB>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>i</I>−1)<I>P</I><SUB><I>i</I></SUB><SUP><I>i</I>−1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD></TR>
</TABLE><P>
on rassemble les deux intégrales ayant <I>P</I><SUB><I>i</I></SUB><SUP><I>i</I>−1</SUP> au dénominateur
et on recommence jusqu’à avoir une puissance 1 au dénominateur. Il reste
alors à intégrer une somme de fractions du type <I>N</I>/<I>D</I> avec
<I>D</I> et <I>D</I>′ premiers entre eux.</P><P><B>Exemple</B><BR>
On reprend le dernier exemple de la section précédente pour
éliminer la puissance 2 au dénominateur:
<I>N</I><SUB>2</SUB>=2<I>x</I> et <I>P</I><SUB>2</SUB>=(<I>X</I>+1) avec <I>X</I>=<I>e</I><SUP><I>x</I></SUP>. On a <I>P</I><SUB>2</SUB>′=<I>X</I>, donc <I>A</I><SUB>2</SUB>=2<I>x</I> et
<I>B</I><SUB>2</SUB>=−2<I>x</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>X</I>+1)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> =</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB>2</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + 
</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−2<I>x</I> <I>P</I><SUB>2</SUB>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB>2</SUB><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB>2</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB>2</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">
− </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB>2</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
il reste donc à intégrer (2<I>x</I>−2)/(<I>e</I><SUP><I>x</I></SUP>+1).</P><!--TOC subsubsection La partie logarithmique-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc160">17.3.3</A>  La partie logarithmique</H4><!--SEC END --><P>
Comme on l’a vu lors de la preuve du théorème de structure de Risch,
si on dérive une fraction en <I>X</I>, le dénominateur de la dérivée ne
peut se décomposer qu’en produit de facteurs de multiplicité supérieure
ou égale à 2. Il en résulte que la fraction à intégrer résiduelle (encore
notée <I>f</I>=<I>N</I>/<I>D</I>) après l’étape de réduction ci-dessus ne peut provenir que de la
dérivation de <I>F</I>=∑<SUB><I>k</I></SUB> <I>c</I><SUB><I>k</I></SUB> ln(<I>v</I><SUB><I>k</I></SUB>) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">=<I>F</I>′= (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>c</I><SUB><I>k</I></SUB> ln(<I>v</I><SUB><I>k</I></SUB>))′= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>c</I><SUB><I>k</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
En identifiant les décompositions
en éléments simples de <I>F</I>′ et <I>f</I>, on montre également que 
les <I>v</I><SUB><I>k</I></SUB> divisent <I>D</I>, plus précisément on peut imposer aux <I>v</I><SUB><I>k</I></SUB>
d’être premiers entre eux 2 à 2 et dans ce cas <I>D</I>=∏<I>v</I><SUB><I>k</I></SUB>. 
Donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>c</I><SUB><I>k</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>v</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
et :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>c</I><SUB><I>k</I></SUB> <I>v</I><SUB><I>k</I></SUB>′ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>≠ <I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>v</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>
Soit <I>t</I> un paramètre, formons le polynôme <I>N</I>−<I>tD</I>′ :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I>−<I>tD</I>′ = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">(<I>c</I><SUB><I>k</I></SUB> −<I>t</I>) <I>v</I><SUB><I>k</I></SUB>′ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>≠ <I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>v</I><SUB><I>j</I></SUB> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
donc le pgcd en <I>X</I> des polynômes <I>N</I>−<I>tD</I>′ et <I>D</I> est :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
si <I>t</I> n’est égal à aucun des <I>c</I><SUB><I>k</I></SUB>, <I>N</I>−<I>tD</I>′ est premier
avec <I>v</I><SUB><I>k</I></SUB> pour tout <I>k</I> car <I>v</I><SUB><I>k</I></SUB> divise
∑<SUB><I>l</I> ≠ <I>k</I></SUB> (<I>c</I><SUB><I>l</I></SUB> −<I>t</I>) <I>v</I><SUB><I>l</I></SUB>′ ∏<SUB><I>j</I>≠ <I>l</I></SUB> <I>v</I><SUB><I>j</I></SUB>
et <I>v</I><SUB><I>k</I></SUB>′∏<SUB><I>j</I>≠ <I>k</I></SUB> <I>v</I><SUB><I>j</I></SUB>  est premier avec <I>v</I><SUB><I>k</I></SUB>. Donc
le pgcd est 1.
</LI><LI CLASS="li-itemize">si <I>t</I> est égal à l’un des <I>c</I><SUB><I>k</I></SUB>, alors le pgcd est le produit
des <I>v</I><SUB><I>k</I></SUB> tels que <I>c</I><SUB><I>k</I></SUB>=<I>t</I> (notons que dans ce cas on peut
rassembler ces <I>v</I><SUB><I>k</I></SUB> à l’intérieur d’un même logarithme)
</LI></UL><P>
Considérons le polynôme <I>R</I> de la variable <I>t</I> égal au résultant par rapport
à <I>X</I> des polynômes <I>D</I> et <I>N</I>−<I>tD</I>′ (rappelons qu’il s’agit du
déterminant du système linéaire <I>AD</I>+<I>B</I>(<I>N</I>−<I>tD</I>′)=1
où les inconnues sont les coefficients des polynômes <I>A</I> et <I>B</I>, 
ce déterminant est nul si et seulement si le système n’a pas
de solution donc si et seulement si <I>D</I> et <I>N</I>−<I>tD</I>′ ne sont pas
premiers entre eux), alors ce polynôme en <I>t</I>
s’annule si et seulement si <I>t</I>=<I>c</I><SUB><I>k</I></SUB>. 
On cherche les racines <I>c</I><SUB><I>k</I></SUB> en <I>t</I> de ce polynôme,
elles doivent être indépendantes de <I>x</I> si <I>F</I> est élémentaire,
et dans ce cas la primitive <I>F</I> de <I>f</I>=<I>N</I>/<I>D</I> vaut
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>c</I><SUB><I>k</I></SUB>  racine de  <I>R</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>c</I><SUB><I>k</I></SUB> ln(gcd(<I>N</I>−<I>c</I><SUB><I>k</I></SUB> <I>D</I>′,<I>D</I>)) </TD></TR>
</TABLE><P><B>Exemples</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>x</I>−2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP><I>x</I></SUP>+1</TD></TR>
</TABLE></TD><TD CLASS="dcell">,    <I>D</I>=<I>X</I>+1, <I>D</I>′=<I>e</I><SUP><I>x</I></SUP>=<I>X</I>,    <I>N</I>−<I>tD</I>′=2<I>x</I>−2−<I>tX</I> </TD></TR>
</TABLE>
On calcule <I>R</I>=−2*<I>x</I>−<I>t</I>+2, l’unique racine est <I>t</I>=2−2<I>x</I> qui n’est
pas constante donc cette fonction n’admet pas de primitive élémentaire.
</LI><LI CLASS="li-itemize"><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(2<I>x</I><SUP>2</SUP>−<I>x</I>−2)<I>X</I>−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>X</I><SUP>2</SUP>+(<I>x</I>+1)<I>X</I>+<I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">,    <I>X</I>=exp(<I>x</I><SUP>2</SUP>+<I>x</I>)</TD></TR>
</TABLE>
On a <I>D</I>′=2(2<I>x</I>+1)<I>X</I><SUP>2</SUP>+(1+(2<I>x</I>+1)(<I>x</I>+1))<I>X</I>+1
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>R</I>=−(2<I>x</I>−1)(<I>x</I>+1)(2<I>x</I>+1)(<I>x</I>−1)<SUP>2</SUP>(<I>t</I>+1)(<I>t</I>−1) </TD></TR>
</TABLE>
les racines en <I>t</I> sont constantes et égales à 1 et -1, donc <I>c</I><SUB>1</SUB>=1
et <I>v</I><SUB>1</SUB>=gcd(<I>N</I>−<I>D</I>′,<I>D</I>)=<I>X</I>+1 et <I>c</I><SUB>2</SUB>=−1, <I>v</I><SUB>2</SUB>=gcd(<I>N</I>+<I>D</I>′,<I>D</I>)=<I>x</I>+<I>X</I>
donc :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(2<I>x</I><SUP>2</SUP>−<I>x</I>−2)<I>X</I>−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>X</I><SUP>2</SUP>+(<I>x</I>+1)<I>X</I>+<I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = ln(<I>X</I>+1)−ln(<I>x</I>+<I>X</I>)</TD></TR>
</TABLE>
</LI></UL><P><B>Remarque importante</B><BR>
Pour les extensions exponentielles ou logarithmiques, 
la dérivée de la partie logarithmique
calculée comme ci-dessus contiendra en général 
une partie entière constante par rapport à <I>X</I>, il faut
donc retirer cette partie entière à la partie polynomiale.</P><!--TOC subsubsection La partie polynomiale (généralisée)-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc161">17.3.4</A>  La partie polynomiale (généralisée)</H4><!--SEC END --><P>
On doit résoudre :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>A</I><SUB><I>j</I></SUB> <I>X</I><SUP><I>j</I></SUP>)′=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUB><I>j</I></SUB> <I>X</I><SUP><I>j</I></SUP> </TD></TR>
</TABLE><P>
avec une somme sur <I>j</I> ∈ℤ si <I>X</I> est une exponentielle et
<I>j</I>∈ ℕ sinon.</P><P>Si <I>X</I>=<I>x</I>, <I>j</I>≥ 0 et la résolution est immédiate: on prend <I>A</I><SUB>0</SUB>=0 et 
<I>A</I><SUB><I>j</I>+1</SUB>=<I>a</I><SUB><I>j</I></SUB>/(<I>j</I>+1).</P><!--TOC subsubsection Extension logarithmique-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc162">17.3.5</A>  Extension logarithmique</H4><!--SEC END --><P>
Si <I>X</I>=ln(<I>Y</I>) est un logarithme, <I>j</I> ≥ 0 et on doit résoudre :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>≥ 0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>A</I><SUB><I>j</I></SUB>′+(<I>j</I>+1)<I>A</I><SUB><I>j</I>+1</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>Y</I>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>Y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">) <I>X</I><SUP><I>j</I></SUP> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUB><I>j</I></SUB> <I>X</I><SUP><I>j</I></SUP> </TD></TR>
</TABLE><P>
Soit <I>k</I> la plus grande puissance non nulle de <I>f</I> (<I>a</I><SUB><I>j</I></SUB>=0 
si <I>j</I>&gt;<I>k</I> et <I>a</I><SUB><I>k</I></SUB>≠ 0). Pour <I>j</I>&gt;<I>k</I>, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUB><I>j</I></SUB>′+(<I>j</I>+1)<I>A</I><SUB><I>j</I>+1</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>Y</I>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>Y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  =0 </TD></TR>
</TABLE><P>
On résout pour des valeurs de <I>j</I> décroissante, pour <I>j</I> suffisamment
grand, on a <I>A</I><SUB><I>j</I>+1</SUB>=0 car la somme sur <I>j</I> est finie, donc <I>A</I><SUB><I>j</I></SUB>
est constant. Si <I>A</I><SUB><I>j</I></SUB> ≠ 0, alors au rang <I>j</I>−1, on a 
<I>A</I><SUB><I>j</I>−1</SUB> ′ = −<I>j</I> <I>A</I><SUB><I>j</I></SUB> <I>Y</I>′/<I>Y</I>  qui n’admet pas de solutions car 
<I>A</I><SUB><I>j</I>−1</SUB> ne peut pas dépendre de <I>X</I>=ln(<I>Y</I>). On en déduit que pour
<I>j</I>&gt;<I>k</I>+1, on a <I>A</I><SUB><I>j</I></SUB>=0 et <I>A</I><SUB><I>k</I>+1</SUB> est constant. En fait la
valeur constante de <I>A</I><SUB><I>k</I>+1</SUB> sera déterminée par une condition
de compatibilité en résolvant l’équation au rang du dessous.
On continue la résolution de 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUB><I>j</I></SUB>′+(<I>j</I>+1)<I>A</I><SUB><I>j</I>+1</SUB> ln(<I>Y</I>)′  = <I>a</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>
par valeur décroissante de <I>j</I>, à chaque
rang on va déterminer <I>A</I><SUB><I>j</I></SUB> à une constante près en résolvant
un problème d’intégration (par appel récursif de l’algorithme
de Risch, mais si <I>j</I> ≠ 0 sans autoriser l’ajout de nouveaux 
logarithmes sauf ln(<I>Y</I>))
et la valeur de la constante de <I>A</I><SUB><I>j</I>+1</SUB> (on fait varier <I>A</I><SUB><I>j</I>+1</SUB>
de la constante nécessaire pour absorber le terme en ln(<I>Y</I>)
qui apparait lors de l’appel récursif de Risch).
Au rang 0, on est ramené à un problème d’intégration avec
une variable de moins (la constante
indéterminée dans <I>A</I><SUB>1</SUB> peut par exemple être choisie comme
le coefficient constant de ln(<I>Y</I>) s’il en apparait un en intégrant).</P><P><B>Exemple</B><BR>
<I>X</I>=ln(<I>x</I><SUP>2</SUP>+1) et on cherche l’intégrale de <I>X</I><SUP>2</SUP>. On a donc <I>A</I><SUB>3</SUB>
est constant,
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUB>2</SUB>′ + 3 <I>A</I><SUB>3</SUB> ln(<I>x</I><SUP>2</SUP>+1)′ = 1</TD></TR>
</TABLE><P>
La primitive de 1 est élémentaire et ne fait pas intervenir de ln
donc <I>A</I><SUB>3</SUB>=0 et <I>A</I><SUB>2</SUB>=<I>x</I>+<I>C</I><SUB>2</SUB>. Au rang 1, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUB>1</SUB>′ + 3 <I>x</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2</SUP>+1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> + <I>C</I><SUB>2</SUB> ln(<I>x</I><SUP>2</SUP>+1)′ = 0</TD></TR>
</TABLE><P>
On calcule la primitive de 6<I>x</I><SUP>2</SUP>/(<I>x</I><SUP>2</SUP>+1) qui doit être une fraction
rationnelle à un <I>C</I>ln(<I>x</I><SUP>2</SUP>+1) près, on voit que ce n’est pas le cas
donc <I>X</I><SUP>2</SUP> n’admet pas de primitive élémentaire.
Remarque: si on avait voulu intégrer <I>X</I> au lieu de <I>X</I><SUP>2</SUP>, la même
méthode montre que la primitive existe, car au rang 0 il n’y
a plus de contraintes sur les ln qu’on peut rajouter.</P><!--TOC subsubsection Extension exponentielle-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc163">17.3.6</A>  Extension exponentielle</H4><!--SEC END --><P>
Si <I>X</I>=exp(<I>Y</I>) est une exponentielle, on doit résoudre :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>A</I><SUB><I>j</I></SUB>′+<I>j</I> <I>Y</I>′<I>A</I><SUB><I>j</I></SUB>) <I>X</I><SUP><I>j</I></SUP> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUB><I>j</I></SUB> <I>X</I><SUP><I>j</I></SUP> </TD></TR>
</TABLE><P>
Ceci va se faire degré par degré :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:rischdiffeq"></A>
<I>A</I><SUB><I>j</I></SUB>′+<I>j</I> <I>Y</I>′ <I>A</I><SUB><I>j</I></SUB> = <I>a</I><SUB><I>j</I></SUB>
    (27)</TD></TR>
</TABLE><P>
<B>Exemple</B><BR>
Pour calculer ∫<I>a</I>(<I>x</I>) exp(<I>x</I><SUP>2</SUP>), on a <I>j</I>=1, et on doit résoudre
l’équation différentielle :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUB>1</SUB>′+2<I>xA</I><SUB>1</SUB>= <I>a</I>(<I>x</I>)</TD></TR>
</TABLE><P>Pour <I>j</I>=0, il suffit de faire un appel récursif à l’algorithme de Risch,
mais pour <I>j</I>≠ 0, la situation se complique!
Notons <I>Z</I> la variable située juste en-dessous de <I>X</I> dans la tour
de variables (dans l’exemple ci-dessus <I>Z</I>=<I>x</I>), il s’agit de résoudre : 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:rischdiffeq2"></A>
<I>y</I>′+<I>f</I> <I>y</I>=<I>g</I>
    (28)</TD></TR>
</TABLE><P>
avec <I>f</I>, <I>g</I> élémentaires par rapport à une tour dont le
variable au sommet est <I>Z</I>, on cherche <I>y</I> élémentaire par rapport
à cette tour (ici <I>f</I>=<I>jY</I>′ est une dérivée mais dans certains
cas nous devrons résoudre par appel récursif des équations
du type ci-dessus où <I>f</I> ne sera pas une dérivée).</P><P><B>Élimination des dénominateurs</B><BR>
Soit <I>P</I> un facteur irréductible du dénominateur de <I>y</I>, notons 
α&lt;0 la valuation de <I>y</I> par rapport à <I>P</I>, 
β celle de <I>f</I>, γ celle de <I>g</I>. 
Si <I>P</I> n’est pas une exponentielle,
la valuation de <I>y</I>′ est α−1, celle de  <I>f</I> <I>y</I>  est α +β . 
Si β ≠ −1, 
il n’y a pas de simplification possible dans le membre de gauche
donc α + min(β,−1) =γ. Autrement dit, si 
β ≥ 0 alors α=γ+1 et si β&lt;−1 
alors α=γ−β.
On observe que γ&lt;0 donc
<I>P</I> est un facteur du dénominateur <I>g</I><SUB><I>d</I></SUB> de <I>g</I>. De plus, on va montrer
que la valuation α de <I>P</I> dans <I>y</I> est l’opposé de celle
de <I>P</I> dans :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:defD"></A>
<I>D</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">gcd(<I>g</I><SUB><I>d</I></SUB>,∂<SUB><I>Z</I></SUB> <I>g</I><SUB><I>d</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">gcd(<I>c</I>,∂<SUB><I>Z</I></SUB> <I>c</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">, 
   <I>c</I>=gcd(<I>f</I><SUB><I>d</I></SUB>,<I>g</I><SUB><I>d</I></SUB>)
    (29)</TD></TR>
</TABLE><P>
En effet, si β ≥ 0, <I>P</I> ne divise pas <I>f</I><SUB><I>d</I></SUB> donc ne divise
pas <I>c</I>, donc la valuation de <I>P</I> dans <I>D</I> est −γ−1. Si β &lt; −1,
alors α=γ − β &lt;0 entraine −γ &gt; −β donc la
valuation de <I>P</I> dans <I>c</I> est −β et la valuation de <I>P</I> dans <I>D</I>
est −γ−1 − (−β−1).</P><P>Si β=−1, s’il n’y a pas de simplifications dans le membre
de gauche pour les termes de plus petite puissance en <I>P</I>, alors 
α=γ+1. S’il y a simplification,
on décompose en éléments
simples (avec Bézout) puis on ordonne par puissances croissantes
de <I>P</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>= <I>N</I><SUB>1</SUB> <I>P</I><SUP>α</SUP>+..., <I>f</I>= <I>N</I><SUB>2</SUB> <I>P</I><SUP>−1</SUP>+...,</TD></TR>
</TABLE><P>
avec <I>N</I><SUB>1</SUB>,<I>N</I><SUB>2</SUB> de degré plus petit que <I>P</I>, puis on remplace dans 
(<A HREF="#eq:rischdiffeq2">28</A>). On cherche les termes de valuation α−1
en <I>P</I> qui doivent se simplifier :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">α <I>N</I><SUB>1</SUB> <I>P</I>′ <I>P</I><SUP>α−1</SUP> + <I>N</I><SUB>2</SUB> <I>P</I><SUP>−1</SUP> <I>N</I><SUB>1</SUB> <I>P</I><SUP>α</SUP>=0 </TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I><SUB>2</SUB> = −α <I>P</I>′ </TD></TR>
</TABLE><P>
ce qui détermine α.</P><P><B>Récapitulons</B><BR>
Si <I>f</I> est une dérivée, alors β=−1 est exclus et on peut
appliquer (<A HREF="#eq:defD">29</A>) pour déterminer <I>D</I>. Si <I>f</I> n’est
pas une dérivée, on calcule les facteurs de degré 1 de <I>f</I><SUB><I>d</I></SUB> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I><SUB>1</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I><SUB><I>d</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">gcd(<I>f</I><SUB><I>d</I></SUB>,∂<SUB><I>Z</I></SUB> <I>f</I><SUB><I>d</I></SUB>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
on décompose <I>f</I> par Bézout en isolant la partie <I>N</I>/<I>f</I><SUB>1</SUB>
les α possibles sont alors les racines entières (en <I>t</I>)
du résultant en <I>Z</I> de <I>N</I>−<I>tf</I><SUB>1</SUB>′ et <I>f</I><SUB>1</SUB>, ils correspondent aux
facteurs gcd(<I>N</I>−α <I>f</I><SUB>1</SUB>′,<I>f</I><SUB>1</SUB>) que l’on retire de <I>f</I><SUB><I>d</I></SUB> pour
appliquer (<A HREF="#eq:defD">29</A>).</P><P><B>Exemple</B><BR>
Reprenons <I>y</I>′+2<I>xy</I>=<I>a</I>(<I>x</I>). Si <I>a</I>(<I>x</I>)=1 (résolution de ∫exp(<I>x</I><SUP>2</SUP>)),
ou plus généralement si <I>a</I>(<I>x</I>) est un polynôme,
alors <I>D</I>=1. Si <I>a</I>(<I>x</I>)=1/<I>x</I><SUP>2</SUP>, on trouve <I>D</I>=<I>x</I> et on pose <I>y</I>=<I>xz</I>,
donc <I>x</I><SUP>2</SUP>(<I>xz</I>′+<I>z</I>)+2<I>x</I><SUP>4</SUP><I>z</I>=1 soit <I>x</I><SUP>3</SUP><I>z</I>′+(2<I>x</I><SUP>4</SUP>+1)<I>z</I>=1.</P><P>Reste le cas où <I>Z</I> est une exponentielle et <I>P</I>=exp(<I>z</I>). On reprend
le même raisonnement, <I>y</I>′ a pour valuation −α&lt;0, <I>fy</I> a pour
valuation −β−α, donc si β &gt; 0,
α=γ et si β&lt;0, α=γ−β.
Si β=0, s’il n’y a pas de simplifications du terme de plus bas
degré, on est ramené au cas précédent. 
Si β=0 et s’il y a simplification des termes de plus
bas degré en <I>Z</I>, notons <I>f</I><SUB>0</SUB> le coefficient constant de <I>f</I> 
par rapport à <I>Z</I> et <I>y</I><SUB>α</SUB> le coefficient de <I>Z</I><SUP>α</SUP>
dans <I>y</I>, on a 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I><SUB>α</SUB>′ + (α <I>z</I>′ + <I>f</I><SUB>0</SUB>) <I>y</I><SUB>α</SUB>=0 </TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I><SUB>α</SUB>= exp(−α <I>z</I>−</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><I>f</I><SUB>0</SUB>)</TD></TR>
</TABLE><P>
Comme <I>y</I><SUB>α</SUB> est élémentaire et indépendant de <I>Z</I>
on en déduit par le théorème de structure de Risch
que −α <I>z</I> −∫<I>f</I><SUB>0</SUB> est combinaison linéaire à coefficients
rationnels des logarithmes et des arguments des exponentielles de la tour,
de plus le coefficient de <I>z</I> doit être nul pour que <I>y</I><SUB>α</SUB> soit
indépendant de <I>Z</I>, ce qui impose la valeur de α (après avoir
résolu récursivement le problème d’intégration pour <I>f</I><SUB>0</SUB>)</P><P><B>Majoration du degré du numérateur de </B><B><I>y</I></B><BR>
En multipliant <I>y</I> par <I>D</I> <I>Z</I><SUP>−α</SUP>, puis en réduisant au
même dénominateur,
on se ramène alors à une équation différentielle à coefficients
polynomiaux par rapport à la variable <I>Z</I> dont l’inconnue est un polynôme 
<I>N</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:rischdepol"></A>
<I>R</I> <I>N</I>′ + <I>S</I> <I>N</I> = <I>T</I>
    (30)</TD></TR>
</TABLE><P>
On va chercher une majoration sur le degré possible de <I>N</I> puis
utiliser l’identité de Bézout pour simplifier
cette équation. </P><P>On écrit maintenant <I>N</I>=∑<SUB><I>k</I>=0</SUB><SUP><I>n</I></SUP> <I>N</I><SUB><I>k</I></SUB> <I>Z</I><SUP><I>k</I></SUP> et on remplace, 
il y a à nouveau trois cas selon le type de <I>Z</I>.</P><P><B>Si </B><B><I>Z</I>=<I>x</I></B><B>: cas exponentielle rationnelle</B><BR>
Donc <I>Z</I>′=1, le degré de <I>RN</I>′ est <I>r</I>+<I>n</I>−1 (si <I>N</I> est non constant
c’est-à-dire si <I>T</I> n’est pas un multiple de <I>S</I>), le degré de
<I>SN</I> est <I>s</I>+<I>n</I>. Si <I>r</I>−1≠ <I>s</I>, on en déduit que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>n</I>=<I>t</I>−max(<I>r</I>−1,<I>s</I>)</TD></TR>
</TABLE><P>
Si <I>r</I>−1=<I>s</I>, on peut avoir
une simplification du terme de plus haut degré <I>s</I>+<I>n</I> (sinon
on est dans le cas précédent) si <I>n</I> <I>R</I><SUB><I>r</I></SUB> =<I>S</I><SUB><I>s</I></SUB> 
d’où on déduit le degré <I>n</I> de <I>N</I>.</P><P>Par exemple, pour <I>y</I>′+2<I>xy</I>=<I>T</I> ou pour <I>x</I><SUP>3</SUP><I>z</I>′+(2<I>x</I><SUP>4</SUP>+1)<I>z</I>=1 on a <I>r</I>=<I>s</I>−1 donc
<I>n</I>+<I>s</I>=<I>t</I>, donc pas de solution dans le deuxième cas, dans le premier cas
il ne peut y avoir de solutions que si <I>t</I> ≥ <I>s</I>, en particulier
il n’y a pas de solution pour <I>t</I>=1, on a donc démontré que ∫exp(<I>x</I><SUP>2</SUP>)
n’admet pas de primitive élémentaire.</P><P><B>Si </B><B><I>Z</I>=</B><B>exp</B><B>(<I>z</I>)</B><B>: cas exponentielle d’exponentielle</B><BR>
Ici les <I>N</I><SUB><I>k</I></SUB> peuvent ne pas être constants, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I>′=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>N</I><SUB><I>k</I></SUB>′+<I>kN</I><SUB><I>k</I></SUB> <I>z</I>′) <I>Z</I><SUP><I>k</I></SUP></TD></TR>
</TABLE><P>
Comme on l’a déjà observé, <I>N</I><SUB><I>n</I></SUB>′+<I>n</I> <I>N</I><SUB><I>n</I></SUB> <I>z</I>′≠ 0, donc le
degré de <I>N</I>′ est égal au degré de <I>N</I>. On a donc trois cas :
</P><UL CLASS="itemize"><LI CLASS="li-itemize"> 
si <I>r</I>≠ <I>s</I>, alors <I>n</I>=<I>t</I>−max(<I>r</I>,<I>s</I>)
</LI><LI CLASS="li-itemize">si <I>r</I>=<I>s</I> et les termes de plus haut degré du membre de gauche ne
se simplifient pas, alors, <I>n</I>=<I>t</I>−<I>r</I>=<I>t</I>−<I>s</I>.
</LI><LI CLASS="li-itemize">si <I>r</I>=<I>s</I> et s’il y a simplification, alors :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>R</I><SUB><I>r</I></SUB>(<I>N</I><SUB><I>n</I></SUB>′+<I>nN</I><SUB><I>n</I></SUB><I>z</I>′)+<I>S</I><SUB><I>s</I></SUB><I>N</I><SUB><I>n</I></SUB>=0 </TD></TR>
</TABLE>
donc :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I><SUB><I>n</I></SUB>′ + (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>S</I><SUB><I>s</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>R</I><SUB><I>r</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">+<I>nz</I>′)<I>N</I><SUB><I>n</I></SUB> = 0</TD></TR>
</TABLE>
et :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I><SUB><I>n</I></SUB> = <I>C</I> exp(−<I>nz</I>−</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>S</I><SUB><I>s</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>R</I><SUB><I>r</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">) </TD></TR>
</TABLE>
On appelle alors l’algorithme de Risch avec une variable de moins (<I>S</I><SUB><I>s</I></SUB>
et <I>R</I><SUB><I>r</I></SUB> ne dépendent plus de <I>Z</I>) pour calculer <I>I</I>=∫<I>S</I><SUB><I>s</I></SUB>/<I>R</I><SUB><I>r</I></SUB>. 
Il s’agit alors de trouver <I>n</I> tel que l’exponentielle précédente
soit élémentaire et indépendante de la variable <I>Z</I>. Le théorème
de structure de Risch implique que −<I>nz</I>−∫<I>S</I><SUB><I>s</I></SUB>/<I>R</I><SUB><I>r</I></SUB> est combinaison 
linéaire à coefficients rationnels des logarithmes et des arguments 
des exponentielles de autres variables de la tour (jusqu’à <I>z</I> non compris).
Ceci permet de déterminer <I>n</I> de manière unique (c’est le coefficient
rationnel de ∫<I>S</I><SUB><I>s</I></SUB>/<I>R</I><SUB><I>r</I></SUB> en <I>z</I>).
</LI></UL><P><B>Si </B><B><I>Z</I>=</B><B>ln</B><B>(<I>z</I>)</B><B>: exponentielle de logarithme</B><BR>
Ici aussi, les <I>N</I><SUB><I>k</I></SUB> peuvent ne pas être constants, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I>′=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>N</I><SUB><I>k</I></SUB>′<I>Z</I><SUP><I>k</I></SUP>+<I>kN</I><SUB><I>k</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>z</I>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>z</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Z</I><SUP><I>k</I>−1</SUP>)</TD></TR>
</TABLE><P>
Si <I>N</I><SUB><I>n</I></SUB> n’est pas constant, le terme de plus haut degré de 
<I>RN</I>′ est <I>N</I><SUB><I>n</I></SUB>′ <I>R</I><SUB><I>r</I></SUB> <I>Z</I><SUP><I>n</I>+<I>r</I></SUP>, si <I>N</I><SUB><I>n</I></SUB> est constant, 
le terme de plus haut degré de <I>RN</I>′ est <I>R</I><SUB><I>r</I></SUB>(<I>nN</I><SUB><I>n</I></SUB><I>z</I>′/<I>z</I>+<I>N</I><SUB><I>n</I>−1</SUB>′) <I>Z</I><SUP><I>r</I>−1</SUP> 
qui est non nul (sinon <I>z</I>′/<I>z</I>=<I>CN</I><SUB><I>n</I>−1</SUB>′ et <I>z</I>=exp(<I>CN</I><SUB><I>n</I>−1</SUB>) serait 
une exponentielle).
Le terme de plus haut degré de <I>SN</I> est <I>N</I><SUB><I>n</I></SUB> <I>S</I><SUB><I>s</I></SUB> <I>Z</I><SUP><I>n</I>+<I>s</I></SUP>.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>r</I>&lt;<I>s</I> ou si <I>r</I>=<I>s</I> sans simplifications,
alors <I>n</I>=<I>t</I>−<I>s</I>.
</LI><LI CLASS="li-itemize">Si <I>r</I>&gt;<I>s</I>+1 ou si <I>r</I>=<I>s</I>+1 sans simplifications,
alors deg(<I>N</I>′)=<I>t</I>−<I>r</I> donc <I>n</I>=<I>t</I>−<I>r</I> ou <I>n</I>=<I>t</I>−<I>r</I>+1.
</LI><LI CLASS="li-itemize">Si <I>r</I>=<I>s</I>+1, et s’il y a simplifications, alors <I>N</I><SUB><I>n</I></SUB> est constant et :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>R</I><SUB><I>r</I></SUB>(<I>nN</I><SUB><I>n</I></SUB><I>z</I>′/<I>z</I>+<I>N</I><SUB><I>n</I>−1</SUB>′)+ <I>S</I><SUB><I>s</I></SUB> <I>N</I><SUB><I>n</I></SUB> = 0 </TD></TR>
</TABLE>
alors <I>N</I><SUB><I>n</I>−1</SUB>=<I>C</I> (−∫<I>N</I><SUB><I>n</I></SUB> <I>S</I><SUB><I>s</I></SUB>/<I>R</I><SUB><I>r</I></SUB> −<I>n</I> <I>N</I><SUB><I>n</I></SUB> ln(<I>z</I>))
doit être élémentaire et indépendante de <I>Z</I> donc ∫<I>S</I><SUB><I>s</I></SUB>/<I>R</I><SUB><I>r</I></SUB>
est élémentaire, on détermine <I>n</I> en éliminant le coefficient de 
<I>Z</I>=ln(<I>z</I>) provenant de ∫<I>S</I><SUB><I>s</I></SUB>/<I>R</I><SUB><I>r</I></SUB>.
</LI><LI CLASS="li-itemize">Si <I>r</I>=<I>s</I>, et s’il y a simplification des termes 
de plus haut degré du membre de gauche, 
alors <I>N</I><SUB><I>n</I></SUB>′ <I>R</I><SUB><I>r</I></SUB>+<I>N</I><SUB><I>n</I></SUB> <I>S</I><SUB><I>s</I></SUB>=0 donc <I>N</I><SUB><I>n</I></SUB>=exp(−∫<I>S</I><SUB><I>s</I></SUB>/<I>R</I><SUB><I>r</I></SUB>)
est élémentaire et indépendante de <I>Z</I>. On peut donc changer
d’inconnue <I>N</I>=<I>N</I><SUB><I>n</I></SUB> <I>M</I> sans changer le fait que <I>M</I> est un polynôme de
même degré que <I>N</I>. On se ramène alors à une équation du même type
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>RM</I>′+(<I>S</I>−<I>R</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>S</I><SUB><I>s</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>R</I><SUB><I>r</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">)<I>M</I>= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>T</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE>
mais avec <I>s</I> diminué de 1 au moins.
</LI></UL><P><B>Réduction (algorithme SPDE de Rothstein)</B><A NAME="@default195"></A><BR>
On observe d’abord que si <I>R</I> et <I>S</I> ont un facteur
en commun, alors ce facteur divise <I>T</I> car <I>N</I>′ et <I>N</I> sont des polynômes
en <I>Z</I>. On peut donc quitte à simplifier par gcd(<I>R</I>,<I>S</I>) se ramener
au cas où <I>R</I> et <I>S</I> sont premiers entre eux, il existe donc deux
polynômes <I>U</I> et <I>V</I> tels que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:rischdebezout"></A>
<I>RU</I>+<I>SV</I>=<I>T</I>,    deg(<I>V</I>)&lt; deg(<I>R</I>)
    (31)</TD></TR>
</TABLE><P>
En soustrayant (<A HREF="#eq:rischdebezout">31</A>) de (<A HREF="#eq:rischdepol">30</A>), 
on montre que <I>R</I> divise <I>N</I>−<I>V</I>. Soit <I>H</I>=(<I>N</I>−<I>V</I>)/<I>R</I>. Alors <I>N</I>=<I>RH</I>+<I>V</I> donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>R</I> (<I>RH</I>′+<I>R</I>′<I>H</I>+<I>V</I>′)+<I>SRH</I>+<I>SV</I>= <I>T</I>=<I>RU</I>+<I>SV</I></TD></TR>
</TABLE><P>
donc après simplification par <I>SV</I> et division par <I>R</I>, 
<I>H</I> vérifie l’équation :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>R</I> <I>H</I>′ + (<I>S</I>+<I>R</I>′) <I>H</I> = <I>U</I> − <I>V</I>′</TD></TR>
</TABLE><P>
C’est une équation du même type mais avec deg(<I>H</I>)=deg(<I>N</I>)-deg(<I>R</I>)
ou <I>H</I>=0 (si <I>N</I>=<I>V</I>).
Donc si deg(<I>R</I>)&gt;0, au bout d’un nombre fini d’étapes on doit 
tomber sur un second membre nul ou des simplifications de <I>R</I> avec <I>S</I>+<I>R</I>′
telles que <I>R</I> simplifié soit constant en <I>Z</I>.</P><P><B>Résolution</B><BR>
Si <I>R</I> est constant par rapport à <I>Z</I>, 
on simplifie par <I>R</I> et on doit résoudre 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I>′+<I>SN</I>=<I>T</I> </TD></TR>
</TABLE><P>
Si <I>S</I>=0, c’est un problème d’intégration. Supposons donc que
<I>S</I>≠ 0. Si <I>S</I> est non constant par rapport à <I>Z</I> ou si
<I>Z</I>=<I>x</I>, le degré de <I>N</I>′ est strictement inférieur 
au degré de <I>SN</I>, on peut donc facilement résoudre.
Reste le cas où <I>S</I>=<I>b</I> est constant non nul par rapport à <I>Z</I> et <I>Z</I> est
une exponentielle ou un logarithme.</P><P><B>Si </B><B><I>Z</I>=</B><B>exp</B><B>(<I>z</I>)</B><BR>
On a alors doit alors résoudre 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I><SUB><I>k</I></SUB>′+ <I>k</I> <I>N</I><SUB><I>k</I></SUB> <I>z</I>′ + <I>b</I> <I>N</I><SUB><I>k</I></SUB>=<I>T</I><SUB><I>k</I></SUB> </TD></TR>
</TABLE><P>
c’est une équation différentielle de Risch mais avec une variable de 
moins.</P><P><B>Si </B><B><I>Z</I>=</B><B>ln</B><B>(<I>z</I>)</B><BR>
On doit alors résoudre 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I><SUB><I>k</I></SUB>′+ (<I>k</I>+1) <I>N</I><SUB><I>k</I>+1</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>z</I>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>z</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + <I>b</I> <I>N</I><SUB><I>k</I></SUB> =<I>T</I><SUB><I>k</I></SUB> </TD></TR>
</TABLE><P>
c’est aussi une équation différentielle de Risch avec une
variable de moins.</P><P><B>Exemple</B><BR>
Voyons comment on intègre <I>x</I><SUP><I>n</I></SUP> avec <I>n</I> un paramètre par l’algorithme
de Risch (cela illustre les possibilités couvertes par l’algorithme
mais aussi l’efficacité des méthodes traditionnelles d’intégration
lorsqu’elles s’appliquent).
On écrit d’abord <I>x</I><SUP><I>n</I></SUP>=<I>e</I><SUP><I>n</I> ln(<I>x</I>)</SUP>, donc la tour de variables
est { <I>x</I>, <I>Z</I>=ln(<I>x</I>), <I>X</I>=<I>e</I><SUP><I>n</I> ln(<I>x</I>)</SUP>}, il s’agit donc d’intégrer
<I>X</I> qui est un polynôme généralisé. On cherche donc <I>A</I><SUB>1</SUB> solution
de l’équation différentielle de Risch 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUB>1</SUB>′+ <I>n</I> /<I>x</I> <I>A</I><SUB>1</SUB>=1 </TD></TR>
</TABLE><P>
Par rapport à <I>Z</I>=ln(<I>x</I>) la fonction <I>f</I>=<I>n</I>/<I>x</I> est un polynôme, donc on
applique le dernier cas ci-dessus, <I>A</I><SUB>1</SUB> est aussi indépendant de ln(<I>x</I>)
et on se ramène à résoudre la même équation mais avec comme variable
principale <I>x</I> et non <I>Z</I>. Cette fois, il y a un dénominateur <I>x</I> en <I>f</I>.
Si <I>A</I><SUB>1</SUB> possède un dénominateur, il faut qu’il y ait annulation
du terme de plus bas degré en <I>x</I> car le second membre n’a pas de
dénominateur, on obtient <I>n</I>+α=0 qui n’a pas de solution, donc
<I>A</I><SUB>1</SUB> est un polynôme en <I>x</I> et l’équation se réécrit en :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>xA</I><SUB>1</SUB>′+<I>nA</I><SUB>1</SUB>=<I>x</I></TD></TR>
</TABLE><P>
On majore alors le degré en <I>x</I> de <I>A</I><SUB>1</SUB> par 1, car il ne peut pas y avoir
d’annulation de terme de plus grand degré. Ensuite, on peut appliquer
l’algorithme SPDE de Rothstein pour réduire le degré, ou ici conclure
à la main, <I>x</I> divise <I>nA</I><SUB>1</SUB> donc <I>A</I><SUB>1</SUB>=<I>Cx</I> qu’on remplace et <I>C</I>=1/(<I>n</I>+1).
Finalement, <I>A</I><SUB>1</SUB>=<I>x</I>/(<I>n</I>+1) et ∫<I>x</I><SUP><I>n</I></SUP>=<I>x</I>/(<I>n</I>+1)  <I>x</I><SUP><I>n</I></SUP>.</P><!--TOC subsection Quelques références-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc164">17.4</A>  Quelques références</H3><!--SEC END --><P> <A NAME="sec:rischref"></A>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
M. Bronstein:<BR>
Symbolic Integration I, Transcendental functions, Springer</LI><LI CLASS="li-itemize">M. Bronstein:<BR>
Integration tutorial,<BR>
<CODE>http://www-sop.inria.fr/cafe/Manuel.Bronstein/publications/mb_papers.html</CODE></LI><LI CLASS="li-itemize">J.H. Davenport, Y. Siret, E. Tournier:<BR>
Calcul formel: Systèmes et algorithmes 
de manipulations algébriques</LI><LI CLASS="li-itemize">R. Risch:<BR>
les références des articles originaux de Risch sont dans
le “Integration tutorial” de Bronstein.</LI><LI CLASS="li-itemize">B. Trager:<BR>
PHD thesis MIT, 1984</LI><LI CLASS="li-itemize">On peut lire en clair le code source de l’implémentation en MuPAD
(sous Unix, désarchiver le fichier <TT>lib.tar</TT> du répertoire
<TT>/usr/local/MuPAD/share/lib</TT> et regarder dans le sous-répertoire
<TT>lib/INTLIB</TT>)</LI></UL><!--TOC section Intégration numérique-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc165">18</A>  Intégration numérique</H2><!--SEC END --><P> <A NAME="sec:intnum"></A><A NAME="@default196"></A> <A NAME="@default197"></A>
Les fractions rationnelles admettent une primitive que l’on calcule
en décomposant la fraction avec Bézout comme expliqué précédemment.
Mais elles font figure d’exceptions,
la plupart des fonctions n’admettent pas de primitives qui s’expriment
à l’aide des fonctions usuelles. Pour calculer une intégrale, on
revient donc à la définition d’aire sous la courbe, aire que
l’on approche, en utilisant par exemple un polynome de Lagrange.</P><P>Le principe est donc le suivant : on découpe l’intervalle d’intégration
en subdivisions [<I>a</I>,<I>b</I>]=[<I>a</I>,<I>a</I>+<I>h</I>] + [<I>a</I>+<I>h</I>,<I>a</I>+2<I>h</I>]+...[<I>a</I>+(<I>n</I>−1)<I>h</I>,<I>a</I>+<I>nh</I>=<I>b</I>, où
<I>h</I>=(<I>b</I>−<I>a</I>)/<I>n</I> est le pas de la subdivision, et
sur chaque subdivision, on approche l’aire sous la courbe.</P><!--TOC subsection Les rectangles et les trapèzes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc166">18.1</A>  Les rectangles et les trapèzes</H3><!--SEC END --><P>
Sur une subdivision [α,β], on approche la fonction par un segment.
Pour les rectangles, il s’agit d’une horizontale : on peut prendre 
<I>f</I>(α), <I>f</I>(β) (rectangle à droite et gauche)
ou <I>f</I>((α+β)/2) (point milieu), pour les trapèzes on utilise
le segment reliant [α,<I>f</I>(α)] à [β,<I>f</I>(β)].</P><P>Exemple : calcul de la valeur approchée de ∫<SUB>0</SUB><SUP>1</SUP> <I>t</I><SUP>3</SUP> <I>dt</I>
(on en connait la valeur exacte 1/4=0.25) par ces méthodes en subdivisant
[0,1] en 10 subdivisions (pas <I>h</I>=1/10), donc α=<I>j</I>/10 et β=(<I>j</I>+1)/10
pour <I>j</I> variant de 0 à 9.
Pour les rectangles à gauche, on obtient sur une subdivision
<I>f</I>(α)=(<I>j</I>/10)<SUP>3</SUP>  que l’on multiplie par la longueur de la subdivision 
soit <I>h</I>=1/10 :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">10</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">9</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">10</TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>3</SUP>  = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">81</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">400</TD></TR>
</TABLE></TD><TD CLASS="dcell"> = 0.2025</TD></TR>
</TABLE><P>
Pour les rectangles à droite, on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">10</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">10</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">10</TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>3</SUP>  = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">121</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">400</TD></TR>
</TABLE></TD><TD CLASS="dcell"> = 0.3025</TD></TR>
</TABLE><P>
Pour le point milieu <I>f</I>((α+β)/2)=<I>f</I>((<I>j</I>/10+(<I>j</I>+1)/10)/2)=<I>f</I>(<I>j</I>/10+1/20)
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">10</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">9</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">10</TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">20</TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>3</SUP>  = 199/800 = 0.24875</TD></TR>
</TABLE><P>
Enfin pour les trapèzes, l’aire du trapèze délimité par l’axe des <I>x</I>,
les verticales <I>y</I>=α, <I>y</I>=β et les points sur ces verticales
d’ordonnées respectives <I>f</I>(α) et <I>f</I>(β) vaut
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>h</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I>(α)+<I>f</I>(β)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">10</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">9</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">10</TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>3</SUP> +(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>j</I>+1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">10</TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>3</SUP>
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">= 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">101</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">400</TD></TR>
</TABLE></TD><TD CLASS="dcell"> = 0.2525 </TD></TR>
</TABLE><P>
Dans la somme des trapèzes, on voit que chaque terme apparait deux fois
sauf le premier et le dernier.</P><P>Plus généralement, les formules sont donc les suivantes :
<A NAME="@default198"></A> <A NAME="@default199"></A> <A NAME="@default200"></A>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">


     

</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>rectangle gauche</TD><TD ALIGN=center NOWRAP> =</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> <I>h</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>a</I>+<I>jh</I>) <A NAME="eq:rectangle_gauche"> </A></TD></TR>
</TABLE></TD><TD ALIGN=right NOWRAP>    (32)</TD></TR>
<TR><TD ALIGN=right NOWRAP>rectangle droit</TD><TD ALIGN=center NOWRAP> =</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> <I>h</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>a</I>+<I>jh</I>) <A NAME="eq:rectangle_droit"> </A></TD></TR>
</TABLE></TD><TD ALIGN=right NOWRAP>    (33)</TD></TR>
<TR><TD ALIGN=right NOWRAP>point milieu</TD><TD ALIGN=center NOWRAP> =</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> <I>h</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>a</I>+<I>jh</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">) 
<A NAME="eq:point_milieu"> </A></TD></TR>
</TABLE></TD><TD ALIGN=right NOWRAP>    (34)</TD></TR>
<TR><TD ALIGN=right NOWRAP> trapezes </TD><TD ALIGN=center NOWRAP> =</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> 
<I>h</I> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I>(<I>a</I>)+<I>f</I>(<I>b</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>a</I>+<I>jh</I>) </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
<A NAME="eq:trapezes"> </A>
</TD></TR>
</TABLE></TD><TD ALIGN=right NOWRAP>    (35)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
où <I>h</I>=(<I>b</I>−<I>a</I>)/<I>n</I> est le pas de la subdivision, <I>n</I> le nombre de subdivisions.</P><P>On observe sur l’exemple que le point milieu et les trapèzes donnent
une bien meilleure précision que les rectangles. Plus généralement,
la précision de l’approximation n’est pas la même selon le choix
de méthode.
Ainsi pour les rectangles à gauche (le résultat est le même
à droite), si <I>f</I> est continument dérivable, de dérivée majorée
par une constante <I>M</I><SUB>1</SUB> sur [<I>a</I>,<I>b</I>], en faisant un
développement de Taylor de <I>f</I> en α, on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>t</I>) <I>dt</I> − </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(α) <I>dt</I> |
= | </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>′(θ<SUB><I>t</I></SUB>)(<I>t</I>−α) <I>dt</I> |
≤ <I>M</I><SUB>1</SUB> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>t</I>−α) <I>dt</I> = <I>M</I><SUB>1</SUB></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(β−α)<SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Ainsi dans l’exemple, on a <I>M</I><SUB>1</SUB>=3, l’erreur est donc majorée par 0.015
sur une subdivision, donc par 0.15 sur les 10 subdivisions.</P><P>Pour le point milieu, on fait le développement en (α+β)/2 à l’ordre
2, en supposant que <I>f</I> est deux fois continument dérivable :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> |</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>t</I>)  − </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">α+β</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)  |</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">| </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>′(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">α+β</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)(<I>t</I>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">α+β</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">) <I>dt</I></TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">+  </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I>′′(θ<SUB><I>t</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>t</I>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">α+β</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>2</SUP> |</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>M</I><SUB>2</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 2 </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">α+β</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
(<I>t</I>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">α+β</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>2</SUP> <I>dt</I>  </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I><SUB>2</SUB></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(β−α)<SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">24</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Dans l’exemple, on a <I>M</I><SUB>2</SUB>=6, donc l’erreur sur une subdivision est
majorée par 0.25<I>e</I>−3, donc sur 10 subdivisions par 0.25<I>e</I>−2=0.0025.</P><P>Pour les trapèzes, la fonction <I>g</I> dont le graphe est le segment reliant
[α,<I>f</I>(α)] à [β,<I>f</I>(β)] est <I>f</I>(α)+(<I>t</I>−α)/(β−α)<I>f</I>(β),
c’est en fait un polynome de Lagrange, si <I>f</I> est deux fois continument
dérivable, on peut donc majorer la différence
entre <I>f</I> et <I>g</I> en utilisant (<A HREF="#eq:lagrange">54</A>), on intègre la valeur
absolue ce qui donne
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>t</I>) <I>dt</I> − </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>g</I>(<I>t</I>) <I>dt</I> |
≤ </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I>′′(ξ<SUB><I>x</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>x</I>−α)(<I>x</I>−β)|
≤ <I>M</I><SUB>2</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(β−α)<SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">12</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
où <I>M</I><SUB>2</SUB> est un majorant de |<I>f</I>′′| sur [<I>a</I>,<I>b</I>].</P><P>Lorsqu’on calcule l’intégrale sur [<I>a</I>,<I>b</I>] par une de ces méthodes,
on fait la somme sur <I>n</I>=(<I>b</I>−<I>a</I>)/<I>h</I> subdivisions de longueur 
β−α=<I>h</I>, on obtient
donc une majoration de l’erreur commise sur l’intégrale :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
pour les rectangles à droite ou gauche <I>nM</I><SUB>1</SUB><I>h</I><SUP>2</SUP>/2=<I>M</I><SUB>1</SUB> <I>h</I> (<I>b</I>−<I>a</I>)/2
</LI><LI CLASS="li-itemize">pour le point milieu <I>M</I><SUB>2</SUB> <I>h</I><SUP>2</SUP> (<I>b</I>−<I>a</I>)/24
</LI><LI CLASS="li-itemize">pour les trapèzes <I>M</I><SUB>2</SUB><I>h</I><SUP>2</SUP> (<I>b</I>−<I>a</I>)/12.
</LI></UL><P>
Lorsque <I>h</I> tend vers 0, l’erreur tend vers 0, mais pas à la même vitesse,
plus rapidement pour les trapèzes et le point milieu
que pour les rectangles. Plus on
approche précisément la fonction sur une subdivision, plus la
puissance de <I>h</I> va être grande, plus la convergence sera rapide
lorsque <I>h</I> sera petit, avec toutefois une contrainte fixée par la
valeur de <I>M</I><SUB><I>k</I></SUB>, borne sur la dérivée <I>k</I>-ième de <I>f</I> (plus
<I>k</I> est grand, plus <I>M</I><SUB><I>k</I></SUB> est grand en général). Nous allons voir dans la suite
comment se comporte cette puissance de <I>h</I> en fonction de la facon
dont on approche <I>f</I>.</P><!--TOC subsection Ordre d’une méthode-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc167">18.2</A>  Ordre d’une méthode</H3><!--SEC END --><P> <A NAME="@default201"></A>
On appelle méthode d’intégration l’écriture d’une approximation
de l’intégrale sur une subdivision sous la forme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>t</I>) <I>dt</I> ≈ <I>I</I>(<I>f</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>w</I><SUB><I>j</I></SUB> <I>f</I>(<I>y</I><SUB><I>j</I></SUB>) </TD></TR>
</TABLE><P>
où les <I>y</I><SUB><I>j</I></SUB> sont dans l’intervalle [α,β], par exemple équirépartis
sur [α,β]. On utilise aussi la définition :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>t</I>) <I>dt</I> ≈ <I>I</I>(<I>f</I>)=
(β−α)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> w<SUB><I>j</I></SUB> <I>f</I>(<I>y</I><SUB><I>j</I></SUB>) </TD></TR>
</TABLE><P>
On prend toujours ∑<SUB><I>j</I></SUB> <I>w</I><SUB><I>j</I></SUB>=β−α (ou ∑<SUB><I>j</I></SUB> w<SUB><I>j</I></SUB>=1) pour
que la méthode donne le résultat exact si la fonction est constante.</P><P>On dit qu’une méthode d’intégration est d’ordre <I>n</I> si il y a égalité
ci-dessus pour tous les polynômes de degré inférieur ou égal à <I>n</I>
et non égalité pour un polynôme de degré <I>n</I>+1.
Par exemple, les rectangles à droite et gauche sont d’ordre 0, 
le point milieu et les trapèzes sont d’ordre 1. Plus
généralement, si on approche <I>f</I> par son polynôme
d’interpolation de Lagrange en <I>n</I>+1 points (donc par un polynôme
de degré inférieur ou égal à <I>n</I>), on obtient une méthode
d’intégration d’ordre au moins <I>n</I>.</P><P>Si une méthode est d’ordre <I>n</I> avec des <I>w</I><SUB><I>j</I></SUB>≥ 0 et 
si <I>f</I> est <I>n</I>+1 fois continument dérivable,
alors sur une subdivision, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:majoration_err"></A>
|</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>−<I>I</I>(<I>f</I>)| ≤ <I>M</I><SUB><I>n</I>+1</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(β−α)<SUP><I>n</I>+2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell">
(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>+2</TD></TR>
</TABLE></TD><TD CLASS="dcell">+1)
    (36)</TD></TR>
</TABLE><P>En effet, on fait le développement de Taylor de <I>f</I> par exemple
en α à l’ordre <I>n</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>f</I>(<I>t</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>T</I><SUB><I>n</I></SUB>(<I>f</I>)+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>t</I>−α)<SUP><I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I><SUP>[<I>n</I>+1]</SUP>(θ<SUB><I>t</I></SUB>),</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP> <I>T</I><SUB><I>n</I></SUB>(<I>f</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(α)+(<I>t</I>−α)<I>f</I>′(α)+...+ 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>t</I>−α)<SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I><SUP>[<I>n</I>]</SUP>(α)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Donc 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>− </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>T</I><SUB><I>n</I></SUB>(<I>f</I>)|
≤ </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>t</I>−α)<SUP><I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |<I>f</I><SUP>[<I>n</I>+1]</SUP>(θ<SUB><I>t</I></SUB>)| 
≤ </TD><TD CLASS="dcell">⎡<BR>
⎢<BR>
⎢<BR>
⎣</TD><TD CLASS="dcell"><I>M</I><SUB><I>n</I>+1</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>t</I>−α)<SUP><I>n</I>+2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+2)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎤<BR>
⎥<BR>
⎥<BR>
⎦</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
De plus, 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> |<I>I</I>(<I>f</I>) −<I>I</I>(<I>T</I><SUB><I>n</I></SUB>(<I>f</I>))| =|<I>I</I></TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><I>f</I><SUP>[<I>n</I>+1]</SUP>(θ<SUB><I>t</I></SUB>)
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>t</I>−α)<SUP><I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">|</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |<I>w</I><SUB><I>j</I></SUB>| <I>M</I><SUB><I>n</I>+1</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>y</I><SUB><I>j</I></SUB>−α)<SUP><I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |<I>w</I><SUB><I>j</I></SUB>| <I>M</I><SUB><I>n</I>+1</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(β−α)<SUP><I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Donc comme la méthode est exacte pour <I>T</I><SUB><I>n</I></SUB>(<I>f</I>), on en déduit que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>−<I>I</I>(<I>f</I>)|</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>−</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>T</I><SUB><I>n</I></SUB>(<I>f</I>)+<I>I</I>(<I>T</I><SUB><I>n</I></SUB>(<I>f</I>))− <I>I</I>(<I>f</I>)| </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>−</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>T</I><SUB><I>n</I></SUB>(<I>f</I>)|+|<I>I</I>(<I>T</I><SUB><I>n</I></SUB>(<I>f</I>))− <I>I</I>(<I>f</I>)|</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I><SUB><I>n</I>+1</SUB>  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(β−α)<SUP><I>n</I>+2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+2)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> +  
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |<I>w</I><SUB><I>j</I></SUB>| <I>M</I><SUB><I>n</I>+1</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(β−α)<SUP><I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Si les <I>w</I><SUB><I>j</I></SUB>≥ 0, alors ∑<SUB><I>j</I>=1</SUB><SUP><I>k</I></SUP> |<I>w</I><SUB><I>j</I></SUB>|=∑<SUB><I>j</I>=1</SUB><SUP><I>k</I></SUP> <I>w</I><SUB><I>j</I></SUB>=β−α
et on obtient finalement (<A HREF="#eq:majoration_err">36</A>)</P><P>On remarque qu’on peut améliorer la valeur de la constante 
en faisant tous les développement de Taylor
en (α+β)/2 au lieu de α, 
Après sommation sur les <I>n</I> subdivisions, on obtient que :
</P><DIV CLASS="theorem"><B>Théorème 33</B>  <EM>
Pour une méthode d’ordre </EM><EM><I>n</I></EM><EM> à coefficients positifs et une fonction </EM><EM><I>f</I></EM><EM>
</EM><EM><I>n</I>+1</EM><EM> fois continument dérivable 
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>|</EM></TD><TD CLASS="dcell"><EM><FONT SIZE=6>∫</FONT></EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><EM><EM><I>b</I></EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><BR>
<BR>
</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><EM><EM><I>a</I></EM></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> <I>f</I>−<I>I</I>(<I>f</I>)| ≤ <I>M</I></EM><SUB><EM><I>n</I>+1</EM></SUB><EM> </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>h</I></EM><SUP><EM><I>n</I>+1</EM></SUP></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM>2</EM><SUP><EM><I>n</I>+1</EM></SUP><EM>(<I>n</I>+1)!</EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>  (<I>b</I>−<I>a</I>) 
(</EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM>1</EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM>(<I>n</I>+2)</EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>+1)</EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>On observe que cette majoration a la bonne puissance de <I>h</I> sur
les exemples déja traités, mais pas forcément le meilleur coefficient
possible, parce que nous avons traité le cas général d’une
méthode d’ordre <I>n</I>, et utilisé une majoration pas toujours
optimale du reste. Pour obtenir la meilleure valeur possible de la
constante, il faut exprimer le reste de la formule de Taylor sous
forme intégrale et utiliser la forme précise de la méthode :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>t</I>)=<I>T</I><SUB><I>n</I></SUB>(<I>f</I>)(<I>t</I>)+</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>t</I>−<I>x</I>)<SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I><SUP>[<I>n</I>+1]</SUP>(<I>x</I>) 
<I>dx</I> </TD></TR>
</TABLE><P>
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>− </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>T</I><SUB><I>n</I></SUB>(<I>f</I>)
= </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>t</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>t</I>−<I>x</I>)<SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
<I>f</I><SUP>[<I>n</I>+1]</SUP>(<I>x</I>)  <I>dx</I>  <I>dt</I>
= </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>t</I>−<I>x</I>)<SUB>+</SUB><SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
<I>f</I><SUP>[<I>n</I>+1]</SUP>(<I>x</I>)  <I>dx</I>  <I>dt</I>
</TD></TR>
</TABLE><P>
où (<I>t</I>−<I>x</I>)<SUB>+</SUB>=max(0,<I>t</I>−<I>x</I>). En intervertissant les deux intégrales
(Fubini), on obtient :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>− </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>T</I><SUB><I>n</I></SUB>(<I>f</I>)</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>t</I>−<I>x</I>)<SUB>+</SUB><SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
 <I>dt</I> <I>f</I><SUP>[<I>n</I>+1]</SUP>(<I>x</I>)  <I>dx</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>t</I>−<I>x</I>)<SUB>+</SUB><SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> 
<I>f</I><SUP>[<I>n</I>+1]</SUP>(<I>x</I>)  <I>dx</I></TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(β−<I>x</I>)<SUP><I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I><SUP>[<I>n</I>+1]</SUP>(<I>x</I>)  <I>dx</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
D’autre part :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>I</I>(<I>f</I>)−<I>I</I>(<I>T</I><SUB><I>n</I></SUB>(<I>f</I>))</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>I</I></TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>x</I>−<I>t</I>)<SUB>+</SUB><SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>f</I><SUP>[<I>n</I>+1]</SUP>(<I>t</I>)  <I>dt</I> 
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>w</I><SUB><I>j</I></SUB> 
</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>y</I><SUB><I>i</I></SUB>−<I>t</I>)<SUB>+</SUB><SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I><SUP>[<I>n</I>+1]</SUP>(<I>t</I>)  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>−<I>I</I>(<I>f</I>)
= </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
( </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(β−<I>x</I>)<SUP><I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> −  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>w</I><SUB><I>j</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>y</I><SUB><I>j</I></SUB>−<I>x</I>)<SUB>+</SUB><SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell">)
<I>f</I><SUP>[<I>n</I>+1]</SUP>(<I>x</I>)  <I>dx</I>
</TD></TR>
</TABLE><P>
On appelle noyau de <B>Péano</B><A NAME="@default202"></A> l’expression
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I>(<I>x</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(β−<I>x</I>)<SUP><I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> −  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>w</I><SUB><I>j</I></SUB>
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>y</I><SUB><I>j</I></SUB>−<I>x</I>)<SUB>+</SUB><SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On a alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>−<I>I</I>(<I>f</I>)|
≤ </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |<I>N</I>(<I>x</I>)| |<I>f</I><SUP>[<I>n</I>+1]</SUP>(<I>x</I>)|  <I>dx</I>
≤ <I>M</I><SUB><I>n</I>+1</SUB> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">β</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">α</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |<I>N</I>(<I>x</I>)|  <I>dx</I></TD></TR>
</TABLE><!--TOC subsection Simpson-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc168">18.3</A>  Simpson</H3><!--SEC END --><P> <A NAME="@default203"></A>
Il s’agit de la méthode obtenue en approchant la fonction
sur la subdivision [α,β] par son polynome de Lagrange
aux points α,(α+β)/2,β. On calcule l’intégrale
par exemple avec un logiciel de calcul formel, avec Xcas :
</P><DIV CLASS="center">
<CODE>factor(int(lagrange([a,(a+b)/2,b],[fa,fm,fb]),x=a..b))</CODE> 
</DIV><P>
qui donne la formule sur une subdivision
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>I</I>(<I>f</I>) = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>f</I>(α)+4<I>f</I>(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">α+β</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">) + <I>f</I>(β)) </TD></TR>
</TABLE><P>
et sur [<I>a</I>,<I>b</I>] :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:simpson"></A>
<I>I</I>(<I>f</I>) = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><I>f</I>(<I>a</I>)+<I>f</I>(<I>b</I>)+ 4 </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>a</I>+<I>jh</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)
+ 2  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>a</I>+<I>jh</I>) </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
    (37)</TD></TR>
</TABLE><P>
Si on intègre <I>t</I><SUP>3</SUP> sur [0,1] en 1 subdivision par cette méthode,
on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (0+ 4 </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP>3</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + 1)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
c’est-à-dire le résultat exact, ceci est aussi vérifié pour <I>f</I> polynome
de degré inférieur ou égal à 2 puisque l’approximation de Lagrange
de <I>f</I> est alors égale à <I>f</I>. On en déduit que la méthode de Simpson
est d’ordre 3 (pas plus car la méthode
de Simpson appliquée à l’intégrale de
<I>t</I><SUP>4</SUP> sur [0,1] n’est pas exacte). On peut améliorer
la constante générale de la section précédente pour la majoration
de l’erreur en :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>b</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>a</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I> − <I>I</I>(<I>f</I>)| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>h</I><SUP>4</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2880</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>b</I>−<I>a</I>) <I>M</I><SUB>4</SUB> </TD></TR>
</TABLE><P>
En effet sur une subdivision élémentaire [α,β], 
le noyau de Péano vaut :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>N</I>(<I>x</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(β−<I>x</I>)<SUP>4</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(β−<I>x</I>)<SUB>+</SUB><SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3!</TD></TR>
</TABLE></TD><TD CLASS="dcell">
−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">α+β</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">−<I>x</I>)<SUB>+</SUB><SUP>3</SUP></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> − 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(α−<I>x</I>)<SUB>+</SUB><SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(β−<I>x</I>)<SUP>4</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(β−<I>x</I>)<SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3!</TD></TR>
</TABLE></TD><TD CLASS="dcell">
−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">α+β</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">−<I>x</I>)<SUB>+</SUB><SUP>3</SUP></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
on observe que <I>N</I>(<I>x</I>)≤ 0 sur [α,β]<BR>
<CODE>N(x):=(1-x)^4/4!-1/6*(1-x)^3/3!-2/3/3!*max(0,1/2-x)^3</CODE><BR>
<CODE>plot(N(x),x=0..1)</CODE><BR>
et son intégrale vaut −1/2880(β−α)<SUP>4</SUP> :<BR>
<CODE>int(N(x),x=0..1/2)+int(N(x),x=1/2..1)</CODE></P><P>La méthode de Simpson nécessite 2<I>n</I>+1 évaluations de <I>f</I> (le calcul
de <I>f</I> est un point étant presque toujours 
l’opération la plus couteuse en temps d’une
méthode de quadrature), au lieu de <I>n</I> pour les rectangles
et le point milieu et <I>n</I>+1 pour les trapèzes. Mais on a une majoration
en <I>h</I><SUP>4</SUP> au lieu de <I>h</I><SUP>2</SUP> donc le “rapport qualité-prix” de la méthode
de Simpson est meilleur, on l’utilise donc plutot que les
méthodes précédentes sauf si <I>f</I> n’a pas la régularité
suffisante (ou si <I>M</I><SUB>4</SUB> est trop grand).</P><!--TOC subsection Newton-Cotes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc169">18.4</A>  Newton-Cotes</H3><!--SEC END --><P> <A NAME="@default204"></A>
On peut généraliser l’idée précédente, découper la subdivision 
[α,β] en <I>n</I> parts égales et utiliser le polynôme d’interpolation
en ces <I>n</I>+1 points <I>x</I><SUB>0</SUB>=α, <I>x</I><SUB>1</SUB>, ..., <I>x</I><SUB><I>n</I></SUB>=β. 
Ce sont les méthodes de Newton-Cotes,
qui sont d’ordre <I>n</I> au moins. Comme le polynôme d’interpolation
dépend linéairement des ordonnées, cette méthode est bien
de la forme :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>I</I>(<I>f</I>)=(β−α)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> w<SUB><I>j</I></SUB> <I>f</I>(<I>x</I><SUB><I>j</I></SUB>)</TD></TR>
</TABLE><P>
De plus les w<SUB><I>j</I></SUB> sont universels (ils ne dépendent pas de 
la subdivision), parce qu’on peut faire 
le changement de variables <I>x</I>=α+<I>t</I>(β−α) dans l’intégrale
et le polynôme d’interpolation et donc se ramener à [0,1].</P><P>Exemple : on prend le polynôme d’interpolation en 5 points 
équidistribués sur une subdivision [<I>a</I>,<I>b</I>] (méthode de Boole). 
Pour calculer les
w<SUB><I>j</I></SUB>, on se ramène à [0,1], puis on tape
</P><DIV CLASS="center">
<CODE>int(lagrange(seq(j/4,j,0,4),[f0,f1,f2,f3,f4]),x=0..1)</CODE>
</DIV><P>
et on lit les coefficients de <CODE>f0</CODE> à <CODE>f4</CODE>
qui sont les w<SUB>0</SUB> à w<SUB>4</SUB>: 7/90, 32/90, 12/90, 32/90, 7/90.
La méthode est d’ordre au moins 4 par construction, mais on vérifie
qu’elle est en fait d’ordre 5 (exercice), la majoration de l’erreur
d’une méthode d’ordre 5 est 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>b</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>a</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I> −<I>I</I>(<I>f</I>)| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>M</I><SUB>6</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP>6</SUP> 6!</TD></TR>
</TABLE></TD><TD CLASS="dcell">(1+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">7</TD></TR>
</TABLE></TD><TD CLASS="dcell">) <I>h</I><SUP>6</SUP> (<I>b</I>−<I>a</I>) </TD></TR>
</TABLE><P>
elle peut être améliorée pour cette méthode précise en
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>b</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>a</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I> −<I>I</I>(<I>f</I>)| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>M</I><SUB>6</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1935360</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>h</I><SUP>6</SUP> (<I>b</I>−<I>a</I>) </TD></TR>
</TABLE><P>En pratique, on ne les utilise pas très souvent, car d’une part
pour <I>n</I>≥ 8, les <I>w</I><SUB><I>j</I></SUB> ne sont pas tous positifs, et
d’autre part, parce que la constante <I>M</I><SUB><I>n</I></SUB> devient trop
grande. On préfère utiliser la méthode de Simpson en utilisant
un pas plus petit.</P><P>Il existe aussi d’autres méthodes, par exemple les quadratures de Gauss
(on choisit d’interpoler en utilisant des points non équirépartis 
tels que l’ordre de la méthode soit le plus grand possible)
ou la méthode de Romberg qui est une méthode d’accélération
de convergence basée sur la méthode des trapèzes (on prend
la méthode des trapèzes en 1 subdivision de [<I>a</I>,<I>b</I>], puis
2, puis 2<SUP>2</SUP>, ..., et on élimine les puissances de <I>h</I>
du reste ∫<I>f</I>−<I>I</I>(<I>f</I>) en utilisant un théorème d’Euler-Mac Laurin
qui montre que le développement asymptotique de
l’erreur en fonction de <I>h</I> ne contient que des puissances paires
de <I>h</I>). De plus, on peut être amené à faire varier le pas <I>h</I>
en fonction de la plus ou moins grande régularité de la fonction.</P><!--TOC subsection En résumé-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc170">18.5</A>  En résumé</H3><!--SEC END --><P>
Intégration sur [<I>a</I>,<I>b</I>], <I>h</I> pas d’une subdivision, <I>M</I><SUB><I>k</I></SUB> majorant
de la dérivée <I>k</I>-ième de la fonction sur [<I>a</I>,<I>b</I>]<BR>
</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>formule</TD><TD ALIGN=center NOWRAP>Lagrange degré</TD><TD ALIGN=center NOWRAP>ordre</TD><TD ALIGN=center NOWRAP>erreur</TD></TR>
<TR><TD ALIGN=center NOWRAP>rectangles</TD><TD ALIGN=center NOWRAP>(<A HREF="#eq:rectangle_gauche">32</A>), (<A HREF="#eq:rectangle_droit">33</A>)</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>M</I><SUB>1</SUB> <I>h</I> (<I>b</I>−<I>a</I>)/2</TD></TR>
<TR><TD ALIGN=center NOWRAP>point milieu</TD><TD ALIGN=center NOWRAP>(<A HREF="#eq:point_milieu">34</A>)</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP><I>M</I><SUB>2</SUB> <I>h</I><SUP>2</SUP> (<I>b</I>−<I>a</I>)/24</TD></TR>
<TR><TD ALIGN=center NOWRAP>trapèzes</TD><TD ALIGN=center NOWRAP>(<A HREF="#eq:trapezes">35</A>)</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP><I>M</I><SUB>2</SUB> <I>h</I><SUP>2</SUP> (<I>b</I>−<I>a</I>)/12</TD></TR>
<TR><TD ALIGN=center NOWRAP>Simpson</TD><TD ALIGN=center NOWRAP>(<A HREF="#eq:simpson">37</A>)</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>3</TD><TD ALIGN=center NOWRAP><I>M</I><SUB>4</SUB> <I>h</I><SUP>4</SUP> (<I>b</I>−<I>a</I>)/2880</TD></TR>
</TABLE><!--TOC subsection Accélération de Richardson-Romberg-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc171">18.6</A>  Accélération de Richardson-Romberg</H3><!--SEC END --><P>
<A NAME="@default205"></A><A NAME="@default206"></A>
</P><DIV CLASS="theorem"><B>Proposition 34</B>  <EM>
Soit </EM><EM><I>g</I></EM><EM> une fonction de classe </EM><EM><I>C</I></EM><SUP><EM>2<I>k</I></EM></SUP><EM> sur </EM><EM>[<I>a</I>,<I>b</I>]</EM><EM>, 
</EM><EM><I>T</I></EM><SUB><EM><I>h</I></EM></SUB><EM>(<I>g</I>)</EM><EM> la valeur de la méthode des trapèzes sur </EM><EM>[<I>a</I>,<I>b</I>]</EM><EM> de pas 
</EM><EM><I>h</I>=(<I>b</I>−<I>a</I>)/<I>N</I></EM><EM> (</EM><EM><I>N</I></EM><EM> entier).
Alors </EM><EM><I>T</I></EM><SUB><EM><I>h</I></EM></SUB><EM>(<I>g</I>)</EM><EM> admet un développement en puissances paires de </EM><EM><I>h</I></EM><EM>
à l’ordre </EM><EM>2<I>k</I></EM><EM>.
</EM></DIV><P>Pour montrer ce résultat, il faut établir la formule d’Euler-Mac
Laurin. On commence par se placer sur une subdivision de l’intervalle
[0,1], on intègre par parties ∫<SUB>0</SUB><SUP>1</SUP> <I>f</I>(<I>t</I>) <I>dt</I> en faisant apparaitre
la formule des trapèzes, on intègre donc 1 en <I>t</I>−1/2
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>t</I>)  <I>dt</I> = 
[(<I>t</I>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)<I>f</I>(<I>t</I>)]<SUB>0</SUB><SUP>1</SUP> − </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>t</I>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)<I>f</I>′(<I>t</I>)  <I>dt</I> =
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I>(0)+<I>f</I>(1)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> − </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>t</I>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)<I>f</I>′(<I>t</I>)  <I>dt</I>
</TD></TR>
</TABLE><P>
où encore
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>T</I><SUB>1</SUB>(<I>f</I>)=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>t</I>)  <I>dt</I> 
+  </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>t</I>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)<I>f</I>′(<I>t</I>)  <I>dt</I> </TD></TR>
</TABLE><P>
Pour poursuivre, on pose <I>B</I><SUB>1</SUB>(<I>t</I>)=<I>t</I>−1/2, qu’on va intégrer
en 1/2((<I>t</I>−1/2)<SUP>2</SUP>+<I>c</I>), où on choisit <I>c</I> pour que l’intégrale
soit nulle, donc <I>c</I>=−1/6. On pose <I>B</I><SUB>2</SUB>=(<I>t</I>−1/2)<SUP>2</SUP>−1/6, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>T</I><SUB>1</SUB>(<I>f</I>)=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>t</I>)  <I>dt</I> 
+ [</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB>2</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>′]<SUB>0</SUB><SUP>1</SUP> − </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB>2</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>f</I>′′(<I>t</I>)  <I>dt</I> 
</TD></TR>
</TABLE><P>
Plus
généralement, on pose
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>B</I><SUB><I>p</I>+1</SUB>′=<I>pB</I><SUB><I>p</I></SUB>,    </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>B</I><SUB><I>p</I>+1</SUB>(<I>t</I>)  <I>dt</I>=0 </TD></TR>
</TABLE><P>
ce qui définit de manière unique les <I>B</I><SUB><I>p</I></SUB>. La nullité de l’intégrale
montre que <I>B</I><SUB><I>p</I>+1</SUB>(1)=<I>B</I><SUB><I>p</I>+1</SUB>(0) ce qui simplifiera l’expression des
termes tout intégrés. De plus, on montre par récurrence
que les <I>B</I><SUB><I>p</I></SUB> ont une symétrie paire
ou impaire selon la parité de <I>p</I> par rapport à <I>t</I>=1/2.
Après <I>p</I> intégrations par parties, on obtient :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>  <I>T</I><SUB>1</SUB>(<I>f</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>t</I>)  <I>dt</I> 
+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB>2</SUB>(0)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>f</I>′(1)−<I>f</I>′(0)) 
+ ... </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB>2<I>k</I></SUB>(0)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(2<I>k</I>)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>f</I><SUP>[2<I>k</I>−1]</SUP>(1)−<I>f</I><SUP>[2<I>k</I>−1]</SUP>(0)) 
− </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB>2<I>k</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(2<I>k</I>)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I><SUP>[2<I>k</I>]</SUP>(<I>t</I>)  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
En faisant le même raisonnement sur [<I>k</I>,<I>k</I>+1] pour <I>k</I>=1,...,<I>N</I>−1
et en sommant, on obtient la formule 
d’<B>Euler-Mac Laurin</B><A NAME="@default207"></A><A NAME="@default208"></A> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>  <I>T</I><SUB>1</SUB><SUP>[0,<I>N</I>]</SUP>(<I>f</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>N</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>t</I>)  <I>dt</I> 
+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB>2</SUB>(0)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>f</I>′(<I>N</I>)−<I>f</I>′(0)) 
+ ... </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB>2<I>k</I></SUB>(0)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(2<I>k</I>)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>f</I><SUP>[2<I>k</I>−1]</SUP>(<I>N</I>)−<I>f</I><SUP>[2<I>k</I>−1]</SUP>(0)) 
− </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>N</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB>2<I>k</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(2<I>k</I>)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I><SUP>[2<I>k</I>]</SUP>(<I>t</I>)  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On pose alors <I>x</I>=<I>a</I>+<I>ht</I> (donc <I>dt</I>=<I>dx</I>/<I>h</I>) et <I>f</I>(<I>t</I>)=<I>g</I>(<I>x</I>)
(donc <I>f</I>′(<I>t</I>)=<I>df</I>/<I>dt</I>=<I>h</I> <I>dg</I>/<I>dx</I>), on obtient 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>T</I><SUB><I>h</I></SUB><SUP>[<I>a</I>,<I>b</I>]</SUP>(<I>g</I>)</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>N</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>g</I>(<I>x</I>)  <I>dx</I> 
+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB>2</SUB>(0)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>h</I>(<I>g</I>′(<I>b</I>)−<I>g</I>′(<I>a</I>)) 
+ ... </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB>2<I>k</I></SUB>(0)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(2<I>k</I>)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>h</I><SUP>2<I>k</I>−1</SUP> (<I>g</I><SUP>[2<I>k</I>−1]</SUP>(<I>N</I>)−<I>g</I><SUP>[2<I>k</I>−1]</SUP>(0)) 
− </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>N</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB>2<I>k</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(2<I>k</I>)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>h</I><SUP>2<I>k</I></SUP> <I>g</I><SUP>[2<I>k</I>]</SUP>(<I>x</I>)  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>h</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>dx</I> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>T</I><SUB><I>h</I></SUB><SUP>[<I>a</I>,<I>b</I>]</SUP>(<I>g</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>N</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>g</I>(<I>x</I>)  <I>dx</I> 
+ <I>h</I><SUP>2</SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB>2</SUB>(0)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>g</I>′(<I>b</I>)−<I>g</I>′(<I>a</I>)) 
+ ... </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">+ <I>h</I><SUP>2<I>k</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB>2<I>k</I></SUB>(0)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(2<I>k</I>)!</TD></TR>
</TABLE></TD><TD CLASS="dcell">  (<I>g</I><SUP>[2<I>k</I>−1]</SUP>(<I>N</I>)−<I>g</I><SUP>[2<I>k</I>−1]</SUP>(0)) 
− <I>h</I><SUP>2<I>k</I></SUP> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>N</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB>2<I>k</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(2<I>k</I>)!</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>g</I><SUP>[2<I>k</I>]</SUP>(<I>x</I>)   <I>dx</I> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>L’accélération consiste à éliminer les puissances de <I>h</I><SUP>2</SUP> en
commençant par <I>h</I><SUP>2</SUP> avec des subdivisions deux fois plus fines
à chaque itération.
Ainsi <I>T</I><SUB><I>h</I></SUB><SUP>1</SUP>(<I>f</I>) = (4<I>T</I><SUB><I>h</I>/2</SUB>(<I>f</I>)−<I>T</I><SUB><I>h</I></SUB>(<I>f</I>))/(4−1) n’a plus de termes en <I>h</I><SUP>2</SUP>
et tend vers l’intégrale à approcher lorsque <I>h</I> tend vers 0. 
On peut d’ailleurs vérifier qu’il s’agit de la méthode de Simpson.
On élimine ensuite le terme en <I>h</I><SUP>4</SUP> en posant
<I>T</I><SUB><I>h</I></SUB><SUP>2</SUP>(<I>f</I>)=(4<SUP>2</SUP> <I>T</I><SUB><I>h</I>/2</SUB><SUP>1</SUP>(<I>f</I>)−<I>T</I><SUB><I>h</I></SUB><SUP>1</SUP>(<I>f</I>))/(4<SUP>2</SUP>−1) et ainsi
de suite. On construit un tableau triangulaire <CODE>T</CODE>
dont chaque
ligne <I>l</I> contient <I>T</I><SUB><I>h</I>/2<SUP><I>l</I></SUP></SUB>(<I>f</I>), <I>T</I><SUB><I>h</I>/2<SUP><I>l</I></SUP></SUB><SUP>1</SUP>(<I>f</I>), ... 
(avec des indices qui commencent à 0). Pour
calculer le terme d’indice 0 de la ligne courante
on fait une méthode des trapèzes sur 2 fois plus
de subdivisions que la précédente, puis pour le <I>j</I>-ième terme
<CODE>T[l,j]</CODE>
on effectue <CODE>(4^j*T[l-1,j-1]-T[l,j-1])/(4^j-1)</CODE>
(on n’a donc besoin que de la ligne précédente pour calculer
la ligne courante).
On s’arrête par exemple lorsque la valeur absolue de la différence
entre les derniers termes de deux lignes consécutives est inférieur
à la précision souhaitée (erreur empirique).</P><!--TOC subsection Cas des fonctions périodiques.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc172">18.7</A>  Cas des fonctions périodiques.</H3><!--SEC END --><P>
Si <I>f</I> est une fonction périodique régulière (<I>C</I><SUP>∞</SUP>),
alors la méthode des trapèzes sur une période est d’ordre 
arbitrairement grand. En effet, pour une série de Fourier tronquée
à l’ordre <I>m</I>, la formule des trapèzes avec <I>N</I> subdivisions donne
le résultat exact de ∫<SUB>0</SUB><SUP><I>T</I></SUP> <I>f</I>(<I>t</I>) <I>dt</I> dès que <I>N</I>&gt;<I>m</I>. Il suffit
ensuite d’utiliser que le reste de
la série de Fourier (<I>m</I>&gt;<I>N</I>) 
a des coefficients à décroissance rapide.</P><P>La méthode des trapèzes donne donc de bons résultats pour une 
fonction périodique, on peut d’ailleurs aussi 
l’appliquer pour calculer une valeur
approchée des coefficients de Fourier de la fonction. La liste des valeurs
approchées obtenue est alors la transformée de Fourier discrète
des valeurs de la fonction <I>f</I> aux <I>N</I> points de la subdivision, elle
se calcule donc rapidement avec la transformée de Fourier rapide.
Par exemple, pour approcher <I>f</I>(<I>x</I>)=<I>e</I><SUP>sin(<I>x</I>)</SUP>, on peut utiliser les
commandes suivantes en Xcas :
</P><PRE CLASS="verbatim">f(x):=exp(sin(x));
N:=100; F:=seq(f(k/N*2.*pi),k,0,N-1); G:=fft(F);
k:=4;
g:=G[0]+sum(G[j]*exp(i*j*x),j,1,k)+sum(G[N-j]*exp(-i*j*x),j,1,k);
h:=normal(exp2trig(g)/N);
plot(h,x=-pi..pi,color=red); //plot(f(x),x=-pi..pi)
</PRE><P>Ou directement <CODE>2*re(G[j]/N)</CODE> est une valeur approchée du
<I>j</I>-ième coefficient de Fourier <I>a</I><SUB><I>j</I></SUB> de <I>f</I>, et <CODE>-2*im(G[j]/N)</CODE>
de <I>b</I><SUB><I>j</I></SUB>, par exemple :
</P><PRE CLASS="verbatim">1/pi*int(f(x)*cos(4x),x,0,2.*pi); 2*re(G[4]/N);
1/pi*int(f(x)*sin(5x),x,0,2.*pi); -2*im(G[5]/N);
</PRE><P>On observe en effet une très bonne concordance (11 décimales).</P><P>Bien entendu, cela n’est pas très utile pour approcher <I>e</I><SUP>sin(<I>x</I>)</SUP>
(il vaut mieux composer exponentielle et sinus), 
mais cela pourrait le devenir pour une
fonction périodique plus compliquée ou pour une fonction
périodique dont on ne connait qu’un échantillonage régulier
(par exemple un fichier numérique audio).</P><!--TOC subsection Quadratures gaussiennes.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc173">18.8</A>  Quadratures gaussiennes.</H3><!--SEC END --><P><A NAME="@default209"></A>
On a vu que l’interpolation polynomiale était de meilleure
qualité en prenant les points de Tchebyshev plutot que
des points équidistants, il est donc naturel de calculer
des approximations d’intégrale de cette manière
ou encore d’optimiser le choix des abscisses pour avoir
une méthode d’intégration d’ordre maximal.</P><P>Si on se fixe <I>n</I> abscisses <I>x</I><SUB>1</SUB> à <I>x</I><SUB><I>n</I></SUB>, on peut obtenir l’ordre
2<I>n</I>−1. En effet, si on considère le polynôme <I>P</I><SUB><I>n</I></SUB>=∏<SUB><I>i</I>=1</SUB><SUP><I>n</I></SUP> (<I>x</I>−<I>x</I><SUB><I>i</I></SUB>),
il est de degré <I>n</I>, si la méthode est d’ordre 2<I>n</I>−1 alors
il sera orthogonal à tous les polynômes de degré inférieur
strict à <I>n</I> pour le produit scalaire <I>f</I>.<I>g</I>=∫<SUB><I>a</I></SUB><SUP><I>b</I></SUP> <I>f</I>(<I>x</I>) <I>g</I>(<I>x</I>)  <I>dx</I>
puisque <I>P</I><SUB><I>n</I></SUB>.<I>x</I><SUP><I>j</I></SUP>=∫<SUB><I>a</I></SUB><SUP><I>b</I></SUP> <I>P</I><SUB><I>n</I></SUB> <I>x</I><SUP><I>j</I></SUP>  sera combinaison linéaire des
<I>P</I><SUB><I>n</I></SUB> <I>x</I><SUP><I>j</I></SUP> en <I>x</I><SUB><I>k</I></SUB>, <I>k</I>=1..<I>n</I> (car l’intégrale est exacte puisque le degré
du polynôme est au plus 2<I>n</I>−1). Donc <I>P</I><SUB><I>n</I></SUB> est à une constante
multiplicative près le <I>n</I>-ième polynôme orthogonal pour
l’integrale sur [<I>a</I>,<I>b</I>], si [<I>a</I>,<I>b</I>]=[−1,1] c’est <CODE>legendre(n)</CODE><A NAME="@default210"></A>.
Réciproquement, si les <I>x</I><SUB><I>k</I></SUB> sont les racines de ce polynôme,
alors la formule d’intégration est exacte, on effectue la division
euclidienne du polynôme <I>P</I> de degré au plus 2<I>n</I>−1 à
intégrer par <I>P</I><SUB><I>n</I></SUB>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>= <I>P</I><SUB><I>n</I></SUB> <I>Q</I> + <I>R</I> ,    deg(<I>Q</I>) ≤ <I>n</I>−1 </TD></TR>
</TABLE><P>
On a ∫<SUB><I>a</I></SUB><SUP><I>b</I></SUP> <I>P</I><SUB><I>n</I></SUB> <I>Q</I>=0 par orthogonalité et la combinaison
linéaire correspondante en les <I>x</I><SUB><I>k</I></SUB> est nulle, et on a exactitude
pour <I>R</I>, car de degré au plus <I>n</I>−1.</P><!--TOC subsection Méthode adaptative.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc174">18.9</A>  Méthode adaptative.</H3><!--SEC END --><P>
On calcule une valeur approchée de l’intégrale sur [<I>a</I>,<I>b</I>] par
deux quadratures gaussiennes emboitées, on estime l’erreur,
si elle est supérieure à la tolérance on divise en 2. On
recommence en subdivisant en 2 l’intervalle où l’erreur est
maximale. On s’arrête lorsque l’erreur estimée est inférieure
à la tolérance.</P><P>L’estimation de l’erreur se fait par exemple avec deux quadratures
gaussiennes emboitées (c’est-à-dire que les points d’interpolation
de la moins fine sont contenues dans les points d’interpolation de la
plus fine, pour éviter de devoir calculer la fonction en de nouveaux
points, on considére alors l’erreur sur la quadrature la moins fine
comme la valeur absolue de la différence des deux valeurs). Ou avec
trois quadratures emboitées,
Hairer propose de prendre comme quadrature la plus fine en <I>h</I><SUP>30</SUP>
(15 points), intermédiaire en <I>h</I><SUP>14</SUP> (avec les mêmes points
sauf le point central), moins fine en <I>h</I><SUP>6</SUP> (avec les points 1, 3, 5,
9, 11, 13), et d’estimer l’erreur par 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">є<SUB>1</SUB>=| <I>I</I><SUB>30</SUB>−<I>I</I><SUB>14</SUB>|,  є<SUB>2</SUB>=| <I>I</I><SUB>30</SUB>−<I>I</I><SUB>6</SUB>|; 
є = є<SUB>1</SUB> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">є<SUB>1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">є<SUB>2</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">2</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
On observe en effet que є est en <I>h</I><SUP>30</SUP>, comme
l’ordre de la méthode.</P><!--TOC subsection Méthodes probabilistes.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc175">18.10</A>  Méthodes probabilistes.</H3><!--SEC END --><P> <A NAME="@default211"></A>
Pour déterminer ∫<SUB><I>a</I></SUB><SUP><I>b</I></SUP> <I>f</I>(<I>t</I>)  <I>dt</I> , on l’interprète comme
une espérance, plus précisément comme (<I>b</I>−<I>a</I>)<I>E</I>(<I>f</I>(<I>X</I>)) 
où <I>X</I> est une variable aléatoire
qui suit la loi uniforme sur [<I>a</I>,<I>b</I>], et on approche cette valeur
par 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>b</I>−<I>a</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>x</I><SUB><I>k</I></SUB>) </TD></TR>
</TABLE><P>
où <I>x</I><SUB><I>k</I></SUB> est obtenu par un générateur pseudo-aléatoire
(selon la loi uniforme).
Par exemple
</P><PRE CLASS="verbatim">f(t):=exp(-t^2); n:=1000;
l:=ranv(n,uniform,0,2);
(2-0)*sum(apply(f,l))/n; int(f(t),t,0,2.0);
</PRE><P>La convergence en fonction de <I>n</I> est assez lente, on peut l’observer
en faisant plusieurs estimations :
</P><PRE CLASS="verbatim">m:=ranm(500,n,uniform,0,2);
I:=seq(2*sum(apply(f,m[k]))/n,k,0,size(m)-1);
histogram(I,0,0.01)
</PRE><P>En effet, les tirages sont équidistribués selon la même loi,
la loi des grands nombres s’applique donc : on fait <I>b</I>−<I>a</I> fois
une moyenne de
<I>n</I> tirages, si <I>n</I> est grand, on converge vers une loi normale
dont l’écart-type est en (<I>b</I>−<I>a</I>)σ/√<SPAN style="text-decoration:overline"><I>n</I></SPAN>.
La valeur de la constante σ
peut se calculer à partir de <I>f</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">σ<SUP>2</SUP> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>b</I>−<I>a</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>b</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>a</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I><SUP>2</SUP>(<I>t</I>)  <I>dt</I> −
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>b</I>−<I>a</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>b</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>a</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(<I>t</I>)  <I>dt</I>  </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">2</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
par exemple ici<BR>
<CODE>2*sqrt(int(f(t)^2,t,0,2.)/2-(1/2*int(f(t),t,0,2.))^2)/sqrt(n)</CODE><BR>
mais on ne fait pas ce calcul en pratique
(puisqu’il faudrait calculer une intégrale), on estime
l’écart-type σ/√<SPAN style="text-decoration:overline"><I>n</I></SPAN> de la loi normale par
l’écart-type de l’échantillon des estimations <CODE>stddevp(I)</CODE>.</P><P>Cette méthode converge donc beaucoup moins vite que les quadratures,
en dimension 1. Mais elle se généralise très facilement en
dimension plus grande en conservant la même vitesse de convergence
alors que le travail nécessaire pour une méthode de quadrature
croit comme une puissance de la dimension, et ne nécessite pas
de paramétrer des domaines d’intégration compliqués (il suffit
par exemple d’utiliser la méthode du rejet pour avoir un
générateur uniforme
dans un domaine inclus dans un cube).</P><!--TOC section Suites récurrentes et applications-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc176">19</A>  Suites récurrentes et applications</H2><!--SEC END --><P> <A NAME="sec:rec"></A>
<A NAME="@default212"></A><A NAME="@default213"></A>
Cette section comporte une première petite partie sur le calcul
de l’expression exacte de suites récurrences (linéaires), puis
une deuxième partie sur l’intérêt du calcul approché de limites
de suites récurrentes (dont on ne sait en général pas déterminer l’expression
générale).</P><!--TOC subsection Calcul de l’expression des suites récurrentes.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc177">19.1</A>  Calcul de l’expression des suites récurrentes.</H3><!--SEC END --><P>
Le problème général est l’analogue discret de la recherche de solutions
d’équations différentielles. On ne sait en général pas le résoudre, sauf
pour certaines classes de suites, en particulier celles qui suivent
une récurrence affine.</P><!--TOC subsubsection Récurrence affine-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc178">19.1.1</A>  Récurrence affine</H4><!--SEC END --><P><A NAME="@default214"></A>
<A NAME="@default215"></A>
On peut toujours se ramener au cas d’une suite vectorielle dans ℝ<SUP><I>d</I></SUP>
vérifiant un récurrence à un cran :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <I>v</I><SUB><I>n</I>+1</SUB> = <I>A</I> <I>v</I><SUB><I>n</I></SUB> + <I>B</I> <A NAME="eq:recaffine"></A>
    (38)</TD></TR>
</TABLE><P>
où <I>A</I> est une matrice indépendante de <I>n</I>, et <I>B</I> un vecteur qui peut
dépendre de <I>n</I>.
Par exemple pour une suite <I>u</I><SUB><I>n</I></SUB> récurrente à deux crans
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I>+2</SUB>=<I>au</I><SUB><I>n</I>+1</SUB>+<I>bu</I><SUB><I>n</I></SUB>+<I>c</I></TD></TR>
</TABLE><P>
on pose <I>v</I><SUB><I>n</I></SUB>=(<I>u</I><SUB><I>n</I></SUB>,<I>u</I><SUB><I>n</I>+1</SUB>) qui vérifie alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>v</I><SUB><I>n</I>+1</SUB>= </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>b</I></TD><TD ALIGN=center NOWRAP><I>a</I> </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><I>v</I><SUB><I>n</I></SUB> + 
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>c</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P> 
La solution générale de (<A HREF="#eq:recaffine">38</A>) est la somme de la solution
de l’équation homogène <I>v</I><SUB><I>n</I>+1</SUB>=<I>Av</I><SUB><I>n</I></SUB> et d’une solution particulière,
solution que l’on sait calculer lorsque <I>B</I> est combinaison linéaire
d’un produit d’exponentielle par un polynôme en <I>n</I>.
L’équation homogène a pour solution <I>v</I><SUB><I>n</I></SUB>=<I>A</I><SUP><I>n</I></SUP> <I>v</I><SUB>0</SUB>, où l’expression de <I>A</I><SUP><I>n</I></SUP>
se calcule sur un corps algébriquement clos par réduction de Jordan
(fonction <CODE>matpow</CODE> dans Xcas). On peut aussi utiliser un algorithme
de puissance rapide pour calculer le reste de la division euclidienne
de <I>A</I><SUP><I>n</I></SUP> par un polynôme annulateur de <I>A</I> (minimal ou caractéristique)
ce qui permet de rester dans le corps des coefficients.</P><P>Le calcul d’une solution particulière dans le cas où 
<I>B</I>=<I>c</I><SUP><I>n</I></SUP> <I>P</I>(<I>n</I>) avec <I>P</I> un vecteur à coefficients polynomiaux
de degré au plus <I>p</I> se fait en posant <I>v</I><SUB><I>n</I></SUB>=<I>c</I><SUP><I>n</I></SUP> <I>Q</I>(<I>n</I>)
où <I>Q</I> est un vecteur de polynôme de degré <I>p</I> plus la multiplicité
de <I>c</I> comme valeur propre de <I>A</I>. En effet, on doit alors résoudre :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>v</I><SUB><I>n</I>+1</SUB>−<I>Av</I><SUB><I>n</I></SUB> = <I>c</I><SUP><I>n</I></SUP> (<I>c</I> <I>Q</I>(<I>n</I>+1)− <I>AQ</I>(<I>n</I>)) = <I>c</I><SUP><I>n</I></SUP> <I>P</I>(<I>n</I>)  </TD></TR>
</TABLE><P>
soit
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:recpart"></A>
<I>c</I> <I>Q</I>(<I>n</I>+1)− <I>AQ</I>(<I>n</I>) = <I>P</I>(<I>n</I>)
    (39)</TD></TR>
</TABLE><P>
Si <I>Q</I>(<I>n</I>)=∑<SUB><I>j</I>=0</SUB><SUP><I>q</I></SUP> <I>Q</I><SUB><I>j</I></SUB> <I>n</I><SUP><I>j</I></SUP>, alors le coefficient de <I>n</I><SUP><I>q</I></SUP> de cette équation
est (<I>c</I> <I>I</I><SUB><I>d</I></SUB> −<I>A</I>)<I>Q</I><SUB><I>q</I></SUB>=<I>P</I><SUB><I>q</I></SUB>. Si <I>c</I> n’est pas valeur propre de <I>A</I>, alors
on peut calculer <I>Q</I><SUB><I>q</I></SUB> en fonction de <I>P</I><SUB><I>q</I></SUB> et en descendant de degré en degré
on peut trouver <I>Q</I> solution de même degré que <I>P</I>. Si <I>c</I> est valeur
propre de <I>A</I>, la résolution de cette façon
est plus compliquée, il faut séparer les
<I>Q</I><SUB><I>j</I></SUB> en deux composantes, l’une sur l’espace caractéristique associé
à <I>c</I> et l’autre sur la somme des autres sous-espaces caractéristiques,
ce qui peut se faire avec l’identité de Bézout, si <I>M</I> un polynôme annulateur
de <I>A</I> est <I>M</I>(<I>x</I>)=(<I>x</I>−<I>c</I>)<SUP><I>m</I></SUP> <I>N</I>(<I>x</I>) où <I>m</I> est la multiplicité de <I>c</I> dans <I>M</I>,
alors il existe <I>U</I> et <I>V</I> tels que (<I>x</I>−<I>c</I>)<SUP><I>m</I></SUP><I>U</I>(<I>x</I>)+<I>N</I>(<I>x</I>)<I>V</I>(<I>x</I>)=1, donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>A</I>−<I>cI</I>)<SUP><I>m</I></SUP> <I>U</I>(<I>A</I>)<I>y</I>+<I>N</I>(<I>A</I>)<I>V</I>(<I>A</I>)<I>y</I>= <I>y</I></TD></TR>
</TABLE><P>
on a écrit <I>y</I> comme somme de deux vecteurs, le premier dans le noyau de
<I>N</I>(<I>A</I>) et le second dans le noyau de (<I>A</I>−<I>cI</I>)<SUP><I>m</I></SUP>. Pour la première
composante on est ramené au cas où <I>c</I> n’est pas valeur propre de <I>A</I>,
pour la seconde composante, on jordanise puis on travaille composante
par composante, pour chaque composante on aura une équation du type
<I>c</I>(<I>Q</I>(<I>n</I>+1)−<I>Q</I>(<I>n</I>))=polynôme connu, équation 
que l’on peut résoudre efficacement avec
la base de Newton (voir section ci-dessous).</P><!--TOC subsubsection Utilisation de la base de Newton si <I>A</I>=<I>I</I><SUB><I>d</I></SUB> et <I>c</I>=1-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc179">19.1.2</A>  Utilisation de la base de Newton si <I>A</I>=<I>I</I><SUB><I>d</I></SUB> et <I>c</I>=1</H4><!--SEC END --><P>
<A NAME="@default216"></A>
Plutôt que d’exprimer les polynômes dans la base canonique, il est
intéressant d’utiliser la base 1,<I>n</I>,<I>n</I>(<I>n</I>−1),<I>n</I>(<I>n</I>−1)(<I>n</I>−2),...,<I>n</I>(<I>n</I>−1)...(<I>n</I>−<I>p</I>+1).
En effet (<A HREF="#eq:recpart">39</A>) appliqué à <I>Q</I><SUB><I>k</I>+1</SUB> <I>n</I>(<I>n</I>−1)..(<I>n</I>−<I>k</I>) s’écrit
<I>Q</I><SUB><I>k</I>+1</SUB>((<I>n</I>+1)−(<I>n</I>−<I>k</I>))<I>n</I>(<I>n</I>−1)...(<I>n</I>−<I>k</I>+1)=<I>Q</I><SUB><I>k</I>+1</SUB>(<I>k</I>+1)<I>n</I>(<I>n</I>−1)...(<I>n</I>−<I>k</I>+1), on obtient
donc <I>Q</I><SUB><I>k</I>+1</SUB>=<I>P</I><SUB><I>k</I></SUB>/(<I>k</I>+1). Le calcul des coefficients <I>P</I><SUB><I>k</I></SUB> s’effectue
efficacement par l’algorithme des différences divisées à partir
du polynôme <I>P</I> et de sa valeur en 0,1,2,...,degré(<I>P</I>).</P><!--TOC subsection Le point fixe dans ℝ-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc180">19.2</A>  Le point fixe dans ℝ</H3><!--SEC END --><P><A NAME="@default217"></A> 
Soit <I>f</I> une fonction continue sur un intervalle <I>I</I>=[<I>a</I>,<I>b</I>] de ℝ, et 
à valeurs dans <I>I</I> (attention à bien choisir <I>I</I> pour que l’image
de <I>I</I> par <I>f</I> reste dans <I>I</I>).
On s’intéresse à la suite 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:u_n_fixe"></A>
<I>u</I><SUB><I>n</I>+1</SUB>=<I>f</I>(<I>u</I><SUB><I>n</I></SUB>),    <I>u</I><SUB>0</SUB> ∈ <I>I</I> 
    (40)</TD></TR>
</TABLE><P>
Supposons que <I>u</I><SUB><I>n</I></SUB> converge vers une limite <I>l</I> ∈ <I>I</I> lorsque
<I>n</I> → +∞, alors la limite doit vérifier
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>l</I>)=<I>l</I> </TD></TR>
</TABLE><P>
puisque <I>f</I> est continue. On dit que <I>l</I> est un point fixe de <I>f</I>.
Ceci amène à l’idée d’utiliser ces suites pour résoudre numériquement
l’équation <I>f</I>(<I>x</I>)=<I>x</I>. Nous allons donner un théorème permettant
d’assurer que la suite (<A HREF="#eq:u_n_fixe">40</A>) converge, et que la limite
est l’unique solution de <I>f</I>(<I>l</I>)=<I>l</I> sur <I>I</I>.</P><DIV CLASS="theorem"><B>Définition 35</B>  <EM>
On dit que </EM><EM><I>f</I></EM><EM> est </EM><EM><B>contractante</B></EM><A NAME="@default218"></A><EM> de rapport </EM><EM><I>k</I>&lt;1</EM><EM> sur </EM><EM><I>I</I></EM><EM> si
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>∀ <I>x</I>,<I>y</I> ∈ <I>I</I>,    |<I>f</I>(<I>y</I>)−<I>f</I>(<I>x</I>)| ≤ <I>k</I> |<I>y</I>−<I>x</I>| </EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>En pratique, les fonctions <I>f</I> que l’on considèrera seront continument
dérivables, donc d’après le théorème des accroissements finis
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>y</I>)−<I>f</I>(<I>x</I>)=<I>f</I>′(θ) (<I>y</I>−<I>x</I>),    θ ∈ [<I>x</I>,<I>y</I>] </TD></TR>
</TABLE><P>
ainsi pour vérifier que <I>f</I> est contractante, on étudie la valeur absolue
de <I>f</I>′ sur <I>I</I>, il suffit de montrer que cette valeur absolue
est strictement inférieure à un réel <I>k</I>&lt;1 pour conclure (il faut
donc chercher le maximum de |<I>f</I>′| sur <I>I</I>. Attention, il s’agit du
maximum de |<I>f</I>′| et pas du maximum de <I>f</I>′, ce qui revient à chercher
le maximum de <I>f</I>′ et de −<I>f</I>′).</P><P>On a alors le 
</P><DIV CLASS="theorem"><B>Théorème 36</B>  <EM> (du </EM><EM><B>point fixe</B></EM><EM>)</EM><A NAME="@default219"></A><EM><BR>
si </EM><EM><I>f</I></EM><EM> est contractante de </EM><EM><I>I</I>=[<I>a</I>,<I>b</I>]</EM><EM>
dans </EM><EM><I>I</I></EM><EM> de rapport </EM><EM><I>k</I></EM><EM> 
alors la suite (</EM><A HREF="#eq:u_n_fixe"><EM>40</EM></A><EM>) converge vers l’unique
solution de </EM><EM><I>f</I>(<I>l</I>)=<I>l</I></EM><EM> dans </EM><EM><I>I</I></EM><EM>. On a de plus les encadrements :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>  </EM><A NAME="eq:u_n_l"></A><EM>
|<I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM>−<I>l</I>| ≤ <I>k</I></EM><SUP><EM><I>n</I></EM></SUP><EM> |<I>b</I>−<I>a</I>|,   
|<I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM> −<I>l</I> | ≤ </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM>|<I>u</I></EM><SUB><EM><I>n</I>+1</EM></SUB><EM>−<I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM>|</EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM>1−<I>k</I></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> 
    (41)</EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>Démonstration : Tout d’abord si <I>f</I> est contractante, on montre à partir
de la définition de la continuité que <I>f</I> est continue. 
Soit <I>g</I>(<I>x</I>)=<I>f</I>(<I>x</I>)−<I>x</I>, alors <I>g</I> est continue, positive en <I>a</I> et négative
en <I>b</I>, il existe donc <I>l</I>∈[<I>a</I>,<I>b</I>] tel que <I>g</I>(<I>l</I>)=0 (théorème des
valeurs intermédiaires). 
Soit <I>u</I><SUB><I>n</I></SUB> une suite définie par
(<A HREF="#eq:u_n_fixe">40</A>). On a alors pour tout <I>n</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>u</I><SUB><I>n</I>+1</SUB>−<I>l</I>|=|<I>f</I>(<I>u</I><SUB><I>n</I></SUB>)−<I>f</I>(<I>l</I>)| ≤ <I>k</I> |<I>u</I><SUB><I>n</I></SUB>−<I>l</I>| </TD></TR>
</TABLE><P>
Donc par une récurrence évidente :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>u</I><SUB><I>n</I></SUB>−<I>l</I>| ≤ <I>k</I><SUP><I>n</I></SUP> |<I>u</I><SUB>0</SUB>−<I>l</I>| </TD></TR>
</TABLE><P>
ce qui entraine d’ailleurs que |<I>u</I><SUB><I>n</I></SUB>−<I>l</I>| ≤ <I>k</I><SUP><I>n</I></SUP> |<I>a</I>−<I>b</I>|.
Comme <I>k</I> ∈ [0,1[ , la suite géométrique <I>k</I><SUP><I>n</I></SUP> converge vers 0
lorsque <I>n</I> tend vers l’infini, donc <I>u</I><SUB><I>n</I></SUB> tend vers <I>l</I>.
Notons que <I>l</I> est unique car si <I>l</I>′ est une autre solution
alors |<I>l</I>−<I>l</I>′|=|<I>f</I>(<I>l</I>)−<I>f</I>(<I>l</I>′)| ≤ <I>k</I>|<I>l</I>−<I>l</I>′| donc (1−<I>k</I>)|<I>l</I>−<I>l</I>′| ≤ 0,
or 1−<I>k</I>&gt;0 et |<I>l</I>−<I>l</I>′| ≥ 0 donc |<I>l</I>−<I>l</I>′| doit être nul.
Passons à la preuve de la majoration (<A HREF="#eq:u_n_l">41</A>) qui est importante
en pratique car elle donne un test d’arrêt de calcul des
termes de la suite récurrente, on écrit pour <I>m</I>&gt;0 :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I></SUB>−<I>l</I>= <I>u</I><SUB><I>n</I></SUB> − <I>u</I><SUB><I>n</I>+1</SUB> + <I>u</I><SUB><I>n</I>+1</SUB> − <I>u</I><SUB><I>n</I>+2</SUB> + ... + <I>u</I><SUB><I>n</I>+<I>m</I>−1</SUB>− <I>u</I><SUB><I>n</I>+<I>m</I></SUB>
+ <I>u</I><SUB><I>m</I></SUB>−<I>l</I> </TD></TR>
</TABLE><P>
puis on majore avec l’inégalité triangulaire
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>u</I><SUB><I>n</I></SUB>−<I>l</I>| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>m</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |<I>u</I><SUB><I>n</I>+<I>j</I></SUB>−<I>u</I><SUB><I>n</I>+<I>j</I>+1</SUB>| + |<I>u</I><SUB><I>m</I></SUB>−<I>l</I>| </TD></TR>
</TABLE><P>
puis on applique le fait que <I>f</I> est contractante de rapport <I>k</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>u</I><SUB><I>n</I></SUB>−<I>l</I>| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>m</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>k</I><SUP><I>j</I></SUP> |<I>u</I><SUB><I>n</I></SUB>−<I>u</I><SUB><I>n</I>+1</SUB>| + |<I>u</I><SUB><I>m</I></SUB>−<I>l</I>| </TD></TR>
</TABLE><P>
soit
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>u</I><SUB><I>n</I></SUB>−<I>l</I>| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1−<I>k</I><SUP><I>m</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1−<I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> |<I>u</I><SUB><I>n</I></SUB>−<I>u</I><SUB><I>n</I>+1</SUB>| + |<I>u</I><SUB><I>m</I></SUB>−<I>l</I>| </TD></TR>
</TABLE><P>
On fait alors tendre <I>m</I> vers l’infini d’où le résultat.</P><P>Remarque : on peut aussi (voir plus bas le point fixe en dimension
<I>n</I>) montrer l’existence de la limite en montrant que (<I>u</I><SUB><I>n</I></SUB>) est
une suite de Cauchy. On peut alors faire <I>a</I>=−∞ ou <I>b</I>=+∞
dans l’énoncé du théorème. On remarque aussi 
que l’existence d’un point fixe
dans [<I>a</I>,<I>b</I>] pour <I>a</I> et <I>b</I> finis ne nécessite pas la contractance
de rapport <I>k</I>&lt;1, il suffit de préserver [<I>a</I>,<I>b</I>].</P><P>Exemples : 
Cherchons une valeur approchée de √<SPAN style="text-decoration:overline">2</SPAN> par cette méthode.
Il faut d’abord trouver une fonction <I>f</I> dont √<SPAN style="text-decoration:overline">2</SPAN> est un point
fixe, par exemple
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>x</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+1</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On vérifie que <I>f</I>(√<SPAN style="text-decoration:overline">2</SPAN>)=√<SPAN style="text-decoration:overline">2</SPAN>), puis que <I>f</I>′=−1/(<I>x</I>+1)<SUP>2</SUP>
donc <I>f</I> décroit. On va voir si les hypothèses du théorème du point
fixe s’appliquent sur par exemple [1,2]. Comme <I>f</I> est décroissante
<I>f</I>([1,2])=[<I>f</I>(2),<I>f</I>(1)]=[4/3,3/2] qui est bien inclus dans [1,2] .
De plus <I>f</I>′ est comprise entre −1/(1+1)<SUP>2</SUP>=−1/4 et −1/(2+1)<SUP>2</SUP>=−1/9 donc
|<I>f</I>′|&lt;1/4, <I>f</I> est contractante de rapport 1/4. On peut donc
itérer la suite à partir par exemple de <I>u</I><SUB>0</SUB>=1 et on va converger
vers √<SPAN style="text-decoration:overline">2</SPAN> (en s’en rapprochant à chaque cran d’un rapport
inférieur à 1/4).</P><P>Considérons l’équation en <I>x</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>− <I>e</I> sin(<I>x</I>) =<I>t</I>,    <I>e</I> ∈ [0,1[ </TD></TR>
</TABLE><P>
c’est l’équation du temps utilisée en astronomie pour trouver la
position d’une planète sur son orbite elliptique (<I>e</I> étant l’excentricité
de l’ellipse).
Il n’y a pas de formule exacte permettant de calculer <I>x</I> en fonction de <I>t</I>.
Si on a une valeur numérique pour <I>t</I>, on peut trouver une valeur
numérique approchée de <I>x</I> par la méthode du point fixe, en réécrivant
l’équation sous la forme 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>x</I>)=<I>t</I>+<I>e</I>sin(<I>x</I>) = <I>x</I> </TD></TR>
</TABLE><P>
On observe que <I>f</I> envoie ℝ dans [<I>t</I>−<I>e</I>,<I>t</I>+<I>e</I>] donc on peut prendre
<I>I</I>=[<I>t</I>−<I>e</I>,<I>t</I>+<I>e</I>], de plus |<I>f</I>′|≤ <I>e</I> &lt;1, <I>f</I> est contractante
de rapport <I>e</I> ∈ [0,1[, le théorème s’applique, il suffit de
prendre une valeur initiale dans [<I>t</I>−<I>e</I>,<I>t</I>+<I>e</I>] et d’itérer la suite
jusqu’à obtenir la précision désirée. Par exemple si on veut une
valeur approchée de <I>x</I> à 10<SUP>−6</SUP> près, il suffira que la différence
entre deux termes successifs de la suite <I>u</I><SUB><I>n</I></SUB> vérifie
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>u</I><SUB><I>n</I>+1</SUB>−<I>u</I><SUB><I>n</I></SUB>| ≤  10<SUP>−6</SUP> (1−<I>e</I>) </TD></TR>
</TABLE><P>
on aura alors bien :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>u</I><SUB><I>n</I></SUB>−<I>x</I>| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">|<I>u</I><SUB><I>n</I>+1</SUB>−<I>u</I><SUB><I>n</I></SUB>|</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1−<I>e</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ≤ 10<SUP>−6</SUP> </TD></TR>
</TABLE><P>Cette méthode n’est pas toujours optimale, car la vitesse de convergence
vers la limite <I>l</I> est dite “linéaire”, c’est-à-dire 
que le temps de calcul pour
avoir <I>n</I> décimales est proportionnel à <I>n</I> (ou
encore il faut effectuer un nombre d’itérations
proportionnel à <I>n</I>, chaque itération faisant
gagner en précision de l’ordre du rapport <I>k</I> de contractance). 
En effet, supposons que <I>f</I>′ est continue en <I>l</I> et que 0&lt;<I>L</I>=|<I>f</I>′(<I>l</I>)|&lt;1 .
Il existe alors un intervalle <I>I</I>=[<I>l</I>−η,<I>l</I>+η] tel que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I> ∈ <I>I</I> ⇒ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ≤ |<I>f</I>′(<I>x</I>)| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1+<I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
Le théorème des accroissements finis donne alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>u</I><SUB><I>n</I>+1</SUB> − <I>l</I> | = |<I>f</I>(<I>u</I><SUB><I>n</I></SUB>)−<I>f</I>(<I>l</I>)| = |<I>f</I>′(θ)| |<I>u</I><SUB><I>n</I></SUB>−<I>l</I>|,
   θ ∈ [<I>u</I><SUB><I>n</I></SUB>,<I>l</I>] </TD></TR>
</TABLE><P>
Si <I>u</I><SUB>0</SUB> ∈ <I>I</I>, alors θ ∈ <I>I</I> donc |<I>u</I><SUB>1</SUB>−<I>l</I>| ≤ |<I>u</I><SUB>0</SUB>−<I>l</I>| et
<I>u</I><SUB>1</SUB> ∈ <I>I</I>, par récurrence on a pour tout <I>n</I>, <I>u</I><SUB><I>n</I></SUB> ∈ <I>I</I> 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |<I>u</I><SUB><I>n</I></SUB>−<I>l</I>| ≤ |<I>u</I><SUB><I>n</I>+1</SUB> − <I>l</I>| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1+<I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |<I>u</I><SUB><I>n</I></SUB>−<I>l</I>| </TD></TR>
</TABLE><P>
on a donc par récurrence 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">|<I>u</I><SUB>0</SUB>−<I>l</I>| ≤ |<I>u</I><SUB><I>n</I></SUB>−<I>l</I>| ≤  
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1+<I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">|<I>u</I><SUB>0</SUB>−<I>l</I>|
</TD></TR>
</TABLE><P>
Donc pour avoir |<I>u</I><SUB><I>n</I></SUB>−<I>l</I>| ≤ є il suffit que 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1+<I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">|<I>u</I><SUB>0</SUB>−<I>l</I>| ≤ є ⇒
<I>n</I> ≥ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">ln(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">є</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">|<I>u</I><SUB>0</SUB>−<I>l</I>|</TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">ln( </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1+<I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">) </TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
et il faut que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |<I>u</I><SUB>0</SUB>−<I>l</I>| ≤ є
⇒
<I>n</I> ≥ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">ln(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">є</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">|<I>u</I><SUB>0</SUB>−<I>l</I>|</TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">ln( </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">) </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Si <I>f</I> est suffisamment régulière,
il existe une méthode plus rapide lorsqu’on est proche de la racine ou lorsque
la fonction a des propriétés de convexité, c’est la méthode de Newton
(voir aussi la méthode de la sécante).
Et même si Newton n’est pas applicable, une simple dichotomie
peut être plus efficace si la constante de contractance est 
supérieure à 1/2 (y compris prés de la solution de <I>f</I>(<I>x</I>)=<I>x</I>).
Toutefois la méthode du point fixe reste intéressante si la
constante de contractance est suffisamment petite (par exemple <I>k</I>=0.1
garantit 15 décimales en 15 itérations) et présente l’avantage
de se généraliser en dimension plus grande, cf. la section suivante.</P><!--TOC subsection Le point fixe dans ℝ<SUP><I>n</I></SUP>-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc181">19.3</A>  Le point fixe dans ℝ<SUP><I>n</I></SUP></H3><!--SEC END --><P>
Le théorème précédent se généralise. 
</P><DIV CLASS="theorem"><B>Théorème 37</B>  <EM>
Soit </EM><EM><I>I</I></EM><EM> un ensemble
fermé de </EM><EM>ℝ</EM><SUP><EM><I>n</I></EM></SUP><EM> (ou d’un espace métrique complet) tel que </EM><EM><I>f</I></EM><EM> 
envoie </EM><EM><I>I</I></EM><EM> dans </EM><EM><I>I</I></EM><EM> et tel que </EM><EM><I>f</I></EM><EM> soit contractante sur </EM><EM><I>I</I></EM><EM>
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>∃ <I>k</I>&lt;1, ∀ <I>x</I>,<I>y</I> ∈ <I>I</I>,    |<I>f</I>(<I>x</I>)−<I>f</I>(<I>y</I>)| ≤ <I>k</I> |<I>x</I>−<I>y</I>|</EM></TD></TR>
</TABLE><EM>
Alors pour tout </EM><EM><I>u</I></EM><SUB><EM>0</EM></SUB><EM> ∈ <I>I</I></EM><EM>, la suite </EM><EM>(<I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM>)</EM><EM> définie par
</EM><EM><I>u</I></EM><SUB><EM><I>n</I>+1</EM></SUB><EM>=<I>f</I>(<I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM>)</EM><EM> converge vers l’unique solution dans </EM><EM><I>I</I></EM><EM> de </EM><EM><I>f</I>(<I>l</I>)=<I>l</I></EM><EM>.
</EM></DIV><P>
La démonstration de la convergence est un peu différente de celle 
donnée en
dimension 1, on montre que (<I>u</I><SUB><I>n</I></SUB>) est une suite de Cauchy, car pour <I>n</I>&gt;<I>m</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>u</I><SUB><I>n</I></SUB>−<I>u</I><SUB><I>m</I></SUB>| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=<I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">|<I>u</I><SUB><I>j</I>+1</SUB>−<I>u</I><SUB><I>j</I></SUB> | 
≤ <I>k</I><SUP><I>m</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1−<I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> |<I>u</I><SUB>1</SUB>−<I>u</I><SUB>0</SUB>| </TD></TR>
</TABLE><P>
donc (<I>u</I><SUB><I>n</I></SUB>) est convergente puisque nous sommes dans un fermé 
d’un espace complet. (Cela permet d’ailleurs de généraliser 
l’énoncé donné en dimension 1 au cas où <I>a</I> ou <I>b</I> est infini).</P><P>La vitesse de convergence est linéaire, la démonstration est
identique à celle de la dimension 1.</P><P>Remarque : 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
L’existence d’un point fixe sans hypothèse de contractance
se généralise si <I>I</I> est un convexe compact préservé
par <I>f</I> (théorème
de Brouwer ou de Schauder).
</LI><LI CLASS="li-itemize">Pour vérifier les hypothèses du théorème dans
ℝ<SUP><I>n</I></SUP>, il suffit de montrer que dans <I>I</I> la norme triple de <I>f</I>′
subordonnée à la norme choisie dans ℝ<SUP><I>n</I></SUP> est inférieure
à <I>k</I>&lt;1. Pour <I>f</I> linéaire,
cela revient à calculer une norme subordonnée de matrice
et donne lieu à des méthodes itératives alternatives à
l’inversion de matrice, cf. la section <A HREF="#sec:jacobi">20.9.2</A>.
</LI><LI CLASS="li-itemize">l’algorithme de recherche
PageRank de google utilise le point fixe, en très grande dimension :
<I>n</I> est le nombre de pages Web, <I>I</I> est l’ensemble des vecteurs
de ℝ<SUP><I>n</I></SUP> dont toutes les coordonnées sont positives ou nulles et
dont la somme des coordonnées vaut 1, <I>f</I> est la somme d’un vecteur
constant et du produit du vecteur <I>x</I> par une matrice <I>A</I> transposée
d’une matrice stochastique.
</LI></UL><!--TOC subsection La méthode de Newton dans ℝ.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc182">19.4</A>  La méthode de Newton dans ℝ.</H3><!--SEC END --><P>
La méthode de Newton est une méthode de résolution de l’équation
<I>f</I>(<I>x</I>)=0, attention à la différence avec le théorème du point fixe
qui permet de résoudre numériquement <I>f</I>(<I>x</I>)=<I>x</I>.
Si <I>x</I><SUB>0</SUB> est proche de la racine <I>r</I>
on peut faire un développement de Taylor à l’ordre 1 de la
fonction <I>f</I> en <I>x</I><SUB>0</SUB> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>x</I>)=<I>f</I>(<I>x</I><SUB>0</SUB>)+(<I>x</I>−<I>x</I><SUB>0</SUB>)<I>f</I>′(<I>x</I><SUB>0</SUB>)+<I>O</I>((<I>x</I>−<I>x</I><SUB>0</SUB>)<SUP>2</SUP>) </TD></TR>
</TABLE><P>
Pour trouver une valeur approchée de <I>r</I>, on ne garde que la partie
linéaire du développement, on résout :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>r</I>)=0 ≈ <I>f</I>(<I>x</I><SUB>0</SUB>) + (<I>r</I>−<I>x</I><SUB>0</SUB>) <I>f</I>′(<I>x</I><SUB>0</SUB>) </TD></TR>
</TABLE><P>
donc (si <I>f</I>′(<I>x</I><SUB>0</SUB>)≠ 0) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>r</I> ≈ <I>x</I><SUB>0</SUB> −</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I>(<I>x</I><SUB>0</SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>f</I>′(<I>x</I><SUB>0</SUB>)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Graphiquement, cela revient à tracer la tangente à la courbe représentative
de <I>f</I> et à chercher où elle coupe l’axe des <I>x</I>.
On considère donc la suite récurrente définie par une valeur <I>u</I><SUB>0</SUB>
proche de la racine et par la relation :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I>+1</SUB> = <I>u</I><SUB><I>n</I></SUB> −</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I>(<I>u</I><SUB><I>n</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>f</I>′(<I>u</I><SUB><I>n</I></SUB>)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Il y a deux théorèmes importants, l’un d’eux prouve que
si <I>u</I><SUB>0</SUB> est “assez proche” de <I>r</I> alors la suite <I>u</I><SUB><I>n</I></SUB> converge vers <I>r</I>,
malheureusement il est difficile de savoir en pratique si on est 
“assez proche” de <I>u</I><SUB>0</SUB> pour que ce théorème s’applique. Le second
théorème donne un critère pratique facile à vérifier qui assure
la convergence, il utilise les propriétés de convexité de la fonction.</P><DIV CLASS="theorem"><B>Théorème 38</B>  <EM> </EM><A NAME="@default220"></A><EM>
Soit </EM><EM><I>f</I></EM><EM> une fonction de classe </EM><EM><I>C</I></EM><SUP><EM>2</EM></SUP><EM> (2 fois continument dérivable)
sur un intervalle fermé </EM><EM><I>I</I></EM><EM>. Soit </EM><EM><I>r</I></EM><EM> une racine simple de </EM><EM><I>f</I></EM><EM>
située à l’intérieur de </EM><EM><I>I</I></EM><EM>
(telle que </EM><EM><I>f</I>(<I>r</I>)=0</EM><EM> et </EM><EM><I>f</I>′(<I>r</I>)≠ 0</EM><EM>). Alors il existe </EM><EM>ε&gt;0</EM><EM>
tel que la suite définie par
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><I>u</I></EM><SUB><EM><I>n</I>+1</EM></SUB><EM> = <I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM> −</EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>f</I>(<I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM>)</EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>f</I>′(<I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM>)</EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>,    |<I>u</I></EM><SUB><EM>0</EM></SUB><EM>−<I>r</I>| ≤ ε </EM></TD></TR>
</TABLE><EM>
converge vers </EM><EM><I>r</I></EM><EM>.</EM><P><EM>Si on a </EM><EM>|<I>f</I>′</EM><EM>′</EM><EM>| ≤ <I>M</I></EM><EM> et </EM><EM>|1/<I>f</I>′| ≤ <I>m</I></EM><EM> sur un intervalle 
</EM><EM>[<I>r</I>−η,<I>r</I>+η]</EM><EM> contenu dans </EM><EM><I>I</I></EM><EM>, alors on peut prendre tout réel
</EM><EM>ε&gt;0</EM><EM> tel que </EM><EM>ε &lt; 2/(<I>mM</I>)</EM><EM> et </EM><EM>ε ≤ η</EM><EM>.
</EM></P></DIV><P><B>Démonstration</B> : on a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I>+1</SUB>−<I>r</I> = <I>u</I><SUB><I>n</I></SUB> − <I>r</I> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I>(<I>u</I><SUB><I>n</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>f</I>′(<I>u</I><SUB><I>n</I></SUB>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> = 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>u</I><SUB><I>n</I></SUB>−<I>r</I>)<I>f</I>′(<I>u</I><SUB><I>n</I></SUB>)−<I>f</I>(<I>u</I><SUB><I>n</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>f</I>′(<I>u</I><SUB><I>n</I></SUB>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
En appliquant un développement de Taylor de <I>f</I> en <I>u</I><SUB><I>n</I></SUB> à l’ordre 2,
on obtient pour un réel θ
situé entre <I>r</I> et <I>u</I><SUB><I>n</I></SUB> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">0 = <I>f</I>(<I>r</I>)=<I>f</I>(<I>u</I><SUB><I>n</I></SUB>)+(<I>r</I>−<I>u</I><SUB><I>n</I></SUB>) <I>f</I>′(<I>u</I><SUB><I>n</I></SUB>) + (<I>r</I>−<I>u</I><SUB><I>n</I></SUB>)<SUP>2</SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I>′′(θ)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>u</I><SUB><I>n</I></SUB>−<I>r</I>)<I>f</I>′(<I>u</I><SUB><I>n</I></SUB>)−<I>f</I>(<I>u</I><SUB><I>n</I></SUB>)= (<I>u</I><SUB><I>n</I></SUB>−<I>r</I>)<SUP>2</SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I>′′(θ)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
d’où :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>u</I><SUB><I>n</I>+1</SUB>−<I>r</I>| ≤ |<I>u</I><SUB><I>n</I></SUB>−<I>r</I>|<SUP>2</SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">|<I>f</I>′(<I>u</I><SUB><I>n</I></SUB>)|</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">|<I>f</I>′′(θ)|</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
On commence par choisir un intervalle [<I>r</I>−ε,<I>r</I>+ε]
contenant strictement <I>r</I> et tel que |<I>f</I>′′|&lt;<I>M</I> et |1/<I>f</I>′|&lt;<I>m</I>
sur [<I>r</I>−ε,<I>r</I>+ε] (c’est toujours possible car
<I>f</I>′′ et 1/<I>f</I>′ sont continues au voisinage de <I>r</I> puisque <I>f</I>′(<I>r</I>)≠ 0).
Si <I>u</I><SUB><I>n</I></SUB> est dans cet intervalle, alors θ aussi donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><A NAME="eq:newton"></A>
|<I>u</I><SUB><I>n</I>+1</SUB>−<I>r</I>| ≤ |<I>u</I><SUB><I>n</I></SUB>−<I>r</I>|<SUP>2</SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>Mm</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ≤  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">|<I>u</I><SUB><I>n</I></SUB>−<I>r</I>|<I>Mm</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">
|<I>u</I><SUB><I>n</I></SUB>−<I>r</I>|,  
    (42)</TD></TR>
</TABLE><P>
On a |<I>u</I><SUB><I>n</I></SUB>−<I>r</I>| ≤ ε, on diminue si nécessaire
ε pour avoir ε &lt; 2/(<I>Mm</I>), on a alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>u</I><SUB><I>n</I>+1</SUB>−<I>r</I>| ≤ <I>k</I> |<I>u</I><SUB><I>n</I></SUB>−<I>r</I>|,    <I>k</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">ε <I>Mm</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">&lt;1  </TD></TR>
</TABLE><P>
donc d’une part <I>u</I><SUB><I>n</I>+1</SUB> est encore dans l’intervalle 
[<I>r</I>−ε,<I>r</I>+ε] 
ce qui permettra de refaire le même raisonnement au rang
suivant, et d’autre part
on a une convergence au moins géométrique vers <I>r</I>.
En fait la convergence est bien meilleure
lorsqu’on est proche de <I>r</I> grace au carré dans |<I>u</I><SUB><I>n</I></SUB>−<I>r</I>|<SUP>2</SUP>,
plus précisément, on montre par récurrence que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>u</I><SUB><I>n</I></SUB>−<I>r</I>| ≤ |<I>u</I><SUB>0</SUB> − <I>r</I>|<SUP>2<SUP><I>n</I></SUP></SUP> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>Mm</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">2<SUP><I>n</I></SUP>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
il faut donc un nombre d’itérations proportionnel à ln(<I>n</I>)
pour atteindre une précision donnée.</P><P><B>Remarque :</B> ce théorème se généralise sur ℂ et même sur ℝ<SUP><I>n</I></SUP>
(cf. la section suivante).</P><P><B>Exemple :</B> pour calculer √<SPAN style="text-decoration:overline">2</SPAN>, on écrit l’équation <I>x</I><SUP>2</SUP>−2=0
qui a √<SPAN style="text-decoration:overline">2</SPAN> comme racine simple sur <I>I</I>=[1/2,2], 
on obtient la suite récurrente
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I>+1</SUB> = <I>u</I><SUB><I>n</I></SUB> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I></SUB><SUP>2</SUP>−2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>u</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
Si on prend η=1/2, on a <I>f</I>′=2<I>x</I> et <I>f</I>′′=2
donc on peut prendre <I>M</I>=2 et <I>m</I>=1 car |1/<I>f</I>′|≤ 1 sur 
[√<SPAN style="text-decoration:overline">2</SPAN>−1/2,√<SPAN style="text-decoration:overline">2</SPAN>+1/2]. On a 2/(<I>mM</I>)=1, on peut donc 
prendre ε=1/2, la suite convergera pour tout 
 <I>u</I><SUB>0</SUB> ∈ [√<SPAN style="text-decoration:overline">2</SPAN>−1/2,√<SPAN style="text-decoration:overline">2</SPAN>+1/2].</P><P>Plus généralement, on peut calculer une racine <I>k</I>-ième d’un réel <I>a</I>
en résolvant <I>f</I>(<I>x</I>)=<I>x</I><SUP><I>k</I></SUP>−<I>a</I> par la méthode de Newton.</P><P>L’inconvénient de ce théorème
est qu’il est difficile de savoir si la valeur de départ qu’on
a choisie se trouve suffisamment près d’une racine pour que
la suite converge. Pour illustrer le phénomène, 
on peut par exemple colorer les points du plan
complexe en <I>n</I>+1 couleurs selon que la suite définie par la méthode
de Newton converge vers l’une des <I>n</I> racines d’un polynôme de degré
<I>n</I> fixé au bout de par exemple 50 itérations (la <I>n</I>+1-ième couleur
servant aux origines de suite qui ne semblent pas converger).</P><P>Passons maintenant à un critère très utile en pratique :
</P><DIV CLASS="theorem"><B>Définition 39</B>  <EM> (</EM><EM><B>convexité</B></EM><EM>)</EM><A NAME="@default221"></A><EM><BR>
Une fonction </EM><EM><I>f</I></EM><EM> continument dérivable sur un intervalle </EM><EM><I>I</I></EM><EM> de </EM><EM>ℝ</EM><EM>
est dite convexe si son graphe est au-dessus de la tangente en tout point
de </EM><EM><I>I</I></EM><EM>.
</EM></DIV><P>
Il existe un critère simple permettant de savoir si
une fonction de classe <I>C</I><SUP>2</SUP> est convexe :
</P><DIV CLASS="theorem"><B>Théorème 40</B>  <EM>
Si </EM><EM><I>f</I></EM><EM> est </EM><EM><I>C</I></EM><SUP><EM>2</EM></SUP><EM> et </EM><EM><I>f</I>′</EM><EM>′</EM><EM> ≥ 0</EM><EM> sur </EM><EM><I>I</I></EM><EM> alors </EM><EM><I>f</I></EM><EM> est convexe.
</EM></DIV><P>
<B>Démonstration</B> :<BR>
L’équation de la tangente au graphe en <I>x</I><SUB>0</SUB> est 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>=<I>f</I>(<I>x</I><SUB>0</SUB>)+<I>f</I>′(<I>x</I><SUB>0</SUB>)(<I>x</I>−<I>x</I><SUB>0</SUB>) </TD></TR>
</TABLE><P>
Soit
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>g</I>(<I>x</I>)=<I>f</I>(<I>x</I>)−(<I>f</I>(<I>x</I><SUB>0</SUB>)+<I>f</I>′(<I>x</I><SUB>0</SUB>)(<I>x</I>−<I>x</I><SUB>0</SUB>)) </TD></TR>
</TABLE><P>
on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>g</I>(<I>x</I><SUB>0</SUB>)=0,    <I>g</I>′(<I>x</I>)=<I>f</I>′(<I>x</I>)−<I>f</I>′(<I>x</I><SUB>0</SUB>),    <I>g</I>′(<I>x</I><SUB>0</SUB>)=0, 
   <I>g</I>′′=<I>f</I>′′ ≥ 0 </TD></TR>
</TABLE><P>
donc <I>g</I>′ est croissante, comme <I>g</I>′(<I>x</I><SUB>0</SUB>)=0, <I>g</I>′ est négative
pour <I>x</I>&lt;<I>x</I><SUB>0</SUB> et positive pour <I>x</I>&gt;<I>x</I><SUB>0</SUB>, donc <I>g</I> est décroissante
pour <I>x</I>&lt;<I>x</I><SUB>0</SUB> et croissante pour <I>x</I>&gt;<I>x</I><SUB>0</SUB>. On conclut alors que
<I>g</I> ≥ 0 puisque <I>g</I>(<I>x</I><SUB>0</SUB>)=0. Donc <I>f</I> est bien au-dessus
de sa tangente.</P><P>On arrive au deuxième théorème sur la méthode de Newton
</P><DIV CLASS="theorem"><B>Théorème 41</B>  <EM> </EM><A NAME="@default222"></A><EM>
Si </EM><EM><I>f</I>(<I>r</I>)=0, <I>f</I>′(<I>r</I>)&gt;0</EM><EM> et si </EM><EM><I>f</I>′</EM><EM>′</EM><EM> ≥ 0</EM><EM> sur </EM><EM>[<I>r</I>,<I>b</I>]</EM><EM> alors
pour tout </EM><EM><I>u</I></EM><SUB><EM>0</EM></SUB><EM> ∈ [<I>r</I>,<I>b</I>]</EM><EM> la suite de la méthode de Newton
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><I>u</I></EM><SUB><EM><I>n</I>+1</EM></SUB><EM> = <I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM> −</EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>f</I>(<I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM>)</EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>f</I>′(<I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM>)</EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>,  </EM></TD></TR>
</TABLE><EM>
est définie, décroissante, minorée par </EM><EM><I>r</I></EM><EM> et converge vers 
</EM><EM><I>r</I></EM><EM>. De plus
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>0 ≤ <I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM> −<I>r</I> ≤ </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>f</I>(<I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM>)</EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>f</I>′(<I>r</I>)</EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> </EM></TD></TR>
</TABLE><EM>
(On prendra garde dans cette estimation aux erreurs en calcul
approché, le calcul de la valeur de </EM><EM><I>f</I>(<I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM>)</EM><EM>, proche de 0, va typiquement
faire intervenir la différence de deux termes très proches,
d’où perte de précision sur la mantisse)
</EM></DIV><P><B>Démonstration</B> :<BR>
On a <I>f</I>′′ ≥ 0 donc si <I>f</I>′(<I>r</I>)&gt;0 alors <I>f</I>′&gt;0
sur [<I>r</I>,<I>b</I>], <I>f</I> est donc strictement croissante sur [<I>r</I>,<I>b</I>]
on en déduit que <I>f</I>&gt;0 sur ]<I>r</I>,<I>b</I>] donc <I>u</I><SUB><I>n</I>+1</SUB> ≤ <I>u</I><SUB><I>n</I></SUB>.
Comme la courbe représentative de <I>f</I> est au-dessus de la tangente,
on a <I>u</I><SUB><I>n</I>+1</SUB> ≥ <I>r</I> (car <I>u</I><SUB><I>n</I>+1</SUB> est l’abscisse du point
d’intersection de la tangente avec l’axe des <I>x</I>). 
La suite <I>u</I><SUB><I>n</I></SUB> est donc décroissante minorée par <I>r</I>, donc convergente
vers une limite <I>l</I>≥ <I>r</I>. À la limite, on a 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>l</I>=<I>l</I>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I>(<I>l</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>f</I>′(<I>l</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ⇒ <I>f</I>(<I>l</I>)=0 </TD></TR>
</TABLE><P>
donc <I>l</I>=<I>r</I> car <I>f</I>&gt;0 sur ]<I>r</I>,<I>b</I>].</P><P>Comme (<I>u</I><SUB><I>n</I></SUB>) est décroissante, on a bien 0 ≤ <I>u</I><SUB><I>n</I></SUB> −<I>r</I>,
pour montrer l’autre inégalité, on applique le théorème
des accroissements finis, il existe θ ∈ [<I>r</I>,<I>u</I><SUB><I>n</I></SUB>] tel que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>u</I><SUB><I>n</I></SUB>)−<I>f</I>(<I>r</I>)=(<I>u</I><SUB><I>n</I></SUB>−<I>r</I>)<I>f</I>′(θ) </TD></TR>
</TABLE><P>
comme <I>f</I>(<I>r</I>)=0, on a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I></SUB>−<I>r</I> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I>(<I>u</I><SUB><I>n</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>f</I>′(θ)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
et la deuxième inégalité du théorème
en découle parce que <I>f</I>′ est croissante.</P><P><B>Variantes</B> :<BR>
Il existe des variantes, par exemple si <I>f</I>′(<I>r</I>)&lt;0 et <I>f</I>′′ ≥ 0
sur [<I>a</I>,<I>r</I>]. Si <I>f</I>′′ ≤ 0, on considère <I>g</I>=−<I>f</I>.</P><P><B>Application</B> :<BR>
On peut calculer la valeur approchée de la 
racine <I>k</I>-ième d’un réel <I>a</I>&gt;0 en appliquant ce deuxième
théorème. En effet si
<I>a</I>&gt;0, alors <I>x</I><SUP><I>k</I></SUP>−<I>a</I> est 2 fois continument dérivable et 
de dérivée première <I>kx</I><SUP><I>k</I>−1</SUP>  et
seconde <I>k</I>(<I>k</I>−1)<I>x</I><SUP><I>k</I>−2</SUP> strictement positives sur ℝ<SUP>+∗</SUP> (car <I>k</I> ≥ 2).
Il suffit donc de prendre une valeur de départ <I>u</I><SUB>0</SUB> plus grande que
la racine <I>k</I>-ième, par exemple 1+<I>a</I>/<I>k</I> (en effet
(1+<I>a</I>/<I>k</I>)<SUP><I>k</I></SUP> ≥ 1+<I>k</I> <I>a</I>/<I>k</I>=1+<I>a</I>).
En appliquant l’inégalité du théorème, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">0 ≤ <I>u</I><SUB><I>n</I></SUB> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎝</TD><TD CLASS="dcell"><I>a</I></TD><TD CLASS="dcell">⎞<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ≤  
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I></SUB><SUP><I>k</I></SUP> − <I>a</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>k</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎝</TD><TD CLASS="dcell"><I>a</I></TD><TD CLASS="dcell">⎞<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP><I>k</I>−1</SUP> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I></SUB><SUP><I>k</I></SUP>−<I>a</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ka</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎝</TD><TD CLASS="dcell"><I>a</I></TD><TD CLASS="dcell">⎞<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I></SUB><SUP><I>k</I></SUP>−<I>a</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>ka</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (1+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)
</TD></TR>
</TABLE><P>
Pour avoir une valeur approchée de (<I>a</I>)<SUP>1/<I>k</I></SUP> à ε près,
on peut donc choisir comme test d’arrêt 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I></SUB><SUP><I>k</I></SUP> −<I>a</I> ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>ka</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">1+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ε </TD></TR>
</TABLE><P>
Par exemple pour √<SPAN style="text-decoration:overline">2</SPAN>, le test d’arrêt serait 
<I>u</I><SUB><I>n</I></SUB><SUP>2</SUP>−2 ≤ 2 ε.</P><!--TOC subsection La méthode de Newton dans ℝ<SUP><I>n</I></SUP>.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc183">19.5</A>  La méthode de Newton dans ℝ<SUP><I>n</I></SUP>.</H3><!--SEC END --><P>
Le premier énoncé du cas de la dimension 1 se généralise en :
</P><DIV CLASS="theorem"><B>Théorème 42</B>  <EM> </EM><A NAME="@default223"></A><EM>
Soit </EM><EM><I>f</I></EM><EM> une fonction de classe </EM><EM><I>C</I></EM><SUP><EM>2</EM></SUP><EM> (2 fois continument dérivable)
sur un fermé </EM><EM><I>I</I></EM><EM> de </EM><EM>ℝ</EM><SUP><EM><I>n</I></EM></SUP><EM>. Soit </EM><EM><I>r</I></EM><EM> une racine simple de </EM><EM><I>f</I></EM><EM>
située à l’intérieur de </EM><EM><I>I</I></EM><EM>
(telle que </EM><EM><I>f</I>(<I>r</I>)=0</EM><EM> et </EM><EM><I>f</I>′(<I>r</I>)=(∂</EM><SUB><EM><I>j</I></EM></SUB><EM> <I>f</I></EM><SUB><EM><I>i</I></EM></SUB><EM>)(<I>r</I>)</EM><EM> inversible). 
Alors il existe </EM><EM>ε&gt;0</EM><EM>
tel que la suite définie par
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><I>u</I></EM><SUB><EM><I>n</I>+1</EM></SUB><EM> = <I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM> −(<I>f</I>′(<I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM>) )</EM><SUP><EM>−1</EM></SUP><EM><I>f</I>(<I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM>),    |<I>u</I></EM><SUB><EM>0</EM></SUB><EM>−<I>r</I>| ≤ ε </EM></TD></TR>
</TABLE><EM>
converge vers </EM><EM><I>r</I></EM><EM>.</EM><P><EM>Si on a </EM><EM>|<I>f</I>′</EM><EM>′</EM><EM>| ≤ <I>M</I></EM><EM> et </EM><EM>|(<I>f</I>′)</EM><SUP><EM>−1</EM></SUP><EM>| ≤ <I>m</I></EM><EM> sur une boule
centré en </EM><EM><I>r</I></EM><EM> de rayon </EM><EM>η&gt;0</EM><EM> contenue dans </EM><EM><I>I</I></EM><EM>, alors on peut prendre tout réel
</EM><EM>ε&gt;0</EM><EM> tel que </EM><EM>ε &lt; 2/(<I>mM</I>)</EM><EM> et </EM><EM>ε ≤ η</EM><EM>.
</EM></P></DIV><P>
La démonstration est calquée sur la dimension 1, mais il faut
prendre le reste intégral dans la formule de Taylor
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I>+1</SUB>−<I>r</I> = <I>u</I><SUB><I>n</I></SUB> − <I>r</I> − <I>f</I>′(<I>u</I><SUB><I>n</I></SUB>)<SUP>−1</SUP> <I>f</I>(<I>u</I><SUB><I>n</I></SUB>) = 
<I>f</I>′(<I>u</I><SUB><I>n</I></SUB>)<SUP>−1</SUP> (<I>f</I>′(<I>u</I><SUB><I>n</I></SUB>)(<I>u</I><SUB><I>n</I></SUB>−<I>r</I>)−<I>f</I>(<I>u</I><SUB><I>n</I></SUB>) ) </TD></TR>
</TABLE><P>
puis on applique Taylor le long du segment [<I>r</I>,<I>u</I><SUB><I>n</I></SUB>] :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">0 = <I>f</I>(<I>r</I>)=<I>f</I>(<I>u</I><SUB><I>n</I></SUB>)+ <I>f</I>′(<I>u</I><SUB><I>n</I></SUB>) (<I>r</I>−<I>u</I><SUB><I>n</I></SUB>)+  </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (1−θ)(<I>r</I>−<I>u</I><SUB><I>n</I></SUB>)
<I>f</I>′′(<I>r</I>+θ (<I>u</I><SUB><I>n</I></SUB>−<I>r</I>)) (<I>r</I>−<I>u</I><SUB><I>n</I></SUB>)   <I>d</I>θ </TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I>+1</SUB>−<I>r</I> =−<I>f</I>′(<I>u</I><SUB><I>n</I></SUB>)<SUP>−1</SUP>  (<I>r</I>−<I>u</I><SUB><I>n</I></SUB>) 
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (1−θ)<I>f</I>′′(<I>r</I>+θ (<I>u</I><SUB><I>n</I></SUB>−<I>r</I>))   <I>d</I>θ </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">(<I>r</I>−<I>u</I><SUB><I>n</I></SUB>)  </TD></TR>
</TABLE><P>
et on en déduit (<A HREF="#eq:newton">42</A>) et on conclut de même en
remplaçant intervalle centré en <I>r</I> de rayon ε
par boule de rayon ε.</P><P>Remarque : la convergence “numérique” (au sens du calcul en
flottant) de la suite <I>u</I><SUB><I>n</I></SUB> ne suffit pas à montrer l’existence
d’une racine proche de <I>u</I><SUB><I>n</I></SUB>. Une méthode de preuve alternative
au calcul des constantes <I>m</I> et <I>M</I> consiste
à trouver un rectangle ou une boule autour de <I>u</I><SUB><I>n</I></SUB> préservée
par l’application <I>x</I>→ <I>x</I>−<I>f</I>′(<I>x</I>)<SUP>−1</SUP> <I>f</I>(<I>x</I>).</P><!--TOC subsection Calcul approché des racines complexes simples-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc184">19.6</A>  Calcul approché des racines complexes simples</H3><!--SEC END --><P> 
<A NAME="@default224"></A> <A NAME="@default225"></A> <A NAME="sec:proot"></A>
La section précédente nous a montré qu’on pouvait
se ramener à la recherche de racines simples, ce qui 
donne envie d’essayer la méthode de Newton. On a malheureusement
rarement la possibilité de pouvoir démontrer qu’à partir d’une valeur
initiale donnée, la méthode de Newton converge, 
parce que les racines peuvent être complexes, et même si elles
sont réelles, on n’a pas forcément de résultat sur la convexité
du polynôme (cf. cependant une application des suites de
Sturm qui permet de connaitre le signe
de <I>P</I>′′ sur un intervalle sans le factoriser).</P><P>Par contre, on peut montrer à postériori des estimations sur la
distance entre une racine approchée et la racine la plus proche
d’un polynôme, plus précisément cette distance est inférieure
ou égale au degré du polynôme multiplié par le module
de <I>P</I>/<I>P</I>′ en la racine approchée (<A HREF="#sec:autres_algorithmes">5.3</A>).</P><P>On effectue donc souvent des itérations de Newton, en partant de
0.0, en espérant s’approcher suffisamment d’une racine pour que
le théorème de convergence théorique s’applique. On se fixe
un nombre maximal d’itérations, si on le dépasse on prend alors
une valeur initiale aléatoire complexe et on recommence.</P><P>Une fois une racine déterminée, on l’élimine en calculant
le quotient euclidien <I>Q</I> de <I>P</I> par <I>X</I>−<I>r</I> (par l’algorithme de Horner),
puis on calcule les racines du quotient <I>Q</I> (qui sont des racines de <I>P</I>).</P><P>Un problème pratique apparait alors, c’est que <I>r</I> n’est pas exact
donc le quotient <I>Q</I> non plus, au fur et à mesure du calcul des
racines de <I>P</I>, on perd de plus en plus de précision.
Il existe une amélioration simple, si <I>r</I>′ est une racine
approchée de <I>Q</I>, alors elle est racine approchée de <I>P</I>
et on a toutes les chances qu’elle soit suffisamment proche
d’une racine de <I>P</I> pour que le théorème s’applique, on
effectue alors 1 ou 2 itérations de Newton avec <I>r</I>′ mais pour <I>P</I>
(et non <I>Q</I>) afin d’améliorer sa précision comme racine de <I>P</I>.</P><P>Une méthode de calcul plus stable utilise la recherche des valeurs
propres de la matrice companion en double précision, 
puis affine par la méthode de
Newton pour obtenir des valeurs approchées multi-précision,
c’est ce que fait <CODE>proot</CODE>, par exemple <CODE>proot(x^3+x+1,50)</CODE>.
Il existe aussi un algorithme de recherche de racines
dû à Schönhage dont la convergence
est garantie, cet algorithme est implémenté dans PARI (voir
la thèse de Xavier Gourdon et l’article Splitting circle method de Wikipedia)
et est appelé par Xcas pour des polynômes mals conditionnés.</P><P>Enfin, on peut appliquer directement la méthode de Newton pour
trouver dans ℂ<SUP><I>n</I></SUP> toutes les racines simultanément, c’est la
méthode de <B>Durand-Kerner, Weierstrass</B><A NAME="@default226"></A>.
On pose <I>g</I><SUB><I>x</I></SUB>(<I>z</I>)=∏<SUB><I>i</I>=1</SUB><SUP><I>n</I></SUP> (<I>x</I>−<I>z</I><SUB><I>i</I></SUB>), il s’agit de résoudre en <I>z</I>
<I>g</I><SUB><I>x</I></SUB>(<I>z</I>)=<I>P</I>(<I>x</I>). On a a l’ordre 1 en <I>z</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>g</I><SUB><I>x</I></SUB>(<I>z</I>+<I>w</I>)=<I>g</I><SUB><I>x</I></SUB>(<I>z</I>) − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>w</I><SUB><I>i</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> ≠ <I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>x</I>−<I>z</I><SUB><I>j</I></SUB>) +<I>O</I>(<I>w</I><SUP>2</SUP>)
=<I>P</I>(<I>x</I>)</TD></TR>
</TABLE><P>
pour trouver <I>w</I><SUB><I>i</I></SUB>, on pose <I>x</I>=<I>z</I><SUB><I>i</I></SUB>, on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> ≠ <I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>z</I><SUB><I>i</I></SUB>−<I>z</I><SUB><I>j</I></SUB>) <I>w</I><SUB><I>i</I></SUB> = <I>P</I>(<I>z</I><SUB><I>i</I></SUB>)</TD></TR>
</TABLE><P>
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>w</I><SUB><I>i</I></SUB>=−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I>(<I>z</I><SUB><I>i</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> ≠ <I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>z</I><SUB><I>i</I></SUB>−<I>z</I><SUB><I>j</I></SUB>)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On peut aussi calculer le produit du dénominateur en effectuant
<I>g</I><SUB><I>x</I></SUB>′(<I>z</I><SUB><I>i</I></SUB>) (la dérivée porte sur <I>x</I>). 
On retrouve la méthode de Newton à une variable
où la dérivée du polynôme au dénominateur est remplacée 
par la valeur approchée du polynôme.
D’où le programme
</P><PRE CLASS="verbatim">dw(P,N,eps):={ // Weierstrass, Durand-Kerner polynomial rooter
  local l,v,w,n,j,k,q,q1;
  P:=P/lcoeff(P);
  n:=degree(P);
  assume(l,symbol);
  v:=seq(exp(i*l/n*2.0*pi),l,0,n-1); w:=v;
  for k from 1 to N do
    q:=pcoeff(v);
    q1:=q';
    for j from 0 to n-1 do
      w[j]:=v[j]-horner(P,v[j])/horner(q1,v[j]);
    od;
    if (l2norm(w-v)&lt;eps*l2norm(v))
      return w;
    v:=w;
  od;
  retourne "max iter reached";
}:;
</PRE><P>Par exemple <CODE>dw(x^3+x+1,100,1e-10)</CODE> renvoie des valeurs
approchées des racines de <I>x</I><SUP>3</SUP>+<I>x</I>+1.</P><P>Si on s’intéresse seulement à la racine de module maximal d’un
polynôme, on peut
en trouver une estimation assez simplement en appliquant la méthode
de la puissance à la matrice companion du polynôme.
On peut améliorer la précision d’une racine
par des itérations inverses ou par la méthode de Newton en une
variable.</P><!--TOC section Algèbre linéaire-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc185">20</A>  Algèbre linéaire</H2><!--SEC END --><P> <A NAME="sec:linalg"></A>
On présente ici des algorithmes autour de la résolution exacte
et approchée de systèmes (réduction des matrices sous forme échelonnée) 
et la recherche de valeurs propres et de vecteurs propres 
(diagonalisation et jordanisation des matrices).</P><!--TOC subsection Résolution de systèmes, calcul de déterminant.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc186">20.1</A>  Résolution de systèmes, calcul de déterminant.</H3><!--SEC END --><!--TOC subsubsection La méthode du pivot de Gauß.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc187">20.1.1</A>  La méthode du pivot de Gauß.</H4><!--SEC END --><P><A NAME="@default227"></A> <A NAME="@default228"></A>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Le pivot : on détermine à partir d’une ligne <I>i</I> 
la ligne <I>j</I> où apparait le premier coefficient non nul <I>p</I> dans
la colonne à réduire. On échange les lignes
<I>i</I> et <I>j</I>. Puis pour <I>j</I>&gt;<I>i</I> (réduction sous-diagonale)
ou <I>j</I>≠ <I>i</I> (réduction complète), on effectue l’opération
<I>L</I><SUB><I>j</I></SUB> ← <I>L</I><SUB><I>j</I></SUB> − <I>p</I><SUB><I>j</I></SUB>/<I>p</I><I>L</I><SUB><I>i</I></SUB>.<BR>
Inconvénient : avec des données exactes de taille non bornée, 
la complexité des coefficients augmente plus vite qu’en choisissant 
le pivot le plus simple possible, (remarque, lorsque les données 
sont approchées, on n’utilise pas non plus cette méthode
pour des raisons de stabilité numérique).
Le domaine d’utilisation naturel concerne donc les coefficients
dans un corps fini (par exemple ℤ/<I>n</I>ℤ).
</LI><LI CLASS="li-itemize">Le pivot partiel. On choisit le meilleur coefficient non nul de la
colonne, où meilleur dépend du type de coefficient : avec des données
exactes, on choisirait le coefficient de taille la plus petite possible,
avec des données approximatives, on choisit
le coefficient de plus grande norme dans la colonne.
Le domaine d’utilisation naturel concerne les coefficients
approchés. Pour les coefficients exacts, on remplacerait la
réduction par <I>L</I><SUB><I>j</I></SUB> ← <I>pL</I><SUB><I>j</I></SUB> −<I>p</I><SUB><I>j</I></SUB> <I>L</I><SUB><I>i</I></SUB> pour ne pas effectuer
de division. Mais avec cette méthode, la taille des coefficients
augmente de manière exponentielle. On peut améliorer
la taille des coefficients intermédiaires en divisant chaque
ligne par le PGCD de ses coefficients, mais comme pour le
calcul du PGCD par l’algorithme du sous-résultant, il existe
une méthode plus efficace présentée ci-dessous.
</LI><LI CLASS="li-itemize">La méthode de <B>Bareiss</B> :<A NAME="@default229"></A> on initialise un coefficient <I>b</I> à 1.
On remplace l’étape de réduction ci-dessus
par <I>L</I><SUB><I>j</I></SUB> ← (<I>pL</I><SUB><I>j</I></SUB> −<I>p</I><SUB><I>j</I></SUB> <I>L</I><SUB><I>i</I></SUB>)/<I>b</I>.
À la fin de l’étape de réduction, on met le coefficient <I>b</I>
à la valeur du pivot <I>p</I>. L’intérêt de la méthode est que la division
se fait sans introduire de fraction (la preuve pour les deux premières
étapes se fait facilement à la main ou avec
un système de calcul formel (cf. infra), pour le cas général, on vérifie
que le déterminant de la matrice de départ
est égal au dernier coefficient sur la diagonale obtenu par
cette méthode de réduction, ce dernier est donc entier, le
même raisonnement fait sur des sous-matrices dont on prend les
<I>k</I> premières lignes et colonnes et une autre ligne et une autre
colonne montre que tous les coefficients des matrices intermédiaires
sont entiers).
On peut utiliser cette méthode aussi bien pour la réduction
sous-diagonale que pour la réduction complète (les lignes
intervenant dans la combinaison linéaire subissent des 
modifications identiques dans les deux cas).
</LI></UL><P>
Vérifions
qu’on n’introduit pas de dénominateur dans la méthode
de Bareiss. Sans
restreindre la généralité, il suffit de le montrer avec une
matrice 3x3 à coefficients symboliques génériques. 
</P><PRE CLASS="verbatim">Pivot(M,n,m,r):={ 
 // n ligne du pivot, m colonne, r ligne a modifier
 local COL,j,a,b; 
 COL:=ncols(M);
 a:=M[n,m];
 b:=M[r,m];
 for j from 0 to COL-1 do
   // afficher(j,a,b,n,m,r);
   M[r,j]:=a*M[r,j]-b*M[n,j];
 end_for;
 return(M);
}:; 
M:=matrix(3,3,[[A,B,C],[D,E,F],[G,H,J]]);
M:=Pivot(M,0,0,1); M:=Pivot(M,0,0,2); /* 1ere colonne */
M:=Pivot(M,1,1,2); M:=Pivot(M,1,1,0); /* 2eme colonne */
factor(M[2,2]);
</PRE><P>Ce qui met bien en évidence le facteur <I>A</I> dans <I>M</I><SUB>3,3</SUB>.</P><!--TOC subsubsection Le déterminant.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc188">20.1.2</A>  Le déterminant.</H4><!--SEC END --><P><A NAME="@default230"></A>
On peut bien sûr appliquer les méthodes ci-dessus en tenant compte
des pivots utilisés et du produit des coefficients diagonaux. Dans le cas de 
la méthode de Bareiss, si on effectue la réduction sous-diagonale
uniquement, il n’est pas nécessaire de garder une trace des pivots
et de calculer le produit des coefficients diagonaux,
montrons que la valeur du déterminant est égal au 
dernier coefficient diagonal : en effet si <I>R</I> désigne la matrice réduite et
que l’on pose <I>R</I><SUB>0,0</SUB>=1, alors la réduction par la méthode de
Bareiss de la colonne <I>i</I> a pour effet de multiplier le déterminant 
de la matrice initiale <I>M</I> par (<I>R</I><SUB><I>i</I>,<I>i</I></SUB>/(<I>R</I><SUB><I>i</I>−1,<I>i</I>−1</SUB>)<SUP><I>n</I>−<I>i</I></SUP>. Donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> det(<I>R</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">det(<I>M</I>)  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell">
(<I>R</I><SUB><I>i</I>,<I>i</I></SUB>/(<I>R</I><SUB><I>i</I>−1,<I>i</I>−1</SUB>)<SUP><I>n</I>−<I>i</I></SUP> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>R</I><SUB><I>i</I>,<I>i</I></SUB></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">det(<I>M</I>)  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>R</I><SUB><I>i</I>,<I>i</I></SUB>  </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><I>R</I><SUB><I>n</I>,<I>n</I></SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>det(<I>M</I>)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Pour les matrices à coefficients entiers, on peut aussi utiliser une
méthode 
<B>modulaire</B><A NAME="@default231"></A><A NAME="@default232"></A> :
on calcule une borne à priori sur le déterminant
et on calcule le déterminant modulo suffisamment de petits nombres
premiers pour le reconstruire par les restes chinois. En effet
si le produit des nombres premiers utilisés
est supérieur au double d’un majorant de la valeur absolue du
déterminant, alors le déterminant est le résultat des restes chinois
écrit en représentation symétrique.
L’avantage de cet algorithme est qu’il est simple et facile à paralléliser.</P><P>On utilise souvent la <B>borne d’Hadamard</B><A NAME="@default233"></A> 
sur le déterminant :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|det(<I>M</I>)| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1≤ <I>i</I> ≤ <I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1≤ <I>j</I> ≤ <I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> |<I>m</I><SUB><I>i</I>,<I>j</I></SUB>|<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Preuve de la borne : on majore le déterminant par le produit des
normes des vecteurs colonnes de <I>M</I>.</P><P>L’algorithme de calcul modulaire du déterminant d’une matrice bornée
de taille <I>n</I> est en <I>O</I>(<I>n</I><SUP>4</SUP> ln(<I>n</I>)) opérations, en effet 
chaque calcul modulaire
nécessite <I>O</I>(<I>n</I><SUP>3</SUP>) opérations, et il faut <I>O</I>(<I>n</I>ln(<I>n</I>)) nombres premiers
d’une taille donnée (par exemple 31 bits)
pour dépasser le double de la borne de Hadamard 
(on montre facilement que la norme
euclidienne d’une colonne de <I>A</I> est ≤ √<SPAN style="text-decoration:overline"><I>n</I></SPAN>||<I>A</I>||<SUB>∞</SUB>,
on en prend la puissance <I>n</I>-ième).
C’est meilleur que la méthode de Bareiss, qui est en 
<I>O</I>(<I>n</I><SUP>5</SUP> ln(<I>n</I>)<SUP>2</SUP> (avec multiplication naïve des entiers). En effet
lors de la réduction de la <I>k</I>-ième colonne, on manipule des entiers
qui sont des mineurs de taille <I>k</I> donc de taille <I>O</I>(<I>k</I>ln(<I>k</I>)), d’où
une complexité en <I>O</I>(∑<SUB><I>k</I>=1</SUB><SUP><I>n</I>−1</SUP> (<I>n</I>−<I>k</I>)<SUP>2</SUP> (<I>k</I>ln(<I>k</I>))<SUP>2</SUP> ). Mais
la méthode de Bareiss fonctionne dans bien d’autres situations, par
exemple si les coefficients sont des polynômes.</P><P><B>Remarque</B> :<BR>
Si on veut juste prouver l’inversibilité d’une matrice à coefficients
entiers, il suffit
de trouver un nombre premier <I>p</I> tel que le déterminant de cette matrice modulo
<I>p</I> soit non nul.</P><P><B>Développement par rapport à une ligne ou une colonne</B><BR>
On a tendance à oublier ce type de méthode car le développement
complet du déterminant (faisant intervenir une somme sur toutes les
permutations du groupe symétrique)
nécessite d’effectuer <I>n</I>! produits
de <I>n</I> coefficients et <I>n</I>! additions ce qui est gigantesque. Or on peut
"factoriser" une partie des calculs et se ramener à <I>n</I>.2<SUP><I>n</I></SUP> opérations
élémentaires au lieu de <I>n</I>.<I>n</I>!. Remarquons aussi que le nombre
d’opérations élémentaires n’a guère de sens si on ne tient pas
compte de la complexité des expressions, l’avantage principal
de la méthode de développement étant d’éviter d’effectuer
des divisions.</P><P><B>Calcul du déterminant par développement de Laplace</B><A NAME="@default234"></A><BR>
On calcule d’abord tous les mineurs 2x2 des colonnes 1 et 2
que l’on place dans une table de mineurs,
puis on calcule les mineurs 3x3 des colonnes 1 à 3 en développant
par rapport à la colonne 3 et en utilisant les mineurs précédents,
puis les mineurs 4x4 avec les mineurs 3x3, etc.. 
On évite ainsi de recalculer plusieurs fois les mêmes mineurs.
Cf. par exemple l’implémentation en C++ dans giac/xcas
(<CODE>www-fourier.ujf-grenoble.fr/~parisse/giac.html</CODE>)
qui utilise le type générique <CODE>map&lt;&gt;</CODE> de la librairie standard C++ (STL)
pour stocker les tables de mineurs (fonction 
<CODE>det_minor</CODE> du fichier <TT>vecteur.cc</TT>).<BR>
Nombre d’opérations élémentaires : il y a (<SUB>2</SUB><SUP><I>n</I></SUP>) mineurs d’ordre 2
à calculer nécessitant chacun 2 multiplications (et 1 addition),
puis (<SUB>3</SUB><SUP><I>n</I></SUP>) mineurs d’ordre 3 nécessitant 3 multiplications et
2 additions, etc. donc le nombre de multiplications est de
2(<SUB>2</SUB><SUP><I>n</I></SUP>)+3(<SUB>3</SUB><SUP><I>n</I></SUP>)+...+<I>n</I>(<SUB><I>n</I></SUB><SUP><I>n</I></SUP>), celui d’additions est
(<SUB>2</SUB><SUP><I>n</I></SUP>)+2(<SUB>3</SUB><SUP><I>n</I></SUP>)+...+(<I>n</I>−1)(<SUB><I>n</I></SUB><SUP><I>n</I></SUP>) soit un nombre d’opérations
élémentaires majoré par <I>n</I>.2<SUP><I>n</I></SUP>.</P><P>On observe "expérimentalement" que cet algorithme est intéressant
lorsque le nombre de
paramètres dans le déterminant est grand et que la matrice est
plutôt creuse (majorité de coefficients nuls). Il existe des
heuristiques de permutation des lignes ou des colonnes visant
à optimiser la position des zéros (par exemple, les auteurs de GiNaC
(<CODE>www.ginac.de</CODE>) suite à des expérimentations
privilégient la simplification des petits mineurs en mettant les colonnes 
contenant le maximum de zéros à gauche selon la description faite
ici). </P><P>Pour se convaincre de l’intérêt de cet algorithme, on peut effectuer
le test O1 de Lewis-Wester<BR>
<CODE>http://www.bway.net/~lewis/calatex.html</CODE><BR>
il s’agit de calculer un déterminant de taille 15 avec 18 paramètres.</P><!--TOC subsubsection Systèmes linéaires-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc189">20.1.3</A>  Systèmes linéaires</H4><!--SEC END --><P><A NAME="@default235"></A>
On peut appliquer la méthode du pivot de Gauß ou les règles
de Cramer (matrices creuses avec beaucoup de paramètres par exemple). </P><P>Pour les systèmes à coefficients entiers non singuliers, 
on peut aussi utiliser une méthode <I>p</I>-adique asymptotiquement
plus efficace. On calcule d’abord une borne sur les
coefficients des fractions solutions de l’équation <I>Ax</I>=<I>b</I>
en utilisant les règles de Cramer et la borne d’Hadamard.
On calcule ensuite <I>C</I>, l’inverse de <I>A</I> modulo <I>p</I> (en changeant de <I>p</I> si
<I>A</I> n’est pas inversible modulo <I>p</I>), puis, si
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>i</I></SUB> <I>p</I><SUP><I>i</I></SUP>,    <I>A</I>(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>&lt;<I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>i</I></SUB> <I>p</I><SUP><I>i</I></SUP>)=<I>b</I> (mod <I>p</I><SUP><I>k</I></SUP> ) </TD></TR>
</TABLE><P>
on ajoute <I>x</I><SUB><I>k</I></SUB> <I>p</I><SUP><I>k</I></SUP>  et on obtient l’équation :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Ax</I><SUB><I>k</I></SUB> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>b</I>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I> &lt;<I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUB><I>i</I></SUB> <I>p</I><SUP><I>i</I></SUP></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>p</I><SUP><I>k</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (mod <I>p</I> ) </TD></TR>
</TABLE><P>
qui détermine <I>x</I><SUB><I>k</I></SUB>.
On s’arrête lorsque <I>k</I> est suffisamment grand pour pouvoir reconstruire
les fractions à l’aide de l’identité de Bézout (cf. infra),
ce qui est le cas si <I>p</I><SUP><I>k</I></SUP> est
supérieur à 4 fois la borne de Hadamard de <I>A</I> au carré.
Pour éviter de recalculer plusieurs fois <I>b</I>−∑<SUB><I>i</I> &lt;<I>k</I></SUB> <I>x</I><SUB><I>i</I></SUB> <I>p</I><SUP><I>i</I></SUP>,
on utilise la récurrence suivante
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I><SUB>0</SUB>=<I>b</I>,    <I>x</I><SUB><I>k</I></SUB>=<I>Cy</I><SUB><I>k</I></SUB> (mod <I>p</I> ),    <I>y</I><SUB><I>k</I>+1</SUB> =
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I><SUB><I>k</I></SUB>−<I>Ax</I><SUB><I>k</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>p</I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Pour une matrice de taille <I>n</I>, il faut <I>O</I>(<I>n</I><SUP>3</SUP>) opérations
pour calculer <I>C</I>, puis <I>kn</I><SUP>2</SUP> ln(<I>n</I>) opérations 
pour calculer <I>x</I><SUB><I>k</I></SUB> (le terme ln(<I>n</I>) 
vient de la taille des coefficients
de <I>y</I><SUB><I>k</I></SUB> dans le produit <I>Cy</I><SUB><I>k</I></SUB>),
donc pour pouvoir reconstruire <I>x</I>, il faut prendre <I>k</I> de l’ordre
de <I>n</I>ln(<I>n</I>), ce qui nécessite finalement <I>O</I>(<I>n</I><SUP>3</SUP>ln(<I>n</I>)<SUP>2</SUP>) opérations.</P><!--TOC subsubsection Bézout et les <I>p</I>-adiques.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc190">20.1.4</A>  Bézout et les <I>p</I>-adiques.</H4><!--SEC END --><P>
Soit <I>n</I> et <I>a</I>/<I>b</I> une fraction irréductible d’entiers tels que 
<I>b</I> est premier avec <I>n</I> et |<I>a</I>| &lt; √<SPAN style="text-decoration:overline"><I>n</I></SPAN>/2 et  0 ≤ <I>b</I> ≤ √<SPAN style="text-decoration:overline"><I>n</I></SPAN>/2.
Il s’agit de reconstruire <I>a</I> et <I>b</I> connaissant 
<I>x</I>=<I>a</I> × (<I>b</I><SUP>−1</SUP>) (mod <I>n</I> ) avec <I>x</I>∈ [0,<I>n</I>[.</P><P><B>Unicité</B><BR>
S’il existe une solution (<I>a</I>,<I>b</I>) vérifiant |<I>a</I>| &lt; √<SPAN style="text-decoration:overline"><I>n</I></SPAN>/2 et 
 0 ≤ <I>b</I> ≤ √<SPAN style="text-decoration:overline"><I>n</I></SPAN>/2, soit (<I>a</I>′,<I>b</I>′) une solution
de <I>x</I>=<I>a</I> × (<I>b</I><SUP>−1</SUP>) (mod <I>n</I> ) et 
vérifiant |<I>a</I>′| &lt; √<SPAN style="text-decoration:overline"><I>n</I></SPAN> et  0 ≤ <I>b</I>′ ≤ √<SPAN style="text-decoration:overline"><I>n</I></SPAN>, alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I> <I>b</I>′=<I>a</I>′ <I>b</I> (mod <I>n</I> ) </TD></TR>
</TABLE><P>
Comme |<I>ab</I>′| &lt; <I>n</I>/2, |<I>a</I>′<I>b</I>| &lt;<I>n</I>/2, 
on en déduit que <I>ab</I>′=<I>a</I>′<I>b</I>. Donc <I>a</I>/<I>b</I>=<I>a</I>′/<I>b</I>′
donc <I>a</I>=<I>a</I>′ et <I>b</I>=<I>b</I>′ car <I>a</I>/<I>b</I> et <I>a</I>′/<I>b</I>′ sont supposées irréductibles.</P><P><B>Reconstruction lorsqu’on sait qu’il y a une solution</B><BR>
On suit l’algorithme de calcul des coefficients de Bézout
pour les entiers <I>n</I> et <I>x</I>. On pose :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">α<SUB><I>k</I></SUB> <I>n</I> + β<SUB><I>k</I></SUB> <I>x</I>= <I>r</I><SUB><I>k</I></SUB> </TD></TR>
</TABLE><P>
où les <I>r</I><SUB><I>k</I></SUB> sont les restes successifs de l’algorithme d’Euclide,
avec la condition initiale :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">α<SUB>0</SUB>=1, β<SUB>0</SUB>=0, α<SUB>1</SUB>=0, β<SUB>1</SUB>=1, <I>r</I><SUB>0</SUB>=<I>n</I>, <I>r</I><SUB>1</SUB>=<I>x</I> </TD></TR>
</TABLE><P>
et la relation de récurrence :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">β<SUB><I>k</I>+2</SUB>=β<SUB><I>k</I></SUB> − <I>q</I><SUB><I>k</I>+2</SUB> β<SUB><I>k</I>+1</SUB>,   
<I>q</I><SUB><I>k</I>+2</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>r</I><SUB><I>k</I></SUB>−<I>r</I><SUB><I>k</I>+2</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I><SUB><I>k</I>+1</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>On a  β<SUB><I>k</I></SUB> <I>x</I>= <I>r</I><SUB><I>k</I></SUB> (mod <I>n</I> ) pour tout rang mais il faut vérifier
les conditions de taille sur β<SUB><I>k</I></SUB> et <I>r</I><SUB><I>k</I></SUB> pour trouver le couple
(<I>a</I>,<I>b</I>).
Montrons par récurrence que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:rec"></A>
β<SUB><I>k</I>+1</SUB> <I>r</I><SUB><I>k</I></SUB> − <I>r</I><SUB><I>k</I>+1</SUB> β<SUB><I>k</I></SUB> = (−1)<SUP><I>k</I></SUP> <I>n</I> 
    (43)</TD></TR>
</TABLE><P>
Au rang <I>k</I>=0, on vérifie l’égalité, on l’admet au rang <I>k</I>, 
alors au rang <I>k</I>+1, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> β<SUB><I>k</I>+2</SUB> <I>r</I><SUB><I>k</I>+1</SUB> − <I>r</I><SUB><I>k</I>+2</SUB> β<SUB><I>k</I>+1</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>β<SUB><I>k</I></SUB> <I>r</I><SUB><I>k</I>+1</SUB> − <I>q</I><SUB><I>k</I>+2</SUB> <I>r</I><SUB><I>k</I>+1</SUB> β<SUB><I>k</I>+1</SUB>  − <I>r</I><SUB><I>k</I>+2</SUB> β<SUB><I>k</I>+1</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>β<SUB><I>k</I></SUB> <I>r</I><SUB><I>k</I>+1</SUB> − (<I>r</I><SUB><I>k</I></SUB>−<I>r</I><SUB><I>k</I>+2</SUB>) β<SUB><I>k</I>+1</SUB>  − <I>r</I><SUB><I>k</I>+2</SUB> β<SUB><I>k</I>+1</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>β<SUB><I>k</I></SUB> <I>r</I><SUB><I>k</I>+1</SUB> − <I>r</I><SUB><I>k</I></SUB> β<SUB><I>k</I>+1</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>− (−1)<SUP><I>k</I></SUP> <I>n</I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On vérifie aussi que le signe de β<SUB><I>k</I></SUB> est positif si <I>k</I> est impair
et négatif si <I>k</I> est pair, on déduit donc de (<A HREF="#eq:rec">43</A>) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|β<SUB><I>k</I>+1</SUB>| <I>r</I><SUB><I>k</I></SUB> &lt; <I>n</I> </TD></TR>
</TABLE><P>
(avec égalité si <I>r</I><SUB><I>k</I>+1</SUB>=0)</P><P>Considérons la taille des restes successifs, il existe un rang <I>k</I>
tel que <I>r</I><SUB><I>k</I></SUB> ≥ √<SPAN style="text-decoration:overline"><I>n</I></SPAN> et <I>r</I><SUB><I>k</I>+1</SUB>&lt;√<SPAN style="text-decoration:overline"><I>n</I></SPAN>. On a alors
|β<SUB><I>k</I>+1</SUB>| &lt; <I>n</I>/<I>r</I><SUB><I>k</I></SUB> ≤ √<SPAN style="text-decoration:overline"><I>n</I></SPAN>.</P><P>Donc l’algorithme de Bézout permet de reconstruire l’unique couple
solution s’il existe.</P><P><B>Exemple</B><BR>
On prend <I>n</I>=101, <I>a</I>=2, <I>b</I>=3, <I>a</I>/<I>b</I>=68 (mod 101 ).
Puis on effectue Bézout pour 68 et 101 en affichant les étapes 
intermédiaires (par exemple avec <CODE>IEGCD</CODE> sur une HP49 ou exercice
avec votre système de calcul formel) :
</P><PRE CLASS="verbatim">   = alpha*101+beta*68
101    1        0
 68    0        1  L1 - 1*L2
 33    1       -1  L2 - 2*L3
  2   -2        3  ...
</PRE><P>On s’arrête à la première ligne telle que le coefficient de la 1ère colonne
est inférieur à √<SPAN style="text-decoration:overline">101</SPAN>, on retrouve bien 2 et 3.
Quand on programme l’algorithme de
reconstruction, on ne calcule bien sûr pas la colonne des α,
ce qui donne par exemple le programme xcas ou mupad suivant :
</P><PRE CLASS="verbatim">// Renvoie a/b tel que a/b=x mod n et |a|,|b|&lt;sqrt(n)
padictofrac:=proc (n,x)
  local r0,beta0,r1,beta1,r2,q2,beta2;
begin
  r0:=n;
  beta0:=0;
  r1:=x;
  beta1:=1;
  sqrtn:=float(sqrt(n));
  while r1&gt;sqrtn do
    r2:= irem(r0,r1); 
    q2:=(r0-r2)/r1;
    beta2:=beta0-q2*beta1;
    beta0:=beta1; r0:=r1; beta1:=beta2; r1:=r2;
  end_while;
  return(r1/beta1);
end_proc;
</PRE><!--TOC subsubsection Base du noyau-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc191">20.1.5</A>  Base du noyau</H4><!--SEC END --><P><A NAME="@default236"></A>
On présente ici deux méthodes, la première se généralise
au cas des systèmes à coefficients entiers, la deuxième
utilise un peu moins de mémoire (elle travaille sur une matrice 2 fois
plus petite).</P><P><B>Première méthode</B>
Soir <I>M</I> la matrice dont on cherche le noyau. On ajoute à droite
de la matrice transposée de <I>M</I> une matrice identité ayant
le même nombre de lignes que <I>M</I><SUP><I>t</I></SUP>. On effectue une réduction
sous-diagonale qui nous amène à une matrice composée de deux
blocs
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">( <I>M</I><SUP><I>t</I></SUP> <I>I</I><SUB><I>n</I></SUB> )  →  ( <I>U</I> L ) </TD></TR>
</TABLE><P>
Attention, L n’est pas la matrice <I>L</I> de la décomposition <I>LU</I>
de <I>M</I><SUP><I>t</I></SUP>, on a en fait
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">L <I>M</I><SUP><I>t</I></SUP> = <I>U</I></TD></TR>
</TABLE><P>
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I> L<SUP><I>t</I></SUP> = <I>U</I><SUP><I>t</I></SUP> </TD></TR>
</TABLE><P>
Les colonnes de L<SUP><I>t</I></SUP> correspondant aux colonnes nulles de <I>U</I><SUP><I>t</I></SUP> 
(ou si on préfère les lignes de L correspondant
aux lignes nulles de <I>U</I>) sont donc dans le noyau de <I>M</I> et réciproquement
si <I>Mv</I>=0 alors 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>U</I><SUP><I>t</I></SUP> (L<SUP><I>t</I></SUP>)<SUP>−1</SUP> <I>v</I> =0 </TD></TR>
</TABLE><P>
donc, comme <I>U</I> est réduite, (L<SUP><I>t</I></SUP>)<SUP>−1</SUP> <I>v</I> est une combinaison
linéaire des vecteurs de base d’indice les lignes nulles de <I>U</I>.
Finalement, les lignes de L correspondant
aux lignes nulles de <I>U</I> forment une base du noyau de <I>M</I>.</P><P><B>Deuxième méthode</B>
On commence bien sûr par réduire la matrice (réduction complète
en-dehors de la diagonale), et on divise chaque ligne par son
premier coefficient non nul (appelé pivot). On insère alors
des lignes de 0 pour que les pivots (non nuls) se trouvent
sur la diagonale. Puis en fin de matrice, on ajoute ou on supprime des 
lignes de 0 pour avoir une matrice carrée de dimension le nombre de colonnes
de la matrice de départ.
On parcourt alors la matrice en diagonale. Si
le <I>i</I>-ième coefficient est non nul, on passe au suivant. 
S’il est nul, alors tous
les coefficients d’indice supérieur ou égal à <I>i</I> du <I>i</I>-ième
vecteur colonne <I>v</I><SUB><I>i</I></SUB> sont nuls (mais pas forcément pour les indices
inférieurs à <I>i</I>). Si on remplace le <I>i</I>-ième coefficient de <I>v</I><SUB><I>i</I></SUB>
par -1, il est facile de se convaincre que c’est un vecteur du noyau,
on le rajoute donc à la base du noyau. On voit facilement
que tous les vecteurs de ce type forment une famille libre de
la bonne taille, c’est donc bien une base du noyau.</P><!--TOC subsection Algèbre linéaire sur ℤ-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc192">20.2</A>  Algèbre linéaire sur ℤ</H3><!--SEC END --><!--TOC subsubsection Calcul du déterminant d’une matrice à coefficient entiers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc193">20.2.1</A>  Calcul du déterminant d’une matrice à coefficient entiers</H4><!--SEC END --><P>
L’algorithme <I>p</I>-adique de résolution de systèmes
linéaires peut servir à accélérer le calcul du
déterminant d’une matrice à coefficients entiers de grande taille.
En effet, le PPCM <I>f</I> des dénominateurs des composantes de <I>x</I> est
un diviseur du déterminant, et si <I>b</I> est choisi avec des
coefficients aléatoires, on a une forte probabilité d’obtenir
le dernier facteur invariant de la matrice <I>A</I>. Comme le déterminant
de <I>A</I> a une très faible probabilité de contenir un gros facteur
carré, ce dernier facteur invariant est très proche du
déterminant. Ce dernier est pour une matrice <I>A</I> aléatoire
lui-même à un facteur de l’ordre de (2/π)<SUP><I>n</I></SUP> proche
de la borne de Hadamard. Il suffit donc de très peu de nombres
premiers pour déterminer det(<I>A</I>)/<I>f</I> par le théorème
des restes chinois. En pratique pour des <I>n</I> de l’ordre de 100
à 1000, cet algorithme est plus rapide que le calcul uniquement
par les restes chinois. Pour des <I>n</I> plus grands, il faut se
rabattre sur des algorithmes probabilistes avec arrêt prématuré
pour être plus rapide (on s’arrête lorsque le déterminant
n’évolue plus par reconstruction par les restes chinois 
pour plusieurs nombres premiers successifs, le résultat n’est
alors pas certifié, c’est ce qui se passe dans Xcas si
<CODE>proba_epsilon</CODE> n’est pas nul), 
ou utiliser des méthodes
d’inversion ou de réduction de type Strassen.</P><!--TOC subsubsection Réduction de Hermite et Smith-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc194">20.2.2</A>  Réduction de Hermite et Smith</H4><!--SEC END --><P><A NAME="@default237"></A> <A NAME="@default238"></A>
Lorsque <I>M</I> est une matrice à coefficients entiers, 
on ne peut plus faire l’algorithme du pivot de Gauss ou de
Gauss-Bareiss en restant dans ℤ et en étant réversible.
On peut toutefois effectuer des manipulations élémentaires
réversibles dans ℤ, grâce à l’idendité de Bézout. Si <I>a</I>
est le pivot en ligne <I>i</I>, <I>b</I> le coefficient en ligne <I>j</I> à
annuler, et <I>u</I>, <I>v</I>, <I>d</I> les coefficients de l’identité de Bézout
<I>a</I> <I>u</I> + <I>b</I> <I>v</I> =<I>d</I> on fait les changements :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>L</I><SUB><I>i</I></SUB> ← <I>uL</I><SUB><I>i</I></SUB> +<I>v</I> <I>L</I><SUB><I>j</I></SUB>,    
<I>L</I><SUB><I>j</I></SUB> ← −</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>b</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>L</I><SUB><I>i</I></SUB> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>L</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>
qui est réversible dans ℤ
car le déterminant de la sous-matrice élémentaire
correspondante est
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>u</I></TD><TD ALIGN=center NOWRAP><I>v</I> </TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>b</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD><TD CLASS="dcell">= 1
</TD></TR>
</TABLE><P>
On peut donc créer des zéros en-dessous de la diagonale, il existe
une matrice inversible <I>L</I> telle que <I>LM</I>=<I>U</I> où <I>U</I> est triangulaire
supérieure. On peut même rendre les coefficients hors diagonale
de <I>U</I> inférieur aux pivots de leurs colonnes respectives en faisant
une combinaison linéaire de lignes <I>L</I><SUB><I>j</I></SUB> = <I>L</I><SUB><I>j</I></SUB>−<I>qL</I><SUB><I>p</I></SUB>, <I>j</I>&lt;<I>p</I> où <I>q</I>
est le quotient de la division euclidienne de <I>M</I><SUB><I>jc</I></SUB> par <I>M</I><SUB><I>pc</I></SUB>
(<I>p</I> la ligne du pivot, en principe <I>p</I>=<I>c</I>).
On observe aussi que les pivots sont les pgcd des éléments de la colonne
du pivot à partir de la ligne du pivot.</P><P>Applications : 
Cette réduction (dite forme normale de Hermite 
lorsqu’on réduit les lignes
au-dessus de la diagonale par division euclidienne par
le pivot) permet de trouver une base du noyau
à coefficients entiers et telle que tout élément du noyau à 
coefficient entier s’écrit comme combinaison linéaire à coefficients
entiers des éléments de la base. Il suffit d’appliquer la
réduction de Hermite à (<I>M</I><SUP><I>t</I></SUP>|<I>I</I>), on obtient une matrice (<I>U</I>|<I>L</I>)
telle que <I>U</I>=<I>LM</I><SUP><I>t</I></SUP>.
Dans Xcas, on peut utiliser l’instruction <CODE>ihermite</CODE> (ou
<CODE>mathnf</CODE> de PARI). L’aide
détaillée de Xcas donne un exemple de calcul de ℤ-base
d’un noyau. </P><P>Exemple : soit à résoudre en entiers 2<I>x</I>+3<I>y</I>+5<I>z</I>=0.
On pose <CODE>M:=[[2,3,5]]</CODE> puis 
<CODE>L,U:=ihermite(tran(M))</CODE>, les lignes nulles de <I>U</I> correspondent
à des lignes de <I>L</I> qui forment une base du noyau de <I>M</I>, soit
(6,1,−3) et (−5,0,2).
En effet <I>U</I>=<I>L</I> <I>M</I><SUP><I>t</I></SUP> donc <I>U</I><SUP><I>t</I></SUP>=<I>M</I> <I>L</I><SUP><I>t</I></SUP>, les colonnes nulle 
de <I>U</I><SUP><I>t</I></SUP> sont donc images par <I>M</I> des colonnes
correspondantes de <I>L</I><SUP><I>t</I></SUP>, ainsi les lignes de <I>L</I> correspondant
à des lignes nulles de <I>U</I> sont dans le noyau. Et si un vecteur
à coefficient entiers est dans le noyau, alors il se décompose
sur les vecteurs colonnes de <I>L</I><SUP><I>t</I></SUP> avec des coefficients entiers
(puisque <I>L</I>∈GL<SUB><I>n</I></SUB>(ℤ)), on applique <I>M</I> et on conclut
que ses composantes sur les colonnes non nulles de <I>U</I><SUP><I>t</I></SUP> sont nulles.</P><P>Plus généralement, chercher une solution particulière
du système <I>MX</I>=<I>B</I> revient à résoudre
<I>U</I><SUP><I>t</I></SUP> <I>Y</I>=<I>B</I> avec <I>Y</I>=(<I>L</I><SUP><I>t</I></SUP>)<SUP>−1</SUP> <I>X</I>, la recherche de <I>Y</I> est
alors très simple puisque <I>U</I> est échelonnée. 
Par exemple, <CODE>M:=[[2,3,5],[7,5,3]]</CODE>
puis <CODE>B:=[3,-2]</CODE>, puis
<CODE>L,U:=ihermite(tran(M))</CODE>, donne pour <CODE>tran(U)</CODE>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
on a donc <I>y</I><SUB>1</SUB>=3, <I>y</I><SUB>2</SUB>=−2, <I>y</I><SUB>3</SUB> quelconque puis on calcule 
<CODE>X:=tran(L)*[3,-2,y3]</CODE>, on peut vérifier 
avec <CODE>normal(M*X)</CODE>.</P><P>On peut aussi se servir de la forme normale de Hermite pour
compléter un vecteur <I>v</I>=(<I>a</I><SUB>1</SUB>,...,<I>a</I><SUB><I>n</I></SUB>) de contenu 1 en une base
de ℤ<SUP><I>n</I></SUP> (si le contenu n’est pas 1, c’est bien sur impossible
puisque le déterminant est un multiple du contenu), il suffit
de prendre les colonnes de <I>L</I><SUP>−1</SUP> 
(où <CODE>L,U:=ihermite(tran(v))</CODE>).
En effet on a <I>U</I>=<I>L</I> <I>v</I><SUP><I>t</I></SUP> et <I>U</I> est égal à (1,0,...,0) car le
contenu de <I>v</I> vaut 1.</P><P>La réduction échelonnée sous la diagonale correspond à
<CODE>ihermite</CODE>, la réduction complète correspond à
<CODE>ismith</CODE>
(ou <CODE>matsnf</CODE> de PARI) qui 
calcule la décomposition de Smith d’une matrice <I>A</I> à coefficients
entiers et en donne les coefficients invariants.
Il faut pour cela alterner plusieurs décomposition de Hermite en
ligne et en colonne. En effet un élément hors diagonale <I>a</I><SUB><I>ij</I></SUB>
non nul d’une
réduction de Hermite est un reste de division euclidienne par
le pivot <I>a</I><SUB><I>jj</I></SUB> (respectivement <I>a</I><SUB><I>ii</I></SUB> selon qu’on réduit en lignes ou en
colonnes) sur la diagonale, il est donc 
strictement plus petit et donnera lieu à
l’étape de réduction suivante à un pgcd
soit égal en <I>a</I><SUB><I>ii</I></SUB> [resp. <I>a</I><SUB><I>jj</I></SUB>] 
(et dans ce cas <I>a</I><SUB><I>ij</I></SUB> deviendra nul), soit strictement plus
petit, donc soit l’un des pivots décroit, soit l’un des <I>a</I><SUB><I>ij</I></SUB>
hors diagonale s’annule. On obtient en un nombre fini d’étape
une matrice diagonale.
La forme normale de Smith d’une matrice <I>A</I> impose également 
que les coefficients
diagonaux non nuls <I>d</I><SUB>1</SUB>|<I>d</I><SUB>2</SUB>|...|<I>d</I><SUB><I>r</I></SUB> se divisent. Pour réaliser
cela, si par exemple <I>d</I><SUB>1</SUB> ne divise pas <I>d</I><SUB>2</SUB>, on remplace <I>C</I><SUB>1</SUB> par
<I>C</I><SUB>1</SUB>+<I>C</I><SUB>2</SUB>, puis on fait apparaitre le pgcd de <I>d</I><SUB>1</SUB> et <I>d</I><SUB>2</SUB> en ligne
1 colonne 1 en créant un 0 en ligne 2 colonne 1. </P><P>La réduction de Smith sert par exemple à montrer
qu’un sous-module de ℤ<SUP><I>n</I></SUP> obtenu par quotient par l’image 
d’une application linéaire de matrice <I>A</I> est isomorphe 
à ℤ/<I>d</I><SUB><I>i</I></SUB> × ... × ℤ/<I>d</I><SUB><I>r</I></SUB> × ℤ<SUP><I>n</I>−<I>r</I></SUP>. C’est ce
qu’on obtient pour un module présenté par des générateurs
et relations entre générateurs.
Les coefficients <I>d</I><SUB><I>i</I></SUB> sont appelés <B>facteurs
invariants</B><A NAME="@default239"></A> de la
matrice <I>A</I>, leur factorisation en produit de nombres 
premiers à une certaine puissance donne les <B>diviseurs 
élémentaires</B><A NAME="@default240"></A>.</P><P>Exemple 1 : on se donne le groupe abélien engendré par <I>x</I><SUB>1</SUB> et
<I>x</I><SUB>2</SUB> vérifiant les relations 2<I>x</I><SUB>1</SUB>+4<I>x</I><SUB>2</SUB>=0, −2<I>x</I><SUB>1</SUB>+6<I>x</I><SUB>2</SUB>=0. On fait
<I>L</I><SUB>2</SUB>=<I>L</I><SUB>2</SUB>+<I>L</I><SUB>1</SUB> et <I>C</I><SUB>2</SUB>=<I>C</I><SUB>2</SUB>−<I>C</I><SUB>1</SUB> ce qui donne la matrice réduite
de diagonale 2 et 10, qui en sont les facteurs invariants, le groupe
est isomorphe à ℤ/2 × ℤ/10 (parfois noté 
⊕ au lieu de ×).</P><P>Exemple 2 : on se donne un module sur ℤ engendré par <I>m</I><SUB>1</SUB>,<I>m</I><SUB>2</SUB>,<I>m</I><SUB>3</SUB>
et les relations 2<I>m</I><SUB>1</SUB>+3<I>m</I><SUB>2</SUB>+5<I>m</I><SUB>3</SUB>=0, 7<I>m</I><SUB>1</SUB>+3<I>m</I><SUB>2</SUB>−5<I>m</I><SUB>3</SUB>=0.
On pose <CODE>A:=[[2,3,5],[7,3,-5]]</CODE>, puis
<CODE>U,B,V:=ismith(A)</CODE>, on a donc <I>B</I>=<I>UAV</I>.
Si <I>M</I>=(<I>m</I><SUB>1</SUB>,<I>m</I><SUB>2</SUB>,<I>m</I><SUB>3</SUB>), on a <I>AM</I>=0 donc <I>B</I> <I>V</I><SUP>−1</SUP><I>M</I>=<I>UAM</I>=0.
On pose (<I>n</I><SUB>1</SUB>,<I>n</I><SUB>2</SUB>,<I>n</I><SUB>3</SUB>)=<I>N</I>=<I>V</I><SUP>−1</SUP><I>M</I>, 
les générateurs <I>n</I><SUB>1</SUB>=<I>m</I><SUB>1</SUB>−6<I>m</I><SUB>2</SUB>−20<I>m</I><SUB>3</SUB>, <I>n</I><SUB>2</SUB>=<I>m</I><SUB>2</SUB>+3<I>m</I><SUB>3</SUB>,<I>n</I><SUB>3</SUB>=<I>m</I><SUB>3</SUB>
vérifient donc <I>b</I><SUB>1</SUB> <I>n</I><SUB>1</SUB>=0, <I>b</I><SUB>2</SUB><I>n</I><SUB>2</SUB>=0, <I>b</I><SUB>1</SUB>=1, <I>b</I><SUB>2</SUB>=15, le module est donc
isomorphe à ℤ/1 × ℤ/15 × ℤ soit encore ℤ/15ℤ
× ℤ.</P><!--TOC subsubsection L’algorithme LLL.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc195">20.2.3</A>  L’algorithme LLL.</H4><!--SEC END --><P> <A NAME="@default241"></A>
Il s’agit d’une méthode permettant d’obtenir rapidement
une base courte d’un réseau. Ce n’est pas la base la plus courte
possible mais un compromis temps d’exécution rapide/base
pas trop grande. Voir par exemple Cohen pour la définition
et les propriétés. L’instruction Xcas correspondante est
<CODE>lll</CODE> (ou <CODE>qflll</CODE> de PARI).</P><P>Cet algorithme est très utile en calcul formel, pour éviter
une explosion combinatoire dans certaines
opérations de recombinaison. Par exemple, supposons que
nous souhaitions factoriser un polynôme <I>P</I> à coefficients
entiers sur ℤ[<I>X</I>] en utilisant ses racines approchées. Si
plusieurs racines <I>r</I><SUB><I>k</I></SUB> correspondent à un facteur entier,
alors <I>p</I><SUB><I>n</I></SUB> ∑<I>r</I><SUB><I>k</I></SUB>  doit être un entier aux erreurs
d’arrondi près. Tester toutes les combinaisons possibles
serait beaucoup trop long, en particulier si <I>P</I> est irréductible
(en gros 2<SUP><I>n</I>−1</SUP> tests de recombinaison). Pour éviter ce
problème, on construit un réseau engendré par degré <I>P</I> 
lignes dont les premières coordonnées sont celles de la
matrice identité, complétées par la partie réelle et
imaginaire des racines de <I>P</I> multipliée par le coefficient dominant
de <I>P</I> et par une puissance de 10 assez grande. On ajoute
deux lignes qui“annulent” les parties entières des combinaisons
linéaires des parties réelles et imaginaires.
L’existence
d’un facteur irréductible se lira sur un vecteur court du réseau
avec des 1 et des 0 comme combinaison linéaire des vecteurs
initiaux.
</P><PRE CLASS="verbatim">f(P):={
  local l,n,prec,M,S,A,L,O;
  n:=degree(P);
  prec:=2*n;
  l:=proot(P,prec+n);
  M:=round(tran([op(idn(n)),
     lcoeff(P)*10^prec*re(l),lcoeff(P)*10^prec*im(l)]));
  M:=[op(M),[0$n,10^prec,0],[0$(n+1),10^prec]];
  S,A,L,O:=lll(M);
  retourne l,A;
}:;
</PRE><P>Par exemple, <CODE>P:=(x^3+x+1)*(x^4+x+1)</CODE> suivi de <CODE>l,A:=f(P)</CODE>
fait apparaitre en première ligne de <I>A</I> le vecteur
(1,1,1,0,0,0,0,0,0). On essaie donc de recombiner les trois
premières racines de <CODE>l</CODE><BR>
<CODE>pcoeff(l[0],l[1],l[2])</CODE><BR>
renvoie bien un facteur presqu’entier de <I>P</I>. Il faut bien entendu des
encadrements rigoureux pour déterminer la précision à utiliser
pour les racines pour prouver l’irréductibilité de <I>P</I> si <I>A</I> ne
contient pas de vecteur court contenant uniquement des 1 et 0.</P><!--TOC subsection Le pivot de Gauss numérique.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc196">20.3</A>  Le pivot de Gauss numérique.</H3><!--SEC END --><!--TOC subsubsection Efficacité de l’algorithme-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc197">20.3.1</A>  Efficacité de l’algorithme</H4><!--SEC END --><P>
Si la matrice possède <I>L</I> lignes et <I>C</I> colonnes,
le nombre maximal d’opérations pour réduire une ligne est <I>C</I> divisions,
<I>C</I> multiplications, <I>C</I> soustractions, donc 3<I>C</I> opérations
arithmétiques de base. Il y a <I>L</I>−1 lignes à réduire à chaque
étape et min(<I>L</I>,<I>C</I>) étapes à effectuer, on en déduit que le
nombre maximal d’opérations pour réduire une matrice est
3<I>LC</I>min(<I>L</I>,<I>C</I>). Pour une matrice carrée de taille <I>n</I>, cela fait 
3<I>n</I><SUP>3</SUP> opérations.</P><!--TOC subsubsection Erreurs d’arrondis du pivot de Gauss-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc198">20.3.2</A>  Erreurs d’arrondis du pivot de Gauss</H4><!--SEC END --><P> <A NAME="@default242"></A>
<A NAME="@default243"></A>
Comme |<I>a</I><SUB><I>jc</I></SUB>| ≤ |<I>a</I><SUB><I>lc</I></SUB>|, une étape de réduction multiplie
au plus l’erreur absolue des coefficients par 2. Donc la
réduction complète d’une matrice peut multiplier au pire l’erreur
absolue sur les coefficients par 2<SUP><I>n</I></SUP> (où <I>n</I> est le nombre
d’étapes de réduction, inférieur au plus petit du nombre de lignes
et de colonnes). Ceci signifie qu’avec la précision d’un double,
on peut au pire perdre toute précision pour des matrices pas
si grandes que ça (<I>n</I>=52). Heureusement, il semble qu’en pratique, 
l’erreur absolue
ne soit que très rarement multipliée par un facteur supérieur à 10.</P><P>Par contre, si on ne prend pas la précaution de choisir le pivot
de norme maximale dans la colonne, les erreurs d’arrondis se
comportent de manière bien moins bonnes, cf. l’exemple suivant.</P><P><B>Exemple</B><BR>
Soit à résoudre le système linéaire
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">є <I>x</I> + 1.0 <I>y</I> = 1.0 ,    <I>x</I> + 2.0 <I>y</I> = 3.0 </TD></TR>
</TABLE><P>
avec є =2<SUP>−54</SUP> (pour une machine utilisant des doubles pour
les calculs en flottant,
plus généralement on choisira є tel que (1.0+3є)−1.0
soit indistinguable de 0.0).<BR>
Si on résoud le système exactement,
on obtient <I>x</I>=1/(1−2є) (environ 1)
et <I>y</I>=(1−3є)/(1−2є) (environ 1).
Supposons que l’on n’utilise pas la stratégie du pivot partiel,
on prend alors comme pivot є, donc on effectue la
manipulation de ligne <I>L</I><SUB>2</SUB> ← <I>L</I><SUB>2</SUB> − 1/є <I>L</I><SUB>1</SUB> ce qui
donne comme 2ème équation (2.0−1.0/є)<I>y</I>=3.0−1.0/є.
Comme les calculs sont numériques, et à cause des erreurs
d’arrondis, cette 2ème équation sera remplacée par
(−1.0/є)<I>y</I>=−1.0/є d’où <I>y</I>=1.0, qui sera remplacé
dans la 1ère équation, donnant є <I>x</I> = 1.0−1.0<I>y</I>=0.0 donc
<I>x</I>=0.0.<BR>
Inversement, si on utilise la stratégie du pivot partiel, alors
on doit échanger les 2 équations <I>L</I><SUB>2</SUB>′=<I>L</I><SUB>1</SUB> et <I>L</I><SUB>1</SUB>′=<I>L</I><SUB>2</SUB> puis on effectue
<I>L</I><SUB>2</SUB> ← <I>L</I><SUB>2</SUB>′ − є <I>L</I><SUB>1</SUB>′, ce qui donne
(1.0−2.0є) <I>y</I> = 1.0 − 3.0 є , remplacée en raison
des erreurs d’arrondi par 1.0*<I>y</I>=1.0 donc <I>y</I>=1.0, puis on remplace
<I>y</I> dans <I>L</I><SUB>1</SUB>′ ce qui donne <I>x</I>=3.0−2.0<I>y</I>=1.0.<BR>
On observe dans les deux cas que la valeur de <I>y</I> est proche de la
valeur exacte, mais la valeur de <I>x</I> dans le premier cas est
grossièrement eloignée de la valeur correcte.</P><P>On peut aussi s’intéresser à la sensibilité de la solution d’un
système linéaire à des variations de son second membre. Cela fait intervenir
le nombre de conditionnement de la matrice <I>A</I> (voir plus bas) du système (qui
est essentiellement la valeur absolue du rapport de la valeur propre
la plus grande sur la valeur propre la plus petite), plus
ce nombre est grand, plus la solution variera (donc plus on
perd en précision).</P><!--TOC subsection La méthode de factorisation <I>LU</I>-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc199">20.4</A>  La méthode de factorisation <I>LU</I></H3><!--SEC END --><P> <A NAME="@default244"></A>
<A NAME="@default245"></A>
Dans sa forme la plus simple, elle permet d’écrire
une matrice <I>A</I> comme produit de deux matrices triangulaire
inférieures et supérieures, ce qui ramène la résolution
de système à la résolution de deux systèmes triangulaires.
Pour tenir compte d’éléments diagonaux nuls et pour optimiser 
les erreurs d’arrondi, il est nécessaire d’effectuer des
permutations sur les lignes de la matrice.</P><!--TOC subsubsection Interprétation matricielle du pivot de Gauss-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc200">20.4.1</A>  Interprétation matricielle du pivot de Gauss</H4><!--SEC END --><P>
On notera <I>l</I> et <I>c</I> le nombre de lignes et colonnes de <I>A</I> (pour
éviter la confusion avec le facteur <I>L</I>) et on
supposera <I>A</I> non singulière pour simplifier l’exposition.</P><P>Lorsqu’on réduit la colonne <I>j</I> d’une matrice Ã
(partiellement réduite) à partir
de la ligne <I>j</I>+1 (en supposant Ã<SUB><I>j</I>,<I>j</I></SUB> ≠ 0), cela revient à
multiplier Ã à gauche par une matrice L<SUB><I>j</I></SUB> créée en
partant de la matrice
identité de taille <I>l</I> où on remplace les 0 
colonne <I>j</I>, lignes <I>j</I>+1 à <I>l</I> par 
le coefficient de la combinaison de ligne effectuée :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>l</I><SUB><I>i</I></SUB> → <I>l</I><SUB><I>i</I></SUB> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">Ã<SUB><I>i</I>,<I>j</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">Ã<SUB><I>j</I>,<I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>l</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">L<SUB><I>j</I></SUB> = </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD></TR>
<TR><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">− </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">Ã<SUB><I>j</I>+1,<I>j</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">Ã<SUB><I>j</I>,<I>j</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP> 0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>....</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">− </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">Ã<SUB><I>l</I>,<I>j</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">Ã<SUB><I>j</I>,<I>j</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
On vérifie facilement que l’inverse de cette matrice est
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>L</I><SUB><I>j</I></SUB> = L<SUB><I>j</I></SUB><SUP>−1</SUP> = </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD></TR>
<TR><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">Ã<SUB><I>j</I>+1,<I>j</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">Ã<SUB><I>j</I>,<I>j</I></SUB></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP> 0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>....</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">Ã<SUB><I>l</I>,<I>j</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">Ã<SUB><I>j</I>,<I>j</I></SUB></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
Donc <I>A</I> est le produit des matrices <I>L</I><SUB><I>j</I></SUB> par une matrice réduite
<I>U</I> qui est triangulaire supérieure
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>= <I>L</I><SUB>1</SUB>...<I>L</I><SUB><I>l</I>−1</SUB> <I>U</I> </TD></TR>
</TABLE><P>
On vérifie ensuite que le produit des matrices <I>L</I><SUB>1</SUB>...<I>L</I><SUB><I>l</I>−1</SUB> revient à
remplacer les coefficients de la colonne <I>j</I> sous la diagonale 
par ceux de <I>L</I><SUB><I>j</I></SUB>, ce qui donne une matrice <I>L</I> triangulaire
inférieure (avec des 1 sur la diagonale). Pour l’obtenir il suffit
au cours de l’algorithme de réduction sous-diagonale du 
pivot de Gauss de stocker le coefficient
de la combinaison linéaire dans une matrice initialisée
à la matrice identité (on peut aussi le faire
en place dans la matrice á réduire).</P><P>Attention, le produit L<SUB><I>l</I>−1</SUB>...L<SUB>1</SUB> ne s’obtient pas en
copiant la colonne <I>j</I> de L<SUB><I>j</I></SUB> pour <I>j</I> variant de 1 à
<I>l</I>−1! On peut l’obtenir en faisant
une réduction sous-diagonale de la matrice bloc obtenue en collant
<I>A</I> avec la matrice identité ayant <I>l</I> lignes.</P><!--TOC subsubsection Factorisation <I>PA</I>=<I>LU</I>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc201">20.4.2</A>  Factorisation <I>PA</I>=<I>LU</I></H4><!--SEC END --><P>
Si on veut mettre en oeuvre la stratégie du pivot partiel (ou en
calcul exact si un coefficient diagonal est nul), il est nécessaire
d’intervertir une ligne de la matrice partiellement réduite
avec une ligne en-dessous. Cela revient à réduire la matrice
<I>A</I> de départ après échange de ces mêmes lignes. En
conséquence ce n’est pas <I>A</I> qui est le produit <I>LU</I> mais
une matrice obtenue par permutations de lignes de <I>A</I>, que
l’on peut écrire comme produit à gauche de <I>A</I> par une matrice
de permutation <I>P</I>.</P><P>Remarque : si à une étape de réduction, tous les coefficients
de la colonne <I>j</I> à partir de la ligne <I>j</I> sont nuls, on peut
simplement ignorer cette colonne et incrémenter <I>j</I> de 1 (<I>L</I><SUB><I>j</I></SUB>
sera l’identité).
Mais ceci différe de la réduction sous forme échelonnée
où on incrémente <I>j</I> de 1, mais pas <I>i</I> (on ne peut plus
alors déduire le rang de <I>U</I> du nombre de lignes non nulles).
On peut aussi effectuer un échange de colonnes (ce qui revient
à multiplier à droite par une matrice de permutation).</P><!--TOC subsubsection Applications de la décomposition <I>LU</I>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc202">20.4.3</A>  Applications de la décomposition <I>LU</I></H4><!--SEC END --><P>
On peut résoudre des systèmes linéaires par la factorisation
<I>LU</I>. En effet soit à résoudre <I>Ax</I>=<I>b</I>. On effectue la permutation
de lignes sur <I>A</I> et <I>b</I> (correspondant à la matrice de permutation
<I>P</I>), ce qui donne <I>PAx</I>=<I>Pb</I>=<I>LUx</I>, puis on résoud <I>Ly</I>=<I>Pb</I>
(système triangulaire inférieur), puis on résoud <I>Ux</I>=<I>y</I>
(système triangulaire supérieur).</P><P>Comparaison avec la réduction complète sous forme échelonnée de
(<I>A</I>|<I>b</I>) :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
La factorisation <I>LU</I> peut reservir plus tard pour résoudre le même
système linéaire avec un autre second membre.
Avec <CODE>rref</CODE> il faut dès le départ mettre tous les
vecteurs colonnes second membre à <I>A</I>.
</LI><LI CLASS="li-itemize">Le nombre d’opérations pour résoudre un système <I>n</I>,<I>n</I>
est moindre. La réduction sous-diagonale nécessite de réduire
les colonnes <I>j</I> de 1 à <I>n</I>−1, avec pour réduire la colonne <I>j</I>
<I>n</I>−<I>j</I> combinaisons linéaire de lignes ayant <I>n</I>+1−<I>j</I> coefficients non
nuls, soit ∑<SUB><I>j</I>=1</SUB><SUP>(</SUP><I>n</I>−1) 2(<I>n</I>−<I>j</I>)(<I>n</I>+1−<I>j</I>)=2/3<I>n</I><SUP>3</SUP>+<I>O</I>(<I>n</I><SUP>2</SUP>) opérations
(1 multiplication et 1 soustraction par coefficient).
La résolution des systèmes triangulaires est en <I>O</I>(<I>n</I><SUP>2</SUP>).
</LI><LI CLASS="li-itemize">Le calcul est plus favorable au cache mémoire, puisqu’on
travaille sur une portion de plus en plus petite de la matrice.
</LI></UL><P>On peut inverser une matrice en utilisant la décomposition
<I>LU</I>. Supposons pour simplifier que la permutation est l’identité.
On calcule d’abord <I>L</I><SUP>−1</SUP> en utilisant le fait que <I>L</I> est
triangulaire inférieure, voici comment cela est implémenté dans
Xcas (<I>L</I> est noté <TT>l</TT>) :
</P><PRE CLASS="verbatim">first step compute l^-1, 
solve l*a=y for y a canonical basis vector
  a0=y0, a1=y1-l_{1,0}*a0, ..., ak=yk-sum_{j=0..k-1}(l_kj*aj)
if y=(0,..,0,1,0,...0) (1 at position i), 
  a0=..=a_{i-1}=0, a_i=1 and we start at equation k=i+1 and sum_{j=i...}
-&gt; n^3/6 operations
To store the result in place of l
we first compute all the a2 (there is only 1), then all the a3 (2), etc.
a0=y0, a1=y1-l_{1,0}*a0, ..., ak=yk-sum_{j=0..k-1}(l_kj*aj)
</PRE><P>Puis on résoud <I>U</I> <I>A</I><SUP>−1</SUP>=<I>L</I><SUP>−1</SUP> colonne par colonne
</P><PRE CLASS="verbatim">second step, solve u*inverse=l^-1 (now under the diagonal)
we compute a column of inverse by solving the system: 
u*col(inverse)=corresponding row of l^-1, 
and overwrite the row of l^-1 by solution
u*[x0,..,xn-1]=[a0,...,an]
x_{n-1}=a_{n-1}/u_{n-1,n-1}
x_{n-2}=(a_{n-2}-u_{n-2,n-1}*x_{n-1})/u_{n-2,n-2}
...
x_k=(a_{k}-sum_{j=k+1..n-1} u_{k,j}x_j)/u_{k,k}
-&gt; n^3/2 operations
To store the solution in place, we first compute all the x_{n-1}
put them in the last line of m, then all the x_{n-2}, etc.
</PRE><!--TOC subsection La factorisation de Cholesky-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc203">20.5</A>  La factorisation de Cholesky</H3><!--SEC END --><P> <A NAME="@default246"></A>
<A NAME="@default247"></A>
Dans le cas où la matrice est réelle symétrique ou plus
généralement hermitienne, on peut obtenir une écriture analogue
mais où <I>U</I> est la transconjuguée de <I>L</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=<I>U</I><SUP>*</SUP> <I>U</I> = <I>L</I> <I>L</I><SUP>*</SUP> </TD></TR>
</TABLE><P>
<I>L</I> reste triangulaire
inférieure, mais n’a plus des 1 sur sa diagonale en général. Si
<I>A</I> est définie positive, on peut rendre l’écriture unique en
imposant aux coefficients diagonaux de <I>L</I> d’être réels positifs.</P><P>L’algorithme de calcul de <I>U</I> est la traduction matricielle de l’algorithme
de Gauss de réduction des formes quadratiques. On a en effet
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I><SUP>*</SUP> <I>A</I> <I>x</I>=<I>x</I><SUP>*</SUP> <I>U</I><SUP>*</SUP> <I>U</I> <I>x</I> = ||<I>Ux</I>||<SUP>2</SUP> </TD></TR>
</TABLE><P>
les lignes de <I>U</I> (ou les colonnes de <I>L</I>) sont donc les coefficients
des formes linéaires indépendantes qui interviennent dans l’écriture
de la forme quadratique comme somme/différence de carrés de formes
linéaires. Si <I>A</I>
est définie positive, seules des sommes interviennent, et les
variables s’éliminent l’une après l’autre (le coefficient de <I>x</I><SUB>2</SUB> est forcément
non nul lorsqu’on a éliminé <I>x</I><SUB>1</SUB> et ainsi de suite), ceci explique
la forme triangulaire de <I>U</I> et <I>L</I>.</P><P>Le calcul de <I>L</I> se fait donc colonne par colonne, en calculant d’abord le
coefficient diagonal comme racine carrée du coefficient diagonal 
α<SUB><I>j</I></SUB>=√<SPAN style="text-decoration:overline"><I>A</I></SPAN><SUB><SPAN style="text-decoration:overline"><I>j</I>,<I>j</I></SPAN></SUB>.
Ensuite on effectue les combinaisons de ligne sous la forme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>l</I><SUB><I>j</I></SUB> → </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">α<SUB><I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>l</I><SUB><I>j</I></SUB>,     <I>l</I><SUB><I>i</I></SUB> → α<SUB><I>j</I></SUB> <I>l</I><SUB><I>i</I></SUB> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>A</I><SUB><I>i</I>,<I>j</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">α<SUB><I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>l</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>On peut aussi tout simplement effectuer le produit de <I>L</I> <I>L</I><SUP>*</SUP> et
chercher les inconnues en commencant par <I>l</I><SUB>1,1</SUB> puis on calcule
les <I>l</I><SUB><I>i</I>,1</SUB> pour <I>i</I>&gt;1, etc. En suivant wikipedia, pour une matrice réelle :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>L</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">⎡<BR>
⎢<BR>
⎢<BR>
⎢<BR>
⎣</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>l</I><SUB>11</SUB></TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>⋯</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>l</I><SUB>21</SUB></TD><TD ALIGN=center NOWRAP><I>l</I><SUB>22</SUB></TD><TD ALIGN=center NOWRAP>⋯</TD><TD ALIGN=center NOWRAP>0</TD></TR>
<TR><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>⋱</TD><TD ALIGN=center NOWRAP>⋮</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>l</I><SUB><I>n</I>1</SUB></TD><TD ALIGN=center NOWRAP><I>l</I><SUB><I>n</I>2</SUB></TD><TD ALIGN=center NOWRAP>⋯</TD><TD ALIGN=center NOWRAP><I>l</I><SUB><I>nn</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎤<BR>
⎥<BR>
⎥<BR>
⎥<BR>
⎦</TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>ij</I></SUB>=</TD><TD CLASS="dcell">⎛<BR>
⎝</TD><TD CLASS="dcell"><I>LL</I><SUP><I>T</I></SUP></TD><TD CLASS="dcell">⎞<BR>
⎠</TD><TD CLASS="dcell"><SUB><I>ij</I></SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>l</I><SUB><I>ik</I></SUB><I>l</I><SUB><I>jk</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">=
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">min</TD><TD CLASS="dcell">⎧<BR>
⎨<BR>
⎩</TD><TD CLASS="dcell"><I>i</I>,<I>j</I></TD><TD CLASS="dcell">⎫<BR>
⎬<BR>
⎭</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>l</I><SUB><I>ik</I></SUB><I>l</I><SUB><I>jk</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">, 1≤ <I>i</I>,<I>j</I>≤ <I>n</I> </TD></TR>
</TABLE><P>
La matrice <I>A</I> étant symétrique, il suffit que les relations ci-dessus
soient vérifiées pour <I>i</I> ≤ <I>j</I>, 
c’est-à-dire que les éléments <I>l</I><SUB><I>i</I>,<I>j</I></SUB> de la matrice <I>L</I> doivent
satisfaire
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>ij</I></SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>i</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>l</I><SUB><I>ik</I></SUB><I>l</I><SUB><I>jk</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">, 1≤ <I>i</I>≤ <I>j</I>≤ <I>n</I> </TD></TR>
</TABLE><P>
Pour <I>i</I>=1, on détermine la première colonne de <I>L</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB>11</SUB>=<I>l</I><SUB>11</SUB><I>l</I><SUB>11</SUB>,    <I>a</I><SUB>1<I>j</I></SUB>=<I>l</I><SUB>11</SUB><I>l</I><SUB><I>j</I>1</SUB></TD></TR>
</TABLE><P>
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>l</I><SUB>11</SUB>=</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>a</I><SUB>11</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">,    <I>l</I><SUB><I>j</I>1</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUB>1<I>j</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I><SUB>11</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">
 (pour  <I>j</I>&gt;1) </TD></TR>
</TABLE><P>
On détermine la <I>i</I>-ième colonne de <I>L</I> (2≤ <I>i</I>≤ <I>n</I>) après avoir
calculé les <I>i</I>−1 premières colonnes
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>ii</I></SUB>=<I>l</I><SUB><I>i</I>1</SUB><I>l</I><SUB><I>i</I>1</SUB>+…+<I>l</I><SUB><I>ii</I></SUB><I>l</I><SUB><I>ii</I></SUB>,   
<I>a</I><SUB><I>ij</I></SUB>=<I>l</I><SUB><I>i</I>1</SUB><I>l</I><SUB><I>j</I>1</SUB>+…+<I>l</I><SUB><I>ii</I></SUB><I>l</I><SUB><I>ji</I></SUB> </TD></TR>
</TABLE><P>
d’où 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>l</I><SUB><I>ii</I></SUB>= </TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>ii</I></SUB>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>i</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>l</I><SUB><I>ik</I></SUB><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">,   
<I>l</I><SUB><I>ji</I></SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>ij</I></SUB>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>i</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>l</I><SUB><I>ik</I></SUB><I>l</I><SUB><I>jk</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I><SUB><I>ii</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
(pour  <I>j</I> &gt; <I>i</I>)</TD></TR>
</TABLE><P>
Pour une matrice hermitienne complexe, il suffit de remplacer
<I>l</I><SUB><I>ik</I></SUB><I>l</I><SUB><I>jk</I></SUB> par <I>l</I><SUB><I>ik</I></SUB><SPAN style="text-decoration:overline"><I>l</I></SPAN><SUB><SPAN style="text-decoration:overline"><I>jk</I></SPAN></SUB> et <I>l</I><SUB><I>ik</I></SUB><SUP>2</SUP> par
|<I>l</I><SUB><I>ik</I></SUB>|<SUP>2</SUP>.</P><P>Le nombre d’opérations à effectuer est asymptotiquement
2 fois plus faible que celui pour <I>LU</I>. En effet,
pour la première ligne, il faut 1 racine et <I>n</I>−1 divisions,
pour la deuxième ligne, 1 racine, <I>n</I>−1 additions, multiplications
et <I>n</I>−2 divisions, ..., pour la <I>i</I>-ième ligne 1 racine,
(<I>i</I>−1)(<I>n</I>−<I>i</I>) additions, multiplications et <I>n</I>−2 divisions, au final
le cout est dominé par les additions et multiplications en 1/6<I>n</I><SUP>3</SUP>
pour chaque, donc 1/3<I>n</I><SUP>3</SUP> en tout, contre 2/3<I>n</I><SUP>3</SUP> pour la
factorisation <I>LU</I>.</P><P>La commande Xcas correspondante est <CODE>cholesky</CODE> et renvoie
la matrice <I>L</I>.</P><!--TOC subsection Conditionnement-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc204">20.6</A>  Conditionnement</H3><!--SEC END --><P> <A NAME="@default248"></A> <A NAME="@default249"></A>
Le conditionnement mesure la sensibilité de la solution renvoyée d’un
système linéaire aux données du problème.</P><P>Soit le système linéaire <I>Ax</I>=<I>b</I> de solution <I>x</I>=<I>A</I><SUP>−1</SUP><I>b</I>, 
supposons <I>b</I> connu avec une erreur <I>e</I>, alors la solution renvoyée
sera <I>x</I>+<I>A</I><SUP>−1</SUP><I>e</I>, on a donc une erreur relative sur la solution de 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">||<I>A</I><SUP>−1</SUP><I>e</I>||</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">||<I>A</I><SUP>−1</SUP><I>b</I>||</TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">||<I>A</I><SUP>−1</SUP><I>e</I>||</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">||<I>e</I>||</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">||<I>e</I>||</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">||<I>b</I>||</TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">||<I>b</I>||</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">||<I>A</I><SUP>−1</SUP><I>b</I>||</TD></TR>
</TABLE></TD><TD CLASS="dcell">  ≤ |||<I>A</I><SUP>−1</SUP>|||  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">|<I>e</I>|</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">|<I>b</I>|</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |||<I>A</I>|||  </TD></TR>
</TABLE><P>
(la dernière inégalité s’obtient en écrivant <I>b</I>=<I>A</I>(<I>A</I><SUP>−1</SUP><I>b</I>)).
On en déduit que le rapport de l’erreur relative sur la solution par l’erreur
relative du second membre est majorée par
le produit de la norme de <I>A</I> (en tant qu’application linéaire)
par la norme de <I>A</I><SUP>−1</SUP>, ce produit est appelé conditionnement
de la matrice <I>A</I> (ou parfois nombre de condition de <I>A</I> en adoptant
la terminologie anglo-saxonne).</P><P>On remarquera que le conditionnement dépend du choix de la norme sur
l’espace vectoriel.
Si on prend comme norme la norme <I>L</I><SUP>2</SUP>, le calcul de |||<I>A</I>|||
nécessite de maximiser √<SPAN style="text-decoration:overline">&lt;<I>Ab</I>|<I>Ab</I>&gt;</SPAN> pour <I>b</I> de norme 1, ce qui revient
à maximiser √<SPAN style="text-decoration:overline">&lt;<I>b</I>|<I>A</I></SPAN><SUP><SPAN style="text-decoration:overline">*</SPAN></SUP><SPAN style="text-decoration:overline"> <I>A</I> <I>b</I>&gt;</SPAN>. En diagonalisant la matrice hermitienne
<I>A</I><SUP>*</SUP> <I>A</I>, on voit qu’il suffit d’en trouver la plus grande valeur
propre et d’en prendre la racine carrée. Les valeurs propres de
<I>A</I><SUP>*</SUP><I>A</I> sont appelées valeurs singulières de <I>A</I> (ce sont des
réels positifs). Le même raisonnement pour <I>A</I><SUP>−1</SUP> (dont les
valeurs singulières sont les inverses des valeurs singulières de <I>A</I>) nous
donne alors le :
</P><DIV CLASS="theorem"><B>Théorème 43</B>  <EM>
Lorsqu’on résoud un système linéaire </EM><EM><I>Ax</I>=<I>b</I></EM><EM>, </EM><EM><I>A</I></EM><EM> matrice connue
précisément et inversible, </EM><EM><I>b</I></EM><EM> connu avec une erreur relative en
norme </EM><EM><I>L</I></EM><SUP><EM>2</EM></SUP><EM>, l’erreur relative en norme </EM><EM><I>L</I></EM><SUP><EM>2</EM></SUP><EM> sur </EM><EM><I>x</I></EM><EM> est au plus
multipliée par
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><I>K</I></EM><SUB><EM>2</EM></SUB><EM>(<I>A</I>)= </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM>λ</EM><SUB><EM><I>n</I></EM></SUB></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM>λ</EM><SUB><EM>1</EM></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> </EM></TD></TR>
</TABLE><EM>
oú </EM><EM>λ</EM><SUB><EM><I>n</I></EM></SUB><EM> [resp. </EM><EM>λ</EM><SUB><EM>1</EM></SUB><EM>] est la plus grande [resp. plus
petite] valeur singulière de </EM><EM><I>A</I></EM><EM> (racines carrées des
valeurs propres de </EM><EM><I>A</I></EM><SUP><EM>*</EM></SUP><EM><I>A</I></EM><EM>).<BR>
Ce facteur d’amplification des erreurs relatives est évidemment
supérieur ou égal à 1. Il est égal à 1 si la matrice est
unitaire (puisque </EM><EM><I>A</I></EM><EM> est une matrice
d’isométrie ou car </EM><EM><I>AA</I></EM><SUP><EM>*</EM></SUP><EM>=<I>I</I></EM><EM>). 
S’il est de l’ordre de </EM><EM>2</EM><SUP><EM><I>c</I></EM></SUP><EM> on perdra (au plus) </EM><EM><I>c</I></EM><EM> bits de
précision sur la mantisse de </EM><EM><I>x</I></EM><EM>.
</EM></DIV><P>
Avec Xcas, les <B>valeurs singulières</B><A NAME="@default250"></A> 
<A NAME="@default251"></A>
s’obtiennent par l’instruction
<CODE>SVL(A)</CODE>, le conditionnement <I>L</I><SUP>2</SUP> par <CODE>COND(A,2)</CODE>.
Attention, les valeurs singulières de <I>A</I> ne sont pas les valeurs
absolues des valeurs propres de <I>A</I> (c’est le cas si <I>A</I> 
commute avec sa transconjuguée mais ce n’est pas général).
On peut utiliser la méthode de la puissance (cf. infra) pour estimer la plus
grande valeur singulière de <I>A</I> (donc sans diagonaliser complètement
la matrice <I>A</I><SUP>*</SUP><I>A</I>), et de même sur <I>A</I><SUP>−1</SUP> (en utilisant <I>LU</I>
ou Cholesky pour trouver les itérées sans calculer <I>A</I><SUP>−1</SUP>).</P><P>On peut aussi prendre la norme <I>L</I><SUP>1</SUP> sur l’espace vectoriel, dans ce
cas la norme de matrice correspondante est la norme de colonne (exercice!),
le maximum des sommes valeurs absolues des éléments
des colonnes (<CODE>colNorm(A)</CODE> en Xcas) et le conditonnement
est le produit de <CODE>colNorm(A)</CODE> par <CODE>colNorm(inv(A))</CODE>
qui est renvoyé par <CODE>COND(A)</CODE> en Xcas.</P><P>Si la matrice du système <I>A</I> (de nombre de condition noté
κ(<I>A</I>)) est elle-même connue avec une
certaine incertitude, alors pour ||Δ <I>A</I>|| suffisamment petit,
on montre que la solution de
(<I>A</I>+Δ <I>A</I>)(<I>x</I>+Δ <I>x</I>)=<I>b</I>+Δ <I>b</I> vérifie
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">|Δ <I>x</I> |</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">|<I>x</I>|</TD></TR>
</TABLE></TD><TD CLASS="dcell">≤
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">κ(<I>A</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">1−κ(<I>A</I>)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">||Δ <I>A</I>||</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">||<I>A</I>||</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">|Δ <I>b</I>|</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">|<I>b</I>|</TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">||Δ <I>A</I>||</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">||<I>A</I>||</TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><!--TOC subsection Réduction des endomorphismes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc205">20.7</A>  Réduction des endomorphismes</H3><!--SEC END --><!--TOC subsubsection Le polynôme minimal-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc206">20.7.1</A>  Le polynôme minimal</H4><!--SEC END --><P><A NAME="@default252"></A>
On prend un vecteur <I>v</I> au hasard et on calcule la relation linéaire
de degré minimal entre <I>v</I>, <I>Av</I>, ..., <I>A</I><SUP><I>n</I></SUP><I>v</I> en cherchant
le premier vecteur <I>w</I> du noyau de la matrice obtenue en écrivant
les vecteurs <I>v</I>, <I>Av</I>, etc. en colonne dans cet ordre. Les
coordonnées de <I>w</I> donnent alors par ordre de degré croissant
un polynôme <I>P</I> de degré minimal tel que <I>P</I>(<I>A</I>)<I>v</I>=0 donc
<I>P</I> divise le polynôme minimal <I>M</I>. Donc si <I>P</I> est de
degré <I>n</I>, <I>P</I>=<I>M</I>. Sinon, il faut vérifier que le polynôme obtenu 
annule la matrice <I>A</I>. On peut aussi calculer en parallèle le polynôme <I>P</I>
précédent pour quelques vecteurs aléatoires et prendre le PPCM des
polynômes obtenus.</P><P><B>Exemple 1</B><BR>
Polynôme minimal de (</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>4</TD></TR>
</TABLE><P>) . On prend <I>v</I>=(1,0), la matrice à réduire est
alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>−11 </TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>10</TD><TD ALIGN=center NOWRAP>38</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">→ 
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>−6 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>5</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
Le noyau est engendré par (−6,5,−1) donc <I>P</I>=−<I>x</I><SUP>2</SUP>+5<I>x</I>−6.</P><P><B>Exemple 2</B><BR>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 3</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>−2 </TD></TR>
<TR><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
en prenant <I>v</I>=(1,0,0) on obtient la matrice :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>3</TD><TD ALIGN=center NOWRAP>5</TD><TD ALIGN=center NOWRAP>7 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>−2</TD><TD ALIGN=center NOWRAP>−3 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>3</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">→
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>−2 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>3 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
le permier vecteur du noyau est (−1,2,−1) d’où un polynôme divisant
le polynôme minimal −<I>x</I><SUP>2</SUP>+2<I>x</I>−1.</P><!--TOC subsubsection Le polynôme caractéristique-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc207">20.7.2</A>  Le polynôme caractéristique</H4><!--SEC END --><P>
<A NAME="@default253"></A>
Pour une matrice générique, le polynôme caractéristique est égal
au polynôme minimal, il est donc intéressant de chercher si le polynôme
annulateur de <I>A</I> sur un vecteur aléatoire est de degré <I>n</I>, 
car le temps de calcul du polynôme caractéristique est alors en <I>O</I>(<I>n</I><SUP>3</SUP>). 
Si cette méthode probabiliste échoue, on se
rabat sur une des méthode déterministe ci-dessous:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
on utilise la formule det(λ <I>I</I> −<I>A</I>) déterminé par
une des méthodes de calcul de déterminant ci-dessus. Cela
nécessite <I>O</I>(<I>n</I><SUP>3</SUP>) opérations mais avec des coefficients 
polynômes en λ.
</LI><LI CLASS="li-itemize">on fait une interpolation de Lagrange en donnant <I>n</I>+1 valeurs
distinctes à λ. Ce qui nécessite <I>O</I>(<I>n</I><SUP>4</SUP>) opérations mais avec
des coefficients indépendants de λ, de plus cette méthode 
est facile à programmer de manière parallèle.
</LI><LI CLASS="li-itemize">si la matrice est à coefficients entiers
on peut utiliser la méthode de Hessenberg (voir ci-dessous), on calcule
une borne à priori sur les coefficients du polynôme caractéristique
(cf. Cohen p.58-59) :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>P</I><SUB><I>k</I></SUB>| ≤ </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>n</I> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>n</I>−<I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
(<I>n</I>−<I>k</I>)<SUP>(<I>n</I>−<I>k</I>)/2</SUP> |<I>M</I>|<SUP><I>n</I>−<I>k</I></SUP>  ,</TD></TR>
</TABLE>
on calcule le polynôme caractéristique modulo suffisamment
de petits entiers puis on remonte par les restes chinois.
</LI></UL><!--TOC subsubsection La méthode de Hessenberg-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc208">20.7.3</A>  La méthode de Hessenberg</H4><!--SEC END --><P><A NAME="@default254"></A>
Pour les matrices à coefficients de taille bornée (modulaires par exemple)
on préfère la méthode de Hessenberg qui est plus
efficace, car elle nécessite de l’ordre de <I>n</I><SUP>3</SUP> opérations sur
les coefficients.</P><P>On se raméne d’abord à une matrice triangulaire supérieure à
une diagonale près qui est semblable à la
matrice de départ puis on
applique une formule de récurrence pour calculer les coefficients
du polynôme caractéristique.</P><P><B>Algorithme de réduction de Hessenberg:</B><BR>
Dans une colonne <I>m</I> donnée de la matrice <I>H</I>, 
on cherche à partir de la ligne
<I>m</I>+1 un coefficient non nul. S’il n’y en a pas on passe à la colonne
suivante. S’il y en a un en ligne <I>i</I>, on échange les lignes <I>m</I>+1
et <I>i</I> et les colonnes <I>m</I>+1 et <I>i</I>. Ensuite pour tout <I>i</I>≥ <I>m</I>+2,
soit <I>u</I>=<I>H</I><SUB><I>i</I>,<I>m</I></SUB>/<I>H</I><SUB><I>m</I>+1,<I>m</I></SUB>, on remplace alors la ligne <I>L</I><SUB><I>i</I></SUB> de <I>H</I>
par <I>L</I><SUB><I>i</I></SUB>−<I>uL</I><SUB><I>m</I>+1</SUB> et la colonne <I>C</I><SUB><I>m</I>+1</SUB> par <I>C</I><SUB><I>m</I>+1</SUB>+<I>uC</I><SUB><I>i</I></SUB>
ce qui revient “à remplacer le vecteur <I>e</I><SUB><I>m</I>+1</SUB> de la base
par le vecteur <I>e</I><SUB><I>m</I>+1</SUB>+<I>ue</I><SUB><I>i</I></SUB>” ou plus précisément
à multiplier à gauche par (</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>−<I>u</I></TD><TD ALIGN=center NOWRAP>1</TD></TR>
</TABLE><P>) et à droite par la matrice inverse
(</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>u</I></TD><TD ALIGN=center NOWRAP>1</TD></TR>
</TABLE><P>) (en utilisant les lignes et colonnes
<I>m</I>+1 et <I>i</I> au lieu de 1 et 2 pour ces matrices). 
Ceci a pour effet d’annuler le coefficient <I>H</I><SUB><I>i</I>,<I>m</I></SUB>
dans la nouvelle matrice.</P><P>On obtient ainsi en <I>O</I>(<I>n</I><SUP>3</SUP>) opérations
une matrice <I>H</I>′ semblable à <I>H</I> de la forme :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>H</I>′<SUB>1,1</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB>1,2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB>1,<I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB>1,<I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB>1,<I>n</I></SUB></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>H</I>′<SUB>2,1</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB>2,2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB>2,<I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB>2,<I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB>2,<I>n</I></SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB>3,2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB>3,<I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB>3,<I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB>3,<I>n</I></SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB>4,<I>n</I>−2</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB>4,<I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB>4,<I>n</I></SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>⋮ </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB><I>n</I>,<I>n</I>−1</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>′<SUB><I>n</I>,<I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
On calcule alors le polynôme caractéristique de <I>H</I>′ par une récurrence
qui s’obtient en développant le déterminant par rapport à la dernière
colonne :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>h</I><SUB><I>n</I></SUB>(λ) = det(λ <I>I</I><SUB><I>n</I></SUB>−<I>H</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>(λ−<I>H</I>′<SUB><I>n</I>,<I>n</I></SUB>) <I>h</I><SUB><I>n</I>−1</SUB>(λ) −(−<I>H</I>′<SUB><I>n</I>−1,<I>n</I></SUB>) (−<I>H</I>′<SUB><I>n</I>,<I>n</I>−1</SUB>) 
<I>h</I><SUB><I>n</I>−2</SUB>(λ) + </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>    + (−<I>H</I>′<SUB><I>n</I>−2,<I>n</I></SUB>) (−<I>H</I>′<SUB><I>n</I>,<I>n</I>−1</SUB>) (−<I>H</I>′<SUB><I>n</I>−1,<I>n</I>−2</SUB>) <I>h</I><SUB><I>n</I>−3</SUB>(λ) − ...</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
où les <I>h</I><SUB><I>i</I></SUB> s’entendent en gardant les <I>i</I> premières lignes/colonnes de <I>H</I>′.
On peut écrire cette formule pour <I>m</I>≤ <I>n</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>h</I><SUB><I>m</I></SUB>(λ)= (λ − <I>H</I>′<SUB><I>m</I>,<I>m</I></SUB>) <I>h</I><SUB><I>m</I>−1</SUB>(λ)
−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>m</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>H</I>′<SUB><I>m</I>−<I>i</I>,<I>m</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>i</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>H</I>′<SUB><I>m</I>−<I>j</I>+1,<I>m</I>−<I>j</I></SUB> <I>h</I><SUB><I>i</I>−1</SUB>(λ)</TD></TR>
</TABLE><P>
Pour effectuer cette récurrence de manière efficace, on conserve
les <I>h</I><SUB><I>m</I></SUB>(λ) dans un tableau de polynômes et on utilise une 
variable produit contenant successivement les ∏<I>H</I>′<SUB><I>m</I>−<I>j</I>+1,<I>m</I>−<I>j</I></SUB>.</P><P><B>Remarques</B>
Une variante de la réduction ci-dessus utilise des matrices de
<B>rotation de Givens</B><A NAME="@default255"></A> : il s’agit d’une rotation
dans le plan engendré par deux vecteurs de base <I>e</I><SUB><I>i</I></SUB>,<I>e</I><SUB><I>j</I></SUB> 
prolongée par l’identité. On doit alors effectuer 
deux combinaisons linéaires de ligne
et deux combinaisons linéaires de colonnes par transformation
donc deux fois plus de calculs, mais l’avantage est que la matrice
de transformation est unitaire (donc facile à inverser, et bien
conditionnée).</P><P>On peut aussi utiliser des <B>matrices de
Householder</B><A NAME="@default256"></A> 
pour se ramener à une forme de Hessenberg.
La matrice de Householder associée à <I>v</I> est définie par ;
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>H</I>=<I>I</I>−2</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>v</I> <I>v</I><SUP><I>t</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">||<I>v</I>||<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
c’est la matrice de la symétrie par rapport à l’hyperplan 
perpendiculaire à <I>v</I>, <I>Hv</I>=−<I>v</I> et pour tout vecteur
perpendiculaire à <I>v</I> on a <I>Hw</I>=<I>w</I>, donc <I>H</I> est orthogonale.
On l’utilise en général pour <I>v</I>=<I>a</I>−<I>b</I> avec ||<I>a</I>||=||<I>b</I>||,
on a alors <I>Ha</I>=<I>b</I> puisque <I>H</I>(<I>a</I>−<I>b</I>)=<I>b</I>−<I>a</I> car <I>v</I>=<I>a</I>−<I>b</I> et <I>H</I>(<I>a</I>+<I>b</I>)=<I>a</I>+<I>b</I>
car <I>v</I> est orthogonal à <I>a</I>+<I>b</I> (puisque ||<I>a</I>||=||<I>b</I>||).</P><!--TOC subsubsection La méthode de
Leverrier-Faddeev-Souriau-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc209">20.7.4</A>  La méthode de
Leverrier-Faddeev-Souriau</H4><!--SEC END --><P><A NAME="@default257"></A> <A NAME="@default258"></A><A NAME="@default259"></A>
Cette méthode permet le calcul simultané des coefficients 
<I>p</I><SUB><I>i</I></SUB>  (<I>i</I>=0..<I>n</I>) du polynôme caractéristique 
<I>P</I>(λ)=det(λ <I>I</I>−<I>A</I>) et des coefficients matriciels
<I>B</I><SUB><I>i</I></SUB>  (<I>i</I>=0..<I>n</I>−1) du polynôme en λ donnant la matrice adjointe
(ou transposée de la comatrice) <I>B</I>(λ) de λ <I>I</I> −<I>A</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:Bp"></A>
(λ <I>I</I> −<I>A</I>)<I>B</I>(λ)=(λ <I>I</I> −<I>A</I>) </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>≤ <I>n</I>−1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>B</I><SUB><I>k</I></SUB> λ<SUP><I>k</I></SUP>
= (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>≤ <I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>p</I><SUB><I>k</I></SUB> λ<SUP><I>k</I></SUP>)<I>I</I> =<I>P</I>(λ)<I>I</I>
    (44)</TD></TR>
</TABLE><P>
Remarquons que cette équation donne une démonstration assez simple
de Cayley-Hamilton puisque le reste de la division euclidienne
du polynôme <I>P</I>(λ)<I>I</I> par λ <I>I</I> −<I>A</I>  est <I>P</I>(<I>A</I>).</P><P>Pour déterminer simultanément les <I>p</I><SUB><I>k</I></SUB> et <I>B</I><SUB><I>k</I></SUB>,
on a les relations de récurrence :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
<A NAME="eq:Bp1"></A> <I>B</I><SUB><I>n</I>−1</SUB>=<I>p</I><SUB><I>n</I></SUB> <I>I</I>=<I>I</I>,    <I>B</I><SUB><I>k</I></SUB>−<I>AB</I><SUB><I>k</I>+1</SUB>=<I>p</I><SUB><I>k</I>+1</SUB> <I>I</I>
    (45)</TD></TR>
</TABLE><P>
Il nous manque une relation entre les <I>p</I><SUB><I>k</I></SUB> et <I>B</I><SUB><I>k</I></SUB> pour pouvoir
faire le calcul par valeurs décroissantes de <I>k</I>, on va montrer le :
</P><DIV CLASS="theorem"><B>Théorème 44</B>  <EM>
La dérivée du polynôme caractéristique </EM><EM><I>P</I>′(λ)</EM><EM>,
est égale à la trace de la matrice adjointe 
de </EM><EM>λ <I>I</I>−<I>A</I></EM><EM>
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>tr</EM><EM>(<I>B</I>)=<I>P</I>′(λ) </EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>
Le théorème nous donne tr(<I>B</I><SUB><I>k</I></SUB>) = (<I>k</I>+1)<I>p</I><SUB><I>k</I>+1</SUB> .
Si on prend la trace de (<A HREF="#eq:Bp1">45</A>), on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">tr(<I>B</I><SUB><I>n</I>−1</SUB>)=<I>n</I> <I>p</I><SUB><I>n</I></SUB>,    (<I>k</I>+1)<I>p</I><SUB><I>k</I>+1</SUB> −tr(<I>AB</I><SUB><I>k</I>+1</SUB>)
=<I>np</I><SUB><I>k</I>+1</SUB> </TD></TR>
</TABLE><P>
donc on calcule <I>p</I><SUB><I>k</I>+1</SUB> en fonction de <I>B</I><SUB><I>k</I>+1</SUB> puis <I>B</I><SUB><I>k</I></SUB> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>p</I><SUB><I>k</I>+1</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">tr(<I>AB</I><SUB><I>k</I>+1</SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>+1−<I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">, 
   <I>B</I><SUB><I>k</I></SUB>=<I>AB</I><SUB><I>k</I>+1</SUB>+<I>p</I><SUB><I>k</I>+1</SUB> <I>I</I> </TD></TR>
</TABLE><P>
<B>Démonstration du théorème:</B><BR>
Soient <I>V</I><SUB>1</SUB>(λ),...<I>V</I><SUB><I>n</I></SUB>(λ) les vecteurs colonnes 
de λ <I>I</I>−<I>A</I> et <I>b</I><SUB><I>i</I>,<I>j</I></SUB>(λ) les coefficients de <I>B</I>, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>P</I>′(λ<SUB>0</SUB>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>det(<I>V</I><SUB>1</SUB>(λ),<I>V</I><SUB>2</SUB>(λ),...,<I>V</I><SUB><I>n</I></SUB>(λ) )′
<SUB>|λ=λ<SUB>0</SUB></SUB></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>det(<I>V</I>′<SUB>1</SUB>(λ<SUB>0</SUB>),<I>V</I><SUB>2</SUB>(λ<SUB>0</SUB>),...,<I>V</I><SUB><I>n</I></SUB>(λ<SUB>0</SUB>) )+
det(<I>V</I><SUB>1</SUB>(λ<SUB>0</SUB>),<I>V</I>′<SUB>2</SUB>(λ<SUB>0</SUB>),...,<I>V</I><SUB><I>n</I></SUB>(λ<SUB>0</SUB>) )+ </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>+...+det(<I>V</I><SUB>1</SUB>(λ<SUB>0</SUB>),<I>V</I><SUB>2</SUB>(λ<SUB>0</SUB>),...,<I>V</I>′<SUB><I>n</I></SUB>(λ<SUB>0</SUB>) )</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Il suffit alors de remarquer que
<I>V</I>′<SUB><I>i</I></SUB>(λ<SUB>0</SUB>) est le <I>i</I>-ième vecteur de la base canonique donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">det(<I>V</I><SUB>1</SUB>(λ<SUB>0</SUB>),<I>V</I><SUB>2</SUB>(λ<SUB>0</SUB>),...,<I>V</I>′<SUB><I>i</I></SUB>(λ<SUB>0</SUB>),...,<I>V</I><SUB><I>n</I></SUB>(λ<SUB>0</SUB>) )
=<I>b</I><SUB><I>i</I>,<I>i</I></SUB>(λ<SUB>0</SUB>) </TD></TR>
</TABLE><P>
Finalement :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>′(λ<SUB>0</SUB>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>b</I><SUB><I>i</I>,<I>i</I></SUB>(λ<SUB>0</SUB>)=tr (<I>B</I>(λ<SUB>0</SUB>)) </TD></TR>
</TABLE><P><B>Remarque</B> :<BR>
En réindexant les coefficients de <I>P</I> et <I>B</I> de la manière suivante :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>P</I>(λ)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>λ<SUP><I>n</I></SUP>+<I>p</I><SUB>1</SUB>λ<SUP><I>n</I>−1</SUP>+<I>p</I><SUB>2</SUB>λ<SUP><I>n</I>−2</SUP>...+<I>p</I><SUB><I>n</I></SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>B</I>(λ)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>λ<SUP><I>n</I>−1</SUP><I>I</I>+λ<SUP><I>n</I>−2</SUP><I>B</I><SUB>1</SUB>+...+<I>B</I><SUB><I>n</I>−1</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
on a montré que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎧<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎨<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎩</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>A</I><SUB>1</SUB>=<I>A</I>,</TD><TD ALIGN=center NOWRAP><I>p</I><SUB>1</SUB>=−tr(<I>A</I>),</TD><TD ALIGN=center NOWRAP><I>B</I><SUB>1</SUB>=<I>A</I><SUB>1</SUB>+<I>p</I><SUB>1</SUB><I>I</I> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I><SUB>2</SUB>=<I>AB</I><SUB>1</SUB>,</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>p</I><SUB>2</SUB>=−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">tr(<I>A</I><SUB>2</SUB>),</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><I>B</I><SUB>2</SUB>=<I>A</I><SUB>2</SUB>+<I>p</I><SUB>2</SUB><I>I</I> </TD></TR>
<TR><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>⋮ </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I><SUB><I>k</I></SUB>=<I>AB</I><SUB><I>k</I>−1</SUB>,</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>p</I><SUB><I>k</I></SUB>=−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">tr(<I>A</I><SUB><I>k</I></SUB>),</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><I>B</I><SUB><I>k</I></SUB>=<I>A</I><SUB><I>k</I></SUB>+<I>p</I><SUB><I>k</I></SUB><I>I</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD></TR>
</TABLE><P>
On peut alors vérifier que <I>B</I><SUB><I>n</I></SUB>=<I>A</I><SUB><I>n</I></SUB>+<I>p</I><SUB><I>n</I></SUB><I>I</I>=0.
D’où ce petit programme :
</P><PRE CLASS="verbatim">Faddeev(A):={ // renvoie la liste des matrices B et le polynome P
  local Aj,AAj,Id,coef,n,pcara,lmat,j;
  n:=ncols(A);
  Id:=idn(n);     // matrice identite
  Aj:=Id;
  lmat:=[];      // B initialise a liste vide
  pcara:=[1];    // coefficient de plus grand degre de P
  for j from 1 to n do
    lmat:=append(lmat,Aj);  // rajoute Aj a la liste de matrices
    AAj:=Aj*A;
    coef:=-trace(AAj)/j;    
    pcara:=append(pcara,coef);  // rajoute coef au pol. caract.
    Aj:=AAj+coef*Id;
   end_for;
  return lmat,pcara;        // resultat
}:;
</PRE><!--TOC subsubsection Les vecteurs propres simples.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc210">20.7.5</A>  Les vecteurs propres simples.</H4><!--SEC END --><P>
On suppose ici qu’on peut factoriser le polynôme caractéristique
(ou calculer dans une extension algébrique d’un corps).
Lorsqu’on a une valeur propre simple λ<SUB>0</SUB>, en écrivant
la relation (<I>A</I>−λ<SUB>0</SUB> <I>I</I>)<I>B</I>(λ<SUB>0</SUB>)=<I>P</I>(λ<SUB>0</SUB>)<I>I</I>=0,
on voit que les vecteurs colonnes de la matrice <I>B</I>(λ<SUB>0</SUB>)
sont vecteurs propres.
Remarquer que <I>B</I>(λ<SUB>0</SUB>) ≠ 0 sinon on pourrait factoriser
λ−λ<SUB>0</SUB> dans <I>B</I>(λ) et apres simplifications on aurait :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>A</I>−λ<SUB>0</SUB> <I>I</I>)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">λ−λ<SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">(λ<SUB>0</SUB>)=
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">λ−λ<SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">(λ<SUB>0</SUB>)<I>I</I> </TD></TR>
</TABLE><P>
or le 2ème membre est inversible en λ<SUB>0</SUB> ce qui n’est pas le
cas du premier.
Pour avoir une base des vecteurs propres associés à λ<SUB>0</SUB>, on
calcule <I>B</I>(λ<SUB>0</SUB>)  par la méthode de Horner appliquée au
polynôme <I>B</I>(λ) en λ=λ<SUB>0</SUB>, et on réduit en
colonnes la matrice obtenue.</P><!--TOC subsubsection La forme normale de Jordan-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc211">20.7.6</A>  La forme normale de Jordan</H4><!--SEC END --><P> <A NAME="sec:jordan"></A><A NAME="@default260"></A>
Pour les valeurs propres de multiplicité plus grande que 1, on souhaiterait 
généraliser la méthode ci-dessus pour obtenir une base
de l’espace caractéristique, sous forme de cycles de Jordan.
Soit λ <SUB><I>i</I></SUB>, <I>n</I><SUB><I>i</I></SUB> les valeurs propres comptées avec leur 
multiplicité. On fait un développement de Taylor en
λ <SUB><I>i</I></SUB>:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>−<I>P</I>(λ )<I>I</I></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(<I>A</I>−λ <I>I</I>)</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">
<I>B</I>(λ<SUB><I>i</I></SUB> )+ <I>B</I>′(λ <SUB><I>i</I></SUB>)(λ −λ <SUB><I>i</I></SUB>)
+ ... +  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUP>(<I>n</I>−1)</SUP>(λ<SUB><I>i</I></SUB> )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>−1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
(λ −λ <SUB><I>i</I></SUB>)<SUP><I>n</I>−1</SUP> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−(λ −λ <SUB><I>i</I></SUB>)<SUP><I>n</I><SUB><I>i</I></SUB></SUP>
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>≠ <I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (λ −λ <SUB><I>j</I></SUB>)<SUP><I>n</I><SUB><I>j</I></SUB></SUP> <I>I</I> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Comme <I>A</I>−λ <I>I</I>=<I>A</I>−λ <SUB><I>i</I></SUB> <I>I</I> − (λ −λ <SUB><I>i</I></SUB>)<I>I</I>, on obtient
pour les <I>n</I><SUB><I>i</I></SUB> premières puissances de λ −λ <SUB><I>i</I></SUB>:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">


     

</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><A NAME="eq:jordan1"> </A>
(<I>A</I>−λ <SUB><I>i</I></SUB> <I>I</I>) <I>B</I>(λ <SUB><I>i</I></SUB>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>0</TD><TD ALIGN=right NOWRAP>    (46)</TD></TR>
<TR><TD ALIGN=right NOWRAP>(<I>A</I>−λ <SUB><I>i</I></SUB> <I>I</I>) <I>B</I>′(λ <SUB><I>i</I></SUB>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>B</I>(λ<SUB><I>i</I></SUB> )</TD><TD ALIGN=right NOWRAP>    (47)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP> ...</TD><TD ALIGN=left NOWRAP> </TD><TD ALIGN=right NOWRAP>    (48)</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(<I>A</I>−λ <SUB><I>i</I></SUB> <I>I</I>) </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>−1)</SUP>(λ <SUB><I>i</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I><SUB><I>i</I></SUB>−1)!</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>−2)</SUP>(λ <SUB><I>i</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I><SUB><I>i</I></SUB>−2)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <A NAME="eq:jordan3"> </A> </TD></TR>
</TABLE></TD><TD ALIGN=right NOWRAP>    (49)</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(<I>A</I>−λ <SUB><I>i</I></SUB> <I>I</I>)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>)</SUP>(λ<SUB><I>i</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I><SUB><I>i</I></SUB>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> −  
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>−1)</SUP>(λ<SUB><I>i</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I><SUB><I>i</I></SUB>−1)!</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>≠ <I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">(λ <SUB><I>i</I></SUB>−λ <SUB><I>j</I></SUB>)<SUP><I>n</I><SUB><I>j</I></SUB></SUP> <I>I</I> <A NAME="eq:jordan4"> </A>
</TD></TR>
</TABLE></TD><TD ALIGN=right NOWRAP>    (50)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Le calcul des matrices <I>B</I><SUP>(<I>n</I>)</SUP>(λ <SUB><I>i</I></SUB>)/<I>n</I>! pour <I>n</I>&lt;<I>n</I><SUB><I>i</I></SUB> se fait en
appliquant <I>n</I><SUB><I>i</I></SUB> fois l’algorithme de Horner (avec reste).</P><DIV CLASS="theorem"><B>Théorème 45</B>  <EM> </EM><A NAME="th:jordan"></A><EM>
L’espace caractéristique de </EM><EM>λ </EM><SUB><EM><I>i</I></EM></SUB><EM> est égal à
l’image de </EM><EM><I>B</I></EM><SUP><EM>(<I>n</I></EM><SUB><EM><I>i</I></EM></SUB><EM>−1)</EM></SUP><EM>(λ </EM><SUB><EM><I>i</I></EM></SUB><EM>)/(<I>n</I></EM><SUB><EM><I>i</I></EM></SUB><EM>−1)!</EM><EM>.
</EM></DIV><P>
<B>Preuve :</B><BR>
On montre d’abord que Im<I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>−1)</SUP>(λ <SUB><I>i</I></SUB>)/(<I>n</I><SUB><I>i</I></SUB>−1)! est inclus
dans l’espace caractéristique correspondant à λ<SUB><I>i</I></SUB> en
appliquant l’équation (<A HREF="#eq:jordan3">49</A>) et les équations précédentes.
Réciproquement on veut prouver que tout vecteur caractéristique <I>v</I> est dans 
l’image de <I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>−1)</SUP>(λ <SUB><I>i</I></SUB>)/(<I>n</I><SUB><I>i</I></SUB>−1)!. Prouvons le par récurrence
sur le plus petit entier <I>m</I> tel que
(<I>A</I>−λ <SUB><I>i</I></SUB>)<SUP><I>m</I></SUP><I>v</I>=0. Le cas <I>m</I>=0 est clair puisque <I>v</I>=0.
Supposons le cas <I>m</I> vrai, prouvons le cas <I>m</I>+1. On applique l’équation
(<A HREF="#eq:jordan4">50</A>) à <I>v</I>, il suffit alors de prouver que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>w</I>=(<I>A</I>−λ <SUB><I>i</I></SUB>)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>)</SUP>(λ<SUB><I>i</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I><SUB><I>i</I></SUB>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>v</I></TD></TR>
</TABLE><P>
appartient à l’image de
<I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>−1)</SUP>(λ <SUB><I>i</I></SUB>)/(<I>n</I><SUB><I>i</I></SUB>−1)!.
Comme <I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>)</SUP>(λ<SUB><I>i</I></SUB>)
commute avec <I>A</I> (car c’est un polynôme en <I>A</I> ou en appliquant
le fait que <I>B</I>(λ) inverse de <I>A</I>−λ <I>I</I>):
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>A</I>−λ <SUB><I>i</I></SUB>)<SUP><I>m</I></SUP> <I>w</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>)</SUP>(λ<SUB><I>i</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I><SUB><I>i</I></SUB>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
(<I>A</I>−λ <SUB><I>i</I></SUB>)<SUP><I>m</I>+1</SUP><I>v</I>=0 </TD></TR>
</TABLE><P>
et on applique l’hypothèse de récurrence à <I>w</I>.</P><P>Pour calculer les cycles de Jordan, nous allons effectuer une
réduction par le pivot de Gauß simultanément sur les colonnes
des matrices <I>B</I><SUP>(<I>k</I>)</SUP>(λ <SUB><I>i</I></SUB>)/<I>k</I>! où <I>k</I>&lt;<I>n</I><SUB><I>i</I></SUB>. 
La simultanéité a pour but de conserver les
relations (<A HREF="#eq:jordan1">46</A>) à (<A HREF="#eq:jordan3">49</A>) pour les matrices
réduites. Pour visualiser l’algorithme, on se représente les
matrices les unes au-dessus des autres, colonnes alignées.
On commence par réduire la matrice <I>B</I>(λ <SUB><I>i</I></SUB>) jusqu’à ce
que l’on obtienne une matrice réduite <B>en recopiant</B> les opérations
élémentaires de colonnes faites sur <I>B</I>(λ <SUB><I>i</I></SUB>) sur toutes les matrices
<I>B</I><SUP>(<I>k</I>)</SUP>(λ <SUB><I>i</I></SUB>)/<I>k</I>!. On va continuer avec la liste des matrices
réduites issues de <I>B</I>′(λ <SUB><I>i</I></SUB>), ..., 
<I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>−1)</SUP>(λ <SUB><I>i</I></SUB>)/(<I>n</I><SUB><I>i</I></SUB>−1)!, 
mais en déplacant les colonnes non nulles de <I>B</I>(λ <SUB><I>i</I></SUB>) 
d’une matrice vers le bas
(pour une colonne non nulle de la matrice réduite <I>B</I>(λ )
les colonnes correspondantes de <I>B</I><SUP>(<I>k</I>)</SUP>(λ <SUB><I>i</I></SUB>) réduite 
sont remplacées par les colonnes correspondantes de <I>B</I><SUP>(<I>k</I>−1)</SUP>(λ <SUB><I>i</I></SUB>)
réduite pour <I>k</I> décroissant de <I>n</I><SUB><I>i</I></SUB>−1 vers 1).
À chaque étape, on obtient une famille (éventuellement vide)
de cycles de Jordan, ce sont les vecteurs colonnes correspondants 
aux colonnes non nulles de la matrice réduite du haut de la colonne.
On élimine bien sûr les colonnes correspondant aux fins de cycles
déjà trouvés.</P><P>Par exemple, si <I>B</I>(λ <SUB><I>i</I></SUB>)≠ 0, son rang est 1 et on a
une colonne non nulle, et un cycle de Jordan de longueur
<I>n</I><SUB><I>i</I></SUB> fait des <I>n</I><SUB><I>i</I></SUB> vecteurs colonnes des matrices
<I>B</I><SUP>(<I>k</I>)</SUP>(λ <SUB><I>i</I></SUB>)/<I>k</I>! réduites. 
Plus généralement, on obtiendra plus qu’un cycle de Jordan
(et dans ce cas <I>B</I>(λ <SUB><I>i</I></SUB>)= 0).</P><!--TOC subsubsection Exemple 1-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc212">20.7.7</A>  Exemple 1</H4><!--SEC END --><P> <A NAME="sec:ex1"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 3</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>2 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
λ =2 est valeur propre de multiplicité 2, on obtient :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>B</I>(λ )= λ <SUP>2</SUP> <I>I</I> + λ </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> −2</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>−5</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>−3 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
+ </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>−3</TD><TD ALIGN=center NOWRAP>5</TD><TD ALIGN=center NOWRAP>−1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>−2</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>2 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
on applique l’algorithme de Horner :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>B</I>(2)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 1</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">,</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><I>B</I>′(2)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 2</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Comme <I>B</I>(2)≠ 0, on pourrait arrêter les calculs en utilisant
une colonne non nulle et le cycle de Jordan associé
(2,2,1)→ (1,1,0) → (0,0,0) . Expliquons tout
de même l’algorithme général sur cet exemple. La réduction
de <I>B</I>(2) s’obtient en effectuant les manipulations de colonnes
<I>C</I><SUB>2</SUB>+<I>C</I><SUB>1</SUB> → <I>C</I><SUB>2</SUB> et <I>C</I><SUB>3</SUB>−<I>C</I><SUB>1</SUB> → <I>C</I><SUB>3</SUB>. 
On effectue les mêmes opérations sur <I>B</I>′(2) 
et on obtient :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">, </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 2</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−1</TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
L’étape suivante consiste à déplacer vers le bas d’une matrice les
colonnes non nulles de la matrice du haut, on obtient :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−1</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
qui se réduit en :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
on chercherait alors dans les colonnes 2 et 3 de nouveaux cycles (puisque
la colonne 1 a déja été utilisée pour fournir un cycle).</P><!--TOC subsubsection Exemple 2-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc213">20.7.8</A>  Exemple 2</H4><!--SEC END --><P> <A NAME="sec:ex2"></A>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 3</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>−2 </TD></TR>
<TR><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
λ =1 est valeur propre de multiplicité 3.
On trouve :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>B</I>(1)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">, </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><I>B</I>′(1)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>−2 </TD></TR>
<TR><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−1 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">, </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"> <I>B</I>′′(1)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Le processus de réduction commence avec <I>B</I>′(1) en haut de la liste
de matrices, on effectue les opérations élémentaires de
colonne <I>C</I><SUB>2</SUB>−<I>C</I><SUB>1</SUB>→ <I>C</I><SUB>2</SUB>
et <I>C</I><SUB>3</SUB>+<I>C</I><SUB>1</SUB> → <I>C</I><SUB>3</SUB> et on obtient:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">, </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
La première colonne donne le premier cycle de Jordan
(1,0,0) → (2,−1,1).
On déplace les premières colonnes d’une matrice vers le bas :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
qu’on réduit par les opérations 2<I>C</I><SUB>2</SUB> +<I>C</I><SUB>1</SUB> → <I>C</I><SUB>2</SUB> et
2<I>C</I><SUB>3</SUB>−<I>C</I><SUB>1</SUB>→ <I>C</I><SUB>3</SUB> en :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
Puis on effectue <I>C</I><SUB>3</SUB>−<I>C</I><SUB>2</SUB> → <I>C</I><SUB>3</SUB> et la deuxième colonne
nous donne le deuxième cycle de Jordan, réduit ici à un
seul vecteur propre (0,1,1).</P><!--TOC subsubsection Le polynôme minimal par Faddeev-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc214">20.7.9</A>  Le polynôme minimal par Faddeev</H4><!--SEC END --><P>
On vérifie aisément que le degré du facteur 
(λ−λ<SUB><I>i</I></SUB>) dans le polynôme minimal de <I>A</I> est égal
à <I>n</I><SUB><I>i</I></SUB>−<I>k</I> où <I>k</I> est le plus grand entier tel que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">∀ <I>j</I>&lt;<I>k</I>,    <I>B</I><SUP>(<I>j</I>)</SUP>(λ<SUB><I>i</I></SUB>)=0 </TD></TR>
</TABLE><!--TOC subsubsection Formes normales rationnelles-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc215">20.7.10</A>  Formes normales rationnelles</H4><!--SEC END --><P><A NAME="@default261"></A>
On se place ici dans une problématique différente : trouver une matrice
semblable la plus simple possible sans avoir à introduire d’extension
algébrique pour factoriser le polynôme caractéristique.
Quitte à “compléter” plus tard la factorisation et la jordanisation à
partir de la forme simplifiée. Il existe diverses formes associées
à une matrice et plusieurs algorithmes permettant de les relier entre elles,
forme de Smith, de Frobenius, forme normale de Jordan rationnelle.</P><P>On va présenter une méthode directe de calcul d’une forme normale
contenant le maximum de zéros (dont la forme dite normale de Jordan
rationnelle peut se déduire) en utilisant le même algorithme que pour 
la forme
normale de Jordan. Soit <I>Q</I>(λ)=<I>q</I><SUB>0</SUB>+...+<I>q</I><SUB><I>d</I></SUB> λ<SUP><I>d</I></SUP> 
un facteur irréductible
de degré <I>d</I> et de multiplicité <I>q</I> 
du polynôme caractéristique <I>P</I>. Il
s’agit de construire un sous-espace de dimension <I>dq</I> formé de “cycles
de Jordan rationnels”.
On part toujours de la relation 
(λ <I>I</I> −<I>A</I>) ∑<SUB><I>k</I>≤ <I>n</I>−1</SUB> <I>B</I><SUB><I>k</I></SUB> λ<SUP><I>k</I></SUP>=<I>P</I>(λ)<I>I</I>.
On observe que <I>Q</I>(λ)<I>I</I>−<I>Q</I>(<I>A</I>) est divisible par (λ <I>I</I> −<I>A</I>) 
donc il existe une matrice <I>M</I>(λ) telle que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>Q</I>(λ) <I>I</I> −<I>Q</I>(<I>A</I>)) (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>≤ <I>n</I>−1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>B</I><SUB><I>k</I></SUB> λ<SUP><I>k</I></SUP>)
=<I>Q</I>(λ)<SUP><I>q</I></SUP> <I>M</I>(λ) </TD></TR>
</TABLE><P>
On observe aussi que <I>Q</I> a pour coefficient dominant 1 puisqu’il divise
<I>P</I>, on peut donc effectuer des divisions euclidiennes de polynômes
donc de polynômes à coefficients matriciels par <I>Q</I> sans avoir
à diviser des coefficients. Ce qui nous
permet de décomposer <I>B</I>(λ)=∑<SUB><I>k</I>≤ <I>n</I>−1</SUB> <I>B</I><SUB><I>k</I></SUB> λ<SUP><I>k</I></SUP> en 
puissances croissantes de <I>Q</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>B</I>(λ)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>C</I><SUB><I>k</I></SUB>(λ) <I>Q</I>(λ)<SUP><I>k</I></SUP>,    deg(<I>C</I><SUB><I>k</I></SUB>)&lt;<I>q</I> </TD></TR>
</TABLE><P>
On remplace et on écrit que les coefficients des puissances inférieures
à <I>q</I> de <I>Q</I> sont nulles (la <I>k</I>-ième étant non nulle
car <I>M</I>(λ) n’est pas divisible par <I>Q</I> pour les mêmes raisons
que pour la forme normale de Jordan). On a donc les relations :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Q</I>(<I>A</I>)<I>C</I><SUB>0</SUB> = 0,    <I>C</I><SUB><I>k</I></SUB> = <I>Q</I>(<I>A</I>) <I>C</I><SUB><I>k</I>+1</SUB> </TD></TR>
</TABLE><P>
ce qui donne une colonne de matrice 
<I>C</I><SUB><I>q</I>−1</SUB> → <I>C</I><SUB><I>q</I>−2</SUB> ... → <I>C</I><SUB>0</SUB> → 0
qui sont images l’une de l’autre en appliquant <I>Q</I>(<I>A</I>). On peut alors
faire l’algorithme de réduction simultanée sur les colonnes des <I>C</I><SUB><I>j</I></SUB>. 
On observe
ensuite que le nombre de cycles de Jordan de <I>Q</I>(<I>A</I>) de longueur donnée 
est un multiple de <I>d</I>, en effet il suffit de multiplier
un cycle par <I>A</I>, ..., <I>A</I><SUP><I>d</I>−1</SUP> pour créer un autre cycle, de plus ces
cycles forment des familles libres car on a supposé <I>Q</I> irréductible.
On peut donc choisir pour un cycle de longueur <I>k</I> des bases de la forme
(<I>v</I><SUB><I>k</I>−1</SUB>,<I>Av</I><SUB><I>k</I>−1</SUB>...,<I>A</I><SUP><I>d</I>−1</SUP><I>v</I><SUB><I>k</I>−1</SUB>) → ... 
→ (<I>v</I><SUB>0</SUB>,<I>Av</I><SUB>0</SUB>...,<I>A</I><SUP><I>d</I>−1</SUP><I>v</I><SUB>0</SUB>) → (0,...,0) 
où la flèche → désigne l’image par <I>Q</I>(<I>A</I>).
Si on écrit la matrice de <I>A</I> dans la base 
<I>v</I><SUB>0</SUB>,<I>Av</I><SUB>0</SUB>...,<I>A</I><SUP><I>d</I>−1</SUP><I>v</I><SUB>0</SUB>,...,<I>v</I><SUB><I>k</I>−1</SUB>,<I>Av</I><SUB><I>k</I>−1</SUB>...,<I>A</I><SUP><I>d</I>−1</SUP><I>v</I><SUB><I>k</I>−1</SUB>
on obtient un “quasi-bloc de Jordan rationnel” de taille <I>kd</I> 
multiple de <I>d</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>−<I>q</I><SUB>0</SUB></TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>−<I>q</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>−<I>q</I><SUB>2</SUB></TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD></TR>
<TR><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>...</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>−<I>q</I><SUB><I>d</I>−1</SUB></TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>−<I>q</I><SUB>0</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>−<I>q</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>⋮</TD><TD ALIGN=center NOWRAP>...</TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P><B>Exemple</B><BR>
Soit la matrice
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−2</TD><TD ALIGN=center NOWRAP>4</TD><TD ALIGN=center NOWRAP>−2</TD><TD ALIGN=center NOWRAP>5</TD><TD ALIGN=center NOWRAP>−4 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">5</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−7</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−5</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−5</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">5</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>−3 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">9</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−7</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>3</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−7</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>−2</TD><TD ALIGN=center NOWRAP>3</TD><TD ALIGN=center NOWRAP>−1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−3</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">3</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
Son polynôme caractéristique est (<I>x</I>−2)<SUP>2</SUP>(<I>x</I><SUP>2</SUP>−2)<SUP>2</SUP> et on va déterminer
la partie bloc de Jordan rationnel correspondant au facteur irréductible
sur les entiers <I>Q</I>(<I>x</I>)=(<I>x</I><SUP>2</SUP>−2) de multiplicité <I>q</I>=2. 
On calcule <I>B</I>(<I>x</I>) et l’écriture de <I>B</I> comme
somme de puissances de <I>Q</I> (ici avec <CODE>xcas</CODE> en mode <CODE>xcas</CODE>) :
</P><PRE CLASS="verbatim">A:=[[1,-2,4,-2,5,-4],[0,1,5/2,(-7)/2,2,(-5)/2],[1,(-5)/2,2,1/(-2),5/2,-3],
    [0,-1,9/2,(-7)/2,3,(-7)/2],[0,0,2,-2,3,-1],[1,(-3)/2,1/(-2),1,3/2,1/2]];
P:=det(A-x*idn(6));
B:=normal(P*inv(A-x*idn(6))); // preferer un appel a faddeev bien sur!
ecriture(B,Q,q):={
  local j,k,l,n,C,D,E;
  C:=B;
  D:=B;
  E:=NULL;
  n:=coldim(B);
  for (j:=0;j&lt;q;j++){ 
    for (k:=0;k&lt;n;k++){
      for (l:=0;l&lt;n;l++){
        D[k,l]:=rem(C[k,l],Q,x);
        C[k,l]:=quo(C[k,l],Q,x);
      }
    }
    E:=E,D;
  }
  return E;
};
E:=ecriture(B,x^2-2,2);
QA:=A*A-2*idn(6);
</PRE><P>On vérifie bien que <CODE>normal(QA*E(0))</CODE> et
<CODE>normal(QA*E(1))-E(0))</CODE> sont nuls. On sait qu’on a un bloc de
taille 2 de cycles de Jordan de longueur 2, donc il n’est pas nécessaire
de faire des réductions ici, il suffit de prendre une colonne non nulle
de <I>E</I>(0), par exemple la première colonne en <I>x</I>=0
et la colonne correspondante de <I>E</I>(1) et leurs images par <I>A</I>, ici
cela donne (4,24,12,32,8,−4) correspondant à (0,4,−4,8,4,−4),
on calcule les images par <I>A</I>, la matrice de l’endomorphisme
restreint à ce sous-espace est alors le bloc de taille 4 :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>2 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>Cette forme normale minimise le nombre de coefficients non nuls,
mais présente un inconvénient, la partie nilpotente ne commute pas
avec la partie bloc-diagonale, contrairement à la forme normale
rationnelle de Jordan qui contient des blocs identités au-dessus
de la diagonale de blocs.
Pour créer la forme normale rationnelle de Jordan, on doit donc remplacer
les blocs ( </P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>... </TD></TR>
</TABLE><P> )
par des matrices identités. Supposons constitués les <I>j</I> premiers blocs de
taille <I>d</I> numérotés de 0 à <I>j</I>−1 avec comme base de vecteurs
(<I>v</I><SUB>0,0</SUB>,...,<I>v</I><SUB>0,<I>d</I>−1</SUB>,...,<I>v</I><SUB><I>j</I>−1,<I>d</I>−1</SUB>). 
Il s’agit de trouver un vecteur <I>v</I><SUB><I>j</I>,0</SUB> pour commencer le bloc
suivant. On définit alors <I>v</I><SUB><I>j</I>,<I>l</I></SUB> en fonction de <I>v</I><SUB><I>j</I>,<I>l</I>−1</SUB>
en appliquant la relation <I>Av</I><SUB><I>j</I>,<I>l</I>−1</SUB>=<I>v</I><SUB><I>j</I>,<I>l</I></SUB>+<I>v</I><SUB><I>j</I>−1,<I>l</I>−1</SUB>.
Il faut donc chercher <I>v</I><SUB><I>j</I>,0</SUB> tel que 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:jordanrat1"></A>
<I>Av</I><SUB><I>j</I>,<I>d</I>−1</SUB>=−<I>q</I><SUB>0</SUB> <I>v</I><SUB><I>j</I>,0</SUB>−...−<I>q</I><SUB><I>d</I>−1</SUB> <I>v</I><SUB><I>j</I>,<I>d</I>−1</SUB>+<I>v</I><SUB><I>j</I>−1,<I>d</I>−1</SUB> 
    (51)</TD></TR>
</TABLE><P>
En utilisant les relations de récurrence précédentes, on voit que
cela revient à fixer <I>Q</I>(<I>A</I>)<I>v</I><SUB><I>j</I>,0</SUB> en fonction des <I>v</I><SUB><I>j</I>′,<I>l</I></SUB> avec
<I>j</I>′&lt;<I>j</I> (<I>l</I> quelconque). Ce qui est toujours possible en utilisant
la colonne de matrices <I>C</I><SUB><I>j</I>′</SUB> qui s’obtiennent en
fonction des <I>C</I><SUB><I>j</I>′+1</SUB> en appliquant <I>Q</I>(<I>A</I>).</P><P>Plus précisément, calculons les <I>v</I><SUB><I>j</I>,<I>l</I></SUB> en fonction de <I>v</I><SUB><I>j</I>,0</SUB>
et des <I>v</I><SUB><I>j</I>′,<I>l</I>′</SUB> (<I>j</I>′&lt;<I>j</I>). On utilise les coefficients binomiaux 
( <SUB><I>m</I></SUB><SUP><I>l</I></SUP>) calculés par la règle du triangle de Pascal et
on montre par récurrence que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:jordanrat3"></A>
<I>v</I><SUB><I>j</I>,<I>l</I></SUB> = <I>A</I><SUP><I>l</I></SUP> <I>v</I><SUB><I>j</I>,0</SUB> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">inf(<I>l</I>,<I>j</I>)</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell">⎛<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>l</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎠</TD><TD CLASS="dcell"><I>v</I><SUB><I>j</I>−<I>m</I>,<I>l</I>−<I>m</I></SUB>
    (52)</TD></TR>
</TABLE><P>
On remplace dans (<A HREF="#eq:jordanrat1">51</A>) d’où :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUP><I>d</I></SUP> <I>v</I><SUB><I>j</I>,0</SUB> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">inf(<I>d</I>,<I>j</I>)</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell">⎛<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>d</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎠</TD><TD CLASS="dcell"><I>v</I><SUB><I>j</I>−<I>m</I>,<I>l</I>−<I>m</I></SUB>
+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
<I>q</I><SUB><I>l</I></SUB> (<I>A</I><SUP><I>l</I></SUP> <I>v</I><SUB><I>j</I>,0</SUB> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">inf(<I>l</I>,<I>j</I>)</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>l</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎠</TD><TD CLASS="dcell">
<I>v</I><SUB><I>j</I>−<I>m</I>,<I>l</I>−<I>m</I></SUB> )=0
</TD></TR>
</TABLE><P>
finalement :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:jordanrat"></A>
<I>Q</I>(<I>A</I>) <I>v</I><SUB><I>j</I>,0</SUB>= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
<I>q</I><SUB><I>l</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">inf(<I>l</I>,<I>j</I>)</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>l</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎠</TD><TD CLASS="dcell"><I>v</I><SUB><I>j</I>−<I>m</I>,<I>l</I>−<I>m</I></SUB> 
    (53)</TD></TR>
</TABLE><P><B>Application à l’exemple :</B><BR>
Ici <I>v</I><SUB>0,0</SUB>=(4,24,12,32,8,−4) et <I>v</I><SUB>0,1</SUB>=<I>Av</I><SUB><I>j</I>,0</SUB> dont une préimage
par <I>Q</I>(<I>A</I>) est <I>w</I><SUB>1,0</SUB>=(0,4,−4,8,4,−4) et <I>w</I><SUB>1,1</SUB>=<I>Aw</I><SUB>1,0</SUB>.
On applique (<A HREF="#eq:jordanrat">53</A>), comme <I>q</I><SUB>1</SUB>=0 et <I>q</I><SUB>2</SUB>=1
on doit avoir :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Q</I>(<I>A</I>) <I>v</I><SUB>1,0</SUB> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell">
<I>q</I><SUB><I>l</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">inf(<I>l</I>,1)</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>l</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎠</TD><TD CLASS="dcell"><I>v</I><SUB>1−<I>m</I>,<I>l</I>−<I>m</I></SUB> 
=2<I>v</I><SUB>0,1</SUB> </TD></TR>
</TABLE><P>
donc  :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> <I>v</I><SUB>1,0</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=center NOWRAP>2<I>A</I>(0,4,−4,8,4,−4)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=center NOWRAP>(−8,−32,0,−48,−16,16) </TD></TR>
<TR><TD ALIGN=center NOWRAP> <I>v</I><SUB>1,1</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=center NOWRAP><I>Av</I><SUB>1,0</SUB>−<I>v</I><SUB>0,0</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=center NOWRAP>(4,40,−4,64,24,−20) </TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On vérifie bien que <I>Av</I><SUB>1,1</SUB>=2<I>v</I><SUB>1,0</SUB>+<I>v</I><SUB>0,1</SUB>.</P><!--TOC subsubsection Fonctions analytiques-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc216">20.7.11</A>  Fonctions analytiques</H4><!--SEC END --><P>
Soit <I>f</I> une fonction analytique et <I>M</I> une matrice. Pour calculer
<I>f</I>(<I>M</I>), on calcule la forme normale de Jordan de 
<I>M</I>=<I>P</I>(<I>D</I>+<I>N</I>)<I>P</I><SUP>−1</SUP> où <I>D</I>=diag(<I>d</I><SUB>1</SUB>,...,<I>d</I><SUB><I>m</I></SUB>) est diagonale et <I>N</I> nilpotente
d’ordre <I>n</I>. On calcule
aussi le développement de Taylor formel de <I>f</I> en <I>x</I> à l’ordre
<I>n</I>−1, on a alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>N</I>)=<I>P</I> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">diag(<I>f</I><SUP>(<I>j</I>)</SUP>(<I>d</I><SUB>1</SUB>),...,
<I>f</I><SUP>(<I>j</I>)</SUP>(<I>d</I><SUB><I>m</I></SUB>))</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>N</I><SUP><I>j</I></SUP> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><I>P</I><SUP>−1</SUP></TD></TR>
</TABLE><!--TOC subsection Quelques autres algorithmes utiles-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc217">20.8</A>  Quelques autres algorithmes utiles</H3><!--SEC END --><!--TOC subsubsection Complexité asymptotique-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc218">20.8.1</A>  Complexité asymptotique</H4><!--SEC END --><P>
Pour calculer le produit de matrices, on peut utiliser
l’algorithme de <B>Strassen</B>, on présente ici la variante
de <B>Winograd</B><A NAME="@default262"></A><A NAME="@default263"></A>. Soit à calculer :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>a</I><SUB>1,1</SUB></TD><TD ALIGN=center NOWRAP><I>a</I><SUB>1,2</SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>a</I><SUB>2,1</SUB></TD><TD ALIGN=center NOWRAP><I>a</I><SUB>2,2</SUB> </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>b</I><SUB>1,1</SUB></TD><TD ALIGN=center NOWRAP><I>b</I><SUB>1,2</SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>b</I><SUB>2,1</SUB></TD><TD ALIGN=center NOWRAP><I>b</I><SUB>2,2</SUB> </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
=</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>c</I><SUB>1,1</SUB></TD><TD ALIGN=center NOWRAP><I>c</I><SUB>1,2</SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>c</I><SUB>2,1</SUB></TD><TD ALIGN=center NOWRAP><I>c</I><SUB>2,2</SUB> </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
On calcule :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>s</I><SUB>1</SUB>=<I>a</I><SUB>2,1</SUB>+<I>a</I><SUB>2,2</SUB>,    <I>s</I><SUB>2</SUB>=<I>s</I><SUB>1</SUB>−<I>a</I><SUB>1,1</SUB>,    
<I>s</I><SUB>3</SUB>=<I>a</I><SUB>1,1</SUB>− <I>a</I><SUB>2,1</SUB>,    <I>s</I><SUB>4</SUB>=<I>a</I><SUB>1,2</SUB>−<I>s</I><SUB>2</SUB></TD></TR>
<TR><TD ALIGN=right NOWRAP><I>t</I><SUB>1</SUB>=<I>b</I><SUB>1,2</SUB>−<I>b</I><SUB>1,1</SUB>,    <I>t</I><SUB>2</SUB>=<I>b</I><SUB>2,2</SUB>−<I>t</I><SUB>1</SUB>,
   <I>t</I><SUB>3</SUB>=<I>b</I><SUB>2,2</SUB>−<I>b</I><SUB>1,2</SUB>,    <I>t</I><SUB>4</SUB>=<I>b</I><SUB>2,1</SUB>−<I>t</I><SUB>2</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
puis :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>p</I><SUB>1</SUB>=<I>a</I><SUB>1,1</SUB> <I>b</I><SUB>1,1</SUB>,   
<I>p</I><SUB>2</SUB>=<I>a</I><SUB>1,2</SUB><I>b</I><SUB>2,1</SUB>,   
<I>p</I><SUB>3</SUB>=<I>s</I><SUB>1</SUB> <I>t</I><SUB>1</SUB>,    <I>p</I><SUB>4</SUB>=<I>s</I><SUB>2</SUB> <I>t</I><SUB>2</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>p</I><SUB>5</SUB>=<I>s</I><SUB>3</SUB> <I>t</I><SUB>3</SUB>,    <I>p</I><SUB>6</SUB>=<I>s</I><SUB>4</SUB> <I>b</I><SUB>2,2</SUB>,
   <I>p</I><SUB>7</SUB>=<I>a</I><SUB>2,2</SUB> <I>t</I><SUB>4</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>u</I><SUB>1</SUB>= <I>p</I><SUB>1</SUB>+<I>p</I><SUB>2</SUB>    <I>u</I><SUB>2</SUB>=<I>p</I><SUB>1</SUB>+<I>p</I><SUB>4</SUB>,
   <I>u</I><SUB>3</SUB>=<I>u</I><SUB>2</SUB>+<I>p</I><SUB>5</SUB>,    <I>u</I><SUB>4</SUB>=<I>u</I><SUB>3</SUB>+<I>p</I><SUB>7</SUB></TD></TR>
<TR><TD ALIGN=right NOWRAP><I>u</I><SUB>5</SUB>=<I>u</I><SUB>3</SUB>+<I>p</I><SUB>3</SUB>,   
<I>u</I><SUB>6</SUB>=<I>u</I><SUB>2</SUB>+<I>p</I><SUB>3</SUB>,    <I>u</I><SUB>7</SUB>=<I>u</I><SUB>6</SUB>+<I>p</I><SUB>6</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Alors <I>c</I><SUB>1,1</SUB>=<I>u</I><SUB>1</SUB>, <I>c</I><SUB>1,2</SUB>=<I>u</I><SUB>7</SUB>, <I>c</I><SUB>2,1</SUB>=<I>u</I><SUB>4</SUB>, <I>c</I><SUB>2,2</SUB>=<I>u</I><SUB>5</SUB>.<BR>
Cet algorithme utilise 7 multiplications et 15 additions
ce qui économise 1 multiplication et permet en appliquant
récursivement cet algorithme pour des matrices blocs
de réduire la complexité d’un produit de grandes matrices
normalement en <I>O</I>(<I>n</I><SUP>3</SUP>=<I>n</I><SUP>ln(8)/ln(2)</SUP>) à <I>O</I>(<I>n</I><SUP>ln(7)/ln(2)</SUP>) (la preuve
est analogue à celle de la multiplication des polynômes
par l’algorithme de Karatsuba).</P><P>En utilisant une factorisation <I>LU</I> par blocs, on peut montrer
que cette complexité asymptotique se généralise au
calcul de l’inverse. On peut d’ailleurs améliorer l’exposant,
mais la constante non explicitée dans le <I>O</I> augmente aussi.
En pratique, Strassen n’est pas utilisée pour des matrices
de taille plus petites que plusieurs centaines de lignes et colonnes.</P><P>De même on peut gagner sur le calcul du polynôme minimal en
faisant des opérations de multiplication par bloc.</P><!--TOC subsection Quelques méthodes alternatives au pivot-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc219">20.9</A>  Quelques méthodes alternatives au pivot</H3><!--SEC END --><!--TOC subsubsection Factorisation <I>QR</I>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc220">20.9.1</A>  Factorisation <I>QR</I></H4><!--SEC END --><P><A NAME="@default264"></A>
La factorisation <I>QR</I> 
consiste à écrire une matrice <I>A</I> comme produit d’une matrice
orthogonale (ou unitaire dans ℂ) et d’une matrice triangulaire
supérieure. Les matrices orthogonales ayant un conditionnement
de 1 (en norme <I>L</I><SUP>2</SUP>) cette factorisation est numériquement stable.</P><P>Il existe plusieurs algorithmes pour effectuer cette factorisation.
La méthode de Householder utilise des matrices de symétrie
par rapport à un hyperplan.
Pour annuler les coefficients de la première colonne <I>c</I><SUB>1</SUB> de <I>A</I>,
on construit le vecteur <I>u</I>=<I>c</I><SUB>1</SUB> ± ||<I>c</I><SUB>1</SUB>|| <I>e</I><SUB>1</SUB> où <I>e</I><SUB>1</SUB>
est le premier vecteur de base et le signe ± est
le signe de la première composante de <I>c</I><SUB>1</SUB> (pour assurer
la stabilité numérique). On fait alors la symétrie <I>Q</I><SUB>1</SUB> par rapport
à l’hyperplan <I>H</I> orthogonal à <I>u</I>, qui laisse <I>H</I> invariant
et transforme <I>u</I> en −<I>u</I>. Comme <I>u</I> est vecteur directeur
de la bissectrice intérieure ou extérieure de <I>c</I><SUB>1</SUB> et <I>e</I><SUB>1</SUB>, la symétrie
échange ces deux vecteurs, éventuellement au signe près.
La matrice <I>A</I><SUB>1</SUB>=<I>Q</I><SUB>1</SUB><I>A</I> a donc comme première colonne un multiple de
<I>e</I><SUB>1</SUB>, on continue ensuite en faisant le même raisonnement
sur la matrice <I>A</I><SUB>1</SUB> en se limitant et lignes et colonnes d’indice
≥ 2. Après <I>n</I>−1 itérations, on a <I>A</I><SUB><I>n</I>−1</SUB>=<I>Q</I><SUB><I>n</I>−1</SUB>...<I>Q</I><SUB>1</SUB><I>A</I>
qui est triangulaire supérieure d’où la factorisation annoncée.</P><P>Matriciellement, <I>Q</I><SUB>1</SUB>=<I>I</I>−2<I>vv</I><SUP>*</SUP> où <I>v</I>=<I>u</I>/||<I>u</I>||, pour calculer <I>Q</I><SUB>1</SUB><I>A</I>
il faut effectuer <I>A</I>−2<I>vv</I><SUP>*</SUP><I>A</I>, on calcule donc <I>w</I>=<I>v</I><SUP>*</SUP><I>A</I> en <I>n</I><SUP>2</SUP>
opérations (ou une opération est une addition et une
multiplication) puis on soustrait (2<I>v</I>)<SUB><I>i</I></SUB> <I>w</I><SUB><I>j</I></SUB> de <I>a</I><SUB><I>ij</I></SUB> en <I>n</I><SUP>2</SUP>
opérations. En faisant de même aux étapes qui suivent, sans
tenir compte de la simplification progressive du vecteur <I>v</I>, on 
effectue 2<I>n</I><SUP>3</SUP> opérations. La constante 2 peut être 
un peu améliorée en tenant compte des 0 initiaux de <I>v</I> aux
étapes 2 et ultérieures, elle est toutefois supérieure à LU
(et Cholesky), mais en contrepartie
la méthode est très stable numériquement.</P><P><B>Application :</B><BR>
On peut alors écrire <I>Ax</I>=<I>b</I> sous la forme <I>QRx</I>=<I>b</I>
donc <I>Rx</I>=<I>Q</I><SUP>*</SUP><I>b</I> qui est un système triangulaire supérieur,
donc résoudre <I>Ax</I>=<I>b</I> en <I>O</I>(<I>n</I><SUP>2</SUP>) opérations une fois 
la factorisation <I>QR</I> effectuée.
Mais c’est surtout pour résoudre au sens des moindres carrés
un système sur-déterminé que la factorisation <I>QR</I> trouve tout
son intérêt. En effet, minimiser || <I>Ax</I>−<I>b</I> ||<SUB>2</SUB><SUP>2</SUP>,
revient à résoudre <I>A</I><SUP>*</SUP> <I>Ax</I>=<I>A</I><SUP>*</SUP> <I>b</I>, donc <I>R</I><SUP>*</SUP><I>Q</I><SUP>*</SUP><I>QRx</I>=<I>R</I><SUP>*</SUP><I>Q</I><SUP>*</SUP><I>b</I>
soit <I>R</I><SUP>*</SUP><I>Rx</I>=<I>R</I><SUP>*</SUP><I>Q</I><SUP>*</SUP><I>b</I>. Si <I>A</I> est une matrice ayant <I>L</I> lignes et <I>C</I>
colonnes avec <I>L</I> ≥ <I>C</I> et de rang <I>L</I>, alors
les <I>L</I> premières lignes de <I>R</I> forment une matrice <I>R</I><SUB>1</SUB> inversible
et les <I>C</I>−<I>L</I> lignes restantes sont nulles. L’équation précédente
devient <I>R</I><SUB>1</SUB><SUP>*</SUP> <I>R</I><SUB>1</SUB> <I>x</I>=<I>R</I><SUB>1</SUB><SUP>*</SUP> <I>Q</I><SUP>*</SUP> <I>b</I> et se simplifie en <I>R</I><SUB>1</SUB><I>x</I>=<I>Q</I><SUP>*</SUP><I>b</I>,
il vaut mieux résoudre cette équation que <I>A</I><SUP>*</SUP> <I>Ax</I>=<I>A</I><SUP>*</SUP><I>b</I> car
le conditionnement de cette dernière est le carré du conditionnement
de <I>A</I> (le nombre d’opérations est multiplié par une constante
car <I>QR</I> a une constante plus grande que Cholesky, mais le résultat
est plus précis).</P><!--TOC subsubsection Méthodes itératives de
Jacobi, Gauss-Seidel, relaxation-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc221">20.9.2</A>  Méthodes itératives de
Jacobi, Gauss-Seidel, relaxation</H4><!--SEC END --><P><A NAME="@default265"></A> <A NAME="@default266"></A>
<A NAME="sec:jacobi"></A>
Lorsqu’on a une matrice creuse (peu d’éléments non nuls),
l’algorithme du pivot de Gauss a tendance à densifier rapidement
la matrice réduite (surtout avec le pivot partiel où on ne
controle pas le nombre de zéros de la ligne contenant le pivot). Il
peut alors être intéressant d’utiliser des méthodes alternatives
ne faisant intervenir que des produits de matrice, donnant éventuellement
un résultat seulement approché. </P><P>Par exemple pour calculer
l’inverse d’une matrice <I>A</I>=<I>M</I>−<I>N</I>, avec <I>M</I> facile à inverser (par
exemple diagonale) et 
<I>N</I> petit en norme et creuse, on peut écrire :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUP>−1</SUP>=(<I>M</I>−<I>N</I>)<SUP>−1</SUP> =
(<I>M</I>(<I>I</I>−<I>M</I><SUP>−1</SUP><I>N</I>))<SUP>−1</SUP>=(<I>I</I>+<I>M</I><SUP>−1</SUP><I>N</I>+(<I>M</I><SUP>−1</SUP><I>N</I>)<SUP>2</SUP>+...)<I>M</I><SUP>−1</SUP></TD></TR>
</TABLE><P>De même pour résoudre un système linéaire <I>Ax</I>=<I>b</I>
avec <I>A</I>=<I>M</I>−<I>N</I>,
on considère la suite <I>Mx</I><SUB><I>n</I>+1</SUB>−<I>Nx</I><SUB><I>n</I></SUB>=<I>b</I>, donc <I>x</I><SUB><I>n</I>+1</SUB> est obtenu
en résolvant le système :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Mx</I><SUB><I>n</I>+1</SUB>=<I>b</I>+<I>N</I> <I>x</I><SUB><I>n</I></SUB>,    <I>x</I><SUB>0</SUB>=0</TD></TR>
</TABLE><P>
pour laquelle on vérifiera les hypothèses du théorème du point
fixe, il suffit par exemple de vérifier que la plus
grande valeur singulière de <I>M</I><SUP>−1</SUP><I>N</I> est strictement plus petite que 1.
Lorsque la matrice <I>N</I> n’est pas creuse, le procédé est intéressant
pour résoudre approximativement un système si <I>n</I> est grand
et si chaque itération est en <I>O</I>(<I>n</I><SUP>2</SUP>) (ceci veut
dire qu’on ne calcule pas <I>M</I><SUP>−1</SUP> sauf si c’est
évident, par exemple si <I>M</I> est diagonale), 
mais le procédé n’est pas intéressant pour le calcul de
l’inverse de <I>A</I>.</P><P>Notons <I>D</I> la partie diagonale de <I>A</I>,
<I>L</I> sa partie triangulaire inférieure stricte, <I>U</I> sa partie
triangulaire supérieure stricte,
La méthode de Jacobi utilise pour <I>M</I> la
diagonale <I>D</I> de <I>A</I>, alors
que la méthode de Gauss-Seidel prend pour <I>M</I> la partie triangulaire
inférieure <I>D</I>+<I>L</I> de <I>A</I> (diagonale comprise). 
Pour Jacobi, on a donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I><SUB><I>n</I>+1</SUB>=<I>D</I><SUP>−1</SUP>(<I>b</I>+(<I>D</I>−<I>A</I>)<I>x</I><SUB><I>n</I></SUB>)=<I>x</I><SUB><I>n</I></SUB>+<I>D</I><SUP>−1</SUP>(<I>b</I>−<I>Ax</I><SUB><I>n</I></SUB>)</TD></TR>
</TABLE><P>
En Xcas, on peut programmer la méthode par
</P><PRE CLASS="verbatim">jacobi(A,b,N,eps):={
  local D,x0,x1,n,j;
  n:=size(A);
  D:=diag(A).^-1;
  x0:=[0.0$n];
  pour j de 1 jusque N faire
    x1:=b-A*x0;
    si l2norm(x1)&lt;eps alors return x0; fsi;
    x0:=x0+D .*x1;
  fpour;
  return "non convergent";
}:;
</PRE><P>Un cas simple où on a convergence :
</P><DIV CLASS="theorem"><B>Proposition 46</B>  <EM> 
Lorsque la matrice </EM><EM><I>A</I></EM><EM> est
à diagonale strictement dominante, c’est-à-dire que
l’élément diagonal est en valeur absolue strictement supérieur
à la somme des éléments non diagonaux de la même ligne :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>|<I>a</I></EM><SUB><EM><I>ii</I></EM></SUB><EM>| &gt; </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM>&nbsp;</EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><FONT SIZE=6>∑</FONT></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><EM><I>j</I>≠ <I>i</I></EM></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> |<I>a</I></EM><SUB><EM><I>ij</I></EM></SUB><EM>| </EM></TD></TR>
</TABLE><EM>
la méthode de Jacobi converge.
</EM></DIV><P>
En effet, ||<I>M</I><SUP>−1</SUP><I>Nx</I>||<SUB>∞</SUB>&lt; || <I>x</I>||<SUB>∞</SUB> car :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|(<I>Nx</I>)<SUB><I>i</I></SUB>| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> ≠ <I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> |<I>a</I><SUB><I>ij</I></SUB>| |<I>x</I><SUB><I>j</I></SUB>| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> ≠ <I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">
|<I>a</I><SUB><I>ij</I></SUB>| ||<I>x</I>||<SUB>∞</SUB>&lt; |<I>a</I><SUB><I>ii</I></SUB>| || <I>x</I>||<SUB>∞</SUB>    ⇒    |<I>M</I><SUP>−1</SUP>(<I>Nx</I>)<SUB><I>i</I></SUB>| &lt;  || <I>x</I>||<SUB>∞</SUB></TD></TR>
</TABLE><P>
On retrouve ce cas pour une petite perturbation d’une matrice
diagonale, par exemple <BR>
<CODE>A:=2*idn(1000)+1e-4*ranm(1000,1000,uniform,-1,1)</CODE><BR>
<CODE>b:=[1$1000];</CODE><BR>
<CODE>linsolve(A,b);</CODE><BR>
<CODE>jacobi(A,b,50,1e-12)</CODE></P><P>Pour Gauss-Seidel,
le calcul de <I>M</I><SUP>−1</SUP> n’est pas effectué, on résoud
directement le système triangulaire <I>Mx</I><SUB><I>n</I>+1</SUB>=<I>b</I>+<I>Nx</I><SUB><I>n</I></SUB> soit
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>D</I>+<I>L</I>)<I>x</I><SUB><I>n</I>+1</SUB>=<I>b</I>−<I>Ux</I><SUB><I>n</I></SUB></TD></TR>
</TABLE><P> 
Gauss-Seidel
est moins adapté à la parallélisation que Jacobi.
On adapte le programme précédent
</P><PRE CLASS="verbatim">seidel(A,b,N,eps):={
  local L,U,x0,x1,n,j;
  n:=size(A);
  L:=diag(A,left);
  U:=A-L;
  x0:=[0.0$n];
  pour j de 1 jusque N faire
    x1:=b-U*x0;
    x1:=linsolve(L,x1);
    si l2norm(x1-x0)&lt;eps*l2norm(x0) alors return x0; fsi;
    x0:=x1;
  fpour;
  return "non convergent";
}:;
</PRE><P>Dans la méthode de relaxation, on pose pour <I>M</I> la matrice triangulaire
inférieure <I>M</I>=1/ω<I>D</I>+<I>L</I> où ω &gt;0, donc
<I>N</I>=(1/ω−1) <I>D</I>−<I>U</I>
et on utilise la récurrence <I>Mx</I><SUB><I>n</I>+1</SUB>=<I>b</I>+<I>Nx</I><SUB><I>n</I></SUB> donc
<I>Mx</I><SUB><I>n</I>+1</SUB>=<I>b</I>+(<I>M</I>−<I>A</I>)<I>x</I><SUB><I>n</I></SUB> puis
<I>M</I>(<I>x</I><SUB><I>n</I>+1</SUB>−<I>x</I><SUB><I>n</I></SUB>)=<I>b</I>−<I>Ax</I><SUB><I>n</I></SUB> puis
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>D</I>+ω <I>L</I>) (<I>x</I><SUB><I>n</I>+1</SUB>−<I>x</I><SUB><I>n</I></SUB>) = ω(<I>b</I>−<I>Ax</I><SUB><I>n</I></SUB>)</TD></TR>
</TABLE><P>
On remarque que Gauss-Seidel correspond à ω=1.</P><DIV CLASS="theorem"><B>Proposition 47</B>  <EM> (Convergence ): 
si </EM><EM><I>A</I>=<I>M</I>−<I>N</I></EM><EM> est une matrice symétrique définie positive
et si </EM><EM><I>M</I></EM><SUP><EM>*</EM></SUP><EM>+<I>N</I></EM><EM> est définie positive, alors la méthode converge. 
</EM></DIV><P>
On utilise la norme correspondant à
la forme quadratique de matrice <I>A</I> et on calcule la norme subordonnée
de <I>M</I><SUP>−1</SUP><I>N</I>, on a  <I>M</I><SUP>−1</SUP><I>Nx</I>=<I>x</I>−<I>y</I> avec <I>y</I>=<I>M</I><SUP>−1</SUP><I>Ax</I> donc 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>|| <I>M</I><SUP>−1</SUP><I>Nx</I> ||<SUB><I>A</I></SUB><SUP>2</SUP></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>&lt;<I>x</I>−<I>y</I>|<I>A</I> (<I>x</I>−<I>y</I>))&gt; </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>&lt;<I>x</I>|<I>Ax</I>&gt;+&lt;<I>y</I>|<I>Ay</I>&gt;−&lt;<I>y</I>|<I>Ax</I>&gt;−&lt;<I>x</I>|<I>Ay</I>&gt; </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>&lt;<I>x</I>|<I>Ax</I>&gt;+&lt;<I>y</I>|<I>Ay</I>&gt;−&lt;<I>y</I>|<I>My</I>&gt; −&lt;<I>My</I>|<I>y</I>&gt;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>&lt;<I>x</I>|<I>Ax</I>&gt;−&lt;<I>y</I>|(<I>M</I><SUP>*</SUP>+<I>N</I>)<I>y</I>&gt;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&lt;</TD><TD ALIGN=left NOWRAP>&lt;<I>x</I>|<I>Ax</I>&gt;=||<I>x</I>||<SUB><I>A</I></SUB><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Conséquence : si <I>A</I> symétrique définie positive, alors 
Gauss-Seidel converge, car <I>M</I><SUP>*</SUP>+<I>N</I>=<I>D</I>. Pour la relaxation,
on a <I>M</I><SUP>*</SUP>+<I>N</I>=(2/ω −1)<I>D</I> qui est définie positive si ω&lt;2.</P><!--TOC subsubsection Méthode itérative du gradient conjugué-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc222">20.9.3</A>  Méthode itérative du gradient conjugué</H4><!--SEC END --><P><A NAME="@default267"></A>
Il s’agit de résoudre <I>Ax</I>=<I>b</I>, où <I>A</I> est définie positive. 
Si on a une base orthogonale pour le produit scalaire induit par <I>A</I>, 
on peut calculer la <I>j</I>-ième coordonnée de <I>x</I> 
dans cette base en faisant le produit scalaire de 
<I>Ax</I>=<I>b</I> par le <I>j</I>-ième vecteur de la base. 
On construit donc petit à petit une base orthogonale 
{ <I>p</I><SUB>1</SUB>,...,<I>p</I><SUB><I>n</I></SUB> } pour <I>A</I> par un procédé à la Gram-Schmidt, 
mais on ne part pas de la base canonique : 
on construit cette famille orthogonale pour <I>A</I> 
en meme temps qu’on calcule les composantes de <I>x</I>.
Si <I>x</I>=∑<SUB><I>j</I>≥ 1</SUB> α<SUB><I>j</I></SUB> <I>p</I><SUB><I>j</I></SUB>, alors 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&lt;<I>b</I>|<I>p</I><SUB><I>j</I></SUB>&gt;=&lt;<I>Ax</I>|<I>p</I><SUB><I>j</I></SUB>&gt;=α<SUB><I>j</I></SUB> &lt;<I>Ap</I><SUB><I>j</I></SUB>|<I>p</I><SUB><I>j</I></SUB>&gt;</TD></TR>
</TABLE><P>
Posons <I>x</I><SUB><I>i</I></SUB>=∑<SUB><I>j</I>≤ <I>i</I></SUB> α<SUB><I>j</I></SUB> <I>p</I><SUB><I>j</I></SUB>, on a donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&lt;<I>b</I>−<I>Ax</I><SUB><I>i</I></SUB>|<I>p</I><SUB><I>j</I></SUB>&gt;=0  si  <I>j</I>≤ <I>i</I>,    
&lt;<I>b</I>−<I>Ax</I><SUB><I>i</I></SUB>|<I>p</I><SUB><I>j</I></SUB>&gt;=α<SUB><I>j</I></SUB> &lt;<I>Ap</I><SUB><I>j</I></SUB>|<I>p</I><SUB><I>j</I></SUB>&gt;  sinon.</TD></TR>
</TABLE><P>
On peut donc construire <I>x</I><SUB><I>i</I></SUB> comme une suite récurrente de 
la manière suivante : 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
son premier terme est <I>x</I><SUB>0</SUB>=0, 
</LI><LI CLASS="li-itemize">à la <I>i</I>-ième itération, on pose <I>r</I><SUB><I>i</I>+1</SUB>=<I>b</I>−<I>Ax</I><SUB><I>i</I></SUB>, on a donc
&lt;<I>r</I><SUB><I>i</I>+1</SUB>|<I>p</I><SUB><I>j</I></SUB>&gt;=0 si <I>j</I>≤ <I>i</I>.<BR>
Si <I>r</I><SUB><I>i</I>+1</SUB> est combinaison linéaire des <I>p</I><SUB><I>j</I></SUB>, <I>j</I> ≤ <I>i</I>, alors
<I>r</I><SUB><I>i</I>+1</SUB>=0 donc on a terminé : <I>x</I>=<I>x</I><SUB><I>i</I></SUB>.<BR>
Sinon, on complète la famille <I>A</I>-orthogonale par un nouveau vecteur
<I>p</I><SUB><I>i</I>+1</SUB> tel que <I>r</I><SUB><I>i</I>+1</SUB>−<I>p</I><SUB><I>i</I>+1</SUB> soit dans Vect({
<I>p</I><SUB>1</SUB>,...,<I>p</I><SUB><I>i</I></SUB>}) et <I>A</I>-orthogonal.
On calcule la <I>i</I>+1-ième composante de <I>x</I> 
sur la famille orthogonale augmentée :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">α<SUB><I>i</I>+1</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&lt;<I>b</I>|<I>p</I><SUB><I>i</I>+1</SUB>&gt;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">&lt;<I>Ap</I><SUB><I>i</I>+1</SUB>|<I>p</I><SUB><I>i</I>+1</SUB>&gt;</TD></TR>
</TABLE></TD><TD CLASS="dcell">=
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&lt;<I>r</I><SUB><I>i</I>+1</SUB>|<I>r</I><SUB><I>i</I>+1</SUB>&gt;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">&lt;<I>Ap</I><SUB><I>i</I>+1</SUB>|<I>p</I><SUB><I>i</I>+1</SUB>&gt;</TD></TR>
</TABLE></TD></TR>
</TABLE>
Pour obtenir la dernière égalité, on observe que
<I>b</I>=<I>Ax</I><SUB><I>i</I></SUB>+<I>r</I><SUB><I>i</I>+1</SUB> et <I>r</I><SUB><I>i</I>+1</SUB> est orthogonal aux <I>p</I><SUB><I>j</I></SUB>, <I>j</I> ≤ <I>i</I> donc :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&lt;<I>b</I>|<I>p</I><SUB><I>i</I>+1</SUB>&gt;=&lt;<I>Ax</I><SUB><I>i</I></SUB>+<I>r</I><SUB><I>i</I>+1</SUB>|<I>p</I><SUB><I>i</I>+1</SUB>&gt;=&lt;<I>r</I><SUB><I>i</I>+1</SUB>|<I>p</I><SUB><I>i</I>+1</SUB>&gt;=&lt;<I>r</I><SUB><I>i</I>+1</SUB>|<I>r</I><SUB><I>i</I>+1</SUB>&gt;</TD></TR>
</TABLE>
On ajoute enfin la <I>i</I>+1-ième composante à <I>x</I><SUB><I>i</I></SUB> 
pour obtenir <I>x</I><SUB><I>i</I>+1</SUB>=<I>x</I><SUB><I>i</I></SUB>+α<SUB><I>i</I>+1</SUB><I>p</I><SUB><I>i</I>+1</SUB>. 
</LI></UL><P>
On s’arrête en au plus la dimension itérations 
lorsque la famille orthogonale est devenue une base. </P><P>La commande <CODE>conjugate_gradient(A,b)</CODE> de Xcas permet de faire ce
calcul, on peut préciser une valeur initiale de recherche <CODE>x0</CODE>
et une précision <CODE>eps</CODE> en tapant <CODE>conjugate_gradient(A,b,x0,eps)</CODE>.
Voir aussi le menu <TT>Exemple, analyse, gradconj</TT></P><!--TOC subsection Réduction approchée des endomorphismes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc223">20.10</A>  Réduction approchée des endomorphismes</H3><!--SEC END --><P>
On pourrait trouver des valeurs propres approchées d’une matrice
en calculant le polynome caractéristique ou minimal puis en le
factorisant numériquement. Mais cette méthode n’est pas idéale
relativement aux erreurs d’arrondis (calcul du polynome caractéristiaue,
de ses racines, et nouvelle approximation en calculant le noyau
de <I>A</I>−λ <I>I</I>), lorsqu’on veut calculer quelques valeurs propres
on préfère utiliser des méthodes itératives directement sur <I>A</I>
ce qui évite la propagation des erreurs d’arrondi.</P><!--TOC subsubsection Méthode de la puissance-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc224">20.10.1</A>  Méthode de la puissance</H4><!--SEC END --><P> <A NAME="@default268"></A>
Elle permet de déterminer la plus grande valeur propre en valeur absolue
d’une matrice diagonalisable lorsque celle-ci est unique.
Supposons en effet que les valeurs propres de <I>A</I> soient
<I>x</I><SUB>1</SUB>,...,<I>x</I><SUB><I>n</I></SUB> avec |<I>x</I><SUB>1</SUB>| ≤ |<I>x</I><SUB>2</SUB>| ≤ ... ≤ |<I>x</I><SUB><I>n</I>−1</SUB>| &lt; |<I>x</I><SUB><I>n</I></SUB>|
et soient <I>e</I><SUB>1</SUB>,...,<I>e</I><SUB><I>n</I></SUB> une base de vecteurs propres correspondants.
On choisit un vecteur aléatoire <I>v</I> et on calcule la suite
<I>v</I><SUB><I>k</I></SUB>=<I>Av</I><SUB><I>k</I>−1</SUB>=<I>A</I><SUP><I>k</I></SUP> <I>v</I> . Si <I>v</I> a pour coordonnées <I>V</I><SUB>1</SUB>,...,<I>V</I><SUB><I>n</I></SUB>) 
dans la base propre, alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>v</I><SUB><I>k</I></SUB> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>V</I><SUB><I>j</I></SUB> <I>x</I><SUB><I>j</I></SUB><SUP><I>k</I></SUP> <I>e</I><SUB><I>j</I></SUB> 
= <I>x</I><SUB><I>n</I></SUB><SUP><I>k</I></SUP> <I>w</I><SUB><I>k</I></SUB>,    <I>w</I><SUB><I>k</I></SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>V</I><SUB><I>j</I></SUB> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB><I>j</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUB><I>j</I></SUB>
</TD></TR>
</TABLE><P>
L’hypothèse que <I>x</I><SUB><I>n</I></SUB> est l’unique valeur propre
de module maximal entraine alors 
que lim<SUB><I>k</I> → +∞</SUB> <I>w</I><SUB><I>k</I></SUB> = <I>V</I><SUB><I>n</I></SUB> <I>e</I><SUB><I>n</I></SUB> puisque la suite
géométrique de raison <I>x</I><SUB><I>j</I></SUB>/<I>x</I><SUB><I>n</I></SUB> converge vers 0.
Autrement dit, si <I>V</I><SUB><I>n</I></SUB>≠ 0 (ce qui a une probabilité 1 d’être
vrai pour un vecteur aléatoire), 
<I>v</I><SUB><I>k</I></SUB> est équivalent à <I>V</I><SUB><I>n</I></SUB> <I>x</I><SUB><I>n</I></SUB><SUP><I>k</I></SUP> <I>e</I><SUB><I>n</I></SUB>. Lorsque <I>n</I>
est grand, <I>v</I><SUB><I>k</I></SUB> est presque colinéaire au vecteur propre
<I>e</I><SUB><I>n</I></SUB> (que l’on peut estimer par <I>v</I><SUB><I>k</I></SUB> divisé par sa norme), 
ce que l’on détecte en testant si <I>v</I><SUB><I>k</I>+1</SUB> et <I>v</I><SUB><I>k</I></SUB>
sont presques colinéaires. De plus le facteur de colinéarité
entre <I>v</I><SUB><I>k</I>+1</SUB> et <I>v</I><SUB><I>k</I></SUB> est presque <I>x</I><SUB><I>n</I></SUB>, la valeur propre
de module maximal.</P><P>En pratique, pour éviter des débordements d’exposant des
coordonnées des <I>v</I><SUB><I>k</I></SUB> on normalise <I>v</I><SUB><I>k</I></SUB> à chaque
étape, on pose donc <I>w</I><SUB><I>k</I>+1</SUB>=<I>Av</I><SUB><I>k</I></SUB>, <I>v</I><SUB><I>k</I>+1</SUB>=<I>w</I><SUB><I>k</I>+1</SUB>/||<I>w</I><SUB><I>k</I>+1</SUB>|| 
et on estime <I>x</I><SUB><I>n</I></SUB> en calculant λ<SUB><I>k</I></SUB>=(<I>w</I><SUB><I>k</I></SUB>|<I>v</I><SUB><I>k</I></SUB>).</P><P>Lorsque la matrice <I>A</I> est symétrique réelle ou hermitienne
complexe, on peut utiliser comme
test d’arrêt || <I>w</I><SUB><I>k</I></SUB>−λ<SUB><I>k</I></SUB> <I>v</I><SUB><I>k</I></SUB>|| ≤ ε . En effet,
<I>A</I> est alors diagonalisable dans une base orthonormale,
on écrit la relation || (<I>A</I>−λ<SUB><I>k</I></SUB>)<I>v</I><SUB><I>k</I></SUB> || ≤ ε
dans cette base et on obtient qu’il existe une valeur propre de <I>A</I>
à distance inférieure ou égale à ε de
la valeur propre estimée λ<SUB><I>k</I></SUB>. Ce résultat n’est
malheureusement plus vrai si <I>A</I> est quelconque, car deux
vecteurs propres peuvent faire un angle très petit. Par
exemple la matrice 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>0</TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">є</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>1</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
a pour valeurs propres −1 et 1 mais
<I>A</I>(<SUB>1</SUB><SUP>є</SUP>)=(<SUB>0</SUB><SUP>−є</SUP>) donc 0 semble
être une valeur propre approchée. Il vaut alors mieux tester
l’écart entre deux estimations consécutives de la valeur
propre, en effet au premier ordre
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">λ<SUB><I>k</I></SUB>−<I>x</I><SUB><I>n</I></SUB> ≈ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> β<SUB><I>j</I></SUB> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB><I>j</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
où la somme porte sur les indices <I>j</I> des valeurs propres
de module sous-dominant. En général cette somme se
réduit au seul indice <I>j</I>=<I>n</I>−1, et λ<SUB><I>k</I>+1</SUB>−λ<SUB><I>k</I></SUB> se
comporte comme une suite géométrique (de raison <I>x</I><SUB><I>j</I></SUB>/<I>x</I><SUB><I>n</I></SUB>),
on peut alors estimer l’erreur par 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|λ<SUB><I>k</I></SUB>−<I>x</I><SUB><I>n</I></SUB>| ≤ є,   
є ≈<SUB><I>k</I> → +∞</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">|λ<SUB><I>k</I>+1</SUB>−λ<SUB><I>k</I></SUB>|</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">1−|</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">λ<SUB><I>k</I>+2</SUB>−λ<SUB><I>k</I>+1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">λ<SUB><I>k</I>+1</SUB>−λ<SUB><I>k</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">|</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Mais cette estimation n’est plus correcte s’il y a plusieurs indices
<I>j</I> sous-dominants (cas par exemple d’une paire 
de valeurs propres conjuguées
pour une matrice réelle).</P><P>Exercice : tester la convergence de <I>v</I><SUB><I>k</I></SUB>=<I>A</I><SUP><I>k</I></SUP><I>v</I> vers l’espace propre
associé à λ=3 pour la matrice <CODE>[[1,-1],[2,4]]</CODE>
et le vecteur <I>v</I>=(1,0). Attention à ne pas calculer <I>A</I><SUP><I>k</I></SUP> pour
déterminer <I>v</I><SUB><I>k</I></SUB>, utiliser la relation de récurrence!</P><P>Si on n’observe pas de convergence ou si elle est trop lente, alors
|<I>x</I><SUB><I>n</I>−1</SUB>| est proche de |<I>x</I><SUB><I>n</I></SUB>| ou égal, il est judicieux
de faire subir à la matrice un shift, on remplace <I>A</I> par
<I>A</I>−λ <I>I</I>. On peut prendre λ aléatoirement, ou bien
mieux faire des itérations inverses sur <I>A</I>−λ <I>I</I> si λ
est une estimation d’une valeur propre (voir les itérations inverses
ci-dessous).</P><P>Lorsqu’on applique cette méthode a une matrice réelle, il peut arriver
quíl y ait deux valeurs propres conjuguées de module maximal. On
peut appliquer la méthode ci-dessus avec un shift complexe non réel,
mais on doit alors travailler en arithmétique complexe 
ce qui est plus couteux. Le même
type de raisonnement que ci-dessus montre que pour <I>k</I> grand,
<I>v</I><SUB><I>k</I>+2</SUB> est presque colinéaire à l’espace engendré par <I>v</I><SUB><I>k</I></SUB> et <I>v</I><SUB><I>k</I>+1</SUB>, 
la recherche d’une relation  <I>av</I><SUB><I>k</I>+2</SUB>+ <I>b</I> <I>v</I><SUB><I>k</I>+1</SUB> + <I>v</I><SUB><I>k</I></SUB>=0 
permet alors de calculer les valeurs propres qui sont les deux racines
de <I>ax</I><SUP>2</SUP>+<I>bx</I>+1=0.</P><P>La convergence est de type série géométrique, on gagne le même nombre
de décimales à chaque itération. </P><P>Applications : 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
la méthode de la puissance peut donner
une estimation du nombre de condition <I>L</I><SUP>2</SUP> d’une
matrice <I>A</I>. On calcule <I>B</I>=<I>A</I><SUP>*</SUP> <I>A</I> puis on effectue
cette méthode sur <I>B</I> pour avoir une estimation
de la plus grande valeur propre, puis “sur <I>B</I><SUP>−1</SUP>”
par itérations inverses et on fait le rapport des racines carrées.
C’est une méthode intéressante si la matrice
est creuse et symétrique (pour pouvoir faire Cholesky creux
pour les itérations inverses).
</LI><LI CLASS="li-itemize">la méthode de la puissance peut donner une estimation
rapide de la taille de la plus grande racine d’un polynôme (en
module), en itérant sur la matrice companion du polynôme,
matrice qui contient beaucoup de 0, donc le produit avec un vecteur
se fait en temps <I>O</I>(<I>n</I>), où <I>n</I> est le degré du polynôme.
<PRE CLASS="verbatim">f(P,eps,N):={
  local k,l,n,v,old,new,oldratio,tmp;
  l:=coeffs(P);
  n:=degree(P);
  l:=revlist(l[1..n]/l[0]);
  v:=randvector(n,uniform,-1,1);
  oldratio:=inf;
  for k from 1 to N do
    old:=maxnorm(v);
    tmp := -l[0]*v[n-1];
    for j from 1 to n-1 do
      v[j] =&lt; v[j-1]-l[j]*v[n-1];
    od;
    v[0] =&lt; tmp;
    new:=maxnorm(v);
    if (abs(new/old-oldratio)&lt;eps) return new/old;
    oldratio:=new/old;
  od;
  retourne undef;
}:;
</PRE></LI></UL><P>Ceci peut par exemple servir à déterminer pour un polynôme <I>P</I> donné
squarefree (de degré <I>n</I> et coefficient dominant <I>p</I><SUB><I>n</I></SUB>)
l’écart minimal entre 2 racines, on calcule<BR>
<CODE>R:=normal(resultant(P,subst(P,x=x+y),x)/x^degree(P))</CODE><BR>
c’est un polynôme bicarré dont on cherche la plus petite racine
en calculant le carré de la plus grande racine en module
de <CODE>numer(subst(R,y=1/sqrt(x)))</CODE>.</P><P>On peut obtenir un minorant à priori de cette plus petit racine en calculant 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">resultant(<I>P</I>,<I>P</I>′)= 
± <I>p</I><SUB><I>n</I></SUB><SUP>2<I>n</I>−1</SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1 ≤ <I>i</I> &lt; <I>j</I> ≤ <I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>r</I><SUB><I>i</I></SUB>−<I>r</I><SUB><I>j</I></SUB>)<SUP>2</SUP> 
</TD></TR>
</TABLE><P>
on isole l’écart minimal au carré, on majore les autres carrés en
majorant les racines, et
on peut minorer le résultant à priori par 1 si <I>P</I> est à coefficients
entiers.</P><!--TOC subsubsection Itérations inverses-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc225">20.10.2</A>  Itérations inverses</H4><!--SEC END --><P> <A NAME="@default269"></A>
La méthode précédente permet de calculer la valeur propre
de module maximal d’une matrice. Pour trouver une valeur
propre proche d’une quantité donnée <I>x</I>, on peut appliquer
la méthode précédente à la matrice (<I>A</I>−<I>xI</I>)<SUP>−1</SUP> (en pratique
on effectue <I>LU</I> sur <I>A</I>−<I>xI</I> et on résoud (<I>A</I>−<I>xI</I>)<I>u</I><SUB><I>n</I>+1</SUB>=<I>u</I><SUB><I>n</I></SUB>). En effet,
les valeurs propres de cette matrice sont les (<I>x</I><SUB><I>i</I></SUB>−<I>x</I>)<SUP>−1</SUP> dont
la norme est maximale lorsqu’on se rapproche de <I>x</I><SUB><I>i</I></SUB>. Attention
à ne pas prendre <I>x</I> trop proche d’une valeur propre, car le calcul
de (<I>A</I>−<I>xI</I>)<I>u</I><SUB><I>n</I>+1</SUB>=<I>u</I><SUB><I>n</I></SUB> est alors peu précis (la matrice étant
mal conditionnée).</P><!--TOC subsubsection Elimination des valeurs propres trouvées-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc226">20.10.3</A>  Elimination des valeurs propres trouvées</H4><!--SEC END --><P>
Si la matrice <I>A</I> est symétrique, et
si <I>e</I><SUB><I>n</I></SUB> est un vecteur propre normé écrit en colonne, on peut considérer
la matrice <I>B</I>=<I>A</I>−<I>x</I><SUB><I>n</I></SUB> <I>e</I><SUB><I>n</I></SUB> <I>e</I><SUB><I>n</I></SUB><SUP><I>t</I></SUP> qui possède les mêmes valeurs
propres et mêmes vecteurs propres que <I>A</I> avec même multiplicité, 
sauf <I>x</I><SUB><I>n</I></SUB> qui est remplacé par 0. 
En effet les espaces propres de <I>A</I> sont orthogonaux
entre eux, donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Be</I><SUB><I>n</I></SUB>=<I>x</I><SUB><I>n</I></SUB><I>e</I><SUB><I>n</I></SUB> −<I>x</I><SUB><I>n</I></SUB> <I>e</I><SUB><I>n</I></SUB> <I>e</I><SUB><I>n</I></SUB><SUP><I>t</I></SUP> <I>e</I><SUB><I>n</I></SUB> = 0,
<I>Be</I><SUB><I>k</I></SUB> = <I>x</I><SUB><I>k</I></SUB> <I>e</I><SUB><I>k</I></SUB> − <I>x</I><SUB><I>n</I></SUB> <I>e</I><SUB><I>n</I></SUB> <I>e</I><SUB><I>n</I></SUB><SUP><I>t</I></SUP> <I>e</I><SUB><I>k</I></SUB> = <I>x</I><SUB><I>k</I></SUB> <I>e</I><SUB><I>k</I></SUB></TD></TR>
</TABLE><P>
On peut donc calculer
la 2ème valeur propre (en valeur absolue), l’éliminer
et ainsi de suite.</P><P>Si la matrice <I>A</I> n’est pas symétrique, il faut considérer
<I>B</I>=<I>A</I>−<I>x</I><SUB><I>n</I></SUB> <I>e</I><SUB><I>n</I></SUB> <I>f</I><SUB><I>n</I></SUB><SUP><I>t</I></SUP> /<I>e</I><SUB><I>n</I></SUB>.<I>f</I><SUB><I>n</I></SUB> où <I>f</I><SUB><I>n</I></SUB> est vecteur propre
de <I>A</I><SUP><I>t</I></SUP> associé à <I>x</I><SUB><I>n</I></SUB>. En effet <I>f</I><SUB><I>k</I></SUB>.<I>e</I><SUB><I>j</I></SUB>=0 si <I>i</I> ≠ <I>j</I>
car <I>Ae</I><SUB><I>k</I></SUB>.<I>f</I><SUB><I>j</I></SUB>=<I>x</I><SUB><I>k</I></SUB><I>e</I><SUB><I>k</I></SUB>.<I>f</I><SUB><I>j</I></SUB>=<I>e</I><SUB><I>k</I></SUB>.<I>A</I><SUP><I>t</I></SUP><I>f</I><SUB><I>j</I></SUB>=<I>x</I><SUB><I>j</I></SUB><I>e</I><SUB><I>k</I></SUB><I>f</I><SUB><I>j</I></SUB> et donc <I>f</I><SUB><I>k</I></SUB>.<I>e</I><SUB><I>k</I></SUB> ≠ 0
(sinon <I>e</I><SUB><I>k</I></SUB> est dans l’orthogonal de ℝ<SUP><I>n</I></SUP>=Vect(<I>f</I><SUB>1</SUB>,...,<I>f</I><SUB><I>n</I></SUB>).</P><!--TOC subsubsection Décomposition de Schur-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc227">20.10.4</A>  Décomposition de Schur</H4><!--SEC END --><P><A NAME="@default270"></A>
<A NAME="@default271"></A>
Il s’agit d’une factorisation de matrice sous la forme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I> = <I>P</I> <I>S</I> <I>P</I><SUP>−1</SUP></TD></TR>
</TABLE><P>
où <I>P</I> est unitaire et <I>S</I> diagonale supérieure.
Existence (théorique) : 
on prend une valeur propre et un vecteur propre correspondant,
puis on projette sur l’orthogonal de ce vecteur propre et on s’y
restreint, on prend à nouveau une valeur propre et un vecteur propre
correspondant, etc.</P><P>On peut approcher cette factorisation par un algorithme itératif
qui utilise la <B>factorisation </B><B><I>QR</I></B><A NAME="@default272"></A> 
d’une matrice quelconque comme
produit d’une matrice unitaire par une matrice triangulaire supérieure
à coefficients positifs sur la diagonale. On fait l’hypothèse que les
valeurs propres de <I>S</I> sur la diagonale sont classées par ordre de module 
strictement décroissant |λ<SUB>1</SUB>|&gt;|λ<SUB>2</SUB>|&gt;...&gt;|λ<SUB><I>n</I></SUB>| 
(développement inspiré par Peter J. Olver dans le cas symétrique
<CODE>http://www.math.umn.edu/~olver/aims_/qr.pdf</CODE>). On peut toujours
s’y ramener quitte à remplacer <I>A</I> par <I>A</I>− α <I>I</I>.
Posons <I>A</I><SUB>1</SUB>=<I>A</I>, et par récurrence <I>A</I><SUB><I>n</I></SUB>=<I>Q</I><SUB><I>n</I></SUB><I>R</I><SUB><I>n</I></SUB> (avec <I>Q</I><SUB><I>n</I></SUB> unitaire et <I>R</I>
triangulaire supérieure à coefficients diagonaux positifs), 
<I>A</I><SUB><I>n</I>+1</SUB>=<I>R</I><SUB><I>n</I></SUB><I>Q</I><SUB><I>n</I></SUB>. On a alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>A</I><SUP><I>k</I></SUP></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>(<I>Q</I><SUB>1</SUB> <I>R</I><SUB>1</SUB>) (<I>Q</I><SUB>1</SUB> <I>R</I><SUB>1</SUB>) (<I>Q</I><SUB>1</SUB> <I>R</I><SUB>1</SUB>) ... (<I>Q</I><SUB>1</SUB> <I>R</I><SUB>1</SUB>) (<I>Q</I><SUB>1</SUB> <I>R</I><SUB>1</SUB>) </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>Q</I><SUB>1</SUB> (<I>R</I><SUB>1</SUB> <I>Q</I><SUB>1</SUB>) (<I>R</I><SUB>1</SUB> <I>Q</I><SUB>1</SUB>) (<I>R</I><SUB>1</SUB> ... <I>Q</I><SUB>1</SUB>) (<I>R</I><SUB>1</SUB> <I>Q</I><SUB>1</SUB>) <I>R</I><SUB>1</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>Q</I><SUB>1</SUB> (<I>Q</I><SUB>2</SUB> <I>R</I><SUB>2</SUB>) (<I>Q</I><SUB>2</SUB> <I>R</I><SUB>2</SUB>) .. (<I>Q</I><SUB>2</SUB> <I>R</I><SUB>2</SUB>) <I>R</I><SUB>1</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>Q</I><SUB>1</SUB> <I>Q</I><SUB>2</SUB> (<I>R</I><SUB>2</SUB> <I>Q</I><SUB>2</SUB>) <I>R</I><SUB>2</SUB> .. <I>Q</I><SUB>2</SUB> <I>R</I><SUB>2</SUB> <I>R</I><SUB>1</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>Q</I><SUB>1</SUB> <I>Q</I><SUB>2</SUB> (<I>Q</I><SUB>3</SUB> <I>R</I><SUB>3</SUB>) ... <I>Q</I><SUB>3</SUB> <I>R</I><SUB>3</SUB> <I>R</I><SUB>2</SUB> <I>R</I><SUB>1</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>Q</I><SUB>1</SUB> ... <I>Q</I><SUB><I>k</I></SUB> <I>R</I><SUB><I>k</I></SUB> ...<I>R</I><SUB>1</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
D’autre part <I>A</I>=<I>PSP</I><SUP>−1</SUP> donc <I>A</I><SUP><I>k</I></SUP> = <I>P</I> <I>S</I><SUP><I>k</I></SUP> <I>P</I><SUP>−1</SUP>. Soit <I>D</I> la forme diagonale
de <I>S</I> et <I>U</I> la matrice de passage <I>S</I>=<I>UDU</I><SUP>−1</SUP>, où <I>U</I> est triangulaire supérieure
et où on choisit la normalisation des coefficients sur la diagonale de <I>U</I> valant 1.
On a donc 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUP><I>k</I></SUP> = <I>P</I> <I>U</I> <I>D</I><SUP><I>k</I></SUP> <I>U</I><SUP>−1</SUP> <I>P</I><SUP>−1</SUP> </TD></TR>
</TABLE><P>
Ensuite, on suppose
qu’on peut factoriser <I>U</I><SUP>−1</SUP><I>P</I><SUP>−1</SUP>=<I>L</I>Ũ sans permutations, donc
qu’on ne rencontre pas de pivot nul, et quitte à multiplier 
les vecteurs unitaires de <I>P</I><SUP>−1</SUP> par une constante complexe de module 1
on peut supposer que les pivots sont positifs donc que Ũ a
des coefficients positifs sur la diagonale, on a alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUP><I>k</I></SUP> = <I>P</I> <I>U</I> <I>D</I><SUP><I>k</I></SUP> <I>L</I> Ũ = <I>Q</I><SUB>1</SUB> ... <I>Q</I><SUB><I>k</I></SUB> <I>R</I><SUB><I>k</I></SUB> ...<I>R</I><SUB>1</SUB> </TD></TR>
</TABLE><P>
puis en multipliant par Ũ<SUP>−1</SUP> |<I>D</I>|<SUP>−<I>k</I></SUP>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I> <I>U</I> <I>D</I><SUP><I>k</I></SUP> <I>L</I> |<I>D</I>|<SUP>−<I>k</I></SUP> =  <I>Q</I><SUB>1</SUB> ... <I>Q</I><SUB><I>k</I></SUB> <I>R</I><SUB><I>k</I></SUB> ...<I>R</I><SUB>1</SUB> Ũ<SUP>−1</SUP> |<I>D</I>|<SUP>−<I>k</I></SUP> </TD></TR>
</TABLE><P>
où <I>R</I><SUB><I>k</I></SUB> ...<I>R</I><SUB>1</SUB> Ũ<SUP>−1</SUP> |<I>D</I>|<SUP>−<I>k</I></SUP> est triangulaire supérieure à coefficients positifs
sur la diagonale et <I>Q</I><SUB>1</SUB> ... <I>Q</I><SUB><I>k</I></SUB> est unitaire. On regarde ensuite les entrées 
de la matrice <I>D</I><SUP><I>k</I></SUP> <I>L</I> |<I>D</I>|<SUP>−<I>k</I></SUP>, sous la diagonale elles convergent (géométriquement) vers 0,
donc <I>UD</I><SUP><I>k</I></SUP> <I>L</I> |<I>D</I>|<SUP>−<I>k</I></SUP> tend vers une matrice triangulaire supérieure
dont les coefficients diagonaux valent <I>e</I><SUP><I>i</I> <I>k</I>arg(λ<SUB><I>j</I></SUB>)</SUP>. On montre que cela
entraine que <I>Q</I><SUB>1</SUB> ... <I>Q</I><SUB><I>k</I></SUB>  est équivalent à <I>P</I>(<I>D</I>/|<I>D</I>|)<SUP><I>k</I></SUP>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Q</I><SUB>1</SUB> ... <I>Q</I><SUB><I>k</I></SUB> ≈ <I>P</I> (<I>D</I>/|<I>D</I>|)<SUP><I>k</I></SUP>,     
<I>R</I><SUB><I>k</I></SUB> ...<I>R</I><SUB>1</SUB> Ũ<SUP>−1</SUP> |<I>D</I>|<SUP>−<I>k</I></SUP> ≈ (<I>D</I>/|<I>D</I>|)<SUP>−<I>k</I></SUP> <I>UD</I><SUP><I>k</I></SUP> <I>L</I> |<I>D</I>|<SUP>−<I>k</I></SUP> </TD></TR>
</TABLE><P>
Donc, <I>Q</I><SUB><I>k</I></SUB> tend à devenir diagonale, et <I>R</I><SUB><I>k</I></SUB> <I>Q</I><SUB><I>k</I></SUB>=<I>A</I><SUB><I>k</I>+1</SUB> triangulaire supérieure. De plus
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=<I>Q</I><SUB>1</SUB> <I>A</I><SUB>2</SUB> <I>Q</I><SUB>1</SUB><SUP>−1</SUP> = ... = <I>Q</I><SUB>1</SUB> ... <I>Q</I><SUB><I>k</I></SUB> <I>A</I><SUB><I>k</I>+1</SUB> (<I>Q</I><SUB>1</SUB> ... <I>Q</I><SUB><I>k</I></SUB>)<SUP>−1</SUP> </TD></TR>
</TABLE><P>
la matrice <I>A</I><SUB><I>k</I>+1</SUB> est donc semblable à <I>A</I>.</P><P>En pratique, on n’impose pas la positivité des coefficients diagonaux de <I>R</I>
dans la factorisation <I>QR</I>, ce qui ne change
évidemment pas le fait que <I>Q</I><SUB><I>k</I></SUB> s’approche d’une matrice diagonale et <I>A</I><SUB><I>k</I></SUB> d’une matrice
triangulaire supérieure (avec convergence à vitesse géométrique).
On commence aussi par mettre la matrice <I>A</I> sous forme de Hessenberg
(par conjugaison par des matrices de Householder),
c’est-à-dire presque triangulaire supérieure (on autorise des
coefficients non nuls dans la partie inférieure seulement sur la sous-diagonale, 
<I>a</I><SUB><I>ij</I></SUB>=0 si <I>i</I>&gt;<I>j</I>+1). Cela réduit considérablement le temps de calcul de la
décomposition <I>QR</I>, le produit <I>RQ</I> ayant encore cette
propriété, une itération se fait en temps <I>O</I>(<I>n</I><SUP>2</SUP>) au lieu de
<I>O</I>(<I>n</I><SUP>3</SUP>). Le calcul de <I>RQ</I> à partir de <I>A</I> est d’ailleurs fait directement,
on parle d’itération <I>QR</I> implicite.</P><P>On utilise aussi des “shifts” pour accélerer la convergence, c’est-à-dire qu’au lieu
de faire <I>QR</I> et <I>RQ</I> sur la matrice <I>A</I><SUB><I>k</I></SUB> on le fait sur <I>A</I><SUB><I>k</I></SUB> − α<SUB><I>k</I></SUB> <I>I</I> où
λ<SUB><I>k</I></SUB> est choisi pour accélerer la convergence vers 0 du coefficient d’indice
ligne <I>n</I> colonne <I>n</I>−1 (idéalement il faut prendre α<SUB><I>k</I></SUB> proche de λ<SUB><I>n</I></SUB> la
valeur propre de module minimal, afin de minimiser 
|λ<SUB><I>n</I></SUB>−α<SUB><I>k</I></SUB>|/|λ<SUB><I>n</I>−1</SUB>−α<SUB><I>k</I></SUB>|). 
En effet, si <I>A</I><SUB><I>k</I></SUB> − λ<SUB><I>k</I></SUB> <I>I</I> = <I>Q</I><SUB><I>k</I></SUB> <I>R</I><SUB><I>k</I></SUB> et <I>A</I><SUB><I>k</I>+1</SUB>=<I>R</I><SUB><I>k</I></SUB><I>Q</I><SUB><I>k</I></SUB>+λ<SUB><I>k</I></SUB> <I>I</I> alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> (<I>A</I>−α<SUB>1</SUB> <I>I</I>) ... (<I>A</I>−α<SUB><I>k</I></SUB> <I>I</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>Q</I><SUB>1</SUB><I>R</I><SUB>1</SUB>(<I>Q</I><SUB>1</SUB><I>R</I><SUB>1</SUB>−(α<SUB>2</SUB>−α<SUB>1</SUB>)<I>I</I>) ...(<I>Q</I><SUB>1</SUB><I>R</I><SUB>1</SUB>−(α<SUB><I>k</I></SUB>−α<SUB>1</SUB>)<I>I</I>)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>Q</I><SUB>1</SUB> (<I>R</I><SUB>1</SUB><I>Q</I><SUB>1</SUB> − (α<SUB>2</SUB>−α<SUB>1</SUB>)<I>I</I>)<I>R</I><SUB>1</SUB> 
(<I>Q</I><SUB>1</SUB><I>R</I><SUB>1</SUB>−(α<SUB>3</SUB>−α<SUB>1</SUB>)<I>I</I>) ...(<I>Q</I><SUB>1</SUB><I>R</I><SUB>1</SUB>−(α<SUB><I>k</I></SUB>−α<SUB>1</SUB>)<I>I</I>)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>Q</I><SUB>1</SUB> (<I>A</I><SUB>2</SUB> − α<SUB>1</SUB> <I>I</I> −(α<SUB>2</SUB>−α<SUB>1</SUB>)<I>I</I>) <I>R</I><SUB>1</SUB> 
<I>Q</I><SUB>1</SUB>(<I>R</I><SUB>1</SUB><I>Q</I><SUB>1</SUB>−(α<SUB>3</SUB>−α<SUB>1</SUB>)<I>I</I>) <I>R</I><SUB>1</SUB>...(<I>Q</I><SUB>1</SUB><I>R</I><SUB>1</SUB>−(α<SUB><I>k</I></SUB>−α<SUB>1</SUB>)<I>I</I>)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>Q</I><SUB>1</SUB> (<I>A</I><SUB>2</SUB> − α<SUB>2</SUB> <I>I</I>) (<I>A</I><SUB>2</SUB> − α<SUB>3</SUB> <I>I</I>) ... (<I>A</I><SUB>2</SUB> − α<SUB><I>k</I></SUB><I>I</I>) <I>R</I><SUB>1</SUB></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>...</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>Q</I><SUB>1</SUB> ... <I>Q</I><SUB><I>k</I></SUB> <I>R</I><SUB><I>k</I></SUB> ...<I>R</I><SUB>1</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On peut aussi éliminer la dernière
ligne et la dernière colonne de la matrice pour accélerer les calculs dès que le coefficient
en ligne <I>n</I> colonne <I>n</I>−1 est suffisamment petit.</P><P>On remarque que pour une matrice réelle si on choisit des shifts conjugués,
alors <I>Q</I><SUB>1</SUB>...<I>Q</I><SUB><I>k</I></SUB> <I>R</I><SUB><I>k</I></SUB>...<I>R</I><SUB>1</SUB> est réel. Or si <I>QR</I>=<SPAN style="text-decoration:overline"><I>Q</I></SPAN><SPAN style="text-decoration:overline"><I>R</I></SPAN>
et si <I>R</I> est inversible
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>Q</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP>−1</SUP> <I>Q</I> = </TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>R</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>R</I><SUP>−1</SUP> </TD></TR>
</TABLE><P>
On a donc une matrice symétrique (car <SPAN style="text-decoration:overline"><I>Q</I></SPAN><SUP>−1</SUP>=<I>Q</I><SUP><I>t</I></SUP>) 
et triangulaire supérieure. On en déduit que
<SPAN style="text-decoration:overline"><I>Q</I></SPAN><SUP>−1</SUP> <I>Q</I>=<I>D</I> est diagonale, donc <I>Q</I>=<SPAN style="text-decoration:overline"><I>Q</I></SPAN> <I>D</I>. On peut
donc rendre <I>Q</I> réelle en divisant chaque colonne par un <I>e</I><SUP><I>i</I>θ</SUP>, et
rendre <I>R</I> réelle en conjuguant par la matrice <I>D</I>.
Mais ce procédé de retour au réel après élimination de 2 valeurs propres
complexes conjuguées d’une matrice réelle
se heurte à un problème de conditionnement parce que le choix d’un shift
intéressant pour la convergence va rendre la matrice <I>R</I> proche d’une matrice non
inversible (les deux derniers coefficients diagonaux de <I>R</I> sont proches de 0).
On a alors seulement
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>Q</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP>−1</SUP> <I>Q</I> <I>R</I> = </TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>R</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
Si on décompose <SPAN style="text-decoration:overline"><I>Q</I></SPAN><SUP>−1</SUP> <I>Q</I>, <I>R</I>, <SPAN style="text-decoration:overline"><I>R</I></SPAN> par blocs 
<I>n</I>−2,<I>n</I>−2, <I>n</I>−2,2, 2,<I>n</I>−2 et 2,2, on a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>QQ</I><SUB>11</SUB></TD><TD ALIGN=center NOWRAP><I>QQ</I><SUB>12</SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>QQ</I><SUB>21</SUB></TD><TD ALIGN=center NOWRAP><I>QQ</I><SUB>22</SUB> </TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>R</I><SUB>11</SUB></TD><TD ALIGN=center NOWRAP><I>R</I><SUB>12</SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>R</I><SUB>22</SUB> </TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>QQ</I><SUB>11</SUB> <I>R</I><SUB>11</SUB></TD><TD ALIGN=center NOWRAP><I>QQ</I><SUB>21</SUB><I>R</I><SUB>11</SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>QQ</I><SUB>11</SUB> <I>R</I><SUB>12</SUB> + <I>QQ</I><SUB>12</SUB> <I>R</I><SUB>22</SUB></TD><TD ALIGN=center NOWRAP><I>QQ</I><SUB>21</SUB> <I>R</I><SUB>12</SUB> + <I>QQ</I><SUB>22</SUB> <I>R</I><SUB>22</SUB> </TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>R</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUB>11</SUB></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>R</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUB>12</SUB> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>R</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUB>22</SUB> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Donc on a <I>QQ</I><SUB>11</SUB> =<SPAN style="text-decoration:overline"><I>R</I></SPAN><SUB>11</SUB> <I>R</I><SUB>11</SUB><SUP>−1</SUP>.
Comme <I>Q</I> est unitaire, <I>QQ</I>=<SPAN style="text-decoration:overline"><I>Q</I></SPAN><SUP>−1</SUP> <I>Q</I>=<I>Q</I><SUP><I>t</I></SUP>   <I>Q</I> est symétrique, donc
<I>QQ</I><SUB>11</SUB> est diagonale puisque symétrique et triangulaire supérieure. On peut donc
ramener <I>Q</I><SUB>11</SUB> et <I>R</I><SUB>11</SUB> en des matrices réelles.
L’algorihtme des itérations <I>QR</I> implicites traite de manière
efficace le cas des
couples de valeurs propres complexes conjuguées ou plus
généralement de clusters de valeurs propres, c’est l’algorithme
de Francis (aussi appelé <EM>bulge chasing</EM> en anglais, qu’on
pourrait traduire par “à la poursuite du bourrelet”, cela vient
de la forme que prend la matrice après application d’un shift,
elle a des entrées non nulles en première colonne plus bas
que la sous-diagonale qui forment un bourrelet non nul, 
l’annulation de ces entrées par des transformations de Householder
déplace le bourrelet sur la colonne suivante).</P><P>Revenons à la localisation des valeurs propres 
On suppose qu’on a maintenant une matrice
unitaire <I>P</I> et une matrice triangulaire supérieure <I>S</I>
(aux erreurs d’arrondi près) telles que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUP>−1</SUP> <I>A</I> <I>P</I> = <I>S</I> </TD></TR>
</TABLE><P>
Que peut-on en déduire ?
<SUP><A NAME="text29" HREF="#note29">29</A></SUP>
On va d’abord arrondir <I>P</I> en une matrice exacte à coefficients rationnels, dont les dénominateurs
sont une puissance de 2 (en fait c’est exactement ce que donne l’écriture d’un flottant
en base 2, une fois ramené tous les exposants à la même valeur). On a donc une matrice
<I>P</I><SUB><I>e</I></SUB> presque unitaire exacte et telle que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>S</I><SUB><I>e</I></SUB> = <I>P</I><SUB><I>e</I></SUB><SUP>−1</SUP> <I>A</I> <I>P</I><SUB><I>e</I></SUB>  </TD></TR>
</TABLE><P>
est semblable à <I>A</I>, et presque triangulaire supérieure.
(comme <I>P</I><SUB><I>e</I></SUB> est presque unitaire, sa norme et la norme de son inverse
sont proches de 1 donc <I>S</I><SUB><I>e</I></SUB> est proche de <I>S</I>, les coefficients de <I>S</I><SUB><I>e</I></SUB>
sont de la même taille que les coefficients de <I>A</I> : le changement de base est bien
conditionné et c’est la raison pour laquelle on a choisi d’effectuer des 
transformations unitaires). </P><P>Notons µ<SUB>1</SUB>, ..., µ<SUB><I>n</I></SUB> les coefficients
diagonaux de <I>S</I><SUB><I>e</I></SUB>, soit ε un majorant de la norme des coefficients
sous-diagonaux de <I>S</I><SUB><I>e</I></SUB>, et soit δ un minorant de l’écart entre 2 µ<SUB><I>j</I></SUB> distincts.
On a donc <I>S</I><SUB><I>e</I></SUB>=<I>U</I>+<I>E</I> où <I>U</I> est triangulaire supérieure, <I>E</I> est triangulaire inférieure
avec des 0 sous la diagonale et des coefficients de module majorés par ε.
Si ε est suffisamment petit devant δ, on va montrer qu’on peut
localiser les valeurs propres de <I>S</I><SUB><I>e</I></SUB> (qui sont celles de <I>A</I>) au moyen des µ<SUB><I>j</I></SUB>.</P><P>En effet, fixons <I>j</I> et soit <I>C</I> un cercle de centre µ=µ<SUB><I>j</I></SUB> et de rayon 
α ≤ δ/2. 
Si <I>A</I> est une matrice diagonalisable, on sait que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">nombre de valeurs propres ∈ <I>C</I> =  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>i</I>π</TD></TR>
</TABLE></TD><TD CLASS="dcell">  trace </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>C</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>A</I>−<I>zI</I>)<SUP>−1</SUP> </TD></TR>
</TABLE><P>
En prenant <I>A</I>=<I>S</I><SUB><I>e</I></SUB>, et en écrivant
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>S</I><SUB><I>e</I></SUB>−<I>zI</I>)<SUP>−1</SUP> = (<I>U</I>−<I>zI</I>+<I>E</I>)<SUP>−1</SUP> = ( <I>I</I> + (<I>U</I>−<I>zI</I>)<SUP>−1</SUP><I>E</I>)<SUP>−1</SUP>(<I>U</I>−<I>zI</I>)<SUP>−1</SUP>  </TD></TR>
</TABLE><P>
on développe le second terme si la norme de (<I>U</I>−<I>zI</I>)<SUP>−1</SUP><I>E</I> est strictement inférieure à 1
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>S</I><SUB><I>e</I></SUB>−<I>zI</I>)<SUP>−1</SUP> = (<I>U</I>−<I>zI</I>)<SUP>−1</SUP> −(<I>U</I>−<I>zI</I>)<SUP>−1</SUP><I>E</I>(<I>U</I>−<I>zI</I>)<SUP>−1</SUP> + (<I>U</I>−<I>zI</I>)<SUP>−1</SUP><I>E</I>(<I>U</I>−<I>zI</I>)<SUP>−1</SUP><I>E</I>(<I>U</I>−<I>zI</I>)<SUP>−1</SUP> + ...</TD></TR>
</TABLE><P>
puis on calcule la trace
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">trace(<I>S</I><SUB><I>e</I></SUB>−<I>zI</I>)<SUP>−1</SUP> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (µ<SUB><I>j</I></SUB>−<I>z</I>)<SUP>−1</SUP> + η </TD></TR>
</TABLE><P>
avec
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|η| ≤ 2π α || (<I>U</I>−<I>zI</I>)<SUP>−1</SUP> || </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">|| (<I>U</I>−<I>zI</I>)<SUP>−1</SUP><I>E</I> ||</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1−|| (<I>U</I>−<I>zI</I>)<SUP>−1</SUP><I>E</I> ||</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Au final, le nombre de valeurs propres dans <I>C</I> est donné par
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">1 + η,    |η| ≤ 
α max<SUB><I>z</I> ∈ <I>C</I></SUB> || (<I>U</I>−<I>zI</I>)<SUP>−1</SUP> || </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">|| (<I>U</I>−<I>zI</I>)<SUP>−1</SUP><I>E</I> ||</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1−|| (<I>U</I>−<I>zI</I>)<SUP>−1</SUP><I>E</I> ||</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
Il suffit donc que le max soit plus petit que 1 pour avoir l’existence d’une valeur
propre et une seule de <I>S</I><SUB><I>e</I></SUB> dans le cercle <I>C</I> (à distance au plus α de µ).
Ce sera le cas si
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ε ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">δ</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2 ||<I>S</I><SUB><I>e</I></SUB>||</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>n</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">α</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>n</I>−1</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
on choisit donc α pour réaliser l’égalité ci-dessus,
sous réserve que δ ne soit pas trop petit, rappelons que α doit être
plus petit ou égal à δ/2. Si δ est petit, il peut être nécessaire
d’utiliser une précision plus grande pour les calculs de la décomposition de Schur
en arithmétique flottante.</P><P>Typiquement, on peut espérer (pour un écart δ pas trop petit) pouvoir
localiser les racines d’un polynôme de degré <I>n</I> par cette méthode avec précision
<I>b</I> bits en <I>O</I>(<I>n</I><SUP>3</SUP> <I>b</I><SUP>2</SUP> + <I>n</I><SUP>2</SUP> <I>b</I><SUP>3</SUP>) opérations pour le calcul de la décomposition
de Schur en flottant (<I>n</I><SUP>3</SUP><I>b</I><SUP>2</SUP> pour Hessenberg initial puis <I>n</I><SUP>2</SUP><I>b</I><SUP>2</SUP> par itération
et un nombre d’itérations proportionnel à <I>b</I>). 
Pour le calcul exact de <I>S</I><SUB><I>e</I></SUB>, il faut inverser une matrice
de taille <I>n</I> avec des coefficients de taille proportionnelle à <I>b</I> donc <I>O</I>(<I>n</I><SUP>4</SUP><I>b</I>ln(<I>n</I>))
opérations (en modulaire, la taille des coefficients de l’inverse est <I>O</I>(<I>nb</I> ln(<I>n</I>)))
puis calculer un produit avec une matrice <I>n</I>,<I>n</I> de coefficients de taille
proportionnelle à <I>b</I>, soit <I>O</I>(<I>n</I><SUP>4</SUP><I>b</I><SUP>2</SUP>ln(<I>nb</I>)) opérations. Asymptotiquement,
on peut faire mieux avec des méthodes de multiplication et d’opérations matricielles
par blocs. Pour éviter la perte d’un facteur <I>n</I>, 
on peut aussi ne pas faire de calculs en mode exact et controler
les erreurs sur la matrice <I>S</I>.
On peut regrouper les valeurs propres par “clusters” si elles sont trop
proches à la précision de <I>b</I> bits. Pour la recherche des racines
d’un polynôme <I>P</I>, on peut montrer, en calculant le résultant de <I>P</I>
et de <I>P</I>′ qui est en module plus grand ou égal à 1, et en l’écrivant
comme produit des carrés de différences des racines, et en majorant toutes
les différences de racine sauf une à l’aide de la norme infinie
de <I>P</I>, qu’il faut au pire <I>b</I>=<I>O</I>(<I>n</I>) bits pour séparer les racines).</P><!--TOC subsection Quelques références-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc228">20.11</A>  Quelques références</H3><!--SEC END --><P> <A NAME="sec:ref"></A></P><UL CLASS="itemize"><LI CLASS="li-itemize">
Comme toujours on renvoie à l’excellent livre de Henri Cohen:
A Course in Computational Algebraic Number Theory</LI><LI CLASS="li-itemize">Gantmacher: Théorie des matrices</LI><LI CLASS="li-itemize">Press et al.: Numerical recipies in Fortran/C/Pascal.<BR>
Pour des algorithmes numériques (sur les matrices et autres).</LI></UL><!--TOC subsection Exercices (algèbre linéaire)-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc229">20.12</A>  Exercices (algèbre linéaire)</H3><!--SEC END --><!--TOC subsubsection Instructions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc230">20.12.1</A>  Instructions</H4><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
Les commandes d’algèbre linéaire de Xcas sont
regroupées dans le menu <TT>Cmds-&gt;Alglin</TT>.
En maple V, la commande <TT>?linalg</TT> affiche
la liste des commandes d’algèbre linéaire. 
</LI><LI CLASS="li-itemize">En maple V il est conseillé d’exécuter <TT>with(linalg);</TT>,
sinon il faut précéder
chaque commande de <TT>linalg::</TT>.
Attention
il faut utiliser le caractère <TT>&amp;</TT> avant la multiplication
et il faut souvent utiliser <TT>evalm</TT> dans les programmes
utilisant des matrices et vecteurs. Notez aussi que les
matrices sont toujours passées par référence en maple V,
en Xcas le choix revient à l’utilisateur (affectation par <CODE>:=</CODE>
par valeur ou par <CODE>=&lt;</CODE> par référence)
</LI><LI CLASS="li-itemize">Pour travailler avec des
coefficients modulaires, en Xcas
on fait suivre les coefficients ou matrices de <TT>% n</TT>
(utiliser <CODE>% 0</CODE> pour enlever les modulos),
en maple V, on utilise les noms de commandes
avec une majuscule (forme inerte) suivi de <TT>mod n</TT>.
</LI></UL><!--TOC subsubsection Exercices-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc231">20.12.2</A>  Exercices</H4><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
En utilisant un logiciel de calcul formel,
comparez le temps de calcul d’un déterminant de matrice
aléatoire à coefficients entiers de tailles 50 et 100, 
d’une matrice de taille 6 et 12 avec comme coefficients symboliques
ligne <I>j</I> colonne <I>k</I>, <I>x</I><SUB><I>j</I>+<I>k</I></SUB> lorsque <I>j</I>+<I>k</I> est pair
et 0 sinon. Peut-on en déduire une indication sur l’algorithme
utilisé?
</LI><LI CLASS="li-enumerate">Écrire un programme calculant la borne de Hadamard d’un
déterminant à coefficients réels (rappel : c’est la borne obtenue en faisant
le produit des normes euclidiennes des vecteurs colonnes).
</LI><LI CLASS="li-enumerate">Créez une matrice 4x4 aléatoire avec des coefficients entiers
compris entre -100 et 100, calculer la borne de Hadamard de son déterminant
avec le programme précédent, calculer ce déterminant modulo
quelques nombres premiers choisis en fonction de la borne de Hadamard
et vérifiez le résultat de la reconstruction modulaire du déterminant.
</LI><LI CLASS="li-enumerate">Créez une matrice 100x100 aléatoire à coefficients entiers
et calculez son déterminant
modulo quelques nombres premiers. Dans quels cas peut-on
conclure que la matrice est inversible dans ℝ? dans ℤ?
</LI><LI CLASS="li-enumerate">Écrire un programme calculant par interpolation de Lagrange
le polynôme caractéristique d’une matrice (en donnant à λ
de det(λ <I>I</I> −<I>A</I>), <I>n</I>+1 valeurs distinctes).
</LI><LI CLASS="li-enumerate">(Long) Écrire un programme qui calcule un déterminant de matrice
en calculant les mineurs 2x2 puis 3x3 etc. (méthode de Laplace)
</LI><LI CLASS="li-enumerate">Recherche du polynôme minimal. On prend un vecteur aléatoire
à coefficients entiers et on calcule <I>v</I>, <I>Av</I>, ..., <I>A</I><SUP><I>n</I></SUP><I>v</I> puis
on cherche une relation linéaire minimale entre ces vecteurs, en
calculant le noyau de la matrice ayant ces vecteurs colonnes. Si le
noyau est de dimension 1, alors le polynôme minimal est égal au
polynome caractéristique et correspond à un vecteur de la base du noyau.
Sinon, il faut choisir un vecteur du noyau correspondant au degré
le plus petit possible puis faire le PPCM avec les polynomes obtenurs
avec d’autres vecteurs pour obtenir le polynôme minimal avec une grande
probabilité.
Essayez avec la matrice <I>A</I> de taille 3 ayant des 0 sur la diagonale et 
des 1 ailleurs.
Écrire un programme mettant en oeuvre cette recherche, testez-le avec
une matrice aléatoire de taille 30.
</LI><LI CLASS="li-enumerate">Testez l’algorithme méthode de Fadeev pour la matrice <I>A</I> ci-dessus.
Même question pour 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 3</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>2 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">,    
<I>A</I>=</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 3</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>−2 </TD></TR>
<TR><TD ALIGN=center NOWRAP>−1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE>
</LI><LI CLASS="li-enumerate">Écrire un programme calculant par une méthode itérative
la valeur propre de module maximal d’une matrice à coefficients
complexes. Dans le cas réel, modifier le programme pour pouvoir
traiter le cas d’un couple de complexes conjugués de module maximal.
Dans le cas hermitien ou réel symétrique, éliminer le couple valeur
propre/vecteur propre et continuer la diagonalisation numérique.
</LI><LI CLASS="li-enumerate">Soient |<I>a</I>|,|<I>b</I>|&lt;√<SPAN style="text-decoration:overline"><I>n</I>/2</SPAN>
Écrire une fonction ayant comme arguments <I>a</I>/<I>b</I> (mod <I>n</I> ) 
qui calcule <I>a</I> et <I>b</I>.<BR>
Utiliser ce programme pour résoudre un système 4,4 à coefficients entiers
par une méthode <I>p</I>-adique.
</LI></OL><!--TOC section Approximation polynomiale-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc232">21</A>  Approximation polynomiale</H2><!--SEC END --><P> <A NAME="sec:interp"></A>
On présente dans cette section quelques méthodes d’approximation
de fonctions par des polynômes sur un intervalle, la section suivante 
présente des méthodes d’approximation près d’un point ou de l’infini.</P><!--TOC subsection Polynôme de Lagrange-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc233">21.1</A>  Polynôme de Lagrange</H3><!--SEC END --><P><A NAME="@default273"></A> <A NAME="@default274"></A>
Étant donné la facilité de manipulation qu’apportent les
polynomes, on peut chercher à approcher une fonction par un
polynôme. La méthode la plus naturelle consiste à chercher
un polynôme de degré le plus petit possible
égal à la fonction en certains points <I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>n</I></SUB>
et à trouver une majoration de la différence entre la fonction
et le polynôme.
Le polynome interpolateur de Lagrange répond à cette question.</P><!--TOC subsubsection Existence et unicité-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc234">21.1.1</A>  Existence et unicité</H4><!--SEC END --><P>
Soit donc <I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>n</I></SUB> des réels distincts et <I>y</I><SUB>0</SUB>,...,<I>y</I><SUB><I>n</I></SUB>
les valeurs de la fonction à approcher en ces points (on posera
<I>y</I><SUB><I>j</I></SUB>=<I>f</I>(<I>x</I><SUB><I>j</I></SUB>) pour approcher la fonction <I>f</I>). On cherche
donc <I>P</I> tel que <I>P</I>(<I>x</I><SUB><I>j</I></SUB>)=<I>y</I><SUB><I>i</I></SUB> pour <I>j</I> ∈ [0,<I>n</I>].</P><P>Commencons par voir s’il y a beaucoup de solutions. Soit <I>P</I> et <I>Q</I>
deux solutions distinctes du problème, alors <I>P</I>−<I>Q</I> est non nul
et va s’annuler en <I>x</I><SUB>0</SUB>, ...,<I>x</I><SUB><I>n</I></SUB> donc possède <I>n</I>+1 racines donc
est de degré <I>n</I>+1 au moins. Réciproquement, si on ajoute
à <I>P</I> un multiple du polynome <I>A</I>=∏<SUB><I>j</I>=0</SUB><SUP><I>n</I></SUP> (<I>X</I>−<I>x</I><SUB><I>j</I></SUB>), on obtient
une autre solution. Toutes les solutions se déduisent donc
d’une solution particulière en y ajoutant un polynome de degré
au moins <I>n</I>+1 multiple de <I>A</I>. </P><P>Nous allons maintenant construire
une solution particulière de degré au plus <I>n</I>.
Si <I>n</I>=0, on prend <I>P</I>=<I>x</I><SUB>0</SUB> constant. On procède ensuite par
récurrence. Pour construire le polynôme correspondant
à <I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>n</I>+1</SUB> on part du polynoôme <I>P</I><SUB><I>n</I></SUB> correspondant à
<I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>n</I></SUB> et on lui ajoute un multiple réel de <I>A</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB><I>n</I>+1</SUB>=<I>P</I><SUB><I>n</I></SUB>+ α<SUB><I>n</I>+1</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>X</I>−<I>x</I><SUB><I>j</I></SUB>) </TD></TR>
</TABLE><P>
Ainsi on a toujours <I>P</I><SUB><I>n</I>+1</SUB>(<I>x</I><SUB><I>j</I></SUB>)=<I>y</I><SUB><I>j</I></SUB> pour <I>j</I>=0,..<I>n</I>, on calcule
maintenant  α<SUB><I>n</I>+1</SUB> pour que <I>P</I><SUB><I>n</I>+1</SUB>(<I>x</I><SUB><I>n</I>+1</SUB>)=<I>y</I><SUB><I>n</I>+1</SUB>.
En remplacant avec l’expression de <I>P</I><SUB><I>n</I>+1</SUB> ci-dessus, on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB><I>n</I></SUB>(<I>x</I><SUB><I>n</I>+1</SUB>)+  α<SUB><I>n</I>+1</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>x</I><SUB><I>n</I>+1</SUB>−<I>x</I><SUB><I>j</I></SUB>) = <I>y</I><SUB><I>n</I>+1</SUB> </TD></TR>
</TABLE><P>
Comme tous les <I>x</I><SUB><I>j</I></SUB> sont distincts, il existe une solution unique :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">α<SUB><I>n</I>+1</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I><SUB><I>n</I>+1</SUB>−<I>P</I><SUB><I>n</I></SUB>(<I>x</I><SUB><I>n</I>+1</SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>x</I><SUB><I>n</I>+1</SUB>−<I>x</I><SUB><I>j</I></SUB>)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>On a donc prouvé le :
</P><DIV CLASS="theorem"><B>Théorème 48</B>  <EM> </EM><A NAME="@default275"></A><EM> </EM><A NAME="@default276"></A><EM>
Soit </EM><EM><I>n</I>+1</EM><EM> réels distincts </EM><EM><I>x</I></EM><SUB><EM>0</EM></SUB><EM>,...,<I>x</I></EM><SUB><EM><I>n</I></EM></SUB><EM> et </EM><EM><I>n</I>+1</EM><EM>
réels quelconques </EM><EM><I>y</I></EM><SUB><EM>0</EM></SUB><EM>,...,<I>y</I></EM><SUB><EM><I>n</I></EM></SUB><EM>.
Il existe un unique polynôme </EM><EM><I>P</I></EM><EM> de degré inférieur ou égal à
</EM><EM><I>n</I></EM><EM>, appelé polynome de Lagrange, tel que :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><I>P</I>(<I>x</I></EM><SUB><EM><I>i</I></EM></SUB><EM>)=<I>y</I></EM><SUB><EM><I>i</I></EM></SUB></TD></TR>
</TABLE><EM>
</EM></DIV><P>Exemple : déterminons le polynome de degré inférieur ou égal
à 2 tel que <I>P</I>(0)=1, <I>P</I>(1)=2, <I>P</I>(2)=1. On commence par <I>P</I><SUB>0</SUB>=1.
Puis on pose <I>P</I><SUB>1</SUB>=<I>P</I><SUB>0</SUB>+ α<SUB>1</SUB><I>X</I>=1+ α<SUB>1</SUB><I>X</I>. 
Comme <I>P</I>(1)=2=1+ α<SUB>1</SUB> on en tire  α<SUB>1</SUB>=1
donc <I>P</I><SUB>1</SUB>=1+<I>X</I>. Puis on pose <I>P</I><SUB>2</SUB>=<I>P</I><SUB>1</SUB>+ α<SUB>2</SUB><I>X</I>(<I>X</I>−1), on a 
<I>P</I><SUB>2</SUB>(2)=3+2 α<SUB>2</SUB>=1
donc  α<SUB>2</SUB>=−1, finalement <I>P</I><SUB>2</SUB>=1+<I>X</I>−<I>X</I>(<I>X</I>−1).</P><!--TOC subsubsection Majoration de l’erreur d’interpolation.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc235">21.1.2</A>  Majoration de l’erreur d’interpolation.</H4><!--SEC END --><P>
Reste à estimer l’écart entre une fonction et son polynome
interpolateur, on a le :
</P><DIV CLASS="theorem"><B>Théorème 49</B>  <EM> </EM><A NAME="@default277"></A><EM>
Soit </EM><EM><I>f</I></EM><EM> une fonction </EM><EM><I>n</I>+1</EM><EM> fois dérivable sur un intervalle </EM><EM><I>I</I>=[<I>a</I>,<I>b</I>]</EM><EM>
de </EM><EM>ℝ</EM><EM>, </EM><EM><I>x</I></EM><SUB><EM>0</EM></SUB><EM>,...,<I>x</I></EM><SUB><EM><I>n</I></EM></SUB><EM> des réels distincts de </EM><EM><I>I</I></EM><EM>. 
Soit </EM><EM><I>P</I></EM><EM> le polynome de Lagrange donné par les </EM><EM><I>x</I></EM><SUB><EM><I>j</I></EM></SUB><EM> et </EM><EM><I>y</I></EM><SUB><EM><I>j</I></EM></SUB><EM>=<I>f</I>(<I>x</I></EM><SUB><EM><I>j</I></EM></SUB><EM>)</EM><EM>.
Pour tout réel </EM><EM><I>x</I> ∈ <I>I</I></EM><EM>,
il existe un réel </EM><EM>ξ</EM><SUB><EM><I>x</I></EM></SUB><EM> ∈ [<I>a</I>,<I>b</I>]</EM><EM> (qui dépend de </EM><EM><I>x</I></EM><EM>) tel
que :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM> </EM><A NAME="eq:lagrange"></A><EM>
<I>f</I>(<I>x</I>)−<I>P</I>(<I>x</I>) = </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>f</I></EM><SUP><EM>[<I>n</I>+1]</EM></SUP><EM>(ξ</EM><SUB><EM><I>x</I></EM></SUB><EM>)</EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM>(<I>n</I>+1)!</EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><EM><I>n</I></EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><FONT SIZE=6>∏</FONT></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><EM><I>j</I>=0</EM></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>(<I>x</I>−<I>x</I></EM><SUB><EM><I>j</I></EM></SUB><EM>) 
    (54)</EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>
Ainsi l’erreur commise dépend d’une majoration de la taille
de la dérivée <I>n</I>+1-ième sur l’intervalle, mais aussi
de la disposition des points <I>x</I><SUB><I>j</I></SUB> par rapport à <I>x</I>. Par exemple
si les points <I>x</I><SUB><I>j</I></SUB> sont équidistribués, le terme
|∏<SUB><I>j</I>=0</SUB><SUP><I>n</I></SUP>(<I>x</I>−<I>x</I><SUB><I>j</I></SUB>)| sera plus grand près du bord de <I>I</I> qu’au
centre de <I>I</I>.</P><P>Preuve du théorème : Si <I>x</I> est l’un des <I>x</I><SUB><I>j</I></SUB> l’égalité est vraie. Soit 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>C</I>=(<I>f</I>(<I>x</I>)−<I>P</I>(<I>x</I>))/</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>x</I>−<I>x</I><SUB><I>j</I></SUB>) </TD></TR>
</TABLE><P>
on considère maintenant la fonction :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>g</I>(<I>t</I>)=<I>f</I>(<I>t</I>)−<I>P</I>(<I>t</I>) − <I>C</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>t</I>−<I>x</I><SUB><I>j</I></SUB>) </TD></TR>
</TABLE><P>
elle s’annule en <I>x</I><SUB><I>j</I></SUB> pour <I>j</I> variant de 0 à <I>n</I> ainsi qu’en <I>x</I>
suite au choix de la constante <I>C</I>, donc <I>g</I> s’annule au moins <I>n</I>+2 fois
sur l’intervalle contenant les <I>x</I><SUB><I>j</I></SUB> et <I>x</I>, donc <I>g</I>′ s’annule au moins
<I>n</I>+1 fois sur ce même intervalle, donc <I>g</I>′′ s’annule au moins
<I>n</I> fois, etc. et finalement <I>g</I><SUP>[<I>n</I>+1]</SUP> s’annule une fois
au moins sur cet intervalle. Or 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>g</I><SUP>[<I>n</I>+1]</SUP> = <I>f</I><SUP>[<I>n</I>+1]</SUP> − <I>C</I> (<I>n</I>+1)!</TD></TR>
</TABLE><P>
car <I>P</I> est de degré inférieur ou égal à <I>n</I> 
et  ∏<SUB><I>j</I>=0</SUB><SUP><I>n</I></SUP>(<I>x</I>−<I>x</I><SUB><I>j</I></SUB>) − <I>x</I><SUP><I>n</I>+1</SUP> est de degré
inférieur ou égal à <I>n</I>. Donc il existe bien un réel ξ<SUB><I>x</I></SUB> dans
l’intervalle contenant les <I>x</I><SUB><I>j</I></SUB> et <I>x</I> tel que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>C</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I><SUP>[<I>n</I>+1]</SUP>(ξ<SUB><I>x</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><!--TOC subsubsection Calcul efficace du polynôme de
Lagrange.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc236">21.1.3</A>  Calcul efficace du polynôme de
Lagrange.</H4><!--SEC END --><P><A NAME="@default278"></A><A NAME="@default279"></A>
Avec la méthode de calcul précédent, on remarque que le
polynôme de Lagrange peut s’écrire à la Horner sous la forme :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>P</I>(<I>x</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>α<SUB>0</SUB> + α<SUB>1</SUB> (<I>x</I>−<I>x</I><SUB>0</SUB>) + ... + α<SUB><I>n</I></SUB>
(<I>x</I>−<I>x</I><SUB>0</SUB>)...(<I>x</I>−<I>x</I><SUB><I>n</I>−1</SUB>) </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>α<SUB>0</SUB> + (<I>x</I>−<I>x</I><SUB>0</SUB>)( α<SUB>1</SUB> + (<I>x</I>−<I>x</I><SUB>1</SUB>)(α<SUB>2</SUB> +  ... +
(<I>x</I>−<I>x</I><SUB><I>n</I>−2</SUB>)(α<SUB><I>n</I>−1</SUB>+(<I>x</I>−<I>x</I><SUB><I>n</I>−1</SUB>) α<SUB><I>n</I></SUB>)...))</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
ce qui permet de le calculer rapidement une fois les α<SUB><I>i</I></SUB>
connus.
On observe que 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">α<SUB>0</SUB>=<I>f</I>(<I>x</I><SUB>0</SUB>),    α<SUB>1</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I>(<I>x</I><SUB>1</SUB>)−<I>f</I>(<I>x</I><SUB>0</SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB>1</SUB>−<I>x</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
On va voir que les α<SUB><I>k</I></SUB> peuvent aussi se mettre sous forme
d’une différence.
On définit les différences divisées d’ordre <I>n</I> par récurrence
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>[<I>x</I><SUB><I>i</I></SUB>]=<I>f</I>(<I>x</I><SUB><I>i</I></SUB>),    <I>f</I>[<I>x</I><SUB><I>i</I></SUB>,...,<I>x</I><SUB><I>k</I>+<I>i</I>+1</SUB>]=
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I>[<I>x</I><SUB><I>i</I>+1</SUB>,...,<I>x</I><SUB><I>k</I>+<I>i</I>+1</SUB>]−<I>f</I>[<I>x</I><SUB><I>i</I></SUB>,...,<I>x</I><SUB><I>k</I>+<I>i</I></SUB>]</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB><I>k</I>+<I>i</I>+1</SUB>−<I>x</I><SUB><I>i</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
On va montrer que α<SUB><I>k</I></SUB>=<I>f</I>[<I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>k</I></SUB>].
C’est vrai au rang 0, il suffit donc de le montrer au rang <I>k</I>+1 en
l’admettant au rang <I>k</I>. Pour cela on observe qu’on peut construire 
le polynôme d’interpolation en <I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>k</I>+1</SUB> à partir des polynômes 
d’interpolation <I>P</I><SUB><I>k</I></SUB> en <I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>k</I></SUB> et <I>Q</I><SUB><I>k</I></SUB> en <I>x</I><SUB>1</SUB>,...,<I>x</I><SUB><I>k</I>+1</SUB> 
par la formule :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB><I>k</I>+1</SUB>(<I>x</I>)= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>x</I><SUB><I>k</I>+1</SUB>−<I>x</I>)<I>P</I><SUB><I>k</I></SUB> + (<I>x</I>−<I>x</I><SUB>0</SUB>)<I>Q</I><SUB><I>k</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB><I>k</I>+1</SUB>−<I>x</I><SUB>0</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
en effet on vérifie que <I>P</I><SUB><I>k</I>+1</SUB>(<I>x</I><SUB><I>i</I></SUB>)=<I>f</I>(<I>x</I><SUB><I>i</I></SUB>) pour <I>i</I>∈ [1,<I>k</I>] car
<I>P</I><SUB><I>k</I></SUB>(<I>x</I><SUB><I>i</I></SUB>)=<I>f</I>(<I>x</I><SUB><I>i</I></SUB>)=<I>Q</I><SUB><I>k</I></SUB>(<I>x</I><SUB><I>i</I></SUB>),
et pour <I>i</I>=0 et <I>i</I>=<I>k</I>+1, on a aussi <I>P</I><SUB><I>k</I>+1</SUB>(<I>x</I><SUB>0</SUB>)=<I>f</I>(<I>x</I><SUB>0</SUB>) et 
<I>P</I><SUB><I>k</I>+1</SUB>(<I>x</I><SUB><I>k</I>+1</SUB>)=<I>f</I>(<I>x</I><SUB><I>k</I>+1</SUB>).
Or α<SUB><I>k</I>+1</SUB> est le coefficient dominant de <I>P</I><SUB><I>k</I>+1</SUB> donc
c’est la différence du coefficient dominant de <I>Q</I><SUB><I>k</I></SUB> et de <I>P</I><SUB><I>k</I></SUB>
divisée par <I>x</I><SUB><I>k</I>+1</SUB>−<I>x</I><SUB>0</SUB>, c’est-à-dire la définition de 
<I>f</I>[<I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>k</I>+1</SUB>] en fonction de <I>f</I>[<I>x</I><SUB>1</SUB>,...,<I>x</I><SUB><I>k</I>+1</SUB>] et <I>f</I>[<I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>k</I></SUB>].</P><P>Exemple : on reprend <I>P</I>(0)=1, <I>P</I>(1)=2, <I>P</I>(2)=1. On a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>x</I><SUB><I>i</I></SUB></TD><TD ALIGN=center NOWRAP><I>f</I>[<I>x</I><SUB><I>i</I></SUB>]</TD><TD ALIGN=center NOWRAP><I>f</I>[<I>x</I><SUB><I>i</I></SUB>,<I>x</I><SUB><I>i</I>+1</SUB>]</TD><TD ALIGN=center NOWRAP><I>f</I>[<I>x</I><SUB>0</SUB>,<I>x</I><SUB>1</SUB>,<I>x</I><SUB>2</SUB>] </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><TABLE CLASS="boxed"><TR><TD>1</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(2−1)/(1−0)=</TD><TD CLASS="dcell"><TABLE CLASS="boxed"><TR><TD>1</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(−1−1)/(2−0)=</TD><TD CLASS="dcell"><TABLE CLASS="boxed"><TR><TD>-1</TD></TR>
</TABLE></TD><TD CLASS="dcell">   </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>(1−2)/(2−1)=−1</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
donc <I>P</I>(<I>x</I>)=<SPAN CLASS="textboxed">1</SPAN>+(<I>x</I>−0)(<SPAN CLASS="textboxed">1</SPAN>+(<I>x</I>−1)(<SPAN CLASS="textboxed">−1</SPAN>))=1+<I>x</I>(2−<I>x</I>).</P><P>On peut naturellement utiliser l’ordre que l’on souhaite pour les
<I>x</I><SUB><I>i</I></SUB>, en observant que le coefficient dominant de <I>P</I> ne dépend pas de
cet ordre, on en déduit que <I>f</I>[<I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>k</I></SUB>] est indépendant de
l’ordre des <I>x</I><SUB><I>i</I></SUB>, on peut donc à partir du tableau ci-dessus
écrire <I>P</I> par exemple avec l’ordre 2,1,0, sous la forme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>x</I>)=1+(<I>x</I>−2)(−1+(<I>x</I>−1)(−1))=1+(<I>x</I>−2)(−<I>x</I>)</TD></TR>
</TABLE><P>La commande Xcas <CODE>interp</CODE> ou son synonyme <CODE>lagrange</CODE>
effectue ce calcul.</P><P>Pour avoir les différences divisées, on peut créer le programme suivant
</P><PRE CLASS="verbatim">dd(X,Y):={ // Algorithme des différences divisées
  local k,l,n,A,old,cur;
  si size(X)!=size(Y) alors return "erreur" fsi;
  n:=size(X)-1;
  A:=[Y[0]];
  old:=Y;
  pour k de 1 jusque n faire
    // calcul de cur en fonction de old
    cur:=[];
    pour l de 0 jusque n-k faire
      cur[l]:=(old[l+1]-old[l])/(X[l+k]-X[l])
    fpour;
    A[k]:=cur[0];
    old:=cur;
  fpour;
  retourne A;
}:;
</PRE><P>(N.B. pour rendre ce programme optimal, il faudrait utiliser l’affectation en place)</P><!--TOC subsubsection Sensibilité aux erreurs sur les données.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc237">21.1.4</A>  Sensibilité aux erreurs sur les données.</H4><!--SEC END --><P>
Si les <I>y</I><SUB><I>j</I></SUB> sont connus avec une certaine erreur, alors le polynôme 
d’interpolation est connu de manière approchée. Plus
précisément, si on note
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">π<SUB><I>j</I></SUB>(<I>x</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∏</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I> ≠ <I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I>−<I>x</I><SUB><I>k</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB><I>j</I></SUB>−<I>x</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
le <I>j</I>-ième polynome de Lagrange valant 1 en <I>x</I><SUB><I>j</I></SUB> et 0 ailleurs,
l’erreur vaut :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (ỹ<SUB><I>j</I></SUB>−<I>y</I><SUB><I>j</I></SUB>) π<SUB><I>j</I></SUB>(<I>x</I>) </TD></TR>
</TABLE><P>
Si l’erreur relative sur les <I>y</I><SUB><I>j</I></SUB> est majorée par є,
l’erreur sur le polynôme d’interpolation est majorée par :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">є   max<SUB><I>j</I></SUB>|<I>y</I><SUB><I>j</I></SUB>| </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> |π<SUB><I>j</I></SUB>(<I>x</I>)| </TD></TR>
</TABLE><P>
il y a amplification de l’erreur par un facteur majoré par 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">max<SUB><I>x</I> ∈ [<I>a</I>,<I>b</I>]</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |π<SUB><I>j</I></SUB>(<I>x</I>)| </TD></TR>
</TABLE><P>
Ce facteur s’appelle <B>constante de Lebesgue</B><A NAME="@default280"></A><A NAME="@default281"></A> relative à la
subdivision <I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>n</I></SUB> de [<I>a</I>,<I>b</I>]. On peut le calculer
numériquement pour une subdivision équidistribuée,
et montrer qu’il croit comme 2<SUP><I>n</I>+1</SUP>/<I>e</I> <I>n</I> ln(<I>n</I>),
par exemple pour <I>n</I>=40, il vaut environ <TT>5e9</TT>.
Illustration avec Xcas :<BR>
<TT>l(k,n):=product((x-j)/(k-j),j,0,k-1)*product((x-j)/(k-j),j,k+1,n)</TT><BR>
<TT>n:=10; f:=add(abs(l(k,n)),k,0,n); plot(f,x=0..n)</TT><BR>
puis essayer avec <I>n</I>=20. Pour <I>n</I>=40, en observant que le max
est atteint dans [0,1], on peut remplacer les valeurs absolues
par la bonne puissance de -1<BR>
<CODE>g:=l(0,n)+add((-1)^(k+n-1)*l(k,n),k,1,n)</CODE><BR>
on a alors un polynôme, dont on calcule l’abscisse du maximum par
<TT>l:=proot(g’)</TT> puis <TT>subst(g,x=l[0])</TT> qui donne environ <TT>4.7e9</TT>.</P><!--TOC subsection Interpolation aux points de Tchebyshev-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc238">21.2</A>  Interpolation aux points de Tchebyshev</H3><!--SEC END --><P><A NAME="@default282"></A>
L’idée la plus naturelle pour interpoler un polynôme en <I>n</I>+1
points d’un intervalle [<I>a</I>,<I>b</I>] consiste à couper en <I>n</I> morceaux
de même longueur. Mais ce n’est pas le plus efficace car le
terme |∏<SUB><I>j</I>=0</SUB><SUP><I>n</I></SUP>(<I>x</I>−<I>x</I><SUB><I>j</I></SUB>)| est plus grand près des bords. Il est
donc plus judicieux d’avoir plus de points près des bords et moins
à l’intérieur. C’est là qu’interviennent les polynômes de
Tchebyshev, ils sont définis par développement de cos(<I>nx</I>)
en puissances de cos(<I>x</I>) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>T</I><SUB><I>n</I></SUB>(cos(<I>x</I>))=cos(<I>nx</I>) </TD></TR>
</TABLE><P>
Sur [−1,1], le polynôme <I>T</I><SUB><I>n</I></SUB> vaut en valeur absolue au plus 1, et
atteint cette valeur exactement <I>n</I>+1 fois lorsque <I>x</I>=<I>k</I>π/<I>n</I> donc 
<I>X</I>=cos(<I>x</I>)=cos(<I>k</I>π/<I>n</I>). De plus cette majoration est optimale,
si un autre polynôme <I>U</I> de degré au plus <I>n</I> 
vérifie |<I>U</I>|<SUB>∞</SUB>&lt;1 et a le même coefficient dominant que
<I>T</I><SUB><I>n</I></SUB>, alors la différence <I>T</I><SUB><I>n</I></SUB>−<I>U</I> est du signe de <I>T</I><SUB><I>n</I></SUB> en
<I>X</I>=cos(<I>k</I>π/<I>n</I>), <I>k</I> ∈ [0,<I>n</I>] puisqu’en ces points <I>T</I><SUB><I>n</I></SUB> est
extrêmal, et donc <I>T</I><SUB><I>n</I></SUB>−<I>U</I> s’annule <I>n</I> fois sur [−1,1], mais son degré
est au plus <I>n</I>−1.</P><P>On a donc intérêt à prendre les abscisses des points
d’interpolation en les racines <I>t</I><SUB><I>n</I></SUB> de <I>T</I><SUB><I>n</I></SUB>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I>+<I>b</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I>−<I>b</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>t</I><SUB><I>n</I></SUB>,    <I>t</I><SUB><I>n</I></SUB>=cos((<I>k</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">), 
   <I>k</I>=0..<I>n</I>−1</TD></TR>
</TABLE><P>
On pourra observer que le phénomène de Runge qui apparait par
exemple pour <I>f</I>(<I>x</I>)=1/(25<I>x</I><SUP>2</SUP>+1) avec des points d’interpolation
équidistants n’apparait plus si on prend des points de Tchebyshev.
Ceci est relié à la constante de Lebesgue 
qui pour des points de Tchebyshev vaut un peu moins de 4 pour <I>n</I>&lt;100
(se comporte comme 2/πln(<I>n</I>) pour <I>n</I> grand), on peut montrer
que les polynômes de Lagrange aux points de Tchebyshev convergent
uniformément vers 1/(25<I>x</I><SUP>2</SUP>+1) (c’est plus généralement
vrai pour toute fonction <I>C</I><SUP>1</SUP> sur l’intervalle).</P><P>Remarque : ce n’est pas le polynôme de meilleure approximation,
de <I>f</I> (celui qui minimise la norme <I>L</I><SUP>∞</SUP> de la différence)
car la dérivée <I>n</I>+1-ième varie en général sur [<I>a</I>,<I>b</I>]. Mais
il est trop difficile de le calculer en général.</P><P>Exemple de calcul explicite de constante de Lebesgue pour <I>n</I>=40 avec Xcas
</P><PRE CLASS="verbatim">l(k,n):=product((x-j)/(k-j),j,0,k-1)*product((x-j)/(k-j),j,k+1,n);
n:=40; f:=add(abs(l(k,n)),k,0,n); plot(f,x=0..n);
g:=l(0,n)+add((-1)^(k+n-1)*l(k,n),k,1,n);
r:=proot(g'); subst(g,x=r[0]); 2.^41/e/41/ln(41);
t(k,n):={ 
 local T; 
 T:=seq(cos(pi*(k+.5)/(n+1)),k,0,n);
 return product((x-T[j])/(T[k]-T[j]),j,0,k-1)*
  product((x-T[j])/(T[k]-T[j]),j,k+1,n);
}:;
n:=40; f:=add(abs(t(k,n)),k,0,n):;plot(f,x=-1..1)
</PRE><!--TOC subsection Interpolation de Hermite-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc239">21.3</A>  Interpolation de Hermite</H3><!--SEC END --><P><A NAME="@default283"></A>
Si on fait tendre un des points d’interpolation vers un autre, la
donnée de la valeur en ces 2 points serait redondante, elle 
est remplacée par la valeur de la dérivée. Dans le calcul
des différences divisées ci-dessus on fera comme si les
2 points étaient distincts et successifs, disons <I>x</I><SUB><I>i</I></SUB> et <I>x</I><SUB><I>i</I>+1</SUB>,
on remplace le rapport indéterminé 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I>(<I>x</I><SUB><I>i</I>+1</SUB>)−<I>f</I>(<I>x</I><SUB><I>i</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB><I>i</I>+1</SUB>−<I>x</I><SUB><I>i</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">0</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">0</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
par <I>f</I>′(<I>x</I><SUB><I>i</I></SUB>).
On montre qu’une fois ce changement réalisé
tout le reste est identique (y compris la majoration d’erreur).
On peut bien sur généraliser au cas de plusieurs paires de points 
identiques ou des multiplicités plus grandes faisant intervenir
des dérivées d’ordre supérieures, dans ce cas la différence
divisée <I>f</I>[<I>x</I><SUB><I>i</I></SUB>,...,<I>x</I><SUB><I>i</I>+<I>m</I></SUB>] sera remplacée par <I>f</I><SUP>[<I>m</I>]</SUP>(<I>x</I><SUB><I>i</I></SUB>)/<I>m</I>!.</P><!--TOC subsection Polynômes de Bernstein et courbes de
Bézier-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc240">21.4</A>  Polynômes de Bernstein et courbes de
Bézier</H3><!--SEC END --><P><A NAME="@default284"></A> <A NAME="@default285"></A>
Les polynômes de Bernstein de degré <I>m</I> sont les
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>B</I><SUB><I>k</I></SUB><SUP><I>n</I></SUP> (<I>x</I>) = 
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>n</I> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>k</I> </TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><I>x</I><SUP><I>k</I></SUP> (1−<I>x</I>)<SUP><I>n</I>−<I>k</I></SUP></TD></TR>
</TABLE><P>
On reconnait la probabilité d’avoir <I>k</I> succès si on effectue <I>n</I>
tirages indépendants (avec remise) 
avec probabilité <I>x</I> ∈ [0,1] de succès par tirage. Ceci donne
une relation de récurrence
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>B</I><SUB><I>k</I>+1</SUB><SUP><I>n</I>+1</SUP>=(1−<I>x</I>)<I>B</I><SUB><I>k</I>+1</SUB><SUP><I>n</I></SUP>+<I>x</I> <I>B</I><SUB><I>k</I></SUB><SUP><I>n</I></SUP> </TD></TR>
</TABLE><P>
qui peut servir à calculer les <I>B</I><SUB><I>i</I></SUB><SUP><I>m</I></SUP>. On en déduit aussi que l’espérance
de <I>k</I> selon cette loi vaut <I>nx</I> (somme de <I>n</I> variables d’espérance
<I>x</I>) et l’espérance de (<I>k</I>−<I>nx</I>)<SUP>2</SUP> vaut
<I>nx</I>(1−<I>x</I>) (variance de la somme de <I>n</I> variables indépendantes
de variance <I>x</I>).
On en déduit qu’on peut approcher uniformément une
fonction continue sur un intervalle [<I>a</I>,<I>b</I>] par des polynômes, en
se ramenant à <I>a</I>=0, <I>b</I>=1, on pose :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB><I>n</I></SUB>(<I>x</I>) = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">) <I>B</I><SUB><I>k</I></SUB><SUP><I>n</I></SUP>(<I>x</I>) </TD></TR>
</TABLE><P>
En effet, par continuité uniforme de <I>f</I> sur [0,1], pour
є&gt;0,
il existe δ&gt;0 tel que |<I>x</I>−<I>y</I>|&lt;δ ⇒
|<I>f</I>(<I>x</I>)−<I>f</I>(<I>y</I>)|&lt;є/2,
dans
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB><I>n</I></SUB>(<I>x</I>)−<I>f</I>(<I>x</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>f</I>(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)−<I>f</I>(<I>x</I>)) <I>B</I><SUB><I>k</I></SUB><SUP><I>n</I></SUP>(<I>x</I>)</TD></TR>
</TABLE><P>
on décompose la somme sur <I>k</I> en deux parties, |<I>k</I>/<I>n</I>−<I>x</I>|&lt;δ
et |<I>k</I>/<I>n</I>−<I>x</I>| ≥ δ, pour la première somme, on majore
|<I>f</I>(<I>k</I>/<I>n</I>)−<I>f</I>(<I>x</I>)| par є/2 puis par ∑<SUB><I>k</I>=0</SUB><SUP><I>n</I></SUP>,
pour la deuxième somme, on majore par 2|<I>f</I>|<SUB>∞</SUB> et on utilise
1&lt;(<I>k</I>/<I>n</I>−<I>x</I>)<SUP>2</SUP>/δ<SUP>2</SUP>=1/<I>n</I><SUP>2</SUP>/δ<SUP>2</SUP> (<I>k</I>−<I>nx</I>)<SUP>2</SUP> pour se ramener au calcul
de la variance de <I>k</I>, au final
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>P</I><SUB><I>n</I></SUB>(<I>x</I>)−<I>f</I>(<I>x</I>)| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">є</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I><SUP>2</SUP> δ<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>nx</I>(1−<I>x</I>)|<I>f</I>|<SUB>∞</SUB></TD></TR>
</TABLE><P>
il suffit de choisir <I>n</I> assez grand pour rendre le membre de droite
plus petit que є.</P><P>Les polynômes de Bernstein ne sont pas des polynômes
interpolateurs aux points <I>k</I>/<I>n</I>,   0&lt;<I>k</I>&lt;<I>n</I>, et la convergence
n’est pas forcément très rapide.
On les utilise pour approcher rapidement des morceaux de
courbes, si on se donne des “points de controle” <I>A</I><SUB>0</SUB>, ..., <I>A</I><SUB><I>n</I></SUB>
on construit la courbe paramétrée
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>(<I>t</I>) = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>A</I><SUB><I>k</I></SUB> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>n</I></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>i</I> </TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><I>x</I><SUP><I>i</I></SUP>
(1−<I>x</I>)<SUP><I>n</I>−<I>i</I></SUP> </TD></TR>
</TABLE><P>
appelée courbe de Bézier. En pratique on les utilise pour <I>n</I>=3.</P><!--TOC subsection Polynômes orthogonaux.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc241">21.5</A>  Polynômes orthogonaux.</H3><!--SEC END --><P><A NAME="@default286"></A>
<A NAME="@default287"></A>
Autre exemple important pour l’intégration : les polynômes
de meilleur approximation au sens de normes <I>L</I><SUP>2</SUP> ou <I>L</I><SUP>2</SUP>
à poids (on projette alors sur une base de polynômes orthogonaux
de degrés croissants pour le produit scalaire attaché à la
norme).</P><P>Par exemple, pour l’intégrale sur [−1,1] sans poids, 
les polynômes de Legendre forment une base orthonormée :<BR>
<CODE>S(f,g):=int(f*g,x,-1,1);</CODE><BR>
<CODE>gramschmidt([1,x,x^2,x^3,x^4],S);</CODE><BR>
<CODE>f:=ln(x+2);C:=seq(S(f,legendre(k))/S(legendre(k),legendre(k)),k,0,4);</CODE><BR>
<CODE>g:=sum(C[j]*legendre(j),j,0,4);</CODE><BR>
<CODE>plot([f,g],x,-1.2,1.2,color=[red,blue]);</CODE></P><!--TOC subsection Les splines-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc242">21.6</A>  Les splines</H3><!--SEC END --><P><A NAME="@default288"></A>
Il s’agit de fonctions définies par des polynomes de degré borné
sur des intervalles, dont on fixe la valeur
aux extrémités des intervalles (comme pour le polynome de Lagrange)
ce qui rend la fonction continue, de plus on exige un
degré de régularité plus grand, par exemple etre de classe <I>C</I><SUP>2</SUP>.
Enfin, on fixe des conditions aux bornes de la réunion des 
intervalles, par exemple avoir certaines dérivées nulles. </P><P>Par exemple supposons qu’on se donne <I>n</I> intervalles, donc <I>n</I>+1
points <I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>n</I></SUB>, on se fixe une régularité <I>C</I><SUP><I>d</I>−1</SUP>. Ceci
entraine (<I>n</I>−1)<I>d</I> conditions de recollement, on y ajoute <I>n</I>+1
conditions de valeur en <I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>n</I></SUB>, on a donc <I>nd</I>+1 conditions,
la borne sur le degré des polynomes doit donc etre <I>d</I> (ou plus,
mais <I>d</I> suffit) ce qui donne <I>n</I>(<I>d</I>+1) degrés de liberté, on
peut donc ajouter <I>d</I>−1 conditions, par exemple pour les splines
naturelles, on impose que les dérivées d’ordre <I>d</I>/2 à <I>d</I>−1
soient nulles en <I>x</I><SUB>0</SUB> et <I>x</I><SUB><I>n</I></SUB> (si <I>d</I> est pair, on commence à
la dérivée <I>d</I>/2+1-ième nulle en <I>x</I><SUB><I>n</I></SUB>).</P><P>Pour trouver les polynomes, on doit donc résoudre un grand système
linéaire. Une méthode permettant de diminuer la taille du système
linéaire à résoudre dans le cas des splines naturelles
consiste à se fixer <I>n</I> inconnues <I>z</I><SUB>0</SUB>,..,<I>z</I><SUB><I>n</I>−1</SUB>
représentant les dérivées <I>d</I>-ième de la spline <I>f</I> en
<I>x</I><SUB>0</SUB> sur [<I>x</I><SUB>0</SUB>,<I>x</I><SUB>1</SUB>] à <I>x</I><SUB><I>n</I>−1</SUB> sur [<I>x</I><SUB><I>n</I>−1</SUB>,<I>x</I><SUB><I>n</I></SUB>], 
et (<I>d</I>−1)/2 inconnues <I>f</I><SUB><I>j</I></SUB>, représentant
la valeur de la dérivée de <I>f</I> en <I>x</I><SUB>0</SUB> pour <I>j</I> variant
de 1 à (<I>d</I>−1)/2. On peut alors écrire le polynome sur l’intervalle
[<I>x</I><SUB>0</SUB>,<I>x</I><SUB>1</SUB>] car on connait son développement de Taylor en <I>x</I><SUB>0</SUB>.
On effectue un changement d’origine (par application répétée
de Horner) en <I>x</I><SUB>1</SUB>. On obtient alors le polynome sur [<I>x</I><SUB>1</SUB>,<I>x</I><SUB>2</SUB>]
en remplaçant uniquement la dérivée <I>d</I>-ième par <I>z</I><SUB>1</SUB>.
On continue ainsi jusqu’en <I>x</I><SUB><I>n</I>−1</SUB>. Le système s’obtient en
calculant la valeur du polynome en <I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>n</I></SUB> et la nullité
des dérivées d’ordre (<I>d</I>−1)/2 à <I>d</I>/2 en <I>x</I><SUB><I>n</I></SUB>. On résoud
le système et on remplace pour avoir les valeurs numériques
des coefficients du polynome.</P><!--TOC section Développement de Taylor, asymptotiques, 
séries entières, fonctions usuelles-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc243">22</A>  Développement de Taylor, asymptotiques, 
séries entières, fonctions usuelles</H2><!--SEC END --><P>
<A NAME="sec:series"></A>
<A NAME="@default289"></A>
Pour approcher les fonctions classiques (exponentielle, sinus,
cosinus, log nepérien), on peut utiliser les développements en séries 
classiques, le polynôme de Taylor en un point donne
une bonne approximation près du point, l’équivalent
en l’infini appelé développement asymptotique donne
une bonne approximation loin de 0, et
les approximants de Padé 
où on approche par le quotient de 2 polynômes (ceci
donne parfois de très bons résultats comme pour la fonction
exponentielle près de 0 par exemple).</P><P>Soit <I>f</I> une fonction indéfiniment dérivable sur un intervalle <I>I</I> de ℝ
et <I>x</I><SUB>0</SUB> ∈ <I>I</I>. On peut alors effectuer le développement de Taylor de <I>f</I>
en <I>x</I><SUB>0</SUB> à l’ordre <I>n</I><A NAME="@default290"></A>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>T</I><SUB><I>n</I></SUB>(<I>f</I>)(<I>x</I>)= <I>f</I>(<I>x</I><SUB>0</SUB>) + (<I>x</I>−<I>x</I><SUB>0</SUB>) <I>f</I>′(<I>x</I><SUB>0</SUB>) + ... + 
(<I>x</I>−<I>x</I><SUB>0</SUB>)<SUP><I>n</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I><SUP>[<I>n</I>]</SUP>(<I>x</I><SUB>0</SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
et se demander si <I>T</I><SUB><I>n</I></SUB>(<I>f</I>) converge lorsque <I>n</I> tend vers
l’infini, si la limite est égale à <I>f</I>(<I>x</I>) et si on peut facilement
majorer la différence entre <I>f</I>(<I>x</I>) et <I>T</I><SUB><I>n</I></SUB>(<I>f</I>)(<I>x</I>). Si c’est le
cas, on pourra utiliser <I>T</I><SUB><I>n</I></SUB>(<I>f</I>)(<I>x</I>) comme valeur approchée de <I>f</I>(<I>x</I>).</P><P>On peut parfois répondre à ces questions simultanément en regardant le
développement de Taylor de <I>f</I> avec reste : il existe θ compris
entre <I>x</I><SUB>0</SUB> et <I>x</I> tel que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>R</I><SUB><I>n</I></SUB>(<I>x</I>) := <I>f</I>(<I>x</I>)− <I>T</I><SUB><I>n</I></SUB>(<I>f</I>)(<I>x</I>) = (<I>x</I>−<I>x</I><SUB>0</SUB>)<SUP><I>n</I>+1</SUP></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I><SUP>[<I>n</I>+1]</SUP>(θ)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
C’est le cas pour la fonction exponentielle que nous allons
détailler, ainsi que les fonctions sinus et cosinus.</P><!--TOC subsection La fonction exponentielle-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc244">22.1</A>  La fonction exponentielle</H3><!--SEC END --><P><A NAME="@default291"></A><A NAME="@default292"></A>
Soit <I>f</I>(<I>x</I>)=exp(<I>x</I>) et <I>x</I><SUB>0</SUB>=0, la dérivée <I>n</I>-ième de <I>f</I> 
est exp(<I>x</I>), donc <I>R</I><SUB><I>n</I></SUB>(<I>x</I>)=exp(θ)<I>x</I><SUP><I>n</I>+1</SUP>/(<I>n</I>+1)! avec θ
compris entre 0 et <I>x</I>, ainsi si <I>x</I> est positif 
|<I>R</I><SUB><I>n</I></SUB>(<I>x</I>)| ≤ <I>e</I><SUP><I>x</I></SUP> <I>x</I><SUP><I>n</I>+1</SUP>/(<I>n</I>+1)! et si <I>x</I> est négatif,
|<I>R</I><SUB><I>n</I></SUB>(<I>x</I>)| ≤ <I>x</I><SUP><I>n</I>+1</SUP>/(<I>n</I>+1)!. Dans les deux cas, la limite de <I>R</I><SUB><I>n</I></SUB>
est 0 lorsque <I>n</I> tend vers l’infini, car pour <I>n</I> ≥ 2<I>x</I>, on a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP><I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>+1</TD></TR>
</TABLE></TD><TD CLASS="dcell">≤ 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
on a donc pour tout <I>x</I> réel
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>e</I><SUP><I>x</I></SUP> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">lim</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I> → +∞</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>T</I><SUB><I>n</I></SUB>(<I>f</I>)(<I>x</I>)
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">lim</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I> → +∞</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP><I>k</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell">
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP><I>k</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>Comment en déduire une valeur approchée de <I>e</I><SUP><I>x</I></SUP>? Il suffira d’arrêter
la sommation lorsque <I>R</I>:=<I>x</I><SUP><I>n</I>+1</SUP>/(<I>n</I>+1)! si <I>x</I>&lt;0 ou lorsque
<I>R</I>:=<I>e</I><SUP><I>x</I></SUP> <I>x</I><SUP><I>n</I>+1</SUP>/(<I>n</I>+1)! si <I>x</I>&gt;0 est inférieur à 
l’erreur absolue souhaitée, le plus tôt étant le mieux pour des
raisons d’efficacité et pour éviter l’accumulation d’erreurs
d’arrondi. 
Si on veut connaitre <I>e</I><SUP><I>x</I></SUP> à une erreur relative ε donnée
(par exemple ε=2<SUP>−53</SUP> pour stocker le résultat dans un double)
il suffit que <I>R</I>/<I>e</I><SUP><I>x</I></SUP> &lt; ε, donc si <I>x</I> est positif, il suffit
que <I>x</I><SUP><I>n</I>+1</SUP>/(<I>n</I>+1)!&lt;ε, on peut donc arrêter la sommation
lorsque le terme suivant est plus petit que ε.</P><P>On observe que plus <I>x</I> est grand, plus <I>n</I> devra
être grand pour réaliser le test d’arrêt, ce qui est facheux
pour le temps de calcul.
De plus, le résultat final peut être petit alors que les termes
intermédiaires calculés dans la somme peuvent être grands, ce qui
provoque une perte de précision relative, par exemple si on
veut calculer <I>e</I><SUP>−10</SUP> ou plus généralement l’exponentielle
d’un nombre négatif de grande valeur absolue.</P><P>Exercice : combien de termes faut-il calculer dans le développement
de l’exponentielle de -10 pour que le reste soit plus petit
que 2<SUP>−53</SUP> ? Quel est la valeur du plus grand terme rencontré dans
la suite ? Quelle est la perte de précision relative occasionné
par cette méthode de calcul ?</P><P>On peut utiliser les propriétés de la fonction exponentielle
pour éviter ce problème. Pour les nombres négatifs, on peut
utiliser l’équation <I>e</I><SUP>−<I>x</I></SUP>=1/<I>e</I><SUP><I>x</I></SUP> (ne change pas l’erreur relative). 
Pour les grands réels, on peut utiliser <I>e</I><SUP>2<I>x</I></SUP>=(<I>e</I><SUP><I>x</I></SUP>)<SUP>2</SUP>
(multiplie par 2 l’erreur relative).
On peut aussi, si on connait une valeur approchée
de ln(2), effectuer la division euclidienne de <I>x</I> par ln(2) 
avec reste symétrique :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I> = <I>a</I> ln(2) + <I>r</I>,    <I>a</I> ∈ ℤ, |<I>r</I>| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>ln</I>(2)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
puis si <I>r</I> est positif, on somme la série de <I>T</I>(<I>f</I>)(<I>r</I>), si <I>r</I>
est négatif, on calcule <I>T</I>(<I>f</I>)(−<I>r</I>) et on inverse, on applique alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>e</I><SUP><I>x</I></SUP> = 2<SUP><I>a</I></SUP> <I>e</I><SUP><I>r</I></SUP> </TD></TR>
</TABLE><P>Il faut toutefois noter que ln(2) n’étant pas connu exactement,
on commet une erreur d’arrondi absolu sur <I>r</I> d’ordre <I>a</I> η,
où η est l’erreur relative sur ln(2),
il faut donc ajouter une erreur d’arrondi relative de <I>x</I>/ln(2) η
qui peut devenir grande si <I>x</I> est grand. Puis il faut ajouter
la somme des erreurs d’arrondi due au calcul de <I>e</I><SUP><I>r</I></SUP>, que l’on
peut minimiser en utilisant la méthode de Horner pour évaluer
<I>T</I><SUB><I>n</I></SUB>(<I>f</I>)(<I>r</I>) (car elle commence par sommer les termes de plus haut degré
qui sont justement les plus petits termes de la somme). 
Les coprocesseurs arithmétiques qui implémentent la fonction exponentielle
ont un format de représentation interne des double avec une mantisse
plus grande que celle des double (par exemple 64 bits au lieu de 53),
et une table contenant des constantes dont ln(2) avec cette précision,
le calcul de <I>e</I><SUP><I>x</I></SUP> par cette méthode entraine donc seulement une erreur
relative d’arrondi au plus proche sur le résultat converti en double 
(donc de 2<SUP>−53</SUP>).</P><P>Notons que en général <I>x</I> lui-même
a déjà été arrondi ou n’est connu qu’avec une précision relative.
Or si <I>x</I>&gt;0 est connu avec une erreur relative de ε
(donc une erreur absolue de ε |<I>x</I>|, alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>e</I><SUP><I>x</I>+ε |<I>x</I>|</SUP>= <I>e</I><SUP><I>x</I></SUP> <I>e</I><SUP>ε |<I>x</I>|</SUP> </TD></TR>
</TABLE><P>
donc on ne peut pas espérer mieux qu’une erreur relative de 
<I>e</I><SUP>ε |<I>x</I>|</SUP>−1 sur l’exponentielle de <I>x</I>. Si ε <I>x</I> est petit
cette erreur relative (impossible à éviter, quel que soit
l’algorithme utilisé pour calculer l’exponentielle) 
est d’ordre ε |<I>x</I>|. Si ε <I>x</I> est 
grand alors l’erreur relative devient de l’ordre de 1, et la valeur
de l’exponentielle calculée peut être très éloignée de la valeur
réelle! Notons que pour les double, il y aura dans ce cas débordement 
soit vers l’infini soit vers 0
(par exemple si <I>x</I> est supérieur à 709, l’exponentielle renvoie infini).</P><P>Exercice : refaire les mêmes calculs pour les fonction sinus ou cosinus.
On utilise par exemple sin(<I>x</I>+π)=−<I>sin</I>(<I>x</I>), sin(−<I>x</I>)=−sin(<I>x</I>),
sin(<I>x</I>)=cos(π/2−<I>x</I>) pour se ramener au calcul de sin(<I>x</I>) 
ou de cos(<I>x</I>) sur [0,π/4].<A NAME="@default293"></A><A NAME="@default294"></A>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">sin(<I>x</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell">(−1)<SUP><I>n</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2<I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(2<I>n</I>+1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell">,
   cos(<I>x</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell">(−1)<SUP><I>n</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2<I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(2<I>n</I>)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>Cette méthode a toutefois ces limites, car il peut devenir impraticable
de calculer la dérivée <I>n</I>-ième d’une fonction (par exemple avec tan(<I>x</I>)),
et encore plus de la majorer. D’où l’intérêt de développer une théorie
des fonctions qui sont égales à leur développement de Taylor à l’infini
d’une part, et d’avoir d’autres méthodes pour majorer le reste, nous
présentons ici le cas des séries alternées.</P><!--TOC subsection Séries entières.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc245">22.2</A>  Séries entières.</H3><!--SEC END --><P><A NAME="@default295"></A>
Les séries de type prendre la limite lorsque <I>n</I> tend vers
l’infini du développement de Taylor en x=0 sont de la forme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>a</I><SUB><I>n</I></SUB> <I>x</I><SUP><I>n</I></SUP> := </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">lim</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"> <I>k</I> → +∞</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUB><I>n</I></SUB> <I>x</I><SUP><I>n</I></SUP>, <I>a</I><SUB><I>n</I></SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I><SUP>[<I>n</I>]</SUP>(0)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On peut s’intéresser plus généralement à ∑<SUB><I>n</I>=0</SUB><SUP>∞</SUP><I>a</I><SUB><I>n</I></SUB> <I>x</I><SUP><I>n</I></SUP>
lorsque <I>a</I><SUB><I>n</I></SUB> est un complexe quelconque, 
c’est ce qu’on appelle une série entière, on peut aussi les voir comme
des polynômes généralisés. </P><P>S’il existe un point <I>x</I><SUB>0</SUB> tel que 
|<I>a</I><SUB><I>n</I></SUB> <I>x</I><SUB>0</SUB><SUP><I>n</I></SUP>| est borné (ce sera le cas en particulier 
si la série converge en <I>x</I><SUB>0</SUB>), alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>a</I><SUB><I>n</I></SUB> <I>x</I><SUP><I>n</I></SUP>| = |<I>a</I><SUB><I>n</I></SUB> <I>x</I><SUB>0</SUB><SUP><I>n</I></SUP>| |</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">|<SUP><I>n</I></SUP> ≤ 
<I>M</I> |</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">|<SUP><I>n</I></SUP>
</TD></TR>
</TABLE><P>
la série converge donc en <I>x</I> si |<I>x</I>|&lt;|<I>x</I><SUB>0</SUB>| et on 
peut majorer le reste de la série au rang <I>n</I> par 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>R</I><SUB><I>n</I></SUB>| ≤ <I>M</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> |</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">|<SUP><I>n</I>+1</SUP></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">1−|</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">|</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD></TR>
</TABLE><P>
la vitesse de convergence est donc du même type que pour le
théorème du point fixe (le nombre de termes à calculer
pour trouver une valeur approchée avec <I>k</I> décimales 
dépend linéairement <I>k</I>, les constantes sont d’autant
plus grandes que |<I>x</I>| est grand).</P><DIV CLASS="theorem"><B>Théorème 50</B>  <EM>
S’il existe un rang </EM><EM><I>n</I></EM><SUB><EM>0</EM></SUB><EM>, un réel </EM><EM><I>M</I>&gt;0</EM><EM> et un complexe </EM><EM><I>x</I></EM><SUB><EM>0</EM></SUB><EM> tels que 
pour </EM><EM><I>n</I>&gt;<I>n</I></EM><SUB><EM>0</EM></SUB><EM>, on ait :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>|<I>a</I></EM><SUB><EM><I>n</I></EM></SUB><EM> <I>x</I></EM><SUB><EM>0</EM></SUB><EM>|</EM><SUP><EM><I>n</I></EM></SUP><EM> ≤ <I>M</I></EM></TD></TR>
</TABLE><EM>
alors la série converge pour </EM><EM>|<I>x</I>|&lt;|<I>x</I></EM><SUB><EM>0</EM></SUB><EM>|</EM><EM>
et pour </EM><EM><I>n</I>≥ <I>n</I></EM><SUB><EM>0</EM></SUB><EM>, on a :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM> </EM><A NAME="eq:maj_serie_entiere"></A><EM>
|<I>R</I></EM><SUB><EM><I>n</I></EM></SUB><EM>| ≤ <I>M</I> </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><EM> |</EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>x</I></EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>x</I></EM><SUB><EM>0</EM></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>|</EM><SUP><EM><I>n</I>+1</EM></SUP></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><EM>1−|</EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>x</I></EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>x</I></EM><SUB><EM>0</EM></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>|</EM></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> 
    (55)</EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>On en déduit qu’il existe un réel
positif <I>R</I>≥ 0 éventuellement égal à +∞ tel que 
la série converge (la limite de la somme jusqu’à l’infini existe) 
lorsque |<I>x</I>|&lt;<I>R</I> et n’existe pas lorsque
|<I>x</I>|&gt;<I>R</I>, ce réel est appelé <B>rayon de convergence</B> de la série.
Par exemple ce rayon vaut +∞ pour l’exponentielle, le sinus
ou le cosinus. Il
est égal à 1 pour la série géométrique ∑<I>x</I><SUP><I>n</I></SUP> (car elle diverge
si |<I>x</I>|&gt;1 et converge si |<I>x</I>|&lt;1). 
On ne peut pas dire ce qui se passe génériquement lorsqu’on
est à la limite, c’est-à-dire lorsque |<I>x</I>|=<I>R</I> (si <I>R</I>≠
+∞). Mais cela n’a en fait pas trop d’importance en pratique
car même si la série converge, elle converge souvent trop lentement
pour donner de bonnes approximations. En fait, la vitesse de
convergence d’une série entière de rayon <I>R</I>≠ +∞ est
en gros la même que celle d’une série géométrique de raison |<I>x</I>|/<I>R</I>.</P><P>Lorsque 2 séries ont un rayon de convergence non nul, alors on
peut effectuer leur somme, leur produit comme des polynômes et la
série somme/produit a un rayon de convergence au moins égal au plus
petit des 2 rayons de convergence des arguments. On peut inverser une série
entière non nulle en 0 en appliquant 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(1+<I>x</I>)<SUP>−1</SUP> = 1−<I>x</I>+<I>x</I><SUP>2</SUP>−<I>x</I><SUP>3</SUP>+... </TD></TR>
</TABLE><P>
et on obtient une série entière de rayon de
convergence non nul. On peut aussi composer deux séries entières
<I>g</I> et <I>f</I> en <I>g</I>∘ <I>f</I> (avec les règles de calcul de composition
des polynômes) si <I>f</I>(0)=0. On peut enfin dériver
et intégrer une série entière terme à terme dans son rayon de convergence.</P><P>On dit qu’une fonction est développable en série entière en 0 si
elle est égale à son développement de Taylor en 0 sommé jusqu’en l’infini
dans un disque de centre 0 et de rayon non nul. Les fonctions
exponentielle, sinus, cosinus sont donc développables en série entière en 0.
La fonction tangente également car le dénominateur cosinus est non nul en 0,
mais son rayon de convergence n’est pas l’infini et le calcul des <I>a</I><SUB><I>n</I></SUB>
est assez complexe.
La fonction (1+<I>x</I>)<SUP>α</SUP> est développable en séries entières
pour tout α ∈ ℝ avec un rayon de convergence 1 (ou l’infini
pour α  entier positif). 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(1+<I>x</I>)<SUP>α</SUP>= 1 + α <I>x</I> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">α (α−1)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUP>2</SUP> +
... + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">α (α−1) ... (α −<I>n</I> +1)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUP><I>n</I></SUP> + ...</TD></TR>
</TABLE><P>
Pour α=−1, c’est la série 
géométrique de raison −<I>x</I>, en effet si |<I>x</I>|&lt;1 :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (−<I>x</I>)<SUP><I>n</I></SUP> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1−(−<I>x</I>)<SUP><I>k</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+<I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
→<SUB><I>k</I>→ ∞</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+<I>x</I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
En intégrant par rapport à <I>x</I>, on obtient que ln(1+<I>x</I>) est développable
en série entière en 0 de rayon de convergence 1 et
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ln(1+<I>x</I>) = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(−<I>x</I>)<SUP><I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>+1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
On peut calculer de manière analogue le développement en série entière
de arctan(<I>x</I>) en iintégrant celui de 1/(1+<I>x</I><SUP>2</SUP>), de même pour arccos(<I>x</I>)
et arcsin(<I>x</I>) en intégrant celui de (1−<I>x</I><SUP>2</SUP>)<SUP>−1/2</SUP>.<A NAME="@default296"></A>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">arctan(<I>x</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell">(−1)<SUP><I>n</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2<I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>n</I>+1</TD></TR>
</TABLE></TD><TD CLASS="dcell">,
</TD></TR>
</TABLE><P>
On peut donc calculer ln, arctan, ... par ces formules, 
mais il faut répondre
à la question où arrête-t-on la somme pour obtenir une précision donnée? 
Dans le cas de ln(1+<I>x</I>),
on pourrait répondre comme avec l’exponentielle en majorant la dérivée
<I>n</I>+1-ième, mais ce n’est plus faisable pour arctan, arcsin, arccos.
On va donner un autre critère qui ne nécessite pas
de calculer cette dérivée mais utilise l’alternance des signes
dans la somme.</P><!--TOC subsection Série alternée-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc246">22.3</A>  Série alternée</H3><!--SEC END --><P><A NAME="@default297"></A>
</P><DIV CLASS="theorem"><B>Théorème 51</B>  <EM>
Soit </EM><EM><I>S</I></EM><SUB><EM><I>n</I></EM></SUB><EM>= ∑</EM><SUB><EM><I>k</I>=0</EM></SUB><SUP><EM><I>n</I></EM></SUP><EM> (−1)</EM><SUP><EM><I>k</I></EM></SUP><EM> <I>u</I></EM><SUB><EM><I>k</I></EM></SUB><EM> la somme jusqu’au rang </EM><EM><I>n</I></EM><EM> d’une
série de réels tels que la suite des </EM><EM><I>u</I></EM><SUB><EM><I>k</I></EM></SUB><EM> décroit à partir
d’un rang </EM><EM><I>n</I></EM><SUB><EM>0</EM></SUB><EM> et tend vers 0
lorsque </EM><EM><I>k</I>→ +∞</EM><EM>. Alors </EM><EM><I>S</I></EM><SUB><EM><I>n</I></EM></SUB><EM> converge vers une limite
</EM><EM><I>S</I></EM><EM>. Si </EM><EM><I>n</I>≥ <I>n</I></EM><SUB><EM>0</EM></SUB><EM>, la limite est comprise entre deux sommes
partielles succesives </EM><EM><I>S</I></EM><SUB><EM><I>n</I></EM></SUB><EM> et </EM><EM><I>S</I></EM><SUB><EM><I>n</I>+1</EM></SUB><EM> et le reste est majoré par
la valeur absolue du premier terme non sommé :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>|<I>R</I></EM><SUB><EM><I>n</I></EM></SUB><EM>| ≤ |<I>u</I></EM><SUB><EM><I>n</I>+1</EM></SUB><EM>|</EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>
Démonstration :<BR>
on montre que les suites <I>v</I><SUB><I>n</I></SUB>=<I>S</I><SUB>2<I>n</I></SUB> et <I>w</I><SUB><I>n</I></SUB>=<I>S</I><SUB>2<I>n</I>+1</SUB> sont
adjacentes. On a 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>v</I><SUB><I>n</I>+1</SUB>−<I>v</I><SUB><I>n</I></SUB>= <I>S</I><SUB>2<I>n</I>+2</SUB>−<I>S</I><SUB>2<I>n</I></SUB>= (−1)<SUP>2<I>n</I>+2</SUP> <I>u</I><SUB>2<I>n</I>+2</SUB> + (−1)<SUP>2<I>n</I>+1</SUP>
<I>u</I><SUB>2<I>n</I>+1</SUB> = <I>u</I><SUB>2<I>n</I>+2</SUB>−<I>u</I><SUB>2<I>n</I>+1</SUB> ≤ 0</TD></TR>
</TABLE><P>
donc <I>v</I><SUB><I>n</I></SUB> est décroissante, de même <I>w</I><SUB><I>n</I></SUB> est croissante,
et <I>v</I><SUB><I>n</I></SUB>−<I>w</I><SUB><I>n</I></SUB>=<I>u</I><SUB>2<I>n</I>+1</SUB> est positif et tend vers 0. On en déduit que
<I>v</I><SUB><I>n</I></SUB> et <I>w</I><SUB><I>n</I></SUB> convergent vers la même limite <I>S</I> telle que
<I>v</I><SUB><I>n</I></SUB>&gt;<I>S</I>&gt;<I>w</I><SUB><I>n</I></SUB> et les inégalités du théorème s’en déduisent.</P><P><B>Remarque</B><BR>
lorsqu’on utilise une suite alternée pour
trouver une valeur approchée, il faut que <I>u</I><SUB><I>n</I></SUB> tende assez
vite vers 0, sinon il y aura perte de précision sur la mantisse
lorsqu’on effectuera <I>u</I><SUB>2<I>n</I></SUB>−<I>u</I><SUB>2<I>n</I>+1</SUB>. On sommera aussi les termes
par ordre décroissant pour diminuer les erreurs d’arrondi.</P><!--TOC subsection La fonction logarithme-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc247">22.4</A>  La fonction logarithme</H3><!--SEC END --><P><A NAME="@default298"></A><A NAME="@default299"></A>
Si nous voulons calculer ln(1+<I>x</I>) pour <I>x</I> ∈ [0,1[ avec une
précision ε, il suffit de calculer
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (−1)<SUP><I>k</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP><I>k</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>+1</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
pour <I>n</I> tel que la valeur absolue du terme suivant soit plus petit 
que ε :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>n</I>  tel que  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP><I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>+1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> &lt; ε </TD></TR>
</TABLE><P>
en effet, les signes sont alternés et la suite <I>x</I><SUP><I>k</I>+1</SUP>/<I>k</I>+1
décroit vers 0.</P><P>Si la suite décroit lentement vers 0, cette méthode est
mauvaise numériquement et en temps de calcul
car il y a presque compensation entre
termes successifs donc perte de précision sur la mantisse et il
y a beaucoup de termes à calculer. C’est le cas pour le logarithme,
si <I>x</I> est voisin de 1, il faut calculer <I>n</I> termes pour avoir une
précision en 1/<I>n</I>, par exemple 1 million de termes pour avoir
une précision de 1<I>e</I>−6 (sans tenir compte des erreurs d’arrondi). 
Si <I>x</I> est proche de 1/2 il faut de l’ordre
de −ln(ε)/ln(2) termes ce qui est mieux, mais encore
relativement grand (par exemple
50 termes environ pour une précision en 1<I>e</I>−16,
13 termes pour 1<I>e</I>−4).
On a donc intérêt à se
ramener si possible à calculer la fonction en un <I>x</I> où la
convergence est plus rapide (donc |<I>x</I>| le plus petit possible).
Par exemple pour le calcul de ln(1+<I>x</I>) on peut :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
utiliser la racine carrée
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>ln</I>(1+<I>x</I>)= 2 <I>ln</I>(</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+<I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE>
on observe que :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>X</I>=</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+<I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">−1 = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">1+</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+<I>x</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE>
il faut toutefois faire attention à la perte de précision sur
<I>X</I> par rapport à <I>x</I> lorsque <I>x</I> est petit.
</LI><LI CLASS="li-itemize">utiliser l’inverse
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ln(1+<I>x</I>)=−ln(1/(1+<I>x</I>))=−ln(1 + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−<I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+<I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">) </TD></TR>
</TABLE>
lorsque <I>x</I> est proche de 1, −<I>x</I>/(1+<I>x</I>) est proche de −<I>x</I>/2, on
a presque divisé par 2. Attention toutefois, on se retrouve alors
avec une série non alternée, mais on peut utiliser 
(<A HREF="#eq:maj_serie_entiere">55</A>) pour majorer le reste dans ce cas.
</LI><LI CLASS="li-itemize">trouver une valeur approchée <I>y</I><SUB>0</SUB> de ln(1+<I>x</I>) à une précision
faible, par exemple 1<I>e</I>−4, et utiliser la méthode de Newton pour
améliorer la précision. Soit en effet <I>y</I>=ln(1+<I>x</I>), alors
<I>e</I><SUP><I>y</I></SUP>=1+<I>x</I>, on pose <I>f</I>(<I>y</I>)=<I>e</I><SUP><I>y</I></SUP>−(1+<I>x</I>), on utilise la suite itérative
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I><SUB><I>n</I>+1</SUB> = <I>y</I><SUB><I>n</I></SUB> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP><I>y</I><SUB><I>n</I></SUB></SUP>−(1+<I>x</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP><I>y</I><SUB><I>n</I></SUB></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD></TR>
</TABLE>
Comme <I>y</I><SUB>0</SUB> est proche à 1<I>e</I>−4 de <I>y</I>, on peut espérer avoir
une valeur approchée de <I>y</I> à 1<I>e</I>−16 en 2 itérations. Notez
que <I>y</I> est proche de 0, on est dans un domaine où le calcul
de <I>e</I><SUP><I>y</I></SUP> est rapide et précis et de plus la méthode de Newton
“corrige” les erreurs intermédiaires.
</LI></UL><P>Nous sommes donc en mesure de calculer précisément le logarithme
ln(1+<I>x</I>) pour disons |<I>x</I>|&lt;1/2. Pour calculer <I>ln</I> sur ℝ<SUP>+</SUP>,
on se ramène à [1,2] en utilisant l’écriture
mantisse-exposant, puis si <I>x</I>∈[3/2,2] on peut en prendre la racine
carrée pour se retrouver dans l’intervalle souhaité.
On peut aussi effectuer une division par √<SPAN style="text-decoration:overline">2</SPAN>.</P><P>Remarquons que si <I>x</I> est connu à une erreur relative ε
près, comme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ln(<I>x</I>(1 ± ε))=ln(<I>x</I>) + ln(1 ± ε) </TD></TR>
</TABLE><P>
ln(<I>x</I>) est connu à une erreur absolue de 
|ln(1 ± ε)| ≈ ε. Si ln(<I>x</I>) est proche
de 0, on a une grande perte de précision relative.</P><P>Finalement, nous savons calculer ln et exp sous réserve
d’avoir dans une table la valeur de ln(2). Pour calculer
ln(2) précisément, on peut utiliser
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ln(2)=−<I>ln</I>(1/2)=−<I>ln</I>(1−1/2) </TD></TR>
</TABLE><P>
et le développement en série calculé en mode exact avec des
fractions à un ordre suffisant, on majore le reste en utilisant 
que le terme général de la série ln(1+<I>x</I>) est borné par
<I>M</I>=1 en <I>x</I>=1, donc d’après (<A HREF="#eq:maj_serie_entiere">55</A>) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>R</I><SUB><I>n</I></SUB>| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP><I>n</I></SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
(on peut même obtenir 1/(<I>n</I>2<SUP><I>n</I></SUP>) car on a besoin de <I>M</I> uniquement
pour les termes d’ordre plus grand que <I>n</I>, on peut donc prendre <I>M</I>=1/<I>n</I>).
Par exemple, pour avoir ln(2) avec une mantisse de 80 bits,
on effectue une fois pour toutes avec un logiciel
de calcul formel :<BR>
<CODE>a:=sum((1/2)^k/k,k=1..80)</CODE>|<BR>
puis la division en base 2 avec 81 bits de précision
<CODE>iquo(numer(a)*2^81,denom(a))</CODE></P><P>Exercice : pour les fonctions trigonométriques, il faut une
méthode de calcul de π. On peut par exemple faire le calcul
de 16 arctan(1/5)−4arctan(1/239) en utilisant le développement
de la fonction arctan à un ordre suffisant.</P><!--TOC subsection Approximants de Padé.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc248">22.5</A>  Approximants de Padé.</H3><!--SEC END --><P><A NAME="@default300"></A>
Soit une fonction <I>f</I>(<I>x</I>) dont on connait le développement
de Taylor <I>B</I> en 0 à l’ordre <I>n</I>, on souhaiterait plutot
approcher <I>f</I> par une fraction <I>P</I>/<I>Q</I> avec degré(<I>P</I>) ≤ <I>d</I>
et degré(<I>Q</I>) ≤ <I>n</I>−<I>d</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>=<I>B</I>+<I>O</I>(<I>x</I><SUP><I>n</I>+1</SUP>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>Q</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> +<I>O</I>(<I>x</I><SUP><I>n</I>+1</SUP>) </TD></TR>
</TABLE><P>
Si <I>Q</I>(0)=0, ceci équivaut à <I>P</I>=<I>BQ</I>+<I>x</I><SUP><I>n</I>+1</SUP> <I>S</I> où <I>S</I>, <I>P</I>,<I>Q</I> sont
des polynômes inconnus. On reconnait une identité de type
Bézout pour les polynômes <I>A</I>=<I>x</I><SUP><I>n</I>+1</SUP> et <I>B</I>.
On déroule l’algorithme d’Euclide itératif pour <I>A</I> et <I>B</I>, on définit
donc 3 suites <I>U</I><SUB><I>k</I></SUB>, <I>V</I><SUB><I>k</I></SUB>, <I>R</I><SUB><I>k</I></SUB> où <I>R</I><SUB><I>k</I></SUB> est la suite des restes d’Euclide
de degrés strictement décroissants
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>R</I><SUB><I>k</I>+2</SUB>=<I>R</I><SUB><I>k</I></SUB> − <I>Q</I><SUB><I>k</I></SUB> <I>R</I><SUB><I>k</I>+1</SUB>, <I>U</I><SUB><I>k</I>+2</SUB>=<I>U</I><SUB><I>k</I></SUB> − <I>Q</I><SUB><I>k</I></SUB> <I>U</I><SUB><I>k</I>+1</SUB>, <I>V</I><SUB><I>k</I>+2</SUB>=<I>V</I><SUB><I>k</I></SUB> − <I>Q</I><SUB><I>k</I></SUB> <I>V</I><SUB><I>k</I>+1</SUB> </TD></TR>
</TABLE><P>
et les initialisations :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>U</I><SUB>0</SUB>=1, <I>U</I><SUB>1</SUB>=0, <I>V</I><SUB>0</SUB>=0, <I>V</I><SUB>1</SUB>=1, <I>R</I><SUB>0</SUB>=<I>A</I>, <I>R</I><SUB>1</SUB>=<I>B</I></TD></TR>
</TABLE><P>
On s’arrête au rang <I>N</I>+1 tel que degré(<I>R</I><SUB><I>N</I></SUB>)&gt;<I>d</I> et degré(<I>R</I><SUB><I>N</I>+1</SUB>) ≤ <I>d</I>.
Rappelons qu’on montre par récurrence que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>V</I><SUB><I>k</I></SUB> <I>R</I><SUB><I>k</I>+1</SUB> − <I>V</I><SUB><I>k</I>+1</SUB> <I>R</I><SUB><I>k</I></SUB> = (−1)<SUP><I>k</I>+1</SUP> <I>X</I><SUP><I>n</I>+1</SUP> </TD></TR>
</TABLE><P>
D’autre part la suite des degrés des <I>V</I><SUB><I>k</I></SUB> est strictement croissante
à partir du rang 1 (car degré(<I>Q</I><SUB><I>k</I></SUB>)&gt;0), on en déduit que
degré(<I>V</I><SUB><I>k</I>+1</SUB>)+degré(<I>R</I><SUB><I>k</I></SUB>)=<I>n</I>+1 donc degré(<I>V</I><SUB><I>N</I>+1</SUB>) ≤ <I>n</I>−<I>d</I>.
On pose alors <I>P</I>=<I>R</I><SUB><I>N</I>+1</SUB> et <I>Q</I>=<I>V</I><SUB><I>N</I>+1</SUB>, qui vérifient
<I>P</I>=<I>BQ</I>+<I>AU</I><SUB><I>N</I>+1</SUB>.
Si <I>Q</I>(0) ≠ 0 on a existence d’une solution <I>P</I>/<I>Q</I>, 
et cette solution est alors
unique, car si on a 2 triplets solutions
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>=<I>BQ</I>+<I>AS</I>,  <I>P</I>′=<I>BQ</I>′+<I>AS</I>′,    <I>A</I>=<I>X</I><SUP><I>n</I>+1</SUP></TD></TR>
</TABLE><P>
alors <I>PQ</I>′−<I>P</I>′<I>Q</I> est un multiple de <I>X</I><SUP><I>n</I>+1</SUP> donc nul pour des raisons
de degré, donc <I>P</I>/<I>Q</I>=<I>P</I>′/<I>Q</I>′.</P><P>Par exemple, pour <I>f</I>(<I>x</I>)=<I>e</I><SUP><I>x</I></SUP> et <I>n</I>=10, <I>d</I>=5, <CODE>pade(e^x,x,10,6)</CODE>
renvoie le quotient de deux polynômes de degré 5
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB>2</SUB>+<I>P</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB>2</SUB>−<I>P</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">,  <I>P</I><SUB>2</SUB>=30240+3360<I>x</I><SUP>2</SUP>+30<I>x</I><SUP>4</SUP>, <I>P</I><SUB>1</SUB>=<I>x</I>(15120+420<I>x</I><SUP>2</SUP>+<I>x</I><SUP>4</SUP>)</TD></TR>
</TABLE><P>
fraction que l’on peut évaluer en 12 opérations (5 additions, 1
soustraction, 5 multiplications et 1 division)
et qui donne une approximation de meilleure qualité que le
développement de Taylor à l’ordre 10.
Pour démontrer des estimations sur l’erreur <I>f</I>(<I>x</I>)−<I>P</I>/<I>Q</I>, il n’existe
pas à ma connaissance de résultat explicite général. 
Pour la fonction exponentielle, on peut calculer l’erreur relative
<I>g</I>(<I>x</I>)=1−<I>e</I><SUP>−<I>x</I></SUP><I>P</I>/<I>Q</I>
puis étudier la fonction.
</P><PRE CLASS="verbatim">P,Q:=fxnd(pade(exp(x),x,10,6));
g:=1-exp(-x)*P/Q; factor(g');
</PRE><P>On en déduit que <I>g</I> est une fonction décroissante
(nulle en l’origine), son maximum en valeur absolue
est donc atteint aux bornes de l’intervalle d’étude, par
exemple sur [−1/4,1/4], l’erreur relative est majorée
par <CODE>3e-17</CODE>, il faudrait aller à l’ordre 12 pour
avoir la même précision avec Taylor donc faire 23 opérations,
quasiment le double. Visuellement, le graphe de l’exponentielle et de
l’approximation de Padé sont encore très proches pour <I>x</I>=5.
</P><PRE CLASS="verbatim">f(x):={
  local P1,P2,x2;
  x2:=x*x;
  P2:=30240+x2*(3360+30*x2);
  P1:=x*(15120+x2*(420+x2));
  retourne (P2+P1)/(P2-P1);
}:;
plot([f(x),exp(x)],x=-6..6,color=[blue,red]);
</PRE><!--TOC subsection Autres applications-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc249">22.6</A>  Autres applications</H3><!--SEC END --><P>
On peut calculer certaines intégrales de la même manière,
par exemple
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1/2</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1+<I>x</I><SUP>3</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
mais aussi des fonctions définies par des intégrales (cas de nombreuses
fonctions spéciales).</P><!--TOC subsubsection Exemple : la fonction d’erreur (error fonction, <TT>erf</TT>)-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc250">22.6.1</A>  Exemple : la fonction d’erreur (error fonction, <TT>erf</TT>)</H4><!--SEC END --><P><A NAME="@default301"></A><A NAME="@default302"></A>
Cette fonction est définie à une constante multiplicative près par :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>x</I>)=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−<I>t</I><SUP>2</SUP></SUP>  <I>dt</I> </TD></TR>
</TABLE><P>
On peut développer en séries entières l’intégrand (rayon
de convergence +∞), puis intégrer terme
à terme, on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>x</I>)= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (−1)<SUP><I>n</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2<I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>! (2<I>n</I>+1)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Ce développement converge très rapidement pour |<I>x</I>|≤ 1.
Par contre, pour |<I>x</I>| grand, il faut calculer beaucoup de termes
avant que le reste soit suffisamment petit pour être négligeable,
et certains termes intermédiaires sont grands, ce qui provoque
une perte de précision qui peut rendre le résultat calculé
complètement faux. Contrairement à la fonction exponentielle,
il n’y a pas de possibilité de réduire l’argument à une plage
où la série converge vite. Il faut donc
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
soit utiliser des flottants multiprécision, avec une précision
augmentée de la quantité nécessaire pour avoir un résultat fiable
</LI><LI CLASS="li-itemize">soit, pour les grandes valeurs de <I>x</I>, utiliser un développement
asymptotique (en puissances de 1/<I>x</I>) de
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−<I>t</I><SUP>2</SUP></SUP>  <I>dt</I> </TD></TR>
</TABLE>
ainsi que 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−<I>t</I><SUP>2</SUP></SUP>  <I>dt</I> =</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>π </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE>
Le développement asymptotique
s’obtient par exemple en changeant de variable
<I>u</I>=<I>t</I><SUP>2</SUP> et en effectuant des intégrations par parties répétées
en intégrant <I>e</I><SUP>−<I>u</I></SUP> et en dérivant <I>u</I><SUP>−1/2</SUP> et ses dérivées
successives. Ce type de développement asymptotique a la propriété
inverse du développement en 0: les termes successifs commencent
par décroitre avant de croitre et de tendre vers l’infini. Il faut
donc arrêter le développement à un rang donné (dépendant de <I>x</I>)
et il est impossible d’obtenir une précision meilleure pour cette
valeur de <I>x</I> par un développement asymptotique (on parle parfois de
développement des astronomes).
</LI></UL><P><B>Exercice </B>: donner une valeur approchée de <I>f</I>(1) à 1<I>e</I>−16 près.
Combien de termes faut-il calculer dans la somme pour trouver
une valeur approchée de <I>f</I>(7) à 1<I>e</I>−16 près ? Comparer la valeur
de <I>f</I>(7) et la valeur absolue du plus grand terme de la série,
quelle est la perte de précision relative si on effectue les
calculs en virgule flottante ? Combien de chiffres significatifs
faut-il utiliser pour assurer une précision finale de 16 chiffres
en base 10 ? Calculer le développement asymptotique en l’infini
et déterminer un encadrement de <I>f</I>(7) par ce développement. Combien
de termes faut-il calculer pour déterminer <I>f</I>(10) à 1<I>e</I>−16 près
par le développement asymptotique et par le développement en séries ?
Quelle est la meilleure méthode pour calculer <I>f</I>(10) ?</P><!--TOC subsubsection Recherche de solutions d’équations différentielles-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc251">22.6.2</A>  Recherche de solutions d’équations différentielles</H4><!--SEC END --><P>
On peut aussi appliquer les techniques ci-dessus pour calculer
des solutions de certaines équations différentielles dont les
solutions ne s’expriment pas à l’aide des fonctions usuelles,
on remplace dans l’équation la fonction inconnue par son 
développement en séries et on cherche une relation de récurrence
entre <I>a</I><SUB><I>n</I>+1</SUB> et <I>a</I><SUB><I>n</I></SUB>. Si on arrive à montrer par exemple
qu’il y a une solution ayant un développement alternée, 
ou plus généralement,
si on a une majoration |<I>a</I><SUB><I>n</I>+1</SUB>/<I>a</I><SUB><I>n</I></SUB>|&lt;<I>C</I>, alors le reste de la
série entière est majoré par |<I>a</I><SUB><I>n</I></SUB><I>x</I><SUP><I>n</I></SUP>|/(1−|<I>Cx</I>|) lorsque
|<I>x</I>|&lt;1/<I>C</I>, on peut alors calculer des valeurs approchées
de la fonction solution à la précision souhaitée en utilisant
le développement en séries entières.</P><!--TOC subsubsection Exemple : fonctions de Bessel d’ordre entier-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc252">22.6.3</A>  Exemple : fonctions de Bessel d’ordre entier</H4><!--SEC END --><P><A NAME="@default303"></A>
Soit <I>m</I> un entier positif fixé, on considère l’équation
différentielle
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I><SUP>2</SUP> <I>y</I>′′ + <I>x</I> <I>y</I>′ + (<I>x</I><SUP>2</SUP>−<I>m</I><SUP>2</SUP>)<I>y</I>=0 </TD></TR>
</TABLE><P>
dont on cherche une solution série entière 
<I>y</I>=∑<SUB><I>k</I>=0</SUB><SUP>∞</SUP><I>a</I><SUB><I>k</I></SUB> <I>x</I><SUP><I>k</I></SUP> . En remplacant dans l’équation, si
<I>x</I> est dans le rayon de convergence de la série (rayon supposé
non nul), on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>k</I>(<I>k</I>−1)<I>a</I><SUB><I>k</I></SUB> <I>x</I><SUP><I>k</I></SUP> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>k</I> <I>a</I><SUB><I>k</I></SUB> <I>x</I><SUP><I>k</I></SUP> 
+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>x</I><SUP>2</SUP>−<I>m</I><SUP>2</SUP>) <I>a</I><SUB><I>k</I></SUB> <I>x</I><SUP><I>k</I></SUP> =0
</TD></TR>
</TABLE><P>
soit encore
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>0</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>k</I><SUP>2</SUP>−<I>m</I><SUP>2</SUP>+<I>x</I><SUP>2</SUP>) <I>a</I><SUB><I>k</I></SUB> <I>x</I><SUP><I>k</I></SUP>  </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−<I>m</I><SUP>2</SUP> <I>a</I><SUB>0</SUB> + (1−<I>m</I><SUP>2</SUP>)<I>a</I><SUB>1</SUB> <I>x</I> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=2</TD></TR>
</TABLE></TD><TD CLASS="dcell">[(<I>k</I><SUP>2</SUP>−<I>m</I><SUP>2</SUP>) <I>a</I><SUB><I>k</I></SUB> +<I>a</I><SUB><I>k</I>−2</SUB>]<I>x</I><SUP><I>k</I></SUP> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Par exemple, prenons le cas <I>m</I>=0. On a alors <I>a</I><SUB>0</SUB> quelconque, <I>a</I><SUB>1</SUB>
nul et pour <I>k</I>≥ 2
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>k</I></SUB> = − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUB><I>k</I>−2</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Donc tous les <I>a</I> d’indice impair sont nuls. Les pairs sont non nuls
si <I>a</I><SUB>0</SUB>≠ 0, et ils sont de signe alterné.
Soit <I>x</I> fixé, on observe que pour 2<I>k</I> &gt; |<I>x</I>|,
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>a</I><SUB>2<I>k</I></SUB> <I>x</I><SUP>2<I>k</I></SUP>| &lt; |<I>a</I><SUB>2<I>k</I>−2</SUB> <I>x</I><SUP>2<I>k</I>−2</SUP>| </TD></TR>
</TABLE><P>
donc la série ∑<SUB><I>k</I>=0</SUB><SUP>∞</SUP><I>a</I><SUB><I>k</I></SUB> <I>x</I><SUP><I>k</I></SUP> est alternée à partir
du rang partie entière de |<I>x</I>| plus un. Donc elle converge pour
tout <I>x</I> (le rayon de convergence de <I>y</I> est +∞) 
et le reste de la somme jusqu’à l’ordre 2<I>n</I> est
inférieur en valeur absolue à :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>R</I><SUB>2<I>n</I></SUB>(<I>x</I>)| ≤ |<I>a</I><SUB>2<I>n</I>+2</SUB> <I>x</I><SUP>2<I>n</I>+2</SUP>| </TD></TR>
</TABLE><P>
Par exemple, pour avoir une valeur approchée à 1<I>e</I>−10 près de
<I>y</I>(<I>x</I>) pour <I>a</I><SUB>0</SUB>=1 et |<I>x</I>|≤ 1, on calcule <I>y</I>=∑<SUB><I>k</I>=0</SUB><SUP>2<I>n</I></SUP> <I>a</I><SUB><I>k</I></SUB> <I>x</I><SUP><I>k</I></SUP> ,
on s’arrête au rang <I>n</I> tel que 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>a</I><SUB>2<I>n</I>+2</SUB> <I>x</I><SUP>2<I>n</I>+2</SUP>| ≤ |<I>a</I><SUB>2<I>n</I>+2</SUB>| ≤ 10<SUP>−10</SUP> </TD></TR>
</TABLE><P>
On remarque que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB>2<I>n</I></SUB> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(−1)<SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP>2</SUP> 4<SUP>2</SUP> ... (2<I>n</I>)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(−1)<SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP>2<I>n</I></SUP> <I>n</I>!<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
donc <I>n</I>=7 convient.</P><P>Pour <I>m</I> ≠ 0, on peut faire un raisonnement analogue (les
calculs sont un peu plus compliqués).</P><P>On a ainsi trouvé une solution <I>y</I><SUB>0</SUB> de l’équation
différentielle de départ dont on peut facilement calculer
une valeur approchée (aussi facilement que par exemple la fonction sinus
pour |<I>x</I>| ≤ 1), 
on peut alors trouver toutes les solutions de l’équation
différentielle (en posant <I>y</I>=<I>y</I><SUB>0</SUB> <I>z</I> et en cherchant <I>z</I>).</P><P><B>Exercice :</B> faire de même pour les solutions de
<I>y</I>′′−<I>xy</I>=0 (fonctions de Airy).</P><!--TOC subsection Développements asymptotiques et séries
divergentes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc253">22.7</A>  Développements asymptotiques et séries
divergentes</H3><!--SEC END --><P><A NAME="@default304"></A>
Un développement asymptotique est une généralisation d’un développement de Taylor, par exemple
lorsque le point de développement est en l’infini. De nombreuses fonctions ayant
une limite en l’infini admettent un développement asymptotique en l’infini, mais ces
développements sont souvent des séries qui semblent commencer par converger
mais sont divergentes. Ce type de développement s’avère néanmoins très utile lorsqu’on
n’a pas besoin d’une trop grande précision sur la valeur de la fonction.</P><P>Nous allons illustrer ce type de développement sur un exemple, la fonction 
<B>exponentielle intégrale</B><A NAME="@default305"></A><A NAME="@default306"></A>, 
définie à une constante près par
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>x</I>)=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP>−<I>t</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> </TD></TR>
</TABLE><P>
On peut montrer que l’intégrale existe bien, car l’intégrand est positif et inférieur à <I>e</I><SUP>−<I>t</I></SUP>
(qui admet −<I>e</I><SUP>−<I>t</I></SUP> comme primitive, cette primitive ayant une limite en +∞).
Pour trouver le développement asymptotique de <I>f</I> en +∞, on effectue des intégrations
par parties répétées, en intégrant l’exponentielle et en dérivant la fraction rationnelle
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>f</I>(<I>x</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">[</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−<I>e</I><SUP>−<I>t</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">]<SUB><I>x</I></SUB><SUP>+∞</SUP> − </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−<I>e</I><SUP>−<I>t</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">−<I>t</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP>−<I>x</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> − </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP>−<I>t</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP>−<I>x</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> − ([</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−<I>e</I><SUP>−<I>t</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">]<SUB><I>x</I></SUB><SUP>+∞</SUP> − </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−2<I>e</I><SUP>−<I>t</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">−<I>t</I><SUP>3</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">) </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP>−<I>x</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP>−<I>x</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>e</I><SUP>−<I>t</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>3</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>... </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>e</I><SUP>−<I>x</I></SUP></TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>3</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + ... + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(−1)<SUP><I>n</I></SUP> <I>n</I>!</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP><I>n</I>+1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
− </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(−1)<SUP><I>n</I></SUP> (<I>n</I>+1)!<I>e</I><SUP>−<I>t</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP><I>n</I>+2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>S</I>(<I>x</I>) + <I>R</I>(<I>x</I>)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
où
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:Eiinf"></A>
<I>S</I>(<I>x</I>)=<I>e</I><SUP>−<I>x</I></SUP>
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>3</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + ... + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(−1)<SUP><I>n</I></SUP> <I>n</I>!</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP><I>n</I>+1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">, 
   <I>R</I>(<I>x</I>)=− </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(−1)<SUP><I>n</I></SUP> (<I>n</I>+1)!<I>e</I><SUP>−<I>t</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP><I>n</I>+2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> 
    (56)</TD></TR>
</TABLE><P>
Le développement en séries est divergent puisque pour <I>x</I>&gt;0 fixé et <I>n</I> tendant vers l’infini
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">lim</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>→ +∞</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP><I>n</I>+1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = +∞</TD></TR>
</TABLE><P>
mais si <I>x</I> est grand, au début la série semble converger, de manière très rapide :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> &gt;&gt; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> &gt;&gt; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>3</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
On peut utiliser <I>S</I>(<I>x</I>) comme valeur approchée de <I>f</I>(<I>x</I>) pour <I>x</I> grand si on sait majorer
<I>R</I>(<I>x</I>) par un nombre suffisamment petit. On a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>R</I>(<I>x</I>) | ≤ </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!<I>e</I><SUP>−<I>t</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP><I>n</I>+2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!<I>e</I><SUP>−<I>x</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP><I>n</I>+2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
On retrouve une majoration du type de celle des séries alternées, 
l’erreur relative est inférieure
à la valeur absolue du dernier terme sommé divisé par <I>e</I><SUP>−<I>x</I></SUP>/<I>x</I>. 
Pour <I>x</I> fixé assez grand, il 
faut donc trouver un rang <I>n</I>, s’il en existe un, 
tel que (<I>n</I>+1)!/<I>x</I><SUP><I>n</I>+1</SUP>&lt;є où
є est la précision relative que l’on s’est fixée.
Par exemple, si <I>x</I>≥ 100, <I>n</I>=11 convient pour 
є=12!/100<SUP>12</SUP>=5<I>e</I>−16 (à peu près
la précision relative d’un “double”).
Ceci permet d’avoir une approximation de la fonction avec une bonne
précision et peu de calculs, mais contrairement aux séries entières,
il n’est pas possible d’améliorer cette précision de manière
arbitraire en poussant le développement plus loin, il y a une
précision maximale possible (qui dépend de <I>x</I>).</P><P>Ce type de développement asymptotique peut être effectué pour
d’autres fonctions du même type, par exemple
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−<I>t</I><SUP>2</SUP></SUP>  <I>dt</I>,    </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">sin(<I>t</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I>,    ... </TD></TR>
</TABLE><P><B>Digression: calcul approché de la constante d’Euler
</B><B>γ</B><A NAME="@default307"></A><BR>
On peut montrer que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:def_gamma"></A>
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">lim</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>→ +∞</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>u</I><SUB><I>n</I></SUB>,    <I>u</I><SUB><I>n</I></SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> − ln(<I>n</I>) 
    (57)</TD></TR>
</TABLE><P>
existe (par exemple en cherchant un équivalent de <I>u</I><SUB><I>n</I>+1</SUB>−<I>u</I><SUB><I>n</I></SUB> qui vaut 
−1/2<I>n</I><SUP>2</SUP>)
et on définit γ comme sa limite. Malheureusement, la convergence
est très lente et cette définition n’est pas applicable pour obtenir la valeur
de γ avec une très grande précision.
Il y a un lien entre γ et la fonction exponentielle intégrale, plus précisément
lorsque <I>x</I>→ 0, <I>f</I>(<I>x</I>) admet une singularité en −ln(<I>x</I>),
plus précisément <I>f</I>(<I>x</I>)+ln(<I>x</I>)
admet un développement en séries (de rayon de convergence +∞), car :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>f</I>(<I>x</I>)+ln(<I>x</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP>−<I>t</I></SUP>−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> + </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP>−<I>t</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP>−<I>t</I></SUP>−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> + </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP>−<I>t</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I>
− </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP>−<I>t</I></SUP>−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Que vaut la constante du membre de droite :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>C</I>=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>e</I><SUP>−<I>t</I></SUP>−1)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> + </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−<I>t</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> </TD></TR>
</TABLE><P>
Il se trouve que <I>C</I>=−γ (voir plus bas une démonstration condensée) et donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:gamma"></A>
γ= </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1−<I>e</I><SUP>−<I>t</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> −<I>f</I>(<I>x</I>)−ln(<I>x</I>)
    (58)</TD></TR>
</TABLE><P>
Pour obtenir une valeur approchée de γ, il suffit donc de prendre un <I>x</I> assez grand
pour pouvoir calculer <I>f</I>(<I>x</I>) par son développement asymptotique à la précision requise,
puis de calculer l’intégrale du membre de droite par le développement en séries en <I>x</I>=0
(en utilisant une précision intermédiaire plus grande puisque ce développement en séries
va sembler diverger au début avant de converger pour <I>n</I> suffisamment grand).
Par exemple, on pose <I>x</I>=13, on calcule <I>f</I>(13) par (<A HREF="#eq:Eiinf">56</A>)
avec <I>n</I>=13 (qui correspond au moment où le terme général
de la série est minimum puisque le rapport de deux termes successifs
est en <I>n</I>/<I>x</I>)
et une erreur absolue inférieure à <I>e</I><SUP>−13</SUP> 13!/13<SUP>14</SUP>=4<I>e</I>−12
</P><DIV CLASS="center">
<I>f</I>(13) ≈ <CODE>exp(-13)*sum((-1)^n*n!/13.^(n+1),n=0..13)</CODE>
</DIV><P>
puis on remplace dans (<A HREF="#eq:gamma">58</A>), avec 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>x</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1−<I>e</I><SUP>−<I>t</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> = 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (−1)<SUP><I>n</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP><I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1) (<I>n</I>+1)!</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
dont on obtient une valeur approchée, 
en faisant la somme jusqu’au rang 49 (pour lequel
le terme général est de l’ordre de <CODE>1e-12</CODE>),
le reste de cette somme <I>R</I><SUB>50</SUB> est positif et est inférieur à
<TT>(-1)</TT><CODE><TT>^</TT></CODE><TT>50*13.</TT><CODE><TT>^</TT></CODE><TT>51/51/51!)</TT> qui est de l’ordre de 
<CODE>8e-12</CODE>
</P><DIV CLASS="center">
<CODE>evalf(sum((-1)^n*13^(n+1)/(n+1)/(n+1)!,n=0..49))</CODE>
</DIV><P>
La somme argument de <CODE>evalf</CODE>
étant exacte, il n’y a pas de problèmes de perte de précision,
on peut aussi faire les calculs intermédiaires en arithmétique approchée,
on doit alors prendre 4 chiffres significatifs de plus
pour tenir compte de la valeur du plus grand terme
sommé dans la série, terme que l’on détermine par exemple par
</P><DIV CLASS="center">
<TT>seq(13.</TT><CODE><TT>^</TT></CODE><TT>(n+1)/(n+1)/(n+1)!,n=0..20)</TT>
</DIV><P> 
ce terme vaut <CODE>13^11/11/11!</CODE> soit 4000 environ)
</P><DIV CLASS="center">
<CODE>Digits:=16; sum((-1)^n*13.^(n+1)/(n+1)/(n+1)!,n=0..49)</CODE>
</DIV><P>
On obtient finalement comme valeur approchée de γ
</P><DIV CLASS="center">
<CODE>-exp(-13)*sum((-1)^n*n!/13.^(n+1),n=0..13)-ln(13)+</CODE><BR>
<CODE>  sum((-1)^n*13^(n+1)/(n+1)/(n+1)!,n=0..49)</CODE>
</DIV><P>
soit <CODE>0.577215664897</CODE> avec une erreur inférieure à <CODE>1.2e-11</CODE>.
Bien entendu, cette méthode est surtout intéressante si on veut calculer
un grand nombre de décimales de la constante d’Euler, sinon
on peut par exemple appliquer la méthode d’accélération de Richardson à
la suite convergente (<A HREF="#eq:def_gamma">57</A>) qui définit γ
ou d’autres méthodes d’accélération (en transformant par
exemple la série en série alternée). On calcule alors
de deux manières différentes <I>f</I>(<I>x</I>) pour <I>x</I> plus grand (déterminé
par la précision qu’on peut obtenir par le développement
aymptotique de <I>f</I>).</P><P>On peut calculer π de la même manière avec le développement 
en séries et asymptotique
de la fonction <B>sinus intégral</B><A NAME="@default308"></A><A NAME="@default309"></A> (on remplace exponentielle par sinus dans
la définition de <I>f</I>) et l’égalité (dont un schéma de preuve est aussi
donné plus bas)
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:Siinf"></A>
</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">sin(<I>t</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">
    (59)</TD></TR>
</TABLE><P><B>Calcul de </B><B><I>C</I></B><B> (et preuve de (</B><A HREF="#eq:Siinf"><B>59</B></A><B>))</B>:<BR>
Pour cela on effectue une intégration par parties, cette fois en intégrant 1/<I>t</I>
et en dérivant l’exponentielle (moins 1 dans la première intégrale).
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>C</I></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>e</I><SUP>−<I>t</I></SUP>−1)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> + </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−<I>t</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I></TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">[(<I>e</I><SUP>−<I>t</I></SUP>−1)ln(<I>t</I>)]<SUB>0</SUB><SUP>1</SUP> +</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ln(<I>t</I>) <I>e</I><SUP>−<I>t</I></SUP>  <I>dt</I> + [<I>e</I><SUP>−<I>t</I></SUP> ln(<I>t</I>)]<SUB>1</SUB><SUP>+∞</SUP>
+</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ln(<I>t</I>) <I>e</I><SUP>−<I>t</I></SUP>  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ln(<I>t</I>) <I>e</I><SUP>−<I>t</I></SUP>  <I>dt</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Pour calculer cette intégrale, on utilise
l’égalité (qui se démontre par récurrence en faisant une 
intégration par parties) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>n</I>!= </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>t</I><SUP><I>n</I></SUP> <I>e</I><SUP>−<I>t</I></SUP>  <I>dt</I> </TD></TR>
</TABLE><P>
On va à nouveau intégrer par parties,
on intègre un facteur multiplicatif 1 
et on dérive l’intégrand, on simplifie, puis
on intègre <I>t</I> et on dérive l’autre terme, puis <I>t</I><SUP>2</SUP>/2, etc. 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>C</I></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">[<I>te</I><SUP>−<I>t</I></SUP> ln(<I>t</I>)]<SUB>0</SUB><SUP>+∞</SUP> − </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>t</I> <I>e</I><SUP>−<I>t</I></SUP>(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">−ln(<I>t</I>))  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">0 − </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−<I>t</I></SUP>  <I>dt</I> + </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>t</I> <I>e</I><SUP>−<I>t</I></SUP> ln(<I>t</I>)  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−1 + [</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>e</I><SUP>−<I>t</I></SUP> ln(<I>t</I>)]<SUB>0</SUB><SUP>+∞</SUP> 
− </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−<I>t</I></SUP>(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">−ln(<I>t</I>))  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−1 − </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−<I>t</I></SUP> +  </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−<I>t</I></SUP> ln(<I>t</I>)  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−1 − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> +  </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−<I>t</I></SUP> ln(<I>t</I>)  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>...</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−1 − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> − ... −  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−<I>t</I></SUP> ln(<I>t</I>)  <I>dt</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−1 − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> − ... −  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + ln(<I>n</I>) + <I>I</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
où
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>I</I><SUB><I>n</I></SUB>=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I><SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−<I>t</I></SUP> (ln(<I>t</I>)−ln(<I>n</I>))  <I>dt</I> </TD></TR>
</TABLE><P>
Pour déterminer <I>I</I><SUB><I>n</I></SUB> on fait le changement de variables <I>t</I>=<I>nu</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>I</I><SUB><I>n</I></SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>nu</I>)<SUP><I>n</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−<I>nu</I></SUP> ln(<I>u</I>) <I>n</I> <I>du</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I><SUP><I>n</I>+1</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP><I>n</I>(<I>ln</I>(<I>u</I>)−<I>u</I>)</SUP> ln(<I>u</I>)  <I>du</I> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Or en faisant le même changement de variables <I>t</I>=<I>nu</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>n</I>!= </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>t</I><SUP><I>n</I></SUP> <I>e</I><SUP>−<I>t</I></SUP>  <I>dt</I> = <I>n</I><SUP><I>n</I>+1</SUP> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP><I>n</I>(<I>ln</I>(<I>u</I>)−<I>u</I>)</SUP>  <I>du</I>
</TD></TR>
</TABLE><P>
Donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>I</I><SUB><I>n</I></SUB>= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP><I>n</I>(<I>ln</I>(<I>u</I>)−<I>u</I>)</SUP> ln(<I>u</I>)  <I>du</I></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP><I>n</I>(<I>ln</I>(<I>u</I>)−<I>u</I>)</SUP>  <I>du</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD></TR>
</TABLE><P>
Lorsque <I>n</I> tend vers l’infini, on peut montrer que <I>I</I><SUB><I>n</I></SUB> → 0, en effet les intégrales
sont équivalentes à leur valeur sur un petit intervalle autour de <I>u</I>=1, point où l’argument
de l’exponentielle est maximal, 
et comme l’intégrand du numérateur a une amplitude ln(<I>u</I>) qui s’annule en <I>u</I>=1, 
il devient négligeable devant le dénominateur. Finalement on a bien <I>C</I>=−γ.</P><P>On peut remarquer qu’en faisant le même calcul que <I>C</I> 
mais en remplacant <I>e</I><SUP>−<I>t</I></SUP> par <I>e</I><SUP>−α <I>t</I></SUP> pour ℜ(α)&gt;0, donne
lim<I>I</I><SUB><I>n</I></SUB>=−ln(α) (car le point critique où la dérivée
de la phase s’annule est alors 1/α). Ceci peut aussi se vérifier
pour α réel en faisant le changement de variables α <I>t</I>=<I>u</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>e</I><SUP>−α <I>t</I></SUP>−1)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> + </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−α <I>t</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> 
= −γ −ln(α) </TD></TR>
</TABLE><P>
En faisant tendre α vers −<I>i</I>, −ln(α) 
tend vers ln(<I>i</I>)=<I>i</I>π/2 et on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>e</I><SUP><I>it</I></SUP>−1)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> + </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP><I>i</I> <I>t</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dt</I> 
= −γ + <I>i</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
dont la partie imaginaire nous donne (<A HREF="#eq:Siinf">59</A>), et la
partie réelle une autre identité sur γ faisant intervenir
la fonction cosinus intégral.</P><!--TOC section La transformée de Fourier discrète.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc254">23</A>  La transformée de Fourier discrète.</H2><!--SEC END --><P>
<A NAME="sec:dft"></A>
<A NAME="@default310"></A><A NAME="@default311"></A><A NAME="@default312"></A>
</P><!--TOC subsection Définition et propriétés-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc255">23.1</A>  Définition et propriétés</H3><!--SEC END --><P>
Soit <I>N</I> un entier fixé. Une suite <I>x</I> périodique de période <I>N</I> est
déterminée par le vecteur <I>x</I>=[<I>x</I><SUB>0</SUB>,<I>x</I><SUB>1</SUB>,...<I>x</I><SUB><I>N</I>−1</SUB>].
La transformée de Fourier discréte (DFT) notée <I>F</I><SUB><I>N</I></SUB> fait correspondre 
à une suite <I>x</I> périodique de période <I>N</I> une autre suite <I>y</I>
périodique de période <I>N</I>, définie pour <I>k</I>=0..<I>N</I>−1 par :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>F</I><SUB><I>N</I></SUB>(<I>x</I>))<SUB><I>k</I></SUB>=<I>y</I><SUB><I>k</I></SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>j</I></SUB> ω<SUB><I>N</I></SUB><SUP>−<I>k</I>· <I>j</I></SUP>,
</TD></TR>
</TABLE><P>
où ω<SUB><I>N</I></SUB> est une racine <I>N</I>-ième primitive de l’unité,
on prend ω=<I>e</I><SUP>2<I>i</I>π/<I>N</I></SUP> si <I>x</I> est à coefficients réels
ou complexes.</P><P>On observe que si la suite <I>x</I> est la suite des valeurs d’une fonction
périodique <I>f</I> sur une discrétisation de la période, alors
la transformée de Fourier discrète est la suite des valeurs approchées
des coefficients de Fourier obtenus en appliquant la méthode des
trapèzes sur cette discrétisation.</P><P>Cette transformation est linéaire, la transformée de la somme de 2
suites est la somme des transformées, et la transformée du produit
par une constante d’une suite 
est le produit par cette constante de la transformée
de la suite.</P><P>La transformée de Fourier discréte <I>F</I><SUB><I>N</I></SUB> est une transformation 
bijective dont la réciproque est donnée par :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I><SUB><I>N</I></SUB><SUP>−1</SUP>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>F</I><SUB><I>N</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">,   
(<I>F</I><SUB><I>N</I></SUB><SUP>−1</SUP>(<I>y</I>))<SUB><I>k</I></SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>y</I><SUB><I>j</I></SUB>ω<SUB><I>N</I></SUB><SUP><I>k</I>· <I>j</I></SUP>
</TD></TR>
</TABLE><P>
On le prouve en remplaçant <I>y</I> par sa valeur :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>(<I>F</I><SUB><I>N</I></SUB><SUP>−1</SUP>(<I>y</I>))<SUB><I>k</I></SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>l</I></SUB> ω<SUB><I>N</I></SUB><SUP>−<I>j</I>· <I>l</I></SUP>
ω<SUB><I>N</I></SUB><SUP><I>k</I>· <I>j</I></SUP> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>l</I></SUB> ω<SUB><I>N</I></SUB><SUP><I>j</I> (<I>k</I>−<I>l</I>)</SUP> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>l</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (ω<SUB><I>N</I></SUB><SUP>(<I>k</I>−<I>l</I>)</SUP>)<SUP><I>j</I></SUP> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>l</I></SUB> 
</TD><TD CLASS="dcell">⎧<BR>
⎪<BR>
⎪<BR>
⎨<BR>
⎪<BR>
⎪<BR>
⎩</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1−(ω<SUB><I>N</I></SUB><SUP>(<I>k</I>−<I>l</I>)</SUP>)<SUP><I>N</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1−ω<SUB><I>N</I></SUB><SUP>(<I>k</I>−<I>l</I>)</SUP></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>si</TD><TD ALIGN=left NOWRAP>ω<SUB><I>N</I></SUB><SUP>(<I>k</I>−<I>l</I>)</SUP>≠ 1 </TD></TR>
<TR><TD ALIGN=left NOWRAP><I>N</I></TD><TD ALIGN=center NOWRAP>si</TD><TD ALIGN=left NOWRAP>ω<SUB><I>N</I></SUB><SUP>(<I>k</I>−<I>l</I>)</SUP> = 1 </TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Or si ω<SUB><I>N</I></SUB><SUP><I>k</I>−<I>l</I></SUP>=<I>e</I><SUP>2<I>i</I>π(<I>k</I>−<I>l</I>)/<I>N</I></SUP>=1 si et seulement si <I>k</I>=<I>l</I>
d’où le résultat.</P><P><B>Propriété</B><BR>
La transformée de Fourier discrète d’une suite réelle vérifie
<I>y</I><SUB><I>N</I>−<I>k</I></SUB>=<SPAN style="text-decoration:overline"><I>y</I></SPAN><SUB><SPAN style="text-decoration:overline"><I>k</I></SPAN></SUB>.<BR>
La preuve est immédiate en appliquant la définition.</P><P>Un des intérêts de la DFT est de mettre en évidence rapidement
d’éventuelles périodicités de <I>x</I> divisant <I>N</I>. Plus précisément
soit <I>j</I> est un entier divisant <I>N</I>. Considérons une suite réelle <I>x</I> dont
la DFT <I>y</I> est nulle sauf <I>y</I><SUB><I>l</I></SUB> et <I>y</I><SUB><I>N</I>−<I>l</I></SUB>. Par linéarité, on
peut se ramener à 2 cas <I>y</I><SUB><I>l</I></SUB>=<I>y</I><SUB><I>N</I>−<I>l</I></SUB>=1 et <I>y</I><SUB><I>l</I></SUB>=<I>i</I>, <I>y</I><SUB><I>N</I>−<I>l</I></SUB>=−<I>i</I>. Dans
le premier cas, on obtient <I>x</I><SUB><I>k</I></SUB>=ω<SUB><I>N</I></SUB><SUP><I>lk</I></SUP>+ω<SUB><I>N</I></SUB><SUP>−<I>lk</I></SUP>=2cos(2π <I>kl</I>/<I>N</I>),
dans le deuxième cas, on obtient <I>x</I><SUB><I>k</I></SUB>=−2sin(2π <I>kl</I>/<I>N</I>), qui sont périodiques
de période <I>N</I>/<I>l</I>.</P><P>Réciproquement, si <I>x</I> a comme période <I>T</I>=<I>N</I>/<I>l</I>, alors en posant
<I>j</I>=<I>T</I> <I>m</I> + <I>r</I> avec <I>m</I>∈[0,<I>l</I>[ et <I>r</I>∈[0,<I>T</I>−1], on a
<I>x</I><SUB><I>j</I></SUB>=<I>x</I><SUB><I>r</I></SUB> donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>y</I><SUB><I>k</I></SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>j</I></SUB> ω<SUB><I>N</I></SUB><SUP>−<I>k</I>· <I>j</I></SUP> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>l</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>T</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>r</I></SUB> ω<SUB><I>N</I></SUB><SUP>−<I>k</I> (<I>T</I> <I>m</I>+<I>r</I>)</SUP> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>T</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>r</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>l</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ω<SUB><I>N</I></SUB><SUP>−<I>k</I> (<I>T</I> <I>m</I>+<I>r</I>)</SUP> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>T</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>r</I></SUB> ω<SUB><I>N</I></SUB><SUP>−<I>kr</I></SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>l</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell">
(ω<SUB><I>N</I></SUB><SUP>−<I>kT</I></SUP>)<SUP><I>m</I></SUP> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>T</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>r</I></SUB> ω<SUB><I>N</I></SUB><SUP>−<I>kr</I></SUP> 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1−(ω<SUB><I>N</I></SUB><SUP>−<I>kT</I></SUP>)<SUP><I>l</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1−ω<SUB><I>N</I></SUB><SUP>−<I>kT</I></SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
si ω<SUB><I>N</I></SUB><SUP>−<I>kT</I></SUP> ≠ 1. Comme (ω<SUB><I>N</I></SUB><SUP>−<I>kT</I></SUP>)<SUP><I>l</I></SUP>=ω<SUB><I>N</I></SUB><SUP>−<I>klT</I></SUP>=1,
<I>y</I><SUB><I>k</I></SUB>=0 si <I>kT</I>=<I>kN</I>/<I>l</I> n’est pas un multiple de <I>N</I>. 
Finalement si <I>k</I> n’est pas un multiple de <I>l</I>, alors <I>y</I><SUB><I>k</I></SUB>=0.</P><P>Voyons maintenant le cas de “pseudo-périodes”, supposons donc
que <I>x</I> est périodique de période <I>N</I> mais que de plus pour un <I>T</I>&gt;0 
quelconque (ne divisant pas forcément <I>N</I>), on ait
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I><SUB><I>j</I>+<I>T</I></SUB>=<I>x</I><SUB><I>j</I></SUB>,    ∀ <I>j</I> ∈[0,<I>N</I>−<I>T</I>] </TD></TR>
</TABLE><P>
On peut refaire le raisonnement ci-dessus, modulo des erreurs.
plus précisément :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I><SUB><I>k</I></SUB> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">ceil(<I>N</I>/<I>T</I>)<I>T</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=<I>N</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>x</I><SUB><I>j</I></SUB> ω<SUB><I>N</I></SUB><SUP>−<I>k</I>· <I>j</I></SUP> 
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">ceil(<I>N</I>/<I>T</I>)</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>T</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>r</I></SUB> ω<SUB><I>N</I></SUB><SUP>−<I>k</I> (<I>T</I> <I>m</I>+<I>r</I>)</SUP> </TD></TR>
</TABLE><P>
On calcule donc <I>y</I><SUB><I>k</I></SUB> à une erreur de ceil(<I>N</I>/<I>T</I>)<I>T</I>−<I>N</I> termes majorés
par |<I>x</I><SUB><I>j</I></SUB>| près.
Et le membre de droite vaudra :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>T</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>r</I></SUB> ω<SUB><I>N</I></SUB><SUP>−<I>kr</I></SUP> 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1−ω<SUB><I>N</I></SUB><SUP>−<I>k</I>ceil(<I>N</I>/<I>T</I>) <I>T</I></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1−ω<SUB><I>N</I></SUB><SUP>−<I>kT</I></SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Le module de la fraction est égal à
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">sin(π <I>k</I> ceil(<I>N</I>/<I>T</I>) <I>T</I>/<I>N</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">sin(π <I>k</I> <I>T</I>/<I>N</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |
= |</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">sin(π <I>k</I> (ceil(<I>N</I>/<I>T</I>) <I>T</I>/<I>N</I>−1))</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">sin(π <I>k</I> <I>T</I>/<I>N</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |
</TD></TR>
</TABLE><P>
il est petit si <I>k</I> n’est pas proche d’un multiple de ceil(<I>N</I>/<I>T</I>).
Par exemple, prenons <I>N</I>=2<SUP>1</SUP>6=65536 et <I>T</I> ≈ <I>N</I>/10 =6554. Dans
ce cas ceil(<I>N</I>/<I>T</I>)<I>T</I>=10 × 6554=65540, il y a donc une erreur
de 4 termes sur le calcul de <I>y</I><SUB><I>k</I></SUB>. Si <I>k</I> n’est pas proche d’un multiple
de 10, on doit trouver <I>y</I><SUB><I>k</I></SUB> proche de 0 relativement à la valeur des |<I>x</I><SUB><I>j</I></SUB>|.</P><P>Les périodes et pseudo-périodes de <I>x</I> correspondent donc aux
valeurs de <I>y</I><SUB><I>k</I></SUB> grandes par la règle <I>k</I> * période =<I>N</I>.</P><!--TOC subsection La transformée de Fourier rapide-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc256">23.2</A>  La transformée de Fourier rapide</H3><!--SEC END --><P><A NAME="@default313"></A>
<A NAME="@default314"></A><A NAME="@default315"></A>
Le calcul de la DFT est relativement lent, il nécessite de l’ordre
de <I>N</I><SUP>2</SUP> opérations, car il revient à calculer la valeur du polynôme
de degré <I>N</I>−1:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>X</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>−1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>j</I></SUB> <I>X</I><SUP><I>j</I></SUP> </TD></TR>
</TABLE><P>
aux <I>N</I> points 1, ω<SUB><I>N</I></SUB>, ..., ω<SUB><I>N</I></SUB><SUP><I>N</I>−1</SUP> 
(on a <I>y</I><SUB><I>k</I></SUB>=<I>P</I>(ω<SUB><I>N</I></SUB><SUP><I>k</I></SUP>)).
Mais si <I>N</I> est une puissance de 2, on peut calculer de manière plus
astucieuse et réduire le nombre d’opérations à un ordre <I>N</I> ln(<I>N</I>).
En effet <I>N</I>=2<I>M</I>,
on découpe <I>P</I> en 2 parties de même longueur :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>x</I>)=<I>x</I><SUP><I>M</I></SUP> <I>Q</I>(<I>X</I>) + <I>R</I>(<I>X</I>) </TD></TR>
</TABLE><P>
on a alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(ω<SUP>2<I>k</I></SUP>)= (<I>Q</I>+<I>R</I>) ((ω<SUP>2</SUP>)<SUP><I>k</I></SUP>),   
<I>P</I>(ω<SUP>2<I>k</I>+1</SUP>)= (−<I>Q</I> +<I>R</I>)<SUB>ω</SUB>((ω<SUP>2</SUP>)<SUP><I>k</I></SUP>)   
<I>S</I><SUB>ω</SUB>(<I>x</I>)=<FONT SIZE=6>∑</FONT><I>s</I><SUB><I>k</I></SUB> <I>w</I><SUP><I>k</I></SUP> <I>x</I><SUP><I>k</I></SUP>
</TD></TR>
</TABLE><P>
On est donc ramené à deux additions de 2 polynômes de degré <I>M</I>,
une multiplication coefficient par puissances (4<I>M</I> opérations),
et au calcul des deux DFT de <I>Q</I>+<I>R</I> et <I>R</I>−<I>Q</I>. Si <I>N</I>=2<SUP><I>n</I></SUP> on
vérifie que cela nécessite <I>O</I>(<I>n</I>2<SUP><I>n</I></SUP>) opérations, donc <I>N</I>ln(<I>N</I>)
opérations.
On appelle alors FFT cette méthode de calcul (DFT=FFT si <I>N</I>2<SUP><I>n</I></SUP>).
Elle se généralise à des <I>N</I> qui ne sont pas des puissances
de 2.</P><!--TOC subsection Applications.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc257">23.3</A>  Applications.</H3><!--SEC END --><P>
La DFT peut servir à trouver des périodes dans des données
expérimentales datées. On peut par exemple le voir sur
des enregistrements de son (par exemple avec le logiciel
libre <CODE>audacity</CODE>), mais dans bien d’autres
domaines, par exemple si on l’applique aux données
issues des paléoclimats, on voit apparaitre les périodicités
des paramètres orbitaux de la Terre, en phase avec la théorie
de Milankovitch.</P><P>En calcul exact, la FFT permet d’obtenir une complexité optimale
pour calculer des produits de grands entiers ou de polynômes
en une variable. Voir par exemple la session <CODE>multfft</CODE>du menu 
<CODE>Aide, Exemples, arit</CODE> de Xcas.</P><!--TOC section Le rayonnement solaire.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc258">24</A>  Le rayonnement solaire.</H2><!--SEC END --><P> <A NAME="sec:soleil"></A></P><!--TOC subsection L’insolation au cours de l’année.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc259">24.1</A>  L’insolation au cours de l’année.</H3><!--SEC END --><P> <A NAME="@default316"></A>
Pour connaitre la quantité d’énergie recue à un moment
donné, il faut calculer l’angle entre la verticale du lieu
et la direction du Soleil. Plus généralement, on va calculer
les composantes du vecteur Terre-Soleil et les composantes
des vecteurs de la base locale (verticale locale, direction du Sud et
direction du parallèle). On choisit d’abord comme référence
le plan <I>Txy</I> de l’écliptique (plan de l’orbite de la Terre
autour du Soleil), avec <I>Ty</I> orthogonal à l’axe de rotation 
de la Terre (donc <I>Tx</I> la projection de l’axe de rotation
de la Terre sur ce plan). Soit θ l’angle que fait la Terre
avec la direction du passage au périhélie, et θ<SUB>0</SUB>
l’angle de la position de la Terre au solstice d’hiver avec la
direction du périhélie, l’angle entre la direction Terre-Soleil
et <I>Tx</I> est donc θ−θ<SUB>0</SUB><BR>
Dans <I>Txyz</I> le vecteur unitaire <I>s</I>
de la direction Terre-Soleil a pour coordonnées :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>s</I>=−(cos(θ−θ<SUB>0</SUB>),sin(θ−θ<SUB>0</SUB>),0)</TD></TR>
</TABLE><P>
On effectue ensuite une rotation autour
de <I>Ty</I> d’angle <I>i</I> l’inclinaison de l’axe de rotation de la Terre.
On obtient ainsi un repère <I>TXyZ</I> (<I>TX</I> et <I>TZ</I> se déduisent de 
<I>Tx</I> et <I>Tz</I> par rotation d’angle <I>i</I>). Dans ce repère 
le vecteur untaire <I>s</I> a pour coordonnées :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>s</I>=−(cos(θ−θ<SUB>0</SUB>)cos(<I>i</I>),sin(θ−θ<SUB>0</SUB>),
cos(θ−θ<SUB>0</SUB>)sin(<I>i</I>)) </TD></TR>
</TABLE><P>
Calculons maintenant dans ce repère <I>TXyZ</I> les coordonnées
des vecteurs de la base locale. On se place en un point de latitude
<I>l</I> et de longitude φ, on note <I>J</I> la durée d’une période
de révolution de la Terre sur elle-même (23 heures 56 minutes,
c’est un peu moins d’un jour car il faut encore en moyenne 4 minutes
pour compenser le déplacement de la Terre sur son orbite autour
du Soleil). La verticale locale a pour coordonnées :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>v</I>=(cos(<I>l</I>)cos(φ+2π <I>t</I>/<I>J</I>),cos(<I>l</I>)sin(φ+2π <I>t</I>/<I>J</I>),sin(<I>l</I>))
</TD></TR>
</TABLE><P>
L’énergie solaire recue au lieu donné (sur une surface horizontale ;
pour un panneau solaire, il faudrait calculer les coordonnées d’un vecteur
perpendiculaire au panneau) est proportionnelle à
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>s</I>.<I>v</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ρ<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
où ρ(θ)=<I>a</I>(1−<I>e</I><SUP>2</SUP>)/(1+<I>e</I>cos(θ)) 
désigne la distance Terre-Soleil.
Le calcul de <I>s</I>.<I>v</I> donne, en notant ϕ=φ+2π <I>t</I>/<I>J</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">−<I>s</I>.<I>v</I>  =  cos(<I>l</I>) cos(ϕ) cos(θ−θ<SUB>0</SUB>)cos(<I>i</I>)
+ cos(<I>l</I>)sin(ϕ) sin(θ−θ<SUB>0</SUB>) 
+ sin(<I>l</I>) cos(θ−θ<SUB>0</SUB>)sin(<I>i</I>) </TD></TR>
</TABLE><P>
On rassemble les deux premiers termes qui dépendent rapidement
du temps par l’intermédiaire de ϕ
(le 3ème terme n’en dépend que par θ qui ne varie
que d’environ 1 degré pendant une journée)
et on applique la formule de trigonométrie:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I> cosα + <I>B</I> sinα = </TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I><SUP>2</SUP>+<I>B</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
cos(α−α<SUB>0</SUB>),    </TD><TD CLASS="dcell">⎧<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎨<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎩</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>cos(α<SUB>0</SUB>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>A</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I><SUP>2</SUP>+<I>B</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=center NOWRAP>sin(α<SUB>0</SUB>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I><SUP>2</SUP>+<I>B</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P> 
Ici, après avoir factorisé cos(<I>l</I>), on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I><SUP>2</SUP>+<I>B</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>
cos(θ−θ<SUB>0</SUB>)<SUP>2</SUP>cos(<I>i</I>)<SUP>2</SUP>+sin(θ−θ<SUB>0</SUB>)<SUP>2</SUP> </TD></TR>
</TABLE></TD><TD CLASS="dcell">
= </TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1 − sin(<I>i</I>)<SUP>2</SUP> cos(θ−θ<SUB>0</SUB>)<SUP>2</SUP> </TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
On peut aussi calculer 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">tan(α<SUB>0</SUB>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>A</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> =  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">tan(θ−θ<SUB>0</SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">cos(<I>i</I>)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
qui donne α<SUB>0</SUB> modulo π et compléter en regardant 
le quadrant où se trouve (<I>A</I>,<I>B</I>), ici α<SUB>0</SUB> et θ−θ<SUB>0</SUB> 
sont tous deux dans [0,π] ou tous deux dans [−π,0].
Finalement, on obtient le
</P><DIV CLASS="theorem"><B>Théorème 52</B>  <EM> </EM><A NAME="thm:soleil"></A><EM>
L’énergie solaire recue au sol est proportionnelle à
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>(1+<I>e</I></EM><EM>cos</EM><EM>(θ))</EM><SUP><EM>2</EM></SUP><EM> <I>s</I>.<I>v</I> </EM></TD></TR>
</TABLE><EM>
où </EM><EM><I>s</I>.<I>v</I></EM><EM> est donné par :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><I>s</I>.<I>v</I> = − </EM><EM>cos</EM><EM>(<I>l</I>) </EM></TD><TD CLASS="dcell"><EM><FONT SIZE=5>√</FONT></EM></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD ALIGN=center NOWRAP><EM>1 − </EM><EM>sin</EM><EM>(<I>i</I>)</EM><SUP><EM>2</EM></SUP><EM> </EM><EM>cos</EM><EM>(θ−θ</EM><SUB><EM>0</EM></SUB><EM>)</EM><SUP><EM>2</EM></SUP><EM> </EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>
</EM><EM>cos</EM><EM>(ϕ−ϕ</EM><SUB><EM>0</EM></SUB><EM>)
− </EM><EM>sin</EM><EM>(<I>l</I>) </EM><EM>cos</EM><EM>(θ−θ</EM><SUB><EM>0</EM></SUB><EM>)</EM><EM>sin</EM><EM>(<I>i</I>)
</EM></TD></TR>
</TABLE><EM>
et 
</EM><UL CLASS="itemize"><LI CLASS="li-itemize"><EM>
</EM><EM><I>e</I></EM><EM> est l’excentricité de l’orbite elliptique (environ
0.0167 actuellement)
</EM></LI><LI CLASS="li-itemize"><EM><I>i</I></EM><EM> est l’obliquité (inclinaison de l’axe de rotation de la Terre,
environ 23 degré 27 minutes actuellement)
</EM></LI><LI CLASS="li-itemize"><EM>θ</EM><EM> est l’angle fait par la direction Terre-Soleil avec la 
direction du demi grand axe (Soleil-périhélie), 
</EM><EM>θ</EM><SUB><EM>0</EM></SUB><EM> le même angle au solstice d’hiver
de l’hémisphère Nord (environ -13 degrés). En première 
approximation, on peut faire varier </EM><EM>θ</EM><EM> proportionnellement au temps,
voir la fin de la section </EM><A HREF="#sec:dureesaison"><EM>24.6</EM></A><EM> pour un calcul plus précis.
</EM></LI><LI CLASS="li-itemize"><EM><I>l</I></EM><EM> est la latitude, </EM><EM>ϕ</EM><EM> la longitude tenant compte
de la rotation de la Terre (somme de la longitude géographique </EM><EM>φ</EM><EM> et 
du terme dépendant du temps </EM><EM>2π <I>t</I>/<I>J</I></EM><EM>)
</EM></LI><LI CLASS="li-itemize"><EM>ϕ</EM><SUB><EM>0</EM></SUB><EM> ∈ [−π,π]</EM><EM> est de même signe que </EM><EM>θ−θ</EM><SUB><EM>0</EM></SUB><EM>
et est défini par :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM> </EM><A NAME="eq:culmination"></A><EM>
</EM><EM>tan</EM><EM>ϕ</EM><SUB><EM>0</EM></SUB><EM> = </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM>tan</EM><EM>(θ−θ</EM><SUB><EM>0</EM></SUB><EM>)</EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM>cos</EM><EM>(<I>i</I>)</EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> 
    (60)</EM></TD></TR>
</TABLE><EM>
</EM></LI></UL><EM>
</EM></DIV><P>
<B>Variations de </B><B><I>s</I>.<I>v</I></B><B> au cours d’une journée dans l’approximation où
</B><B>θ</B><B> ne varie pas</B> :<BR>
On obtient une sinusoide entre les deux valeurs extrêmes :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">± cos(<I>l</I>) </TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1 − sin(<I>i</I>)<SUP>2</SUP> cos(θ−θ<SUB>0</SUB>)<SUP>2</SUP> </TD></TR>
</TABLE></TD><TD CLASS="dcell"> −
sin(<I>l</I>) cos(θ−θ<SUB>0</SUB>)sin(<I>i</I>) </TD></TR>
</TABLE><P>
Le maximum est atteint pour 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ϕ=ϕ<SUB>0</SUB>+ π  ⇒  
2 π <I>t</I>/<I>J</I> = ϕ<SUB>0</SUB> − φ + π,    <I>J</I>=23<I>h</I>56<I>m</I> </TD></TR>
</TABLE><P>
le moment correspondant est appelé culmination (c’est le midi
solaire si le maximum est positif) et ne dépend pas de la latitude
(bien entendu la valeur du maximum en dépend).
Si le maximum est négatif ou nul, la nuit dure 24h.
Si le minimum est positif ou nul, le jour dure 24h.
Par exemple au solstice d’hiver, θ=θ<SUB>0</SUB>, selon la latitude
on obtient un maximum négatif pour <I>l</I>=π/2 (pole Nord), positif 
pour <I>l</I>=−π/2 (pole Sud), le minimum et le maximum croissent 
entre ces 2 valeurs.
Si le maximum est positif et le minimum est négatif, il y a
2 instants ou <I>s</I>.<I>v</I>=0 (lever et coucher du soleil).</P><P>L’énergie solaire recue pendant une journée par une surface
horizontale est proportionnelle à l’intégrale entre le lever
et le coucher de <I>s</I>.<I>v</I>/ρ<SUP>2</SUP>. S’il n’y a pas de lever/coucher, 
soit on ne recoit rien (nuit polaire),
soit on recoit l’intégrale entre 0 et 24h de <I>s</I>.<I>v</I> (jour polaire).</P><P>L’intervalle entre 2 culminations n’est pas constant au cours de
l’année, car ϕ<SUB>0</SUB> n’est pas une fonction linéaire de
θ (qui lui même n’est pas linéaire en fonction du temps
sauf en première approximation avec une orbite terrestre
circulaire). On peut le calculer en dérivant (<A HREF="#eq:culmination">60</A>).
Par exemple dans l’approximation d’une excentricité nulle,
au solstice d’hiver (θ=θ<SUB>0</SUB>), on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ϕ<SUB>0</SUB>= 0,    (1+0<SUP>2</SUP>) <I>d</I>ϕ<SUB>0</SUB> = (1+0<SUP>2</SUP>)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I>θ</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">cos(<I>i</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
avec <I>d</I>θ qui correspond à 4 minutes, on trouve <I>d</I>ϕ<SUB>0</SUB>
correspondant à 4.36 minutes.
L’écart entre 2 culminations
est donc d’environ 24h 20secondes. 
Au moment du solstice, le Soleil se lève et se couche donc environ
20 secondes plus tard entre un jour et son lendemain, dans 
l’hypothèse d’un mouvement circulaire de la Terre autour du Soleil. 
En réalité, l’orbite terrestre étant faiblement elliptique,
l’écart est un peu moins de 30 secondes en hiver et de 15 secondes en été, 
le mouvement de la Terre autour du Soleil étant plus rapide d’environ
3% au solstice d’hiver et moins rapide d’environ 3% au
solstice d’été. Comme 3%
de l’écart moyen entre 2 culminations (4 minutes=240 secondes) 
correspond à 7 secondes cela explique la différence.</P><!--TOC subsection Les saisons-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc260">24.2</A>  Les saisons</H3><!--SEC END --><P><A NAME="@default317"></A>
Les solstices sont définis par les 2 points de l’orbite où la projection
de l’axe de rotation terrestre est parallèle à l’axe Terre-Soleil.
Les équinoxes sont définis par les 2 points où il y a perpendicularité.
Au solstice d’hiver, on voit que les parallèles situés aux hautes latitudes
Nord ne sortent jamais de l’obscurité. Aux latitudes intérmédiaires,
le morceau de parallèle situé au jour est nettement plus petit que
celui situé dans l’obscurité.
À l’équinoxe de printemps, chaque parallèle est à moitié au jour
et à moitié dans l’obscurité (derrière la grille). Au printemps,
la situtation est analogue.
Au solstice d’été, on est dans la situation inverse de l’hiver.</P><!--TOC subsection L’orbite de la Terre.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc261">24.3</A>  L’orbite de la Terre.</H3><!--SEC END --><P><A NAME="@default318"></A>
En première approximation, l’orbite de la Terre est uniquement
influencée par la force de gravitation entre la Terre et le Soleil,
ce dernier pouvant être considéré comme fixe en raison de sa masse
(on peut éviter cette approximation en remplaçant le Soleil par
le centre de gravité du système Terre-Soleil).
La force de gravitation qui dérive d’un potentiel inversement
proportionnel à la distance Terre-Soleil est de la forme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><B><I>F</I>′</B>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><B><I>F</I></B></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I><SUB><I>T</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">= <I>K</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><B><I>r</I></B></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><B><I>r</I></B><SUP><B>3</B></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">,    <I>K</I>=−µ&lt;0</TD></TR>
</TABLE><P>
où <B><I>r</I></B> désigne le vecteur Terre-Soleil, <I>m</I><SUB><I>T</I></SUB> est la masse
de la Terre, µ=<I>Gm</I><SUB><I>S</I></SUB> est le produit de la constante
de gravitation universelle par la masse du Soleil.
Le moment cinétique de la rotation de la Terre autour du Soleil
est défini par :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><B><I>L</I></B> = <B><I>r</I></B> ∧ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I> <B><I>r</I></B></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><B><I>dt</I></B></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
On vérifie que sa dérivée est nulle, donc <B><I>L</I></B> garde
une direction fixe <B>k</B>, orthogonale à <B><I>r</I></B>,
l’orbite de la Terre reste donc dans le plan défini à un instant
donné par l’axe Terre-Soleil et le vecteur vitesse de la Terre.
De plus la conservation de <B>L</B> entraine 
la loi des aires, l’aire balayée par le rayon Soleil-Terre
est proportionnelle au temps.</P><P>On utilise un repère en coordonnées polaires centré au Soleil,
ρ désignant la distance Terre-Soleil et θ l’angle
fait par rapport à une direction fixe, on a alors
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><B><I>L</I></B> = ρ<SUP>2</SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I>θ</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <B><I>k</I></B></TD></TR>
</TABLE><P>
car si on calcule en coordonnées polaires <I>d</I> <B><I>r</I></B>/<I>dt</I>,
la composante sur le vecteur radial <B><I>e</I></B><SUB><B><I>r</I></B></SUB> est <I>d</I>ρ/<I>dt</I>, et
la composante sur le vecteur perpendiculaire <B><I>e</I></B><SUB><B>θ</B></SUB>
est ρ <I>d</I>θ/<I>dt</I>.</P><!--TOC subsubsection Calcul en utilisant le vecteur excentricité.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc262">24.3.1</A>  Calcul en utilisant le vecteur excentricité.</H4><!--SEC END --><P><A NAME="@default319"></A>
Montrons que le vecteur
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><B><I>E</I></B>= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">µ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><B><I>dr</I></B></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><B><I>dt</I></B></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ∧ <B><I>L</I></B> − 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><B><I>r</I></B></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><B>ρ</B></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
est aussi conservé (où on rappelle que µ provient
de la force de gravitation <B><I>F</I>′</B>=<B><I>F</I></B>/<I>m</I><SUB><I>T</I></SUB>=−µ <B><I>r</I></B>/<I>r</I><SUP>3</SUP>).
Le deuxième terme est proportionnel au vecteur
radial −<B><I>e</I></B><SUB><B><I>r</I></B></SUB>, dont la dérivée est le vecteur orthogonal
−<I>d</I>θ/<I>dt</I> <B><I>e</I></B><SUB><B>θ</B></SUB>.
Comme <B><I>L</I></B> est constant, la dérivée du premier terme est
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">µ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <B><I>F</I>′</B> ∧ <B><I>L</I></B> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><B>−<I>e</I></B><SUB><B><I>r</I></B></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><B>ρ</B><SUP><B>2</B></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ∧ <I>L</I> <B><I>k</I></B>
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ρ<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <B><I>e</I></B><SUB><B>θ</B></SUB> = − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I>θ</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ρ<SUP>2</SUP></TD></TR>
</TABLE><P>Notons que <B><I>E</I></B> est dans le plan de l’orbite, prenons comme origine
des angles pour repérer la Terre par rapport au Soleil la direction
de <B><I>E</I></B>. En faisant le produit scalaire de <B><I>E</I></B> avec <B><I>r</I></B>, 
on obtient en notant <I>e</I> la norme de <I>E</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>e</I> ρ cos(θ)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><B><I>E</I></B>.<B><I>r</I></B> </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">µ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><B><I>dr</I></B></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><B><I>dt</I></B></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ∧ <B><I>L</I></B>− 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><B><I>r</I></B></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><B>ρ</B></TD></TR>
</TABLE></TD><TD CLASS="dcell">) .<B><I>r</I></B> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">µ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><B><I>dr</I></B></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><B><I>dt</I></B></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ∧ <B><I>L</I></B>).<B><I>r</I></B>
− ρ </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">µ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<B><I>r</I></B> ∧  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><B><I>dr</I></B></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><B><I>dt</I></B></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ).<B><I>L</I></B> − ρ </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">µ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <B><I>L</I></B>.<B><I>L</I></B>− ρ </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>L</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">µ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> − ρ</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
d’où :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ρ = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>L</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">µ(1+<I>e</I> cos(θ))</TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsubsection Calcul par l’équation différentielle.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc263">24.3.2</A>  Calcul par l’équation différentielle.</H4><!--SEC END --><P>
On a les équations de conservation de l’énergie et du moment cinétique :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>K</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ρ</TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>m</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I>ρ</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">2</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">
+ </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">ρ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I>θ</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">2</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
=<I>C</I><SUB>1</SUB>,    ρ<SUP>2</SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I>θ</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = <I>L</I>,    <I>K</I>&lt;0, <I>m</I>&gt;0
</TD></TR>
</TABLE><P>
On change de variable dépendante pour ρ, 
en prenant θ au lieu de <I>t</I>,
comme <I>d</I>ρ/<I>dt</I>=ρ′ <I>d</I>θ/<I>dt</I> 
(où ρ′=<I>d</I>ρ/<I>d</I>θ), on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>K</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ρ</TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>m</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">(ρ′<SUP>2</SUP>+ρ<SUP>2</SUP>) 
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>L</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ρ<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">2</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">= <I>C</I><SUB>1</SUB>
</TD></TR>
</TABLE><P>
On effectue ensuite le changement de variable ρ=1/<I>u</I>, ρ′=−<I>u</I>′/ <I>u</I><SUP>2</SUP>,
d’où :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>K</I> <I>u</I> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>m</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I>′<SUP>2</SUP> </TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUP>4</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><I>L</I><SUP>2</SUP> <I>u</I><SUP>4</SUP> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
= <I>C</I><SUB>1</SUB>
</TD></TR>
</TABLE><P>
soit :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>K</I> <I>u</I> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>mL</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ( <I>u</I>′<SUP>2</SUP>+<I>u</I><SUP>2</SUP>) = <I>C</I><SUB>1</SUB> </TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>K</I>′ <I>u</I> + <I>u</I><SUP>2</SUP> + <I>u</I>′<SUP>2</SUP> = <I>C</I><SUB>3</SUB>,    
<I>K</I>′=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>K</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>mL</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> &lt;0, <I>C</I><SUB>3</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>C</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>mL</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On pose maintenant <I>v</I>=<I>u</I>+<I>K</I>′/2, d’où :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>v</I><SUP>2</SUP> + <I>v</I>′<SUP>2</SUP> = <I>C</I><SUB>3</SUB> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>K</I>′<SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
</TABLE></TD><TD CLASS="dcell"> = <I>C</I><SUB>4</SUB> </TD></TR>
</TABLE><P>
On montre (en exprimant <I>v</I>′ en fonction de <I>v</I> puis en séparant les
variables), que cette équation différentielle a pour solution générale
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>v</I>= </TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>C</I><SUB>4</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> cos(θ−θ<SUB>0</SUB>) </TD></TR>
</TABLE><P>
D’où :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ρ = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>u</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> =
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>v</I>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>K</I>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>C</I><SUB>4</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> cos(θ−θ<SUB>0</SUB>)−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>K</I>′</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Comme <I>K</I>′&lt;0 et comme la trajectoire de la Terre autour du Soleil
passe par tous les angles (donc ρ est défini pour tout θ,
le dénominateur ne peut pas s’annuler), on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ρ = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">−<I>K</I>′</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+<I>e</I> cos(θ−θ<SUB>0</SUB>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">,    <I>e</I> ∈ [0,1[ </TD></TR>
</TABLE><P>
On définit ensuite <I>a</I> par 2/−<I>K</I>′=<I>a</I>(1−<I>e</I><SUP>2</SUP>), et on obtient finalement
l’équation d’une ellipse dont l’origine (le Soleil) est un des
foyers :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ρ = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I>(1−<I>e</I><SUP>2</SUP>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+<I>e</I> cos(θ−θ<SUB>0</SUB>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
On suppose maintenant quitte à faire pivoter l’axe des <I>x</I> que
θ<SUB>0</SUB>=0.</P><!--TOC subsubsection Lois de Képler.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc264">24.3.3</A>  Lois de Képler.</H4><!--SEC END --><P><A NAME="@default320"></A>
L’orbite de la Terre est donc une ellipse dont le Soleil occupe un des foyers
(1ère loi de Képler).
On a aussi vu que <I>L</I>=ρ<SUP>2</SUP> <I>d</I>θ/<I>dt</I> est constant, ceci entraine la loi
des aires, infinitésimalement on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">ρ<SUP>2</SUP> <I>d</I>θ = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>L</I> <I>dt</I> </TD></TR>
</TABLE><P>
ce qui se traduit par
l’aire balayée par le rayon vecteur Soleil-Terre est proportionnelle
au temps (2ème loi de Képler). 
Au cours d’une période <I>T</I>, l’aire parcourue est celle
de l’ellipse, donc 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">π <I>a</I><SUP>2</SUP> </TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>e</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>LT</I> </TD></TR>
</TABLE><P>
En prenant le carré, et en appliquant
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>L</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">µ</TD></TR>
</TABLE></TD><TD CLASS="dcell">= <I>a</I>(1−<I>e</I><SUP>2</SUP>)</TD></TR>
</TABLE><P>
on en déduit la troisième loi de Képler :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">4π<SUP>2</SUP> <I>a</I><SUP>3</SUP> = µ <I>T</I><SUP>2</SUP> ⇔ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>T</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">µ</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4π<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
où on rappelle que µ est le produit de la constante de gravitation
universelle par la masse du Soleil. (On peut évidemment faire
le même calcul pour la Lune autour de la Terre).</P><!--TOC subsection Quelques propriétés de l’ellipse-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc265">24.4</A>  Quelques propriétés de l’ellipse</H3><!--SEC END --><P><A NAME="@default321"></A>
<B>Définition</B><BR>
L’ellipse <I>E</I> de foyers <I>F</I><SUB>1</SUB> et <I>F</I><SUB>2</SUB> de demi-grand axe
<I>a</I> est l’ensemble des points <I>M</I> du plan tels que 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>MF</I><SUB>1</SUB>+<I>MF</I><SUB>2</SUB>=2<I>a</I></TD></TR>
</TABLE><P>On note 2<I>c</I>=<I>F</I><SUB>1</SUB><I>F</I><SUB>2</SUB> la distance entre les deux foyers, qui doit être
plus petite que 2<I>a</I> pour que l’ellipse soit non vide.
L’excentricité de l’ellipse est définie par <I>e</I>=<I>c</I>/<I>a</I> &lt; 1. Si <I>e</I>=0,
on obtient un cercle de centre <I>F</I><SUB>1</SUB>=<I>F</I><SUB>2</SUB> et de rayon <I>a</I>. Si <I>e</I>≠ 0,
on va voir qu’il s’agit d’un cercle contracté
selon l’axe perpendiculaire à <I>F</I><SUB>1</SUB><I>F</I><SUB>2</SUB> dans un rapport de 
√<SPAN style="text-decoration:overline">1−<I>e</I></SPAN><SUP><SPAN style="text-decoration:overline">2</SPAN></SUP>. On va également calculer l’équation en
coordonnées polaires de <I>E</I> pour montrer que l’équation obtenue
ci-dessus est bien celle d’une ellipse dont le Soleil occupe un foyer.</P><P>Soit <I>O</I> le milieu de <I>F</I><SUB>1</SUB> et <I>F</I><SUB>2</SUB>, on se place dans le repère orthonormé
dont le premier axe <I>Ox</I> contient <I>F</I><SUB>1</SUB> et <I>F</I><SUB>2</SUB> donc les
coordonnées de <I>F</I><SUB>1</SUB> sont (<I>c</I>,0) et celles de <I>F</I><SUB>2</SUB> sont (−<I>c</I>,0). 
Soit <I>M</I>(<I>x</I>,<I>y</I>) un
point de l’ellipse, on a d’une part :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>MF</I><SUB>1</SUB><SUP>2</SUP> − <I>MF</I><SUB>2</SUB><SUP>2</SUP> = (<I>x</I>−<I>c</I>)<SUP>2</SUP>−(<I>x</I>+<I>c</I>)<SUP>2</SUP> = −4<I>cx</I> </TD></TR>
</TABLE><P>
et d’autre part :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>MF</I><SUB>1</SUB><SUP>2</SUP> − <I>MF</I><SUB>2</SUB><SUP>2</SUP> = (<I>MF</I><SUB>1</SUB> + <I>MF</I><SUB>2</SUB>)(<I>MF</I><SUB>1</SUB> − <I>MF</I><SUB>2</SUB> ) = 2<I>a</I> (<I>MF</I><SUB>1</SUB> − <I>MF</I><SUB>2</SUB> )</TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>MF</I><SUB>1</SUB> − <I>MF</I><SUB>2</SUB> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−2<I>cx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
en additionnant avec <I>MF</I><SUB>1</SUB>+<I>MF</I><SUB>2</SUB>=2<I>a</I> et en appliquant <I>c</I>=<I>ea</I>, on en déduit :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:MF1bis"></A>
<I>MF</I><SUB>1</SUB> = <I>a</I> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>cx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = <I>a</I>−<I>ex</I> 
    (61)</TD></TR>
</TABLE><P>
En prenant le carré, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>x</I>−<I>ea</I>)<SUP>2</SUP> + <I>y</I><SUP>2</SUP> = (<I>a</I>−<I>ex</I>)<SUP>2</SUP></TD></TR>
</TABLE><P>
d’où :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I><SUP>2</SUP> + <I>x</I><SUP>2</SUP> (1−<I>e</I><SUP>2</SUP>) = <I>a</I><SUP>2</SUP>(1−<I>e</I><SUP>2</SUP>) </TD></TR>
</TABLE><P>
finalement :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I><SUP>2</SUP> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1−<I>e</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = <I>a</I><SUP>2</SUP> </TD></TR>
</TABLE><P>
qui est bien la contraction selon <I>Oy</I> de rapport √<SPAN style="text-decoration:overline">1−<I>e</I></SPAN><SUP><SPAN style="text-decoration:overline">2</SPAN></SUP> du
cercle de centre <I>O</I> et de rayon <I>a</I> (appelé grand cercle de
l’ellipse).</P><P>En coordonnées polaires, on note ρ la distance de <I>F</I><SUB>1</SUB> à
<I>M</I>, et θ l’angle entre l’axe <I>Ox</I> et <I>F</I><SUB>1</SUB><I>M</I>. L’abscisse de <I>M</I>
est donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>= <I>ea</I> + ρ cos(θ)</TD></TR>
</TABLE><P>
que l’on combine avec (<A HREF="#eq:MF1">15</A>) pour obtenir :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ρ = <I>a</I>−<I>ex</I> =<I>a</I>(1−<I>e</I><SUP>2</SUP>) − <I>e</I> ρ cos(θ) </TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ρ = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I>(1−<I>e</I><SUP>2</SUP>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+<I>e</I>cos(θ)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
ce qui nous permet d’affirmer que l’orbite de la Terre dans
l’approximation du point matériel soumis uniquement au Soleil
supposé fixe est une ellipse dont le Soleil occupe un foyer.</P><!--TOC subsection Influence de l’ellipse sur les saisons-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc266">24.5</A>  Influence de l’ellipse sur les saisons</H3><!--SEC END --><P>
Il faut prendre garde à ne pas confondre les solstices et
équinoxes avec le moment où la Terre coupe le grand axe
de son ellipse autour du Soleil. Il n’y a aucune raison que la
projection de l’axe de rotation de la Terre sur le plan de l’ellipse
soit parallèle ou perpendiculaire au grand axe de l’ellipse, et
actuellement ce n’est pas le cas, le solstice d’hiver a lieu le
21 décembre alors que le passage au plus proche du Soleil a lieu
vers le 3 janvier (donc pendant l’hiver de l’hémisphère Nord)
et le passage au plus loin du Soleil a lieu début juillet
(pendant l’été). C’est pour cette raison que les saisons
sont moins marquées dans l’hémisphère Nord que dans 
l’hémisphère Sud. De plus la loi des aires oblige la Terre
a se déplacer plus vite lorsqu’elle est proche du Soleil que
lorsqu’elle en est éloignée ce qui diminue la durée de l’hiver
boréal et augmente la durée de l’été boréal (c’est
peut-être pour cette raison que février n’a que 
28 jours alors que juillet et aout ont 31 jours).</P><!--TOC subsection L’équation du temps, la durée des
saisons.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc267">24.6</A>  L’équation du temps, la durée des
saisons.</H3><!--SEC END --><P> <A NAME="sec:dureesaison"></A>
<A NAME="@default322"></A> <A NAME="@default323"></A>
</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV> <A NAME="fig:ell"></A>
<IMG SRC="algo001.png">
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 1: Ellipse et équation du temps</TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>
La trajectoire elliptique <I>E</I> de la Terre autour du Soleil est
représentée sur la figure <A HREF="#fig:ell">24.6</A>
en bleu, l’excentricité de l’orbite a été énormément exagérée, il
s’agit d’une ellipse de foyers <I>S</I> (le Soleil) et <I>S</I>′. Le point <I>A</I> désigne
le périhélie de l’orbite (passage de la Terre au plus proche du Soleil), 
qui a lieu
vers le 4 janvier. En noir, on a dessiné le grand cercle de l’ellipse
(l’ellipse s’obtient par contraction du grand cercle de rapport √<SPAN style="text-decoration:overline">1−<I>e</I></SPAN><SUP><SPAN style="text-decoration:overline">2</SPAN></SUP>
où <I>e</I> est l’excentricité de l’orbite).
L’aire décrite par le rayon Soleil-Terre (<I>ST</I>)
est proportionnelle au temps (loi des aires qui découle de la conservation
du moment cinétique), 
il en est donc de même de l’aire (en vert) du
décrite par le rayon <I>SM</I>. Si on ajoute à cette aire verte l’aire en 
rouge du triangle <I>OSM</I>, on obtient l’aire de l’arc de cercle <I>OAM</I>.
Donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>V</I> × <I>OA</I><SUP>2</SUP> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>OS</I> × <I>HM</I> </TD></TR>
</TABLE><P>
est proportionnel au temps écoulé depuis le passage au périhélie.
Comme <I>HM</I>=<I>OM</I> sin(<I>V</I>) et <I>OS</I>= <I>e</I> × <I>OA</I>, on en déduit que 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:tempsV"></A>
<I>V</I> − <I>e</I> sin(<I>V</I>) = <I>C</I> <I>t</I> = 2π </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>T</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">
    (62)</TD></TR>
</TABLE><P>
où la constante <I>C</I> s’obtient en faisant varier <I>V</I> de 0 à 2π
ce qui correspond à la durée <I>T</I> d’une révolution de la Terre 
autour du Soleil (1 an).</P><P>La relation entre θ (noté <I>t</I> sur la figure)
et <I>V</I> s’obtient par exemple en calculant 
l’abscisse de <I>M</I> 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>x</I></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>a</I> cos(<I>V</I>) </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>ea</I> + ρ cos(θ) </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>ea</I> + <I>a</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1−<I>e</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+<I>e</I>cos(θ)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> cos(θ)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Les angles <I>V</I> et θ sont de même signe et
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:Vt"></A>
cos(<I>V</I>) = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">cos(θ)+<I>e</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+<I>e</I>cos(θ)</TD></TR>
</TABLE></TD><TD CLASS="dcell">
    (63)</TD></TR>
</TABLE><P>
et réciproquement :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:tV"></A>
cos(θ)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">cos(<I>V</I>)−<I>e</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1−<I>e</I> cos(<I>V</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
    (64)</TD></TR>
</TABLE><P><B>Durée des saisons </B>:<BR>
Il suffit de connaitre l’angle θ lors du solstice d’hiver et
de lui ajouter <I>k</I>π/2 pour <I>k</I>=1,2,3 pour connaitre l’angle θ
au printemps, en été et à l’automne, on en déduit <I>V</I> par (<A HREF="#eq:Vt">63</A>) 
puis le temps écoulé depuis le périhélie avec (<A HREF="#eq:tempsV">62</A>).</P><P><B>Calcul de </B><B>θ</B><B> en fonction du temps écoulé depuis le passage
au périhélie</B> :<BR>
Il faut calculer <I>V</I> par des méthodes numériques (point fixe ou 
méthode de Newton) en appliquant (<A HREF="#eq:tempsV">62</A>), on en déduit
θ avec (<A HREF="#eq:tV">64</A>).
En résumé, on a le :
</P><DIV CLASS="theorem"><B>Théorème 53</B>  <EM>
Soit </EM><EM>θ</EM><EM> l’angle entre le demi grand axe de l’ellipse et 
la direction Soleil-Terre, </EM><EM><I>t</I>∈ [−<I>T</I>/2,<I>T</I>/2]</EM><EM> le temps écoulé depuis le passage
au périhélie (</EM><EM><I>t</I>=0</EM><EM> lorsque </EM><EM>θ=0</EM><EM>, </EM><EM><I>T</I>=1</EM><EM> an). Soit </EM><EM><I>V</I>∈ [−π,π]</EM><EM> 
la solution de 
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><I>V</I> − <I>e</I> </EM><EM>sin</EM><EM>(<I>V</I>) = 2π </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>t</I></EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><I>T</I></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> </EM></TD></TR>
</TABLE><EM>
où </EM><EM><I>e</I></EM><EM> est l’excentricité de l’ellipse.
Alors </EM><EM>θ</EM><EM> est donné par
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>cos</EM><EM>(θ)=</EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM>cos</EM><EM>(<I>V</I>)−<I>e</I></EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM>1−<I>e</I> </EM><EM>cos</EM><EM>(<I>V</I>)</EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>  </EM></TD></TR>
</TABLE><EM>
</EM></DIV><!--TOC subsection Les variations des paramètres orbitaux-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc268">24.7</A>  Les variations des paramètres orbitaux</H3><!--SEC END --><P>
La Terre n’est pas une sphère idéale, elle a un renflement au niveau
de l’équateur, due à rotation de la Terre sur elle-même (la force
centrifuge y est plus importante). Ce renflement est dans un plan
qui fait un angle avec le plan de l’écliptique, le Soleil exerce
donc un couple sur ce renflement. Ce phénomène est à l’origine
de la précession des équinoxes, le passage au périhélie de la Terre
se décale dans le temps.
De plus, la Terre n’est pas seulement soumise à l’influence du Soleil,
mais aussi des autres planètes, en particulier Jupiter. Cela
modifie sur de très longues périodes tous les paramètres
de l’orbite terrestre, en particulier l’excentricité, la précession
des équinoxes, mais aussi l’obliquité (inclinaison de l’axe de
rotation terrestre par rapport à la perpendiculaire au plan de
l’écliptique).
Le calcul de ces variations est bien au-delà des prétentions de ce texte,
le lecteur intéressé pourra se référer par exemple aux publications
de Laskar (chercher ce mot-clef ou des mots comme orbite,
perturbation, symplectique, hamiltonien, ...). On se bornera ici
à indiquer que le demi-grand axe ne varie pas, ce qui donne
une relation entre les variations de la constante des aires et 
de l’excentricité 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>L</I>  est proportionnel à  </TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>e</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Les variations des paramètre orbitaux
modifient à long terme l’ensolleillement de la Terre (la valeur
de l’énergie reçue en un lieu sur une surface horizontale <I>s</I>.<I>v</I>/ρ<SUP>2</SUP>
dépend de la latitude, de la position de la Terre sur son orbite
mais aussi de l’excentricité de l’orbite, de l’obliquité
et de la date du périhélie par rapport aux saisons) et
sa répartition sur le globe par latitude, il est naturel de supposer
qu’elles influent sur le climat de la Terre.
Par exemple, l’énergie moyenne recue par la Terre au cours d’une
période <I>T</I> de une année est donnée par
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>T</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>T</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ρ<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>T</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">2π</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I>θ</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>L</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2 π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>T</I> <I>L</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD></TR>
</TABLE><P>
est proportionnelle à 1/(<I>T</I> <I>L</I>) donc à (1−<I>e</I><SUP>2</SUP>)<SUP>−1/2</SUP> (car
<I>T</I> est aussi constant d’après la 3ème loi de Képler).
Au premier ordre, la variation de <I>e</I> entraine donc une variation de 
l’ensolleillement global de
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>2</SUP></TD></TR>
</TABLE><P>
Pour la Terre, cela représente au plus 2.5 pour mille (la période
la plus favorable aux glaciations étant celle où l’orbite est
circulaire), soit, sans rétroactions, une variation globale
de 0.2 degrés Kelvin.</P><!--TOC section La moyenne arithmético-géométrique.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc269">25</A>  La moyenne arithmético-géométrique.</H2><!--SEC END --><P>
<A NAME="sec:agm"></A>
<A NAME="@default324"></A>
La moyenne arithmético-géométrique est un processus itératif
qui converge très rapidement et est très utile pour calculer
les fonctions transcendantes réciproques en multi-précision. 
On peut alors trouver les fonctions transcendantes directes
par application de la méthode de Newton.</P><!--TOC subsection Définition et convergence-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc270">25.1</A>  Définition et convergence</H3><!--SEC END --><P>
Soient <I>a</I> et <I>b</I> deux réels positifs,
on définit les 2 suites 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:agm"></A>
<I>u</I><SUB>0</SUB>=<I>a</I>, <I>v</I><SUB>0</SUB>=<I>b</I>,    <I>u</I><SUB><I>n</I>+1</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I></SUB>+<I>v</I><SUB><I>n</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">, <I>v</I><SUB><I>n</I>+1</SUB>=</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>u</I><SUB><I>n</I></SUB><I>v</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
    (65)</TD></TR>
</TABLE><P>
On va montrer que ces 2 suites sont adjacentes et convergent donc vers
une limite commune notée <I>M</I>(<I>a</I>,<I>b</I>) et il se trouve que la convergence
est très rapide, en raison de l’identité :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:agm1"></A>
<I>u</I><SUB><I>n</I>+1</SUB>−<I>v</I><SUB><I>n</I>+1</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">(</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>u</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">−</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>v</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>2</SUP>
=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">2(</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>u</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>v</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>u</I><SUB><I>n</I></SUB>−<I>v</I><SUB><I>n</I></SUB>)<SUP>2</SUP>
    (66)</TD></TR>
</TABLE><P>
la convergence est quadratique.</P><P>On suppose dans la suite que <I>a</I>≥ <I>b</I> sans changer la généralité puisque échanger <I>a</I> et <I>b</I>
ne change pas la valeur de <I>u</I><SUB><I>n</I></SUB> et <I>v</I><SUB><I>n</I></SUB> pour <I>n</I>&gt;0. On a alors <I>u</I><SUB><I>n</I></SUB> ≥ <I>v</I><SUB><I>n</I></SUB> 
(d’après (<A HREF="#eq:agm1">66</A>) pour <I>n</I>&gt;0) et <I>u</I><SUB><I>n</I>+1</SUB> ≤ <I>u</I><SUB><I>n</I></SUB> car
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I>+1</SUB>−<I>u</I><SUB><I>n</I></SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>v</I><SUB><I>n</I></SUB>−<I>u</I><SUB><I>n</I></SUB>) ≤ 0</TD></TR>
</TABLE><P>
et <I>v</I><SUB><I>n</I>+1</SUB>=√<SPAN style="text-decoration:overline"><I>u</I></SPAN><SUB><SPAN style="text-decoration:overline"><I>n</I></SPAN></SUB><SPAN style="text-decoration:overline"><I>v</I></SPAN><SUB><SPAN style="text-decoration:overline"><I>n</I></SPAN></SUB> ≥ √<SPAN style="text-decoration:overline"><I>v</I></SPAN><SUB><SPAN style="text-decoration:overline"><I>n</I></SPAN></SUB><SPAN style="text-decoration:overline"><I>v</I></SPAN><SUB><SPAN style="text-decoration:overline"><I>n</I></SPAN></SUB>=<I>v</I><SUB><I>n</I></SUB>. Donc (<I>u</I><SUB><I>n</I></SUB>) est décroissante 
minorée (par <I>v</I><SUB>0</SUB>), (<I>v</I><SUB><I>n</I></SUB>) est croissante majorée (par <I>u</I><SUB>0</SUB>), ces 2 suites sont 
convergentes et comme <I>u</I><SUB><I>n</I>+1</SUB>=<I>u</I><SUB><I>n</I></SUB>+<I>v</I><SUB><I>n</I></SUB>/2, elles convergent vers la même limite 
<I>l</I> qui dépend de <I>a</I> et <I>b</I> et que l’on note <I>M</I>(<I>a</I>,<I>b</I>).
On remarque aussi que <I>M</I>(<I>a</I>,<I>b</I>)=<I>bM</I>(<I>a</I>/<I>b</I>,1)=<I>aM</I>(1,<I>b</I>/<I>a</I>). </P><P>Précisons maintenant la vitesse de convergence lorsque <I>a</I> ≥ <I>b</I>&gt;0. 
On va commencer par estimer le nombre
d’itérations nécessaires pour que <I>u</I><SUB><I>n</I></SUB> et <I>v</I><SUB><I>n</I></SUB> soient du même ordre de grandeur.
Pour cela, on utilise la majoration
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ln(<I>u</I><SUB><I>n</I>+1</SUB>)−ln(<I>v</I><SUB><I>n</I>+1</SUB>) ≤ ln(<I>u</I><SUB><I>n</I></SUB>)−ln(<I>v</I><SUB><I>n</I>+1</SUB>) = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">
(ln(<I>u</I><SUB><I>n</I></SUB>)−ln(<I>v</I><SUB><I>n</I></SUB>)) </TD></TR>
</TABLE><P>
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">ln</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = ln(<I>u</I><SUB><I>n</I></SUB>)−ln(<I>v</I><SUB><I>n</I></SUB>) ≤ 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP><I>n</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (ln(<I>a</I>)−ln(<I>b</I>)) = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP><I>n</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ln</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>b</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
Donc si <I>n</I> ≥ ln( ln(<I>a</I>/<I>b</I>)/<I>m</I>)/ln(2) alors
ln<I>u</I><SUB><I>n</I></SUB>/<I>v</I><SUB><I>n</I></SUB> ≤ <I>m</I> (par exemple, on peut prendre <I>m</I>=0.1 pour 
avoir <I>u</I><SUB><I>n</I></SUB>/<I>v</I><SUB><I>n</I></SUB> ∈ [1,<I>e</I><SUP>0.1</SUP>]). Le nombre minimum d’itérations <I>n</I><SUB>0</SUB> est proportionnel
au log du log du rapport <I>a</I>/<I>b</I>.
Ensuite on est ramené à étudier la convergence de la suite arithmético-géométrique
de premiers termes <I>a</I>=<I>u</I><SUB><I>n</I><SUB>0</SUB></SUB> et <I>b</I>=<I>v</I><SUB><I>n</I><SUB>0</SUB></SUB> et même en tenant compte
de <I>M</I>(<I>a</I>,<I>b</I>)=<I>aM</I>(1,<I>b</I>/<I>a</I>) à <I>a</I>=1 et <I>b</I>=<I>v</I><SUB><I>n</I></SUB>/<I>u</I><SUB><I>n</I></SUB> donc 0≤ <I>a</I>−<I>b</I> ≤ 1−<I>e</I><SUP>−0.1</SUP>.
Alors l’équation (<A HREF="#eq:agm1">66</A>) entraine 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I>+1</SUB>−<I>v</I><SUB><I>n</I>+1</SUB> ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">8</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>u</I><SUB><I>n</I></SUB>−<I>v</I><SUB><I>n</I></SUB>)<SUP>2</SUP> </TD></TR>
</TABLE><P>
puis (par récurrence)
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">0 ≤ <I>u</I><SUB><I>n</I></SUB>−<I>v</I><SUB><I>n</I></SUB> ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">8<SUP>2<SUP><I>n</I></SUP>−1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>a</I>−<I>b</I>)<SUP>2<SUP><I>n</I></SUP></SUP> </TD></TR>
</TABLE><P>
Donc comme <I>M</I>(<I>a</I>,<I>b</I>) est compris entre <I>v</I><SUB><I>n</I></SUB> et <I>u</I><SUB><I>n</I></SUB>, l’erreur relative sur la limite
commune est inférieure à une précision donnée є
au bout d’un nombre d’itérations proportionnel au ln(ln(1/є)).</P><P>Typiquement dans la suite, on souhaitera calculer <I>M</I>(1,<I>b</I>) avec <I>b</I> de l’ordre
de 2<SUP>−<I>n</I></SUP> en déterminant <I>n</I> chiffres significatifs,
il faudra alors <I>O</I>(ln(<I>n</I>)) itérations pour se ramener à <I>M</I>(1,<I>b</I>) avec <I>b</I>∈ [<I>e</I><SUP>−0.1</SUP>,1] 
puis <I>O</I>(ln(<I>n</I>)) itérations pour avoir la limite avec <I>n</I> chiffres significatifs.</P><P><B>Le cas complexe</B><BR>
On suppose maintenant que <I>a</I>, <I>b</I> ∈ ℂ avec ℜ(<I>a</I>)&gt;0, ℜ(<I>b</I>)&gt;0. On va voir que
la suite arithmético-géométrique converge encore.<BR>
<B>Étude de l’argument</B><BR>
On voit aisément (par récurrence)
que ℜ(<I>u</I><SUB><I>n</I></SUB>)&gt;0 ; de plus ℜ(<I>v</I><SUB><I>n</I></SUB>) &gt; 0 car par définition de la racine carrée
ℜ(<I>v</I><SUB><I>n</I></SUB>)≥ 0 et est de plus non nul car le produit de deux complexes d’arguments dans 
]−π/2,π/2[ ne peut pas être un réel négatif.
On en déduit que
arg(<I>u</I><SUB><I>n</I>+1</SUB>)=arg(<I>u</I><SUB><I>n</I></SUB>+<I>v</I><SUB><I>n</I></SUB>) se trouve dans l’intervalle de bornes
arg(<I>u</I><SUB><I>n</I></SUB>) et arg(<I>v</I><SUB><I>n</I></SUB>) et que arg(<I>v</I><SUB><I>n</I>+1</SUB>)=1/2(arg(<I>u</I><SUB><I>n</I></SUB>)+arg(<I>v</I><SUB><I>n</I></SUB>))
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| arg(<I>u</I><SUB><I>n</I>+1</SUB>−arg(<I>v</I><SUB><I>n</I>+1</SUB>) | ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">|arg(<I>u</I><SUB><I>n</I></SUB>)−arg(<I>v</I><SUB><I>n</I></SUB>)| </TD></TR>
</TABLE><P>
Après <I>n</I> itérations, on a 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|arg(<I>u</I><SUB><I>n</I></SUB>)−arg(<I>v</I><SUB><I>n</I></SUB>)| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP><I>n</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
Après quelques itérations, <I>u</I><SUB><I>n</I></SUB> et <I>v</I><SUB><I>n</I></SUB> seront donc presque alignés. 
Faisons 4 itérations.
On peut factoriser par exemple <I>v</I><SUB><I>n</I></SUB> et on
est ramené à l’étude de la suite de termes initiaux <I>a</I>=<I>u</I><SUB><I>n</I></SUB>/<I>v</I><SUB><I>n</I></SUB> d’argument 
arg(<I>u</I><SUB><I>n</I></SUB>)−arg(<I>v</I><SUB><I>n</I></SUB>) petit 
(inférieur en valeur absolue à π/16) et <I>b</I>=1. On suppose donc dans la suite que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|arg(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">)| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π/16</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP><I>n</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
<B>Étude du module</B><BR>
On a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I>+1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>n</I>+1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
Posons  <I>u</I><SUB><I>n</I></SUB>/<I>v</I><SUB><I>n</I></SUB>=ρ<SUB><I>n</I></SUB> <I>e</I><SUP><I>i</I>θ<SUB><I>n</I></SUB></SUP>, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I>+1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>n</I>+1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">|</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP><I>i</I>θ<SUB><I>n</I></SUB>/2</SUP>
+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I><SUP>−<I>i</I>θ<SUB><I>n</I></SUB>/2</SUP> </TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD><TD CLASS="dcell">(</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">)cos</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">θ<SUB><I>n</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">
+ <I>i</I> (</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">− </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">)sin</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">θ<SUB><I>n</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:6em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> (</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=0 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=0 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>2</SUP>cos<SUP>2</SUP></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">θ<SUB><I>n</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">
+ (</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=0 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">− </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=0 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>2</SUP>sin<SUP>2</SUP></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">θ<SUB><I>n</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> ρ<SUB><I>n</I></SUB>+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> +2cosθ<SUB><I>n</I></SUB> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Si ρ désigne le max de ρ<SUB><I>n</I></SUB> et 1/ρ<SUB><I>n</I></SUB>, on a alors la majoration
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I>+1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>n</I>+1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP> ρ + ρ + 2 ρ </TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
= </TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>ρ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
donc en prenant les logarithmes
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:lnrhon"></A>
lnρ<SUB><I>n</I>+1</SUB> ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">  lnρ=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">  |lnρ<SUB><I>n</I></SUB>| 
    (67)</TD></TR>
</TABLE><P>
On rappelle qu’on a la majoration 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|arg(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">)| = |θ<SUB><I>n</I></SUB>| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π/16</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP><I>n</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP><I>n</I>+1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
qui va nous donner la minoration de ρ<SUB><I>n</I>+1</SUB> 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">ρ<SUB><I>n</I>+1</SUB>=|</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>u</I><SUB><I>n</I>+1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>n</I>+1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">|</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> ρ<SUB><I>n</I></SUB>+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> +2 − 2 (1−cosθ<SUB><I>n</I></SUB>) </TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> ρ<SUB><I>n</I></SUB>+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> +2 − 4 sin<SUP>2</SUP> (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">θ<SUB><I>n</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">) </TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≥</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> ρ<SUB><I>n</I></SUB>+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> +2 − θ<SUB><I>n</I></SUB><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≥</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> ρ<SUB><I>n</I></SUB>+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> +2</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> × 
</TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:8em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">1 − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">θ<SUB><I>n</I></SUB><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">ρ<SUB><I>n</I></SUB>+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ρ<SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> +2</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≥</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ρ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ρ</TD></TR>
</TABLE></TD><TD CLASS="dcell"> +2</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ρ</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> × 
</TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">1 − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">θ<SUB><I>n</I></SUB><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≥</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>ρ</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">1 − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">θ<SUB><I>n</I></SUB><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≥</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>ρ</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">1 − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4 × 2<SUP>2<I>n</I>+2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
en prenant les log et en minorant ln(1−<I>x</I>) par −2<I>x</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">lnρ<SUB><I>n</I>+1</SUB> ≥ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (−|lnρ<SUB><I>n</I></SUB>|+ln(1 −</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4 × 2<SUP>2<I>n</I>+2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ))
≥ −</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (|lnρ<SUB><I>n</I></SUB>|+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP>2<I>n</I>+3</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> )  </TD></TR>
</TABLE><P>
Finalement avec (<A HREF="#eq:lnrhon">67</A>)
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|lnρ<SUB><I>n</I>+1</SUB>|
≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (|lnρ<SUB><I>n</I></SUB>|+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP>2<I>n</I>+3</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ) </TD></TR>
</TABLE><P>
On en déduit
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|lnρ<SUB><I>n</I></SUB>| ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP><I>n</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> lnρ<SUB>0</SUB> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP><I>n</I>+3</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + ... +
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP>2<I>n</I>+1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> +  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP>2<I>n</I>+2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP><I>n</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> lnρ<SUB>0</SUB> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<SUP><I>n</I>+2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
La convergence du ln(<I>u</I><SUB><I>n</I></SUB>/<I>v</I><SUB><I>n</I></SUB>) vers 0 est donc géométrique, donc <I>u</I><SUB><I>n</I></SUB> et <I>v</I><SUB><I>n</I></SUB> convergent
quadratiquement.</P><!--TOC subsection Lien avec les intégrales elliptiques-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc271">25.2</A>  Lien avec les intégrales elliptiques</H3><!--SEC END --><P><A NAME="@default325"></A>
Le calcul de la limite commune des suites <I>u</I><SUB><I>n</I></SUB> et <I>v</I><SUB><I>n</I></SUB> en fonction
de <I>a</I> et <I>b</I> n’est pas trivial
au premier abord. Il est relié aux intégrales elliptiques, plus
précisément on peut construire une intégrale dépendant
de deux paramètres <I>a</I> et <I>b</I> et qui est invariante par
la transformation <I>u</I><SUB><I>n</I></SUB>,<I>v</I><SUB><I>n</I></SUB> → <I>u</I><SUB><I>n</I>+1</SUB>,<I>v</I><SUB><I>n</I>+1</SUB> (<A HREF="#eq:agm">65</A>)
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>I</I>(<I>a</I>,<I>b</I>)=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">−∞</TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>(<I>a</I><SUP>2</SUP>+<I>t</I><SUP>2</SUP>)(<I>b</I><SUP>2</SUP>+<I>t</I><SUP>2</SUP>)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On a en effet
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>I</I>(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I>+<I>b</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">,</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>ab</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)
= </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">−∞</TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>du</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">((</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I>+<I>b</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>2</SUP>+<I>u</I><SUP>2</SUP>)(<I>ab</I>+<I>u</I><SUP>2</SUP>)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
On pose alors 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>t</I>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>ab</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>t</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">),    <I>t</I>&gt;0 </TD></TR>
</TABLE><P>
où <I>t</I> → <I>u</I> est une bijection croissante de <I>t</I>∈]0,+∞[ vers 
<I>u</I> ∈ ]−∞,+∞[, donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>I</I>(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I>+<I>b</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">,</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>ab</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dt</I>/2(1+<I>ab</I>/<I>t</I><SUP>2</SUP>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">((</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I>+<I>b</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>2</SUP>+1/4(<I>t</I>−<I>ab</I>/<I>t</I>)<SUP>2</SUP>)(<I>ab</I>+1/4(<I>t</I>−<I>ab</I>/<I>t</I>)<SUP>2</SUP>)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">2 </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>(<I>a</I><SUP>2</SUP>+<I>t</I><SUP>2</SUP>)(<I>b</I><SUP>2</SUP>+<I>t</I><SUP>2</SUP>)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
= <I>I</I>(<I>a</I>,<I>b</I>)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On note au passage que <I>I</I> est définie si <I>a</I>,<I>b</I> ∈ ℂ vérifient ℜ(<I>a</I>)&gt;0, ℜ(<I>b</I>)&gt;0,
on peut montrer que la relation ci-dessus s’étend (par holomorphie).</P><P>Lorsque <I>a</I>=<I>b</I>=<I>l</I> (par exemple lorsqu’on est à la limite), 
le calcul de <I>I</I>(<I>l</I>,<I>l</I>) est explicite
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>I</I>(<I>l</I>,<I>l</I>)=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">−∞</TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dt</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>l</I><SUP>2</SUP>+<I>t</I><SUP>2</SUP>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>I</I>(<I>a</I>,<I>b</I>)=<I>I</I>(<I>M</I>(<I>a</I>,<I>b</I>),<I>M</I>(<I>a</I>,<I>b</I>))=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>M</I>(<I>a</I>,<I>b</I>)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On peut transformer <I>I</I>(<I>a</I>,<I>b</I>) en posant <I>t</I>=<I>bu</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>I</I>(<I>a</I>,<I>b</I>)=2</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>du</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>(<I>a</I><SUP>2</SUP>+<I>b</I><SUP>2</SUP><I>u</I><SUP>2</SUP>)(1+<I>u</I><SUP>2</SUP>)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">+∞</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>du</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>(1+(<I>b</I>/<I>a</I>)<SUP>2</SUP><I>u</I><SUP>2</SUP>)(1+<I>u</I><SUP>2</SUP>)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
Puis en posant <I>u</I>=tan(<I>x</I>) (<I>du</I>=(1+<I>u</I><SUP>2</SUP>) <I>dx</I>)
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>I</I>(<I>a</I>,<I>b</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1+tan(<I>x</I>)<SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+(<I>b</I>/<I>a</I>)<SUP>2</SUP>tan(<I>x</I>)<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dx</I> </TD></TR>
</TABLE><P>
et enfin en posant tan<SUP>2</SUP>(<I>x</I>)=sin(<I>x</I>)<SUP>2</SUP>/1−sin(<I>x</I>)<SUP>2</SUP>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>I</I>(<I>a</I>,<I>b</I>)= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell">  
</TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:8em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">1−(1−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>b</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">)sin(<I>x</I>)<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dx</I></TD></TR>
</TABLE><P>
Si on définit pour <I>m</I>&lt;1
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>K</I>(<I>m</I>)=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>m</I> sin(<I>x</I>)<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
alors on peut calculer <I>K</I> en fonction de <I>I</I>, en posant
<I>m</I>=1−<I>b</I><SUP>2</SUP>/<I>a</I><SUP>2</SUP> soit <I>b</I><SUP>2</SUP>/<I>a</I><SUP>2</SUP>=1−<I>m</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>K</I>(<I>m</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>I</I>(<I>a</I>,<I>a</I></TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I>(<I>a</I>,<I>a</I></TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">2<I>M</I>(1,</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD></TR>
</TABLE><P>
d’où l’on déduit la valeur de l’intégrale elliptique en fonction
de la moyenne arithmético-géométrique :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:K"></A>
<I>K</I>(<I>m</I>)=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>m</I> sin(<I>x</I>)<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">= 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">2<I>M</I>(1,</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
    (68)</TD></TR>
</TABLE><P>
Dans l’autre sens, pour <I>x</I> et <I>y</I> positifs
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>K</I>( (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I>−<I>y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+<I>y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>2</SUP> )=  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">2<I>M</I>(1,</TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">1−(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I>−<I>y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+<I>y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
=  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">2<I>M</I>(1,</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+<I>y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>xy</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">2 </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+<I>y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>M</I>(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+<I>y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">,</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>xy</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">) </TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+<I>y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>M</I>(<I>x</I>,<I>y</I>)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
et finalement
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I>(<I>x</I>,<I>y</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+<I>y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> <I>K</I></TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I>−<I>y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+<I>y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">2</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> )</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Application : calcul efficace du logarithme.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc272">25.3</A>  Application : calcul efficace du logarithme.</H3><!--SEC END --><P><A NAME="@default326"></A>
On peut utiliser la moyenne arithmético-géométrique pour
calculer le logarithme efficacement, pour cela on cherche le développement
asymptotique de <I>K</I>(<I>m</I>) lorsque <I>m</I> tend vers 1. Plus précisément,
on va poser 1−<I>m</I>=<I>k</I><SUP>2</SUP> avec <I>k</I> ∈ ]0,1], donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>K</I>(<I>m</I>)= </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dx</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−(1−<I>k</I><SUP>2</SUP>) sin(<I>x</I>)<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dy</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−(1−<I>k</I><SUP>2</SUP>) cos(<I>y</I>)<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
en posant <I>y</I>=π/2−<I>x</I>, et
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>K</I>(<I>m</I>)=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dy</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>sin(<I>y</I>)<SUP>2</SUP>+<I>k</I><SUP>2</SUP> cos(<I>y</I>)<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
la singularité de l’intégrale pour <I>k</I> proche
de 0 apparait lorsque <I>y</I> est proche de 0.
Si on effectue un développement de Taylor en <I>y</I>=0, on trouve
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">sin(<I>y</I>)<SUP>2</SUP>+<I>k</I><SUP>2</SUP> cos(<I>y</I>)<SUP>2</SUP> = <I>k</I><SUP>2</SUP> + (1−<I>k</I><SUP>2</SUP>) <I>y</I><SUP>2</SUP> + <I>O</I>(<I>y</I><SUP>4</SUP>)</TD></TR>
</TABLE><P>
Il est donc naturel de comparer <I>K</I>(<I>m</I>) à l’intégrale
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>J</I>=</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>dy</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>k</I><SUP>2</SUP> + (1−<I>k</I><SUP>2</SUP>) <I>y</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
qui se calcule en faisant par exemple le changement de variables
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>k</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> sinh(<I>t</I>)</TD></TR>
</TABLE><P>
ou directement avec Xcas, 
</P><DIV CLASS="center">
<CODE>supposons(k&gt;0 &amp;&amp; k&lt;1);</CODE><BR>
<CODE>J:=int(1/sqrt(k^2+(1-k^2)*y^2),y,0,pi/2)</CODE>
</DIV><P>
qui donne après réécriture :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:J"></A>
<I>J</I>= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>k</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">ln</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">+
ln</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> 1−<I>k</I><SUP>2</SUP> +4 </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">π<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
+</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>k</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
    (69)</TD></TR>
</TABLE><P>
et on peut calculer le développement asymptotique de <I>J</I> en 0
</P><DIV CLASS="center">
<CODE>series(J,k=0,5,1)</CODE>
</DIV><P>
qui renvoie :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>J</I> =ln</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">+<I>O</I>( </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ln(<I>k</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">5</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE><P>
on peut alors préciser ce développement par
</P><DIV CLASS="center">
<CODE>series(J+ln(k)-ln(pi),k=0,5,1)</CODE>
</DIV><P>
qui renvoie (après simplifications et où la notation Õ peut contenir des logarithmes)
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">π<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">ln(π)−ln(<I>k</I>)−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><I>k</I><SUP>2</SUP> + 
Õ(<I>k</I><SUP>4</SUP>)</TD></TR>
</TABLE><P>
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
<I>J</I>=−ln(<I>k</I>)+ln(π)+</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">π<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">ln(π)−ln(<I>k</I>)−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><I>k</I><SUP>2</SUP> + Õ(<I>k</I><SUP>4</SUP>)
    (70)</TD></TR>
</TABLE><P>
Examinons maintenant <I>K</I>−<I>J</I>, il n’a plus de singularité en <I>y</I>=0, et il admet une limite
lorsque <I>k</I> → 0, obtenue en remplacant <I>k</I> par 0
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>K</I>−<I>J</I>)<SUB>|<I>k</I>=0</SUB> = </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">sin(<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
 <I>dy</I> = </TD><TD CLASS="dcell">⎡<BR>
⎢<BR>
⎢<BR>
⎣</TD><TD CLASS="dcell">ln</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">tan</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">− ln(<I>y</I>) </TD><TD CLASS="dcell">⎤<BR>
⎥<BR>
⎥<BR>
⎦</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> =
ln(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE><P>
D’où pour <I>K</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>K</I><SUB><I>k</I> → 0</SUB> = ln</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">+ <I>O</I>( </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">ln(<I>k</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">5</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE><P>
Pour préciser la partie du développement de <I>K</I> en puissances de <I>k</I>, nous allons
majorer <I>K</I>−<I>J</I>−ln(4/π), puis <I>J</I>−ln(π/<I>k</I>).
Posons
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=sin(<I>y</I>)<SUP>2</SUP>+<I>k</I><SUP>2</SUP> cos(<I>y</I>)<SUP>2</SUP>,    <I>B</I>=<I>y</I><SUP>2</SUP>+(1−<I>y</I><SUP>2</SUP>)<I>k</I><SUP>2</SUP></TD></TR>
</TABLE><P>
<B>Majoration de </B><B><I>K</I>−<I>J</I>−</B><B>ln</B><B>(4/π)</B><BR>
L’intégrand de la différence <I>K</I>−<I>J</I>−ln(4/π) est
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">


     

</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> − 
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">sin(<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">−</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> −
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I>−sin(<I>y</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>y</I>sin(<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD></TR>
</TABLE></TD><TD ALIGN=right NOWRAP>    (71)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I>−<I>A</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> −
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I>−sin(<I>y</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>y</I>sin(<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <A NAME="eq:maj0"> </A>
</TD></TR>
</TABLE></TD><TD ALIGN=right NOWRAP>    (72)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>y</I><SUP>2</SUP>−sin(<I>y</I>)<SUP>2</SUP>)(1−<I>k</I><SUP>2</SUP>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
− </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I>−sin(<I>y</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>y</I>sin(<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <A NAME="eq:maj1"> </A>
</TD></TR>
</TABLE></TD><TD ALIGN=right NOWRAP>    (73)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Soit
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:maj2"></A>
<I>K</I>−<I>J</I>−ln(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
</TABLE></TD><TD CLASS="dcell">)= </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(<I>y</I>−sin(<I>y</I>))[(1−<I>k</I><SUP>2</SUP>)<I>y</I> sin(<I>y</I>)(<I>y</I>+sin(<I>y</I>))−</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>AB</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">(</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)]</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">)<I>y</I>sin(<I>y</I>)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
    (74)</TD></TR>
</TABLE><P>
On décompose l’intégrale en 2 parties [0,<I>k</I>] et [<I>k</I>,π/2].
Sur [0,<I>k</I>] on utilise (<A HREF="#eq:maj0">72</A>), on majore chaque terme séparément
et on minore <I>A</I> et <I>B</I> par
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=<I>k</I><SUP>2</SUP>+(1−<I>k</I><SUP>2</SUP>)sin(<I>y</I>)<SUP>2</SUP> ≥ <I>k</I><SUP>2</SUP>,    <I>B</I>=<I>k</I><SUP>2</SUP>+(1−<I>k</I><SUP>2</SUP>)<I>y</I><SUP>2</SUP> ≥ <I>k</I><SUP>2</SUP></TD></TR>
</TABLE><P>
Donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">| </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> |</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">|<I>B</I>−<I>A</I>|</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>k</I><SUP>3</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dy</I> + </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ( </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">sin(<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ) 
 <I>dy</I> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I><SUP>2</SUP>−sin(<I>y</I>)<SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>k</I><SUP>3</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dy</I> + ln(tan(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)) −ln(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">) </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>k</I><SUP>3</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>k</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
</TABLE></TD><TD CLASS="dcell"> sin(2 <I>k</I>)</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2 <I>k</I><SUP>3</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
+ ln(sin(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)) −ln(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">) − ln(cos(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">))</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>k</I><SUP>3</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>k</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (2<I>k</I>−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">8<I>k</I><SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">32<I>k</I><SUP>5</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">5!</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2 <I>k</I><SUP>3</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> − ln(cos(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)) </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">30</TD></TR>
</TABLE></TD><TD CLASS="dcell">−  ln(1− </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2!</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left">2</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">) </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">30</TD></TR>
</TABLE></TD><TD CLASS="dcell"> +</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Sur [<I>k</I>,π/2], on utilise (<A HREF="#eq:maj2">74</A>)
et on minore <I>A</I> et <I>B</I> par
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=sin(<I>y</I>)<SUP>2</SUP>+<I>k</I><SUP>2</SUP> cos(<I>y</I>)<SUP>2</SUP> ≥ sin(<I>y</I>)<SUP>2</SUP>,    <I>B</I>=<I>y</I><SUP>2</SUP>+(1−<I>y</I><SUP>2</SUP>)<I>k</I><SUP>2</SUP> ≥ <I>y</I><SUP>2</SUP></TD></TR>
</TABLE><P>
on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> | ≤  </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>y</I>−sin(<I>y</I>))|<I>C</I>|</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>y</I> sin(<I>y</I>) (<I>y</I>+sin(<I>y</I>))</TD></TR>
</TABLE></TD><TD CLASS="dcell"> , 
</TD></TR>
</TABLE><P>
où :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>C</I></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(1−<I>k</I><SUP>2</SUP>)<I>y</I> sin(<I>y</I>)(<I>y</I>+sin(<I>y</I>))−<I>A</I></TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">+<I>B</I></TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−<I>A</I>(</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">−<I>y</I>)−<I>B</I>(</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">−sin(<I>y</I>))
−<I>Ay</I>−<I>B</I>sin(<I>y</I>) + (1−<I>k</I><SUP>2</SUP>)<I>y</I> sin(<I>y</I>)(<I>y</I>+sin(<I>y</I>)) </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−<I>A</I>(</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">−<I>y</I>)−<I>B</I>(</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">−sin(<I>y</I>)) − <I>k</I><SUP>2</SUP>(<I>y</I>+sin(<I>y</I>))</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> |<I>C</I>|</TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>(</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">−<I>y</I>)+<I>B</I>(</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">−sin(<I>y</I>)) + <I>k</I><SUP>2</SUP>(<I>y</I>+sin(<I>y</I>)) </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I>−<I>y</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>B</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">+<I>y</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
+ <I>B</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>A</I>−sin(<I>y</I>)<SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">+sin(<I>y</I>)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + <I>k</I><SUP>2</SUP>(<I>y</I>+sin(<I>y</I>)) </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + <I>B</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2sin(<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> + <I>k</I><SUP>2</SUP>(<I>y</I>+sin(<I>y</I>))</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
et
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> | ≤ 
</TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(<I>y</I>−sin(<I>y</I>))<I>k</I><SUP>2</SUP>(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>A</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2sin(<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> + (<I>y</I>+sin(<I>y</I>))) </TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>y</I> sin(<I>y</I>) (<I>y</I>+sin(<I>y</I>))</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On peut majorer <I>y</I>−sin(<I>y</I>) ≤ <I>y</I><SUP>3</SUP>/6, donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> | ≤ 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>Ay</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2sin(<I>y</I>) (sin(<I>y</I>)+<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>By</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">sin(<I>y</I>)<SUP>2</SUP>(sin(<I>y</I>)+<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">sin(<I>y</I>)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On majore enfin <I>A</I> et <I>B</I> par 1, 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> |
≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2sin(<I>y</I>)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">sin(<I>y</I>)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Le premier morceau se calcule par intégration par parties
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2sin(<I>y</I>)<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">[−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">tan(<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">]<SUB><I>k</I></SUB><SUP>π/2</SUP> 
+ </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">tan(<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">tan(<I>k</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">+ [ln(sin(<I>y</I>))]</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
<TR><TD CLASS="dcell"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">tan(<I>k</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">−ln(sin(<I>k</I>)) </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>≤</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell">(1−ln(<I>k</I>))</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Le deuxième morceau se majore en minorant sin(<I>y</I>)≥ (2<I>y</I>)/π
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">sin(<I>y</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">
≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><FONT SIZE=6>∫</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>y</I>
= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP>π<SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">96</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD></TR>
</TABLE><P>
Finalement
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>K</I>−<I>J</I>−ln(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
</TABLE></TD><TD CLASS="dcell">)| 
≤ <I>k</I><SUP>2</SUP> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell">−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ln(<I>k</I>) + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π<SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">96</TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">30</TD></TR>
</TABLE></TD><TD CLASS="dcell">+ 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE><P>
où <I>J</I> est donné en (<A HREF="#eq:J">69</A>).</P><P><B>Majoration de </B><B><I>J</I>−<I>ln</I>(π/<I>k</I>)</B><BR>
On a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>J</I> − ln</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">|
= </TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD><TD CLASS="dcell">(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>k</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">−1) ln</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>k</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
ln</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> 1−<I>k</I><SUP>2</SUP> +4 </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">π<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
+</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>k</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪<BR>
⎪</TD></TR>
</TABLE><P>
et on va majorer la valeur absolue de chaque terme de la somme.
Pour <I>k</I>≤ 1/2, on a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>k</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">−1=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>1−<I>k</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">+1−<I>k</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ≤ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">3/4+</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>3</TD></TR>
</TABLE></TD><TD CLASS="dcell">/2</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
Pour le second terme, on majore le facteur 1/√<SPAN style="text-decoration:overline">1−<I>k</I></SPAN><SUP><SPAN style="text-decoration:overline">2</SPAN></SUP> par 2/√<SPAN style="text-decoration:overline">3</SPAN>,
l’argument du logarithme est inférieur à 1 et supérieur à
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">(1 − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> +1− </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>k</I><SUP>2</SUP>(1−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">π<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">)
= 1 − <I>k</I><SUP>2</SUP> ( 1−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">π<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">) &gt; 1−<I>k</I><SUP>2</SUP>
</TD></TR>
</TABLE><P>
donc le logarithme en valeur absolue est inférieur à
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">2 <I>k</I><SUP>2</SUP> </TD></TR>
</TABLE><P>
donc, pour <I>k</I>≤ 1/2,
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>J</I>−ln</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">| ≤ 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>k</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">3/4+</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>3</TD></TR>
</TABLE></TD><TD CLASS="dcell">/2</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ln</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
+ <I>k</I><SUP>2</SUP> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>3</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD></TR>
</TABLE><P>
Finalement, pour <I>k</I>&lt;1/2
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:ln_agm0"></A>
|<I>K</I>−ln</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">| 
≤ <I>k</I><SUP>2</SUP> </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">lnπ</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">3/4+</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>3</TD></TR>
</TABLE></TD><TD CLASS="dcell">/2</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">  + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>3</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π<SUP>3</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">96</TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">9</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">20</TD></TR>
</TABLE></TD><TD CLASS="dcell">
− (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">3/4+</TD><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>3</TD></TR>
</TABLE></TD><TD CLASS="dcell">/2</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">6</TD></TR>
</TABLE></TD><TD CLASS="dcell">) ln(<I>k</I>) </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
    (75)</TD></TR>
</TABLE><P>
que l’on peut réécrire
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:ln_agm"></A>
|</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>M</I>(1,<I>k</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">−ln</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">|
≤  <I>k</I><SUP>2</SUP>(3.8−0.8ln(<I>k</I>))
    (76)</TD></TR>
</TABLE><P>
La formule (<A HREF="#eq:ln_agm">76</A>) 
permet de calculer le logarithme d’un réel positif
avec (presque) <I>n</I> bits 
lorsque <I>k</I> ≤ 2<SUP>−<I>n</I>/2</SUP> (ce à quoi on peut toujours se ramener
en calculant le logarithme d’une puissance 2<SUP><I>m</I></SUP>-ième de <I>x</I> ou
le logarithme de 2<SUP><I>m</I></SUP><I>x</I>, en calculant au préalable ln(2)).
Par exemple, prenons <I>k</I>=2<SUP>−27</SUP>, on trouve (en 8 itérations)
<I>M</I>(1,2<SUP>−</SUP>27)=<I>M</I><SUB>1</SUB>=0.0781441403763. 
On a, avec une erreur inférieure à 19 × 2<SUP>−54</SUP>=1.1× 10<SUP>−15</SUP>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I>(1,2<SUP>−</SUP>27)=<I>M</I><SUB>1</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2ln(2<SUP>29</SUP>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">π</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">58ln(2)</TD></TR>
</TABLE></TD><TD CLASS="dcell">,
</TD></TR>
</TABLE><P> 
On peut donc déduire une valeur approchée de π  si on connait
la valeur approchée de ln(2) et réciproquement.
Si on veut calculer les deux simultanément, comme les relations entre ln
et π seront des équations homogènes, on est obligé
d’introduire une autre relation. Par exemple pour calculer une
valeur approchée de π on calcule la différence
ln(2<SUP>29</SUP>+1)−ln(2<SUP>29</SUP>) dont on connait le développement au premier
ordre, et on applique la formule de la moyenne arithmético-géométrique.
Il faut faire attention à la perte de précision lorsqu’on fait
la différence des deux logarithmes qui sont très proches, ainsi
on va perdre une trentaine de bits (de même pour les moyennes).
On peut aussi calculer π directement avec <I>M</I>(1,√<SPAN style="text-decoration:overline">(</SPAN>2)) en
utilisant des propriétés des intégrales elliptiques<A NAME="@default327"></A>
</P><PRE CLASS="verbatim">f(n):={
  local x,y,z,p;
  x:=evalf(1/sqrt(2),2^n);
  y:=(1+x)/2/sqrt(x);
  z:=1/sqrt(x);
  p:=evalf(2+sqrt(2),2^n);
  for k from 1 to n do
    p,y,z:=p*(1+y)/(1+z),(1+y)/sqrt(y)/2,(1+y*z)/(1+z)/sqrt(y);
  od;
  retourne p;
}:;
</PRE><P>L’intérêt de cet algorithme apparait lorsqu’on veut calculer
le logarithme avec beaucoup de précision, en raison de la
convergence quadratique de la moyenne arithmético-géométrique
(qui est nettement meilleure que la convergence linéaire
pour les développements en série, ou logarithmiquement
meilleure pour l’exponentielle), par contre elle n’est pas
performante si on ne veut qu’une dizaine de chiffres significatifs. 
On peut alors calculer les autres
fonctions transcendantes usuelles, telle l’exponentielle,
à partir du logarithme, ou les fonctions trigonométriques
inverses (en utilisant des complexes) et directes.</P><P>On trouvera dans Brent-Zimmermann quelques considérations permettant
d’améliorer les constantes dans les temps de calcul par rapport
à cette méthode (cela nécessite d’introduire des fonctions 
spéciales θ) et d’autres formules pour calculer π.</P><P>On peut ensuite à partir du logarithme, calculer l’exponentielle
en utilisant la méthode de Newton.</P><!--TOC section Les générateurs de nombres pseudo-aléatoires.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc273">26</A>  Les générateurs de nombres pseudo-aléatoires.</H2><!--SEC END --><P>
<A NAME="sec:random"></A>
<A NAME="@default328"></A>
</P><!--TOC subsection Selon la loi uniforme-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc274">26.1</A>  Selon la loi uniforme</H3><!--SEC END --><P>
Les générateurs d’entiers dans une plage donnée selon la loi
uniforme servent en général de base pour générer des 
nombres aléatoires entiers ou non selon des lois classiques.
Ils doivent à la fois être rapides, avoir une période égale à
la plage donnée et avoir de bonnes propriétés statistiques.</P><P>Xcas utilise un “tiny” Mersenne Twister (de période environ 2<SUP>127</SUP>),
certaines implantations de Giac utilisent un générateur congruentiel.</P><!--TOC subsubsection Les générateurs congruentiels.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc275">26.1.1</A>  Les générateurs congruentiels.</H4><!--SEC END --><P><A NAME="@default329"></A>
<A NAME="@default330"></A> 
Etant donnés trois entiers <I>a</I>, <I>c</I> et <I>m</I> on considère la suite
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I>+1</SUB>=<I>au</I><SUB><I>n</I></SUB>+<I>c</I> (mod <I>m</I> ) </TD></TR>
</TABLE><P>
où on choisit (par exemple) comme représentant de <I>u</I><SUB><I>n</I></SUB>
le reste de la division euclidienne par <I>m</I>. La valeur de <I>u</I><SUB>0</SUB>
est appelée seed en anglais, elle est initialisée usuellement
soit à 0 (ce qui permet de reproduire des bugs dans un programme
dépendant du hasard), soit avec l’horloge système ou tout autre
entrée de l’ordinateur (par exemple périphériques).</P><P>On supposera que <I>a</I>≠ 1, le cas <I>a</I>=1 n’est pas très
intéressant. On a alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I></SUB>=<I>a</I><SUP><I>n</I></SUP> <I>u</I><SUB>0</SUB> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUP><I>n</I></SUP>−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I>−1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>c</I> (mod <I>m</I> )</TD></TR>
</TABLE><P>
On cherche à réaliser une période la plus grande possible
idéalement <I>m</I>, mais <I>m</I>−1 peut fort bien convenir, et c’est
possible si <I>m</I> est premier en choisissant 
<I>a</I> générateur du groupe cyclique, car on a alors <I>a</I>≠ 1 (mod <I>m</I> ) et :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I></SUB>=<I>a</I><SUP><I>n</I></SUP> (<I>u</I><SUB>0</SUB> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>c</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I>−1</TD></TR>
</TABLE></TD><TD CLASS="dcell">) − </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>c</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I>−1</TD></TR>
</TABLE></TD><TD CLASS="dcell">  (mod <I>m</I> )</TD></TR>
</TABLE><P>
donc la suite est stationnaire ou prend toutes les valeurs sauf − <I>c</I>/<I>a</I>−1 .</P><P>Exemple : choisir pour <I>m</I> une puissance de 2 permet d’effectuer
la division euclidienne très rapidement, mais cela a un
inconvénient assez important : les bits de poids faible
de <I>u</I><SUB><I>n</I></SUB> ont une périodicité très (trop) petite.
Il est alors intéressant de prendre <I>m</I>=2<SUP><I>k</I></SUP> ± 1, parce
que la division euclidienne par <I>m</I> peut se coder efficacement en base
2, on divise par 2<SUP><I>k</I></SUP> (décalage de <I>k</I> bits) et on ajuste
<I>x</I>=(2<SUP><I>k</I></SUP> ± 1)<I>q</I>+<I>r</I>=2<SUP><I>k</I></SUP> <I>q</I> + (<I>r</I> ± <I>q</I>).
Ainsi pour <I>k</I>=4 et <I>m</I>=2<SUP>4</SUP>+1=17, <I>m</I> est premier.
On peut construire une suite de période 16 en choisissant <I>a</I> générateur
de (ℤ/17ℤ)<SUP>*</SUP>, par exemple <I>a</I>=3 et <I>c</I>=2 donne la suite
0,2,8,9,12,4,14,10,15,13,7,6,3,11,1,5.</P><P>On a le :
</P><DIV CLASS="theorem"><B>Théorème 54</B>  <EM>
La suite </EM><EM>(<I>u</I></EM><SUB><EM><I>n</I></EM></SUB><EM>)</EM><EM> définie ci-dessus est de périodicité maximale </EM><EM><I>m</I></EM><EM> si
et seulement si :
</EM><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><EM>
</EM><EM><I>c</I></EM><EM> et </EM><EM><I>m</I></EM><EM> sont premiers entre eux
</EM></LI><LI CLASS="li-enumerate"><EM><I>a</I>−1</EM><EM> est divisible par tous les facteurs premiers de </EM><EM><I>m</I></EM><EM>
</EM></LI><LI CLASS="li-enumerate"><EM><I>a</I>−1</EM><EM> est multiple de 4 si </EM><EM><I>m</I></EM><EM> l’est.
</EM></LI></OL><EM>
</EM></DIV><P>
On observe d’abord que vouloir la périodicité maximale revient
à pouvoir supposer que <I>u</I><SUB>0</SUB>=0. 
Il est donc nécessaire d’avoir <I>c</I>
et <I>m</I> premiers entre eux, sinon tous les <I>u</I><SUB><I>n</I></SUB> sont multiples du
pgcd de <I>c</I> et <I>m</I>. Ensuite, on pose <I>m</I>=∏<I>p</I><SUB><I>i</I></SUB><SUP><I>r</I><SUB><I>i</I></SUB></SUP> la
décomposition en facteurs premiers de <I>m</I> et on raisonne modulo
chaque premier (par le lemme chinois, la périodicité
est le PPCM des périodicités modulo chaque <I>p</I><SUB><I>i</I></SUB><SUP><I>r</I><SUB><I>i</I></SUB></SUP>). 
Si <I>a</I>≠ 1 (mod <I>p</I> )<SUB><I>i</I></SUB>
alors <I>a</I>−1 est inversible modulo <I>p</I><SUB><I>i</I></SUB> donc modulo 
<I>p</I><SUB><I>i</I></SUB><SUP><I>r</I><SUB><I>i</I></SUB></SUP> on a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>u</I><SUB><I>n</I></SUB>=<I>a</I><SUP><I>n</I></SUP> (<I>u</I><SUB>0</SUB> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>c</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I>−1</TD></TR>
</TABLE></TD><TD CLASS="dcell">) + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−<I>c</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I>−1</TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD></TR>
</TABLE><P>
et la valeur −<I>c</I>/(<I>a</I>−1) ne peut pas être atteinte
(ou alors la suite est stationnaire).
Donc <I>a</I>−1 doit être divisible par tous les facteurs premiers de <I>m</I>
pour avoir la périodicité maximale.
Réciproquement, il faut trouver le premier ordre <I>n</I> tel que
(<I>a</I><SUP><I>n</I></SUP>−1)/(<I>a</I>−1)=0 (mod <I>p</I><SUP><I>r</I></SUP> ). On pose <I>a</I>=<I>b</I>+1, on a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUP><I>n</I></SUP>−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I>−1</TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(<I>b</I>+1)<SUP><I>n</I></SUP>−1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>b</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎛<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">⎞<BR>
⎠</TD><TD CLASS="dcell"><I>b</I><SUP><I>k</I>−1</SUP> = <I>n</I> +</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>(<I>n</I>−1)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>b</I> +... </TD></TR>
</TABLE><P>
On sait que <I>b</I>=<I>a</I>−1 est un multiple de <I>p</I>, disons <I>b</I>=<I>qp</I>, on en déduit que
pour <I>n</I>=<I>p</I><SUP><I>r</I></SUP>, on a bien (<I>a</I><SUP><I>n</I></SUP>−1)/(<I>a</I>−1)=0 (mod <I>p</I><SUP><I>r</I></SUP> ), alors que
pour <I>n</I>=<I>p</I><SUP><I>r</I>−1</SUP> et <I>p</I>≠ 2, (<I>a</I><SUP><I>n</I></SUP>−1)/(<I>a</I>−1)=<I>n</I> (mod <I>p</I><SUP><I>r</I></SUP> ) ≠ 0.
Le même calcul pour <I>p</I>=2 (prise en compte de la division par 2 de
<I>n</I>(<I>n</I>−1)) donne la condition <I>b</I>=<I>a</I>−1 est multiple de 4 si <I>m</I> l’est.</P><P>On trouvera dans Knuth une discussion détaillée du choix de <I>a</I>,<I>b</I>,<I>m</I>.</P><P>Exemple : <I>m</I>=2<SUP>31</SUP>−1 est premier, on peut donc construire un
générateur congruentiel de période <I>m</I>−1 en choisissant <I>a</I>
générateur de ℤ/<I>m</I>ℤ<SUP>*</SUP>. Pour en trouver un, on peut tester
<I>a</I> pris au hasard et voir si <I>a</I><SUP><I>m</I>−1/<I>j</I></SUP> ≠ 1 (mod <I>m</I> )
pour tous les diviseurs premiers de <I>m</I>−1. Par exemple<BR>
<CODE>F:=ifactors(b:=m-1); G:=seq(F[2*j],j,0,iquo(size(F)-1,2))</CODE><BR>
<CODE>a:=456783546; for k in G do afficher(powmod(a,b/k,m)); od</CODE><BR>
<CODE>etat:=1;</CODE> initialise l’état du générateur<BR>
<CODE>r():=return etat:=irem(a*etat,n);</CODE><BR>
Un appel à <CODE>r()</CODE> renvoie un entier entre 1 et <I>m</I>−1, pour avoir
un g’enérateur pseudo-aléatoire selon la loi uniforme sur ]0,1[, on tape
<CODE>evalf(r()/m)</CODE>.
Ainsi<BR>
<CODE>L:=seq(evalf(r()/m),j,1,10000);histogramme(L,0,.01)</CODE><BR>
permet de vérifier visuellement si les réels générés sont
bien répartis, ou bien<BR>
<CODE>seq(point(evalf(r()/n,r()/n),affichage=point_point),j,1,10000)</CODE><BR>
qui détecte des biais invisibles avec le test précédent, par
exemple pour <I>a</I>=7.</P><!--TOC subsubsection Mersenne twister.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc276">26.1.2</A>  Mersenne twister.</H4><!--SEC END --><P>
Ce sont des générateurs plus performants, avec un état interne
en général plus grand, dont l’état initial est généré par
un générateur congruentiel. Ils utilisent une relation
de récurrence qui ressemble aux générateurs
congruentiels, mais au lieu de travailler sur de grands
entiers, on découpe l’entier en mots de taille gérée
par le CPU, et on fait des opérations de type matriciels
avec des opérations bit à bit (ou exclusif par exemple)
au lieu d’opérations arithmétiques.</P><!--TOC subsection Selon plusieurs lois classiques-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc277">26.2</A>  Selon plusieurs lois classiques</H3><!--SEC END --><P>
La méthode générale consiste à calculer la distribution
cumulée de la loi et à prendre la fonction réciproque
d’un réel généré aléatoirement entre 0 et 1 selon
la loi uniforme. Lorsqu’on a un nombre discret de valeurs possibles
pas trop grand et que l’on veut générer plusieurs
nombres selon la même loi, on peut précalculer la distribution cumulée
en chaque valeur, et faire une dichotomie pour trouver
la valeur de la fonction réciproque du nombre aléatoire
généré. Les calculs peuvent être rendus difficiles
par des dépassement de capacité des flottants si on utilise
des méthodes naives pour estimer les fonction de répartition.
On trouvera dans Abramowitz-Stegun diverses formules 
pour initialiser les méthodes de Newton pour inverser les
fonction de répartition courante.</P><P>Il existe aussi quelques cas particuliers où
on peut obtenir plus facilement un réel selon la loi
donnée :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Pour la loi normale<A NAME="@default331"></A>, on génère 2 réels <I>u</I>,<I>d</I>
entre 0 et 1, on calcule<BR>
√<SPAN style="text-decoration:overline">−2 </SPAN><SPAN style="text-decoration:overline">log</SPAN><SPAN style="text-decoration:overline">(<I>u</I>)</SPAN> cos(2π <I>d</I>)<BR>
En effet si on considère un couple de variables qui
suivent une loi normale centrée réduite, la densité de probabilité
au point (<I>x</I>,<I>y</I>) (coordonnées cartésiennes) ou (<I>r</I>,θ) est :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=5>√</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>2π</TD></TR>
</TABLE></TD><TD CLASS="dcell"><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2</SUP>+<I>y</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">   <I>dx</I>   <I>dy</I>
=  </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><I>e</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>r</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>r</I>    <I>dr</I> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2π</TD></TR>
</TABLE></TD><TD CLASS="dcell">   <I>d</I>θ </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
= </TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>e</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">−</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>s</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">   <I>ds</I> </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">⎛<BR>
⎜<BR>
⎜<BR>
⎝</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2π</TD></TR>
</TABLE></TD><TD CLASS="dcell">   <I>d</I>θ </TD><TD CLASS="dcell">⎞<BR>
⎟<BR>
⎟<BR>
⎠</TD></TR>
</TABLE>
où <I>r</I><SUP>2</SUP>=<I>s</I>. Donc <I>s</I> suit une loi exponentielle (générée
par la réciproque de la distribution cumulée) et θ
uniforme, les deux sont indépendantes. On écrit 
alors <I>x</I>=<I>r</I>cos(θ). On peut pour le même prix
générer <I>y</I>=<I>r</I>sin(θ).<BR>
Pour éviter de calculer
des lignes trigonométriques, on peut aussi tirer
<I>x</I> et <I>y</I> uniformément dans [−1,1], accepter le tirage
si <I>s</I>=<I>x</I><SUP>2</SUP>+<I>y</I><SUP>2</SUP> ∈ ]0,1] et renvoyer deux valeurs
aléatoires selon la loi normale
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I> </TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−2ln(<I>s</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>s</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">,    <I>y</I> </TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>√</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">−2ln(<I>s</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>s</I></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE>
</LI><LI CLASS="li-itemize">Pour la loi du χ<SUP>2</SUP> à <I>k</I> degrés de liberté, 
on fait la somme
des carrés de <I>k</I> réels aléatoires selon la loi normale
</LI><LI CLASS="li-itemize">Pour la loi de Student, on fait le quotient d’un réel
selon la loi normale par la racine carrée
d’un réel selon la loi du χ<SUP>2</SUP> divisé par le nombre
de degré de liberté
</LI><LI CLASS="li-itemize">Pour la loi de Fisher, on fait le quotient d’un réel
selon la loi du χ<SUP>2</SUP> en <I>k</I><SUB>1</SUB> degrés de liberté divisé par
<I>k</I><SUB>1</SUB> et d’un réel
selon la loi du χ<SUP>2</SUP> en <I>k</I><SUB>2</SUB> degrés de liberté divisé par
<I>k</I><SUB>2</SUB>
</LI></UL><!--TOC section Bonus : le “making of” de Giac/Xcas-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc278">A</A>  Bonus : le “making of” de Giac/Xcas</H2><!--SEC END --><!--TOC subsection Comment le projet Giac/Xcas est né.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc279">A.1</A>  Comment le projet Giac/Xcas est né.</H3><!--SEC END --><P>
Lorsque j’étais au lycée au début des années 80,
nous avions des calculatrices
scientifiques mais les calculatrices graphiques n’existaient pas
encore, et les
particuliers n’avaient pas d’ordinateurs ni de téléphone
portable (cela doit paraitre incroyable à un lycéen actuel,
pourtant cela fait à peine plus de 30 ans!). On pouvait
programmer le calcul d’une fonction pour faire un tableau
de valeurs, par une suite d’opérations ressemblant un peu
à de la programmation en langage assembleur,
avec quelques régistres pour stocker des résultats
intermédiaires et un nombre très
limité de mémoires et de pas de programmes (environ
50 instructions).
J’ai ensuite appris à programmer sur un Apple II en Basic puis en
assembleur, puis en Pascal sur un PC compatible IBM (avec 512K de RAM,
pour plus de 10kg),
mais sans jamais essayer de logiciels de maths, tout cela
en amateur, puisque je faisais mes études de maths, conclues
en 1992 par un doctorat en physique mathématique à Orsay :
je n’ai donc jamais suivi un seul cours d’informatique ni
même de cours où
on utilise l’outil informatique, j’ai sans doute perdu quelques
enseignements utiles, mais je n’ai pas été déformé par
l’enseignement de certains, je pense par exemple
à ceux qui n’ont jamais écrit de
gros programmes et préconisent de ne pas
utiliser <CODE>break</CODE> ou <CODE>return</CODE> dans une boucle
alors que cela rend le code beaucoup plus lisible que
d’ajouter un booléen artificiel, ou qui
sont incapables de mettre au point un programme.</P><P>Je n’avais donc jamais entendu parler de calcul formel
avant 1993, et c’est Gilles, un de mes étudiants de Deug (on
dirait licence 1ère année aujourd’hui) qui m’a montré
le calcul d’une dérivée symbolique et d’un inverse
de matrice sur une calculatrice HP (qui était le leader du marché
haut de gamme avant que TI ne sorte la TI92 puis la TI89).
L’idée de pouvoir faire ce type de calculs sur calculatrices
m’a séduit, j’étais assez insatisfait des exercices
que l’on donnait en examen aux étudiants où la
différence entre un 8 et un 12 se fait souvent sur une petite
étourderie dans une résolution de système linéaire
et pas du tout sur la compréhension des notions au programme.
J’ai donc décidé de rattraper mon retard dans le domaine,
d’acheter une calculatrice et de la documentation pour la
programmer l’été suivant. C’était indispensable, car le moteur
de calcul formel fourni sur les HP48 était très limité. D’un
certain point de vue, c’était une chance, puisqu’il y avait
tout à faire donc tout à apprendre.
Au cours des années qui ont suivi, j’ai amélioré ces programmes,
et je les ai mis à disposition de la communauté des utilisateurs
de calculatrices HP sous le nom d’Erable (clin d’oeil à Maple).
Erable fait partie de ce que l’on peut qualifier de système de
calcul formel “jouets”, j’entends par là capable de résoudre
les exercices calculatoires donnés du lycée à la licence de maths.
En même temps, j’enseignais
l’algorithmique en licence (avec toute
une équipe très sympathique : Renée, Roland,
Gérard, Frédéric). On programmait en Pascal au début, puis
rapidement on a basculé les enseignements en C/C++.
Renée s’intéressait
aussi aux calculatrices et pensait qu’il faut contacter HP (il
y a un centre HP en banlieue de Grenoble),
ce qui ne fut pas évident mais finit par déboucher sur
la création d’un module optionnel calculatrices en Deug
(avec des calculatrices prêtées par HP),
puis en 1997 des contacts avec la nouvelle équipe calculatrices
de HP en Australie. En 1998/99, j’ai effectué une délégation
pour mettre au point la HP49 avec l’équipe australienne,
afin d’y intégrer Erable.
Un an plus tard nous sortons
la HP40, version lycée simplifiée et moins chère de la HP49,
projet porté par Jean Tavenas chez HP Grenoble.
Mais HP décide alors que les calculatrices graphiques
ne sont pas assez rentables, les efforts de Jean pour
faire la publicité de la HP40 sont stoppés juste au
moment où ils commençaient à porter leurs fruits
(avec une calculatrice formelle au prix de la TI83,
la HP40 avait pourtant toutes ses chances, c’est
d’ailleurs encore vrai en 2014,
la HP40GS est la calculatrice formelle
la moins chère du marché, on la trouve cette rentrée 2014
à un prix équivalent aux graphiques d’entrée de gamme de TI et Casio).</P><P>C’est cette expérience avec HP
qui m’a fait prendre conscience qu’il était possible d’écrire un logiciel
de calcul formel compétitif. Ma décision
d’abandonner le développement sur HP49/40 fut alors
la conséquence d’une part de la mise en retrait de HP du marché,
d’autre part de la modification de l’épreuve d’option de l’agrégation
de maths, qui devenait un oral de modélisation avec utilisation
de logiciels. À l’époque seuls les logiciels propriétaires
“leaders du marché” étaient autorisés (Maple et Mathematica
pour ne pas les nommer), il n’y avait pas
un seul logiciel libre de calcul formel et
cela m’avait beaucoup choqué. Au début
j’argumentais pour l’ajout de Mupad qui était sinon libre au moins
gratuit (Mupad n’existe plus isolément aujourd’hui).
Quelques années plus tard, Maxima et d’autres logiciels libres
ont été rajoutés à la liste des logiciels, mais sans connaitre beaucoup
de succès parmi les candidats. Au lancement du projet Giac/Xcas en 2000,
j’avais comme objectif que Xcas soit un jour intégré dans la liste des
logiciels de l’oral de modélisation (ce fut le cas en 2005, mais
les premiers candidats à l’utiliser ne l’ont fait que vers 2007 ou
2008...).</P><!--TOC subsection L’enfance d’Xcas: 2000-2006-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc280">A.2</A>  L’enfance d’Xcas: 2000-2006</H3><!--SEC END --><P>
L’année 2000 marque sans doute un tournant dans ma carrière,
je viens d’achever l’année de délégation pour mettre au point
la HP49, et le travail se poursuit pour sortir la HP40 à la
rentrée scolaire. Le tandem se met en place avec Renée qui
rédige le manuel de calcul formel de la HP40G.
C’est la dernière année où je travaille activement en recherche sur
des thèmes de physique mathématique.
Au moment où nous avions décider de basculer l’enseignement
d’algorithmique du Pascal au C (fin des années 90),
j’avais regardé les possibilités
de bibliothèque pour faire un peu de calcul en précision
arbitraire à défaut de faire du calcul formel
(on a essayé LiDiA, PARI, mais sans vraiment être satisfait).
En mai 2000, alors que le projet HP40 s’achève,
je me lance dans un projet d’extension de la librairie C++
de calcul symbolique GiNaC,
il s’agissait dans un premier temps d’améliorer les fonctions
polynômiales avec des représentations non symboliques,
pour avoir de la simplification et de la factorisation. Après
plusieurs mois, je me rends compte que la philosophie de GiNaC
ne me convient pas, je bascule vers un projet complètement
indépendant, que je nomme Giac, en référence à GiNaC
<SUP><A NAME="text30" HREF="#note30">30</A></SUP>. Au début il s’agissait juste
d’avoir une librairie C++ capable de faire des opérations
sur les polynômes de manière efficace. Pendant 2 ans,
j’implémente les algorithmes de base d’un CAS pour la
licence de maths (pgcd, factorisation, intégration, limites...),
puis je crée une petite interface pour pouvoir tester le tout
sans avoir à écrire un programme C++ à chaque fois.
La première version publique de Xcas est disponible en 2002,
elle est très influencée par les interfaces de calculatrices.
En 2003/2004, premier contact avec le milieu de la recherche
en calcul formel, dont certains membres veulent créer une
alternative aux grands logiciels propriétaires du domaine, soit
par conviction, soit tout simplement pour des raisons de budget.
Une conférence a lieu à Lyon puis une école d’été,
où sont présents
de mombreux développeurs de logiciels libres
(Axiom, Fricas, Maxima, texmacs, pari, gap,
MPFR... mais aussi des gens de Mupad même s’il n’est pas libre). Cette
conférence n’a de mon point de vue abouti à rien de concret,
chacun tirant pour sa chapelle. La présentation des objectifs du projet 
Giac/Xcas n’a pas du tout attiré les autres participants,
d’une part à cause de mes déficiences en anglais,
d’autre part parce que l’objectif prioritaire de Xcas (pour l’enseignement)
est souvent assez éloigné des objectifs d’un logiciel
pour la recherche en calcul formel, sans parler de l’orientation
calculatrice de l’interface de Xcas à l’époque.
C’est plutôt vers le projet Sage que la
communauté recherche de calcul formel “libre” se tournera un peu
plus tard. Les deux projets Giac/Xcas et Sage sont
aujourd’hui concurrents (même si on peut appeler Giac
depuis Sage), voir plus bas section <A HREF="#sec:concurrents">A.5</A>.</P><P>Parallèlement, Renée a lancé à l’IREM de Grenoble
un groupe de travail sur l’utilisation des calculatrices
formelles au lycée, à l’automne 2000 :
HP mettait à disposition
des profs de lycée participants des valises de HP40G
prêtées aux élèves. Peu après, HP se désintéresse
des calculatrices, l’idée de tester le Xcas (d’alors) en classe
est venue tout naturellement. Ce sont Michèle Gandit et
Christianne Serret qui se lancent dans l’aventure, c’est bien
le mot, parce qu’il fallait y croire avec les très nombreux
bugs et manques de l’interface de l’époque. C’est
l’observation des problèmes rencontrés par les élèves
qui m’a fait prendre conscience qu’une révision complète
de l’interface s’imposait, et j’y ai consacré une bonne année
de travail, aboutissant à une interface proche de l’actuelle.
C’est cette nouvelle interface qui a permis le
décollage de Xcas, que l’on peut juger
au nombre de téléchargements, ainsi que par
les interactions avec des utilisateurs inconnus.</P><!--TOC subsection La montée en puissance: 2007-2013-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc281">A.3</A>  La montée en puissance: 2007-2013</H3><!--SEC END --><P>
En 2007, Xcas participe aux Trophées du Libre, (concours
de logiciels libres qui n’existe plus aujourd’hui), et obtient
la 3ième place dans la catégorie logiciels scientifiques.
J’espérais que cela marquerait une étape
décisive dans la montée en puissance,
par exemple en faisant entrer Xcas dans
des distributions Linux, mais cela n’a pas servi (et encore
aujourd’hui Giac n’a pas réussi à entrer dans les distributions
Linux majeures, même si l’entrée dans Fedora semble
imminente). En fait la montée en puissance s’est faite
progressivement, avec environ une dizaine de % d’utilisateurs
en plus chaque année, grâce aux améliorations
implémentées par l’interaction avec les profs
de maths sur le forum de Xcas ou par email. C’est aussi
vers 2008 que l’interface est devenue suffisamment
intuitive pour que les étudiants de la préparation
à l’agrégation de Grenoble option calcul formel
basculent de Maple vers Xcas
(avec une période de transition où certains travaillaient
avec Maple en même temps que d’autres avec Xcas). Suivis
peu de temps après par Jussieu (F. Han). Puis progressivement
dans certains enseignements de licence à Grenoble et
sans doute ailleurs.</P><P>Le projet Giac va aussi prendre en 2011 une direction un peu
imprévue, c’est la valorisation. Le noyau de Giac va
en effet pour la première fois être intégré
à une application commerciale, PocketCAS. Ce qui nécessitera
de contacter les services de valorisation de l’université, début d’un épisode
difficile que je ne peux pas commenter plus pour des
raisons de confidentialité.</P><!--TOC subsection Le présent et le futur proche-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc282">A.4</A>  Le présent et le futur proche</H3><!--SEC END --><P>
Le nombre de téléchargements de Xcas dépasse maintenant
les 50 000 par an avec des pointes mensuelles en septembre et octobre
à plus de 12 000 (principalement sous Windows). Xcas est
présent dans la grande majorité des livres de maths de Terminale
S, on en parle aussi en ES (une copie d’écran de Xcas se trouve
d’ailleurs dans le sujet du bac ES 2014).
La couverture en France est donc plutôt bonne, c’est
vers l’étranger qu’il faut maintenant gagner des parts de marché
(ce qui nécessitera une amélioration de la documentation
en anglais).</P><P>Au concours de l’agrégation externe,
Xcas est choisi par une fraction
significative des candidats en modélisation option C
(un tiers environ en 2012).
Parallèlement à la montée en
puissance de Xcas, l’arrivée de Sage, la fin de Maple (et
Mathematica) en classes préparatoires
et le succès de Scilab en calcul numérique et probabilités, ont
fait que la situation s’est renversée, en 2015,
seuls les logiciels libres sont autorisés
à cette épreuve de modélisation, on peut
dire que c’est un beau succès pour les logiciels libres,
auquel Xcas a contribué.
En 2013/14, j’ai retravaillé pour les candidats
aux options A et surtout B : refonte de
la page agrégation externe, ajout de fonctionnalités,
testées dans un cours de méthodes numériques
niveau licence 3ième année. Il y a en effet une part de marché
à conquérir parmi tous les candidats qui utilisaient auparavant
Maple, en particulier pour tous les certifiés qui
ne sont pas inscrits à une préparation, Xcas est un choix
qui semble rationnel : ceux qui ont appris Maple peuvent
utiliser leurs connaissances, Xcas est aussi proposé
à l’agrégation interne et les professeurs peuvent utiliser Xcas avec
leurs élèves ce qui est certainement un excellent entrainement
pour la mise au point d’un petit programme le jour du concours.
Xcas est aussi présent pour les oraux du Capes, mais je n’ai
pas de retour sur son utilisation réelle par les candidats,
même si plusieurs préparations semblent utiliser Xcas.</P><P>La collaboration entamée avec Geogebra en 2013
se concrétise avec la version 4.4 sortie en décembre 2013
qui interface Giac (module natif java et version
web) avec l’écran CAS de Geogebra.
Les interfaces vers d’autres langages s’améliorent,
module Python, interface avec Sage (F. Han),
utilisation depuis javascript. Plusieurs projets
libres utilisent Giac comme moteur de calcul : Qcas (interface
alternative, qui pourrait remplacer Xcas un jour),
Smartcas (calculatrice CAS dans votre navigateur),
Xcas Pad (sur tablettes)...</P><P>Coté valorisation, Giac fait aujourd’hui l’objet de
plusieurs contrats de
commercialisation (en dual-licensing), dont un avec HP
pour le CAS des calculatrices HP-Prime.</P><!--TOC subsection Les concurrents open-source.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc283">A.5</A>  Les concurrents open-source.</H3><!--SEC END --><P> <A NAME="sec:concurrents"></A>
Les principaux concurrents open-source de Giac/Xcas sont Maxima et
Sage. Il existe d’autres logiciels libres de calcul formel généralistes, mais ils
ne semblent pas avoir beaucoup d’utilisateurs.</P><P>L’utilisation de Giac et de Maxima est assez proche, ce sont
tous deux des logiciels qui fonctionnent localement (sans
avoir besoin de connexion Internet),
installables facilement sous Windows, Linux
et Mac OS, avec une prise en main rapide
aidée par un typage faible et par l’interface
(Xcas ou Wxmaxima). Maxima est plus connu dans le monde anglo-saxon
car il est plus ancien, alors que Xcas est maintenant bien
implanté en France (et sans doute dans d’autres pays francophones)
grace à la documentation en français. Xcas évolue plus vite.
Giac dispose d’algorithmes beaucoup plus
performants pour de (gros) calculs polynomiaux pour la recherche
(meilleur moteur open-source de calcul de bases de Groebner 
à l’heure actuelle par exemple)
et est bien adapté à un usage
en enseignement dès le lycée (en particulier 
par son intégration comme CAS de geogebra). Un challenge pour Xcas
pour les années à venir va être d’augmenter la part
de marché dans le monde anglo-saxon, il nous faudrait
un amateur motivé parlant nativement anglais prêt à consacrer
du temps pour améliorer la documentation en anglais.</P><P>Sage est très différent de Xcas et Maxima. On peut certes l’utiliser
comme un logiciel local en ligne de commande, mais
pour une interface plus conviviale il faut utiliser une 
client-serveur, l’interface étant alors dans le navigateur. Les
ressources nécessaires sont significativement plus importantes
si on l’installe localement, et l’accès Internet est indispensable
sinon<SUP><A NAME="text31" HREF="#note31">31</A></SUP>. Le langage de 
Sage est beaucoup plus typé que celui de Giac, il est
philosophiquement
plus proche de Magma que de Maple ou Mathematica,
donc plus difficile à apprendre pour qui n’est pas algébriste.
Sage se fonde sur un énorme corpus de logiciels et
bibliothèques (dont Maxima, appelé pour les calculs symboliques,
Giac peut d’ailleurs en être un composant
optionnel), qu’il fait communiquer entre eux, un peu à la
manière d’une distribution linux qui fait cohabiter des composants
logiciels, mais de manière plus intime, Python servant
de colle entre les briques logicielles écrits en différents
langages (c’est aussi là une différence importante avec Giac
qui utilise C/C++ pour dialoguer avec d’autres bibliothèques
ou logiciels, tout en restant utilisable comme module
Python). C’est la force et la
faiblesse de Sage, car on bénéficie de certains composants très
performants, mais le code propre de Sage est très dépendant
de l’évolution de ces composants :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
son composant d’infrastructure le plus fondamental, 
la version de Python utilisée est
figée depuis plusieurs années en 2.7 (alors que le module
giacpy pour accéder à giac depuis Python fonctionne
en versions 2.7 et 3.x),
</LI><LI CLASS="li-itemize">toutes les opérations de calcul formel non
spécialisé font très souvent appel à Maxima,
si une intégrale rend un résultat incorrect, il faut en informer
les développeurs de Maxima
</LI><LI CLASS="li-itemize">les opérations polynomiales rapides font appel à des
bibliothèques C/C++ et dépendent donc des performances
de ces bibliothèques : par exemple le calcul de base
de Groebner sur les entiers utilise Singular, dont la version
actuelle est très inefficace sur ℤ
</LI></UL><P> 
De ce fait, le portage est difficile : sans même parler des OS de tablettes
et smartphones, il n’y a pas de version native Windows,
on fait communiquer le navigateur sous Windows avec un serveur
sage dans une machine virtuelle sous linux, ce qui nécessite
significativement plus de ressources<SUP><A NAME="text32" HREF="#note32">32</A></SUP> que pour Giac, 
qui peut même tourner sur des calculatrices.</P><P>Les deux stratégies de développement de Giac et Sage
sont assez opposées<SUP><A NAME="text33" HREF="#note33">33</A></SUP> : Giac se contente de peu de ressources et cible le 
public enseignement dès le lycée (calculatrices, geogebra) alors
que W. Stein, le fondateur de Sage se tourne vers le cloud computing :
“Measured by the mission statement, Sage has overall failed. The core
goal is to provide similar functionality to Magma (and [Maple,
Mathematica Matlab]) across the board, and the Sage development model
and community has failed to do this across the board, since after 9
years, based on our current progress, we will never get there. There
are numerous core areas of research mathematics that I’m personally
familiar with (in arithmetic geometry), where Sage has barely moved in
years and Sage does only a few percent of what Magma does.”
“The longterm plan is to start a separate for-profit company if we
build a sufficient customer base. If this company is successful, it
would also support fulltime development of Sage (e.g., via teaching
buyouts for faculty, support of students, etc.), similar to how Magma
(and Mathematica, etc.) development is funded.” (<TT><FONT SIZE=1>http://sagemath.blogspot.co.uk/2014/08/what-is-sagemathcloud-lets-clear-some.html</FONT></TT>).</P><!--TOC section Quelques opinions.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc284">B</A>  Quelques opinions.</H2><!--SEC END --><!--TOC subsection Languages-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc285">B.1</A>  Languages</H3><!--SEC END --><P>
La question du choix de langage en informatique est récurrente.
J’ai choisi C++ pour Giac/Xcas, en fait c’est plutôt du C– (au
sens où Giac définit très peu de classes lui-même, mais
utilise les facilités de la bibliothèque C++).</P><P>Lorsque j’ai développé pour la HP48 dans les années 90, le langage
était du RPL, un dérivé du Forth, sorte de Lisp restreint écrit
en polonaise inversé, spécialement conçu pour créer
des programmes compacts (le CAS de la HP49 occupe environ
200K, l’ensemble du système environ 1M).
C’était un langage où on pouvait
tout manipuler, y compris la pile des retours de fonction.
Mais c’était un langage difficile à maitriser et où le
moindre changement nécessitait de reconcevoir complètement
le programme. C’était aussi un langage interprété donc lent,
et comme pour tout langage interprété, optimiser nécessite
une longue pratique et rend le programme optimisé encore plus
incompréhensible que dans d’autres langages.
Et bien sur c’est un langage propriétaire, complètement
inutilisable en-dehors des HP48/49/50.</P><P>C’est donc avec ces défauts en tête que j’ai choisi le
langage de Giac : portabilité, facilités pour optimiser,
mettre au point et modifier, vitesse. Ce qui excluait
tout langage interprété. Le choix
de C/C++ c’était aussi la possibilité d’utiliser des opérateurs
sur le type générique de giac, pour pouvoir écrire
<CODE>b*b-4*a*c</CODE> et pas <CODE>sub(mult(b,b),mult(4,mult(a,c)))</CODE>
comme en Java.</P><P>Je ne regrette pas un instant ce choix. Si on regarde les logiciels
de calcul formel, on a essentiellement 3 langages :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Lisp utilisé par Maxima. Cela affecte
le nombre de développeurs potentiels du système,
et nécessite d’avoir un interpréteur Lisp sur
certaines plateformes (avec des problèmes de lenteur)
</LI><LI CLASS="li-itemize">C/C++ utilisé par Xcas, Maple, Mathematica
mais aussi par de nombreux logiciels et librairies
mathématiques : GMP, MPFR, NTL,
Pari-GP, Singular...
</LI><LI CLASS="li-itemize">Python utilisé par Sage et Sympy. Sage doit toutefois
être un peu mis à part, la plupart de ses fonctionnalités
sont en fait héritées de bibliothèques C ou logiciels
interfacés et les développeurs ont recours à une
sorte de traducteur C (cython) pour optimiser certaines portions de code
Python natif. Sympy se classe pour le moment encore dans les
systèmes de calcul formel jouets,
et est structurellement très lent comparé à giacpy.
</LI></UL><P>
Je pense que le potentiel de portabilité
et réutilisation de code est maximal en C/C++,
on peut s’intégrer dans du Python (module giacpy
et interface giac/sage de F. Han, l’inverse est beaucoup plus difficile et
nécessite plus de ressources, essayez d’appeler
du code sage depuis un programme C/C++!),
du java (module natif javagiac utilisé par geogebra),
du Javascript (le langage de base du web! Giac se compile en
Javascript),
du code natif pour le navigateur google-chrome,
en embarqué (sur les HP Prime, mais aussi ailleurs,
la plus petite version de giac existante à ce jour
occupe moins de 5M et tourne sur calculatrices TI nspire) ou
enfoui dans un autre programme (C/C++ ou avec
un langage interfaçable, par exemple de la liste fournie par SWIG).
La durée de vie de code C/C++ est aussi excellente, le
langage C/C++ est au coeur de la très grande majorité
des applications utilisées aujourd’hui. L’avenir de Javascript
ou de Python parait aujourd’hui assuré, mais c’était
la situation de Java il y a une dizaine d’années, alors
qu’aujourd’hui on ne peut plus en dire autant.</P><P>Bien sur, écrire un programme en C/C++ nécessite
un peu plus d’apprentissage qu’écrire un programme
en Python ou en tout autre langage interprété,
mais c’est je pense aussi plus formateur, on
comprend mieux les avantages et inconvénients
d’utiliser un conteneur, un type de donnée précis
ou un algorithme avec un langage plus proche de la machine
réelle qu’avec une machine abstraite filtrée par les
possibilités mises à disposition par l’interpréteur
(avec souvent un biais lorsqu’on optimise, on favorise
l’instruction implémentée le plus efficacement par
l’interpréteur au détriment de l’algorithme le plus
efficace, ce qui conduit par exemple à choisir un style fonctionnel
plus difficile à concevoir, relire et modifier et moins
efficace dans un langage compilé).</P><!--TOC subsection Le libre, la recherche et l’éducation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc286">B.2</A>  Le libre, la recherche et l’éducation</H3><!--SEC END --><P>
Le logiciel libre a fini par se faire une place au soleil,
mais cela n’a pas été facile. Au sein de l’éducation
nationale, c’est probablement les restrictions budgétaires qui ont été
le meilleur allié du libre, et Open Office ou LIbre Office,
Geogebra, Xcas sont maintenant bien présents dans
les lycées et manuels, mais l’OS reste Windows et
l’évolution dans le monde des calculatrices va dans le mauvais sens.</P><P>L’idée de mettre en place un mode examen en 2018 va à l’encontre
de la possibilité pour l’acheteur de tirer parti de sa calculatrice
comme il l’entend, il suffit de voir la guerre entre les
développeurs de TI et la communauté Ndless, digne
de la lutte menée par Apple contre les“jailbreaks”
qui permettent d’utiliser l’Ipad avec des logiciels en-dehors
du marché controlé par Apple ou avec d’autres opérateurs
téléphoniques. L’institution devrait bien réfléchir avant de
se lancer dans l’aventure. Certes, le mode examen évitera le
recours parfois abusif aux anti-sèches, mais cela va décourager
le développement de programmes par les élèves sur leurs
calculatrices (car ces programmes seront effacés le jour de
l’examen) et renforcer les inégalités, en particulier pour
l’accès au calcul formel (qui est possible sur des modèles
d’entrée de gamme aujourd’hui).</P><P>Je pense que si on veut vraiment des calculatrices avec mode examen,
alors c’est à l’institution de les acheter, puis de les 
prêter aux élèves. L’éducation nationale devrait aussi
avoir plus de contrôle sur les logiciels
embarqués, qui ne devraient pas tant
dépendre des constructeurs
et donc des programmes de l’enseignement US. Cela permettrait
aussi de mettre fin à des rentes pour les constructeurs
en situation de position dominante, que l’on songe par
exemple au bénéfice sur les modèles de calculatrices les plus
conseillées et vendues, calculatrices qui ne se sont
guère améliorées depuis 20 ans.</P><P>Si ce sont les élèves qui sont propriétaires du matériel, alors
ils doivent pouvoir y installer les logiciels de leur choix.
En fait, avec la baisse du prix des tablettes et autres
netbooks où chacun peut installer le logiciel de son
choix, est-il raisonnable de continuer à utiliser
des calculatrices graphiques (à plus de disons 20 euros) ? Il vaudrait
peut-être mieux prévoir des dispositifs de brouillage
des communications de type wifi, ou/et des sujets avec
une partie sans outil informatique pour controler les questions
de cours.</P><P>Coté recherche, l’esprit “libre” progresse mais il y a encore
beaucoup de chemin à accomplir. L’édition scientifique
est encore essentiellement basée sur le paradigme du 20ième
siècle : revue papier vendue à prix d’or aux bibliothèques,
droits d’auteurs cédés par les auteurs des articles sans aucune
contrepartie, accès en ligne payant. Les éditeurs privés
s’approprient ainsi la connaissance financée par les fonds publics,
un comble!
Heureusement les archives en ligne permettent la plupart
du temps de contourner ces accès payants. Il reste
que les crédits utilisés pour payer les abonnements seraient
bien mieux utilisés à financer les journaux en ligne et en
les rendant publics.</P><P>Concernant le dèveloppement logiciel,
il y a beaucoup de logiciels scientifiques libres de qualité aujourd’hui, mais
il y a des freins :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
la publication de code source de logiciel scientifique n’est pas
considéré comme équivalent à la publication d’un article :
certains qualifient d’ailleurs cette activité par “pisser du
code”. 
Conséquence, l’auteur d’un morceau de code n’a pas intérêt
à en diffuser le source car cela n’accélérera en rien
sa carrière, il est souvent plus rentable
de diffuser un article qui parle du code source,
sans rentrer trop dans les
détails qui rendent un algorithme efficace. Éventuellement
on diffuse un exécutable,
comme cela toute personne utilisant le code pour un autre
travail de recherche devra collaborer
ou remercier d’une autre manière. Dans certains
domaines, on me dit que la situation en arrive au point
où il faut communiquer
les données à l’auteur du code qui renvoie le résultat.
On est vraiment aux antipodes de la démarche scientifique,
encore plus en maths où on attend de pouvoir consulter
tous les détails d’une preuve.
</LI><LI CLASS="li-itemize">On peut sans doute dire la même chose concernant
le développement de logiciels
éducatifs. Il n’y a pas de reconnaissance de l’institution et
les encouragements sont rares (en tout cas c’est le ressenti
de notre visite de présentation de Xcas
au ministère de l’Education Nationale
il y a quelques années, peut-être que ce serait différent
aujourd’hui).
</LI><LI CLASS="li-itemize">Un autre frein au libre, c’est le droit qui est différent pour les logiciels
et pour les écrits scientifiques, la personne qui dispose des droits
patrimomiaux sur un logiciel c’est l’employeur de l’auteur et
pas l’auteur lui-même, or les responsables de projets,
universités et autres organismes
publics de recherche sont beaucoup plus réticentes au logiciel
libre que les auteurs eux-mêmes ... surtout s’ils ont des organismes
de valorisation. Ce n’est pas seulement une question financière
mais tout simplement de qui controle quoi, une fois un logiciel
libéré, le contrôle est dans les mains des personnes qui codent,
et échappe aux services de valorisation ou aux scientifiques
qui dirigent le projet<SUP><A NAME="text34" HREF="#note34">34</A></SUP>.
</LI><LI CLASS="li-itemize">Plus généralement, le financement de la recherche
aujourd’hui n’est pas favorable aux projets de long terme.
Le manque de confiance des décideurs envers les chercheurs
est une cause majeure de perte d’efficacité des chercheurs,
en raison de l’inflation du temps passé à chercher des crédits,
à évaluer des projets, à évaluer les collègues
(pour les nominations et promotions aujourd’hui, bientot peut-être pour les services
d’enseignement!). Le système actuel favorise d’ailleurs la politique
d’édition dénoncée plus haut, avec une floraison d’indices utilisant
les publications dans les journaux prestigieux. Il serait bien plus
rentable de faire confiance aux chercheurs avec des financements
pérennes et la fin des contrôles systématiques, bien sur il y aura
toujours quelques abus, mais globalement on gagnerait en efficacité.
</LI></UL><!--TOC subsection Les maths et les outils de calcul.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc287">B.3</A>  Les maths et les outils de calcul.</H3><!--SEC END --><P>
En un demi-siècle les outils de calcul informatiques ont
gagné en puissance de manière radicale. Aujourd’hui,
pour une centaine d’euros, on a la puissance de calcul
qui était réservée, il y a une vingtaine d’années, 
aux centres de calculs spécialisés. </P><P>Cela a des conséquences
visibles dans tous les domaines de la vie quotidienne, il
est impossible de les ignorer en maths sauf peut-être
dans certains domaines de recherche. En tout
cas pas dans le domaine de l’enseignement. Bien entendu,
les maths c’est pour partie du raisonnement, mais pour
l’écrasante majorité des gens, y compris scientifiques,
c’est surtout un outil et pas une fin en soi (sur une classe
d’age, deux à trois pour mille vont
être des professionnels des maths, en comptant tous les
enseignants de maths). Je pense que si les matheux veulent survivre
en tant que discipline, il faut qu’ils adaptent leur enseignement
pour un usage <EM>intelligent</EM> des outils de calcul, sinon ils finiront
comme les langues anciennes. On ne devrait par exemple 
plus étudier les courbes sans utiliser un logiciel ou une
calculatrice pour en avoir une représentation graphique : 
avant on faisait l’étude complète pour aboutir au tracé 
parce qu’on n’avait pas le choix de faire autrement, aujourd’hui il faut
faire le tracé et l’étude simultanément, létude analytique
servant à expliquer les particularités du tracé.</P><P>Utiliser des outils de calcul n’est pas contradictoire avec faire
du calcul, en particulier faire un peu de calcul mental pour avoir
une idée de la plausibilité d’un résultat obtenu par
un logiciel (ordre de grandeur). C’est
de l’hygiène intellectuelle, analogue à faire de l’exercice
physique. Faire quelques calculs à la main est aussi une
façon de s’approprier de nouveaux concepts. Mais une fois
cette étape franchie, je ne vois aucune raison de devoir
continuer à apprendre à faire des calculs fastidieux
ou techniques, alors que l’ordinateur fait cela beaucoup mieux
que nous. Il est beaucoup plus judicieux de savoir diriger
un logiciel pour cela, et donc de passer un peu de temps
(autrefois consacré à faire des calculs techniques)
à connaitre leurs possibilités
et limites (à la fois en termes de fonctionnalités et
de temps de calcul).</P><P>Prenons l’exemple de la résolution des équations du second
degré. Au moment où on enseigne cette technique, je pense
qu’il est important de faire faire quelques calculs de racines 
de trinômes (sans
calculatrices), et d’expliquer comment ce genre de calculs peut
se faire avec un logiciel de calcul formel (ce qui d’ailleurs
permettra aux élèves de vérifier les résultats
de leurs calculs faits à la main).
Un an ou deux ans après, je ne vois pas l’intérêt de forcer
des élèves à continuer à faire ces calculs à la main
s’ils savent les faire avec un logiciel ou une calculatrice. En les
bloquant sur un point technique, on ne fera
que les braquer et on les empêchera de comprendre à quoi
cela peut servir (par exemple ici faire un tableau de variations).
Il faut arrêter de croire que tous les
scientifiques fonctionnent comme les matheux qui veulent
comprendre de A à Z, c’est d’ailleurs souvent devenu
impossible en recherche en maths, les autres disciplines
ont leurs propres règles (je pense par exemple qu’un
bon physicien n’a pas forcément besoin de savoir
démontrer rigoureusement quelque chose, l’essentiel
est qu’il ait une bonne intuition des bonnes approximations
à faire pour calculer correctement, calcul qu’il n’hésitera
par à déléguer à la machine). Interdire les outils
de calculs (ou les réserver à ceux qui savent déjà
les faire à la main), c’est pour moi une pratique élitiste,
on donne l’accès à certaines connaissances non pas
à ceux qui sont capables de les comprendre, mais à
ceux qui sont suffisamment virtuoses du calcul à la main.</P><P>Certains enseignants mettent sur le dos de l’usage des outils de
calcul tous les maux du système actuel alors qu’à mon avis cela n’a rien
à voir. Je pense que le problème principal des maths au lycée, 
c’est que les maths de S sont à la fois dures pour des non matheux
et inintéressantes pour des matheux (au sens large), conséquence
de l’universalité des débouchés accessibles en sortant de S.
Dans le supérieur (hors prépas), le problème principal c’est
la multiplication des parcours, la semestrialisation 
et l’atomisation des enseignements
en unités beaucoup trop petites, qui augmentent les effets
frontières, sont contradictoires avec les échelles de temps
pour assimiler des notions, créent des casses-têtes pour faire
les emplois du temps, multiplient les sessions d’examens. 
A cela s’ajoute la perte d’attractivité des métiers de
l’enseignement et de la recherche en maths, que ce soit
dans le secondaire (conditions de travail, reconnaissance
par la société) ou dans le supérieur (dégradation
des conditions d’exercice de la recherche, mais aussi
de l’enseignement). Rien d’étonnant à ce que les jurys
du CAPES et de l’agrégation n’arrivent pas à
pourvoir tous les postes.</P><P>Les programmes des classes préparatoires aux grandes écoles
ont supprimé récemment l’apprentissage d’un logiciel de calcul
formel, peut-être une victoire des enseignants qui sont contre
l’usage des outils de calcul formel. Ce sont les mêmes qui conseillent
à leurs élèves l’achat de calculatrices graphiques non formelles
au lycée (ce qui arrange bien les constructeurs qui peuvent ainsi
faire payer au prix fort le modèle formel). 
Je pense que ce combat d’arrière-garde est voué à l’échec :
les calculatrices graphiques de milieu de gamme commencent
à avoir des logiciels de calcul formel jouets (comme
par exemple Eigenmath sur Casio Graph 35+USB et 75/85/95),
et à moyen terme (10 ans?), ces calculatrices 
auront suffisamment de capacité mémoire pour
permettre le portage de logiciels de calcul formel complets comme Giac.</P><!--TOC subsection Calculatrices, tablettes ou PC ?-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc288">B.4</A>  Calculatrices, tablettes ou PC ?</H3><!--SEC END --><P>
Si on est convaincu de l’intérêt d’utiliser un outil de calcul,
se pose alors la question du choix de l’outil. Voici quelques
éléments de réflexion.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Les calculatrices ont pour avantages : la disponibilité
immédiate (on appuie sur ON, en 1 seconde on peut
travailler), l’encombrement faible, la robustesse,
le clavier scientifique
dédié (avec sur les calculatrices graphiques haut
de gamme une interface facilitant la saisie d’intégrales,
limites, etc.), la consommation faible (des piles qui durent
plusieurs mois ou des batteries dont la charge tient plusieurs
semaines), l’absence de connection Internet (pour les examens).<BR>
Les inconvénients : prix élevé, taille d’écran trop petite
pour faire des gros calculs (et puissance parfois insuffisante), 
plus difficile de charger/sauvegarder
des données dans des fichiers, pas de souris, l’utilisation du clavier peut
être pénible pour programmer ou saisir une ligne de commandes
un peu longue (le clavier des TI92 et des TI Nspire CX est
un bon compromis, l’écran tactile des HP Prime permet
de se passer de souris, il faudrait un hybride des deux!)<BR>
Bien adapté à l’enseignement (y compris dans le supérieur
même si elles y sont souvent dénigrées par les enseignants).
</LI><LI CLASS="li-itemize">Les avantages des ordinateurs (portables) : clavier, écran,
puissance de calcul, convient pour d’autres usages que le calcul.<BR>
Les inconvénients : poids/encombrement/fragilité, durée de charge
des batteries (souvent 3-4h), connectivité Internet pour les
examens.<BR>
Idéal en usage stationnaire.
</LI><LI CLASS="li-itemize">Les avantages des tablettes : disponibilité immédiate,
écran large, convient pour d’autres usages que le calcul.<BR>
Les inconvénients : saisie de données fastidieuse, encombrement
et fragilité, usage sans recharge limité à une (petite) 
journée, connectivité Internet en examen.<BR>
Peut être intéressant en mobilité
si on a beaucoup de documents à
consulter en ligne avec de temps en temps un petit calcul à
faire. Les tablettes avec possibilité de branchement
de clavier ont un potentiel intéressant pour un usage
en mobilité avec un peu plus de données à saisir.
</LI></UL><!--BEGIN NOTES document-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">1</A></DT><DD CLASS="dd-thefootnotes">Certains
systèmes de calcul formel (calculatrices par exemple) utilisent d’ailleurs des
méthodes spécifiques pour gérer le problème de la fragmentation de
la mémoire, appelés “garbage collector”. Ce type de méthode
est intégré dans des langages comme Lisp ou Java, en C/C++ on trouve
des libraries pour cela, par exemple GC de Boehm, incluse dans la
distribution de GCC.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note2" HREF="#text2">2</A></DT><DD CLASS="dd-thefootnotes">Les HP Prime utilisent Giac comme
noyau de calcul formel, les TI Nspire CAS utilisent sans doute une
version actualisée du système utilisé sur les TI 89, 92,
Voayge 200.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note3" HREF="#text3">3</A></DT><DD CLASS="dd-thefootnotes">un quartet=un demi octet
</DD><DT CLASS="dt-thefootnotes"><A NAME="note4" HREF="#text4">4</A></DT><DD CLASS="dd-thefootnotes">Plus précisément deux
piles, la pile de donnée et la pile gérant le flux d’exécution. Cette
dernière n’est pas visible par l’utilisateur
</DD><DT CLASS="dt-thefootnotes"><A NAME="note5" HREF="#text5">5</A></DT><DD CLASS="dd-thefootnotes">Sauf si
on utilise comme dernier argument le nombre d’arguments de la fonction ou 
si on utilise (cf. infra) un tag de début de liste d’arguments
</DD><DT CLASS="dt-thefootnotes"><A NAME="note6" HREF="#text6">6</A></DT><DD CLASS="dd-thefootnotes">Toutefois une adaptation du logiciel utilisant comme
quantum de base par exemple 32 bits porterait cette limite
à 65536<SUP>65535</SUP>−1
</DD><DT CLASS="dt-thefootnotes"><A NAME="note7" HREF="#text7">7</A></DT><DD CLASS="dd-thefootnotes">Si <I>r</I>′≠ 0,
cela se lit sur l’expression de la vitesse qui est non nulle, mais
c’est encore vrai si <I>r</I>(θ)=<I>r</I>′(θ)=0 et <I>r</I> non identiquement nul, 
pour le voir, on observe que <I>M</I>(θ)<I>M</I>(θ+<I>h</I>)=<I>OM</I>(θ+<I>h</I>) a pour
direction <I>e</I><SUB><I>r</I></SUB>(θ+<I>h</I>) qui tend vers <I>e</I><SUB><I>r</I></SUB>(θ) lorsque <I>h</I> tend
vers 0.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note8" HREF="#text8">8</A></DT><DD CLASS="dd-thefootnotes">En toute rigueur il faut ajouter deux autres cas ;
l’ensemble vide et les paires éventuellement confondues de droites
</DD><DT CLASS="dt-thefootnotes"><A NAME="note9" HREF="#text9">9</A></DT><DD CLASS="dd-thefootnotes">Si <I>d</I>=<I>e</I>=0, le
polynôme est homogène et se factorise,
on obtient l’origine ou la réunion de deux droites
</DD><DT CLASS="dt-thefootnotes"><A NAME="note10" HREF="#text10">10</A></DT><DD CLASS="dd-thefootnotes">Cette méthode
fonctionne pour les coniques, mais ne fonctionne malheureusement
pas pour n’importe quelle équation cartésienne
</DD><DT CLASS="dt-thefootnotes"><A NAME="note11" HREF="#text11">11</A></DT><DD CLASS="dd-thefootnotes">sinon, on 
aura deux droites parce que le
polynôme <I>P</I>(<I>x</I>,<I>y</I>) se factorise en produit de deux facteurs
de degré 1 dont <I>dx</I>+<I>ey</I>. Plus précisément, ce cas
correspond à <I>t</I>=−<I>d</I>/<I>e</I> racine de <I>ct</I><SUP>2</SUP>+<I>bt</I>+<I>a</I>=0
</DD><DT CLASS="dt-thefootnotes"><A NAME="note12" HREF="#text12">12</A></DT><DD CLASS="dd-thefootnotes">On peut aussi voir ce discriminant comme le
déterminant de la matrice de la forme quadratique associée
</DD><DT CLASS="dt-thefootnotes"><A NAME="note13" HREF="#text13">13</A></DT><DD CLASS="dd-thefootnotes">en négligeant la masse
de la planète devant celle du Soleil
</DD><DT CLASS="dt-thefootnotes"><A NAME="note14" HREF="#text14">14</A></DT><DD CLASS="dd-thefootnotes">qui tire
son nom de la trajectoire d’un point fixé à un cercle roulant
sans glisser sur une droite, par exemple l’extrémité d’un rayon 
sur une roue de vélo.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note15" HREF="#text15">15</A></DT><DD CLASS="dd-thefootnotes">L’enveloppe d’une famille
de droites est une courbe dont l’ensemble des tangentes est la famille de droite
</DD><DT CLASS="dt-thefootnotes"><A NAME="note16" HREF="#text16">16</A></DT><DD CLASS="dd-thefootnotes">Ce type de courbe, appelé
spirale d’Euler<A NAME="@default104"></A> ou de Fresnel<A NAME="@default105"></A> ou clothoïde<A NAME="@default106"></A>, est utilisée pour
faire des raccordements de chemin de fer (ou de route) 
entre une portion rectiligne, où l’accélération normale est
nulle, et un arc de cercle, où l’accélération normale est
constante, en effet si <I>Rs</I>=<I>b</I><SUP>2</SUP> est constant alors l’accélération
normale varie linéairement en fonction de l’abscisse curviligne
donc du temps à vitesse constante. C’est plus agréable pour
les passagers qui passent d’une accélération nulle à une
accélération constante progressivement, mais aussi pour
créer une pente progressive latérale sur les rails pour compenser
la force centrifuge par la gravité et éviter une usure
prématurée du rail.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note17" HREF="#text17">17</A></DT><DD CLASS="dd-thefootnotes">Géométriquement,
<I>dx</I> [resp. <I>dy</I>] est la forme linéaire constante
(i.e. indépendante du point du plan choisi) qui a tout vecteur de
ℝ<SUP>2</SUP> associe sa première [resp. deuxième] coordonnée :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>dx</I>(<I>v</I><SUB>1</SUB>,<I>v</I><SUB>2</SUB>)=<I>v</I><SUB>1</SUB>,    <I>dy</I>(<I>v</I><SUB>1</SUB>,<I>v</I><SUB>2</SUB>)=<I>v</I><SUB>2</SUB> </TD></TR>
</TABLE>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note18" HREF="#text18">18</A></DT><DD CLASS="dd-thefootnotes">Pour être complet, on suppose de plus que cette application
linéaire qui dépend du point du plan en dépend de manière 
continue voire différentiable
</DD><DT CLASS="dt-thefootnotes"><A NAME="note19" HREF="#text19">19</A></DT><DD CLASS="dd-thefootnotes">En toute rigueur,
il faut prouver que la solution maximale est bien définie sur
ℝ tout entier. Soit ]<I>t</I><SUB><I>m</I></SUB>,<I>t</I><SUB><I>M</I></SUB>[ l’intervalle maximal de
définition de la solution. Si <I>t</I><SUB><I>M</I></SUB> ≠ +∞,
alors en intégrant <I>y</I>′ qui est borné sur [<I>t</I><SUB>0</SUB>,<I>t</I><SUB><I>M</I></SUB>[ 
on obtient une valeur finie pour la limite en <I>t</I><SUB><I>M</I></SUB> de <I>y</I>(<I>t</I>),
on peut alors prolonger <I>y</I>(<I>t</I>) autour de <I>t</I><SUB><I>M</I></SUB>
en appliquant le théorème de Cauchy-Lipschitz en <I>t</I>=<I>t</I><SUB><I>M</I></SUB>,
ce qui est contradictoire avec l’hypothèse de maximalité. 
Donc <I>t</I><SUB><I>M</I></SUB>=+∞ et de même <I>t</I><SUB><I>m</I></SUB>=−∞
</DD><DT CLASS="dt-thefootnotes"><A NAME="note20" HREF="#text20">20</A></DT><DD CLASS="dd-thefootnotes">Cela vient du fait que
les puissances de <I>A</I> forment une famille d’un
espace vectoriel de dimension finie <I>n</I><SUP>2</SUP>, donc la famille est liée
à partir de <I>n</I><SUP>2</SUP>+1 éléments, en fait on peut montrer
que c’est le cas si on considère <I>I</I>,<I>A</I>,...,<I>A</I><SUP><I>n</I></SUP>.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note21" HREF="#text21">21</A></DT><DD CLASS="dd-thefootnotes">On peut prouver l’existence globale de la solution
exactement comme pour l’exemple <I>y</I>′=<I>y</I>(1−<I>y</I>) de la section 
<A HREF="#sec:existence">12.2</A>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note22" HREF="#text22">22</A></DT><DD CLASS="dd-thefootnotes">Pour une méthode à pas variable,
le pas <I>h</I> peut dépendre de <I>i</I>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note23" HREF="#text23">23</A></DT><DD CLASS="dd-thefootnotes">Il n’existe à ma connaissance
pas de résultat sur pourquoi ces choix de <I>f</I> donnent 
des entiers bien répartis par rapport au hasard
</DD><DT CLASS="dt-thefootnotes"><A NAME="note24" HREF="#text24">24</A></DT><DD CLASS="dd-thefootnotes">Rappelons qu’il s’agit d’une
majoration sur la valeur absolue des coefficients des facteurs de <I>P</I>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note25" HREF="#text25">25</A></DT><DD CLASS="dd-thefootnotes">Plus exactement, on multiplie <I>P</I><SUB><I>j</I></SUB> par le
coefficient dominant de <I>P</I> modulo <I>p</I><SUP><I>l</I></SUP>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note26" HREF="#text26">26</A></DT><DD CLASS="dd-thefootnotes">Ici |<I>P</I>| désigne le plus grand
coefficient de <I>P</I> en valeur absolue
</DD><DT CLASS="dt-thefootnotes"><A NAME="note27" HREF="#text27">27</A></DT><DD CLASS="dd-thefootnotes">cette preuve peut être sautée en première
lecture
</DD><DT CLASS="dt-thefootnotes"><A NAME="note28" HREF="#text28">28</A></DT><DD CLASS="dd-thefootnotes">Peut être omise en première lecture
</DD><DT CLASS="dt-thefootnotes"><A NAME="note29" HREF="#text29">29</A></DT><DD CLASS="dd-thefootnotes">Si <I>A</I> est la matrice companion
d’un polynôme, une autre approche 
consiste à rechercher un rectangle du plan complexe stable par itérée
de la méthode de Newton ou à calculer les disques
de centre les coefficients diagonaux et de rayon le
degré du polynôme divisé par un minorant de la
dérivée du polynôme par la valeur du polynôme
</DD><DT CLASS="dt-thefootnotes"><A NAME="note30" HREF="#text30">30</A></DT><DD CLASS="dd-thefootnotes">acronyme récursif de GiNac Is Not A Cas,
jeu de mot identique à Gnu is Not Unix, alors que Giac est
l’acronyme de Giac Is A Cas
</DD><DT CLASS="dt-thefootnotes"><A NAME="note31" HREF="#text31">31</A></DT><DD CLASS="dd-thefootnotes">Il serait d’ailleurs intéressant de calculer le 
cout énergétique d’un même calcul fait par Sage, Maxima, 
Xcas et une calculatrice formelle! Pour avoir un ordre
de grandeur, une recherche sur google émettrait 7g de CO2, 
soit environ 16Wh, de quoi faire fonctionner un ordinateur 
portable un quart d’heure et une calculatrice haut de gamme
pendant une journée
</DD><DT CLASS="dt-thefootnotes"><A NAME="note32" HREF="#text32">32</A></DT><DD CLASS="dd-thefootnotes">512M de RAM pour la
machine virtuelle linux, à quoi il faut ajouter 
le logiciel VirtualBox et le navigateur. De plus la taille des
calculs possibles est limitée par la RAM allouée à
la machine virtuelle.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note33" HREF="#text33">33</A></DT><DD CLASS="dd-thefootnotes">Ce qui est peut-être une bonne chose,
on peut le voir comme deux stratégies complémentaires pour le
calcul formel libre
</DD><DT CLASS="dt-thefootnotes"><A NAME="note34" HREF="#text34">34</A></DT><DD CLASS="dd-thefootnotes">ainsi Allan Steel, le principal codeur du logiciel 
Magma, dont l’attractivité doit tout au génie algorithmique de cet
auteur, n’apparait même pas dans la citation recommendée
du logiciel.
</DD></DL>
<!--END NOTES-->
<!--CUT END -->
<!--HTMLFOOT-->
Retour à la page principale de <A HREF="http://www-fourier.ujf-grenoble.fr/parisse/giac_fr.html">Giac/Xcas</A>.<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>Ce document a été traduit de L<sup>A</sup>T<sub>E</sub>X par </EM><A HREF="http://hevea.inria.fr"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A></BLOCKQUOTE></BODY>
</HTML>
