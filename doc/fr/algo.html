<!DOCTYPE html>
<html >
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.28">
<style type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding:0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.titlemain{margin:1ex 2ex 2ex 1ex;}
.titlerest{margin:0ex 2ex;}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
</style>
<title>Algorithmes de calcul formel et numérique
</title>
</head>
<body >
<!--HEVEA command line is: hevea -fix algo -->
<!--CUT STYLE article--><!--CUT DEF section 1 --><p>


<div>
<div id="maindiv" style="max-height: 500px; overflow:auto">

 </p><table class="title"><tr><td style="padding:1ex"><h1 class="titlemain">Algorithmes de calcul formel et numérique</h1><h3 class="titlerest">B. Parisse<br>
Institut Fourier<br>
UMR 5582 du CNRS
<br>
Université de Grenoble</h3></td></tr>
</table><p>La version HTML de ce document comporte des champs de saisie
interactifs, ceux-ci apparaissent comme des commandes “mortes” dans
la version PDF. La version HTML est
optimisée pour le navigateur Firefox. Vous pouvez
exécuter toutes les commandes interactives en cliquant sur le bouton
Exécuter, le champ suivant est la console de l’interpréteur du
logiciel de calcul formel.</p><blockquote class="abstract"><span style="font-weight:bold">Résumé: </span>
Giac/Xcas est un logiciel libre de calcul formel dont
une caractéristique est de nécessiter peu de ressources sans
sacrifier les performances (en particulier sur les calculs polynomiaux).
Ce document décrit une partie des algorithmes de calcul formel et
numérique qui y sont
impleémentés, l’objectif à long terme
est de couvrir l’essentiel des algorithmes implémentés.
Ce n’est pas le manuel d’utilisation de Xcas, ni un manuel de programmation
ou d’exercices illustrés avec Xcas (voir le menu Aide, Manuels :
Référence calcul formel, Programmation, Exercices, Amusements...).
Ce texte regroupe donc des résultats
mathématiques qui ont été ou sont utilisés dans Giac
(ou sont susceptibles de l’être),
ils sont en général accompagnés de preuves 
et souvent d’illustrations avec Xcas.<br>
Pour plus d’informations sur Giac/Xcas, cf. :<br>
<code>www-fourier.ujf-grenoble.fr/~parisse/giac_fr.html</code>
</blockquote><!--TOC section id="sec1" Table des matières-->
<h2 id="sec1" class="section">Table des matières</h2><!--SEC END --><ul class="toc"><li class="li-toc">
<a href="#sec2">1  Index, plan</a>
</li><li class="li-toc"><a href="#sec4">2  Trousse de survie Xcas</a>
<ul class="toc"><li class="li-toc">
<a href="#sec5">2.1  Utilisation comme super-calculatrice</a>
</li><li class="li-toc"><a href="#sec6">2.2  Calcul exact</a>
<ul class="toc"><li class="li-toc">
<a href="#sec7">2.2.1  Arithmétique</a>
</li><li class="li-toc"><a href="#sec8">2.2.2  Algèbre linéaire exacte</a>
</li></ul>
</li><li class="li-toc"><a href="#sec9">2.3  Calcul scientifique</a>
<ul class="toc"><li class="li-toc">
<a href="#sec10">2.3.1  Analyse numérique</a>
</li><li class="li-toc"><a href="#sec11">2.3.2  Algèbre linéaire numérique</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec12">3  Calculer sur ordinateur</a>
<ul class="toc"><li class="li-toc">
<a href="#sec13">3.1  Représentation des entiers</a>
</li><li class="li-toc"><a href="#sec14">3.2  Les réels</a>
<ul class="toc"><li class="li-toc">
<a href="#sec15">3.2.1  Virgule fixe et flottante.</a>
</li><li class="li-toc"><a href="#sec16">3.2.2  Les flottants au format <span style="font-family:monospace">double</span></a>
</li><li class="li-toc"><a href="#sec17">3.2.3  Opérations sur les flottants</a>
</li><li class="li-toc"><a href="#sec18">3.2.4  Erreurs</a>
</li><li class="li-toc"><a href="#sec19">3.2.5  Erreur absolue, relative, arrondi propagation des erreurs.</a>
</li></ul>
</li><li class="li-toc"><a href="#sec20">3.3  L’arithmétique d’intervalle.</a>
</li><li class="li-toc"><a href="#sec21">3.4  Calcul exact et approché, types, évaluation.</a>
</li><li class="li-toc"><a href="#sec22">3.5  Forme normale et reconnaissance du 0.</a>
</li><li class="li-toc"><a href="#sec23">3.6  Valeur générique des variables et
hypothèses</a>
</li><li class="li-toc"><a href="#sec24">3.7  Structures de données</a>
<ul class="toc"><li class="li-toc">
<a href="#sec25">3.7.1  Maple, Mathematica, ...</a>
</li><li class="li-toc"><a href="#sec26">3.7.2  Giac/Xcas</a>
</li><li class="li-toc"><a href="#sec27">3.7.3  Calculatrices formelles HP48/49</a>
</li><li class="li-toc"><a href="#sec28">3.7.4  Calculatrices formelles TI92/89/Voyage 200</a>
</li></ul>
</li><li class="li-toc"><a href="#sec29">3.8  Algorithmes et complexité.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec30">3.8.1  Algorithmes modulaires ou p-adiques</a>
</li><li class="li-toc"><a href="#sec31">3.8.2  Algorithmes déterministes. Algorithmes probabilistes: Las Vegas
et Monte-Carlo</a>
</li></ul>
</li><li class="li-toc"><a href="#sec32">3.9  Quelques algorithmes d’arithmétique de base.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec33">3.9.1  Exemple de multiplication rapide : l’algorithme de Karatsuba</a>
</li><li class="li-toc"><a href="#sec34">3.9.2  Calcul de la racine carrée entière</a>
</li><li class="li-toc"><a href="#sec35">3.9.3  Bezout sur les entiers et les fractions continues</a>
</li><li class="li-toc"><a href="#sec36">3.9.4  La puissance rapide itérative</a>
</li></ul>
</li><li class="li-toc"><a href="#sec37">3.10  Pour en savoir plus.</a>
</li><li class="li-toc"><a href="#sec38">3.11  Exercices sur types, calcul exact et approché, 
algorithmes de bases</a>
</li></ul>
</li><li class="li-toc"><a href="#sec39">4  Les générateurs de nombres pseudo-aléatoires.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec40">4.1  Selon la loi uniforme</a>
<ul class="toc"><li class="li-toc">
<a href="#sec41">4.1.1  Les générateurs congruentiels à 1 cran.</a>
</li><li class="li-toc"><a href="#sec42">4.1.2  Récurrence à <span style="font-style:italic">k</span> éléments</a>
</li><li class="li-toc"><a href="#sec43">4.1.3  Mersenne twister.</a>
</li></ul>
</li><li class="li-toc"><a href="#sec44">4.2  Selon plusieurs lois classiques</a>
</li></ul>
</li><li class="li-toc"><a href="#sec45">5  Le PGCD de polynômes.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec46">5.1  Le sous-résultant.</a>
</li><li class="li-toc"><a href="#sec47">5.2  Le pgcd en une variable.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec48">5.2.1  Le pgcd heuristique.</a>
</li><li class="li-toc"><a href="#sec49">5.2.2  Le pgcd modulaire</a>
</li></ul>
</li><li class="li-toc"><a href="#sec50">5.3  Le pgcd à plusieurs variables.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec51">5.3.1  Le pgcd heuristique.</a>
</li><li class="li-toc"><a href="#sec52">5.3.2  Le pgcd modulaire multivariables.</a>
</li><li class="li-toc"><a href="#sec53">5.3.3  EZGCD.</a>
</li></ul>
</li><li class="li-toc"><a href="#sec54">5.4  Quel algorithme choisir?</a>
</li><li class="li-toc"><a href="#sec55">5.5  Pour en savoir plus.</a>
</li></ul>
</li><li class="li-toc"><a href="#sec56">6  Le résultant</a>
<ul class="toc"><li class="li-toc">
<a href="#sec57">6.1  Définition</a>
</li><li class="li-toc"><a href="#sec58">6.2  Applications</a>
<ul class="toc"><li class="li-toc">
<a href="#sec59">6.2.1  Systèmes polynomiaux</a>
</li><li class="li-toc"><a href="#sec60">6.2.2  Identité de Bézout dans ℤ[<span style="font-style:italic">X</span>].</a>
</li></ul>
</li><li class="li-toc"><a href="#sec61">6.3  Résultant et degrés</a>
</li><li class="li-toc"><a href="#sec62">6.4  Lien avec l’algorithme du sous-résultant (calcul de PGCD)</a>
</li><li class="li-toc"><a href="#sec63">6.5  Calcul efficace du résultant</a>
</li></ul>
</li><li class="li-toc"><a href="#sec64">7  Localisation des racines</a>
<ul class="toc"><li class="li-toc">
<a href="#sec65">7.1  Majoration</a>
</li><li class="li-toc"><a href="#sec66">7.2  Les suites de Sturm.</a>
</li><li class="li-toc"><a href="#sec67">7.3  Autres algorithmes</a>
</li></ul>
</li><li class="li-toc"><a href="#sec68">8  Exercices (PGCD, résultant, ...)</a>
<ul class="toc"><li class="li-toc">
<a href="#sec69">8.1  Instructions</a>
<ul class="toc"><li class="li-toc">
<a href="#sec70">8.1.1  Entiers</a>
</li><li class="li-toc"><a href="#sec71">8.1.2  Polynômes</a>
</li><li class="li-toc"><a href="#sec72">8.1.3  Calculs modulo <span style="font-style:italic">n</span></a>
</li></ul>
</li><li class="li-toc"><a href="#sec73">8.2  Exercices PGCD</a>
</li><li class="li-toc"><a href="#sec74">8.3  Exercices (résultant)</a>
</li><li class="li-toc"><a href="#sec75">8.4  Exercice (Bézout modulaire)</a>
</li><li class="li-toc"><a href="#sec76">8.5  Exercice (Géométrie et résultants).</a>
</li><li class="li-toc"><a href="#sec77">8.6  Décalage entier entre racines.</a>
</li><li class="li-toc"><a href="#sec78">8.7  Exemple de correction de géométrie et résultant</a>
</li></ul>
</li><li class="li-toc"><a href="#sec79">9  Bases de Gröbner.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec80">9.1  Ordre et réduction</a>
</li><li class="li-toc"><a href="#sec81">9.2  Idéaux</a>
</li><li class="li-toc"><a href="#sec82">9.3  Introduction</a>
</li><li class="li-toc"><a href="#sec83">9.4  Checking a reconstructed Groebner basis</a>
</li><li class="li-toc"><a href="#sec84">9.5  Speeding up by learning from previous primes</a>
</li><li class="li-toc"><a href="#sec85">9.6  Giac/Xcas implementation and experimentation</a>
</li><li class="li-toc"><a href="#sec86">9.7  Conclusion</a>
</li><li class="li-toc"><a href="#sec87">9.8  Représentation rationnelle univariée 
(rur).</a>
</li></ul>
</li><li class="li-toc"><a href="#sec88">10  Courbes paramétriques et polaires</a>
<ul class="toc"><li class="li-toc">
<a href="#sec89">10.1  Introduction</a>
</li><li class="li-toc"><a href="#sec90">10.2  Représentation graphique</a>
</li><li class="li-toc"><a href="#sec91">10.3  Paramétrage</a>
</li><li class="li-toc"><a href="#sec92">10.4  Étude analytique d’une courbe en paramétrique</a>
<ul class="toc"><li class="li-toc">
<a href="#sec93">10.4.1  Rappel sur les graphes de fonction</a>
</li><li class="li-toc"><a href="#sec94">10.4.2  Domaine et périodicité</a>
</li><li class="li-toc"><a href="#sec95">10.4.3  Branches infinies</a>
</li><li class="li-toc"><a href="#sec96">10.4.4  Étude locale</a>
</li></ul>
</li><li class="li-toc"><a href="#sec97">10.5  Plan d’étude d’une courbe</a>
</li><li class="li-toc"><a href="#sec98">10.6  Courbes en polaires</a>
</li><li class="li-toc"><a href="#sec99">10.7  Coniques</a>
<ul class="toc"><li class="li-toc">
<a href="#sec100">10.7.1  Ellipse</a>
</li><li class="li-toc"><a href="#sec101">10.7.2  Parabole</a>
</li><li class="li-toc"><a href="#sec102">10.7.3  Hyperbole</a>
</li><li class="li-toc"><a href="#sec103">10.7.4  Paramétrisation rationnelle</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec104">11  Propriétés métriques des courbes.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec105">11.1  Longueur d’arc</a>
</li><li class="li-toc"><a href="#sec106">11.2  Courbure, repère de Frenet, accélération normale et
tangentielle.</a>
</li></ul>
</li><li class="li-toc"><a href="#sec107">12  Représentation des courbes implicites.</a>
</li><li class="li-toc"><a href="#sec108">13  Formes différentielles et intégrales curvilignes</a>
<ul class="toc"><li class="li-toc">
<a href="#sec109">13.1  Forme différentielle</a>
</li><li class="li-toc"><a href="#sec110">13.2  Intégrale curviligne</a>
</li><li class="li-toc"><a href="#sec111">13.3  Forme différentielle exacte</a>
</li><li class="li-toc"><a href="#sec112">13.4  Intégrale curviligne et intégrales doubles.</a>
</li></ul>
</li><li class="li-toc"><a href="#sec113">14  Équations et systèmes différentiels.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec114">14.1  Introduction et représentation graphique.</a>
</li><li class="li-toc"><a href="#sec115">14.2  Existence et unicité</a>
</li><li class="li-toc"><a href="#sec116">14.3  Quelques méthodes de résolution explicite.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec117">14.3.1  Équations à variables
séparables</a>
</li><li class="li-toc"><a href="#sec118">14.3.2  Équations linéaires</a>
</li><li class="li-toc"><a href="#sec119">14.3.3  Équations linéaires à coefficients constants</a>
</li><li class="li-toc"><a href="#sec120">14.3.4  Systèmes différentiels linéaires à coefficients
constants d’ordre 1.</a>
</li><li class="li-toc"><a href="#sec121">14.3.5  Intégrales premières.</a>
</li><li class="li-toc"><a href="#sec122">14.3.6  Quelques autres méthodes</a>
</li></ul>
</li><li class="li-toc"><a href="#sec123">14.4  Comportement asymptotique des solutions</a>
<ul class="toc"><li class="li-toc">
<a href="#sec124">14.4.1  Équations linéaires à coefficients constants 
d’ordre 1 et 2</a>
</li><li class="li-toc"><a href="#sec125">14.4.2  Forçage périodique</a>
</li><li class="li-toc"><a href="#sec126">14.4.3  Équation autonome sans second membre</a>
</li><li class="li-toc"><a href="#sec127">14.4.4  Systèmes linéaires</a>
</li><li class="li-toc"><a href="#sec128">14.4.5  Le modèle proie-prédateur</a>
</li><li class="li-toc"><a href="#sec129">14.4.6  Forçage près d’un point d’équilibre de système.</a>
</li></ul>
</li><li class="li-toc"><a href="#sec130">14.5  Résolution numérique</a>
<ul class="toc"><li class="li-toc">
<a href="#sec131">14.5.1  Méthodes à un pas</a>
</li><li class="li-toc"><a href="#sec132">14.5.2  Méthodes de Runge-Kutta (explicites)</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec133">15  Introduction au calcul variationnel</a>
</li><li class="li-toc"><a href="#sec134">16  Corps finis.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec135">16.1  Rappels</a>
</li><li class="li-toc"><a href="#sec136">16.2  Représentation des corps non premiers.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec137">16.2.1  Cas général.</a>
</li><li class="li-toc"><a href="#sec138">16.2.2  Corps de petit cardinal, cas de la caractéristique 2</a>
</li></ul>
</li><li class="li-toc"><a href="#sec139">16.3  Exercices</a>
</li><li class="li-toc"><a href="#sec140">16.4  Rappels de quelques complexités de base</a>
<ul class="toc"><li class="li-toc">
<a href="#sec141">16.4.1  Polynomes denses et entiers</a>
</li><li class="li-toc"><a href="#sec142">16.4.2  Algèbre linéaire dense</a>
</li></ul>
</li><li class="li-toc"><a href="#sec143">16.5  Codes linéaires et polynomiaux.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec144">16.5.1  Le bit de parité.</a>
</li><li class="li-toc"><a href="#sec145">16.5.2  Codes linéaires</a>
</li><li class="li-toc"><a href="#sec146">16.5.3  Codes polynomiaux</a>
</li><li class="li-toc"><a href="#sec147">16.5.4  Détection et correction d’erreur</a>
</li><li class="li-toc"><a href="#sec148">16.5.5  Distances</a>
</li><li class="li-toc"><a href="#sec149">16.5.6  Correction au mot le plus proche</a>
</li><li class="li-toc"><a href="#sec150">16.5.7  Codes de Hamming</a>
</li></ul>
</li><li class="li-toc"><a href="#sec151">16.6  Les codes de Reed-Solomon</a>
<ul class="toc"><li class="li-toc">
<a href="#sec152">16.6.1  Théorie</a>
</li><li class="li-toc"><a href="#sec153">16.6.2  Preuve du calcul de <span style="font-style:italic">l</span></a>
</li><li class="li-toc"><a href="#sec154">16.6.3  Avec Xcas</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec155">17  Factorisation des entiers et primalité.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec156">17.1  Le test de primalité de Pocklington.</a>
</li><li class="li-toc"><a href="#sec157">17.2  La méthode ρ de Pollard</a>
</li><li class="li-toc"><a href="#sec158">17.3  Le crible quadratique</a>
<ul class="toc"><li class="li-toc">
<a href="#sec159">17.3.1  Recherche de racine carrée modulo p</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec160">18  Factorisation des polynômes.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec161">18.1  Les facteurs multiples</a>
</li><li class="li-toc"><a href="#sec162">18.2  Factorisation en une variable</a>
<ul class="toc"><li class="li-toc">
<a href="#sec163">18.2.1  Factorisation dans ℤ/<span style="font-style:italic">p</span>ℤ[<span style="font-style:italic">X</span>]</a>
</li><li class="li-toc"><a href="#sec164">18.2.2  Distinct degree factorization</a>
</li><li class="li-toc"><a href="#sec165">18.2.3  La méthode de Cantor-Zassenhaus</a>
</li><li class="li-toc"><a href="#sec166">18.2.4  La méthode de Berlekamp</a>
</li><li class="li-toc"><a href="#sec167">18.2.5  Remontée (Hensel)</a>
</li><li class="li-toc"><a href="#sec168">18.2.6  Combinaison de facteurs</a>
</li></ul>
</li><li class="li-toc"><a href="#sec169">18.3  Factorisation à plusieurs variables</a>
</li><li class="li-toc"><a href="#sec170">18.4  Preuve de l’identité de Bézout généralisée</a>
</li><li class="li-toc"><a href="#sec171">18.5  Algorithme de Bézout généralisé</a>
</li><li class="li-toc"><a href="#sec172">18.6  Factorisation rationnelle et sur une extension</a>
</li><li class="li-toc"><a href="#sec173">18.7  Factorisation absolue</a>
</li><li class="li-toc"><a href="#sec174">18.8  Compléments</a>
</li><li class="li-toc"><a href="#sec175">18.9  Exercices (factorisation des polynômes)</a>
</li></ul>
</li><li class="li-toc"><a href="#sec176">19  Intégration formelle.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec177">19.1  Introduction</a>
</li><li class="li-toc"><a href="#sec178">19.2  Fonctions élémentaires</a>
<ul class="toc"><li class="li-toc">
<a href="#sec179">19.2.1  Extensions transcendantes, tour de variables</a>
</li><li class="li-toc"><a href="#sec180">19.2.2  Théorème de structure de Risch</a>
</li><li class="li-toc"><a href="#sec181">19.2.3  Théorème de Liouville</a>
</li></ul>
</li><li class="li-toc"><a href="#sec182">19.3  L’algorithme de Risch</a>
<ul class="toc"><li class="li-toc">
<a href="#sec183">19.3.1  Intégration d’une fraction propre</a>
</li><li class="li-toc"><a href="#sec184">19.3.2  Réduction sans facteurs multiples</a>
</li><li class="li-toc"><a href="#sec185">19.3.3  La partie logarithmique</a>
</li><li class="li-toc"><a href="#sec186">19.3.4  La partie polynomiale (généralisée)</a>
</li><li class="li-toc"><a href="#sec187">19.3.5  Extension logarithmique</a>
</li><li class="li-toc"><a href="#sec188">19.3.6  Extension exponentielle</a>
</li></ul>
</li><li class="li-toc"><a href="#sec189">19.4  Quelques références</a>
</li></ul>
</li><li class="li-toc"><a href="#sec190">20  Intégration numérique</a>
<ul class="toc"><li class="li-toc">
<a href="#sec191">20.1  Les rectangles et les trapèzes</a>
</li><li class="li-toc"><a href="#sec192">20.2  Ordre d’une méthode</a>
</li><li class="li-toc"><a href="#sec193">20.3  Simpson</a>
</li><li class="li-toc"><a href="#sec194">20.4  Newton-Cotes</a>
</li><li class="li-toc"><a href="#sec195">20.5  Calcul des poids <span style="font-style:italic">w</span><sub><span style="font-style:italic">i</span></sub></a>
</li><li class="li-toc"><a href="#sec196">20.6  En résumé</a>
</li><li class="li-toc"><a href="#sec197">20.7  Accélération de Richardson-Romberg</a>
</li><li class="li-toc"><a href="#sec198">20.8  Cas des fonctions périodiques.</a>
</li><li class="li-toc"><a href="#sec199">20.9  Quadratures gaussiennes.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec200">20.9.1  Description</a>
</li><li class="li-toc"><a href="#sec201">20.9.2  Calcul des poids</a>
</li><li class="li-toc"><a href="#sec202">20.9.3  Erreur d’une quadrature gaussienne</a>
</li></ul>
</li><li class="li-toc"><a href="#sec203">20.10  Méthode adaptative.</a>
</li><li class="li-toc"><a href="#sec204">20.11  Méthodes probabilistes.</a>
</li></ul>
</li><li class="li-toc"><a href="#sec205">21  Suites récurrentes et applications</a>
<ul class="toc"><li class="li-toc">
<a href="#sec206">21.1  Calcul de l’expression des suites récurrentes.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec207">21.1.1  Récurrence affine</a>
</li><li class="li-toc"><a href="#sec208">21.1.2  Utilisation de la base de Newton si <span style="font-style:italic">A</span>=<span style="font-style:italic">I</span><sub><span style="font-style:italic">d</span></sub> et <span style="font-style:italic">c</span>=1</a>
</li></ul>
</li><li class="li-toc"><a href="#sec209">21.2  Le point fixe dans ℝ</a>
</li><li class="li-toc"><a href="#sec210">21.3  Le point fixe dans ℝ<sup><span style="font-style:italic">n</span></sup></a>
</li><li class="li-toc"><a href="#sec211">21.4  La méthode de Newton dans ℝ.</a>
</li><li class="li-toc"><a href="#sec212">21.5  La méthode de Newton dans ℝ<sup><span style="font-style:italic">n</span></sup>.</a>
</li><li class="li-toc"><a href="#sec213">21.6  Calcul approché des racines complexes simples</a>
</li><li class="li-toc"><a href="#sec214">21.7  Méthodes de gradient (sans contrainte)</a>
</li></ul>
</li><li class="li-toc"><a href="#sec215">22  Algèbre linéaire</a>
<ul class="toc"><li class="li-toc">
<a href="#sec216">22.1  Résolution de systèmes, calcul de déterminant.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec217">22.1.1  La méthode du pivot de Gauß.</a>
</li><li class="li-toc"><a href="#sec218">22.1.2  Le déterminant.</a>
</li><li class="li-toc"><a href="#sec219">22.1.3  Systèmes linéaires</a>
</li><li class="li-toc"><a href="#sec220">22.1.4  Bézout et les <span style="font-style:italic">p</span>-adiques.</a>
</li><li class="li-toc"><a href="#sec221">22.1.5  Base du noyau</a>
</li></ul>
</li><li class="li-toc"><a href="#sec222">22.2  Algèbre linéaire sur ℤ</a>
<ul class="toc"><li class="li-toc">
<a href="#sec223">22.2.1  Calcul du déterminant d’une matrice à coefficient entiers</a>
</li><li class="li-toc"><a href="#sec224">22.2.2  Réduction de Hermite et Smith</a>
</li><li class="li-toc"><a href="#sec225">22.2.3  L’algorithme LLL.</a>
</li></ul>
</li><li class="li-toc"><a href="#sec226">22.3  Le pivot de Gauss numérique.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec227">22.3.1  Efficacité de l’algorithme</a>
</li><li class="li-toc"><a href="#sec228">22.3.2  Erreurs d’arrondis du pivot de Gauss</a>
</li></ul>
</li><li class="li-toc"><a href="#sec229">22.4  La méthode de factorisation <span style="font-style:italic">LU</span></a>
<ul class="toc"><li class="li-toc">
<a href="#sec230">22.4.1  Interprétation matricielle du pivot de Gauss</a>
</li><li class="li-toc"><a href="#sec231">22.4.2  Factorisation <span style="font-style:italic">PA</span>=<span style="font-style:italic">LU</span></a>
</li><li class="li-toc"><a href="#sec232">22.4.3  Applications de la décomposition <span style="font-style:italic">LU</span></a>
</li></ul>
</li><li class="li-toc"><a href="#sec233">22.5  La factorisation de Cholesky</a>
</li><li class="li-toc"><a href="#sec234">22.6  Conditionnement</a>
</li><li class="li-toc"><a href="#sec235">22.7  Réduction des endomorphismes</a>
<ul class="toc"><li class="li-toc">
<a href="#sec236">22.7.1  Le polynôme minimal (Krylov)</a>
</li><li class="li-toc"><a href="#sec237">22.7.2  Le polynôme caractéristique</a>
</li><li class="li-toc"><a href="#sec238">22.7.3  La méthode de Hessenberg</a>
</li><li class="li-toc"><a href="#sec239">22.7.4  La méthode de
Leverrier-Faddeev-Souriau</a>
</li><li class="li-toc"><a href="#sec240">22.7.5  Les vecteurs propres simples.</a>
</li><li class="li-toc"><a href="#sec241">22.7.6  La forme normale de Jordan</a>
</li><li class="li-toc"><a href="#sec242">22.7.7  Exemple 1</a>
</li><li class="li-toc"><a href="#sec243">22.7.8  Exemple 2</a>
</li><li class="li-toc"><a href="#sec244">22.7.9  Le polynôme minimal par Faddeev</a>
</li><li class="li-toc"><a href="#sec245">22.7.10  Formes normales rationnelles</a>
</li><li class="li-toc"><a href="#sec246">22.7.11  Fonctions analytiques</a>
</li></ul>
</li><li class="li-toc"><a href="#sec247">22.8  Quelques autres algorithmes utiles</a>
<ul class="toc"><li class="li-toc">
<a href="#sec248">22.8.1  Complexité asymptotique</a>
</li></ul>
</li><li class="li-toc"><a href="#sec249">22.9  Quelques méthodes alternatives au pivot</a>
<ul class="toc"><li class="li-toc">
<a href="#sec250">22.9.1  Factorisation <span style="font-style:italic">QR</span></a>
</li><li class="li-toc"><a href="#sec251">22.9.2  Méthodes itératives de
Jacobi, Gauss-Seidel, relaxation</a>
</li><li class="li-toc"><a href="#sec252">22.9.3  Méthode du gradient à pas constant</a>
</li><li class="li-toc"><a href="#sec253">22.9.4  Méthode itérative du gradient conjugué</a>
</li></ul>
</li><li class="li-toc"><a href="#sec254">22.10  Réduction approchée des endomorphismes</a>
<ul class="toc"><li class="li-toc">
<a href="#sec255">22.10.1  Méthode de la puissance</a>
</li><li class="li-toc"><a href="#sec256">22.10.2  Itérations inverses</a>
</li><li class="li-toc"><a href="#sec257">22.10.3  Elimination des valeurs propres trouvées</a>
</li><li class="li-toc"><a href="#sec258">22.10.4  Décomposition de Schur</a>
</li></ul>
</li><li class="li-toc"><a href="#sec259">22.11  Quelques références</a>
</li><li class="li-toc"><a href="#sec260">22.12  Exercices (algèbre linéaire)</a>
<ul class="toc"><li class="li-toc">
<a href="#sec261">22.12.1  Instructions</a>
</li><li class="li-toc"><a href="#sec262">22.12.2  Exercices</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec263">23  Approximation polynomiale</a>
<ul class="toc"><li class="li-toc">
<a href="#sec264">23.1  Polynôme de Lagrange</a>
<ul class="toc"><li class="li-toc">
<a href="#sec265">23.1.1  Existence et unicité</a>
</li><li class="li-toc"><a href="#sec266">23.1.2  Majoration de l’erreur d’interpolation.</a>
</li><li class="li-toc"><a href="#sec267">23.1.3  Calcul efficace du polynôme de
Lagrange.</a>
</li><li class="li-toc"><a href="#sec268">23.1.4  Sensibilité aux erreurs sur les données.</a>
</li></ul>
</li><li class="li-toc"><a href="#sec269">23.2  Interpolation aux points de Tchebyshev</a>
</li><li class="li-toc"><a href="#sec270">23.3  Interpolation de Hermite</a>
</li><li class="li-toc"><a href="#sec271">23.4  Polynômes de Bernstein et courbes de
Bézier</a>
</li><li class="li-toc"><a href="#sec272">23.5  Polynômes orthogonaux.</a>
</li><li class="li-toc"><a href="#sec273">23.6  Les splines</a>
</li></ul>
</li><li class="li-toc"><a href="#sec274">24  Développement de Taylor, asymptotiques, 
séries entières, fonctions usuelles</a>
<ul class="toc"><li class="li-toc">
<a href="#sec275">24.1  La fonction exponentielle</a>
</li><li class="li-toc"><a href="#sec276">24.2  Séries entières.</a>
</li><li class="li-toc"><a href="#sec277">24.3  Série alternée</a>
</li><li class="li-toc"><a href="#sec278">24.4  La fonction logarithme</a>
</li><li class="li-toc"><a href="#sec279">24.5  Approximants de Padé.</a>
</li><li class="li-toc"><a href="#sec280">24.6  Autres applications</a>
<ul class="toc"><li class="li-toc">
<a href="#sec281">24.6.1  Exemple : la fonction d’erreur (error fonction, <span style="font-family:monospace">erf</span>)</a>
</li><li class="li-toc"><a href="#sec282">24.6.2  Recherche de solutions d’équations différentielles</a>
</li><li class="li-toc"><a href="#sec283">24.6.3  Exemple : fonctions de Bessel d’ordre entier</a>
</li></ul>
</li><li class="li-toc"><a href="#sec284">24.7  Développements asymptotiques et séries
divergentes</a>
</li><li class="li-toc"><a href="#sec285">24.8  Séries formelles.</a>
</li></ul>
</li><li class="li-toc"><a href="#sec286">25  La transformée de Fourier discrète.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec287">25.1  Définition et propriétés</a>
</li><li class="li-toc"><a href="#sec288">25.2  La transformée de Fourier rapide</a>
</li><li class="li-toc"><a href="#sec289">25.3  Applications.</a>
</li></ul>
</li><li class="li-toc"><a href="#sec290">26  Le rayonnement solaire.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec291">26.1  L’insolation au cours de l’année.</a>
</li><li class="li-toc"><a href="#sec292">26.2  Les saisons</a>
</li><li class="li-toc"><a href="#sec293">26.3  L’orbite de la Terre.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec294">26.3.1  Calcul en utilisant le vecteur excentricité.</a>
</li><li class="li-toc"><a href="#sec295">26.3.2  Calcul par l’équation différentielle.</a>
</li><li class="li-toc"><a href="#sec296">26.3.3  Lois de Képler.</a>
</li></ul>
</li><li class="li-toc"><a href="#sec297">26.4  Quelques propriétés de l’ellipse</a>
</li><li class="li-toc"><a href="#sec298">26.5  Influence de l’ellipse sur les saisons</a>
</li><li class="li-toc"><a href="#sec299">26.6  L’équation du temps, la durée des
saisons.</a>
</li><li class="li-toc"><a href="#sec300">26.7  Les variations des paramètres orbitaux</a>
</li></ul>
</li><li class="li-toc"><a href="#sec301">27  La moyenne arithmético-géométrique.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec302">27.1  Définition et convergence</a>
</li><li class="li-toc"><a href="#sec303">27.2  Lien avec les intégrales elliptiques</a>
</li><li class="li-toc"><a href="#sec304">27.3  Application : calcul efficace du logarithme.</a>
</li></ul>
</li><li class="li-toc"><a href="#sec305">A  Bonus : le “making of” de Giac/Xcas</a>
<ul class="toc"><li class="li-toc">
<a href="#sec306">A.1  Comment le projet Giac/Xcas est né.</a>
</li><li class="li-toc"><a href="#sec307">A.2  L’enfance d’Xcas: 2000-2006</a>
</li><li class="li-toc"><a href="#sec308">A.3  La montée en puissance: 2007-2013</a>
</li><li class="li-toc"><a href="#sec309">A.4  Le présent et le futur proche</a>
</li><li class="li-toc"><a href="#sec310">A.5  Les concurrents open-source.</a>
</li></ul>
</li><li class="li-toc"><a href="#sec311">B  Quelques opinions.</a>
<ul class="toc"><li class="li-toc">
<a href="#sec312">B.1  Languages</a>
</li><li class="li-toc"><a href="#sec313">B.2  Le libre, la recherche et l’éducation</a>
</li><li class="li-toc"><a href="#sec314">B.3  Les maths et les outils de calcul.</a>
</li><li class="li-toc"><a href="#sec315">B.4  Calculatrices, tablettes ou PC ?</a>
</li></ul>
</li></ul>
<!--TOC section id="sec2" Index, plan-->
<h2 id="sec2" class="section">1  Index, plan</h2><!--SEC END --><p> <a id="sec:index"></a>
L’index commence page suivante dans la version PDF.</p><p>Quelques conseils de lecture :
</p><ul class="itemize"><li class="li-itemize">
Des aspects calcul numérique sont abordés dans les sections
<a href="#sec%3Acalculer">3</a> (représentation des données), 
<a href="#sec%3Aintnum">20</a> (intégration numérique),
<a href="#sec%3Arec">21</a> (point fixe, Newton), <a href="#sec%3Alinalg">22</a> (Gauss, LU,
conditionnement, Schur...), <a href="#sec%3Ainterp">23</a> et <a href="#sec%3Aseries">24</a>
(interpolation, approximation polynomiale),
<a href="#sec%3Adft">25</a> (transformée de Fourier discrète),
</li><li class="li-itemize">Des aspects calcul exact sont abordés dans les sections
<a href="#sec%3Acalculer">3</a> (représentation des données), 
<a href="#sec%3Apgcd">5</a> (PGCD), <a href="#sec%3Aresultant">6</a>
(résultant), <a href="#sec%3Aracines">7</a> (racines), <a href="#sec%3Agroebner">9</a>
(bases de Gröbner), <a href="#sec%3Agf">16</a> (corps
finis), <a href="#sec%3Aifactor">17</a>
et <a href="#sec%3Afactor">18</a> (factorisation des entiers et polynômes),
<a href="#sec%3Aintg">19</a> (calcul de primitives), <a href="#sec%3Alinalg">22</a> (algèbre
linéaire), <a href="#sec%3Aagm">27</a> (moyenne
arithmético-géométrique), 
</li><li class="li-itemize">le lecteur physicien trouvera peut-être un intérêt
aux chapitres tirés de mon cours de licence L2 courbes et
équations différentielles pour la physique,
sections <a href="#sec%3Acourbes">10</a>,
<a href="#sec%3Acourbes_m">11</a>, <a href="#sec%3Aimplicite">12</a>, <a href="#sec%3Adiff">13</a>,
<a href="#sec%3Aode">14</a>, <a href="#sec%3Alagrangien">15</a>, ainsi que le calcul de la
répartition du rayonnement solaire sur Terre <a href="#sec%3Asoleil">26</a>
</li></ul><!--TOC section id="sec3" Index-->
<h2 id="sec3" class="section">Index</h2><!--SEC END --><p></p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" ><ul class="indexenv"><li class="li-indexenv">
équation caractéristique, <a href="#hevea_default144">14.3.3</a>
</li><li class="li-indexenv">équation linéaire, <a href="#hevea_default142">14.3.2</a>
<br>
<br>
</li><li class="li-indexenv">Akritas, <a href="#hevea_default67">7.3</a>
</li><li class="li-indexenv">accélération normale, <a href="#hevea_default104">11.2</a>
</li><li class="li-indexenv">accélération tangentielle, <a href="#hevea_default103">11.2</a>
</li><li class="li-indexenv">action, <a href="#hevea_default159">15</a>
</li><li class="li-indexenv">affine, récurrence, <a href="#hevea_default229">21.1.1</a>
</li><li class="li-indexenv">aléatoire, <a href="#hevea_default45">4</a>
</li><li class="li-indexenv">algébrique, extension, <a href="#hevea_default21">3.7.2</a>, <a href="#hevea_default84">9.8</a>, <a href="#hevea_default200">18.6</a>, <a href="#hevea_default203">18.7</a>
</li><li class="li-indexenv">arrondi, <a href="#hevea_default4">3.2.1</a>
</li><li class="li-indexenv">assume, <a href="#hevea_default19">3.6</a>
</li><li class="li-indexenv">astroïde, <a href="#hevea_default111">11.2</a>
</li><li class="li-indexenv">asymptote, <a href="#hevea_default89">10.4.3</a>
</li><li class="li-indexenv">asymptotique, direction, <a href="#hevea_default88">10.4.3</a>
</li><li class="li-indexenv">atan, <a href="#hevea_default319">24.2</a>
</li><li class="li-indexenv">autonome, <a href="#hevea_default151">14.4.3</a>, <a href="#hevea_default153">14.4.4</a>
<br>
<br>
</li><li class="li-indexenv">Bézier, courbes de, <a href="#hevea_default307">23.4</a>
</li><li class="li-indexenv">Bézout généralisé, <a href="#hevea_default197">18.5</a>
</li><li class="li-indexenv">Bézout, identité de, <a href="#hevea_default32">3.9</a>
</li><li class="li-indexenv">Bézout, théorème, <a href="#hevea_default64">6.3</a>
</li><li class="li-indexenv">Bareiss, <a href="#hevea_default245">22.1.1</a>
</li><li class="li-indexenv">BCD, <a href="#hevea_default6">3.2.1</a>
</li><li class="li-indexenv">Berlekamp, <a href="#hevea_default194">18.2.4</a>
</li><li class="li-indexenv">Bernstein, polynômes de, <a href="#hevea_default306">23.4</a>
</li><li class="li-indexenv">Bessel, <a href="#hevea_default326">24.6.3</a>
</li><li class="li-indexenv">base, <a href="#hevea_default1">3.1</a>
</li><li class="li-indexenv">base de Gröbner, <a href="#hevea_default73">9</a>
</li><li class="li-indexenv">birégulier, <a href="#hevea_default92">10.4.4</a>
</li><li class="li-indexenv">bit, <a href="#hevea_default9">3.2.2</a>
</li><li class="li-indexenv">branche, infinie, <a href="#hevea_default86">10.4.3</a>
</li><li class="li-indexenv">branche, parabolique, <a href="#hevea_default87">10.4.3</a>
<br>
<br>
</li><li class="li-indexenv">Cantor-Zassenhaus, <a href="#hevea_default193">18.2.3</a>
</li><li class="li-indexenv">Cholesky, <a href="#hevea_default262">22.5</a>
</li><li class="li-indexenv">caractéristique,
équation, <a href="#hevea_default143">14.3.3</a>
</li><li class="li-indexenv">caractéristique, polynôme, <a href="#hevea_default270">22.7.2</a>
</li><li class="li-indexenv">caustique, <a href="#hevea_default112">11.2</a>
</li><li class="li-indexenv">centrale, force, <a href="#hevea_default148">14.3.5</a>
</li><li class="li-indexenv">certificat de primalité, <a href="#hevea_default183">17.1</a>
</li><li class="li-indexenv">chinois, <a href="#hevea_default34">3.9</a>
</li><li class="li-indexenv">clothoïde, <a href="#hevea_default115">11.2</a>
</li><li class="li-indexenv">code correcteur, <a href="#hevea_default170">16.5</a>
</li><li class="li-indexenv">code linéaire, <a href="#hevea_default168">16.5</a>
</li><li class="li-indexenv">code polynomial, <a href="#hevea_default169">16.5</a>
</li><li class="li-indexenv">conditionnement, <a href="#hevea_default264">22.6</a>
</li><li class="li-indexenv">congruentiel, générateur, <a href="#hevea_default47">4.1.1</a>
</li><li class="li-indexenv">conique, <a href="#hevea_default98">10.7</a>, <a href="#hevea_default124">12</a>
</li><li class="li-indexenv">constante de Lebesgue, <a href="#hevea_default302">23.1.4</a>
</li><li class="li-indexenv">contenu, <a href="#hevea_default50">5</a>
</li><li class="li-indexenv">continue, fraction, <a href="#hevea_default41">3.9.3</a>
</li><li class="li-indexenv">contractante, <a href="#hevea_default233">21.2</a>
</li><li class="li-indexenv">convexe, <a href="#hevea_default93">10.4.4</a>, <a href="#hevea_default94">10.4.4</a>, <a href="#hevea_default237">21.4</a>
</li><li class="li-indexenv">corps fini, <a href="#hevea_default163">16</a>
</li><li class="li-indexenv">correction d’erreur, <a href="#hevea_default172">16.5.4</a>
</li><li class="li-indexenv">cos, <a href="#hevea_default317">24.1</a>
</li><li class="li-indexenv">courbe implicite, <a href="#hevea_default123">12</a>
</li><li class="li-indexenv">courbure, <a href="#hevea_default108">11.2</a>
</li><li class="li-indexenv">courbure, rayon, <a href="#hevea_default105">11.2</a>
</li><li class="li-indexenv">crible, <a href="#hevea_default178">17</a>
</li><li class="li-indexenv">crible quadratique, <a href="#hevea_default186">17.3</a>
</li><li class="li-indexenv">curviligne, intégrale, <a href="#hevea_default129">13.2</a>
</li><li class="li-indexenv">cyclique, élément, <a href="#hevea_default167">16.2.1</a>
</li><li class="li-indexenv">cycloïde, <a href="#hevea_default102">11.1</a>, <a href="#hevea_default162">15</a>
<br>
<br>
</li><li class="li-indexenv">Danilevsky, <a href="#hevea_default274">22.7.3</a>
</li><li class="li-indexenv">Descartes, <a href="#hevea_default70">7.3</a>
</li><li class="li-indexenv">DFT, <a href="#hevea_default335">25</a>
</li><li class="li-indexenv">Dunford, <a href="#hevea_default280">22.7.10</a>
</li><li class="li-indexenv">Durand-Kerner, Weierstrass, <a href="#hevea_default242">21.6</a>
</li><li class="li-indexenv">dénormalisé, <a href="#hevea_default5">3.2.1</a>
</li><li class="li-indexenv">déterminant, <a href="#hevea_default246">22.1.2</a>
</li><li class="li-indexenv">déterministe, <a href="#hevea_default29">3.8.2</a>
</li><li class="li-indexenv">développée, <a href="#hevea_default109">11.2</a>
</li><li class="li-indexenv">développement asymptotique, <a href="#hevea_default327">24.7</a>
</li><li class="li-indexenv">déterminant, modulaire, <a href="#hevea_default247">22.1.2</a>
</li><li class="li-indexenv">ddf (distinct
degree factorization), <a href="#hevea_default192">18.2.2</a>
</li><li class="li-indexenv">différences divisées, <a href="#hevea_default300">23.1.3</a>
</li><li class="li-indexenv">différentielle, <a href="#hevea_default125">13.1</a>
</li><li class="li-indexenv">différentielle, forme, <a href="#hevea_default127">13.1</a>
</li><li class="li-indexenv">discriminant, <a href="#hevea_default62">6.1</a>
</li><li class="li-indexenv">distance d’un code, <a href="#hevea_default175">16.5.5</a>
</li><li class="li-indexenv">distance de Hamming, <a href="#hevea_default174">16.5.5</a>
</li><li class="li-indexenv">divisées, différences, <a href="#hevea_default299">23.1.3</a>
</li><li class="li-indexenv">diviseur élémentaire, <a href="#hevea_default256">22.2.2</a>
</li><li class="li-indexenv">division euclidienne, <a href="#hevea_default0">3.1</a>
</li><li class="li-indexenv">double, <a href="#hevea_default8">3.2.2</a>
<br>
<br>
</li><li class="li-indexenv">Ei, <a href="#hevea_default328">24.7</a>
</li><li class="li-indexenv">Euler, constante, <a href="#hevea_default330">24.7</a>
</li><li class="li-indexenv">Euler, Mac Laurin, <a href="#hevea_default222">20.7</a>
</li><li class="li-indexenv">Euler, méthode d’, <a href="#hevea_default156">14.5.1</a>
</li><li class="li-indexenv">Euler, spirale, <a href="#hevea_default113">11.2</a>
</li><li class="li-indexenv">Euler-Lagrange, <a href="#hevea_default160">15</a>
</li><li class="li-indexenv">ellipse, <a href="#hevea_default99">10.7.1</a>, <a href="#hevea_default346">26.4</a>
</li><li class="li-indexenv">elliptique, intégrale, <a href="#hevea_default350">27.2</a>
</li><li class="li-indexenv">enveloppe, <a href="#hevea_default110">11.2</a>
</li><li class="li-indexenv">erf, <a href="#hevea_default324">24.6.1</a>
</li><li class="li-indexenv">erreur, <a href="#hevea_default12">3.2.4</a>, <a href="#hevea_default13">3.2.5</a>, <a href="#hevea_default258">22.3.2</a>
</li><li class="li-indexenv">erreur absolue, <a href="#hevea_default14">3.2.5</a>
</li><li class="li-indexenv">erreur relative, <a href="#hevea_default15">3.2.5</a>
</li><li class="li-indexenv">erreur, fonction, <a href="#hevea_default325">24.6.1</a>
</li><li class="li-indexenv">evaluation, <a href="#hevea_default17">3.4</a>
</li><li class="li-indexenv">exacte, forme différentielle, <a href="#hevea_default131">13.3</a>
</li><li class="li-indexenv">excentricité, <a href="#hevea_default344">26.3.1</a>
</li><li class="li-indexenv">exp, <a href="#hevea_default314">24.1</a>
</li><li class="li-indexenv">exponentielle, <a href="#hevea_default315">24.1</a>
</li><li class="li-indexenv">exponentielle
intégrale, <a href="#hevea_default329">24.7</a>
</li><li class="li-indexenv">exposant, <a href="#hevea_default11">3.2.2</a>
</li><li class="li-indexenv">extension
algébrique, <a href="#hevea_default202">18.7</a>
</li><li class="li-indexenv">extension algébrique, <a href="#hevea_default20">3.7.2</a>, <a href="#hevea_default83">9.8</a>, <a href="#hevea_default199">18.6</a>
<br>
<br>
</li><li class="li-indexenv">Faddeev, <a href="#hevea_default276">22.7.4</a>
</li><li class="li-indexenv">FFT, <a href="#hevea_default338">25.2</a>
</li><li class="li-indexenv">Fourier, transformée
discrète, <a href="#hevea_default336">25</a>
</li><li class="li-indexenv">Frenet, <a href="#hevea_default106">11.2</a>
</li><li class="li-indexenv">Fresnel,
spirale, <a href="#hevea_default114">11.2</a>
</li><li class="li-indexenv">facteurs invariants, <a href="#hevea_default255">22.2.2</a>
</li><li class="li-indexenv">factorisation, <a href="#hevea_default177">17</a>, <a href="#hevea_default240">21.6</a>
</li><li class="li-indexenv">factorisation absolue, <a href="#hevea_default201">18.7</a>
</li><li class="li-indexenv">factorisation algébrique, <a href="#hevea_default198">18.6</a>
</li><li class="li-indexenv">factorisation de Cholesky, <a href="#hevea_default263">22.5</a>
</li><li class="li-indexenv">factorisation de Schur, <a href="#hevea_default292">22.10.4</a>
</li><li class="li-indexenv">factorisation LU, <a href="#hevea_default261">22.4</a>
</li><li class="li-indexenv">fermée, forme différentielle, <a href="#hevea_default133">13.3</a>
</li><li class="li-indexenv">fixe, point, <a href="#hevea_default232">21.2</a>
</li><li class="li-indexenv">flottant, <a href="#hevea_default7">3.2.2</a>
</li><li class="li-indexenv">forçage, <a href="#hevea_default150">14.4.2</a>
</li><li class="li-indexenv">force centrale, <a href="#hevea_default149">14.3.5</a>
</li><li class="li-indexenv">forme différentielle, <a href="#hevea_default128">13.1</a>
</li><li class="li-indexenv">formelles, séries, <a href="#hevea_default334">24.8</a>
</li><li class="li-indexenv">fraction continue, <a href="#hevea_default40">3.9.3</a>
<br>
<br>
</li><li class="li-indexenv">Gauß, <a href="#hevea_default244">22.1.1</a>
</li><li class="li-indexenv">Gauss-Seidel, <a href="#hevea_default285">22.9.2</a>
</li><li class="li-indexenv">GF, <a href="#hevea_default164">16</a>
</li><li class="li-indexenv">Givens, <a href="#hevea_default272">22.7.3</a>
</li><li class="li-indexenv">Gröbner, base de, <a href="#hevea_default72">9</a>
</li><li class="li-indexenv">Green-Riemann, <a href="#hevea_default136">13.4</a>
</li><li class="li-indexenv">générateur congruentiel, <a href="#hevea_default46">4.1.1</a>
</li><li class="li-indexenv">gaussienne, quadrature, <a href="#hevea_default224">20.9</a>
</li><li class="li-indexenv">gradient, <a href="#hevea_default126">13.1</a>
</li><li class="li-indexenv">gradient à pas constant, <a href="#hevea_default287">22.9.3</a>
</li><li class="li-indexenv">gradient conjugué, <a href="#hevea_default288">22.9.4</a>
</li><li class="li-indexenv">gravité, centre, <a href="#hevea_default138">13.4</a>
<br>
<br>
</li><li class="li-indexenv">Hörner, <a href="#hevea_default35">3.9</a>, <a href="#hevea_default44">3.11</a>
</li><li class="li-indexenv">Hadamard, borne, <a href="#hevea_default249">22.1.2</a>
</li><li class="li-indexenv">Hamming, <a href="#hevea_default173">16.5.5</a>
</li><li class="li-indexenv">Hensel, <a href="#hevea_default59">5.3.3</a>, <a href="#hevea_default195">18.2.5</a>
</li><li class="li-indexenv">Hermite (forme
de), <a href="#hevea_default253">22.2.2</a>
</li><li class="li-indexenv">Hermite, interpolation de, <a href="#hevea_default305">23.3</a>
</li><li class="li-indexenv">Hermite, réduction de, <a href="#hevea_default209">19.3.1</a>
</li><li class="li-indexenv">Hessenberg, <a href="#hevea_default271">22.7.3</a>
</li><li class="li-indexenv">Householder, <a href="#hevea_default273">22.7.3</a>
</li><li class="li-indexenv">hamiltonien, <a href="#hevea_default161">15</a>
</li><li class="li-indexenv">heuristique, PGCD, <a href="#hevea_default53">5.2.1</a>, <a href="#hevea_default57">5.3.1</a>
</li><li class="li-indexenv">hyperbole, <a href="#hevea_default101">10.7.4</a>
</li><li class="li-indexenv">hypothèse, <a href="#hevea_default18">3.6</a>
<br>
<br>
</li><li class="li-indexenv">idéal, <a href="#hevea_default78">9.2</a>
</li><li class="li-indexenv">implicite,
courbe, <a href="#hevea_default122">12</a>
</li><li class="li-indexenv">inertie, moment, <a href="#hevea_default137">13.4</a>
</li><li class="li-indexenv">inflexion, <a href="#hevea_default95">10.4.4</a>
</li><li class="li-indexenv">insolation, <a href="#hevea_default341">26.1</a>
</li><li class="li-indexenv">intégrale curviligne, <a href="#hevea_default130">13.2</a>
</li><li class="li-indexenv">intégrale première, <a href="#hevea_default147">14.3.5</a>
</li><li class="li-indexenv">intégration, <a href="#hevea_default207">19</a>
</li><li class="li-indexenv">integration, <a href="#hevea_default211">20</a>
</li><li class="li-indexenv">interpolation, <a href="#hevea_default295">23.1</a>, <a href="#hevea_default297">23.1.1</a>
</li><li class="li-indexenv">intersection de
courbes, <a href="#hevea_default63">6.3</a>
</li></ul></td><td style="vertical-align:top;text-align:left;" ><ul class="indexenv"><li class="li-indexenv">intervalle, arithmétique, <a href="#hevea_default16">3.3</a>
</li><li class="li-indexenv">irréductible, <a href="#hevea_default166">16.2.1</a>
</li><li class="li-indexenv">isolation de racines, <a href="#hevea_default69">7.3</a>
</li><li class="li-indexenv">itérations inverses, <a href="#hevea_default290">22.10.2</a>
<br>
<br>
</li><li class="li-indexenv">Jacobi, <a href="#hevea_default284">22.9.2</a>
</li><li class="li-indexenv">Jordan, <a href="#hevea_default278">22.7.6</a>
</li><li class="li-indexenv">Jordan rationnel, <a href="#hevea_default279">22.7.10</a>
<br>
<br>
</li><li class="li-indexenv">Képler, <a href="#hevea_default345">26.3.3</a>
</li><li class="li-indexenv">Karatsuba, <a href="#hevea_default38">3.9.1</a>
</li><li class="li-indexenv">Krylov, <a href="#hevea_default269">22.7.1</a>
</li><li class="li-indexenv">knapsack, <a href="#hevea_default196">18.2.6</a>
<br>
<br>
</li><li class="li-indexenv">Lagrange, <a href="#hevea_default294">23.1</a>
</li><li class="li-indexenv">Landau, <a href="#hevea_default55">5.2.2</a>
</li><li class="li-indexenv">Laplace
(déterminant), <a href="#hevea_default250">22.1.2</a>
</li><li class="li-indexenv">Las Vegas, <a href="#hevea_default27">3.8.2</a>
</li><li class="li-indexenv">Lebesgue, constante
de, <a href="#hevea_default301">23.1.4</a>
</li><li class="li-indexenv">Legendre, <a href="#hevea_default310">23.5</a>
</li><li class="li-indexenv">Leverrier, <a href="#hevea_default275">22.7.4</a>
</li><li class="li-indexenv">Liouville, <a href="#hevea_default208">19.2.3</a>
</li><li class="li-indexenv">LLL, <a href="#hevea_default257">22.2.3</a>
</li><li class="li-indexenv">LU, <a href="#hevea_default260">22.4</a>
</li><li class="li-indexenv">lagrange, <a href="#hevea_default296">23.1.1</a>, <a href="#hevea_default298">23.1.2</a>
</li><li class="li-indexenv">lagrangien, <a href="#hevea_default158">15</a>
</li><li class="li-indexenv">lexicographique, <a href="#hevea_default76">9.1</a>
</li><li class="li-indexenv">linéaire,
équation, <a href="#hevea_default141">14.3.2</a>
</li><li class="li-indexenv">linéaire, récurrence, <a href="#hevea_default230">21.1.1</a>
</li><li class="li-indexenv">linéaire, système différentiel, <a href="#hevea_default145">14.3.4</a>, <a href="#hevea_default152">14.4.4</a>
</li><li class="li-indexenv">ln, <a href="#hevea_default321">24.4</a>
</li><li class="li-indexenv">logarithme, <a href="#hevea_default322">24.4</a>, <a href="#hevea_default351">27.3</a>
<br>
<br>
</li><li class="li-indexenv">Mac Laurin, Euler, <a href="#hevea_default223">20.7</a>
</li><li class="li-indexenv">Mignotte, <a href="#hevea_default56">5.2.2</a>
</li><li class="li-indexenv">Miller, <a href="#hevea_default36">3.9</a>, <a href="#hevea_default179">17</a>
</li><li class="li-indexenv">Monte-Carlo, <a href="#hevea_default28">3.8.2</a>, <a href="#hevea_default226">20.11</a>
</li><li class="li-indexenv">mantisse, <a href="#hevea_default2">3.2.1</a>, <a href="#hevea_default10">3.2.2</a>
</li><li class="li-indexenv">minimal, polynôme, <a href="#hevea_default268">22.7.1</a>
</li><li class="li-indexenv">modèle proie-prédateur, <a href="#hevea_default155">14.4.5</a>
</li><li class="li-indexenv">modulaire symétrique, <a href="#hevea_default26">3.8.1</a>
</li><li class="li-indexenv">modulaire, déterminant, <a href="#hevea_default248">22.1.2</a>
</li><li class="li-indexenv">modulaire, méthode, <a href="#hevea_default22">3.8.1</a>
</li><li class="li-indexenv">modulaire, PGCD, <a href="#hevea_default54">5.2.2</a>, <a href="#hevea_default58">5.3.2</a>
</li><li class="li-indexenv">moyenne arithmético-géométrique, <a href="#hevea_default349">27</a>
</li><li class="li-indexenv">multiplicité, <a href="#hevea_default190">18.1</a>
<br>
<br>
</li><li class="li-indexenv">Newton, <a href="#hevea_default236">21.4</a>, <a href="#hevea_default238">21.4</a>, <a href="#hevea_default239">21.5</a>
</li><li class="li-indexenv">Newton, base de, <a href="#hevea_default231">21.1.2</a>
</li><li class="li-indexenv">Newton, méthode de, <a href="#hevea_default25">3.8.1</a>
</li><li class="li-indexenv">Newton-Cotes, <a href="#hevea_default219">20.4</a>
</li><li class="li-indexenv">nombre de condition, <a href="#hevea_default265">22.6</a>
</li><li class="li-indexenv">normale, loi, <a href="#hevea_default48">4.2</a>
</li><li class="li-indexenv">normalisé, <a href="#hevea_default3">3.2.1</a>
</li><li class="li-indexenv">noyau, <a href="#hevea_default252">22.1.5</a>
<br>
<br>
</li><li class="li-indexenv">orbite de la Terre, <a href="#hevea_default343">26.3</a>
</li><li class="li-indexenv">ordre, <a href="#hevea_default216">20.2</a>
</li><li class="li-indexenv">ordre de monômes, <a href="#hevea_default74">9.1</a>
</li><li class="li-indexenv">orthogonaux, polynômes, <a href="#hevea_default308">23.5</a>
</li><li class="li-indexenv">osculateur, cercle, <a href="#hevea_default107">11.2</a>
<br>
<br>
</li><li class="li-indexenv">Péano, noyau de, <a href="#hevea_default217">20.2</a>
</li><li class="li-indexenv">Padé, <a href="#hevea_default323">24.5</a>
</li><li class="li-indexenv">PGCD (polynômes), <a href="#hevea_default49">5</a>
</li><li class="li-indexenv">Pocklington, <a href="#hevea_default181">17.1</a>
</li><li class="li-indexenv">Pollard, <a href="#hevea_default185">17.2</a>
</li><li class="li-indexenv">p-adique (système linéaire), <a href="#hevea_default251">22.1.3</a>
</li><li class="li-indexenv">p-adique, méthode, <a href="#hevea_default23">3.8.1</a>
</li><li class="li-indexenv">parabole, <a href="#hevea_default100">10.7.2</a>
</li><li class="li-indexenv">paramétrique, courbe, <a href="#hevea_default85">10.4</a>
</li><li class="li-indexenv">parité (bit de), <a href="#hevea_default171">16.5.1</a>
</li><li class="li-indexenv">pas constant, gradient, <a href="#hevea_default286">22.9.3</a>
</li><li class="li-indexenv">pi,
calcul de, <a href="#hevea_default352">27.3</a>
</li><li class="li-indexenv">pivot, <a href="#hevea_default243">22.1.1</a>
</li><li class="li-indexenv">pivot partiel, <a href="#hevea_default259">22.3.2</a>
</li><li class="li-indexenv">point
régulier, <a href="#hevea_default116">12</a>
</li><li class="li-indexenv">point fixe, <a href="#hevea_default234">21.2</a>
</li><li class="li-indexenv">point milieu, <a href="#hevea_default215">20.1</a>
</li><li class="li-indexenv">point singulier, <a href="#hevea_default118">12</a>
</li><li class="li-indexenv">point singulier ordinaire, <a href="#hevea_default121">12</a>
</li><li class="li-indexenv">point singulier régulier, <a href="#hevea_default120">12</a>
</li><li class="li-indexenv">polaire, courbe, <a href="#hevea_default97">10.6</a>
</li><li class="li-indexenv">polynôme symétrique, <a href="#hevea_default204">18.8</a>
</li><li class="li-indexenv">polynômes orthogonaux, <a href="#hevea_default309">23.5</a>
</li><li class="li-indexenv">potentiel, <a href="#hevea_default132">13.3</a>, <a href="#hevea_default134">13.3</a>
</li><li class="li-indexenv">première,
intégrale, <a href="#hevea_default146">14.3.5</a>
</li><li class="li-indexenv">primalité, <a href="#hevea_default182">17.1</a>
</li><li class="li-indexenv">primalité, certificat, <a href="#hevea_default184">17.1</a>
</li><li class="li-indexenv">primitif, <a href="#hevea_default165">16.2.1</a>
</li><li class="li-indexenv">primitive, partie, <a href="#hevea_default51">5</a>
</li><li class="li-indexenv">probabiliste, <a href="#hevea_default30">3.8.2</a>
</li><li class="li-indexenv">proie-prédateur, modèle, <a href="#hevea_default154">14.4.5</a>
</li><li class="li-indexenv">pseudo-division, <a href="#hevea_default31">3.9</a>
</li><li class="li-indexenv">puissance, <a href="#hevea_default289">22.10.1</a>
</li><li class="li-indexenv">puissance
rapide, <a href="#hevea_default42">3.9.4</a>
<br>
<br>
</li><li class="li-indexenv">QR, <a href="#hevea_default283">22.9.1</a>, <a href="#hevea_default293">22.10.4</a>
</li><li class="li-indexenv">quadratique, crible, <a href="#hevea_default187">17.3</a>
</li><li class="li-indexenv">quadrature, <a href="#hevea_default212">20</a>
</li><li class="li-indexenv">quadrature gaussienne, <a href="#hevea_default225">20.9</a>
<br>
<br>
</li><li class="li-indexenv">Rabin, <a href="#hevea_default37">3.9</a>, <a href="#hevea_default180">17</a>
</li><li class="li-indexenv">Reed-Solomon (codes), <a href="#hevea_default176">16.6</a>
</li><li class="li-indexenv">Richardson-Romberg, <a href="#hevea_default221">20.7</a>
</li><li class="li-indexenv">Risch, <a href="#hevea_default206">19</a>
</li><li class="li-indexenv">Romberg, <a href="#hevea_default220">20.7</a>
</li><li class="li-indexenv">Rothstein, <a href="#hevea_default210">19.3.6</a>
</li><li class="li-indexenv">Runge, phénomène de, <a href="#hevea_default304">23.2</a>
</li><li class="li-indexenv">Runge-Kutta, <a href="#hevea_default157">14.5.2</a>
</li><li class="li-indexenv">récurrence, <a href="#hevea_default227">21</a>
</li><li class="li-indexenv">régulier, point, <a href="#hevea_default90">10.4.4</a>, <a href="#hevea_default117">12</a>
</li><li class="li-indexenv">réduction, <a href="#hevea_default75">9.1</a>
</li><li class="li-indexenv">racine, <a href="#hevea_default241">21.6</a>
</li><li class="li-indexenv">racine carrée entière, <a href="#hevea_default39">3.9.2</a>
</li><li class="li-indexenv">racine carrée modulaire, <a href="#hevea_default188">17.3.1</a>
</li><li class="li-indexenv">racine rationnelle, <a href="#hevea_default24">3.8.1</a>
</li><li class="li-indexenv">rapide, puissance, <a href="#hevea_default43">3.9.4</a>
</li><li class="li-indexenv">rapide, transformée de
Fourier, <a href="#hevea_default340">25.2</a>
</li><li class="li-indexenv">rationnelle, représentation
univariée, <a href="#hevea_default81">9.8</a>
</li><li class="li-indexenv">rebroussement, <a href="#hevea_default96">10.4.4</a>
</li><li class="li-indexenv">rectangle, <a href="#hevea_default213">20.1</a>
</li><li class="li-indexenv">regle des signes, <a href="#hevea_default71">7.3</a>
</li><li class="li-indexenv">relaxation, <a href="#hevea_default235">21.2</a>
</li><li class="li-indexenv">représentation rationnelle univariée, <a href="#hevea_default82">9.8</a>
</li><li class="li-indexenv">restes chinois, <a href="#hevea_default33">3.9</a>
</li><li class="li-indexenv">resultant, <a href="#hevea_default60">6</a>
</li><li class="li-indexenv">revlex, <a href="#hevea_default77">9.1</a>
</li><li class="li-indexenv">rur, <a href="#hevea_default80">9.8</a>
<br>
<br>
</li><li class="li-indexenv">Schur (factorisation), <a href="#hevea_default291">22.10.4</a>
</li><li class="li-indexenv">Si, <a href="#hevea_default331">24.7</a>
</li><li class="li-indexenv">Simpson, <a href="#hevea_default218">20.3</a>
</li><li class="li-indexenv">Smith (forme de), <a href="#hevea_default254">22.2.2</a>
</li><li class="li-indexenv">Souriau, <a href="#hevea_default277">22.7.4</a>
</li><li class="li-indexenv">Stokes, <a href="#hevea_default135">13.4</a>
</li><li class="li-indexenv">Strassen, <a href="#hevea_default281">22.8.1</a>
</li><li class="li-indexenv">Strzebonski, <a href="#hevea_default68">7.3</a>
</li><li class="li-indexenv">Sturm, suites de, <a href="#hevea_default65">7.2</a>
</li><li class="li-indexenv">Sylvester, <a href="#hevea_default61">6.1</a>
</li><li class="li-indexenv">s-polynôme, <a href="#hevea_default79">9.2</a>
</li><li class="li-indexenv">séparables, variables, <a href="#hevea_default139">14.3.1</a>
</li><li class="li-indexenv">série altèrnée, <a href="#hevea_default320">24.3</a>
</li><li class="li-indexenv">série entière, <a href="#hevea_default318">24.2</a>
</li><li class="li-indexenv">séries formelles, <a href="#hevea_default333">24.8</a>
</li><li class="li-indexenv">saisons, <a href="#hevea_default342">26.2</a>
</li><li class="li-indexenv">saisons, durée, <a href="#hevea_default348">26.6</a>
</li><li class="li-indexenv">sin, <a href="#hevea_default316">24.1</a>
</li><li class="li-indexenv">singulière, valeur, <a href="#hevea_default266">22.6</a>
</li><li class="li-indexenv">singulier, point, <a href="#hevea_default91">10.4.4</a>, <a href="#hevea_default119">12</a>
</li><li class="li-indexenv">sinus intégral, <a href="#hevea_default332">24.7</a>
</li><li class="li-indexenv">sous-résultant, <a href="#hevea_default52">5.1</a>
</li><li class="li-indexenv">splines, <a href="#hevea_default311">23.6</a>
</li><li class="li-indexenv">squarefree, <a href="#hevea_default191">18.1</a>
</li><li class="li-indexenv">suite, <a href="#hevea_default228">21</a>
</li><li class="li-indexenv">symétrique, polynôme, <a href="#hevea_default205">18.8</a>
<br>
<br>
</li><li class="li-indexenv">Taylor, <a href="#hevea_default313">24</a>
</li><li class="li-indexenv">Taylor, développement, <a href="#hevea_default312">24</a>
</li><li class="li-indexenv">Tchebyshev, <a href="#hevea_default303">23.2</a>
</li><li class="li-indexenv">temps, équation du, <a href="#hevea_default347">26.6</a>
</li><li class="li-indexenv">transformée de Fourier discrète, <a href="#hevea_default337">25</a>
</li><li class="li-indexenv">transformée de Fourier rapide, <a href="#hevea_default339">25.2</a>
</li><li class="li-indexenv">trapèze, <a href="#hevea_default214">20.1</a>
<br>
<br>
</li><li class="li-indexenv">Vincent, <a href="#hevea_default66">7.3</a>
</li><li class="li-indexenv">valeur singulière, <a href="#hevea_default267">22.6</a>
</li><li class="li-indexenv">variables séparables, <a href="#hevea_default140">14.3.1</a>
<br>
<br>
</li><li class="li-indexenv">Winograd, <a href="#hevea_default282">22.8.1</a>
<br>
<br>
</li><li class="li-indexenv">Yun, <a href="#hevea_default189">18.1</a>
</li></ul></td></tr>
</table>
<!--TOC section id="sec4" Trousse de survie Xcas-->
<h2 id="sec4" class="section">2  Trousse de survie Xcas</h2><!--SEC END --><p> <a id="sec:survie"></a>
Cette section peut être vue comme un tutoriel très abrégé 
pour rapidement
prendre en main Xcas par des exemples au niveau fin de licence
master de mathématique et préparation aux concours de recrutement
d’enseignants. Le lecteur pourra consulter le tutoriel calcul
formel (menu Xcas, Aide, Débuter en calcul formel, tutoriel) pour
plus de détails ou/et à un niveau mathématique moins élevé.</p>
<!--TOC subsection id="sec5" Utilisation comme super-calculatrice-->
<h3 id="sec5" class="subsection">2.1  Utilisation comme super-calculatrice</h3><!--SEC END --><ul class="itemize"><li class="li-itemize">
On saisit une ligne de commande, on tape sur la touche Entree pour
l’évaluer. On peut saisir plusieurs commandes sur une même ligne
en les séparant par <code>;</code> (affiche le résultat) ou
<code>:;</code> (n’affiche pas le résultat).
La syntaxe respecte les priorités usuelles des 
opérateurs, attention il faut toujours saisir le signe <code>*</code>
pour effectuer une multiplication (sauf raccourcis dans lécriture
de monômes comme <code>2x</code>). Mettez des parenthèses en cas de doute.

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">2x^3; x/2/y; x/(2*y);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">Si on entre des données exactes, les calculs sont exacts

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">1/2-1/3
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

on peut alors convertir en approché avec <code>evalf</code>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">evalf(sin(1))
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

Si on entre au moins une donnée approchée (nombre avec point
décimal), les calculs sont approchés

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">1/2.0-1/3
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

Les nombres flottants peuvent être saisis avec lécriture standard
mantisse/exposant séparés par <code>e</code>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">Avogadro:=6.02e23; eps:=1e-10;
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">On peut stocker des résultats dans des variables
pour les réutiliser ensuite

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">a:=pi^2/6; evalf(a);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

On peut effacer le contenu d’une variable avec <code>purge</code>, elle
redevient alors libre (elle s’évalue en elle-même)

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">purge(a); a;
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

Les noms de variable peuvent contenir plusieurs lettres

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">xy/y; x*y/y;
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">Les noms de commande et mots-clefs du logiciel sont en général
affichés avec une couleur spécifique. Les menus permettent
de trouver les commandes par thème (menus Outils dans Xcas pour
les plus courantes, menu Graphe avec des assistants pour les 
représentations graphiques les plus courantes, 
menu Cmd pour un ensemble plus
complet). La ligne de commande permet
en général de compléter un début de nom de commande (touche
tabulation). L’appui sur la touche tabulation après
un nom de commande ou la sélection du menu Aide, Index dans
Xcas ouvre l’aide en ligne
courte, avec une description rapide de la commande et
quelques exemples types que l’on peut copier-coller et adapter.
On peut aussi obtenir une aide plus détaillée (boutons Details
dans Xcas).
</li><li class="li-itemize">Les listes sont délimitées par des crochets et servent
à représenter des vecteurs. Les listes de listes de même taille
servent à représenter des matrices. On accède à un élément
d’une liste en donnant le nom de variable de la liste puis l’indice
de l’élément entre crochet, en commençant à 0 (mettre deux crochets
pour commencer à 1).
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">v:=[1,2]; M:=[[1,2],[3,4]]; w:=M*v; w[0]; w[[1]]; M[0,0]:=-1; M*v; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">Pour afficher les étapes intermédiaires de certains calculs, exécutez<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">step_infolevel:=1
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
pour ne pas les afficher<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">step_infolevel:=0
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li></ul>
<!--TOC subsection id="sec6" Calcul exact-->
<h3 id="sec6" class="subsection">2.2  Calcul exact</h3><!--SEC END -->
<!--TOC subsubsection id="sec7" Arithmétique-->
<h4 id="sec7" class="subsubsection">2.2.1  Arithmétique</h4><!--SEC END --><ul class="itemize"><li class="li-itemize">
division euclidienne des entiers

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">a:=25; b:=7; q:=iquo(25,7); r:=irem(25,7); b*q+r;
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">PGCD, identité de Bézout sur les entiers

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">a:=25; b:=7; gcd(a,b); u,v,d:=iegcd(a,b); a*u+b*v; u,v:=iabcuv(a,b,37); a*u+b*v
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">restes chinois entiers

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">ichinrem([2,13],[3,17])
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">primalité, décomposition en facteurs premiers

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">a:=2^64+1;isprime(a); ifactor(a);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">puissance modulaire rapide

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">a:=256789; b:=1234567; m:=345678; powmod(a,b,m);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">division euclidienne des polynômes, la variable par défaut est <span style="font-style:italic">x</span>,
sinon il faut la spécifier en dernier argument
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">a:=x^4+5x^2+7x+1; b:=x^3+4x^2+x+1; q:=quo(a,b); r:=rem(a,b); quo(a,b,y) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">PGCD, identité de Bézout sur les polynômes
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">a:=x^4+5x^2+7x+1; b:=x^3+4x^2+x+1; gcd(a,b); u,v,d:=egcd(a,b); normal(a*u+b*v); u,v:=abcuv(a,b,x^2,x); normal(a*u+b*v) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">factorisation sur le corps des coefficients par défaut, sinon 
ajouter l’extension algébrique souhaitée (éventuellement obtenue
avec <code>solve</code>)
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">factor(x^4-2); solve(x^4-2=0); factor(x^4-2,2^(1/4)); cfactor(x^4-2,2^(1/4)); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<code>sqrfree</code> permet d’effectuer une factorisation partielle
en produit de facteurs premiers entre eux et sans racines multiples.
</li><li class="li-itemize">évaluation d’un polynôme

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">p:=x^5+4x+7; horner(p,2); p(x=2); subst(p,x=2);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">Résultant de 2 polynômes
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">p:=randpoly(7); q:=randpoly(7); resultant(p,q,x); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">m:=sylvester(p,q); det(m); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">décomposition en éléments simples
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">partfrac(1/(x^4-1)) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">polynômes à coefficients dans ℤ/<span style="font-style:italic">p</span>ℤ

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">p:=(x^5+4x+7) % 11; gcd(p,p');
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">Corps fini non premier de caractéristique <span style="font-style:italic">p</span> :<br>
<code>GF(p,n)</code> crée un corps fini <span style="font-style:italic">K</span> de cardinal <span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup>, 
et affecte une variable
pour le générateur du groupe multiplicatif <span style="font-style:italic">K</span><sup>*</sup>, par
défaut <span style="font-style:italic">g</span>. Les éléments du corps sont alors représentés
par des polynômes en le générateur

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">GF(3,5); g^10; g^(3^5);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

on peut travailler avec des polynômes ou des matrices
à coefficients dans <span style="font-style:italic">K</span>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">p:=(g+x)^7; normal(p); quo(p,x^6+g*x^3+x+g^2-2) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li></ul>
<!--TOC subsubsection id="sec8" Algèbre linéaire exacte-->
<h4 id="sec8" class="subsubsection">2.2.2  Algèbre linéaire exacte</h4><!--SEC END --><ul class="itemize"><li class="li-itemize">
Pivot de Gauss : <code>rref</code> crée des 0 de part et d’autre
de la diaginale, <code>ref</code> en-dessous de la diagonale,
<code>ker</code> renvoie une liste de vecteurs formant une 
base du noyau d’une application linéaire
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">m:=[[1,2],[3,4]]; rref(m); ref(m); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div> 
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">m:=[[1,2,3],[4,5,6],[7,8,9]]; ker(m); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">Factorisation LU
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">m:=ranm(3,3); p,l,u:=lu(m); permu2mat(p)*m-l*u;linsolve(p,l,u,[1,2,3]); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">Déterminant

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">m:=ranm(100,100):; det(m);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

On peut forcer l’utilisation d’un algorithme 
(voir l’aide détaillée de <code>det</code>).
</li><li class="li-itemize">Réduction des endomorphismes
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">m:=[[1,2],[3,4]]; p,d:=jordan(m); normal(inv(p)*m*p); pmin(m); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">Polynome d’endomorphisme
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">m:=[[1,2],[3,4]]; p:=charpoly(m); horner(p,m); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">Forme de Hermite et Smith d’une matrice à coefficients entiers
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">m:=ranm(3,3); ihermite(m); ismith(m); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li></ul>
<!--TOC subsection id="sec9" Calcul scientifique-->
<h3 id="sec9" class="subsection">2.3  Calcul scientifique</h3><!--SEC END -->
<!--TOC subsubsection id="sec10" Analyse numérique-->
<h4 id="sec10" class="subsubsection">2.3.1  Analyse numérique</h4><!--SEC END --><ul class="itemize"><li class="li-itemize">
Résolution approché déquation par méthode itérative
ou par bisection
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">fsolve(x=cos(x),x=0.3); fsolve(x=cos(x),x=-4..4) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">Approximation polynômiale : 
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">lagrange([1,2,3,4],[-3,5,2,7]) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">Intégration numérique
<br><textarea onkeypress="UI.ckenter(event,this,2)" style="width:400px;height:20px;font-size:large">int(exp(-x^2),x,0.0,1.0); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML='&nbsp;'+tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><span></span><br>
on peut forcer une méthode avec <code>gaussquad</code> ou <code>romberg</code>
ou de petit ordre avec <code>plotarea</code>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plotarea(exp(-x^2),x=0..1.0,5,trapezes)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">Équations différentielles ordinaires
<span style="font-style:italic">y</span>′=<span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>,<span style="font-style:italic">y</span>)=sin(<span style="font-style:italic">ty</span>) 
avec condition initiale (<span style="font-style:italic">t</span><sub>0</sub>,<span style="font-style:italic">y</span><sub>0</sub>)=(0,1), valeur en <span style="font-style:italic">t</span>=2

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">odesolve(sin(t*y),[t,y],[0,1],2)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

Tracé sur l’intervalle <span style="font-style:italic">t</span> ∈ [−10,10]

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">odeplot(sin(t*y),[t=-10..10,y],[0,1])
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li></ul>
<!--TOC subsubsection id="sec11" Algèbre linéaire numérique-->
<h4 id="sec11" class="subsubsection">2.3.2  Algèbre linéaire numérique</h4><!--SEC END --><ul class="itemize"><li class="li-itemize">
factorisation LU et résolution de système,
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">m:=ranm(3,3,uniform,0,1); p,l,u:=lu(m); v:=[1,2,3]; linsolve(m,v); linsolve(p,l,u,v); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">factorisation QR
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">q,r:=qr(m); q*r-m; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">factorisation de Cholesky
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">n:=trn(m)*m; cholesky(n); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">Conditionnement d’une matrice pour la norme 1, euclidienne ou infinie

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">cond(m,1); cond(m,2); cond(m,inf);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">Réduction des endomorphismes
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">p,d:=jordan(evalf(m)); eigenvalues(m); eigenvects(m); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">Valeurs singulières
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">svl(m); u,s,q:=svd(m); u*diag(s)*trn(q); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">Factorisation de Schur
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">restart;p,u:=schur(m); trn(p)*m*p-u; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li></ul>
<!--TOC section id="sec12" Calculer sur ordinateur-->
<h2 id="sec12" class="section">3  Calculer sur ordinateur</h2><!--SEC END --><p> <a id="sec:calculer"></a></p>
<!--TOC subsection id="sec13" Représentation des entiers-->
<h3 id="sec13" class="subsection">3.1  Représentation des entiers</h3><!--SEC END --><div class="theorem"><span style="font-weight:bold">Proposition 1</span>  <em>
</em><em><span style="font-weight:bold">Division euclidienne de deux entiers :</span></em><em> si </em><span style="font-style:italic">a</span><em> et </em><span style="font-style:italic">b</span><em> sont
deux entiers, </em><span style="font-style:italic">a</span> ≥ 0, <span style="font-style:italic">b</span>&gt;0<em>, il existe un unique couple </em>(<span style="font-style:italic">q</span>,<span style="font-style:italic">r</span>)<em> tel que
</em><a id="hevea_default0"></a><em>
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span> = <span style="font-style:italic">bq</span> +<span style="font-style:italic">r</span> ,    <span style="font-style:italic">r</span> ∈ [0, <span style="font-style:italic">b</span>[ </td></tr>
</table><em>
</em></div><p>
Preuve : On prend pour <span style="font-style:italic">q</span> le plus grand entier tel que <span style="font-style:italic">a</span>−<span style="font-style:italic">bq</span> ≥ 0.<br>
Exemple : 
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">iquorem(23,7)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>La division euclidienne permet d’écrire un nombre entier, en utilisant
une base <span style="font-style:italic">b</span> et des caractères pour représenter les entiers
entre 0 et <span style="font-style:italic">b</span>−1. Nous écrivons les nombres entiers en <span style="font-weight:bold">base</span> <span style="font-style:italic">b</span>=10<a id="hevea_default1"></a>
avec comme caractères les chiffres de 0 à 9.
Les ordinateurs utilisent des circuits binaires pour stocker
les informations, il est donc naturel d’y travailler en base 2 
en utilisant comme caractères 0 et 1 ou en base 16 en utilisant
comme caractères les chiffres de 0 à 9 et les lettres de A à F.
En général, pour trouver l’écriture d’un nombre en base <span style="font-style:italic">b</span> (par
exemple <span style="font-style:italic">b</span>=2), 
on effectue des divisions euclidienne successives par <span style="font-style:italic">b</span> du nombre puis
de ses quotients successifs jusqu’à ce que le quotient soit 0 et on
accolle les restes obtenus (premier reste à droite, dernier
reste à gauche).
Inversement, pour retrouver un entier <span style="font-style:italic">d</span> à partir
de son écriture <span style="font-style:italic">d</span><sub><span style="font-style:italic">n</span></sub>...<span style="font-style:italic">d</span><sub>0</sub>, on traduit les divisions euclidiennes 
successives en 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">d</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >( ... ((<span style="font-style:italic">d</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">b</span> +<span style="font-style:italic">d</span><sub><span style="font-style:italic">n</span>−1</sub>)<span style="font-style:italic">b</span> + <span style="font-style:italic">d</span><sub><span style="font-style:italic">n</span>−2</sub>)...+<span style="font-style:italic">d</span><sub>1</sub>)<span style="font-style:italic">b</span>+<span style="font-style:italic">d</span><sub>0</sub></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">d</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">b</span><sup><span style="font-style:italic">n</span></sup> + <span style="font-style:italic">d</span><sub><span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">b</span><sup><span style="font-style:italic">n</span>−1</sup> + ... + <span style="font-style:italic">d</span><sub>0</sub>
</td></tr>
</table></td></tr>
</table><p>
Par exemple, vingt-cinq s’écrit en base 16 <code>0x19</code> car 25 divisé
par 16 donne quotient 1, reste 9<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">convert(25,base,16)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
En base 2, on trouverait <code>0b11001</code> car 25=2<sup>4</sup>+2<sup>3</sup>+1.<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">convert(25,base,2)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
On peut effectuer les opérations arithmétiques de base 
(+,-,*, division) directement en base 2 (ou 16). Par exemple
la table de l’addition est 0+0=0, 0+1=1+0=1 et 1+1=0 je retiens 1,
donc :
</p><pre class="verbatim">  01001111
+ 01101011
----------
  10111010
</pre><p><span style="font-weight:bold">Exercice </span>: 
comment passe-t-on simplement de la représentation d’un nombre en
base 2 à un nombre en base 16 et réciproquement ?</p><p>Les microprocesseurs peuvent effectuer directement
les opérations arithmétiques de base sur les entiers “machine”
(déclinés en plusieurs variantes selon la taille et la
possibilité d’avoir un signe). Noter que la division de deux
entiers <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> n’a pas la même signification que la division de deux
réels, comme elle ne tomberait pas forcément juste, 
on calcule le quotient et le reste de la division euclidienne. </p><p>Ces entiers machines permettent
de représenter de manière exacte des petits entiers relatifs 
par exemple un entier machine signé sur 4 octets est
compris entre [−2<sup>31</sup>,2<sup>31</sup>−1]. </p><p>Ces entiers machines permettent de faire très rapidement
du calcul exact sur les
entiers, mais à condition qu’il n’y ait pas de dépassement
de capacité, par exemple pour des entiers 32 bits, 2<sup>30</sup>+2<sup>30</sup>+2<sup>30</sup>+2<sup>30</sup>
renverra 0. Ils sont utilisables avec tous les langages de
programmation traditionnels.</p><p>Les logiciels de calcul formel et certains logiciels
de programmation permettent de travailler avec
des entiers de taille beaucoup plus grande, ainsi qu’avec des
rationnels, permettant de faire du calcul exact, mais on paie
cette exactitude par un temps de calcul plus long, de plus
pas mal de méthodes numériques ne gagnent rien à
faire des calculs intermédiaires exacts. Néanmoins, l’utilisation
d’un logiciel de calcul formel permettra dans certains cas d’illustrer
certains phénomènes dus au calcul approché.</p>
<!--TOC subsection id="sec14" Les réels-->
<h3 id="sec14" class="subsection">3.2  Les réels</h3><!--SEC END --><p>
On se ramène d’abord au cas des réels positifs, en machine
on garde traditionnellement un bit pour stocker le signe du réel
à représenter.</p>
<!--TOC subsubsection id="sec15" Virgule fixe et flottante.-->
<h4 id="sec15" class="subsubsection">3.2.1  Virgule fixe et flottante.</h4><!--SEC END --><p>
La première idée qui vient naturellement serait d’utiliser
un entier et de déplacer la virgule
d’un nombre fixe de position, ce qui revient à mulitplier
par une puissance (négative) de la base. Par exemple en base 10 avec un
décalage de 4, <code>1234.5678</code>
serait représenté par <code>12345678</code> et <code>1.2345678</code> par
<code>12345</code> (on passe de l’entier au réel par multiplication
par 10<sup>−4</sup>. L’inconvénient d’une telle représentation est
qu’on ne peut pas représenter des réels grands ou petits,
comme par exemple le nombre d’Avogadro, la constante de Planck, etc.</p><p>D’où l’idée de ne pas fixer la position de la virgule, on parle
alors de représentation à virgule flottante ou de nombre flottant : on
représente un nombre par deux entier, l’un appelé <span style="font-weight:bold">mantisse</span><a id="hevea_default2"></a>
reprend les chiffres significatifs du réel sans virgule, l’autre
l’exposant, donne la position de la virgule. Attention, le séparateur
est un point et non une virgule dans la grande
majorité des logiciels scientifiques.
On sépare
traditionnellement la mantisse de l’exposant par la lettre <code>e</code>.
Par exemple <code>1234.5678</code> peut être représenté 
par <code>12345678e-8</code> (mantisse <code>12345678</code>, exposant -8)
mais aussi par <code>1234567800e-10</code>.</p><p>Naturellement, sur un ordinateur, il y a des limites pour les entiers 
représentant la mantisse <span style="font-style:italic">m</span> et l’exposant <span style="font-style:italic">e</span>. 
Si on écrit les nombres en base
<span style="font-style:italic">b</span>, la mantisse <span style="font-style:italic">m</span> s’écrira avec un nombre <span style="font-style:italic">n</span> fixé de chiffres (ou
de bits en base 2), donc <span style="font-style:italic">m</span> ∈ [0,<span style="font-style:italic">b</span><sup><span style="font-style:italic">n</span></sup>[. Soit un réel <span style="font-style:italic">x</span> représenté
par
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>=<span style="font-style:italic">mb</span><sup><span style="font-style:italic">e</span></sup>,    <span style="font-style:italic">m</span> ∈ [0,<span style="font-style:italic">b</span><sup><span style="font-style:italic">n</span></sup>[ </td></tr>
</table><p>
Si <span style="font-style:italic">m</span>∈ [0,<span style="font-style:italic">b</span><sup><span style="font-style:italic">n</span>−1</sup>[, alors on peut aussi écrire <span style="font-style:italic">x</span>=<span style="font-style:italic">m</span>′ <span style="font-style:italic">b</span><sup><span style="font-style:italic">e</span>−1</sup> avec
<span style="font-style:italic">m</span>′=<span style="font-style:italic">mb</span> ∈ [0,<span style="font-style:italic">b</span><sup><span style="font-style:italic">n</span></sup>[, quelle écriture faut-il choisir?
Intuitivement, on sent qu’il vaut mieux prendre <span style="font-style:italic">m</span>′ le plus grand
possible, car cela augmente le nombre de chiffres significatifs (alors
que des 0 au début de <span style="font-style:italic">m</span> ne sont pas significatifs).
Ceci est confirmé par le calcul de l’erreur d’arrondi pour
représenter un réel. En effet, si <span style="font-style:italic">x</span> est un réel non nul, il ne
s’écrit pas forcément sous la forme <span style="font-style:italic">mb</span><sup><span style="font-style:italic">e</span></sup>, on doit l’arrondir,
par exemple au plus proche réel de la forme <span style="font-style:italic">mb</span><sup><span style="font-style:italic">e</span></sup>. La distance
de <span style="font-style:italic">x</span> à ce réel est inférieure ou égale à la moitié
de la distance entre deux flottants consécutifs, 
<span style="font-style:italic">mb</span><sup><span style="font-style:italic">e</span></sup> et (<span style="font-style:italic">m</span>+1)<span style="font-style:italic">b</span><sup><span style="font-style:italic">e</span></sup>, donc l’erreur d’arrondi
est inférieure ou égale à <span style="font-style:italic">b</span><sup><span style="font-style:italic">e</span></sup>/2. Si on divise par <span style="font-style:italic">x</span> ≥ <span style="font-style:italic">mb</span><sup><span style="font-style:italic">e</span></sup>,
on obtient une erreur relative d’arrondi majorée par 1/(2<span style="font-style:italic">m</span>).
On a donc intérêt à prendre <span style="font-style:italic">m</span> le plus grand possible pour
minimiser cette erreur. Quitte à mulitplier par <span style="font-style:italic">b</span>, on peut
toujours se ramener (sauf exceptions, cf. ci-dessous), 
à <span style="font-style:italic">m</span> ∈ [<span style="font-style:italic">b</span><sup><span style="font-style:italic">n</span>−1</sup>,<span style="font-style:italic">b</span><sup><span style="font-style:italic">n</span></sup>[, on a alors
une erreur d’arrondi relative majorée par
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">b</span><sup><span style="font-style:italic">n</span>−1</sup></td></tr>
</table></td></tr>
</table><p>On appelle <span style="font-weight:bold">flottant normalisé</span><a id="hevea_default3"></a> un flottant tel que <span style="font-style:italic">m</span> ∈
[<span style="font-style:italic">b</span><sup><span style="font-style:italic">n</span>−1</sup>,<span style="font-style:italic">b</span><sup><span style="font-style:italic">n</span></sup>[. Pour écrire un réel sous forme de flottant
normalisé, on écrit le réel en base <span style="font-style:italic">b</span>, et on déplace
la virgule pour avoir exactement <span style="font-style:italic">n</span> chiffres non nuls avant la
virgule et on arrondit (par exemple au plus proche). 
L’exposant est égal au décalage effectué.
Notez qu’en base 2, un flottant normalisé commence forcément
par 1, ce qui permet d’économiser un bit dans le stockage.</p><p>Ainsi, l’erreur d’<span style="font-weight:bold">arrondi</span><a id="hevea_default4"></a> commise lorsqu’on
représente un réel (connu exactement) par un double normalisé 
est une erreur relative inférieure à
de 2<sup>−53</sup> (<span style="font-style:italic">b</span>=2 et <span style="font-style:italic">n</span>=52+1 pour les doubles).</p><p>Exemples : 
</p><ul class="itemize"><li class="li-itemize">
en base 10 avec <span style="font-style:italic">n</span>=6, pour représenter
π=3,14159265..., on doit décaler la virgule de 5 positions,
on obtient <code>314159.265...</code> on arrondit à 314159 donc
on obtient <code>314159e-5</code>.
</li><li class="li-itemize">en base 2 avec <span style="font-style:italic">n</span>=10, pour représenter trois cinquièmes (3/5
en base 10, noté 11/101 en base 2), 
on pose la division en base 2 de <code>11</code> par 
<code>101</code>, ce qui donne
<pre class="verbatim"> 11        | 101
 110       ---------
-101       | 0.1001
----       |
  010      |
   100     |
   1000    |
  - 101    |
  -----    |
    011    |
</pre>on retrouve le nombre de départ donc le développement est
périodique et vaut <code>0.1001 1001 1001 ...</code>.
On décale le point de 10 positions, on arrondit,
donc trois cinquièmes est
représenté par la mantisse <code>1001100110</code> et l’exposant
<code>-10</code>. On observe aussi sur cet exemple que 3/5 dont l’écriture
en base 10 <code>0.6</code> est exacte, n’a pas d’écriture exacte en base
2 (de même que 1/3 n’a pas d’écriture exacte en base 10).
</li></ul><p>Il existe une exception à la possibilité de normaliser les flottants,
lorsqu’on atteint la limite inférieure de l’exposant <span style="font-style:italic">e</span>. 
Soit en effet <span style="font-style:italic">e</span><sub><span style="font-style:italic">m</span></sub> le plus petit exposant des flottants normalisés
et considérons les flottants <span style="font-style:italic">x</span>=<span style="font-style:italic">b</span><sup><span style="font-style:italic">e</span><sub><span style="font-style:italic">m</span></sub></sup>(1+1/<span style="font-style:italic">b</span>) et <span style="font-style:italic">y</span>=<span style="font-style:italic">b</span><sup><span style="font-style:italic">e</span><sub><span style="font-style:italic">m</span></sub></sup>. Ces
flottants sont distincts, 
mais leur différence n’est plus représentable par un flottant normalisé.
Comme on ne souhaite pas représenter <span style="font-style:italic">x</span>−<span style="font-style:italic">y</span> par 0, 
(puisque le test <span style="font-style:italic">x</span>==<span style="font-style:italic">y</span> renvoie faux), on introduit les flottants 
<span style="font-weight:bold">dénormalisés</span> <a id="hevea_default5"></a>, il s’agit de
flottants dont l’exposant est l’exposant minimal représentable sur
machine et dont la mantisse appartient à [0,<span style="font-style:italic">b</span><sup><span style="font-style:italic">n</span>−1</sup>[. Par exemple
0 est représenté par un flottant dénormalisé de mantisse 0
(en fait 0 a deux reprśentation, une de signe positif et une de
signe négatif).</p><p>Enfin, on utilise traditionnellement une valeur de l’exposant pour
représenter les nombres plus grands que le plus grand réel
reprśentable sur machine (traditionnellement appelé plus ou
moins infini)
et les erreurs (par exemple 0./0. ou racine carrée d’un nombre
réel négatif, traditionnellement appelé NaN, Not a Number).</p><p><span style="font-weight:bold">Exercice</span> : quels sont les nombres réels représentables exactement
en base 10 mais pas en base 2 ?
Si on écrit 1/10 en base 2 avec 53 bits de précision, puis que
l’on arrondit avec 64 bits de précision, ou si on écrit 1/10 en
base 2 avec 64 bits de précision, obtient-on la même chose ?</p><p>Les ordinateurs reprśentent généralement les flottants en base 2 
(cf. la section suivante pour
plus de précisions), mais cette représentation n’est pas utilisée
habituellement par les humains, qui préfèrent compter
en base 10. Les ordinateurs effectuent donc la conversion dans
les routines d’entrée-sortie. Le format standard utilisé
pour saisir ou afficher un nombre flottant dans un logiciel
scientifique est composé d’un nombre à virgule
flottante utilisant le point comme séparateur décimal (et
non la virgule) suivi si nécessaire de la lettre <code>e</code> puis de l’exposant,
par exemple <code>1.23e-5</code> ou <code>0.0000123</code>. Dans les
logiciels de calcul formel, pour distinguer un entiers
représentés par un entier
d’un entier représenté par un flottant on écrit
l’entier suivi de <code>.0</code> par exemple <code>23.0</code>.</p><p><span style="font-weight:bold">Remarque</span> :<br>
Les microprocesseurs ayant un mode <span style="font-weight:bold">BCD</span><a id="hevea_default6"></a> peuvent avoir un format
de représentation des flottants en base 10, les nombres décimaux
comme par exemple 0.3 peuvent être représentés exactement. 
Certains logiciels, notamment maple, utilisent par défaut des
flottants logiciels en base 10 sur des microprocesseurs sans mode BCD, 
ce qui entraine une baisse de
rapidité importante pour les calculs numériques (on peut
partiellement améliorer les performances en utilisant <code>evalhf</code>
en maple).</p>
<!--TOC subsubsection id="sec16" Les flottants au format <span style="font-family:monospace">double</span>-->
<h4 id="sec16" class="subsubsection">3.2.2  Les flottants au format <span style="font-family:monospace">double</span></h4><!--SEC END --><p> 
<a id="hevea_default7"></a> <a id="hevea_default8"></a>
Cette section développe les notions de la section précédente
pour les flottants machine selon la norme IEEE-754, utilisables dans les langage de
programmation usuels, elle peut être omise en première lecture.
La représentation d’un double
en mémoire se compose de 3 parties : le bit<a id="hevea_default9"></a> 
de signe <span style="font-style:italic">s</span>=± 1 sur 1 bit, 
la mantisse<a id="hevea_default10"></a> <span style="font-style:italic">M</span> ∈ [0,2<sup>52</sup>[ sur 52 bits, 
et l’exposant<a id="hevea_default11"></a> <span style="font-style:italic">e</span> ∈ [0, 2<sup>11</sup>[ sur 11 bits. Pour les nombres
“normaux”, l’exposant est en fait compris entre 1 et 2<sup>11</sup>−2,
le nombre représenté est le rationnel
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(1+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup>52</sup></td></tr>
</table></td><td class="dcell">) 2<sup><span style="font-style:italic">e</span>+1−2<sup>10</sup></sup> </td></tr>
</table><p>
Pour écrire un nombre sous cette forme, il faut d’abord chercher par
quel multiple de 2 il faut le diviser pour obtenir un réel <span style="font-style:italic">r</span> dans
[1,2[, ce qui permet de déterminer l’exposant <span style="font-style:italic">e</span>. Ensuite on
écrit la représentation en base 2 de <span style="font-style:italic">r</span>−1 ∈ [0,1[.
Exemples :
</p><ul class="itemize"><li class="li-itemize">
-2 <br>
Signe négatif. Il faut diviser sa valeur absolue 
2 par 2<sup>1</sup> pour être entre 1 et 2 dont
<span style="font-style:italic">e</span>+1−2<sup>10</sup>=1, l’exposant est <span style="font-style:italic">e</span>=2<sup>10</sup>. On a alors <span style="font-style:italic">r</span>=1, <span style="font-style:italic">r</span>−1=0.
Représentation <br>
<code>1 10000000000 00000000...0000</code>
</li><li class="li-itemize">1.5=3/2<br>
Signe positif, compris entre 1 et 2 dont l’exposant vérifie
<span style="font-style:italic">e</span>+1−2<sup>10</sup>=0 soit
<span style="font-style:italic">e</span>=2<sup>10</sup>−1=2<sup>9</sup>+2<sup>8</sup>+2<sup>7</sup>+2<sup>6</sup>+2<sup>5</sup>+2<sup>4</sup>+2<sup>3</sup>+2<sup>2</sup>+2<sup>1</sup>+2<sup>0</sup>. 
On a <span style="font-style:italic">r</span>−1=1/2=2<sup>−1</sup>. D’où la représentation<br>
<code>0 01111111111 10000000...0000</code>
</li><li class="li-itemize">6.4=32/5<br>
Positif. Il faut le diviser par 2<sup>2</sup> pour avoir 8/5 ∈ [1,2[
donc <span style="font-style:italic">e</span>+1−2<sup>10</sup>=2 soit <span style="font-style:italic">e</span>=2<sup>10</sup>+1. Ensuite <span style="font-style:italic">r</span>=3/5 qu’il faut
écrire en base 2 (cf. section précédente),
on écrit donc les 52 premiers éléments du développement
avec une règle d’arrondi du dernier bit au nombre le plus proche. 
Ici le bit suivant le dernier <code>1001</code> est un <code>1</code>, on arrondit
donc à <code>1010</code>. D’où la représentation<br>
<code>0 1000000001 100110011001...10011010</code><br>
</li></ul><p>
On observe que la représentation en base 2 de 6.4 a du être
arrondie (car elle est infinie en base 2) bien qu’elle soit exacte
(finie) en base 10.
Seuls les entiers et les rationnels dont le dénominateur est une puissance
de 2 peuvent être représentés exactement.
Ceci entraine des résultats qui peuvent surprendre
comme par exemple le fait que
<code>0.5 - 5*0.1</code> n’est pas nul.</p><p>Des représentations spéciales (avec <span style="font-style:italic">e</span>=0 ou <span style="font-style:italic">e</span>=2<sup>11</sup>−1) 
ont été introduites
pour représenter ± ∞ (pour les flottants plus grands
en valeur absolue que le plus grand flottant représentable), et pour
représenter les
nombres non nuls plus petits que le plus petit flottant représentable
de la manière exposée ci-dessus (on parle de flottants dénormalisés),
ainsi que le nombre NaN (Not a Number) lorsqu’une opération a un résultat
indéfini (par exemple 0/0).</p><p>Remarque : Sur les processeurs compatibles avec les i386, 
le coprocesseur arithmétique i387 gère en interne des flottants
avec 80 bits dont 64 bits de mantisse. Sur les architectures 64 bits
(x86 ou AMD), le jeu d’instruction SSE permet de travailler avec
des flottants de 128 bits. Le compilateur gcc permet d’utiliser
ces flottants longs avec le type <code>long double</code> ou
les types <code>__float80</code> et <code>__float128</code> en utilisant
un drapeau de compilation du type <code>-msse</code></p>
<!--TOC subsubsection id="sec17" Opérations sur les flottants-->
<h4 id="sec17" class="subsubsection">3.2.3  Opérations sur les flottants</h4><!--SEC END --><p>
Les opérations arithmétiques de base sur les flottants
se font de la manière suivante :
</p><ul class="itemize"><li class="li-itemize">
addition et soustraction : on détecte s’il faut additionner
ou soustraire en valeur absolue en analysant les signes,
on détermine l’exposant le plus grand et on décale la partie mantisse 
du flottant dont l’exposant est le plus petit pour se ramener à additionner
deux entiers (partie mantisses correspondant au même exposant), 
on décale à nouveau la partie mantisse en modifiant l’exposant 
après l’opération pour normaliser le flottant
</li><li class="li-itemize">multiplication : on additionne les exposants et on multiplie
les parties mantisses (vus comme des entiers), on arrondit et
on ajuste l’exposant si nécessaire
</li><li class="li-itemize">division : on soustrait les exposants et on divise les parties
mantisses (division “à virgule”), on tronque et on
ajuste l’exposant si nécessaire
</li></ul>
<!--TOC subsubsection id="sec18" Erreurs-->
<h4 id="sec18" class="subsubsection">3.2.4  Erreurs</h4><!--SEC END --><p> <a id="hevea_default12"></a>
La représentation des nombres réels par des doubles présente
des avantages, les opérations arithmétiques
sont faites au plus vite par le microprocesseur.
Les coprocesseurs arithmétiques (intégrés sur les microprocesseurs
de PC) proposent même
le calcul des fonctions usuelles (trigonométriques, racine carrée, log et exp)
sur le type double et utilisent des formats de représentation interne
ayant plus de 64 bits pour les doubles, ce qui permet de limiter
les erreurs d’arrondi. 
Par contre, des erreurs vont être introduites,
on parle de calcul approché par opposition au calcul exact sur les
rationnels. En effet, la représentation doit d’abord arrondir 
tout réel qui n’est pas un rationnel dont le dénominateur
est une puissance de 2. Ensuite chaque opération va entrainer
une propagation de ces erreurs et va y ajouter une erreur d’arrondi 
sur le résultat.
Enfin, l’utilisation du type double peut provoquer un dépassement
de capacité (par exemple <code>100!*100!</code>).</p><p>Pour diminuer ces erreurs et les risques de dépassement de
capacité, il existe des types flottants multiple précision,
qui permettent de travailler avec un nombre fixé à l’avance
de décimales et une plage d’exposants plus grande. Les calculs sont plus longs mais les erreurs
plus faibles. Attention, il s’agit toujours de calcul approché!
De plus, pour des quantités dont la valeur est déterminée
de manière expérimentale, la source principale de propagation
d’erreurs est la précision des quantités initiales, il ne sert
souvent à rien d’utiliser des types flottants multiprécision car les
erreurs dus à la représentation (double) sont négligeables devant
les erreurs de mesure. Dans ce cas, il est pertinent lorsqu’on
évalue <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) avec <span style="font-style:italic">x</span> mal connu de calculer aussi <span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span>), en effet :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>(1+<span style="font-style:italic">h</span>))= <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)+<span style="font-style:italic">xh</span> <span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span>) + <span style="font-style:italic">O</span>(<span style="font-style:italic">h</span><sup>2</sup>)</td></tr>
</table><p>
l’erreur relative sur <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) est donc au premier ordre multipliée par
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">xf</span>′(<span style="font-style:italic">x</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)</td></tr>
</table></td><td class="dcell">|</td></tr>
</table><p>
Par exemple, l’erreur relative sur <span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup> est au premier ordre l’erreur relative sur <span style="font-style:italic">x</span>
multipliée par |<span style="font-style:italic">x</span>|.
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">a:=convert(100,interval); (right(a)-left(a))/evalf(a,12) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">b:=exp(a); (right(b)-left(b))/evalf(b,12) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p>
<!--TOC subsubsection id="sec19" Erreur absolue, relative, arrondi propagation des erreurs.-->
<h4 id="sec19" class="subsubsection">3.2.5  Erreur absolue, relative, arrondi propagation des erreurs.</h4><!--SEC END --><p>
On a vu précédemment que pour représenter un réel, on devait
l’arrondir, ce qui introduit une erreur même si le réel est
connu exactement (par exemple 1/10).
Voyons comment se propagent les <span style="font-weight:bold">erreurs</span><a id="hevea_default13"></a> 
dans les opérations arithmétiques
de base : on distingue l’addition, la multiplication
et l’inversion. La soustraction se ramène à l’addition car
le calcul de l’opposé n’introduit aucune erreur nouvelle.
Pour l’addition, si |<span style="font-style:italic">x</span> −<span style="font-style:italic">x</span><sub>0</sub>| ≤ ε<sub>0</sub> et si |<span style="font-style:italic">y</span>−<span style="font-style:italic">y</span><sub>0</sub>| ≤ ε<sub>1</sub>
alors par l’inégalité triangulaire (|<span style="font-style:italic">a</span>+<span style="font-style:italic">b</span>|≤ |<span style="font-style:italic">a</span>|+|<span style="font-style:italic">b</span>|), on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|(<span style="font-style:italic">x</span>+<span style="font-style:italic">y</span>)−(<span style="font-style:italic">x</span><sub>0</sub>+<span style="font-style:italic">y</span><sub>0</sub>)| ≤ |<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>| + | <span style="font-style:italic">y</span>−<span style="font-style:italic">y</span><sub>0</sub> | ≤ 
ε<sub>0</sub> + ε<sub>1</sub> </td></tr>
</table><p>
on dit que les erreurs <em>absolues</em> s’additionnent. 
</p><div class="theorem"><span style="font-weight:bold">Définition 2</span>  <em>
L’</em><em><span style="font-weight:bold">erreur absolue</span></em><a id="hevea_default14"></a><em>
est définie comme un majorant de la valeur absolue
de la différence entre le nombre réel et
son représentant double :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>| ≤ ε </td></tr>
</table><em>
</em></div><p>
Mais comme il faut représenter <span style="font-style:italic">x</span><sub>0</sub>+<span style="font-style:italic">y</span><sub>0</sub>
en machine, on doit ajouter une erreur d’arrondi, qui est
proportionnelle à la valeur absolue de <span style="font-style:italic">x</span><sub>0</sub>+<span style="font-style:italic">y</span><sub>0</sub> d’où la notion
d’erreur <em>relative</em> :
</p><div class="theorem"><span style="font-weight:bold">Définition 3</span>  <em>
L’</em><em><span style="font-weight:bold">erreur relative</span></em><a id="hevea_default15"></a><em> 
est égale à l’erreur absolue divisée par
la valeur absolue du nombre
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>| ≤ ε |<span style="font-style:italic">x</span><sub>0</sub>| </td></tr>
</table><em>
</em></div><p>
Remarquons au passage que les erreurs de mesure expérimentales sont 
pratiquement toujours des erreurs relatives.</p><p>Donc lorsqu’on effectue une addition (ou une soustraction) de deux réels
sur machine, on doit additionner les deux erreurs absolues sur les opérandes
et ajouter une erreur d’arrondi (relative de 2<sup>−53</sup>, à titre
d’exercice, on pourra vérifier que cette erreur
d’arrondi est majorée par l’erreur absolue de la somme 
<span style="font-style:italic">x</span>+<span style="font-style:italic">y</span> dès l’instant où
<span style="font-style:italic">x</span> et <span style="font-style:italic">y</span> ont eux-même une erreur d’arrondi).</p><p>Lorsqu’on effectue une multiplication de deux nombres <span style="font-style:italic">x</span>,<span style="font-style:italic">y</span> dont les
représentants <span style="font-style:italic">x</span><sub>0</sub>,<span style="font-style:italic">y</span><sub>0</sub> sont non nuls, on a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">xy</span>−<span style="font-style:italic">x</span><sub>0</sub> <span style="font-style:italic">y</span><sub>0</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub>0</sub> <span style="font-style:italic">y</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪</td><td class="dcell">= 
</td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> −1 </td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪</td><td class="dcell">
= </td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪</td><td class="dcell">
(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub>0</sub></td></tr>
</table></td><td class="dcell">−1)(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> −1)+(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub>0</sub></td></tr>
</table></td><td class="dcell">−1)+(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> −1) 
</td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪</td></tr>
</table><p>
l’erreur relative est donc la somme des erreurs relatives et du produit
des erreurs relatives (on peut souvent négliger le produit devant la somme). Il
faut aussi y ajouter une erreur relative d’arrondi de 2<sup>−53</sup> sur <span style="font-style:italic">x</span><sub>0</sub> <span style="font-style:italic">y</span><sub>0</sub>.</p><p>On observe que la multiplication est une opération posant moins
de problèmes que l’addition, car on manipule toujours des erreurs
relatives, par exemple si l’erreur relative sur deux doubles
<span style="font-style:italic">x</span> et <span style="font-style:italic">y</span> non nuls
est de 2<sup>−53</sup>, alors l’erreur relative sur <span style="font-style:italic">xy</span> sera de 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">2<sup>−53</sup> + 2<sup>−53</sup> + 2<sup>−106</sup> + 2<sup>−53</sup> ≈ 3 × 2<sup>−53</sup> </td></tr>
</table><p>
Lorsque l’erreur relative sur les données est grande devant 2<sup>−53</sup>,
l’erreur relative d’arrondi final est négligeable, on peut alors dire que
les erreurs relatives s’additionnent pour un produit (c’est aussi vrai
pour un quotient: exercice!).
Par contre, si on additionne deux nombres dont le représentant de
la somme est proche de 0, la somme des erreurs absolues peut
devenir non négligeable par rapport à la somme des représentants, entrainant
une erreur relative très grande. Par exemple si <span style="font-style:italic">x</span> est représenté
par <span style="font-style:italic">x</span><sub>0</sub>=1+2<sup>−52</sup> avec
une erreur d’arrondi de 2<sup>−53</sup> et
<span style="font-style:italic">y</span> par <span style="font-style:italic">y</span><sub>0</sub>=−1 avec la même erreur d’arrondi, 
l’addition de <span style="font-style:italic">x</span> et <span style="font-style:italic">y</span> renvoie 2<sup>−52</sup> avec une erreur
absolue de 2 * 2<sup>−53</sup> (ici il n’y a pas d’arrondi lorsqu’on fait la somme).
C’est une erreur relative de 1 (qui domine largement
l’erreur d’arrondi) ce qui signifie que dans la mantisse, seul le
premier bit sur les 52 a un sens, la perte de précision est très grande.</p><p>Une autre conséquence importante est que l’addition de réels sur machine
n’est pas une opération associative,
par exemple
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(2.0<sup>−53</sup>+2.0<sup>−53</sup>)+1.0 → 1+2<sup>−52</sup> </td></tr>
</table><p>
alors que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">2.0<sup>−53</sup>+(2.0<sup>−53</sup>+1.0) → 1 </td></tr>
</table><p>
Dans Xcas, il n’y a que 48 bits de mantisse :
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">(2.^(-48)+(2.^(-48)+1.))-1.; ((2.^(-48)+2.^(-48))+1.)-1. 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
Si on a plusieurs termes
à additionner, il faut commencer par additionner entre eux
les termes les plus petits, pour que les petits termes ne soient
pas absorbés un à un dans les erreurs d’arrondi (les petits ruisseaux
font les grands fleuves).</p><p>Exercice : pour calculer la valeur
numérique d’une dérivée de fonction, il vaut mieux
calculer (<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">h</span>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>−<span style="font-style:italic">h</span>))/(2<span style="font-style:italic">h</span>) que (<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">h</span>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>))/<span style="font-style:italic">h</span> car le terme
d’erreur est en <span style="font-style:italic">O</span>(<span style="font-style:italic">h</span><sup>2</sup>) et non en <span style="font-style:italic">O</span>(<span style="font-style:italic">h</span>). Attention
toutefois à ne pas prendre <span style="font-style:italic">h</span> trop petit, sinon <span style="font-style:italic">x</span>+<span style="font-style:italic">h</span>=<span style="font-style:italic">x</span>
en flottants et même si <span style="font-style:italic">x</span>+<span style="font-style:italic">h</span> ≠ <span style="font-style:italic">x</span>, l’erreur absolue sur
<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">h</span>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>−<span style="font-style:italic">h</span>) est (au moins) d’ordre ε |<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)|, donc l’erreur
relative est d’ordre ε/<span style="font-style:italic">h</span> |<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)|. 
Par exemple pour <span style="font-family:monospace">h=1e-8</span> le reste est en <span style="font-style:italic">O</span>(<span style="font-style:italic">h</span><sup>2</sup>) donc
de l’ordre des erreurs d’arrondi mais l’erreur relative sur
<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">h</span>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>−<span style="font-style:italic">h</span>) est d’ordre є/<span style="font-style:italic">h</span> largement supérieure
(en flottants double-précision). On choisira plutôt <span style="font-style:italic">h</span> tel que
є/<span style="font-style:italic">h</span> soit proche de <span style="font-style:italic">h</span><sup>2</sup>, donc de l’ordre de <span style="font-family:monospace">1e-5</span>, qui
fournira une valeur approchée avec une erreur relative de l’ordre
de <span style="font-family:monospace">1e-10</span>.
Exemple : calcul de la dérivée numérique de exp(sin(<span style="font-style:italic">x</span>)) en <span style="font-style:italic">x</span>=1
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:40px;font-style:large">f(x):=exp(sin(x)); seq(taux_accroissement(f(x),1.0-10^(-k),1.0+10^(-k))-f'(1.0),k,1,11) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p><p>Remarquons néanmoins que les erreurs calculées ici sont des majorations
des erreurs réelles (ou si on préfère l’erreur obtenue dans le pire
des cas), statistiquement les erreurs sur les résultats sont moindres,
par exemple si on effectue <span style="font-style:italic">n</span> calculs susceptibles de provoquer
des erreurs indépendantes suivant une même loi d’espérance nulle, la moyenne des
erreurs divisée par l’écart-type de la loi
tend vers une loi normale centrée réduite. De manière plus
déterministe, on a l’inégalité de Bienaymé-Tchebyshev
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(|<span style="font-style:italic">X</span>|&gt;α) ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>σ<sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">α<sup>2</sup></td></tr>
</table></td></tr>
</table><p>
où <span style="font-style:italic">X</span> est la variable aléatoire somme des <span style="font-style:italic">n</span> erreurs, α
l’erreur et <span style="font-style:italic">n</span>σ<sup>2</sup> la variance de la somme <span style="font-style:italic">n</span> erreurs
supposées indépendantes, cette probabilité tend vers 0 pour <span style="font-style:italic">n</span>
grand si α est d’ordre <span style="font-style:italic">n</span>, et ne tend
pas vers 0 si α est de l’ordre de √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>.
Exemple : somme de <span style="font-style:italic">n</span>=400 nombres répartis sur [−1,1] selon la loi
uniforme (représentant des erreurs), on divise par √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>=20, 
on effectue plusieurs tirages (par exemple 500) on trace l’histogramme et 
on compare avec la loi normale de moyenne
nulle (l’espérance de la somme) et d’écart-type celui de la loi
uniforme.

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:40px;font-style:large">m:=ranm(400,500,-1..1):;gl_x=-2..2;histogram(sum(m)/20,-1,0.1); plot(normald(0,0.57),-2..2)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>Il est d’ailleurs souvent trop difficile de calculer une majoration
rigoureuse de l’erreur pour des calculs sauf les plus simples.
Lorsqu’on doute de la précision d’un calcul, un test peu couteux consiste
à refaire ce calcul en utilisant des flottants en précision plus
grande et tester si le résultat varie en fonction du nombre de chiffres
significatifs utilisés, ou faire varier légèrement
les données et observer la sensibilité du résultat.
Si on veut travailler en toute rigueur sans
pour autant calculer les erreurs à priori, il faut utiliser un logiciel
utilisant des intervalles pour représenter les réels (section suivante)</p>
<!--TOC subsection id="sec20" L’arithmétique d’intervalle.-->
<h3 id="sec20" class="subsection">3.3  L’arithmétique d’intervalle.</h3><!--SEC END --><p><a id="hevea_default16"></a>
Certains systèmes de calcul formel peuvent manipuler directement
des intervalles réels, par exemple par l’intermédiaire de la
bibliothèque C MPFI. Les opérations arithmétiques sur des
intervalles renvoient alors le meilleur intervalle possible contenant
toutes les valeurs possibles lorsque les opérandes parcourent
leurs intervalles respectifs.
Exemple en Xcas (version 1.1.1 et ultérieures) :
<code>[-1..2]*[-1..2]</code> renvoie <code>[-2..4]</code>.
Attention ici on parcourt toutes les valeurs possibles de 
<span style="font-style:italic">xy</span>,  <span style="font-style:italic">x</span> ∈ [−1,2], <span style="font-style:italic">y</span> ∈ [−1,2]. Ce qui est différent du carré
d’un intervalle ou plus généralement de l’évaluation
d’un polynôme en un intervalle, <code>horner(x^2,[-1..2])</code>
renvoie ainsi <code>[0..4]</code>.</p><p>Les fonctions disponibles sont souvent moins riches qu’en
arithmétique flottante, le calcul d’une fonction non monotone
sur un intervalle peut s’avérer délicat, alors que si la fonction
est monotone, il suffit de calculer l’image des deux bornes
de l’intervalle. Pour les polynômes, Xcas décompose
les coefficients en deux parties <span style="font-style:italic">P</span>=<span style="font-style:italic">P</span><sub>+</sub>−<span style="font-style:italic">P</span><sub>−</sub> en fonction
du signe, puis utilise la monotonie de <span style="font-style:italic">P</span><sub>+</sub> et <span style="font-style:italic">P</span><sub>−</sub> sur
ℝ<sup>+</sup> et ℝ<sup>−</sup> respectivement.</p><p>L’arithmétique d’intervalle dans ℂ est beaucoup plus difficile
à mettre en oeuvre puisqu’il n’y a plus d’ordre ni de monotonie,
on doit alors s’en remettre à des estimations sur les parties
réelles et imaginaires qui ne tiendront pas compte du phénomène
ci-dessus sur la différence entre <span style="font-style:italic">xy</span>,  <span style="font-style:italic">x</span> ∈ [−1,2], <span style="font-style:italic">y</span> ∈ [−1,2]
et <span style="font-style:italic">x</span><sup>2</sup>,  <span style="font-style:italic">x</span> ∈ [−1,2].</p>
<!--TOC subsection id="sec21" Calcul exact et approché, types, évaluation.-->
<h3 id="sec21" class="subsection">3.4  Calcul exact et approché, types, évaluation.</h3><!--SEC END --><p><a id="hevea_default17"></a>
Dans les langages de programmation traditionnel (C, Pascal,...), il existe 
déjà des types permettant une représentation 
exacte des données (type entier) ou une représentation approchée 
(type flottant). Mais ces types de donnée de base 
occupent une taille fixe en mémoire, le type entier est donc
limité à un intervalle d’entiers (par exemple [0,2<sup>32</sup>−1] pour un entier
non signé sur une machine utilisant un processeur 32 bits) alors que le 
type flottant peut représenter des nombres réels, mais est 
limité à une précision en nombre de digits de la mantisse et de l’exposant 
(par exemple 12 chiffres significatifs et un 
exposant compris entre -499 et 499). </p><p>En calcul formel, on souhaite pouvoir calculer rigoureusement d’une part, 
et avec des paramètres dont la valeur n’est 
pas connue d’autre part ; il faut donc s’affranchir de ces limites : 
</p><ul class="itemize"><li class="li-itemize">
pour les entiers relatifs, on utilise des entiers de 
<em>précision arbitraire</em>
dont la taille en mémoire est dynamique (déterminée pendant l’exécution et non
à la compilation),
</li><li class="li-itemize">pour les nombres complexes, on utilise un couple de nombres réels,
</li><li class="li-itemize">pour les rationnels, on utilise un couple d’entiers relatifs,
</li><li class="li-itemize">pour les irrationnels algébriques (par exemple √<span style="text-decoration:overline">2</span>), 
on utilise un polynôme irréductible dont ils sont racines,
</li><li class="li-itemize">pour les paramètres (<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>,<span style="font-style:italic">z</span>,<span style="font-style:italic">t</span>...), on utilise un type 
structuré contenant un champ de type chaine de caractères pour 
représenter le nom du paramètre et
un champ pour attribuer une valeur à (ou une hypothèse sur) ce paramètre,
</li><li class="li-itemize">pour les nombres transcendants (par exemple π), on est obligé
d’introduire un paramètre auquel on attribue une valeur numérique, 
qui ne sera utilisée qu’au moment où on veut une 
approximation numérique d’une expression contenant ce nombre transcendant,
on parle de constante,
</li><li class="li-itemize">lorsqu’on a besoin d’une approximation numérique d’un nombre,
on peut utiliser des conversions de ces types en un type flottant. On peut 
aussi pour lutter contre les erreurs 
d’arrondi utiliser des nombres flottants étendus dont la précision est 
dynamique ou même des intervalles de flottants étendus,
</li><li class="li-itemize">il faut aussi
un nouveau type, appelé expression ou symbolique, permettant d’appliquer
une fonction qu’on ne peut évaluer directement sur les objets précédents,
par exemple sin(<span style="font-style:italic">x</span>). Il
doit s’agir d’une opération de clôture, au sens où appliquer une fonction à
un objet symbolique ne nécessite pas la création d’un nouveau type
(en général on renvoie un objet symbolique).
</li></ul><p>Enfin, il faut pouvoir évaluer un objet (en particulier symbolique) :
par exemple évaluer sin(<span style="font-style:italic">x</span>) lorsqu’on assigne une valeur à <span style="font-style:italic">x</span>. 
Dans cet exemple, on voit qu’il faut d’abord remplacer <span style="font-style:italic">x</span> par
sa valeur avant de lui appliquer la fonction sinus. C’est le mécanisme
général de l’évaluation, mais il y a quelques exceptions où
on souhaite empêcher l’évaluation d’un ou plusieurs arguments
d’une fonction avant l’évaluation de la fonction. Par exemple si on 
veut calculer la valeur numérique d’une intégrale par des méthodes
de quadrature, on ne souhaitera pas rechercher une primitive de la 
fonction à intégrer. Dans le jargon, on parle alors de “quoter” un argument 
(l’origine du terme vient probablement de la notation <code>'</code> du langage 
Lisp). Certaines fonctions doivent toujours quoter leurs arguments
(par exemple la fonction qui permet de purger le contenu d’un paramètre),
on parle parfois d’autoquotation.</p>
<!--TOC subsection id="sec22" Forme normale et reconnaissance du 0.-->
<h3 id="sec22" class="subsection">3.5  Forme normale et reconnaissance du 0.</h3><!--SEC END --><p>
Une fois défini ces types de base représentant les nombres d’un système de 
calcul formel, il faut pouvoir comparer ces 
nombres, en particulier décider si deux représentations distinctes 
correspondent au même nombre ou, ce qui revient au 
même, par soustraction décider quand un nombre est nul. 
Par exemple 4/2 et 2 représentent le même nombre. 
Lorsqu’on dispose d’un algorithme permettant de représenter un nombre 
d’une manière unique, on parle de forme normale. 
C’est par exemple le cas pour les nombres rationnels, la forme normale 
usuelle est la fraction irréductible de 
dénominateur positif. C’est aussi le cas pour les fractions rationnelles 
de polynômes à coefficients entiers représentées par une fraction 
irréductible, avec au dénominateur un coefficient de plus haut degré
positif.
Malheureusement, il n’est pas toujours possible de trouver une forme normale
pour diverses raisons théoriques ou pratiques : 
</p><ul class="itemize"><li class="li-itemize">
on ne connaît pas toujours le statut de certaines constantes
(par exemple la constante d’Euler),
</li><li class="li-itemize">il n’existe pas d’algorithmes permettant de déterminer
s’il existe des relations algébriques entre constantes,
</li><li class="li-itemize">il n’existe pas forcément une seule forme plus simple, par exemple :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell">+1)<span style="font-style:italic">x</span>+1</td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell">+1</td></tr>
</table></td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell">−1</td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell">−1)<span style="font-style:italic">x</span>+1</td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table>
Ce cas se présente fréquemment avec les extensions algébriques.
</li><li class="li-itemize">en pratique il peut être trop coûteux d’utiliser une forme
normale, par exemple le polynôme (<span style="font-style:italic">x</span><sup>1000</sup>−1)/(<span style="font-style:italic">x</span>−1) possède 1000 monômes
</li></ul><p>
En résumé, au mieux on a une forme normale, au pire on risque de ne pas 
reconnaître un zéro, entre les deux on peut ne
pas avoir de forme normale mais être capable de reconnaître à coup sûr 
une expression nulle (par contre, si le système 
de calcul formel détermine qu’une expression est nulle, alors elle l’est).</p><p>Il n’existe pas d’algorithme solution
pour le problème de la reconnaissance du zéro pour une classe 
d’expressions "assez générale". Heureusement, 
dans la plupart des cas pratiques on sait résoudre ce problème, en
se ramenant le plus souvent au cas des polynômes et fractions rationnelles.
Par exemple, pour simplifier une expression trigonométrique,
on remplace les fonctions trigonométriques sin(<span style="font-style:italic">x</span>), cos(<span style="font-style:italic">x</span>), tan(<span style="font-style:italic">x</span>)
par leur expression en fonction de <span style="font-style:italic">t</span>=tan(<span style="font-style:italic">x</span>/2), on est ainsi ramené
à une fraction rationnelle en <span style="font-style:italic">t</span> que l’on écrit sous forme normale.</p><p>Les polynômes ont un rôle central dans tout système de calcul formel
puisque sauf dans les cas les plus simples (fractions d’entiers par exemple), 
la simplification d’expressions
fait appel à un moment ou à un autre à des calculs
de PGCD de polynômes. Le PGCD de polynômes est un algorithme 
très sollicité auquel nous consacrerons une section. En effet,
l’application brutale de l’algorithme d’Euclide pose des problèmes
d’efficacité ce qui a obligé à inventer des méthodes plus efficaces.
Anticipons rapidement sur un exemple qui montre l’un des problèmes
majeurs des algorithmes de calcul formel, l’explosion en taille
(ici des coefficients des restes successifs).
Voici donc les restes successifs lorsqu’on applique l’algorithme
d’Euclide pour calculer le PGCD de <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)=(<span style="font-style:italic">x</span>+1)<sup>7</sup>−(<span style="font-style:italic">x</span>−1)<sup>6</sup> avec
sa dérivée (les deux polynômes sont premiers entre eux) :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >7 (<span style="font-style:italic">x</span>+1)<sup>6</sup>−6 (<span style="font-style:italic">x</span>−1)<sup>5</sup></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">162</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">49</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span><sup>5</sup>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−390</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">49</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span><sup>4</sup>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1060</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">49</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span><sup>3</sup>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−780</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">49</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span><sup>2</sup>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">474</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">49</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−78</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">49</td></tr>
</table></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">157780</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">729</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span><sup>4</sup>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−507640</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2187</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span><sup>3</sup>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">290864</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">729</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span><sup>2</sup>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−101528</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">729</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">28028</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">729</td></tr>
</table></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">49</td></tr>
</table></td><td class="dcell">  (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1400328</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2645</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span><sup>3</sup>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−732888</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2645</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span><sup>2</sup>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1133352</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3703</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−732888</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">18515</td></tr>
</table></td><td class="dcell">)</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2187</td></tr>
</table></td><td class="dcell">  (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2161816376832</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4669921</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span><sup>2</sup>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−555436846944</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4669921</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">301917024864</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4669921</td></tr>
</table></td><td class="dcell">)</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">907235</td></tr>
</table></td><td class="dcell">  (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">469345063045455</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">129411872</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−47641670106615</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">129411872</td></tr>
</table></td><td class="dcell">)</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">5497465490623352995840</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">209648836272383412129</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Le lecteur voulant tester d’autres exemples pourra utiliser le programme 
<code>Xcas</code> suivant :

</p><pre class="verbatim">pgcdderiv(a):={
  local b,r,res;
  b:=diff(a,x);
  res:=NULL;
  for (;b!=0;){
    res:=res,b;
    r:=rem(a,b);
    a:=b;
    b:=r;
  }
  return(res);
}
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;t.value=tmp;tmp=UI.caseval(tmp);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML);field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>


<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">P:=(x+1)^7-(x-1)^6;pgcdderiv(P)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p>
<!--TOC subsection id="sec23" Valeur générique des variables et
hypothèses-->
<h3 id="sec23" class="subsection">3.6  Valeur générique des variables et
hypothèses</h3><!--SEC END --><p><a id="hevea_default18"></a> <a id="hevea_default19"></a>
Lorsqu’on utilise un symbole sans lui affecter de valeurs en mathématiques 
on s’attend à une discussion en fonction du 
paramètre représenté par ce symbole. Ce qui nécessiterait de créer un 
arborescence de calculs (on retrouve ici les problèmes 
d’explosion évoqués dans la section précédente). 
La plupart des systèmes de calcul formel contournent la difficulté en 
supposant que le paramètre possède une valeur 
générique (par exemple la solution de (<span style="font-style:italic">t</span><sup>2</sup>−1)<span style="font-style:italic">x</span>=<span style="font-style:italic">t</span>−1 sera <span style="font-style:italic">x</span>=1/(<span style="font-style:italic">t</span>+1)) ou 
choisissent une branche pour les fonctions 
possédant un point de branchement (par exemple pour résoudre <span style="font-style:italic">x</span><sup>2</sup>=<span style="font-style:italic">t</span> 
en fonction de <span style="font-style:italic">t</span>). Certains systèmes demandent de 
manière interactive à l’utilisateur si la variable est par exemple positive 
ou différente de 1 mais cela s’oppose à un 
traitement automatique. 
On peut aussi anticiper ce type de décision en faisant des hypothèses
sur une paramètre, la plupart des systèmes de calcul formel actuel
proposent cette possibilité.</p>
<!--TOC subsection id="sec24" Structures de données-->
<h3 id="sec24" class="subsection">3.7  Structures de données</h3><!--SEC END --><p>
On a vu plus haut qu’on souhaitait manipuler des entiers de taille non 
fixe, des réels de précision fixe ou non, des
fractions, des nombres complexes, des extensions algébriques, des 
paramètres, des expressions symboliques. La plupart des systèmes
proposent un type générique qui recouvre ces divers types de scalaire.
On peut par exemple utiliser un type structuré comportant un champ
type et la donnée ou un pointeur sur la donnée (avec dans ce cas un 
pointeur sur un compteur de références de la donnée
pour pouvoir la détruire dès qu’elle n’est plus référencée<sup><a id="text1" href="#note1">1</a></sup>). 
En programmation orientée objet, on utiliserait plutôt un
type abstrait dont dérivent ces différents scalaires et le polymorphisme.</p><p>Il faut aussi un type pour les vecteurs, les matrices et les
listes. Il faut prendre garde à la méthode utilisée
par le système lorsqu’on modifie un élément
d’un vecteur, matrice ou liste : soit on effectue une copie de tout
l’objet en modifiant l’élément, soit on modifie l’élément
de l’objet original. La première méthode (par valeur) est
plus aisée à comprendre pour un débutant mais
la seconde méthode (par référence) est bien plus efficace.</p><p>On peut se poser la question de savoir s’il faut inclure 
ces types dans le type générique ; en général la 
réponse est affirmative, une des raisons étant que les 
interpréteurs qui permettront de lire des données dans un 
fichier texte sont en général basé sur le couple de logiciels
<code>lex(flex)/yacc(bison)</code> qui ne peut compiler qu’à destination d’un 
seul type. Ceci permet également d’unifier en un seul type symbolique 
les fonctions ayant un ou plusieurs arguments en 
voyant plusieurs arguments comme un vecteur d’arguments. 
Les fonctions sont le plus souvent elle-même incluses dans le 
type générique permettant ainsi à l’utilisateur de saisir des 
commandes ou programmes fonctionnels (on peut
utiliser une fonction comme argument d’une commande).</p><p>Pour des raisons d’efficacité, les systèmes de calcul formel
utilisent souvent des représentations particulières pour les polynômes
dont on a dit qu’ils jouaient un rôle central.
Pour les polynômes à une variable,
on peut utiliser la liste des coefficients du polynôme, on parle
alors de représentation dense. On peut aussi décider de ne stocker
que les coefficients non nuls, on parle alors de représentation creuse
(on stocke alors un couple formé par le coefficient et le degré
du monôme correspondant). Pour les polynômes à plusieurs variables,
on peut les considérer comme des polynômes à une variable à
coefficients polynomiaux, on parle alors de représentation récursive.
On peut aussi décider de ne pas briser la symétrie entre les
variables (pas de variable principale), on parle alors de représentation
distribuée, le plus souvent les représentation distribuées
sont creuses car les représentations
denses nécessitent très vite beaucoup de coefficients. Les méthodes
de représentation creuses sont parfois aussi utilisées pour les
matrices ayant beaucoup de coefficients nuls.</p><p>Voyons maintenant plus précisément sur quelques exemples de logiciels
de calcul formel répandus quelles structures de données sont
utilisées. Plusieurs éléments entrent en compte dans les choix faits :
</p><ul class="itemize"><li class="li-itemize">
le(s) profil(s) d’utilisation (enseignement, ingéniérie,
calcul intensif, recherche)
</li><li class="li-itemize">les ressources disponibles (mémoire, puissance du processeur...)
</li><li class="li-itemize">la facilité d’implémentation (choix du langage, outils
disponibles en particulier débuggueurs, ...)
</li><li class="li-itemize">l’histoire du système (un système conçu avec les outils
disponibles aujourd’hui est forcément différent d’un système 
conçu il y a 20 ans)
</li></ul><p>
Voyons quelques exemples, d’abord Giac, puis des systèmes 
pour ordinateur où les ressources
(par exemple mémoire) sont moins limitées ce qui permet 
d’utiliser des langages de programmation de plus haut niveau.
On termine par les calculatrices formelles
HP et TI des années 2000<sup><a id="text2" href="#note2">2</a></sup>.
Ce sont des systèmes plutôt destinés à l’enseignement, soumis 
à de fortes contraintes en termes de taille mémoire, et destinés
à traiter des petits problèmes.</p>
<!--TOC subsubsection id="sec25" Maple, Mathematica, ...-->
<h4 id="sec25" class="subsubsection">3.7.1  Maple, Mathematica, ...</h4><!--SEC END --><p>
Ces systèmes ont un noyau fermé, au sens où l’utilisateur n’a pas
accès du tout, ou en tout cas pas facilement, aux structures de données
de base. Je ne dispose donc pas d’information sur les structures de données
utilisées par le noyau.</p><p>L’interaction système-utilisateur se fait quasiment toujours en utilisant le
langage de programmation propre au système, langage interprété
par le noyau du système (ce qui ralentit l’exécution). Ces langages 
utilisateurs sont essentiellement
non typés : on travaille avec des variables du type générique sans pouvoir
accéder aux types sous-jacents. On ne bénéficie en général pas des
vérifications faites lors de la compilation avec un langage typé,
de plus ces systèmes ne sont pas toujours fourni avec de bon outils de 
mise au point. Enfin ces langages ne sont pas standardisés d’un
système à l’autre et il est en général impossible
d’utiliser ces systèmes comme des librairies depuis un langage
de programmation traditionnel. Leur intérêt principal réside donc
dans une utilisation interactive en profitant de la librairie de 
fonctions accessibles.</p>
<!--TOC subsubsection id="sec26" Giac/Xcas-->
<h4 id="sec26" class="subsubsection">3.7.2  Giac/Xcas</h4><!--SEC END --><p>
Il s’agit du système de calcul formel que j’implémente actuellement sous 
forme d’une bibliothèque C++ (ce qui
permettra aux programmes tiers d’utiliser beaucoup plus facilement du 
calcul formel qu’avec les systèmes précédents). L’objectif est 
d’avoir un système facile à programmer directement en C++, proche 
du langage utilisateur, lui-même compatible avec Maple ou MuPAD, 
tout cela sans trop perdre en performances comparativement aux
librairies spécialisées écrites en C/C++. Ce qui explique un choix 
de type générique (<code>gen</code>) non orienté objet, avec un champ type 
et soit une donnée immédiate (pour les nombres flottants par exemple), 
soit un pointeur vers un objet du type correspondant au champ type pour 
les données de taille non fixe (on pourrait donc se
contenter du langage C, mais le langage C++ permet de redéfinir 
les opérateurs sur des types utilisateurs ce qui
améliore considérablement la lisibilité du code source). 
Les données dynamiques ne sont pas dupliquées, Giac
utilise un pointeur sur un compteur de référence pour détruire 
ces données lorsqu’elles ne sont plus référencées.</p><p>Les entiers en précision arbitraire sont hérités de la bibliothque
GMP (écrite en C) du projet GNU. Les flottants en précision arbitraire
utiliseront aussi GMP (plus précisément MPFR).
Il y a un type fraction, structure C composé d’un champ numérateur
et d’un champ dénominateur, et un type nombre complexe.</p><p>Les listes, vecteurs, matrices utilisent le type paramétré <code>vector&lt;&gt;</code>
de la librairie standard C++ (Standard Template Library).
Les objets symboliques sont des structures composés d’un champ sommet
qui est une fonction prenant un argument de type <code>gen</code>
et renvoyant un résultat
de type <code>gen</code>, et d’un champ feuille qui est de type <code>gen</code>.
Lorsqu’une fonction possède plusieurs arguments, ils sont rassemblés
en une liste formant le champ feuille de l’objet symbolique.
Les programmes sont aussi des objets symboliques, dont le champ
sommet est la fonction évaluation d’un programme.
Les listes sont aussi utilisées pour représenter vecteurs, matrices
et polynômes en une variable en représentation dense, on peut
y accéder par valeur (<code>:=</code>) ou par référence
(<code>=&lt;</code>). Ces polynômes servent eux-mêmes á représenter
des éléments d’une 
<span style="font-weight:bold">extension algébrique</span><a id="hevea_default20"></a><a id="hevea_default21"></a> de ℚ (vus comme
un couple de polynômes <span style="font-style:italic">P</span>,<span style="font-style:italic">Q</span>, où <span style="font-style:italic">Q</span> est un polynome minimal
irréductible à coefficients entiers, autrement dit <span style="font-style:italic">P</span>,<span style="font-style:italic">Q</span> vaut <span style="font-style:italic">P</span>(α) 
où <span style="font-style:italic">Q</span>(α)=0),
ou des éléments d’un corps fini (comme ci-dessus, mais ici <span style="font-style:italic">Q</span> est
à coefficients dans ℤ/<span style="font-style:italic">p</span>ℤ avec <span style="font-style:italic">p</span> premier, cf. la commande <code>GF</code>).
Giac posséde aussi un type pour les polynômes
en représentation creuse distribuée en plusieurs
indéterminées (cf. les commandes <code>symb2poly</code> et <code>poly2symb</code>).</p><p>L’évaluation d’un objet symbolique se fait en regardant d’abord si
la fonction au sommet doit évaluer ou non ses arguments (autoquote),
on évalue les arguments si nécessaire puis on applique la fonction.</p><p>Une hypthèse sur un paramètre est une valeur spéciale
affectée au paramètre, valeur ignorée par la routine d’évaluation.</p>
<!--TOC subsubsection id="sec27" Calculatrices formelles HP48/49-->
<h4 id="sec27" class="subsubsection">3.7.3  Calculatrices formelles HP48/49</h4><!--SEC END --><p>
Les langages utilisés pour programmer ces calculateurs sont l’assembleur
et le RPL (Reverse Polish Lisp) adapté à l’écriture de code
en mémoire morte très compact.</p><p>Le type générique est implémenté avec un champ type appelé prologue (qui est
en fait un pointeur sur la fonction chargée d’évaluer ce type d’objet)
suivi de la donnée elle-même (et non d’un pointeur sur la donnée, on
économise ainsi la place mémoire du compteur de référence).</p><p>Le type entier en précision arbitraire est codé par le nombre de digits 
(sur 5 quartets<sup><a id="text3" href="#note3">3</a></sup>) suivi du signe sur un 
quartet et de la représentation BCD (en base 10) de la valeur absolue de 
l’entier. Le choix de la représentation BCD a été fait pour optimiser 
les temps de conversion en chaîne de caractères pour l’affichage. La mémoire
vive disponible est de 256K, c’est elle qui limite la taille des entiers 
et non le champ longueur de l’entier. Il n’y a pas de type spécifique 
pour les rationnels (on utilise un objet
symbolique normal). </p><p>Les fonctions internes des HP49/50/40 utilisent 
le type programme pour représenter les entiers de Gauß (complexes
dont la partie réelle et imaginaire est entière).
Les nombres algébriques ne sont pas implémentés, sauf les racines carrées
(représentée de manière interne par le type programme). 
Il y a un type spécifique prévu pour les flottants en précision arbitraire, 
mais l’implémentation des opérations sur ces types
n’a pas été intégrée en ROM à ce jour. </p><p>Les types listes, programmes et objet symbolique sont composés du prologue
(champ type) suivi par la succession d’objets situés en
mémoire vive ou de pointeurs sur des objets situés en mémoire en lecture 
seule (ROM) et se terminent par un pointeur sur une
adresse fixe (appelée <code>SEMI</code>). Ces types sont eux-mêmes des 
objets et peuvent donc être utilisés de manière
récursive. La longueur des types listes, programmes, symboliques 
n’est stockée nulle part, c’est le délimiteur final
qui permet de la connaître, ce qui est parfois source d’inefficacité.
On utilise de manière interne les listes pour représenter les 
polynômes denses (avec 
représentation récursive pour les polynômes à plusieurs variables). </p><p>Les calculatrices HP4xG utilisent une pile<sup><a id="text4" href="#note4">4</a></sup>, c’est-à-dire une liste
de taille non fixée d’objets. On place les objets sur la pile,
l’exécution d’une fonction prend ces arguments sur
la pile et renvoie un ou plusieurs résultats sur la pile (ce qui est
une souplesse du RPN comparé aux langages où on ne peut renvoyer
qu’une valeur de retour). Il faut donc
donner les arguments avant d’appeler la fonction correspondante. Par
exemple pour calculer <span style="font-style:italic">a</span>+<span style="font-style:italic">b</span> on tapera <code>a b +</code>. C’est
la syntaxe dite polonaise inversée (RPN). Un avantage de cette syntaxe
est que le codage d’un objet symbolique par cette syntaxe est évidente,
il suffit de stocker la liste précédente <code>{a b +}</code>.
Les objets symboliques sont donc représenté par une suite d’objets écrit
en syntaxe polonaise inversée. L’évaluation d’un objet symbolique se fait
dans l’ordre polonaise inversé : les arguments sont évalués
puis les fonctions leur sont appliqués. Pour des raisons d’efficacité, 
on représente souvent les objets composites (listes, symboliques) par 
leurs composants placés sur la pile (appelé meta-objets).</p><p>Une rigidité de la syntaxe polonaise est
que les fonctions ont toujours un nombre fixe d’arguments<sup><a id="text5" href="#note5">5</a></sup>, par
exemple l’addition a toujours 2 arguments, ainsi
<span style="font-style:italic">a</span>+<span style="font-style:italic">b</span>+<span style="font-style:italic">c</span> est obtenu par (<span style="font-style:italic">a</span>+<span style="font-style:italic">b</span>)+<span style="font-style:italic">c</span> ou par <span style="font-style:italic">a</span>+(<span style="font-style:italic">b</span>+<span style="font-style:italic">c</span>)
c’est-à-dire respectivement <code>a b + c +</code> ou <code>a b c + +</code> ce qui
brise parfois artificiellement la symétrie de certaines opérations. En
polonaise inversée, le système doit de plus jongler avec l’autoquote puisque
les arguments sont évalués avant l’opérateur qui éventuellement demanderait
à ne pas évaluer ses arguments. À noter l’existence d’une commande 
<code>QUOTE</code> permettant à l’utilisateur de quoter une sous-expression.</p><p>Les hypothèses sur des variables réelles sont regroupées dans une liste
stockée dans la variable globale <code>REALASSUME</code>, on peut supposer
qu’une variable est dans un intervalle. Il n’y a pas à ce jour
de possibilité de supposer qu’une variable est entière (ni à fortiori
qu’une variable à une valeur modulo un entier fixé), bien qu’il ait été
décidé de réserver la variable globale <code>INTEGERASSUME</code> à cet effet.
Il n’y a pas de possibilité de faire des hypothèses ayant une portée
locale.</p>
<!--TOC subsubsection id="sec28" Calculatrices formelles TI92/89/Voyage 200-->
<h4 id="sec28" class="subsubsection">3.7.4  Calculatrices formelles TI92/89/Voyage 200</h4><!--SEC END --><p>
Le langage utilisé pour programmer ces calculatrices est le langage C
(on peut aussi écrire du code en assembleur pour ces calculatrices).
On retrouve ici les différents types de données regroupé en un
type générique qui est un tableau d’octets (aussi appelé quantum). 
Le champ type
est appelé tag dans la documentation TI. Contrairement à ce qui
précède, ce champ type est placé en mémoire à la fin de l’objet,
ce qui est possible car la longueur d’un objet est toujours indiquée
au début de l’objet. Ceci est fait afin de faciliter l’évaluation (cf.
infra).</p><p>Les entiers en précision arbitraire sont codés par un tag parmi deux (pour
différencier le signe), un octet pour la longueur, puis la valeur
absolue de l’entier (en base 256). Ils sont donc limités par le
champ longueur à 255 octets, le plus grand entier représentable est
<sup><a id="text6" href="#note6">6</a></sup> (256<sup>255</sup>−1).
Il existe un tag spécifique pour les rationnels, pour les constantes 
réelles et entières qui apparaissent par exemple en résolvant une équation.
Il existe des tags utilisés de manière interne, par exemple
pour les nombres complexes. 
Il n’y a pas de tag prévu pour les flottants en précision arbitraire.
ni pour les nombres algébriques (racines carrées par 
exemple).</p><p>Les listes sont codées par la succession de leurs éléments. En principe
elles ne peuvent pas contenir des listes (sauf pour représenter
une matrice).
Quelques fonctions utilisent les listes pour représenter des polynômes 
denses à une variable, mais probablement pas pour représenter de manière
récursive des polynômes à plusieurs variables (puisque le type liste
n’est en principe pas récursif).</p><p>Comme les HP, les TI utilisent une pile (non visible par
l’utilisateur) appelée expression stack
afin de traduire un expression mathématique sous forme d’un texte
en un objet symbolique codé exactement comme ci-dessus en syntaxe
polonaise. Toutefois, la présence du champ longueur
permet d’évaluer un objet symbolique sans perdre en efficacité
en partant de l’opérateur
final et en redescendant ensuite sur ces arguments, c’est la stratégie
adoptée. C’est pour cela que le tag d’identification
se trouve à la fin de l’objet. L’utilisation de cette méthode
facilite grandement l’autoquotation (on peut toutefois regretter
que le système n’ait pas prévu d’instruction permettant à l’utilisateur 
d’empêcher l’évaluation d’une sous-expression).</p><p>On ne peut pas faire d’hypothèse globale sur un paramètre par
contre on peut faire des hypothèses de type appartenance à un intervalle 
ayant une portée locale.</p>
<!--TOC subsection id="sec29" Algorithmes et complexité.-->
<h3 id="sec29" class="subsection">3.8  Algorithmes et complexité.</h3><!--SEC END --><p>
On va présenter dans la suite quelques algorithmes que l’on peut
considérer comme classiques dans le domaine du calcul formel. Avant 
d’implémenter ce type d’algorithmes, on a besoin des algorithmes de base
en arithmétique. </p><p>La plupart des problèmes posés en calcul formel nécessitent des
calculs dont la taille croit de manière exponentielle voire
doublement exponentielle en fonction de la taille des données et
ce même si le résultat est lui aussi de taille petite. Un
exemple est la réduction des systèmes de plusieurs équations polynomiales
(bases de Groebner).</p>
<!--TOC subsubsection id="sec30" Algorithmes modulaires ou p-adiques-->
<h4 id="sec30" class="subsubsection">3.8.1  Algorithmes modulaires ou p-adiques</h4><!--SEC END --><p>
Dans certains cas, l’application de théories mathématiques
parfois sophistiquées permet de réduire la complexité (par exemple,
M. Van Hoeij a découvert récemment qu’un algorithme très utilisé en théorie des
nombres, l’algorithme LLL, permettait d’améliorer la complexité d’une des
étapes de la factorisation des polynomes à coefficients entiers sur les
entiers). Heureusement, dans de nombreux cas, on peut réduire la
complexité (donc le temps de calcul) par des adaptations au
problème d’une même idée à condition de faire des
hypothèses sur les données (autrement dit en abandonnant la volonté
d’implémenter un algorithme très générique, ou tout au moins
en spécialisant des algorithmes génériques).
Par exemple lorsqu’on travaille
avec des entiers (ou des polynômes à coefficients entiers, ou
des matrices à coefficients entiers...) on utilise souvent des algorithmes
modulaires et <span style="font-style:italic">p</span>-adiques. Comme le calcul exact nécessite
presque toujours de calculer avec des entiers, ces méthodes
ont un rôle central en calcul formel, nous les présentons donc
maintenant brièvement. Dans les prochaines sections, nous utiliserons
ce type de méthode, par exemple pour le calcul de PGCD ou la factorisation
de polynômes à coefficients entiers.</p><p>Les méthodes <span style="font-weight:bold">modulaires</span><a id="hevea_default22"></a> consistent à réduire un problème dans 
ℤ à son équivalent dans <span style="font-style:italic">Z</span>/<span style="font-style:italic">n</span>ℤ pour une ou 
plusieurs valeurs de <span style="font-style:italic">n</span>, nombre premier. Le calcul dans ℤ/<span style="font-style:italic">n</span>ℤ
a l’avantage de se faire avec des entiers dont la taille est bornée.
Ensuite à l’aide d’estimations 
à priori sur la taille des solutions 
éventuelles du problème initial, on reconstruit la solution au problème
initial avec le théorème des restes chinois. </p><p>Par exemple, on peut calculer un déterminant d’une matrice
à coefficients entiers en cherchant ce déterminant dans ℤ/<span style="font-style:italic">n</span>ℤ
pour plusieurs nombres premiers <span style="font-style:italic">n</span>, dont le produit est deux fois plus grand qu’une 
estimation à priori de la taille du déterminant 
(donnée par exemple par l’inégalité d’Hadamard, cf. Cohen, p. 50). </p><p>Les méthodes <span style="font-style:italic">p</span><span style="font-weight:bold">-adiques</span><a id="hevea_default23"></a> commencent de manière identique par un 
calcul dans ℤ/<span style="font-style:italic">n</span>ℤ, on augmente ensuite la
précision de la solution en la «liftant»de ℤ/<span style="font-style:italic">n</span><sup><span style="font-style:italic">k</span></sup> ℤ vers 
ℤ/<span style="font-style:italic">n</span><sup><span style="font-style:italic">k</span>+1</sup>ℤ ou vers ℤ/<span style="font-style:italic">n</span><sup>2<span style="font-style:italic">k</span></sup>ℤ (lift
linéaire ou lift quadratique), on s’arrête lorsque <span style="font-style:italic">k</span> est assez grand 
(à l’aide d’estimations à priori) et on
reconstruit alors la solution initiale. L’étape de «lift»est en 
général un lemme de Hensel dont on verra quelques exemples dans les
prochains articles. L’algorithme
commun au lemme de Hensel et au théorème des restes chinois est 
l’identité de Bézout, que l’on retrouve 
d’ailleurs un peu partout (par exemple pour le calcul de primitives). </p><p>Illustrons cette méthode sur un exemple simple, la recherche de 
<span style="font-weight:bold">racines rationnelles</span><a id="hevea_default24"></a> d’un polynôme <span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>)=<span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub> <span style="font-style:italic">X</span><sup><span style="font-style:italic">d</span></sup> + ⋯ + <span style="font-style:italic">a</span><sub>0</sub> 
à coefficients entiers ou polynomiaux, avec <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub> et <span style="font-style:italic">a</span><sub>0</sub> non nuls. 
L’algorithme générique (assez connu) consiste 
à chercher les diviseurs de <span style="font-style:italic">a</span><sub>0</sub> et de <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub> et à tester toutes 
les fractions de ces diviseurs, on montre en effet 
aisément que si <span style="font-style:italic">X</span>=<span style="font-style:italic">p</span>/<span style="font-style:italic">q</span> fraction irréductible est racine de <span style="font-style:italic">P</span> 
alors <span style="font-style:italic">q</span> divise <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub> et <span style="font-style:italic">p</span> divise <span style="font-style:italic">a</span><sub>0</sub>. Cet 
algorithme est très inefficace si <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub> ou <span style="font-style:italic">a</span><sub>0</sub> est un grand entier 
(car on ne sait pas forcément le factoriser) ou 
s’il a beaucoup de facteurs premiers (la liste des diviseurs à tester 
est alors très grande). </p><p>Lorsque les coefficients de <span style="font-style:italic">P</span> sont entiers, la recherche précédente 
revient à trouver un facteur à
coefficients entiers <span style="font-style:italic">qX</span>−<span style="font-style:italic">p</span> de <span style="font-style:italic">P</span>, on peut donc réduire le problème 
modulo un entier premier <span style="font-style:italic">n</span> qui ne divise pas <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub> : si un tel facteur 
existe dans ℤ alors ce facteur (réduit modulo <span style="font-style:italic">n</span>) est un facteur 
de <span style="font-style:italic">P</span> dans ℤ/<span style="font-style:italic">n</span>ℤ
donc <span style="font-style:italic">P</span> admet une racine dans ℤ/<span style="font-style:italic">n</span>ℤ (puisque <span style="font-style:italic">q</span> est inversible 
modulo <span style="font-style:italic">n</span> car on a choisi <span style="font-style:italic">n</span> premier ne divisant pas <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub>). On
évalue maintenant <span style="font-style:italic">P</span> en les <span style="font-style:italic">n</span> éléments de ℤ/<span style="font-style:italic">n</span>ℤ. S’il n’y a pas 
de 0, alors <span style="font-style:italic">P</span> n’a pas de racine rationnelle. S’il y a des racines, on va 
les lifter de ℤ/<span style="font-style:italic">n</span><sup><span style="font-style:italic">k</span></sup>ℤ dans ℤ/<span style="font-style:italic">n</span><sup>2<span style="font-style:italic">k</span></sup>ℤ.</p><p>On suppose donc que pour <span style="font-style:italic">k</span>≥ 1, il existe un entier <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> tel que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>)=0 (mod <span style="font-style:italic">n</span><sup><span style="font-style:italic">k</span></sup> ) </td></tr>
</table><p>
Il s’agit de trouver un entier <span style="font-style:italic">x</span> tel que <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>+<span style="font-style:italic">n</span><sup><span style="font-style:italic">k</span></sup>  <span style="font-style:italic">x</span>
vérifie
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span>+1</sub>)=0 (mod <span style="font-style:italic">n</span><sup>2<span style="font-style:italic">k</span></sup> ) </td></tr>
</table><p>
On applique la formule de Taylor à l’ordre 1 pour <span style="font-style:italic">P</span> en <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>, le
reste est nul modulo <span style="font-style:italic">n</span><sup>2<span style="font-style:italic">k</span></sup>, donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>)+ <span style="font-style:italic">n</span><sup><span style="font-style:italic">k</span></sup>  <span style="font-style:italic">x</span> <span style="font-style:italic">P</span>′(<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>)=0 (mod <span style="font-style:italic">n</span><sup>2<span style="font-style:italic">k</span></sup> ) </td></tr>
</table><p>
soit finalement :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>=−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span>(<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span><sup><span style="font-style:italic">k</span></sup></td></tr>
</table></td><td class="dcell">  ( <span style="font-style:italic">P</span>′(<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>) (mod <span style="font-style:italic">n</span><sup><span style="font-style:italic">k</span></sup> )) <sup>−1</sup> </td></tr>
</table><p>
On reconnaît au passage la méthode de Newton<a id="hevea_default25"></a>, pour qu’elle fonctionne 
il suffit que <span style="font-style:italic">P</span>′(<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>) ≠ 0 (mod <span style="font-style:italic">n</span> ) ce qui
permet de l’inverser modulo <span style="font-style:italic">n</span><sup><span style="font-style:italic">k</span></sup> (et c’est ici qu’intervient 
l’identité de Bézout). En pratique quand on factorise
un polynôme, on commence par retirer les multiplicités, 
on peut donc supposer que <span style="font-style:italic">P</span> est sans facteur multiple dans
ℤ. Ceci n’entraîne pas forcément qu’il le reste dans ℤ/<span style="font-style:italic">n</span>ℤ 
ce qui crée une contrainte supplémentaire sur le choix
de <span style="font-style:italic">n</span>, à savoir que <span style="font-style:italic">P</span> et <span style="font-style:italic">P</span>′ restent premier entre eux dans ℤ/<span style="font-style:italic">n</span>ℤ 
(il existe forcément de tels <span style="font-style:italic">n</span>, par exemple
<span style="font-style:italic">n</span> premier plus grand que le plus grand entier intervenant dans le calcul 
du PGCD de <span style="font-style:italic">P</span> et <span style="font-style:italic">P</span>′ dans ℤ).</p><p>Reste donc à revenir dans ℤ à partir d’une racine <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> dans ℤ/(<span style="font-style:italic">n</span><sup><span style="font-style:italic">k</span></sup> ℤ)
(où on peut choisir <span style="font-style:italic">k</span>). 
On va maintenant utiliser la représentation 
<span style="font-weight:bold">modulaire symétrique</span><a id="hevea_default26"></a> :
on prend comme représentant modulaire d’un entier <span style="font-style:italic">z</span> dans ℤ/<span style="font-style:italic">n</span><sup><span style="font-style:italic">k</span></sup>ℤ
l’unique entier congru à <span style="font-style:italic">z</span> modulo <span style="font-style:italic">n</span> qui est strictement compris entre
−<span style="font-style:italic">n</span><sup><span style="font-style:italic">k</span></sup>/2 et <span style="font-style:italic">n</span><sup><span style="font-style:italic">k</span></sup>/2 (si <span style="font-style:italic">n</span> est pair, la deuxième inégalité
est choisie large).</p><p>Si <span style="font-style:italic">qX</span>−<span style="font-style:italic">p</span> est un facteur de <span style="font-style:italic">P</span>, alors <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub><span style="font-style:italic">X</span>−<span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub>/<span style="font-style:italic">q</span><span style="font-style:italic">p</span> est encore 
un facteur de <span style="font-style:italic">P</span> (le quotient de <span style="font-style:italic">P</span> par <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub><span style="font-style:italic">X</span>−<span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub>/<span style="font-style:italic">q</span><span style="font-style:italic">p</span>
est à coefficients rationnels mais le facteur est à coefficients entiers). 
Si on a choisi <span style="font-style:italic">k</span> tel que <span style="font-style:italic">n</span><sup><span style="font-style:italic">k</span></sup>&gt;2|<span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub> <span style="font-style:italic">a</span><sub>0</sub>|, l’écriture en représentation
modulaire symétrique de <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub><span style="font-style:italic">X</span>−<span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub>/<span style="font-style:italic">q</span><span style="font-style:italic">p</span> est inchangée,
en effet on a des estimations à priori sur les entiers <span style="font-style:italic">p</span> et <span style="font-style:italic">q</span> : 
|<span style="font-style:italic">q</span>|≤ |<span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub>| et |<span style="font-style:italic">p</span>| ≤ |<span style="font-style:italic">a</span><sub>0</sub>| puisque <span style="font-style:italic">q</span> 
divise <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub> et <span style="font-style:italic">p</span> divise <span style="font-style:italic">a</span><sub>0</sub>. 
Comme <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub><span style="font-style:italic">X</span>−<span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub>/<span style="font-style:italic">q</span><span style="font-style:italic">p</span> est égal à <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub>(<span style="font-style:italic">X</span>−<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>) dans ℤ/(<span style="font-style:italic">n</span><sup><span style="font-style:italic">k</span></sup> ℤ),
il nous suffit d’écrire en représentation modulaire 
symétrique <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub>(<span style="font-style:italic">X</span>−<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>)=<span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub> <span style="font-style:italic">X</span>−<span style="font-style:italic">p</span>′.
Pour conclure, on sait que <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub> <span style="font-style:italic">X</span>−<span style="font-style:italic">p</span>′ est un multiple entier de <span style="font-style:italic">qX</span>−<span style="font-style:italic">p</span>.
On divise donc le facteur <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub> <span style="font-style:italic">X</span>−<span style="font-style:italic">p</span>′ par le pgcd de <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub> et <span style="font-style:italic">p</span>′ et on
teste la divisibilité de <span style="font-style:italic">P</span> par ce facteur réduit.</p><p><span style="font-weight:bold">Exemple</span><br>
Considérons le polynôme 2 <span style="font-style:italic">X</span><sup>3</sup>−<span style="font-style:italic">X</span><sup>2</sup>−<span style="font-style:italic">X</span>−3 qui est sans facteur carré.
On ne peut pas choisir <span style="font-style:italic">n</span>=2 car on réduirait le degré, pour <span style="font-style:italic">n</span>=3,
on a <span style="font-style:italic">P</span>′=<span style="font-style:italic">X</span>−1 qui est facteur de <span style="font-style:italic">P</span>, pour <span style="font-style:italic">n</span>=5, <span style="font-style:italic">P</span>′=6<span style="font-style:italic">X</span><sup>2</sup>−2<span style="font-style:italic">X</span>−1,
on vérifie que <span style="font-style:italic">P</span> et <span style="font-style:italic">P</span>′ sont premiers entre eux (par exemple
avec <code>GCDMOD</code> sur une HP49 où on aura fixé la variable <code>MODULO</code>
à 5).</p><p>On teste ensuite les entiers de -2 à 2 sur <span style="font-style:italic">P</span>. Seul -1 est racine
modulo 5 (<span style="font-style:italic">P</span>(−1)=−5), on va maintenant lifter <span style="font-style:italic">p</span><sub>1</sub>=−1. </p><p>L’estimation à priori est 2|<span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub>||<span style="font-style:italic">a</span><sub>0</sub>|=12 donc <span style="font-style:italic">k</span>=2 (5<sup>2</sup>=25&gt;12), 
une itération suffira. On a <span style="font-style:italic">P</span>′(−1)=7, l’inverse de <span style="font-style:italic">P</span>′(−1) (mod 5 )
est -2 donc:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>= −</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span>(−1)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell"> (−2) = −(−1)  (−2)=−2 </td></tr>
</table><p>
et <span style="font-style:italic">p</span><sub>2</sub>=−1+5×(−2)=−11 est racine de <span style="font-style:italic">P</span> dans ℤ/25ℤ.
On calcule ensuite <span style="font-style:italic">a</span><sub><span style="font-style:italic">d</span></sub>(<span style="font-style:italic">X</span>−<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>)=2(<span style="font-style:italic">X</span>+11)=2<span style="font-style:italic">X</span>+22=2<span style="font-style:italic">X</span>−3 en représentation
symétrique, le PGCD de 2 et -3 est 1 donc on teste le facteur
2<span style="font-style:italic">X</span>−3, ici il divise <span style="font-style:italic">P</span> donc <span style="font-style:italic">P</span> admet un unique facteur entier
de degré 1 qui est 2<span style="font-style:italic">X</span>−3.</p>
<!--TOC subsubsection id="sec31" Algorithmes déterministes. Algorithmes probabilistes: Las Vegas
et Monte-Carlo-->
<h4 id="sec31" class="subsubsection">3.8.2  Algorithmes déterministes. Algorithmes probabilistes: Las Vegas
et Monte-Carlo</h4><!--SEC END --><p><a id="hevea_default27"></a><a id="hevea_default28"></a><a id="hevea_default29"></a><a id="hevea_default30"></a>
L’algorithme p-adique présenté ci-dessus est un algorithme
déterministe, il renvoie toujours un résultat certifié et 
le temps de calcul nécessaire à son exécution ne dépend
pas du hasard (sauf si on choisit le nombre premier <span style="font-style:italic">p</span> au hasard...).
Ce type d’algorithmes est parfois trop long par rapport 
à d’autres type d’algorithmes utilisant le hasard :
</p><ul class="itemize"><li class="li-itemize">
les algorithmes de type Las Vegas. Ceux-ci utilisent un 
élément aléatoire (dont dépend le temps d’exécution) mais
certifient le résultat. Par exemple pour calculer le polynôme
caractéristique d’une matrice <span style="font-style:italic">M</span> de taille <span style="font-style:italic">n</span>, on choisit 
un vecteur <span style="font-style:italic">v</span> aléatoirement
et on cherche une relation linéaire entre <span style="font-style:italic">v</span>,<span style="font-style:italic">Mv</span>,...,<span style="font-style:italic">M</span><sup><span style="font-style:italic">n</span></sup><span style="font-style:italic">v</span>,
s’il n’y en a qu’une à constante multiplicative près, alors
elle donne le polynôme caractéristique, sinon on se rabat
sur une autre méthode (ou on renvoie une erreur).
</li><li class="li-itemize">les algorithmes de type Monte-Carlo. Ceux-ci utilisent un
élément aléatoire mais ne certifient pas le résultat, qui a
une très faible probabilité d’être inexact. Par exemple,
pour calculer un déterminant d’une matrice à coefficients
entiers, on peut faire le calcul modulo plusieurs nombres
premiers et reconstruire le résultat par le théorème
des restes chinois et décider de s’arrêter lorsque
le résultat reconstruit est stable pour un, deux, ... nombres
premiers. L’inverse de la probabilité d’erreur est égale
au produit des nombres premiers pour lesquel on observe la
stabilité. Autre exemple: le test de pseudo-primalité
de Miller-Rabin.
</li></ul><p>
Dans Xcas, certains algorithmes sont de type Monte-Carlo par
défaut, notamment le calcul de déterminant de grandes matrices
à coefficients entiers ou de bases de Gröbner, et un warning
s’affiche alors. La variable
<code>proba_epsilon</code> permet de régler le niveau de probabilité
d’erreur acceptée, on peut la mettre à 0 pour forcer l’utilisation
d’algorithmes déterministes ou de type Las Vegas avec certification
du résultat. Si l’on fait des calculs à but expérimental pour
établir une conjecture, il n’est pas nécessaire de certifier un
calcul et il ne sert à rien de mettre <code>proba_epsilon</code> à 0.
Par contre, pour établir une preuve (au sens mathématique du terme) qui
nécessite un calcul fait sur machine,
on prendra soin de mettre <code>proba_epsilon</code> à 0. 
On remarquera au passage que ce type de
preuve ne peut se faire qu’avec un logiciel open-source, puisqu’il
faut aussi pouvoir montrer que l’algorithme utilisé
est correctement implémenté.</p>
<!--TOC subsection id="sec32" Quelques algorithmes d’arithmétique de base.-->
<h3 id="sec32" class="subsection">3.9  Quelques algorithmes d’arithmétique de base.</h3><!--SEC END --><ul class="itemize"><li class="li-itemize">
Les algorithmes de multiplication et division dit rapides
des entiers et polynômes (Karatsuba, FFT, ...). Cf. par exemple Knuth.
ou pour les entiers la documentation de GMP, ou infra pour Karatsuba.
</li><li class="li-itemize">Au lieu de la division euclidienne, on utilise très souvent la
<span style="font-weight:bold">pseudo-division</span><a id="hevea_default31"></a> pour les polynômes : étant donné deux polynômes <span style="font-style:italic">A</span>
et <span style="font-style:italic">B</span> de degrés <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> à coefficients dans un anneau contenu dans un corps
(par exemple ℤ), on multiplie <span style="font-style:italic">A</span> par une puissance du coefficient
dominant <span style="font-style:italic">B</span><sub><span style="font-style:italic">b</span></sub> de <span style="font-style:italic">B</span>, plus précisément par <span style="font-style:italic">B</span><sub><span style="font-style:italic">b</span></sub><sup><span style="font-style:italic">a</span>−<span style="font-style:italic">b</span>+1</sup>, ce qui permet 
d’effectuer la division par <span style="font-style:italic">B</span> sans que
les coefficients sortent de l’anneau.
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">B</span><sub><span style="font-style:italic">b</span></sub><sup><span style="font-style:italic">a</span>−<span style="font-style:italic">b</span>+1</sup> <span style="font-style:italic">A</span>= <span style="font-style:italic">B</span> <span style="font-style:italic">Q</span> + <span style="font-style:italic">R</span> </td></tr>
</table>
On utilise cette méthode lorsqu’on peut multiplier les polynômes par
des constantes sans changer le problème (par exemple pour l’algorithme
d’Euclide).
</li><li class="li-itemize">L’algorithme d’Euclide est un algorithme «générique»de calcul
de PGCD. Il n’est en général pas utilisé tel quel. Pour les entiers 
on utilise une variation adaptée à la
représentation binaire des entiers (cf. Cohen ou le manuel de GMP version 4 
pour plus de détails). Nous décrirons des
algorithmes de PGCD plus efficaces pour les polynômes dans le prochain article.
</li><li class="li-itemize">l’<span style="font-weight:bold">identité de Bézout</span><a id="hevea_default32"></a>, aussi appelée PGCD étendu. Étant donné
deux entiers ou deux polynômes <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> on calcule <span style="font-style:italic">u</span>, <span style="font-style:italic">v</span> et
<span style="font-style:italic">d</span> tels que <span style="font-style:italic">au</span>+<span style="font-style:italic">bv</span>=<span style="font-style:italic">d</span>. On écrit la matrice :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">a</span></td><td style="text-align:left;white-space:nowrap" >1</td><td style="text-align:left;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">b</span></td><td style="text-align:left;white-space:nowrap" >0</td><td style="text-align:left;white-space:nowrap" >1
</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎠</td></tr>
</table>
où on remarque que pour chaque ligne le coefficient de la 1ère colonne 
est égal à <span style="font-style:italic">a</span> multiplié par le coefficient de la
2ème colonne additionné à <span style="font-style:italic">b</span> multiplié par le coefficient de la 
3ème colonne. Ce qui reste vrai si on effectue des
combinaisons linéaires de lignes (type réduction de Gauß). 
Comme on travaille dans les entiers ou les polynômes, on remplace la
réduction de Gauß des matrices à coefficients réels par une combinaison 
linéaire utilisant le quotient <em>euclidien</em> (entier ou polynomial
selon le cas) <span style="font-style:italic">q</span>
de <span style="font-style:italic">a</span> par <span style="font-style:italic">b</span>. On obtient alors le reste <span style="font-style:italic">r</span> en 1ère colonne :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">L</span><sub>1</sub></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">a</span></td><td style="text-align:left;white-space:nowrap" >1</td><td style="text-align:left;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">L</span><sub>2</sub></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">b</span></td><td style="text-align:left;white-space:nowrap" >0</td><td style="text-align:left;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">L</span><sub>3</sub>=<span style="font-style:italic">L</span><sub>1</sub>−<span style="font-style:italic">qL</span><sub>2</sub></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">r</span></td><td style="text-align:left;white-space:nowrap" >1</td><td style="text-align:left;white-space:nowrap" >−<span style="font-style:italic">q</span>
</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table>
et on recommence jusqu’à obtenir 0 en 1ère colonne.
L’avant-dernière ligne obtenue est l’identité de Bézout (la dernière
ligne donne les cofacteurs du PPCM de <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span>). 
Si l’on veut l’inverse de <span style="font-style:italic">a</span> modulo
<span style="font-style:italic">b</span> on remarque qu’il n’est pas utile de calculer les coefficients
appartenant à la 3ème colonne. Enfin, les lignes intermédiaires
peuvent servir à reconstruire une fraction d’entier représentée
par un entier de ℤ/<span style="font-style:italic">n</span>ℤ lorsque le numérateur et le dénominateur
sont de valeur absolue inférieure à √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span><span style="text-decoration:overline">/2</span>. Exemple :<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">step_infolevel:=1;iegcd(1234,357);step_infolevel:=0 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
Voir aussi dans Xcas la session exemple depuis le menu Exemple,arit,bezout.xws.
</li><li class="li-itemize">Le théorème des <span style="font-weight:bold">restes chinois</span><a id="hevea_default33"></a><a id="hevea_default34"></a>. 
Si on connaît <span style="font-style:italic">x</span>=<span style="font-style:italic">a</span> (mod <span style="font-style:italic">m</span> )
et <span style="font-style:italic">x</span>= <span style="font-style:italic">b</span> (mod <span style="font-style:italic">n</span> )  avec <span style="font-style:italic">m</span> et <span style="font-style:italic">n</span> premiers entre eux,
on détermine <span style="font-style:italic">c</span> tel que
<span style="font-style:italic">x</span>=<span style="font-style:italic">c</span> (mod <span style="font-style:italic">m</span>× <span style="font-style:italic">n</span> ). On a donc <span style="font-style:italic">c</span>=<span style="font-style:italic">a</span>+<span style="font-style:italic">mu</span>=<span style="font-style:italic">b</span>+<span style="font-style:italic">nv</span> et on applique
Bézout pour trouver <span style="font-style:italic">u</span> ou <span style="font-style:italic">v</span>, on en déduit <span style="font-style:italic">c</span>. En pratique,
on cherche un des coefficients de Bézout, par exemple on cherche <span style="font-style:italic">U</span>
tel que <span style="font-style:italic">mU</span>+<span style="font-style:italic">nV</span>=1, on a alors :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">c</span>=<span style="font-style:italic">a</span>+<span style="font-style:italic">m</span> (<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>)<span style="font-style:italic">U</span> </td></tr>
</table>
Si <span style="font-style:italic">n</span> est petit devant <span style="font-style:italic">m</span> (par exemple 32 bits), <span style="font-style:italic">U</span> est aussi petit,
on commence par réduire <span style="font-style:italic">b</span>−<span style="font-style:italic">a</span> modulo <span style="font-style:italic">n</span>,
puis on multiplie par <span style="font-style:italic">U</span>, on réduit à nouveau modulo <span style="font-style:italic">n</span> et on
multiple enfin par <span style="font-style:italic">m</span>.
</li><li class="li-itemize">L’algorithme de <span style="font-weight:bold">Hörner</span><a id="hevea_default35"></a>
pour évaluer un polynôme
<span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>)=<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span></sup>+...+<span style="font-style:italic">a</span><sub>0</sub> en <span style="font-style:italic">x</span>. Il consiste à réécrire <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>) sous
la forme
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)=(...((<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">x</span>+<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub>)<span style="font-style:italic">x</span>+<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−2</sub>)<span style="font-style:italic">x</span>+...+<span style="font-style:italic">a</span><sub>1</sub>)<span style="font-style:italic">x</span>+<span style="font-style:italic">a</span><sub>0</sub></td></tr>
</table>
on calcule donc successivement 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>,  <span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span>−1</sub>=<span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">x</span>+<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub>,  <span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span>−2</sub>=<span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span>−1</sub><span style="font-style:italic">x</span>+<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−2</sub>,
....  <span style="font-style:italic">b</span><sub>0</sub>=<span style="font-style:italic">b</span><sub>1</sub><span style="font-style:italic">x</span>+<span style="font-style:italic">a</span><sub>0</sub>=<span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)</td></tr>
</table>
ce qui nécessite <span style="font-style:italic">n</span> multiplications et <span style="font-style:italic">n</span> additions, donc une
complexité <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span>) (sur un corps fini ou un anneau dont les
opérations se font en temps <span style="font-style:italic">O</span>(1)) avec une constante optimale.
Voir aussi l’exercice sur cette méthode et son application au calcul
du développement de Taylor d’un polynôme
dans la section <a href="#sec%3Aexos_algobase">3.11</a>.
Voir aussi la session exemple depuis le menu Exemples, poly, horner.xws.
</li><li class="li-itemize">La puissance rapide et les tests de pseudo-primalité. Il est essentiel d’avoir une
méthode rapide permettant de générer des nombres premiers pour appliquer
des méthodes modulaires et <span style="font-style:italic">p</span>-adiques. On utilise souvent le
<span style="font-weight:bold">test de Miller-Rabin</span><a id="hevea_default36"></a><a id="hevea_default37"></a>, qui prolonge le petit théorème de Fermat
(si <span style="font-style:italic">p</span> est premier, alors <span style="font-style:italic">a</span><sup><span style="font-style:italic">p</span></sup>=<span style="font-style:italic">a</span> (mod <span style="font-style:italic">p</span> )). Voir le manuel de
programmation de Xcas.
</li></ul>
<!--TOC subsubsection id="sec33" Exemple de multiplication rapide : l’algorithme de Karatsuba-->
<h4 id="sec33" class="subsubsection">3.9.1  Exemple de multiplication rapide : l’algorithme de Karatsuba</h4><!--SEC END --><p><a id="hevea_default38"></a>
Soient <span style="font-style:italic">P</span>, <span style="font-style:italic">Q</span> deux polynômes de degrés strictement inférieur à
2<span style="font-style:italic">n</span>. On suppose que le cout d’une opération arithmétique dans le
corps des coefficients vaut 1 et on néglige les autres
opérations (on suppose par exemple que le corps des coefficients
est un corps fini). On écrit
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>=<span style="font-style:italic">A</span>+<span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">B</span>,    <span style="font-style:italic">Q</span>=<span style="font-style:italic">C</span>+<span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">D</span></td></tr>
</table><p>
avec <span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>,<span style="font-style:italic">C</span>,<span style="font-style:italic">D</span> de degrés strictement inférieur à <span style="font-style:italic">n</span>, on a
alors :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span> <span style="font-style:italic">Q</span> = <span style="font-style:italic">AC</span> + <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup>(<span style="font-style:italic">AD</span>+<span style="font-style:italic">BC</span>)+<span style="font-style:italic">x</span><sup>2<span style="font-style:italic">n</span></sup> <span style="font-style:italic">BD</span></td></tr>
</table><p>
Il y a 4 produits de polynômes de degrés &lt;<span style="font-style:italic">n</span>, mais au prix
d’additions intermédiaires, on peut se ramener à 3 produits, en
effet
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">A</span>+<span style="font-style:italic">B</span>)(<span style="font-style:italic">C</span>+<span style="font-style:italic">D</span>)−<span style="font-style:italic">AC</span>−<span style="font-style:italic">BD</span> = <span style="font-style:italic">AD</span>+<span style="font-style:italic">BC</span></td></tr>
</table><p>
donc pour calculer le cofacteur de <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup> il suffit de soustraire
à (<span style="font-style:italic">A</span>+<span style="font-style:italic">B</span>)(<span style="font-style:italic">C</span>+<span style="font-style:italic">D</span>) les produits <span style="font-style:italic">AC</span> et <span style="font-style:italic">BD</span> que l’on calcule par
ailleurs.
Soit <span style="font-style:italic">M</span>(<span style="font-style:italic">n</span>) le temps nécessaire pour calculer le produit de 2
polynômes par cette méthode, on a alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">M</span>(2<span style="font-style:italic">n</span>) = 3<span style="font-style:italic">M</span>(<span style="font-style:italic">n</span>)+ 8<span style="font-style:italic">n</span></td></tr>
</table><p>
où 8<span style="font-style:italic">n</span> représente le nombre d’additions ou de soustractions
pour former <span style="font-style:italic">A</span>+<span style="font-style:italic">B</span>, <span style="font-style:italic">C</span>+<span style="font-style:italic">D</span>, soustraire <span style="font-style:italic">AC</span> et <span style="font-style:italic">BD</span>, et tenir compte
des "retenues" (les termes de degré ≥ <span style="font-style:italic">n</span> de <span style="font-style:italic">AC</span> se combinent
avec ceux de degré &lt;2<span style="font-style:italic">n</span> de <span style="font-style:italic">AD</span>+<span style="font-style:italic">BC</span> et les termes de degré &lt; 3<span style="font-style:italic">n</span>
de <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">n</span></sup><span style="font-style:italic">BD</span> avec ceux de degré ≥ 2<span style="font-style:italic">n</span> de <span style="font-style:italic">AD</span>+<span style="font-style:italic">BC</span>).
On en déduit
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">M</span>(2<sup><span style="font-style:italic">n</span></sup>),    <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>=3<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>+8 × 2<sup><span style="font-style:italic">n</span></sup> </td></tr>
</table><p> 
cette récurrence se résoud facilement par la commande<br>
<code>rsolve(u(n+1)=3*u(n)+8*2^n,u(n),u(0)=1)</code><br>
qui donne <span style="font-style:italic">M</span>(2<sup><span style="font-style:italic">n</span></sup>)=<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>=−8· 2<sup><span style="font-style:italic">n</span></sup>+9· 3<sup><span style="font-style:italic">n</span></sup>.</p><p>Asymptotiquement, <span style="font-style:italic">M</span>(2<sup><span style="font-style:italic">n</span></sup>) ≈ 9· 3<sup><span style="font-style:italic">n</span></sup> ce qui est bien
meilleur que la multiplication naive en 2 · 4<sup><span style="font-style:italic">n</span></sup>, mais pour de
petites valeurs de <span style="font-style:italic">n</span>, la multiplication naive est plus rapide, on
utilise Karatsuba (récursivement) uniquement pour des valeurs de <span style="font-style:italic">n</span>
suffisamment grandes (théoriquement lorsque 8<span style="font-style:italic">n</span>, le surcout dû
aux additions est plus petit que la multiplication économisée,
soit 8<span style="font-style:italic">n</span>&lt;2<span style="font-style:italic">n</span><sup>2</sup> soit <span style="font-style:italic">n</span>&gt;4, en pratique plutôt pour <span style="font-style:italic">n</span> de l’ordre de quelques
dizaines selon les implémentations, car nous n’avons tenu compte
que des opérations arithmétiques).</p>
<!--TOC subsubsection id="sec34" Calcul de la racine carrée entière-->
<h4 id="sec34" class="subsubsection">3.9.2  Calcul de la racine carrée entière</h4><!--SEC END --><p>
Étant donné un entier <span style="font-style:italic">N</span>, il s’agit de déterminer le plus grand
entier <span style="font-style:italic">n</span> tel que <span style="font-style:italic">n</span><sup>2</sup>≤ <span style="font-style:italic">N</span>, <span style="font-style:italic">n</span> est la racine
carrée<a id="hevea_default39"></a> de <span style="font-style:italic">N</span>.
On choisit une base <span style="font-style:italic">b</span> par exemple <span style="font-style:italic">b</span>=10 pour un humain ou une
puissance de 2 pour une machine, et on écrit <span style="font-style:italic">N</span> en base <span style="font-style:italic">b</span>, en
découpant les chiffres par blocs de 2 en commençant par la
droite, par exemple 2 00 00 00. On initialise la racine carrée <span style="font-style:italic">n</span> à 0
et son carré <span style="font-style:italic">c</span> à 0, on va calculer la racine carrée entière bloc par bloc en
commençant par la gauche. Pour calculer le bloc suivant, on
multiplie <span style="font-style:italic">n</span> par <span style="font-style:italic">b</span> et <span style="font-style:italic">c</span> par <span style="font-style:italic">b</span><sup>2</sup> (c’est un simple décalage de
l’écriture en ajoutant un ou deux zéros). Puis on ajoute les
nombres impairs successifs 2<span style="font-style:italic">n</span>+1, (2<span style="font-style:italic">n</span>+1)+2, ... à <span style="font-style:italic">c</span> tant que l’on est
inférieur à <span style="font-style:italic">N</span> tronqué au bloc. Le nombre d’impairs successifs
ajouté est ajouté à <span style="font-style:italic">n</span>. En pratique, il suffit de conserver
<span style="font-style:italic">N</span>−<span style="font-style:italic">c</span> tronqué et de lui retrancher les impairs successifs.</p><p>Ainsi, pour 2 00 00 00, au 1er bloc 2, on initialise <span style="font-style:italic">n</span>=<span style="font-style:italic">c</span>=0, on
ajoute 2<span style="font-style:italic">n</span>+1=1 à <span style="font-style:italic">c</span> qui vaut alors 1 et on s’arrête car 1+3
est supérieur à 2. On passe au 2ième bloc, <span style="font-style:italic">N</span>−<span style="font-style:italic">c</span> tronqué vaut
100, <span style="font-style:italic">n</span> vaut 10, 2<span style="font-style:italic">n</span>+1 vaut 21, on retranche donc à 100
successivement 21, 23, 25, 27 et on s’arrête car le reste est
4. Donc <span style="font-style:italic">n</span> devient 14, et <span style="font-style:italic">N</span>−<span style="font-style:italic">c</span>=4. On passe au troisième bloc,
<span style="font-style:italic">N</span>−<span style="font-style:italic">c</span>=400 et <span style="font-style:italic">n</span>=140 donc 2<span style="font-style:italic">n</span>+1=281, on retranche de 400 les impairs
successifs à partir de 281, ce qui n’est possible qu’une seule fois,
cela donne <span style="font-style:italic">N</span>−<span style="font-style:italic">c</span>=119 et <span style="font-style:italic">n</span>=141. On passe au dernier bloc,
<span style="font-style:italic">N</span>−<span style="font-style:italic">c</span>=11900 et <span style="font-style:italic">n</span>=1410 donc 2<span style="font-style:italic">n</span>+1=2821, on soustrait
2821, 2823, 2825, 2827 de 11900, il reste 604 et <span style="font-style:italic">n</span>=1414.</p><p>Exercice : calculer la quatrième décimale de √<span style="text-decoration:overline">2</span> de cette
manière.</p><p>La complexité de cet algorithme est en <span style="font-style:italic">O</span>(log<sub><span style="font-style:italic">b</span></sub>(<span style="font-style:italic">N</span>)<sup>2</sup>). En effet,
pour calculer un chiffre il faut faire un nombre de soustraction au
plus égal à <span style="font-style:italic">b</span>, ces soustractions ayant au plus le nombre de
chiffres de <span style="font-style:italic">N</span> en base <span style="font-style:italic">b</span>.
(On peut accélérer le calcul à la manière de Karatsuba en
choisissant une base <span style="font-style:italic">b</span> puissance de 2 (ou 10) de l’ordre de
√<span style="text-decoration:overline"><span style="font-style:italic">N</span></span> et en divisant pour régner).</p><pre class="verbatim">isqrt(x):={
  local l,j,k,s,n,N,res;
  l:=revlist(convert(x,base,100));
  res:=seq(0,size(l));
  s:=0;
  N:=0;
  pour k de 0 jusque size(l)-1 faire
    N := (N-s)*100+l[k];
    n:=2*horner(res[0..k],10)+1;
    s:=n; // ajout de la somme des impairs consecutifs
    pour j de 0 jusque 10 faire
      si s&gt;N alors break; fsi;
      n+=2;
      s+=n;
    fpour;
    s -= n;
    res[k]:=j;
  fpour;
  retourne horner(res,10);
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;t.value=tmp;tmp=UI.caseval(tmp);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML);field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>


<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">isqrt(2*10^8)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p>
<!--TOC subsubsection id="sec35" Bezout sur les entiers et les fractions continues-->
<h4 id="sec35" class="subsubsection">3.9.3  Bezout sur les entiers et les fractions continues</h4><!--SEC END --><p>
Il existe une variante de l’identité de Bézout présentée
ci-dessus pour les entiers. Soient <span style="font-style:italic">a</span>≥ <span style="font-style:italic">b</span>&gt;0 deux entiers, on pose
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">L</span><sub><span style="font-style:italic">n</span></sub>)    <span style="font-style:italic">a</span> <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> − <span style="font-style:italic">b</span> <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> = (−1)<sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">r</span><sub><span style="font-style:italic">n</span></sub> </td></tr>
</table><p> 
où <span style="font-style:italic">r</span><sub>0</sub>=<span style="font-style:italic">a</span>, <span style="font-style:italic">r</span><sub>1</sub>=<span style="font-style:italic">b</span> et <span style="font-style:italic">r</span><sub><span style="font-style:italic">n</span>+2</sub> est le reste de la division
euclidienne de <span style="font-style:italic">r</span><sub><span style="font-style:italic">n</span></sub> par <span style="font-style:italic">r</span><sub><span style="font-style:italic">n</span>+1</sub> (<span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>+2</sub> le quotient), <span style="font-style:italic">u</span><sub>0</sub>=1, <span style="font-style:italic">u</span><sub>1</sub>=0, <span style="font-style:italic">v</span><sub>0</sub>=0,<span style="font-style:italic">v</span><sub>1</sub>=1.
Comme précedemment, chaque ligne s’obtient par combinaison
linéaire des deux précédentes, mais cette fois avec une addition
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">L</span><sub><span style="font-style:italic">n</span>+2</sub>=<span style="font-style:italic">L</span><sub><span style="font-style:italic">n</span></sub>+<span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>+2</sub> <span style="font-style:italic">L</span><sub><span style="font-style:italic">n</span>+1</sub></td></tr>
</table><p> 
ce qui se traduit par :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+2</sub>=<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>+<span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>+2</sub> <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>,    <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+2</sub>=<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>+<span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>+2</sub> <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub></td></tr>
</table><p>
Les suites <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> et <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> sont alors strictement croissantes (à
partir du rang 1 pour <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>). Au rang <span style="font-style:italic">k</span> du dernier reste non nul on
a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span> <span style="font-style:italic">u</span><sub><span style="font-style:italic">k</span></sub> − <span style="font-style:italic">b</span> <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> = (−1)<sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub>,    <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">d</span>=gcd(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>)</td></tr>
</table><p>
et au rang suivant :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">au</span><sub><span style="font-style:italic">k</span>+1</sub> −<span style="font-style:italic">b</span> <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub>=0</td></tr>
</table><p>
On montre par récurrence que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">r</span><sub><span style="font-style:italic">n</span>+1</sub> + <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub> <span style="font-style:italic">r</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">a</span></td></tr>
</table><p>
et une relation analogue pour <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>, on en déduit alors que
<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">a</span>/<span style="font-style:italic">d</span> et <span style="font-style:italic">u</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">b</span>/<span style="font-style:italic">d</span> (ce sont les cofacteurs du PPCM de <span style="font-style:italic">a</span>
et <span style="font-style:italic">b</span>), 
en particulier les coefficients de
Bézout vérifient <span style="font-style:italic">u</span><sub><span style="font-style:italic">k</span></sub>&lt;<span style="font-style:italic">b</span> et <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>&lt;<span style="font-style:italic">a</span>.</p><p>On va aussi voir que <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+2</sub>/<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+2</sub> est la <span style="font-style:italic">n</span>-ième réduite du
développement
en fractions continues de <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span> (donc les coefficients de Bézout
se lisent sur l’avant-dernière réduite). On introduit la notation
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">[<span style="font-style:italic">a</span><sub>0</sub>,<span style="font-style:italic">a</span><sub>1</sub>,..,<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>] =<span style="font-style:italic">a</span><sub>0</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub>1</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub>2</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">...</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
pour <span style="font-style:italic">a</span><sub>0</sub> ≥ 0, <span style="font-style:italic">a</span><sub>1</sub>&gt;0, ..., <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>&gt;0.
On a alors :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span></td></tr>
</table></td><td class="dcell">=[<span style="font-style:italic">q</span><sub>2</sub>,<span style="font-style:italic">q</span><sub>3</sub>,..,<span style="font-style:italic">q</span><sub><span style="font-style:italic">k</span></sub>]</td></tr>
</table><p>
En effet :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span></td></tr>
</table></td><td class="dcell">= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span><sub>0</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span><sub>1</sub></td></tr>
</table></td><td class="dcell">=<span style="font-style:italic">q</span><sub>2</sub> +</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span><sub>2</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span><sub>1</sub></td></tr>
</table></td><td class="dcell"> = <span style="font-style:italic">q</span><sub>2</sub> +
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span><sub>1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span><sub>2</sub></td></tr>
</table></td></tr>
</table></td><td class="dcell"> = ...</td></tr>
</table><p>
D’autre part, on montre par récurrence sur <span style="font-style:italic">n</span>≥ 1 que si <span style="font-style:italic">x</span>&gt;0
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">[<span style="font-style:italic">q</span><sub>2</sub>,..., <span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">x</span>]=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">x</span>+<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>−1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">x</span>+<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>−1</sub></td></tr>
</table></td></tr>
</table><p>
en effet au rang <span style="font-style:italic">n</span>=1
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">[<span style="font-style:italic">x</span>]=<span style="font-style:italic">x</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub>1</sub> <span style="font-style:italic">x</span> + <span style="font-style:italic">v</span><sub>0</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub>1</sub> <span style="font-style:italic">x</span>+<span style="font-style:italic">u</span><sub>0</sub> </td></tr>
</table></td></tr>
</table><p>
et pour l’induction :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >  [<span style="font-style:italic">q</span><sub>2</sub>,..., <span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">x</span>]</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">[<span style="font-style:italic">q</span><sub>2</sub>,..., <span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub>,<span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span></sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell">] </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>−1</sub>(<span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span></sub>+1/<span style="font-style:italic">x</span>)+<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>−2</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>−1</sub>(<span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span></sub>+1/<span style="font-style:italic">x</span>)+<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>−2</sub></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>−1</sub><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span></sub>+<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>−2</sub>)+<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>−1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>−1</sub><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span></sub>+<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>−2</sub>)+<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>−1</sub></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">x</span>+<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>−1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">x</span>+<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>−1</sub></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Donc au rang <span style="font-style:italic">n</span>−1 et pour <span style="font-style:italic">x</span>=<span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span></sub>, on obtient 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">[<span style="font-style:italic">q</span><sub>2</sub>,..., <span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span></sub>]=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub></td></tr>
</table></td></tr>
</table><p>Les <span style="font-weight:bold">fractions continues</span><a id="hevea_default40"></a> <a id="hevea_default41"></a>
servent bien entendu aussi et d’abord à approcher les
réels par des rationnels.
L’algorithme de calcul des termes du développement est le suivant :
Soit <span style="font-style:italic">x</span>≥0. On initialise <span style="font-style:italic">y</span>=<span style="font-style:italic">x</span> et la liste des <span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub> à vide. 
Puis on fait une boucle : on ajoute la partie entière de <span style="font-style:italic">y</span> à la
liste, on calcule la partie fractionnaire de <span style="font-style:italic">y</span>, si elle est nulle on
s’arrête (dans ce cas <span style="font-style:italic">x</span>∈ ℚ),
sinon on stocke dans <span style="font-style:italic">y</span> l’inverse de cette partie fractionnaire et on recommence.
On note classiquement :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">


     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">h</span><sub>−2</sub>=0,</td><td style="text-align:center;white-space:nowrap" > <span style="font-style:italic">h</span><sub>−1</sub>=1,</td><td style="text-align:left;white-space:nowrap" > <span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span></sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub> <span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span>−1</sub>+<span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span>−2</sub></td><td style="text-align:right;white-space:nowrap" >    (1)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">k</span><sub>−2</sub>=1,</td><td style="text-align:center;white-space:nowrap" > <span style="font-style:italic">k</span><sub>−1</sub>=0,</td><td style="text-align:left;white-space:nowrap" > <span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span></sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub> <span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span>−1</sub>+<span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span>−2</sub>
</td><td style="text-align:right;white-space:nowrap" >    (2)</td></tr>
</table></td></tr>
</table><p>
On a <span style="font-style:italic">h</span><sub>0</sub>=<span style="font-style:italic">a</span><sub>0</sub>, <span style="font-style:italic">h</span><sub>1</sub>=<span style="font-style:italic">a</span><sub>1</sub> <span style="font-style:italic">a</span><sub>0</sub>+1, <span style="font-style:italic">k</span><sub>0</sub>=1, <span style="font-style:italic">k</span><sub>1</sub>=<span style="font-style:italic">a</span><sub>1</sub>.
Les suites <span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span></sub> et <span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span></sub> sont donc positives et strictement croissantes pour <span style="font-style:italic">p</span>
≥ 1, puisque pour <span style="font-style:italic">p</span> ≥ 1, <span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>≥ 1, elles tendent vers
l’infini au moins aussi vite que des suites de Fibonacci (à vitesse
au moins géométrique donc).
On a aussi aisément par récurrence :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:fraccon"></a>
<span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span></sub> <span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span>−1</sub> − <span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span>−1</sub><span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span></sub>=(−1)<sup><span style="font-style:italic">p</span>+1</sup>
    (3)</td></tr>
</table><p>
On montre aussi comme ci-dessus :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">[<span style="font-style:italic">a</span><sub>0</sub>,...,<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>−1</sub>,<span style="font-style:italic">y</span>]=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">yh</span><sub><span style="font-style:italic">p</span>−1</sub>+<span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span>−2</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">yk</span><sub><span style="font-style:italic">p</span>−1</sub>+<span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span>−2</sub></td></tr>
</table></td></tr>
</table><p>
On définit <span style="font-style:italic">x</span><sub><span style="font-style:italic">p</span></sub> par <span style="font-style:italic">x</span>=[<span style="font-style:italic">a</span><sub>0</sub>,...,<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span>−1</sub>,<span style="font-style:italic">x</span><sub><span style="font-style:italic">p</span></sub>], en faisant <span style="font-style:italic">y</span>=<span style="font-style:italic">x</span><sub><span style="font-style:italic">p</span></sub>
on a alors <span style="font-style:italic">x</span>=<span style="font-style:italic">x</span><sub><span style="font-style:italic">p</span></sub><span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span>−1</sub>+<span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span>−2</sub>/<span style="font-style:italic">x</span><sub><span style="font-style:italic">p</span></sub> <span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span>−1</sub>+<span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span>−2</sub> ce qui
donne <span style="font-style:italic">x</span><sub><span style="font-style:italic">p</span></sub> en fonction de <span style="font-style:italic">x</span> et
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>=floor</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">− </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">xk</span><sub><span style="font-style:italic">p</span>−2</sub>−<span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span>−2</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">xk</span><sub><span style="font-style:italic">p</span>−1</sub>−<span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span>−1</sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
En faisant <span style="font-style:italic">y</span>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub> on obtient [<span style="font-style:italic">a</span><sub>0</sub>,...,<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>]=<span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span></sub>/<span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span></sub>.
On montre ensuite que les suites (<span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span></sub>/<span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span></sub>) pour les indices pairs et impairs sont deux
suites adjacentes qui convergent vers <span style="font-style:italic">x</span>, et on a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:fraccon1"></a>
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span></sub></td></tr>
</table></td><td class="dcell"> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span>−1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span>−1</sub></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(−1)<sup><span style="font-style:italic">p</span>−1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span></sub>
<span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span>−1</sub></td></tr>
</table></td><td class="dcell">
    (4)</td></tr>
</table><p>
En effet, la dernière égalité est une conséquence immédiate
de (<a href="#eq%3Afraccon">3</a>), la croissance ou décroissance des suites
d’indice pair ou impair s’en déduit en ajoutant (<a href="#eq%3Afraccon1">4</a>) au cran
suivant. La convergence vient de la
limite infinie de <span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span></sub> en l’infini.
On a donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>=<span style="font-style:italic">a</span><sub>0</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span>=0</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(−1)<sup><span style="font-style:italic">p</span>−1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span></sub> <span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span>+1</sub></td></tr>
</table></td><td class="dcell">, 
   </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span></sub>+<span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span>+1</sub>)</td></tr>
</table></td><td class="dcell"> ≤ |<span style="font-style:italic">x</span>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span><sub><span style="font-style:italic">p</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span></sub></td></tr>
</table></td><td class="dcell">| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span></sub>
<span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span>+1</sub></td></tr>
</table></td></tr>
</table><p>
La convergence est d’autant plus rapide que les <span style="font-style:italic">k</span><sub><span style="font-style:italic">p</span></sub> tendent
rapidement vers l’infini, donc si les <span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub> sont plus grands que 1.
La convergence la plus lente correspond au cas où tous les <span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub>=1
cas du nombre d’or, ou à partir d’un certain rang (nombre de <span style="font-style:italic">Q</span>[√<span style="text-decoration:overline">5</span>]).</p>
<!--TOC subsubsection id="sec36" La puissance rapide itérative-->
<h4 id="sec36" class="subsubsection">3.9.4  La puissance rapide itérative</h4><!--SEC END --><p><a id="hevea_default42"></a><a id="hevea_default43"></a>
Pour calculer <span style="font-style:italic">a</span><sup><span style="font-style:italic">k</span></sup> (mod <span style="font-style:italic">n</span> ), on décompose <span style="font-style:italic">k</span> en base 2
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">k</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">J</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">k</span><sub><span style="font-style:italic">j</span></sub> 2<sup><span style="font-style:italic">j</span></sup>,    <span style="font-style:italic">a</span><sup><span style="font-style:italic">k</span></sup> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">J</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">a</span><sup><span style="font-style:italic">k</span><sub><span style="font-style:italic">j</span></sub> 2<sup><span style="font-style:italic">j</span></sup></sup> 
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>/<span style="font-style:italic">k</span><sub><span style="font-style:italic">j</span></sub> ≠ 0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">a</span><sup>2<sup><span style="font-style:italic">j</span></sup></sup> </td></tr>
</table><p>
On initialise une variable <code>B</code> à 1, <code>B</code> vaudra <span style="font-style:italic">a</span><sup><span style="font-style:italic">k</span></sup> (mod <span style="font-style:italic">n</span> ) en fin de calcul, on initialise une variable <code>k</code> à <span style="font-style:italic">k</span>.
On calcule dans une boucle les carrés successifs de <span style="font-style:italic">a</span>
(mod <span style="font-style:italic">n</span> ) que l’on stocke dans une variable <code>A</code> (<code>A</code> 
vaudra donc successivement <span style="font-style:italic">a</span> (mod <span style="font-style:italic">n</span> ), <span style="font-style:italic">a</span><sup>2</sup> (mod <span style="font-style:italic">n</span> ), <span style="font-style:italic">a</span><sup>4</sup> (mod <span style="font-style:italic">n</span> ),
...) et simultanément on teste si <span style="font-style:italic">k</span><sub><span style="font-style:italic">j</span></sub> vaut 1 en prenant le reste de la
division par 2 de <code>k</code> (dans ce cas on multuplie <code>B</code> par
<code>A</code> modulo <span style="font-style:italic">n</span>), on divise ensuite <code>k</code> par 2 au sens du quotient
euclidien.

</p><pre class="verbatim">rapide(a,k,n):={
  local A,B;
  A:=a; B:=1;
  tantque k!=0 faire
    si irem(k,2)==1 alors B:=irem(A*B,n); fsi;
    k:=iquo(k,2);
    A:=irem(A*A,n);
  ftantque;
  return B;
}
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;t.value=tmp;tmp=UI.caseval(tmp);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML);field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>


<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">rapide(123,4567890,123456)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
En mode pas à pas :<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">debug(rapide(123,4567890,123456))
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>

</p>
<!--TOC subsection id="sec37" Pour en savoir plus.-->
<h3 id="sec37" class="subsection">3.10  Pour en savoir plus.</h3><!--SEC END --><p>
Sur des aspects plus théoriques :
</p><ul class="itemize"><li class="li-itemize">
Knuth: TAOCP (The Art of Computer Programming), volumes 1 et suivants
</li><li class="li-itemize">Henri Cohen: A Course in Computational Algebraic Number Theory
</li><li class="li-itemize">Davenport, Siret, Tournier: Calcul formel: Systèmes et algorithmes 
de manipulations algébriques
</li></ul><p>Sur des aspects plus pratiques, quelques références en ligne, 
la plupart sont accessibles gratuitement :
</p><ul class="itemize"><li class="li-itemize">
le code source de Giac disponible à l’URL :<br>
<code>http://www-fourier.ujf-grenoble.fr/~parisse/giac.html</code>
</li><li class="li-itemize">en Maple, il est possible de
décompiler une instruction <code>Maple</code> avec la commande<br>
<code>eval(instruction);</code><br>
après avoir tapé<br>
<code>interface(verboseproc=2);</code>
</li><li class="li-itemize">le source du plus ancien système de calcul formel <code>maxima</code>
(devenu logiciel libre) pour les personnes familières du langage Lisp<br>
<code>http://sourceforge.net/projects/maxima</code><br>
de même pour le système Axiom
</li><li class="li-itemize">le source de librairies plus spécialisées (GMP, MPFR, MPFI, GP-PARI, Singular,
NTL, GAP, CoCoA, ...), rechercher ces mots-clefs sur un moteur de recherche.
</li></ul>
<!--TOC subsection id="sec38" Exercices sur types, calcul exact et approché, 
algorithmes de bases-->
<h3 id="sec38" class="subsection">3.11  Exercices sur types, calcul exact et approché, 
algorithmes de bases</h3><!--SEC END --><p> <a id="sec:exos_algobase"></a>
Vous pouvez 

<a href="http://www-fourier.ujf-grenoble.fr/~parisse/xcasfr.html" target="_blank">tester directement dans votre navigateur</a>
Pour télécharger et installer Xcas sur votre ordinateur, suivre
les instructions données sur<br>
<code>http://www-fourier.ujf-grenoble.fr/~parisse/giac_fr.html</code><br>
Pour lancer <span style="font-family:monospace">xcas</span> sous linux, cherchez Xcas dans le menu
Education ou ouvrir un fenêtre terminal et
taper la commande<br>
<code>  xcas &amp; </code><br>
Lors de la première exécution, vous devrez choisir entre
différents types de syntaxe (compatible C, maple ou TI89). Vous
pouvez changer ce choix à tout moment en utilisant le menu
Configuration-&gt;mode (syntaxe). On vous propose aussi d’ouvrir le
tutoriel, qui est également accessible depuis le menu Aide,
Débuter en calcul formel.</p><p>L’aide en ligne est accessible en tapant <code>?nom_de_commande</code>.
Dans Xcas, vous pouvez aussi taper le début d’un
nom de commande puis la touche de tabulation (à gauche du A sur
un clavier francais), sélectionner la commande dans la boite
de dialogues puis cliquer sur Details pour avoir une aide plus
complète dans votre navigateur. Pour plus de détails sur
l’interface de Xcas, consultez le manuel (Aide-&gt;Interface).
Si vous n’avez jamais utilisé de logiciel de calcul formel,
vous pouvez commencer par lire le tutoriel (menu Aide-&gt;Debuter en
calcul formel-&gt;tutoriel) et faire certains des exercices 
proposés (des corrigés sous forme de sessions Xcas sont 
dans Aide-&gt;Debuter en calcul formel-&gt;solutions)</p><p>Il peut être interessant de tester ces exercices
en parallèle avec Xcas et des calculatrices
formelles....</p><ol class="enumerate" type=1><li class="li-enumerate">
À quelle vitesse votre logiciel multiplie-t-il des
grands entiers (en fonction du nombre de chiffres)? 
On pourra tester le temps de calcul du produit
de <span style="font-style:italic">a</span>(<span style="font-style:italic">a</span>+1) où <span style="font-style:italic">a</span>=10 000!, <span style="font-style:italic">a</span>=15000!, etc. .
Même question pour des polynômes en une variable (à générer
par exemple avec <code>symb2poly(randpoly(n))</code> ou avec <code>poly1[op(ranm(.))]</code>).

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">n:=100; p:=symb2poly(randpoly(n)):; time(p*p);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Comparer le temps de calcul de <span style="font-style:italic">a</span><sup><span style="font-style:italic">n</span></sup> (mod <span style="font-style:italic">m</span> ) par la fonction
<code>powmod</code> et la méthode prendre le reste modulo <span style="font-style:italic">m</span> après avoir 
calculé <span style="font-style:italic">a</span><sup><span style="font-style:italic">n</span></sup>.<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-style:large">a:=123; n:=456; m:=789; time(powmod(a,n,m)); time(irem(a^n,m));
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

Programmez la méthode rapide et la méthode lente.
Refaites la
comparaison. Pour la méthode rapide, programmer aussi la version
itérative utilisant la décomposition en base 2 de l’exposant :
on stocke dans une variable locale <span style="font-style:italic">b</span> les puissances successives
<span style="font-style:italic">a</span><sup>2<sup>0</sup></sup> (mod <span style="font-style:italic">m</span> ),<span style="font-style:italic">a</span><sup>2<sup>1</sup></sup> (mod <span style="font-style:italic">m</span> ), ..., <span style="font-style:italic">a</span><sup>2<sup><span style="font-style:italic">k</span></sup></sup> (mod <span style="font-style:italic">m</span> ), ...,
on forme <span style="font-style:italic">a</span><sup><span style="font-style:italic">n</span></sup> (mod <span style="font-style:italic">n</span> ) en prenant le produit modulo <span style="font-style:italic">m</span> de ces puissances
successives lorsque le bit correspondant est à 1 (ce qui se
détecte par le reste de divisions euclidiennes sucessives par 2, le
calcul de <span style="font-style:italic">b</span> et du bit correspondant se font dans une même boucle).</li><li class="li-enumerate">Déterminer un entier <span style="font-style:italic">c</span> tel que <span style="font-style:italic">c</span>=1 (mod 3 ), 
<span style="font-style:italic">c</span>=3 (mod 5 ), <span style="font-style:italic">c</span>=5 (mod 7 ) et <span style="font-style:italic">c</span>=2 (mod 11 ).

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">ichinrem()
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Calculez dans ℤ/11ℤ
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">10</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>=0</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">x</span>−<span style="font-style:italic">a</span>)</td></tr>
</table>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">product()
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Algorithmes fondementaux : écrire des programmes implémentant
<ol class="enumerate" type=a><li class="li-enumerate">
le pgcd de 2 entiers
</li><li class="li-enumerate">l’algorithme de Bézout
</li><li class="li-enumerate">l’inverse modulaire en ne calculant que ce qui est nécessaire
dans l’algorithme de Bézout
</li><li class="li-enumerate">les restes chinois
</li></ol></li><li class="li-enumerate">Construire un corps fini de cardinal 128 (<code>GF</code>), puis factoriser
le polynôme <span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">y</span> où <span style="font-style:italic">y</span> est un élément quelconque du corps
fini.
Comparer avec la valeur de √<span style="text-decoration:overline"><span style="font-style:italic">y</span></span>.

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">GF(2,7);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Utiliser la commande <span style="font-family:monospace">type</span> ou <span style="font-family:monospace">whattype</span> ou équivalent
pour déterminer la représentation
utilisée par le logiciel pour représenter
une fraction, un nombre complexe, un flottant en précision machine, 
un flottant avec 100 décimales, la variable <span style="font-style:italic">x</span>, l’expression sin(<span style="font-style:italic">x</span>)+2,
la fonction <span style="font-family:monospace">x-&gt;sin(x)</span>, une liste, une séquence, un vecteur,
une matrice. Essayez d’accéder aux parties de
l’objet pour les objets composites (en utilisant <span style="font-family:monospace">op</span> par exemple).

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">a:=sin(x)+2; type(a); a[0]; a[1]
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Comparer le type de l’objet <code>t</code> si on effectue
la commande <code>t[2]:=0;</code> après avoir purgé <code>t</code>
ou après avoir affecté <code>t:=[1,2,3]</code> ?

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">t[2]:=0; type(t); t:=[1,2,3]; type(t)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Comparer l’effet de l’affectation dans une liste et dans un
vecteur ou une matrice sur votre logiciel (en Xcas, on peut utiliser
<code>=&lt;</code> au lieu de <code>:=</code> pour stocker par référence).

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">l:=[1,2,3]; l1:=l; l[1]:=5; l1
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Voici un programme qui calcule la base utilisée
pour représenter les flottants. 

<pre class="verbatim">Base():={
  local A,B;
  A:=1.0; B:=1.0;
  while evalf(evalf(A+1.0)-A)-1.0=0.0 do  A:=2*A; od;
  while evalf(evalf(A+B)-A)-B&lt;&gt;0 do B:=B+1; od;
  return B;
} :;
</pre> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;t.value=tmp;tmp=UI.caseval(tmp);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML);field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>

Testez-le 
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">Base()
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
 et expliquez.</li><li class="li-enumerate">Déterminer le plus grand réel positif <span style="font-style:italic">x</span> de la forme 
2<sup>−<span style="font-style:italic">n</span></sup> (<span style="font-style:italic">n</span> entier)
tel que (1.0+<span style="font-style:italic">x</span>)−1.0 renvoie 0 sur PC avec la précision par
défaut puis avec <code>Digits:=30</code>.

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">n:=30; x:=2^(-n):; (1.0+x)-1.0
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Calculer la valeur de <span style="font-style:italic">a</span>:=exp(π √<span style="text-decoration:overline">163</span>) avec 30 chiffres
significatifs, puis sa partie fractionnaire. Proposez une commande
permettant de décider si <span style="font-style:italic">a</span> est un entier.

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">a:=exp(pi*sqrt(163));
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Déterminer la valeur et le signe de la fraction rationnelle 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">F</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1335</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">y</span><sup>6</sup> + <span style="font-style:italic">x</span><sup>2</sup> (11<span style="font-style:italic">x</span><sup>2</sup> <span style="font-style:italic">y</span><sup>2</sup>−<span style="font-style:italic">y</span><sup>6</sup> −121<span style="font-style:italic">y</span><sup>4</sup>−2) + 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">11</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">y</span><sup>8</sup> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">y</span></td></tr>
</table></td></tr>
</table>
en <span style="font-style:italic">x</span>=77617 et <span style="font-style:italic">y</span>=33096 en faisant deux calculs, l’un en mode approché et 
l’autre en mode exact. Que pensez-vous de ces résultats?
Combien de chiffres significatifs faut-il pour obtenir un résultat
raisonnable en mode approché?

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:40px;font-style:large">F(x,y):=1335/4*y^6+x^2*(11x^2*y^2-y^6-121*y^4-2)+11/2*y^8+x/2/y;
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>


<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">F();
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Que se passe-t-il si on essaie d’appliquer l’algorithme de la
puissance rapide pour calculer (<span style="font-style:italic">x</span>+<span style="font-style:italic">y</span>+<span style="font-style:italic">z</span>+1)<sup><span style="font-style:italic">k</span></sup> par exemple pour
<span style="font-style:italic">k</span>=64 ? 
Calculer le nombre
de termes dans le développement de (<span style="font-style:italic">x</span>+<span style="font-style:italic">y</span>+<span style="font-style:italic">z</span>+1)<sup><span style="font-style:italic">n</span></sup> et expliquez.

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:40px;font-style:large">time(normal((x+y+z+1)^30)); a:=normal((x+y+z+1)^15):; time(normal(a*a));
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Programmation de la <span style="font-weight:bold">méthode de Horner</span><a id="hevea_default44"></a><br>
Il s’agit d’évaluer efficacement un polynôme 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>) = <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span></sup> + ... + <span style="font-style:italic">a</span><sub>0</sub> </td></tr>
</table>
en un point.
On pose <span style="font-style:italic">b</span><sub>0</sub>=<span style="font-style:italic">P</span>(α ) et on écrit :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>)−<span style="font-style:italic">b</span><sub>0</sub>=(<span style="font-style:italic">X</span>−α )<span style="font-style:italic">Q</span>(<span style="font-style:italic">X</span>) </td></tr>
</table>
où :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Q</span>(<span style="font-style:italic">X</span>) = <span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span>−1</sup> + ... +<span style="font-style:italic">b</span><sub>2</sub> <span style="font-style:italic">X</span> + <span style="font-style:italic">b</span><sub>1</sub> </td></tr>
</table>
On calcule alors par ordre décroissant <span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span></sub>, <span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span>−1</sub>, ..., <span style="font-style:italic">b</span><sub>0</sub>.
<ol class="enumerate" type=a><li class="li-enumerate">
Donner <span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span></sub> en fonction de <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> puis pour <span style="font-style:italic">i</span>≤ <span style="font-style:italic">n</span>−1, <span style="font-style:italic">b</span><sub><span style="font-style:italic">i</span></sub>
en fonction de <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub> et <span style="font-style:italic">b</span><sub><span style="font-style:italic">i</span>+1</sub>. Indiquez le détail des calculs
pour <span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>)=<span style="font-style:italic">X</span><sup>3</sup>−2<span style="font-style:italic">X</span>+5 et une valeur de α  non nulle.
</li><li class="li-enumerate">Écrire un fonction <code>horn</code> effectuant ce calcul:
on donnera en arguments le polynôme sous forme de la
liste de ces coefficients (dans l’exemple <code>[1,0,-2,5]</code>) et la
valeur de α  et le programme renverra <span style="font-style:italic">P</span>(α ).
(On pourra aussi renvoyer les coefficients de <span style="font-style:italic">Q</span>).
</li><li class="li-enumerate">En utilisant cette fonction, écrire une fonction qui calcule
le développement de Taylor complet d’un polynôme en un point.
</li></ol></li></ol>
<!--TOC section id="sec39" Les générateurs de nombres pseudo-aléatoires.-->
<h2 id="sec39" class="section">4  Les générateurs de nombres pseudo-aléatoires.</h2><!--SEC END --><p>
<a id="sec:random"></a>
<a id="hevea_default45"></a>
</p>
<!--TOC subsection id="sec40" Selon la loi uniforme-->
<h3 id="sec40" class="subsection">4.1  Selon la loi uniforme</h3><!--SEC END --><p>
Les générateurs d’entiers dans une plage donnée selon la loi
uniforme servent en général de base pour générer des 
nombres aléatoires entiers ou non selon des lois classiques.
Ils doivent à la fois être rapides, avoir une période égale à
la plage donnée et avoir de bonnes propriétés statistiques.</p><p>Xcas utilise un “tiny” Mersenne Twister (de période environ 2<sup>127</sup>),
certaines implantations de Giac utilisent un générateur congruentiel.</p>
<!--TOC subsubsection id="sec41" Les générateurs congruentiels à 1 cran.-->
<h4 id="sec41" class="subsubsection">4.1.1  Les générateurs congruentiels à 1 cran.</h4><!--SEC END --><p><a id="hevea_default46"></a>
<a id="hevea_default47"></a> 
Etant donnés trois entiers <span style="font-style:italic">a</span>, <span style="font-style:italic">c</span> et <span style="font-style:italic">m</span> on considère la suite
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">au</span><sub><span style="font-style:italic">n</span></sub>+<span style="font-style:italic">c</span> (mod <span style="font-style:italic">m</span> ) </td></tr>
</table><p>
où on choisit (par exemple) comme représentant de <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>
le reste de la division euclidienne par <span style="font-style:italic">m</span>. La valeur de <span style="font-style:italic">u</span><sub>0</sub>
est appelée seed en anglais, elle est initialisée usuellement
soit à 0 (ce qui permet de reproduire des bugs dans un programme
dépendant du hasard), soit avec l’horloge système ou tout autre
entrée de l’ordinateur (par exemple périphériques).</p><p>On supposera que <span style="font-style:italic">a</span>≠ 1, le cas <span style="font-style:italic">a</span>=1 n’est pas très
intéressant. On a alors :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">a</span><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">u</span><sub>0</sub> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sup><span style="font-style:italic">n</span></sup>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>−1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">c</span> (mod <span style="font-style:italic">m</span> )</td></tr>
</table><p>
On cherche à réaliser une période la plus grande possible
idéalement <span style="font-style:italic">m</span>, mais <span style="font-style:italic">m</span>−1 peut fort bien convenir, et c’est
possible si <span style="font-style:italic">m</span> est premier en choisissant 
<span style="font-style:italic">a</span> générateur du groupe cyclique, car on a alors <span style="font-style:italic">a</span>≠ 1 (mod <span style="font-style:italic">m</span> ) et :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">a</span><sup><span style="font-style:italic">n</span></sup> (<span style="font-style:italic">u</span><sub>0</sub> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">c</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>−1</td></tr>
</table></td><td class="dcell">) − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">c</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>−1</td></tr>
</table></td><td class="dcell">  (mod <span style="font-style:italic">m</span> )</td></tr>
</table><p>
donc la suite est stationnaire ou prend toutes les valeurs sauf − <span style="font-style:italic">c</span>/<span style="font-style:italic">a</span>−1 .</p><p>Exemple : choisir pour <span style="font-style:italic">m</span> une puissance de 2 permet d’effectuer
la division euclidienne très rapidement, mais cela a un
inconvénient assez important : les bits de poids faible
de <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> ont une périodicité très (trop) petite.
Il est alors intéressant de prendre <span style="font-style:italic">m</span>=2<sup><span style="font-style:italic">k</span></sup> ± 1, parce
que la division euclidienne par <span style="font-style:italic">m</span> peut se coder efficacement en base
2, on divise par 2<sup><span style="font-style:italic">k</span></sup> (décalage de <span style="font-style:italic">k</span> bits) et on ajuste
<span style="font-style:italic">x</span>=(2<sup><span style="font-style:italic">k</span></sup> ± 1)<span style="font-style:italic">q</span>+<span style="font-style:italic">r</span>=2<sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">q</span> + (<span style="font-style:italic">r</span> ± <span style="font-style:italic">q</span>).
Ainsi pour <span style="font-style:italic">k</span>=4 et <span style="font-style:italic">m</span>=2<sup>4</sup>+1=17, <span style="font-style:italic">m</span> est premier.
On peut construire une suite de période 16 en choisissant <span style="font-style:italic">a</span> générateur
de (ℤ/17ℤ)<sup>*</sup>, par exemple <span style="font-style:italic">a</span>=3 et <span style="font-style:italic">c</span>=2 donne la suite
0,2,8,9,12,4,14,10,15,13,7,6,3,11,1,5.</p><p>On a le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 4</span>  <em>
La suite </em>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)<em> définie ci-dessus est de périodicité maximale </em><span style="font-style:italic">m</span><em> si
et seulement si :
</em><ol class="enumerate" type=1><li class="li-enumerate"><em>
</em><span style="font-style:italic">c</span><em> et </em><span style="font-style:italic">m</span><em> sont premiers entre eux
</em></li><li class="li-enumerate"><span style="font-style:italic">a</span>−1<em> est divisible par tous les facteurs premiers de </em><span style="font-style:italic">m</span><em>
</em></li><li class="li-enumerate"><span style="font-style:italic">a</span>−1<em> est multiple de 4 si </em><span style="font-style:italic">m</span><em> l’est.
</em></li></ol><em>
</em></div><p>
On observe d’abord que vouloir la périodicité maximale revient
à pouvoir supposer que <span style="font-style:italic">u</span><sub>0</sub>=0. 
Il est donc nécessaire d’avoir <span style="font-style:italic">c</span>
et <span style="font-style:italic">m</span> premiers entre eux, sinon tous les <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> sont multiples du
pgcd de <span style="font-style:italic">c</span> et <span style="font-style:italic">m</span>. Ensuite, on pose <span style="font-style:italic">m</span>=∏<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span></sub></sup> la
décomposition en facteurs premiers de <span style="font-style:italic">m</span> et on raisonne modulo
chaque premier (par le lemme chinois, la périodicité
est le PPCM des périodicités modulo chaque <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span></sub></sup>). 
Si <span style="font-style:italic">a</span>≠ 1 (mod <span style="font-style:italic">p</span> )<sub><span style="font-style:italic">i</span></sub>
alors <span style="font-style:italic">a</span>−1 est inversible modulo <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> donc modulo 
<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span></sub></sup> on a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">a</span><sup><span style="font-style:italic">n</span></sup> (<span style="font-style:italic">u</span><sub>0</sub> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">c</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>−1</td></tr>
</table></td><td class="dcell">) + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−<span style="font-style:italic">c</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>−1</td></tr>
</table></td><td class="dcell">  </td></tr>
</table><p>
et la valeur −<span style="font-style:italic">c</span>/(<span style="font-style:italic">a</span>−1) ne peut pas être atteinte
(ou alors la suite est stationnaire).
Donc <span style="font-style:italic">a</span>−1 doit être divisible par tous les facteurs premiers de <span style="font-style:italic">m</span>
pour avoir la périodicité maximale.
Réciproquement, il faut trouver le premier ordre <span style="font-style:italic">n</span> tel que
(<span style="font-style:italic">a</span><sup><span style="font-style:italic">n</span></sup>−1)/(<span style="font-style:italic">a</span>−1)=0 (mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">r</span></sup> ). On pose <span style="font-style:italic">a</span>=<span style="font-style:italic">b</span>+1, on a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sup><span style="font-style:italic">n</span></sup>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>−1</td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">b</span>+1)<sup><span style="font-style:italic">n</span></sup>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell">
</td><td class="dcell">⎛<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎠</td><td class="dcell"><span style="font-style:italic">b</span><sup><span style="font-style:italic">k</span>−1</sup> = <span style="font-style:italic">n</span> +</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>−1)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">b</span> +... </td></tr>
</table><p>
On sait que <span style="font-style:italic">b</span>=<span style="font-style:italic">a</span>−1 est un multiple de <span style="font-style:italic">p</span>, disons <span style="font-style:italic">b</span>=<span style="font-style:italic">qp</span>, on en déduit que
pour <span style="font-style:italic">n</span>=<span style="font-style:italic">p</span><sup><span style="font-style:italic">r</span></sup>, on a bien (<span style="font-style:italic">a</span><sup><span style="font-style:italic">n</span></sup>−1)/(<span style="font-style:italic">a</span>−1)=0 (mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">r</span></sup> ), alors que
pour <span style="font-style:italic">n</span>=<span style="font-style:italic">p</span><sup><span style="font-style:italic">r</span>−1</sup> et <span style="font-style:italic">p</span>≠ 2, (<span style="font-style:italic">a</span><sup><span style="font-style:italic">n</span></sup>−1)/(<span style="font-style:italic">a</span>−1)=<span style="font-style:italic">n</span> (mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">r</span></sup> ) ≠ 0.
Le même calcul pour <span style="font-style:italic">p</span>=2 (prise en compte de la division par 2 de
<span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>−1)) donne la condition <span style="font-style:italic">b</span>=<span style="font-style:italic">a</span>−1 est multiple de 4 si <span style="font-style:italic">m</span> l’est.</p><p>On trouvera dans Knuth une discussion détaillée du choix de <span style="font-style:italic">a</span>, <span style="font-style:italic">b</span>, <span style="font-style:italic">m</span>.</p><p>Exemple : <span style="font-style:italic">m</span>=2<sup>31</sup>−1 est premier, on peut donc construire un
générateur congruentiel de période <span style="font-style:italic">m</span>−1 en choisissant <span style="font-style:italic">a</span>
générateur de ℤ/<span style="font-style:italic">m</span>ℤ<sup>*</sup>. Pour en trouver un, on peut tester
<span style="font-style:italic">a</span> pris au hasard et voir si <span style="font-style:italic">a</span><sup><span style="font-style:italic">m</span>−1/<span style="font-style:italic">j</span></sup> ≠ 1 (mod <span style="font-style:italic">m</span> )
pour tous les diviseurs premiers de <span style="font-style:italic">m</span>−1. Par exemple<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">m:=2^31-1;F:=ifactors(b:=m-1); G:=seq(F[2*j],j,0,iquo(size(F)-1,2)) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">a:=456783546; for k in G do print(powmod(a,b/k,m)); od 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">r():=return (etat:=irem(a*etat,m)); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">etat:=1;
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
 initialise l’état du générateur.
Un appel à <code>r()</code> renvoie un entier entre 1 et <span style="font-style:italic">m</span>−1, pour avoir
un g’enérateur pseudo-aléatoire selon la loi uniforme sur ]0,1[, on tape

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">evalf(r()/m)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
.</p><p>Ainsi <br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">L:=seq(evalf(r()/m),j,1,1000):;histogram(L,0,.05)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

permet de vérifier visuellement si les réels générés sont
bien répartis, ou bien<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">seq(point(evalf(r()/m,r()/m),display=point_point),j,1,1000)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

qui détecte des biais invisibles avec le test précédent, par
exemple pour 

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">a:=7;seq(point(evalf(r()/m,r()/m),display=point_point),j,1,1000)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
.</p>
<!--TOC subsubsection id="sec42" Récurrence à <span style="font-style:italic">k</span> éléments-->
<h4 id="sec42" class="subsubsection">4.1.2  Récurrence à <span style="font-style:italic">k</span> éléments</h4><!--SEC END --><p>
Au lieu d’une récurrence <span style="font-style:italic">u</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">au</span><sub><span style="font-style:italic">k</span></sub>+<span style="font-style:italic">c</span> on conserve en mémoire
<span style="font-style:italic">k</span>+1 valeurs successives de la suite et on calcule
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+<span style="font-style:italic">k</span>+1</sub> = <span style="font-style:italic">a</span><sub>0</sub> <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>+...+<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+<span style="font-style:italic">k</span></sub> (mod <span style="font-style:italic">p</span> )</td></tr>
</table><p>
Si on note <span style="font-style:italic">U</span><sub><span style="font-style:italic">n</span></sub> le vecteur (<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>,...,<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+<span style="font-style:italic">k</span></sub>) et <span style="font-style:italic">A</span>
la matrice companion du polynôme <span style="font-style:italic">a</span><sub>0</sub>+<span style="font-style:italic">a</span><sub>1</sub><span style="font-style:italic">x</span>+...+<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup>,
on a <span style="font-style:italic">U</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">AU</span><sub><span style="font-style:italic">n</span></sub>. Rechercher un générateur de période
maximale revient à chercher <span style="font-style:italic">A</span> d’ordre le plus grand possible, donc
les valeurs propres de <span style="font-style:italic">A</span>, i.e. les racines de <span style="font-style:italic">P</span>, doivent être
racines de l’unité d’ordre le plus grand possible donc <span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup>−1. 
Ce que l’on peut faire en construire un polynôme <span style="font-style:italic">P</span> irréductible
primitif (cf. la section <a href="#sec%3Agf">16</a> sur la construction de représentation
des corps finis).</p>
<!--TOC subsubsection id="sec43" Mersenne twister.-->
<h4 id="sec43" class="subsubsection">4.1.3  Mersenne twister.</h4><!--SEC END --><p>
Ce sont des générateurs plus performants, avec un état interne
en général plus grand, dont l’état initial est généré par
un générateur congruentiel. Ils utilisent une relation
de récurrence qui ressemble aux générateurs
congruentiels, mais au lieu de travailler sur de grands
entiers, on découpe l’entier en mots de taille gérée
par le CPU, et on fait des opérations de type matriciels
avec des opérations bit à bit (ou exclusif par exemple)
au lieu d’opérations arithmétiques.</p>
<!--TOC subsection id="sec44" Selon plusieurs lois classiques-->
<h3 id="sec44" class="subsection">4.2  Selon plusieurs lois classiques</h3><!--SEC END --><p>
La méthode générale consiste à calculer la distribution
cumulée de la loi et à prendre la fonction réciproque
d’un réel généré aléatoirement entre 0 et 1 selon
la loi uniforme. Lorsqu’on a un nombre discret de valeurs possibles
pas trop grand et que l’on veut générer plusieurs
nombres selon la même loi, on peut précalculer la distribution cumulée
en chaque valeur, et faire une dichotomie pour trouver
la valeur de la fonction réciproque du nombre aléatoire
généré. Les calculs peuvent être rendus difficiles
par des dépassement de capacité des flottants si on utilise
des méthodes naives pour estimer les fonction de répartition.
On trouvera dans Abramowitz-Stegun diverses formules 
pour initialiser les méthodes de Newton pour inverser les
fonction de répartition courante.</p><p>Il existe aussi quelques cas particuliers où
on peut obtenir plus facilement un réel selon la loi
donnée :
</p><ul class="itemize"><li class="li-itemize">
Pour la loi normale<a id="hevea_default48"></a>, on génère 2 réels <span style="font-style:italic">u</span>,<span style="font-style:italic">d</span>
entre 0 et 1, on calcule <br>
√<span style="text-decoration:overline">−2 </span><span style="text-decoration:overline">log</span><span style="text-decoration:overline">(</span><span style="text-decoration:overline"><span style="font-style:italic">u</span></span><span style="text-decoration:overline">)</span> cos(2π <span style="font-style:italic">d</span>)<br>
En effet si on considère un couple de variables qui
suivent une loi normale centrée réduite, la densité de probabilité
au point (<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) (coordonnées cartésiennes) ou (<span style="font-style:italic">r</span>,θ) est :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2π</td></tr>
</table></td><td class="dcell"><sup>2</sup></td></tr>
</table></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span></td><td class="dcell"><table class="display"><tr><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2</sup>+<span style="font-style:italic">y</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="dcell">&nbsp;</td></tr>
</table></td><td class="dcell">   <span style="font-style:italic">dx</span>   <span style="font-style:italic">dy</span>
=  </td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><span style="font-style:italic">e</span></td><td class="dcell"><table class="display"><tr><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="dcell">&nbsp;</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">r</span>    <span style="font-style:italic">dr</span> </td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell">
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2π</td></tr>
</table></td><td class="dcell">   <span style="font-style:italic">d</span>θ </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
= </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span></td><td class="dcell"><table class="display"><tr><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">s</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="dcell">&nbsp;</td></tr>
</table></td><td class="dcell">   <span style="font-style:italic">ds</span> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2π</td></tr>
</table></td><td class="dcell">   <span style="font-style:italic">d</span>θ </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table>
où <span style="font-style:italic">r</span><sup>2</sup>=<span style="font-style:italic">s</span>. Donc <span style="font-style:italic">s</span> suit une loi exponentielle (générée
par la réciproque de la distribution cumulée) et θ
uniforme, les deux sont indépendantes. On écrit 
alors <span style="font-style:italic">x</span>=<span style="font-style:italic">r</span>cos(θ). On peut pour le même prix
générer <span style="font-style:italic">y</span>=<span style="font-style:italic">r</span>sin(θ). <br>
Pour éviter de calculer
des lignes trigonométriques, on peut aussi tirer
<span style="font-style:italic">x</span> et <span style="font-style:italic">y</span> uniformément dans [−1,1], accepter le tirage
si <span style="font-style:italic">s</span>=<span style="font-style:italic">x</span><sup>2</sup>+<span style="font-style:italic">y</span><sup>2</sup> ∈ ]0,1] et renvoyer deux valeurs
aléatoires selon la loi normale
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span> </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">−2ln(<span style="font-style:italic">s</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">s</span></td></tr>
</table></td></tr>
</table></td><td class="dcell">,    <span style="font-style:italic">y</span> </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">−2ln(<span style="font-style:italic">s</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">s</span></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table>
</li><li class="li-itemize">Pour la loi du χ<sup>2</sup> à <span style="font-style:italic">k</span> degrés de liberté, 
on fait la somme
des carrés de <span style="font-style:italic">k</span> réels aléatoires selon la loi normale
</li><li class="li-itemize">Pour la loi de Student, on fait le quotient d’un réel
selon la loi normale par la racine carrée
d’un réel selon la loi du χ<sup>2</sup> divisé par le nombre
de degré de liberté
</li><li class="li-itemize">Pour la loi de Fisher, on fait le quotient d’un réel
selon la loi du χ<sup>2</sup> en <span style="font-style:italic">k</span><sub>1</sub> degrés de liberté divisé par
<span style="font-style:italic">k</span><sub>1</sub> et d’un réel
selon la loi du χ<sup>2</sup> en <span style="font-style:italic">k</span><sub>2</sub> degrés de liberté divisé par
<span style="font-style:italic">k</span><sub>2</sub>
</li></ul>
<!--TOC section id="sec45" Le PGCD de polynômes.-->
<h2 id="sec45" class="section">5  Le PGCD de polynômes.</h2><!--SEC END --><p> <a id="sec:pgcd"></a> <a id="hevea_default49"></a>
Comme on l’a remarqué dans le premier article, l’algorithme d’Euclide est
inefficace pour calculer le pgcd de deux polynômes à coefficients entiers. On
va présenter ici les algorithmes utilisés habituellement par les systèmes de
calcul formel: sous-résultant (PRS), modulaire (GCDMOD), <span style="font-style:italic">p</span>-adique (EEZGD) et
heuristique (GCDHEU). Le premier est une adaptation de l’algorithme d’Euclide
et s’adapte à des coefficients assez génériques. Les trois autres ont en
commun d’évaluer une ou plusieurs variables du polynôme (dans ce dernier cas
il est nécessaire de bien distinguer le cas de polynômes à plusieurs
variables) et de reconstruire le pgcd par des techniques distinctes, la
plupart du temps ces algorithmes fonctionnent seulement si les coefficients
sont entiers.</p><p>Soit donc  <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> deux polynômes à coefficients dans un corps. Le
pgcd de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> n’est défini qu’à une constante près. Mais lorsque les
coefficients de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> sont dans un anneau euclidien comme par exemple
ℤ ou
ℤ[ <span style="font-style:italic">i</span> ], on appellera pgcd de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> un polynôme <span style="font-style:italic">D</span> tel
que <span style="font-style:italic">P</span> / <span style="font-style:italic">D</span> et <span style="font-style:italic">Q</span> / <span style="font-style:italic">D</span> soient encore à coefficients dans l’anneau, et que <span style="font-style:italic">D</span>
soit optimal, c’est-à-dire que si un multiple µ <span style="font-style:italic">D</span> de <span style="font-style:italic">D</span> vérifie <span style="font-style:italic">P</span> / µ
<span style="font-style:italic">D</span> et <span style="font-style:italic">Q</span> / µ <span style="font-style:italic">D</span> sont à coefficients dans l’anneau, alors µ est
inversible. </p><p>La première étape d’un algorithme de calcul de pgcd consiste donc
à diviser par son contenu (pgcd des coefficients entiers) chaque polynôme.</p><p><span style="font-weight:bold">Exemple</span>: <span style="font-style:italic">P</span> = 4 <span style="font-style:italic">X</span><sup>2</sup> − 4 et <span style="font-style:italic">Q</span> = 6 <span style="font-style:italic">X</span><sup>2</sup> + 12 <span style="font-style:italic">X</span> + 6. Le polynôme
<span style="font-style:italic">X</span> + 1 est un pgcd de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> puisqu’il est de degré maximal divisant <span style="font-style:italic">P</span>
et <span style="font-style:italic">Q</span> mais le pgcd de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> est 2 ( <span style="font-style:italic">X</span> + 1 ). Remarquons qu’avec notre
définition − 2 ( <span style="font-style:italic">X</span> + 1 ) convient aussi. Par convention on appelera
pgcd dans ℤ[<span style="font-style:italic">X</span>] le
polynôme ayant un coefficient dominant positif.</p><p><span style="font-weight:bold">Définition</span>: On appelle <span style="font-weight:bold">contenu</span><a id="hevea_default50"></a> <span style="font-style:italic">c</span> ( <span style="font-style:italic">P</span> ) d’un polynôme <span style="font-style:italic">P</span> le
pgcd des coefficients de <span style="font-style:italic">P</span>. On définit alors la 
<span style="font-weight:bold">partie primitive</span><a id="hevea_default51"></a> de <span style="font-style:italic">P</span>:
pp( <span style="font-style:italic">P</span> ) = <span style="font-style:italic">P</span> / <span style="font-style:italic">c</span> ( <span style="font-style:italic">P</span> ). Si <span style="font-style:italic">c</span>(<span style="font-style:italic">P</span>)=1, on dit que <span style="font-style:italic">P</span> est primitif.</p><p><span style="font-weight:bold">Proposition </span>: Si <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> sont primitifs alors <span style="font-style:italic">AB</span> est
primitif.<br>
Sinon, on prend un facteur premier <span style="font-style:italic">p</span> du contenu de <span style="font-style:italic">AB</span>, 
<span style="font-style:italic">AB</span>=0 (mod <span style="font-style:italic">p</span> ) donc <span style="font-style:italic">A</span>=0 ou <span style="font-style:italic">B</span>=0 modulo <span style="font-style:italic">p</span>, absurde.</p><p><span style="font-weight:bold">Proposition </span>: le contenu de <span style="font-style:italic">AB</span> est le produit des contenus
de <span style="font-style:italic">A</span> et de <span style="font-style:italic">B</span>.<br>
En effet le produit des contenus de <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> divise le contenu de <span style="font-style:italic">AB</span>,
et <span style="font-style:italic">A</span>/contenu de <span style="font-style:italic">A</span> est primitif, <span style="font-style:italic">B</span>/contenu de <span style="font-style:italic">B</span> est primitif
donc le produit l’est,</p><p><span style="font-weight:bold">Proposition </span>: Si <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> sont primitifs et si <span style="font-style:italic">B</span> divise <span style="font-style:italic">A</span>
dans ℚ[<span style="font-style:italic">X</span>] alors <span style="font-style:italic">A</span>/<span style="font-style:italic">B</span> ∈ ℤ[<span style="font-style:italic">X</span>].</p><p><span style="font-weight:bold">Preuve </span>: Soit <span style="font-style:italic">Q</span>=<span style="font-style:italic">A</span>/<span style="font-style:italic">B</span> ∈ ℚ[<span style="font-style:italic">X</span>]. Soit <span style="font-style:italic">q</span> ∈ ℕ  le PPCM des
dénominateurs des coefficients de <span style="font-style:italic">Q</span> et notons <span style="font-style:italic">P</span>=<span style="font-style:italic">qQ</span> ∈ ℤ[<span style="font-style:italic">X</span>].
On a <span style="font-style:italic">A</span>=<span style="font-style:italic">BQ</span> donc <span style="font-style:italic">qA</span>=<span style="font-style:italic">BP</span> donc le contenu de <span style="font-style:italic">qA</span> est le produit 
du contenu de <span style="font-style:italic">B</span> par celui de <span style="font-style:italic">P</span>, donc le contenu de <span style="font-style:italic">P</span>=<span style="font-style:italic">qQ</span> est <span style="font-style:italic">q</span>,
donc <span style="font-style:italic">Q</span> ∈ ℤ[<span style="font-style:italic">X</span>].</p><p>Donc le PGCD de <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span>, polynômes primitifs de ℤ[<span style="font-style:italic">X</span>] est
obtenu en prenant un PGCD de <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> dans ℚ[<span style="font-style:italic">X</span>], en multipliant
par le PPCM des dénominateurs et en rendant le polynôme obtenu
primitif (on change le signe du résultat si nécessaire pour avoir
un coefficient dominant positif).</p><p>On en déduit que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">D</span> = pgcd ( <span style="font-style:italic">P</span>, <span style="font-style:italic">Q</span> ) = pgcd ( <span style="font-style:italic">c</span> ( <span style="font-style:italic">P</span> ), <span style="font-style:italic">c</span> ( <span style="font-style:italic">Q</span> )) pgcd (
pp ( <span style="font-style:italic">P</span> ), pp ( <span style="font-style:italic">Q</span> )) </td></tr>
</table>
<!--TOC subsection id="sec46" Le sous-résultant.-->
<h3 id="sec46" class="subsection">5.1  Le sous-résultant.</h3><!--SEC END --><p><a id="hevea_default52"></a></p><p>La première idée qui vient à l’esprit pour améliorer l’efficacité de
l’algorithme d’Euclide consiste à éviter les fractions qui sont créées par les
divisions euclidiennes. On utilise à cet effet la pseudo-division: au lieu de
prendre le reste <span style="font-style:italic">R</span> de la division euclidienne du polynôme <span style="font-style:italic">P</span> par <span style="font-style:italic">Q</span>, on
prend le reste de la division de <span style="font-style:italic">P</span> <span style="font-style:italic">q</span><sup>δ + 1</sup> par <span style="font-style:italic">Q</span>, où <span style="font-style:italic">q</span> désigne le
coefficient dominant de <span style="font-style:italic">Q</span> et δ la différence entre le degré de <span style="font-style:italic">P</span> et
de <span style="font-style:italic">Q</span>.</p><p><span style="font-weight:bold">Exercice:</span> En utilisant votre système de calcul formel préféré,
calculez les restes intermédiaires générés dans l’algorithme d’Euclide
lorsqu’on utilise la pseudo-division par exemple pour les polynômes <span style="font-style:italic">P</span> ( <span style="font-style:italic">x</span> ) =
( <span style="font-style:italic">x</span> + 1 )<sup>7</sup> − ( <span style="font-style:italic">x</span> − 1 )<sup>6</sup> et sa dérivée.</p><p><span style="font-weight:bold">Une solution avec giac/xcas</span>:

</p><pre class="verbatim">pgcd(a,b,prs):={ 
 local P,p,Q,q,R,g,h,d,res;
 res:=NULL;
 // convertit a et b en polynomes listes 
 // et extrait la partie primitive   
 P:=symb2poly(a);
 p:=lgcd(P); // pgcd des elements de la liste
 P:=P/p; 
 Q:=symb2poly(b);
 q:=lgcd(Q);
 Q:=Q/q; 
 if (size(P)&lt;size(Q)){ // echange P et Q
  R:=P; P:=Q; Q:=R; 
 } 
 // calcul du contenu du pgcd
 p:=gcd(p,q);
 g:=1;
 h:=1;
 while (size(Q)!=1){
  q:=Q[0]; // coefficient dominant
  d:=size(P)-size(Q);
  R:=rem(q^(d+1)*P,Q);
  if (size(R)==0) return(p*poly12symb(Q/lgcd(Q),x));
  P:=Q;
  Q:=R;
  if (prs==1) Q:=Q/content(Q);
  if (prs==2) Q:=R/(g*h^d);
  res:=res,Q;
  if (prs==2) g:=q; h:=q^d/h^(d-1);
 } 
 return(p,res);
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;t.value=tmp;tmp=UI.caseval(tmp);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML);field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>


<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">P:=(x+1)^7-(x-1)^6; pgcd(P,P',0)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

On s’aperçoit que les coefficients croissent de manière exponentielle
(comparer avec ce qui se passe en mettant 1 comme dernier argument). La
deuxième idée qui vient naturellement est alors à chaque étape de rendre le
reste primitif, donc de diviser <span style="font-style:italic">R</span> par le pgcd de ces coefficients. Cela
donne un algorithme plus efficace, mais encore assez peu efficace car à chaque
étape on doit calculer le pgcd de tous les coefficients, on peut imaginer le
temps que cela prendra en dimension 1 et à fortiori en dimension supérieure.
L’idéal serait de connaitre à l’avance une quantité suffisamment grande qui
divise tous les coefficients du reste.</p><p>C’est ici qu’intervient l’algorithme du sous-résultant : après chaque
pseudo-division euclidienne, on exhibe un coefficient "magique" qui divise les
coefficients du reste (pour tester mettre le dernier argument de pgcd
à 2). 
Ce coefficient n’est pas le pgcd mais il est
suffisamment grand pour qu’on évite la croissance exponentielle des
coefficients.</p><p><span style="font-weight:bold">Algorithme du sous-résultant</span></p><p>Arguments: 2 polynômes <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> primitifs. Valeur de retour: le pgcd de <span style="font-style:italic">P</span>
et <span style="font-style:italic">Q</span>.</p><p>Pour calculer le coefficient "magique" on utilise 2 variables auxiliaires <span style="font-style:italic">g</span>
et <span style="font-style:italic">h</span> initialisées a 1.</p><p>Boucle à effectuer tant que <span style="font-style:italic">Q</span> est non nul:
</p><ul class="itemize"><li class="li-itemize">
on note δ =degre(<span style="font-style:italic">P</span>)-degre(<span style="font-style:italic">Q</span>) et <span style="font-style:italic">q</span> le coefficient dominant
de <span style="font-style:italic">Q</span></li><li class="li-itemize">on effectue la division euclidienne (sans fraction) de <span style="font-style:italic">q</span><sup>δ + 1</sup>
<span style="font-style:italic">P</span> par <span style="font-style:italic">Q</span>, soit <span style="font-style:italic">R</span> le reste</li><li class="li-itemize">Si <span style="font-style:italic">R</span> est constant, on sort de l’algorithme en renvoyant 1 comme pgcd</li><li class="li-itemize">on recopie <span style="font-style:italic">Q</span> dans <span style="font-style:italic">P</span> puis <span style="font-style:italic">R</span> / ( <span style="font-style:italic">g</span> <span style="font-style:italic">h</span><sup>δ</sup> ) dans <span style="font-style:italic">Q</span></li><li class="li-itemize">on recopie <span style="font-style:italic">q</span> dans <span style="font-style:italic">g</span> et <span style="font-style:italic">h</span><sup>1 − δ</sup> <span style="font-style:italic">q</span><sup>δ</sup> dans <span style="font-style:italic">h</span>.
</li></ul><p>
Si on sort normalement de la boucle, <span style="font-style:italic">Q</span> est nul, on renvoie donc la partie
primitive de <span style="font-style:italic">P</span> qui est le pgcd cherché.</p><p>Pour tester l’algorithme avec <span style="font-family:monospace">xcas</span>, il suffit de décommenter les
deux lignes <span style="font-family:monospace">Q:=R/(g*h^d);</span> et <span style="font-family:monospace">g:=q; h:=q^d/h
(d-1);</span> ci-dessus.</p><p>La preuve de l’algorithme est un peu longue et par ailleurs bien expliquée
dans le 2ème tome de Knuth (The Art of Computer Programming, Semi-numerical
Algorithms), on y renvoie donc le lecteur intéressé. L’idée générale
(et l’origine du nom de l’algorithme) 
est de considérer la matrice de Sylvester des polynômes de
départ <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> (celle dont le déterminant est appelé résultant de <span style="font-style:italic">P</span> et
<span style="font-style:italic">Q</span>) et de traduire les pseudo-divisions qui permettent de calculer les restes
successifs du sous-résultant en opération de ligne sur ces matrices. On
démontre alors que les coefficients de <span style="font-style:italic">R</span> divisés par <span style="font-style:italic">g</span> <span style="font-style:italic">h</span><sup>δ</sup> peuvent
être interprétés comme des déterminants de sous-matrices de la matrice de
Sylvester après réduction et c’est cela qui permet de conclure qu’ils sont
entiers.</p><p>Par exemple, supposons que <span style="font-style:italic">P</span>=<span style="font-style:italic">R</span><sub>0</sub>, <span style="font-style:italic">Q</span>=<span style="font-style:italic">R</span><sub>1</sub>, <span style="font-style:italic">R</span><sub>2</sub>... diminuent de 1 en degré
à chaque division 
(c’est le cas générique dans le déroulement de l’algorithme
d’Euclide). Dans ce cas, δ=1, il s’agit par exemple
de montrer que le reste <span style="font-style:italic">R</span><sub>3</sub> de <span style="font-style:italic">Q</span>=<span style="font-style:italic">R</span><sub>1</sub> par <span style="font-style:italic">R</span><sub>2</sub> est divisible par le
carré du coefficient dominant de <span style="font-style:italic">Q</span>=<span style="font-style:italic">R</span><sub>1</sub>.
Voyons comment on obtient les coefficients de <span style="font-style:italic">R</span><sub>3</sub>
à partir de la matrice de Sylvester de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>. 
Prenons la sous-matrice constituée des 2 premières lignes de <span style="font-style:italic">P</span>
et des 3 premières lignes de <span style="font-style:italic">Q</span> et réduisons-la sous forme
échelonnée sans introduire de dénominateur. 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>−3</sub></td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−3</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−4</sub></td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−3</sub></td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" >...  
</td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
On effectue <span style="font-style:italic">L</span><sub>1</sub> ← <span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">L</span><sub>1</sub> − <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">L</span><sub>3</sub>
et <span style="font-style:italic">L</span><sub>2</sub> ← <span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">L</span><sub>2</sub> − <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">L</span><sub>4</sub>, ce qui correspond à
l’élimination du terme en <span style="font-style:italic">x</span> du quotient de <span style="font-style:italic">P</span> par <span style="font-style:italic">Q</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>−1</sub> − <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>−1</sub> − <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−3</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−4</sub></td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−3</sub></td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" >...  
</td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
on effectue ensuite 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">L</span><sub>1</sub></td><td style="text-align:center;white-space:nowrap" >←</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">L</span><sub>1</sub> − (<span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>−1</sub> − <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−2</sub>)  <span style="font-style:italic">L</span><sub>4</sub> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">L</span><sub>2</sub></td><td style="text-align:center;white-space:nowrap" >←</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">L</span><sub>2</sub> − (<span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>−1</sub> − <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−2</sub>)  <span style="font-style:italic">L</span><sub>5</sub>
</td></tr>
</table></td></tr>
</table><p> 
ce qui correspond à l’élimination du terme constant du quotient
de <span style="font-style:italic">P</span> par <span style="font-style:italic">Q</span>, on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">r</span><sub>2,<span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">r</span><sub>2,<span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−3</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−4</sub></td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−3</sub></td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" >...  
</td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
si on enlève les lignes 3 et 4, et les colonnes 1 et 2,
on obtient (après échanges
de lignes) une sous-matrice de la matrice de Sylvester de <span style="font-style:italic">Q</span> et <span style="font-style:italic">R</span><sub>2</sub>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > <span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <span style="font-style:italic">r</span><sub>2,<span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > 0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">r</span><sub>2,<span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" >... 
</td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
On recommence les opérations de réduction de cette sous-matrice
correspondant à la division euclidienne de <span style="font-style:italic">Q</span> par <span style="font-style:italic">R</span><sub>2</sub>, on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > 0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">r</span><sub>3,<span style="font-style:italic">n</span>−3</sub> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <span style="font-style:italic">r</span><sub>2,<span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > 0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">r</span><sub>2,<span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" >... 
</td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
puis après suppression des colonnes 1 et 2 et des lignes 2 et 3
la ligne des coefficients de <span style="font-style:italic">R</span><sub>3</sub>.</p><p>Supposons qu’on se limite dès le début de la réduction à ne
garder que les colonnes 1 à 4 et une 5-ième colonne parmi
les suivantes, on obtient à la fin de la réduction
une matrice 1,1 qui contient
un des coefficients de <span style="font-style:italic">R</span><sub>3</sub> (selon le choix de la 5-ième colonne).
Donc ce coefficient est égal au déterminant de la matrice 1,1
qui est égal, au signe près, au déterminant de la matrice 3,3
dont il est issu par notre réduction (en effet, dans la 2ième
partie de la réduction,
on a multiplié deux fois <span style="font-style:italic">L</span><sub>1</sub> par <span style="font-style:italic">r</span><sub>2,<span style="font-style:italic">n</span>−2</sub>, mais on doit ensuite diviser 
le déterminant par <span style="font-style:italic">r</span><sub>2,<span style="font-style:italic">n</span>−2</sub><sup>2</sup> pour éliminer les colonnes 1 et 2).
Quant au déterminant de la matrice 3,3, il se déduit du
déterminant de la matrice 5,5 par multiplication par <span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub><sup>4</sup>
(2 lignes ont été multipliées 2 fois par <span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub>) et division
par <span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub><sup>2</sup> (élimination des colonnes 1 et 2). Au final,
tout coefficient de <span style="font-style:italic">R</span><sub>3</sub> est égal au produit d’un déterminant
5,5 extrait de la matrice de Sylvester de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> par <span style="font-style:italic">q</span><sub><span style="font-style:italic">n</span>−1</sub><sup>2</sup>,
qui est justement le coefficient “magique” par lequel on divise le reste
de <span style="font-style:italic">R</span><sub>1</sub>=<span style="font-style:italic">Q</span> par <span style="font-style:italic">R</span><sub>2</sub> lors de l’algorithme du sous-résultant.</p>
<!--TOC subsection id="sec47" Le pgcd en une variable.-->
<h3 id="sec47" class="subsection">5.2  Le pgcd en une variable.</h3><!--SEC END -->
<!--TOC subsubsection id="sec48" Le pgcd heuristique.-->
<h4 id="sec48" class="subsubsection">5.2.1  Le pgcd heuristique.</h4><!--SEC END --><p><a id="hevea_default53"></a></p><p>On suppose ici que les coefficients sont entiers ou entiers de Gauss.
<span style="font-weight:bold">On peut donc se ramener au cas où les polynômes sont primitifs.</span></p><p>L’idée consiste à évaluer <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> en un entier <span style="font-style:italic">z</span> et à extraire des
informations du pgcd <span style="font-style:italic">g</span> des entiers <span style="font-style:italic">P</span> ( <span style="font-style:italic">z</span> ) et <span style="font-style:italic">Q</span> ( <span style="font-style:italic">z</span> ). Il faut donc un
moyen de remonter de l’entier <span style="font-style:italic">g</span> à un polynôme <span style="font-style:italic">G</span> tel que <span style="font-style:italic">G</span> ( <span style="font-style:italic">z</span> ) = <span style="font-style:italic">g</span>. La
méthode consiste à écrire en base <span style="font-style:italic">z</span> l’entier <span style="font-style:italic">g</span>, avec une particularité
dans les divisions euclidiennes successives on utilise le reste symétrique
(compris entre − <span style="font-style:italic">z</span> / 2 et <span style="font-style:italic">z</span> / 2). Cette écriture donne les coefficients
d’un polynôme <span style="font-style:italic">G</span> unique. On extrait ensuite la partie primitive de ce
polynôme <span style="font-style:italic">G</span>. Lorsque <span style="font-style:italic">z</span> est assez grand par rapport aux coefficients des
polynômes <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>, si pp ( <span style="font-style:italic">G</span> ) divise <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>, on va montrer
que le pgcd de <span style="font-style:italic">P</span> et de <span style="font-style:italic">Q</span> est <span style="font-style:italic">D</span> = pp ( <span style="font-style:italic">G</span> ).</p><p>On remarque tout d’abord que <span style="font-style:italic">d</span> : = <span style="font-style:italic">D</span> ( <span style="font-style:italic">z</span> ) divise <span style="font-style:italic">g</span>. En effet <span style="font-style:italic">D</span> divise
<span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> donc pour tout entier (ou entier de Gauss) <span style="font-style:italic">z</span>, <span style="font-style:italic">D</span> ( <span style="font-style:italic">z</span> ) divise <span style="font-style:italic">P</span>
( <span style="font-style:italic">z</span> ) et <span style="font-style:italic">Q</span> ( <span style="font-style:italic">z</span> ). Il existe donc une constante <span style="font-style:italic">a</span> telle que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">g</span> = <span style="font-style:italic">a</span> <span style="font-style:italic">d</span> </td></tr>
</table><p>
On a aussi pp ( <span style="font-style:italic">G</span> ) divise <span style="font-style:italic">D</span>. Il existe donc un polynôme <span style="font-style:italic">C</span> tel
que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">D</span> = pp ( <span style="font-style:italic">G</span> ) <span style="font-style:italic">C</span> </td></tr>
</table><p>
Nous devons prouver que <span style="font-style:italic">C</span> est un polynôme constant. On suppose dans la suite
que ce n’est pas le cas. Evaluons l’égalité précédente au point <span style="font-style:italic">z</span>, on
obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">d</span> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">g</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">c</span> ( <span style="font-style:italic">G</span> )</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">C</span> ( <span style="font-style:italic">z</span> ) </td></tr>
</table><p>
Finalement
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">1 = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">c</span> ( <span style="font-style:italic">G</span> )</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">C</span> ( <span style="font-style:italic">z</span> ) </td></tr>
</table><p>
La procédure de construction de <span style="font-style:italic">G</span> nous donne une majoration de ces
coefficients par | <span style="font-style:italic">z</span> | / 2, donc de <span style="font-style:italic">c</span> ( <span style="font-style:italic">G</span> ) par | <span style="font-style:italic">z</span> | / 2, donc <span style="font-style:italic">C</span> ( <span style="font-style:italic">z</span>
) divise un entier de module plus petit que | <span style="font-style:italic">z</span> | / 2, donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| <span style="font-style:italic">C</span> ( <span style="font-style:italic">z</span> ) | ⩽ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">| <span style="font-style:italic">z</span> |</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
On considère maintenant les racines complexes <span style="font-style:italic">z</span><sub>1</sub>, … ., <span style="font-style:italic">z</span><sub><span style="font-style:italic">n</span></sub> du polynôme
<span style="font-style:italic">C</span> (il en existe au moins une puisqu’on a supposé <span style="font-style:italic">C</span> non constant). On a:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">C</span> ( <span style="font-style:italic">X</span> ) = <span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub> ( <span style="font-style:italic">X</span> − <span style="font-style:italic">z</span><sub>1</sub> ) … . ( <span style="font-style:italic">X</span> − <span style="font-style:italic">z</span><sub><span style="font-style:italic">n</span></sub> ) </td></tr>
</table><p>
Donc, comme <span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub> est un entier (ou entier de Gauss) non nul, sa norme est
supérieure ou égale à 1 et :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| <span style="font-style:italic">C</span> ( <span style="font-style:italic">z</span> ) | ⩾ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span> = 1</td></tr>
</table></td><td class="dcell"> ( | <span style="font-style:italic">z</span> | − | <span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub> | ) </td></tr>
</table><p>
Il nous reste à majorer les racines de <span style="font-style:italic">C</span> pour minorer | <span style="font-style:italic">C</span> ( <span style="font-style:italic">z</span> ) |. Comme
<span style="font-style:italic">C</span> divise <span style="font-style:italic">D</span> il divise <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> donc les racines de <span style="font-style:italic">C</span> sont des racines
communes à <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>. On va appliquer le:</p><div class="theorem"><span style="font-weight:bold">Lemme 5</span>  <em> </em><a id="lemme:majoration"></a><em>
Soit x une racine complexe d’un polynôme </em><span style="font-style:italic">P</span> = <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span></sup> + … . + <span style="font-style:italic">a</span><sub>0</sub><em>.</em><p><em>Alors 
</em></p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| <span style="font-style:italic">x</span> | &lt; | <span style="font-style:italic">P</span> |/| <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> | + 1, | <span style="font-style:italic">P</span> | = max<sub>0 ⩽ <span style="font-style:italic">i</span>
⩽ <span style="font-style:italic">n</span></sub> ( | <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub> | ) </td></tr>
</table></div><p>Application du lemme à <span style="font-style:italic">C</span>(<span style="font-style:italic">X</span>) : on a 1/|<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub>|≤ 1
donc si on a choisi <span style="font-style:italic">z</span> tel que | <span style="font-style:italic">z</span> | ⩾ 2 min( | <span style="font-style:italic">P</span> |, | <span style="font-style:italic">Q</span> | ) + 2,
alors pour tout <span style="font-style:italic">j</span>, | <span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub> | &lt; | <span style="font-style:italic">z</span> | / 2 donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| <span style="font-style:italic">C</span> ( <span style="font-style:italic">z</span> ) | &gt; </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">| <span style="font-style:italic">z</span> |</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
qui contredit notre majoration de | <span style="font-style:italic">C</span> ( <span style="font-style:italic">z</span> ) |.</p><div class="theorem"><span style="font-weight:bold">Théorème 6</span>  <em>
Soit </em><span style="font-style:italic">P</span><em> et Q deux polynômes à coefficients entiers. On
choisit un entier z tel que </em>| <span style="font-style:italic">z</span> | ⩾ 2 min( | <span style="font-style:italic">P</span> |, | <span style="font-style:italic">Q</span> | ) + 2<em>,
si la partie primitive du polynôme </em><span style="font-style:italic">G</span><em> reconstruit à partir du pgcd de </em><span style="font-style:italic">P</span> (
<span style="font-style:italic">z</span> ) et<em>Q(z) par écriture en base </em><span style="font-style:italic">z</span><em> (avec comme reste euclidien le
reste symétrique) divise </em><span style="font-style:italic">P</span><em> et </em><span style="font-style:italic">Q</span><em> alors c’est le pgcd de </em><span style="font-style:italic">P</span><em> et </em><span style="font-style:italic">Q</span><em>.
</em></div><p>Pour finir la démonstration du théorème, il nous faut encore montrer le lemme.
On a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">− <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup> = <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span> − 1</sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span> − 1</sup> + … . + <span style="font-style:italic">a</span><sub>0</sub> </td></tr>
</table><p>
Donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> | | <span style="font-style:italic">x</span> |<sup><span style="font-style:italic">n</span></sup> ⩽ | <span style="font-style:italic">P</span> | ( 1 + … . + | <span style="font-style:italic">x</span> |<sup><span style="font-style:italic">n</span> − 1</sup> ) = | <span style="font-style:italic">P</span> |
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">| <span style="font-style:italic">x</span> |<sup><span style="font-style:italic">n</span></sup> − 1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">| <span style="font-style:italic">x</span> | − 1</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Ici on peut supposer que | <span style="font-style:italic">x</span> | ⩾ 1, sinon le lemme est démontré,
donc | <span style="font-style:italic">x</span> | − 1 est positif et
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> | ( | <span style="font-style:italic">x</span> | − 1 ) ⩽ | <span style="font-style:italic">P</span> | </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">| <span style="font-style:italic">x</span> |<sup><span style="font-style:italic">n</span></sup> − 1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">| <span style="font-style:italic">x</span> |<sup><span style="font-style:italic">n</span></sup></td></tr>
</table></td><td class="dcell">
⇒ | <span style="font-style:italic">x</span> | − 1 &lt; </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">| <span style="font-style:italic">P</span> |</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">| <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> |</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Remarques
</p><ul class="itemize"><li class="li-itemize">
Le théorème publié par Char, Geddes et Gonnet 
porte sur des coefficients entiers et
c’est comme cela qu’il est utilisé par les systèmes de calcul formel (en
commençant historiquement par Maple). Peu de systèmes l’utilisent pour les
polynômes à coefficients entiers de Gauss. On peut d’ailleurs généraliser le
théorème à d’autres types de coefficients, à condition d’avoir un anneau
euclidien plongé dans ℂ avec une minoration sur la valeur absolue
des élements non nuls de l’anneau.</li><li class="li-itemize">Nous n’avons jusqu’à présent aucune certitude qu’il existe des entiers
<span style="font-style:italic">z</span> tels que la partie primitive de <span style="font-style:italic">G</span> divise <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>. Nous allons
montrer en utilisant l’identité de Bézout que pour <span style="font-style:italic">z</span> assez grand c’est
toujours le cas. Plus précisément, on sait qu’il existe deux polynômes <span style="font-style:italic">U</span>
et <span style="font-style:italic">V</span> tels que
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span> <span style="font-style:italic">U</span> + <span style="font-style:italic">Q</span> <span style="font-style:italic">V</span> = <span style="font-style:italic">D</span> </td></tr>
</table>
Attention toutefois, <span style="font-style:italic">U</span> et <span style="font-style:italic">V</span> sont à coefficients rationnels, pour avoir
des coefficients entiers, on doit multiplier par une constante entière
α, donc en évaluant en <span style="font-style:italic">z</span> on obtient l’existence d’une égalité à
coefficients entiers
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span> ( <span style="font-style:italic">z</span> ) <span style="font-style:italic">u</span> + <span style="font-style:italic">Q</span> ( <span style="font-style:italic">z</span> ) <span style="font-style:italic">v</span> = α <span style="font-style:italic">D</span> ( <span style="font-style:italic">z</span> ) </td></tr>
</table><p>Donc le pgcd <span style="font-style:italic">g</span> de <span style="font-style:italic">P</span> ( <span style="font-style:italic">z</span> ) et <span style="font-style:italic">Q</span> ( <span style="font-style:italic">z</span> ) divise α <span style="font-style:italic">D</span> ( <span style="font-style:italic">z</span> ) = α
<span style="font-style:italic">d</span>. Comme <span style="font-style:italic">g</span> est un multiple de <span style="font-style:italic">d</span>, on en déduit que <span style="font-style:italic">g</span> = β <span style="font-style:italic">d</span>, où
β est un diviseur de α. Si on a choisi <span style="font-style:italic">z</span> tel que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| <span style="font-style:italic">z</span> | &gt;  2 | <span style="font-style:italic">D</span> | | α | </td></tr>
</table><p>
alors | <span style="font-style:italic">z</span> | &gt; 2 | <span style="font-style:italic">D</span> | | β | donc l’écriture symétrique en base <span style="font-style:italic">z</span> de
<span style="font-style:italic">g</span> est <span style="font-style:italic">G</span> = β <span style="font-style:italic">D</span>. Donc la partie primitive de <span style="font-style:italic">G</span> est <span style="font-style:italic">D</span>, le
pgcd de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>.</p></li></ul><div class="theorem"><span style="font-weight:bold">Exemple 7</span>  <em>
Si </em><span style="font-style:italic">P</span><sub>0</sub> = 6 ( <span style="font-style:italic">X</span><sup>2</sup> − 1 )<em> et </em><span style="font-style:italic">Q</span><sub>0</sub> = 4 ( <span style="font-style:italic">X</span><sup>3</sup> − 1 )<em>.</em><p><em>Le contenu de </em><span style="font-style:italic">P</span><sub>0</sub><em> est 6, celui de </em><span style="font-style:italic">Q</span><sub>0</sub><em> est 4.<br>
 On a donc pgcd des contenus = 2, </em><span style="font-style:italic">P</span> = <span style="font-style:italic">X</span><sup>2</sup> − 1, <span style="font-style:italic">Q</span> = <span style="font-style:italic">X</span><sup>3</sup> − 1<em>. La valeur
initiale de </em><span style="font-style:italic">z</span><em> est donc </em>2 ∗ 1 + 2 = 4<em>. On trouve </em><span style="font-style:italic">P</span> ( 4 ) = 15, <span style="font-style:italic">Q</span> ( 4
) = 63<em>. Le pgcd entier de 15 et 63 est 3 que nous écrivons symétriquement
en base 4 sous la forme </em>3 = 1 ∗ 4 − 1<em>, donc </em><span style="font-style:italic">G</span> = <span style="font-style:italic">X</span> − 1<em>, sa partie
primitive est </em><span style="font-style:italic">X</span> − 1<em>. On teste si </em><span style="font-style:italic">X</span> − 1<em> divise </em><span style="font-style:italic">P</span><em> et </em><span style="font-style:italic">Q</span><em>, c’est le cas,
donc c’est le pgcd de </em><span style="font-style:italic">P</span><em> et </em><span style="font-style:italic">Q</span><em> et le pgcd de </em><span style="font-style:italic">P</span><sub>0</sub><em> et </em><span style="font-style:italic">Q</span><sub>0</sub><em> est </em>2 ( <span style="font-style:italic">X</span> − 1
)<em>.
</em></p></div><p><span style="font-weight:bold">Algorithme gcdheu</span><br>
En arguments deux polynômes <span style="font-style:italic">P</span><sub>0</sub> et <span style="font-style:italic">Q</span><sub>0</sub> à coefficients entiers ou entiers
de Gauss. Retourne le pgcd de 
<span style="font-style:italic">P</span><sub>0</sub> et <span style="font-style:italic">Q</span><sub>0</sub> ou faux en cas d’échec.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Calculer le contenu de <span style="font-style:italic">P</span><sub>0</sub> et <span style="font-style:italic">Q</span><sub>0</sub>. Vérifier que les coefficients
sont entiers de Gauss sinon retourner faux.</li><li class="li-enumerate">Extraire la partie primitive <span style="font-style:italic">P</span> de <span style="font-style:italic">P</span><sub>0</sub> et <span style="font-style:italic">Q</span> de <span style="font-style:italic">Q</span><sub>0</sub>, calculer le
pgcd <span style="font-style:italic">c</span> des contenus de <span style="font-style:italic">P</span><sub>0</sub> et <span style="font-style:italic">Q</span><sub>0</sub></li><li class="li-enumerate">Déterminer <span style="font-style:italic">z</span> = 2 min( | <span style="font-style:italic">P</span> |, | <span style="font-style:italic">Q</span> | ) + 2.</li><li class="li-enumerate">Début de boucle: initialisation du nombre d’essais à 1, test d’arrêt
sur un nombre maximal d’essais, avec changement de <span style="font-style:italic">z</span> entre deux itérations
(par exemple <span style="font-style:italic">z</span> ← 2 <span style="font-style:italic">z</span>).</li><li class="li-enumerate">Calculer le pgcd <span style="font-style:italic">g</span> de <span style="font-style:italic">P</span> ( <span style="font-style:italic">z</span> ) et <span style="font-style:italic">Q</span> ( <span style="font-style:italic">z</span> ) puis son écriture
symétrique en base <span style="font-style:italic">z</span> dont on extrait la partie primitive <span style="font-style:italic">G</span>.</li><li class="li-enumerate">Si <span style="font-style:italic">G</span> ne divise pas<span style="font-style:italic">P</span> passer à l’itération
suivante. De même pour <span style="font-style:italic">Q</span>.</li><li class="li-enumerate">Retourner <span style="font-style:italic">c</span> <span style="font-style:italic">G</span></li><li class="li-enumerate">Fin de la boucle</li><li class="li-enumerate">Retourner faux.
</li></ol><p>
On remarque au passage qu’on a calculé le quotient de <span style="font-style:italic">P</span> par <span style="font-style:italic">G</span> et le
quotient de <span style="font-style:italic">Q</span> par <span style="font-style:italic">G</span> lorsque la procédure réussit. On peut donc passer à la
procédure gcdheu deux paramètres supplémentaires par référence, les deux
polynômes que l’on affectera en cas de succès, ce qui optimise la
simplification d’une fraction de 2 polynômes.</p>
<!--TOC subsubsection id="sec49" Le pgcd modulaire-->
<h4 id="sec49" class="subsubsection">5.2.2  Le pgcd modulaire</h4><!--SEC END --><p><a id="hevea_default54"></a></p><p>On part du fait que si <span style="font-style:italic">D</span> est le pgcd de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> dans ℤ (ou
ℤ [ <span style="font-style:italic">i</span> ] ) alors après réduction modulo un nombre premier <span style="font-style:italic">n</span> qui ne
divise pas les coefficients dominants de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>, <span style="font-style:italic">D</span> divise le pgcd <span style="font-style:italic">G</span> de
<span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> dans ℤ / <span style="font-style:italic">n</span> ℤ (par convention, le pgcd dans
ℤ / <span style="font-style:italic">n</span> ℤ est normalisé pour que son coefficient dominant
vaille 1). Comme on calcule <span style="font-style:italic">G</span> dans ℤ / <span style="font-style:italic">n</span> ℤ, les
coefficients des restes intermédiaires de l’algorithme d’Euclide sont bornés,
on évite ainsi la croissance exponentielle des coefficients. Il faudra ensuite
reconstruire <span style="font-style:italic">D</span> à partir de <span style="font-style:italic">G</span>.</p><p>On remarque d’abord que si on trouve <span style="font-style:italic">G</span> = 1, alors <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> sont premiers
entre eux. En général, on peut seulement dire que le degré de <span style="font-style:italic">G</span> est
supérieur ou égal au degré de <span style="font-style:italic">D</span>. En fait, le degré de <span style="font-style:italic">G</span> est égal au degré
de <span style="font-style:italic">D</span> lorsque les restes de l’algorithme d’Euclide (calculé en effectuant des
pseudo-divisions, cf. l’exercice 1) ont leur coefficient dominant non
divisible par <span style="font-style:italic">n</span>. Donc plus <span style="font-style:italic">n</span> est grand, plus la probabilité est grande de
trouver <span style="font-style:italic">G</span> du bon degré.</p><p>Dans la suite, nous allons déterminer une borne <span style="font-style:italic">b</span> à priori majorant 
les coefficients de
<span style="font-style:italic">D</span>. On utilisera ensuite la même méthode que dans l’algorithme modulaire de
recherche de racines évidentes: on multiplie <span style="font-style:italic">G</span> dans ℤ / <span style="font-style:italic">n</span>
ℤ par le pgcd dans ℤ des coefficients dominants <span style="font-style:italic">p</span> et
<span style="font-style:italic">q</span> de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>. Soit D = pgcd ( <span style="font-style:italic">p</span>, <span style="font-style:italic">q</span> ) <span style="font-style:italic">G</span> le résultat écrit
en représentation symétrique. Si <span style="font-style:italic">n</span> ⩾ <span style="font-style:italic">b</span> pgcd ( <span style="font-style:italic">p</span>, <span style="font-style:italic">q</span> ) et si
<span style="font-style:italic">G</span> est du bon degré, on montre de la même manière que <span style="font-style:italic">D</span> = D. Comme 
on ne connait pas le degré de <span style="font-style:italic">D</span>, on est obligé de tester si D 
divise <span style="font-style:italic">P</span>
et <span style="font-style:italic">Q</span>. Si c’est le cas, alors D divise <span style="font-style:italic">D</span> donc D = <span style="font-style:italic">D</span>
puisque degre ( D ) = degre ( <span style="font-style:italic">G</span> ) ⩾
degre ( <span style="font-style:italic">D</span> ). Sinon, <span style="font-style:italic">n</span> est un nombre premier malchanceux pour ce
calcul de pgcd (degre ( <span style="font-style:italic">G</span> ) ⩾ degre ( <span style="font-style:italic">D</span> )), il faut
essayer un autre premier.</p><p><span style="font-weight:bold">Remarque:</span> On serait tenté de dire que les coefficients de <span style="font-style:italic">D</span>
sont bornés par le plus grand coefficient de <span style="font-style:italic">P</span>. C’est malheureusement faux,
par exemple ( <span style="font-style:italic">X</span> + 1 )<sup>2</sup> dont le plus grand coefficient est 2 divise ( <span style="font-style:italic">X</span> + 1
)<sup>2</sup> ( <span style="font-style:italic">X</span> − 1 ) dont le plus grand coefficient (en valeur absolue) est 1.</p><p>Soit <span style="font-style:italic">P</span> = ∑<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">X</span><sup><span style="font-style:italic">i</span></sup> un polynôme à coefficients entiers. On utilise la
norme euclidienne
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
| <span style="font-style:italic">P</span> |<sup>2</sup> = <span style="font-size:xx-large">∑</span>| <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> |<sup>2</sup>
    (5)</td></tr>
</table><p>
On établit d’abord une majoration du produit des racines de norme supérieure à
1 de <span style="font-style:italic">P</span> à l’aide de | <span style="font-style:italic">P</span> |. Ensuite si <span style="font-style:italic">D</span> est un diviseur de <span style="font-style:italic">P</span>, le
coefficient dominant <span style="font-style:italic">d</span> de <span style="font-style:italic">D</span> divise le coefficient dominant <span style="font-style:italic">p</span> de <span style="font-style:italic">P</span> et 
les racines de <span style="font-style:italic">D</span> sont aussi des racines de <span style="font-style:italic">P</span>. On pourra donc déterminer une
majoration des polynômes symétriques des racines de <span style="font-style:italic">D</span> et donc des
coefficients de <span style="font-style:italic">D</span>.</p><div class="theorem"><span style="font-weight:bold">Lemme 8</span>  <em> </em><a id="lemme:A"></a><em>
Soit </em><span style="font-style:italic">A</span> = ∑<sub><span style="font-style:italic">j</span> = 0</sub><sup><span style="font-style:italic">a</span></sup> <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">X</span><sup><span style="font-style:italic">j</span></sup><em> un polynôme et </em>α ∈ ℂ<em>.
Alors
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| ( <span style="font-style:italic">X</span> − α ) <span style="font-style:italic">A</span> | = | ( <span style="text-decoration:overline">α</span> <span style="font-style:italic">X</span> − 1 ) <span style="font-style:italic">A</span> | </td></tr>
</table><em>
</em></div><p>Pour prouver le lemme <a href="#lemme%3AA">8</a>, on développe les produits de polynômes. 
On pose <span style="font-style:italic">a</span><sub>−1</sub> = <span style="font-style:italic">a</span><sub><span style="font-style:italic">a</span> + 1</sub> = 0 et on note ℜ la partie réelle.
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| ( <span style="font-style:italic">X</span> − α ) <span style="font-style:italic">A</span> |<sup>2</sup> = ∑<sub><span style="font-style:italic">j</span> = 0</sub><sup><span style="font-style:italic">a</span> + 1</sup> | <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span> − 1</sub> − α
<span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> |<sup>2</sup> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span> + 1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span> = 0</td></tr>
</table></td><td class="dcell"> | <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span> − 1</sub> |<sup>2</sup> + | α |<sup>2</sup> | <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> |<sup>2</sup> − 2
ℜ ( <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span> − 1</sub> </td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >α  <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub></td></tr>
</table></td><td class="dcell"> ) </td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| ( <span style="text-decoration:overline">α</span> <span style="font-style:italic">X</span> − 1 ) <span style="font-style:italic">A</span> |<sup>2</sup> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span> + 1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span> = 0</td></tr>
</table></td><td class="dcell"> | 
</td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span> − 1</sub>
− <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> |<sup>2</sup> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span> + 1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span> = 0</td></tr>
</table></td><td class="dcell"> | α |<sup>2</sup> | <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span> − 1</sub> |<sup>2</sup> + | <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> |<sup>2</sup> −
2 ℜ ( </td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >α</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span> − 1</sub>   </td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub></td></tr>
</table></td><td class="dcell"> ) </td></tr>
</table><p>
Les deux donnent bien le même résultat.</p><p>Soit <span style="font-style:italic">P</span> ( <span style="font-style:italic">X</span> ) = <span style="font-style:italic">p</span> ∏( <span style="font-style:italic">X</span> − α<sub><span style="font-style:italic">j</span></sub> ) la factorisation de <span style="font-style:italic">P</span> sur
ℂ. On introduit le polynôme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">P = <span style="font-style:italic">p</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span> / | α<sub><span style="font-style:italic">j</span></sub> | ⩾ 1</td></tr>
</table></td><td class="dcell"> ( <span style="font-style:italic">X</span> − α<sub><span style="font-style:italic">j</span></sub> )
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span> / | α<sub><span style="font-style:italic">j</span></sub> | &lt; 1</td></tr>
</table></td><td class="dcell"> (  </td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >α<sub><span style="font-style:italic">j</span></sub></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">X</span> − 1 ) </td></tr>
</table><p>
qui d’après le lemme a la même norme que <span style="font-style:italic">P</span>. La norme de <span style="font-style:italic">P</span> majore donc le
coefficient constant de P  d’où:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
<a id="mignotte"></a>  ∏<sub><span style="font-style:italic">j</span> / | α<sub><span style="font-style:italic">j</span></sub> | ⩾ 1</sub> | α<sub><span style="font-style:italic">j</span></sub> |
⩽ | <span style="font-style:italic">P</span> |/| <span style="font-style:italic">p</span> |
    (6)</td></tr>
</table><p>
On remarque que (<a href="#mignotte">6</a>) reste vraie si on considère les
racines δ<sub><span style="font-style:italic">j</span></sub> de norme plus grande que 1 d’un diviseur <span style="font-style:italic">D</span> de <span style="font-style:italic">P</span> puisque
le produit porte alors sur un sous-ensemble. On écrit maintenant l’expression
des coefficients <span style="font-style:italic">d</span><sub><span style="font-style:italic">j</span></sub> de <span style="font-style:italic">D</span> à l’aide des racines δ<sub><span style="font-style:italic">j</span></sub> de <span style="font-style:italic">D</span>:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| <span style="font-style:italic">d</span><sub><span style="font-style:italic">m</span> − <span style="font-style:italic">j</span></sub> | = | <span style="font-style:italic">d</span> | </td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center">choix de <span style="font-style:italic">j</span> racines
parmi les <span style="font-style:italic">m</span> racines de <span style="font-style:italic">D</span></td></tr>
</table></td><td class="dcell">     </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center">δ<sub><span style="font-style:italic">k</span></sub> ∈
racines choisies</td></tr>
</table></td><td class="dcell"> δ<sub><span style="font-style:italic">k</span></sub> </td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪</td></tr>
</table><p>
Pour majorer | <span style="font-style:italic">d</span><sub><span style="font-style:italic">m</span> − <span style="font-style:italic">j</span></sub> |, on commence par majorer | δ<sub><span style="font-style:italic">k</span></sub> | par
β<sub><span style="font-style:italic">k</span></sub> = max( 1, | δ<sub><span style="font-style:italic">k</span></sub> | ). On est donc ramené à majorer
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">σ<sub><span style="font-style:italic">j</span>, <span style="font-style:italic">m</span></sub> ( β ) = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center">choix de <span style="font-style:italic">j</span> parmi <span style="font-style:italic">m</span>
valeurs β<sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td><td class="dcell">    </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center">β<sub><span style="font-style:italic">k</span></sub> ∈ choix</td></tr>
</table></td><td class="dcell"> β<sub><span style="font-style:italic">k</span></sub>  </td></tr>
</table><p>
avec pour hypothèse une majoration de <span style="font-style:italic">M</span> = ∏<sub><span style="font-style:italic">k</span> = 1</sub><sup><span style="font-style:italic">m</span></sup> β<sub><span style="font-style:italic">k</span></sub> donnée par
la relation (<a href="#mignotte">6</a>). Pour cela, on cherche le maximum de σ<sub><span style="font-style:italic">j</span>,
<span style="font-style:italic">m</span></sub> ( β ) sous les contraintes <span style="font-style:italic">M</span> fixé et β<sub><span style="font-style:italic">k</span></sub> ⩾ 1.</p><p>On va montrer que le maximum ne peut être atteint que si l’un des β<sub><span style="font-style:italic">k</span></sub> =
<span style="font-style:italic">M</span> (et tous les autres β<sub><span style="font-style:italic">k</span></sub> = 1 ). Sinon, quitte à réordonner supposons
que les β<sub><span style="font-style:italic">k</span></sub> sont classés par ordre croissant. On a donc β<sub><span style="font-style:italic">m</span> − 1</sub>
≠ 1, on pose β<sub><span style="font-style:italic">k</span></sub> = β<sub><span style="font-style:italic">k</span></sub> pour <span style="font-style:italic">k</span> ⩽ <span style="font-style:italic">m</span> − 2,
β<sub><span style="font-style:italic">m</span> − 1</sub> = 1 et β<sub><span style="font-style:italic">m</span></sub> = β<sub><span style="font-style:italic">m</span> − 1</sub> β<sub><span style="font-style:italic">m</span></sub>.
Comparons σ<sub><span style="font-style:italic">j</span>, <span style="font-style:italic">m</span></sub> ( β ) et σ<sub><span style="font-style:italic">j</span>, nm</sub> ( β
). Si le choix de <span style="font-style:italic">j</span> parmi <span style="font-style:italic">m</span> comporte <span style="font-style:italic">k</span> = <span style="font-style:italic">m</span> − 1 et <span style="font-style:italic">k</span> = <span style="font-style:italic">m</span>, le produit
est inchangé. Sinon on a la somme de deux produits, l’un contenant <span style="font-style:italic">k</span> = <span style="font-style:italic">m</span> − 1
et l’autre <span style="font-style:italic">k</span> = <span style="font-style:italic">m</span>. On compare donc <span style="font-style:italic">B</span> ( β<sub><span style="font-style:italic">m</span> − 1</sub> + β<sub><span style="font-style:italic">m</span></sub> ) et <span style="font-style:italic">B</span> ( 1
+ β<sub><span style="font-style:italic">m</span> − 1</sub> β<sub><span style="font-style:italic">m</span></sub> ) avec <span style="font-style:italic">B</span> = ∏<sub>β<sub><span style="font-style:italic">k</span></sub> ∈ reste du
choix</sub> β<sub><span style="font-style:italic">k</span></sub>. Comme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">1 + β<sub><span style="font-style:italic">m</span> − 1</sub> β<sub><span style="font-style:italic">m</span></sub> ⩾ β<sub><span style="font-style:italic">m</span> − 1</sub> + β<sub><span style="font-style:italic">m</span></sub> </td></tr>
</table><p>
puisque la différence est le produit (1−β<sub><span style="font-style:italic">m</span></sub>)(1−β<sub><span style="font-style:italic">m</span>−1</sub>) de deux
nombres positifs, on arrive à la contradiction souhaitée.</p><p>Ensuite on décompose les choix de σ<sub><span style="font-style:italic">m</span>, <span style="font-style:italic">j</span></sub> en ceux contenant <span style="font-style:italic">M</span> et
des 1 et ceux ne contenant que des 1, d’où la majoration
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">σ<sub><span style="font-style:italic">j</span>, <span style="font-style:italic">m</span></sub> ( β ) ⩽ </td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >     <span style="font-style:italic">m</span> − 1</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >     <span style="font-style:italic">j</span> − 1
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell"><span style="font-style:italic">M</span> + </td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >     <span style="font-style:italic">m</span> − 1</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >     <span style="font-style:italic">j</span>
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td></tr>
</table><p>
et finalement
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
| <span style="font-style:italic">d</span><sub><span style="font-style:italic">m</span> − <span style="font-style:italic">j</span></sub> | ⩽ | <span style="font-style:italic">d</span> | </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >    <span style="font-style:italic">m</span> − 1</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >    <span style="font-style:italic">j</span> − 1
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">| <span style="font-style:italic">P</span> |</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">| <span style="font-style:italic">p</span> |</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >    <span style="font-style:italic">m</span> − 1</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >    <span style="font-style:italic">j</span>
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><a id="pgcdd"></a>
    (7)</td></tr>
</table><p>
On peut en déduire une majoration indépendante de <span style="font-style:italic">j</span> sur les coefficients de
<span style="font-style:italic">D</span>, en majorant | <span style="font-style:italic">d</span> | par | <span style="font-style:italic">p</span> | (puisque <span style="font-style:italic">d</span> divise <span style="font-style:italic">p</span>) et les
coefficients binomiaux par 2<sup><span style="font-style:italic">m</span> − 1</sup> (obtenue en développant ( 1 + 1 )<sup><span style="font-style:italic">m</span> −
1</sup>). D’où le</p><div class="theorem"><span style="font-weight:bold">Théorème 9</span>  <a id="hevea_default55"></a><em> </em><a id="hevea_default56"></a><em>
(</em><em><span style="font-weight:bold">Landau-Mignotte</span></em><em>) 
Soit </em><span style="font-style:italic">P</span><em> un polynôme à coefficients entiers (ou entiers de
Gauss) et </em><span style="font-style:italic">D</span><em> un diviseur de </em><span style="font-style:italic">P</span><em> de degré </em><span style="font-style:italic">m</span><em>. Si </em>| <span style="font-style:italic">P</span> |<em> désigne la norme
euclidienne du vecteur des coefficients de </em><span style="font-style:italic">P</span><em> et </em><span style="font-style:italic">p</span><em> le coefficient
dominant de </em><span style="font-style:italic">P</span><em> alors les coefficients </em><span style="font-style:italic">d</span><sub><span style="font-style:italic">j</span></sub><em> de </em><span style="font-style:italic">D</span><em> satisfont l’inégalité
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
| <span style="font-style:italic">d</span><sub><span style="font-style:italic">j</span></sub> | ⩽ 2<sup><span style="font-style:italic">m</span> − 1</sup> ( | <span style="font-style:italic">P</span> | + | <span style="font-style:italic">p</span> | )
    (8)</td></tr>
</table><em>
</em></div><p>Avec cette estimation, on en déduit que si <span style="font-style:italic">n</span> est un premier plus grand que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
min( 2<sup>degre ( <span style="font-style:italic">P</span> ) − 1</sup> ( | <span style="font-style:italic">P</span> | + | <span style="font-style:italic">p</span> | ),
2<sup>degre ( <span style="font-style:italic">Q</span> ) − 1</sup> ( | <span style="font-style:italic">Q</span> | + | <span style="font-style:italic">q</span> | ) ), <a id="pgcdbound"></a>
    (9)</td></tr>
</table><p>
alors le pgcd trouvé dans ℤ / <span style="font-style:italic">n</span> ℤ va se reconstruire en un
pgcd dans ℤ si son degré est le bon.</p><p>Malheureusement la borne précédente est souvent très grande par rapport aux
coefficients du pgcd et calculer dans ℤ / <span style="font-style:italic">n</span> ℤ s’avèrera
encore inefficace (surtout si le pgcd est 1). Cela reste vrai même si on
optimise un peu la majoration (<a href="#pgcdbound">9</a>) en repartant de (<a href="#pgcdd">7</a>).</p><p>L’idée est donc de travailler modulo plusieurs nombres premiers plus petits et
reconstruire le pgcd des 2 polynômes à coefficients entiers à partir des pgcd
des polynômes dans ℤ / <span style="font-style:italic">n</span> ℤ et du
théorème des restes chinois. En pratique on prend des nombres premiers
inférieurs à la racine carrée du plus grand entier hardware de la machine
(donc plus petits que 2<sup>16</sup> sur une machine 32 bits) ce qui permet 
d’utiliser l’arithmétique hardware du processeur sans risque de débordement.</p><p><span style="font-weight:bold">Algorithme du PGCD modulaire en 1 variable:</span></p><p>En argument: 2 polynômes primitifs <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> à coefficients entiers. Le
résultat renvoyé sera le polynôme pgcd.</p><p>Variable auxiliaire: un entier <span style="font-style:italic">N</span> initialisé à 1 qui représente le produit
des nombres premiers utilisés jusqu’ici et un polynôme <span style="font-style:italic">H</span> initialisé à 0 qui
représente le pgcd dans ℤ / <span style="font-style:italic">N</span> ℤ.</p><p>Boucle infinie :
</p><ol class="enumerate" type=1><li class="li-enumerate">
Chercher un nouveau nombre premier <span style="font-style:italic">n</span> qui ne divise pas les
coefficients dominants <span style="font-style:italic">p</span> et <span style="font-style:italic">q</span> de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span></li><li class="li-enumerate">Calculer le pgcd <span style="font-style:italic">G</span> de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> dans ℤ / <span style="font-style:italic">n</span> ℤ.
Si <span style="font-style:italic">G</span>=1, renvoyer 1.</li><li class="li-enumerate">Si <span style="font-style:italic">H</span> = 0 ou si le degré de <span style="font-style:italic">G</span> est plus petit que le degré
de <span style="font-style:italic">H</span>, recopier <span style="font-style:italic">G</span> dans <span style="font-style:italic">H</span> et <span style="font-style:italic">n</span> dans <span style="font-style:italic">N</span>, passer à la 6ème étape</li><li class="li-enumerate">Si le degré de <span style="font-style:italic">G</span> est plus grand que celui de <span style="font-style:italic">H</span> passer à
l’itération suivante</li><li class="li-enumerate">Si le degré de <span style="font-style:italic">G</span> est égal au degré de <span style="font-style:italic">H</span>, 
en utilisant le théorème des restes chinois, calculer un polynôme
H tel que H = <span style="font-style:italic">H</span> modulo <span style="font-style:italic">N</span> et H = <span style="font-style:italic">G</span> modulo
<span style="font-style:italic">n</span>. Recopier H dans <span style="font-style:italic">H</span> et <span style="font-style:italic">n</span> <span style="font-style:italic">N</span> dans <span style="font-style:italic">N</span>.</li><li class="li-enumerate">Ecrire pgcd ( <span style="font-style:italic">p</span>, <span style="font-style:italic">q</span> ) <span style="font-style:italic">H</span> en représentation symétrique. Soit
H le résultat rendu primitif. Tester si H divise <span style="font-style:italic">P</span> et
<span style="font-style:italic">Q</span>. Si c’est le cas, renvoyer H, sinon passer à l’itération
suivante.
</li></ol><p>
Finalement on n’a pas utilisé <span style="font-style:italic">b</span>, la borne de Landau-Mignotte. 
On peut penser que l’étape
6 ne devrait être effectuée que lorsque <span style="font-style:italic">N</span> est plus grand que pgcd (
<span style="font-style:italic">p</span>, <span style="font-style:italic">q</span> ) <span style="font-style:italic">b</span>. En pratique, on effectue le test de l’étape 6 plus tôt parce que
les coefficients du pgcd sont rarement aussi grand que <span style="font-style:italic">b</span>. Mais pour éviter
de faire le test trop tôt, on introduit une variable auxiliaire <span style="font-style:italic">H</span>′ qui
contient la valeur de <span style="font-style:italic">H</span> de l’itération précédente et on ne fait le test que
si <span style="font-style:italic">H</span>′ = <span style="font-style:italic">H</span> (ou bien sûr si on a dépassé la borne).</p><p><span style="font-weight:bold">Remarque</span>:</p><p>L’algorithme ci-dessus fonctionne également pour des polynômes à plusieurs
variables.</p><p><span style="font-weight:bold">Exemple 1:</span></p><p>Calcul du pgcd de ( <span style="font-style:italic">X</span> + 1 )<sup>3</sup> ( <span style="font-style:italic">X</span> − 1 )<sup>4</sup> et ( <span style="font-style:italic">X</span><sup>4</sup> − 1 ). Prenons pour
commencer <span style="font-style:italic">n</span> = 2. On trouve comme pgcd <span style="font-style:italic">X</span><sup>4</sup> + 1 (en effet − 1 = 1 donc on
cherchait le pgcd de ( <span style="font-style:italic">X</span> + 1 )<sup>7</sup> et de <span style="font-style:italic">X</span><sup>4</sup> + 1 = ( <span style="font-style:italic">X</span> + 1 )<sup>4</sup>). On teste si
<span style="font-style:italic">X</span><sup>4</sup> + 1 divise <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>, ce n’est pas le cas donc on passe au nombre
premier suivant. Pour <span style="font-style:italic">n</span> = 3, on trouve <span style="font-style:italic">X</span><sup>2</sup> − 1. Donc <span style="font-style:italic">n</span> = 2 n’était pas un
bon nombre premier pour ce calcul de pgcd puisqu’on a trouvé un pgcd de degré
plus petit. On teste si <span style="font-style:italic">X</span><sup>2</sup> − 1 divise <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>, c’est le cas ici donc on
peut arrêter, le pgcd cherché est <span style="font-style:italic">X</span><sup>2</sup>−1.</p><p><span style="font-weight:bold">Exemple</span><span style="font-weight:bold"> 2 :</span></p><p>Calcul du pgcd de ( <span style="font-style:italic">X</span> + 1 )<sup>3</sup> ( <span style="font-style:italic">X</span> − 1 )<sup>4</sup> et ( <span style="font-style:italic">X</span><sup>4</sup> − 1 )<sup>3</sup>. 
Pour <span style="font-style:italic">n</span> = 2, on trouve un polynôme de degré 7.
Pour <span style="font-style:italic">n</span> = 3, on trouve <span style="font-style:italic">X</span><sup>6</sup> − 1 donc <span style="font-style:italic">n</span> = 2 était une mauvaise réduction.
Comme <span style="font-style:italic">X</span><sup>6</sup> − 1 ne divise pas <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>, on passe à <span style="font-style:italic">n</span> = 5. On trouve <span style="font-style:italic">X</span><sup>6</sup> +
2 <span style="font-style:italic">X</span><sup>4</sup> − 2 <span style="font-style:italic">X</span><sup>2</sup> − 1. On applique le théorème des restes chinois qui va nous
donner un polynôme dans ℤ / 15 ℤ. On cherche donc un
entier congru à 2 modulo 5 et à 0 modulo 3, -3 est la solution (écrite en
représentation symétrique), donc le polynôme modulo 15 est <span style="font-style:italic">X</span><sup>6</sup> − 3 <span style="font-style:italic">X</span><sup>4</sup> + 3
<span style="font-style:italic">X</span><sup>2</sup> − 1 = ( <span style="font-style:italic">X</span><sup>2</sup> − 1 )<sup>3</sup>. Ce polynôme divise <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>, c’est donc le pgcd de
<span style="font-style:italic">P</span> et de <span style="font-style:italic">Q</span>.</p>
<!--TOC subsection id="sec50" Le pgcd à plusieurs variables.-->
<h3 id="sec50" class="subsection">5.3  Le pgcd à plusieurs variables.</h3><!--SEC END -->
<!--TOC subsubsection id="sec51" Le pgcd heuristique.-->
<h4 id="sec51" class="subsubsection">5.3.1  Le pgcd heuristique.</h4><!--SEC END --><p><a id="hevea_default57"></a></p><p>On suppose comme dans le cas à une variable que les polynômes sont primitifs,
donc qu’on a simplifié les polynômes par le pgcd entier de leurs coefficients
entiers.</p><p>Le principe est identique à celui du PGCD à 1 variable, on évalue les deux
polynômes <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> de <span style="font-style:italic">k</span> variables <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span></sub> en un <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span></sub> = <span style="font-style:italic">z</span> et
on calcule le pgcd <span style="font-style:italic">g</span> des 2 polynômes <span style="font-style:italic">P</span> ( <span style="font-style:italic">z</span> ) et <span style="font-style:italic">Q</span> ( <span style="font-style:italic">z</span> ) de <span style="font-style:italic">k</span> − 1
variables. On remonte ensuite à un polynôme <span style="font-style:italic">G</span> par écriture symétrique en
base <span style="font-style:italic">z</span> de <span style="font-style:italic">g</span> et on teste si pp ( <span style="font-style:italic">G</span> ) divise <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>. Il s’agit
à nouveau de montrer que si <span style="font-style:italic">z</span> est assez grand, alors pp ( <span style="font-style:italic">G</span> ) est
le pgcd cherché. On sait que <span style="font-style:italic">d</span> = <span style="font-style:italic">D</span> ( <span style="font-style:italic">z</span> ) divise <span style="font-style:italic">g</span>. Il existe donc un
polynôme <span style="font-style:italic">a</span> de <span style="font-style:italic">k</span> − 1 variables tel que <span style="font-style:italic">g</span> = <span style="font-style:italic">a</span> <span style="font-style:italic">d</span>. On sait aussi que
pp ( <span style="font-style:italic">G</span> ) divise <span style="font-style:italic">D</span>, donc il existe un polynôme <span style="font-style:italic">C</span> de <span style="font-style:italic">k</span> variables
tel que <span style="font-style:italic">D</span> = <span style="font-style:italic">C</span> ∗ pp ( <span style="font-style:italic">G</span> ) . On évalue en <span style="font-style:italic">z</span> et on obtient <span style="font-style:italic">d</span> = <span style="font-style:italic">C</span> (
<span style="font-style:italic">z</span> ) <span style="font-style:italic">g</span> / <span style="font-style:italic">c</span> ( <span style="font-style:italic">G</span> ), où <span style="font-style:italic">c</span> ( <span style="font-style:italic">G</span> ) est un entier, donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">c</span> ( <span style="font-style:italic">G</span> ) = <span style="font-style:italic">a</span> ∗ <span style="font-style:italic">C</span> ( <span style="font-style:italic">z</span> ) </td></tr>
</table><p>
Comme <span style="font-style:italic">c</span> ( <span style="font-style:italic">G</span> ) est un entier, <span style="font-style:italic">a</span> et <span style="font-style:italic">C</span> ( <span style="font-style:italic">z</span> ) sont des polynômes constants.
Comme précédemment, on a aussi | <span style="font-style:italic">C</span> ( <span style="font-style:italic">z</span> ) | ⩽ | <span style="font-style:italic">z</span> | / 2 puisque | <span style="font-style:italic">c</span>
( <span style="font-style:italic">G</span> ) | ⩽ | <span style="font-style:italic">z</span> | / 2.
</p><ul class="itemize"><li class="li-itemize">
Premier cas: si <span style="font-style:italic">C</span> ne dépend que de la variable <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span></sub>. On continue le
raisonnement comme dans le cas unidimensionnel.</li><li class="li-itemize">Deuxième cas: si <span style="font-style:italic">C</span> dépend d’une autre variable, par exemple <span style="font-style:italic">X</span><sub>1</sub>.
On regarde le coefficient de plus haut degre de <span style="font-style:italic">C</span> par rapport a <span style="font-style:italic">X</span><sub>1</sub>. Ce
coefficient divise le coefficient de plus haut degre de <span style="font-style:italic">P</span> et de <span style="font-style:italic">Q</span> par
rapport a <span style="font-style:italic">X</span><sub>1</sub>. Comme <span style="font-style:italic">C</span> ( <span style="font-style:italic">z</span> ) est constant, on en deduit que le
coefficient de plus haut degre de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> par rapport a <span style="font-style:italic">X</span><sub>1</sub> est
divisible par <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span></sub> − <span style="font-style:italic">z</span> donc le coefficient de plus bas degre en <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span></sub> de
ces coefficients de plus haut degre est divisible par <span style="font-style:italic">z</span>, ce qui contredit
la majoration de ce coefficient.
</li></ul><p>En pratique, cet algorithme nécessite le calcul récursif de pgcd sans
garantie de réussite. On l’évite donc s’il y a beaucoup de variables (la
limite est par exemple de 5 pour MuPAD).</p>
<!--TOC subsubsection id="sec52" Le pgcd modulaire multivariables.-->
<h4 id="sec52" class="subsubsection">5.3.2  Le pgcd modulaire multivariables.</h4><!--SEC END --><p><a id="hevea_default58"></a></p><p>Ici, on travaille modulo <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> − α, où <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> désignent
les variables des polynômes. On considère donc deux polynômes <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> comme
polynômes de la variables <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> avec des coefficients dans ℤ [ <span style="font-style:italic">X</span><sub>1</sub>,
… ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub> ]. On évalue en <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> = α, on obtient deux polynômes
en <span style="font-style:italic">n</span> − 1 variables dont on calcule le pgcd (récursivement).</p><p>Il s’agit de reconstruire le pgcd par interpolation. Tout d’abord, on a une 
borne évidente sur le degré du pgcd par rapport à la variable <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>, c’est le
minimum δ des degrés par rapport à <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> des polynômes <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>. A
première vue, il suffit donc d’évaluer les polynômes
en δ + 1 points α.</p><p>Il faut toutefois prendre garde aux mauvaises évaluations et à la
normalisation des pgcd avant d’interpoler. En effet, si <span style="font-style:italic">D</span> ( <span style="font-style:italic">X</span><sub>1</sub>, … .,
<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ) désigne le pgcd de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> et <span style="font-style:italic">G</span> ( <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub> ) le
pgcd de <span style="font-style:italic">P</span> ( <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub>, α ) et de <span style="font-style:italic">Q</span> ( <span style="font-style:italic">X</span><sub>1</sub>, … .,
<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub>, α ), 
on peut seulement dire <span style="font-style:italic">D</span> ( <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub>, α )
divise <span style="font-style:italic">G</span>. Plusieurs cas sont donc possibles lorsqu’on évalue en un nouveau
point α:
</p><ul class="itemize"><li class="li-itemize">
l’un des degrés de <span style="font-style:italic">G</span> est plus petit que le degré du polynôme <span style="font-style:italic">D</span>′
reconstruit par interpolation jusque là. Dans ce cas, toutes les évaluations
qui ont conduit à reconstruire <span style="font-style:italic">D</span>′ étaient mauvaises. Il faut recommencer
l’interpolation à zéro ou à partir de <span style="font-style:italic">G</span> (si tous les degrés de <span style="font-style:italic">G</span> sont
inférieurs ou égaux aux degrés du <span style="font-style:italic">D</span>′ reconstruit).</li><li class="li-itemize">l’un des degrés de <span style="font-style:italic">G</span> est plus grand que le degré du <span style="font-style:italic">D</span>′ reconstruit
jusque là. Il faut alors ignorer α.</li><li class="li-itemize">Tous les degrés de <span style="font-style:italic">G</span> sont égaux aux degrés du <span style="font-style:italic">D</span>′ reconstruit
jusque là. Dans ce cas, <span style="font-style:italic">G</span> est un multiple entier du polynôme <span style="font-style:italic">D</span>′
reconstruit jusque là et évalué en <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> = α. Si on suppose qu’on a pu
s’arranger pour que ce multiple soit 1, on ajoute le point α aux
points d’évaluation précédents α<sub><span style="font-style:italic">j</span></sub> en posant:
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">D</span>′ = <span style="font-style:italic">D</span>′ + ( <span style="font-style:italic">G</span> − <span style="font-style:italic">D</span>′ ) </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center">α<sub><span style="font-style:italic">j</span></sub></td></tr>
</table></td><td class="dcell"> ( <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> − α<sub><span style="font-style:italic">j</span></sub>
)</td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center">α<sub><span style="font-style:italic">j</span></sub></td></tr>
</table></td><td class="dcell"> ( α − α<sub><span style="font-style:italic">j</span></sub> )</td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table>
</li></ul><p>
On voit que les mauvaises évaluations se détectent simplement par les degrés.
Pour la normalisation, on utilise une petite astuce: au lieu de reconstruire
le pgcd <span style="font-style:italic">D</span>, on va reconstruire un multiple du pgcd <span style="font-style:italic">D</span> (ce
multiple appartiendra à ℤ [ <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ] ). On voit maintenant <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>
comme des polynômes en <span style="font-style:italic">n</span> − 1 variables <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub> à
coefficients dans ℤ [ <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ]. Alors lcoeff(<span style="font-style:italic">D</span>), 
le coefficient dominant de <span style="font-style:italic">D</span>
(relativement à l’ordre lexicographique sur les variables <span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub>),
est un polynôme en <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> qui divise le coefficient dominant de <span style="font-style:italic">P</span> et de <span style="font-style:italic">Q</span>
donc divise le coefficient dominant du pgcd des coefficients dominants de <span style="font-style:italic">P</span>
et de <span style="font-style:italic">Q</span>. On va donc reconstruire le polynôme :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">D</span>′ = <span style="font-style:italic">D</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Δ ( <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> )</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">lcoeff ( <span style="font-style:italic">D</span> ) ( <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> )</td></tr>
</table></td><td class="dcell">, Δ ( <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ) =
pgcd ( lcoeff ( <span style="font-style:italic">P</span> ) ( <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ), lcoeff ( <span style="font-style:italic">Q</span> ) ( <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> )) </td></tr>
</table><p>
c’est-à-dire <span style="font-style:italic">D</span> multiplié par un polynôme qui ne dépend que de <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>.</p><p>Revenons à <span style="font-style:italic">G</span> en un point α de bonne évaluation. C’est un multiple
entier de <span style="font-style:italic">D</span> ( <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub>, α ):
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">G</span> = β <span style="font-style:italic">D</span> ( <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub>, α ) </td></tr>
</table><p>
Donc, comme polynômes de <span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub> à coefficients dans 
ℤ[<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>] ou dans ℤ,
lcoeff ( <span style="font-style:italic">G</span> ) = β lcoeff ( <span style="font-style:italic">D</span> )<sub>| <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> = α</sub>. Comme
lcoeff ( <span style="font-style:italic">D</span> ) divise Δ ( <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ), il en est de même en <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> =
α donc lcoeff(<span style="font-style:italic">G</span>) divise β Δ(α). 
On en déduit que  Δ ( α) <span style="font-style:italic">G</span> qui 
est divisible par  Δ (α) β est
divisible par lcoeff ( <span style="font-style:italic">G</span> ). On va donc considérer le polynôme
 Δ (α) <span style="font-style:italic">G</span> / lcoeff ( <span style="font-style:italic">G</span> ) :
ses coefficients sont entiers et son coefficient dominant est 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">Δ ( α) = lcoeff(<span style="font-style:italic">D</span>′( <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub>, α ))</td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">Δ (α) <span style="font-style:italic">G</span>  / lcoeff ( <span style="font-style:italic">G</span> )=
<span style="font-style:italic">D</span>′( <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub>, α )</td></tr>
</table><p><span style="font-weight:bold">Algorithme du pgcd modulaire à plusieurs variables (interpolation
dense)</span>:</p><p>Arguments: 2 polynômes primitifs <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> de <span style="font-style:italic">n</span> variables <span style="font-style:italic">X</span><sub>1</sub>, … .,
<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> à coefficients entiers. Renvoie le pgcd de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Si <span style="font-style:italic">n</span> = 1, renvoyer le pgcd de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> en une variable.</li><li class="li-enumerate">Test rapide de pgcd trivial par rapport à <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>. On cherche des <span style="font-style:italic">n</span> −
1-uplets α tels que <span style="font-style:italic">P</span> ( α, <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ) et <span style="font-style:italic">Q</span> ( α, <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> )
soient de même degré que <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> par rapport à la variable <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>. On
calcule le pgcd <span style="font-style:italic">G</span> de ces 2 polynômes en une variable. Si le pgcd est
constant, alors on retourne le pgcd des coefficients de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>.</li><li class="li-enumerate">On divise <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> par leur contenu respectifs vu comme polynômes en
<span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub> à coefficients dans ℤ [ <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ], on note
<span style="font-style:italic">C</span> ( <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ) le pgcd des contenus. On calcule aussi le pgcd Δ ( <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> )
des coefficients dominants de <span style="font-style:italic">P</span> et de <span style="font-style:italic">Q</span>.</li><li class="li-enumerate">On initialise <span style="font-style:italic">D</span>′ le pgcd reconstruit à 0, <span style="font-style:italic">I</span> ( <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ) le polynôme
d’interpolation à 1, δ=(δ<sub>1</sub>,...,δ<sub><span style="font-style:italic">n</span>−1</sub>) 
la liste des degrés partiels du pgcd par
rapport à <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub> au minimum des degrés partiels de <span style="font-style:italic">P</span>
et <span style="font-style:italic">Q</span> par rapport à <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub>, <span style="font-style:italic">e</span> le nombre d’évaluation
à 0 et <span style="font-style:italic">E</span> l’ensemble des points d’interpolation à la liste vide.</li><li class="li-enumerate">Boucle infinie:
<ul class="itemize"><li class="li-itemize">
Faire α=entier aléatoire n’appartenant pas à <span style="font-style:italic">E</span> jusqu’à ce
que
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >      degre(<span style="font-style:italic">P</span> ( <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub>, α
))=degre<sub><span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub></sub> ( <span style="font-style:italic">P</span> ( <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> )</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >      degre ( <span style="font-style:italic">Q</span> ( <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub>, α )) =
degre<sub><span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub></sub> ( <span style="font-style:italic">Q</span> ( <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ))</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >    </td></tr>
</table></td></tr>
</table>
</li><li class="li-itemize">Calculer le pgcd <span style="font-style:italic">G</span> ( <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub> ) en <span style="font-style:italic">n</span> − 1
variables de <span style="font-style:italic">P</span> ( <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub>, α ) et <span style="font-style:italic">Q</span> ( <span style="font-style:italic">X</span><sub>1</sub>, …
., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub>, α ).</li><li class="li-itemize">Si degre ( <span style="font-style:italic">G</span> )<sub><span style="font-style:italic">i</span></sub> &lt; δ<sub><span style="font-style:italic">i</span></sub> pour un indice au moins.
Si degre ( <span style="font-style:italic">G</span> ) ⩽ δ, on pose δ =
degre ( <span style="font-style:italic">G</span> ), <span style="font-style:italic">D</span>′ = <span style="font-style:italic">G</span> Δ ( α )/lcoeff ( <span style="font-style:italic">G</span>
), <span style="font-style:italic">I</span> = <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> − α, <span style="font-style:italic">e</span> = 1 et <span style="font-style:italic">E</span> = [ α ], sinon on pose δ
= min( δ, degre ( <span style="font-style:italic">G</span> )), <span style="font-style:italic">D</span>′ = 0, <span style="font-style:italic">I</span> = 1, <span style="font-style:italic">e</span> = 0, <span style="font-style:italic">E</span> = [ ].
On passe à l’itération suivante.</li><li class="li-itemize">Si degre ( <span style="font-style:italic">G</span> ) &gt; δ, on passe à l’itération suivante.</li><li class="li-itemize">Si degre ( <span style="font-style:italic">G</span> ) = δ, on interpole:
<ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">G</span> := <span style="font-style:italic">G</span> Δ ( α )/lcoeff ( <span style="font-style:italic">G</span> )</li><li class="li-itemize"><span style="font-style:italic">D</span>′ := <span style="font-style:italic">D</span>′ + <span style="font-style:italic">I</span> ( <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> )/∏<sub>α<sub><span style="font-style:italic">j</span></sub> ∈ <span style="font-style:italic">E</span></sub> ( α −
α<sub><span style="font-style:italic">j</span></sub> ) ( <span style="font-style:italic">G</span> − <span style="font-style:italic">D</span>′ ( <span style="font-style:italic">X</span><sub>1</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span> − 1</sub>, α ))</li><li class="li-itemize"><span style="font-style:italic">I</span> := <span style="font-style:italic">I</span> ∗ ( <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> − α )</li><li class="li-itemize"><span style="font-style:italic">e</span> := <span style="font-style:italic">e</span> + 1 et ajouter α à <span style="font-style:italic">E</span></li><li class="li-itemize">Si <span style="font-style:italic">e</span> est strictement plus grand que le minimum des degrés
partiels de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> par rapport à <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>, on pose D la
partie primitive de <span style="font-style:italic">D</span>′ (vu comme polynôme à coefficients dans
ℤ [ <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ]), on teste si <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> sont divisibles par
D, si c’est le cas, on renvoie <span style="font-style:italic">D</span> = <span style="font-style:italic">C</span> ( <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ) D
</li></ul>
</li></ul>
</li></ol><p>
On observe que dans cet algorithme, on fait le test de divisibilite de
D par <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>. En effet, même après avoir évalué en suffisamment
de points, rien n’indique que tous ces points sont des points de bonne
évaluation. En pratique cela reste extrêmement improbable. En pratique, on
teste la divisibilité plus tôt, dès que <span style="font-style:italic">D</span>′ n’est pas modifié par l’ajout
d’un nouveau point à la liste des α<sub><span style="font-style:italic">j</span></sub>.</p><p>Il existe une variation de cet algorithme, appelé SPMOD (sparse modular), qui
suppose que seuls les coefficients non nuls du pgcd en <span style="font-style:italic">n</span> − 1 variables sont
encore non nuls en <span style="font-style:italic">n</span> variables (ce qui a de fortes chances d’être le cas).
L’étape d’interpolation est alors remplacée par la résolution d’un
sous-système d’un système de Vandermonde. Cette variation est intéressante si
le nombre de coefficients non nuls en <span style="font-style:italic">n</span> − 1 variables est petit devant le
degré. Si elle échoue, on revient à l’interpolation dense.</p><p>Notons enfin qu’on peut appliquer cette méthode lorsque les coefficients de
<span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> sont dans ℤ / <span style="font-style:italic">n</span> ℤ mais il faut alors vérifier
qu’on dispose de suffisamment de points d’interpolation. Ce qui en combinant
avec l’algorithme modulaire à une variable donne un algorithme doublement
modulaire pour calculer le pgcd de 2 polynômes à coefficients entiers. C’est
cette méthode qu’utilise par exemple MuPAD (en essayant d’abord SPMOD puis
l’interpolation dense).</p><p><span style="font-weight:bold">Exemple:</span></p><p>Dans cet exemple, on donne <span style="font-style:italic">F</span> et <span style="font-style:italic">G</span> sous forme factorisée, le but étant de
faire comprendre l’algorithme. En utilisation normale, on n’exécuterait cet
algorithme que si <span style="font-style:italic">F</span> et <span style="font-style:italic">G</span> étaient développés.</p><p><span style="font-style:italic">P</span> = (( <span style="font-style:italic">x</span> + 1 ) <span style="font-style:italic">y</span> + <span style="font-style:italic">x</span><sup>2</sup> + 1 ) ( <span style="font-style:italic">y</span><sup>2</sup> + <span style="font-style:italic">x</span> <span style="font-style:italic">y</span> + 1 ), <span style="font-style:italic">Q</span> = (( <span style="font-style:italic">x</span> + 1 ) <span style="font-style:italic">y</span> +
<span style="font-style:italic">x</span><sup>2</sup> + 1 ) ( <span style="font-style:italic">y</span><sup>2</sup> − <span style="font-style:italic">x</span> <span style="font-style:italic">y</span> − 1 ).</p><p>Prenons <span style="font-style:italic">x</span> comme variable <span style="font-style:italic">X</span><sub>1</sub> et <span style="font-style:italic">y</span> comme variable <span style="font-style:italic">X</span><sub>2</sub>. Les coefficients
dominants de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> sont respectivement <span style="font-style:italic">y</span> et − <span style="font-style:italic">y</span> donc Δ = <span style="font-style:italic">y</span>.</p><p>En <span style="font-style:italic">y</span> = 0, <span style="font-style:italic">P</span> ( <span style="font-style:italic">x</span>, 0 ) = <span style="font-style:italic">x</span><sup>2</sup> + 1 n’est pas du bon degré.</p><p>En <span style="font-style:italic">y</span> = 1, <span style="font-style:italic">P</span> ( <span style="font-style:italic">x</span>, 1 ) = ( <span style="font-style:italic">x</span> + <span style="font-style:italic">x</span><sup>2</sup> + 2 ) ( <span style="font-style:italic">x</span> + 2 ) et <span style="font-style:italic">Q</span> ( <span style="font-style:italic">x</span>, 1 ) = ( <span style="font-style:italic">x</span> +
<span style="font-style:italic">x</span><sup>2</sup> + 2 ) ( − <span style="font-style:italic">x</span> ) sont du bon degré. Leur pgcd est <span style="font-style:italic">G</span> = <span style="font-style:italic">x</span><sup>2</sup> + <span style="font-style:italic">x</span> + 2, Δ
( 1 ) = 1, donc <span style="font-style:italic">D</span>′ = <span style="font-style:italic">x</span><sup>2</sup> + <span style="font-style:italic">x</span> + 1. On teste la divisibilité de <span style="font-style:italic">P</span> par <span style="font-style:italic">D</span>′,
le teste échoue.</p><p>En <span style="font-style:italic">y</span> = 2, <span style="font-style:italic">P</span> ( <span style="font-style:italic">x</span>, 2 ) = ( <span style="font-style:italic">x</span><sup>2</sup> + 2 <span style="font-style:italic">x</span> + 3 ) ( 2 <span style="font-style:italic">x</span> + 5 ) et <span style="font-style:italic">Q</span> ( <span style="font-style:italic">x</span>, 2 ) = (
<span style="font-style:italic">x</span><sup>2</sup> + 2 <span style="font-style:italic">x</span> + 3 ) ( − 2 <span style="font-style:italic">x</span> + 3 ) donc <span style="font-style:italic">G</span> = <span style="font-style:italic">x</span><sup>2</sup> + 2 <span style="font-style:italic">x</span> + 3, Δ ( 2 ) = 2.
On interpole:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">D</span>′ = <span style="font-style:italic">x</span><sup>2</sup> + <span style="font-style:italic">x</span> + 2 + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span> − 1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2 − 1</td></tr>
</table></td><td class="dcell"> ( 2 ( <span style="font-style:italic">x</span><sup>2</sup> + 2 <span style="font-style:italic">x</span> + 3 ) − ( <span style="font-style:italic">x</span><sup>2</sup> + <span style="font-style:italic">x</span> +
2 )) = <span style="font-style:italic">y</span> ( <span style="font-style:italic">x</span><sup>2</sup> + 3 <span style="font-style:italic">x</span> + 4 ) − ( 2 <span style="font-style:italic">x</span> + 2 ) </td></tr>
</table><p>
On teste la divisibilité de <span style="font-style:italic">P</span> par <span style="font-style:italic">D</span>′, le test échoue.</p><p>En <span style="font-style:italic">y</span> = 3, <span style="font-style:italic">P</span> ( <span style="font-style:italic">x</span>, 3 ) = ( <span style="font-style:italic">x</span><sup>2</sup> + 3 <span style="font-style:italic">x</span> + 4 ) ( 3 <span style="font-style:italic">x</span> + 10 ) et <span style="font-style:italic">Q</span> ( <span style="font-style:italic">x</span>, 3 ) = (
<span style="font-style:italic">x</span><sup>2</sup> + 3 <span style="font-style:italic">x</span> + 4 ) ( − 3 <span style="font-style:italic">x</span> + 8 ) donc <span style="font-style:italic">G</span> = <span style="font-style:italic">x</span><sup>2</sup> + 3 <span style="font-style:italic">x</span> + 4, Δ ( 3 ) = 3.
On interpole:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >  <span style="font-style:italic">D</span>′</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">y</span> ( <span style="font-style:italic">x</span><sup>2</sup> + 3 <span style="font-style:italic">x</span> + 4 ) − ( 2 <span style="font-style:italic">x</span> + 2 ) + </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">( <span style="font-style:italic">y</span> − 2 ) ( <span style="font-style:italic">y</span> − 1 )</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">( 3 − 2
) ( 3 − 1 )</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎝</td><td class="dcell">3 ( <span style="font-style:italic">x</span><sup>2</sup> + 3 <span style="font-style:italic">x</span> + 4 ) − ( 3 ( <span style="font-style:italic">x</span><sup>2</sup> + 3 <span style="font-style:italic">x</span> + 4 ) − ( 2 <span style="font-style:italic">x</span> + 2
)) </td><td class="dcell">⎞<br>
⎠</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">D</span>′ = <span style="font-style:italic">y</span> ( <span style="font-style:italic">x</span><sup>2</sup> + 3 <span style="font-style:italic">x</span> + 4 ) − ( 2 <span style="font-style:italic">x</span> + 2 ) + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">( <span style="font-style:italic">y</span> − 2 ) ( <span style="font-style:italic">y</span> − 1 )</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> ( −
2 <span style="font-style:italic">x</span> − 2 ) = <span style="font-style:italic">x</span><sup>2</sup> <span style="font-style:italic">y</span> + <span style="font-style:italic">x</span> <span style="font-style:italic">y</span><sup>2</sup> + <span style="font-style:italic">y</span><sup>2</sup> + <span style="font-style:italic">y</span> </td></tr>
</table><p>
On divise <span style="font-style:italic">D</span>′ par son contenu et on trouve <span style="font-style:italic">x</span><sup>2</sup> + <span style="font-style:italic">x</span> <span style="font-style:italic">y</span> + <span style="font-style:italic">y</span> + 1 qui est bien
le pgcd de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>.</p>
<!--TOC subsubsection id="sec53" EZGCD.-->
<h4 id="sec53" class="subsubsection">5.3.3  EZGCD.</h4><!--SEC END --><p>Il s’agit d’une méthode <span style="font-style:italic">p</span>-adique. On évalue toutes les variables sauf une,
on calcule le pgcd en une variable et on remonte au pgcd variable par variable
(EEZGCD) ou toutes les variables simultanément (EZGCD) par un lemme de Hensel.
Il semble qu’il est plus efficace de remonter les variables séparément.</p><p>Soit donc <span style="font-style:italic">F</span> et <span style="font-style:italic">G</span> deux polynômes primitifs dépendant des variables <span style="font-style:italic">X</span><sub>1</sub>,
…, <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> de pgcd <span style="font-style:italic">D</span>, on fixe une des variables qu’on appelera <span style="font-style:italic">X</span><sub>1</sub> dans
la suite. Soient lcoeff ( <span style="font-style:italic">F</span> ) et lcoeff ( <span style="font-style:italic">G</span> ) les
coefficients dominants de <span style="font-style:italic">F</span> et <span style="font-style:italic">G</span> par rapport à <span style="font-style:italic">X</span><sub>1</sub>. On évalue <span style="font-style:italic">F</span> et <span style="font-style:italic">G</span>
en un <span style="font-style:italic">n</span> − 1 uplet <span style="font-style:italic">b</span> tel que le degré de <span style="font-style:italic">F</span> et <span style="font-style:italic">G</span> par rapport à <span style="font-style:italic">X</span><sub>1</sub>
soit conservé après evaluation en <span style="font-style:italic">b</span>. On suppose que <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> ( <span style="font-style:italic">X</span><sub>1</sub> ) =
pgcd ( <span style="font-style:italic">F</span> ( <span style="font-style:italic">b</span> ), <span style="font-style:italic">G</span> ( <span style="font-style:italic">b</span> )) a le même degré que <span style="font-style:italic">D</span> ( <span style="font-style:italic">b</span> ). On a donc
l’égalité:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">( <span style="font-style:italic">F</span> ∗ lcoeff ( <span style="font-style:italic">F</span> )) ( <span style="font-style:italic">b</span> ) = </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub>  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">lcoeff ( <span style="font-style:italic">F</span> (
<span style="font-style:italic">b</span> ))</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">lcoeff ( <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> )</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">∗ </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">F</span> ( <span style="font-style:italic">b</span> )</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub></td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">lcoeff ( <span style="font-style:italic">F</span> ) ( <span style="font-style:italic">b</span> )</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">lcoeff ( </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">F</span> ( <span style="font-style:italic">b</span> )</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub></td></tr>
</table></td><td class="dcell"> )</td></tr>
</table></td></tr>
</table></td><td class="dcell">
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
et de même en remplaçant <span style="font-style:italic">F</span> par <span style="font-style:italic">G</span>.</p><p>Pour pouvoir lifter cette égalité (c’est-à-dire généraliser à plusieurs 
variables), il faut que <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> et <span style="font-style:italic">F</span> ( <span style="font-style:italic">b</span> )/<span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub>
soient premiers entre eux. Sinon, on peut essayer de lifter l’égalité analogue
avec <span style="font-style:italic">G</span>. En général, on montre qu’il existe un entier <span style="font-style:italic">j</span> tel que <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> et
<span style="font-style:italic">F</span> ( <span style="font-style:italic">b</span> ) + <span style="font-style:italic">j</span> <span style="font-style:italic">G</span> ( <span style="font-style:italic">b</span> )/<span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> soient premiers entre eux. En effet, sinon
au moins un des facteurs irréductibles de <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> va diviser <span style="font-style:italic">F</span> ( <span style="font-style:italic">b</span> ) + <span style="font-style:italic">j</span>
<span style="font-style:italic">G</span> ( <span style="font-style:italic">b</span> )/<span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> pour deux valeurs distinctes de <span style="font-style:italic">j</span> et va donc diviser à la
fois <span style="font-style:italic">F</span> ( <span style="font-style:italic">b</span> )/<span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> et <span style="font-style:italic">G</span> ( <span style="font-style:italic">b</span> )/<span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> en contradiction avec la
définition de <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> = pgcd ( <span style="font-style:italic">F</span> ( <span style="font-style:italic">b</span> ), <span style="font-style:italic">G</span> ( <span style="font-style:italic">b</span> )). On lifte alors
l’égalité obtenue en remplaçant <span style="font-style:italic">F</span> par ( <span style="font-style:italic">F</span> + <span style="font-style:italic">k</span> <span style="font-style:italic">G</span> ) ci-dessus. Dans la
suite, on suppose qu’on peut prendre <span style="font-style:italic">j</span> = 0 pour alléger les notations.</p><p>On va aussi supposer que <span style="font-style:italic">b</span> = 0. Sinon, on fait un changement d’origine sur
les polynômes <span style="font-style:italic">F</span> et <span style="font-style:italic">G</span> pour que <span style="font-style:italic">b</span> = 0 convienne, on calcule le pgcd et on
lui applique la translation d’origine opposée.</p><p>On adopte ensuite la notation suivante: si <span style="font-style:italic">k</span> est un entier, on dit qu’un
polynôme <span style="font-style:italic">P</span> est un <span style="font-style:italic">O</span> ( <span style="font-style:italic">k</span> ) si la valuation de <span style="font-style:italic">P</span> vu comme polynôme en
<span style="font-style:italic">X</span><sub>2</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> à coefficients dans ℤ [ <span style="font-style:italic">X</span><sub>1</sub> ] est supérieure
ou égale à <span style="font-style:italic">k</span>, ou de manière équivalente si
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span> ( <span style="font-style:italic">X</span><sub>1</sub>, <span style="font-style:italic">h</span> <span style="font-style:italic">X</span><sub>2</sub>, … ., <span style="font-style:italic">h</span> <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ) = <span style="font-style:italic">O</span><sub><span style="font-style:italic">h</span> → 0</sub> ( <span style="font-style:italic">h</span><sup><span style="font-style:italic">k</span></sup> ) </td></tr>
</table><p>
L’égalité à lifter se réécrit donc:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">F</span> lcoeff ( <span style="font-style:italic">F</span> ) = <span style="font-style:italic">P</span><sub>0</sub> <span style="font-style:italic">Q</span><sub>0</sub> + <span style="font-style:italic">O</span> ( 1 ) </td></tr>
</table><p> 
où <span style="font-style:italic">P</span><sub>0</sub> =<span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> lcoeff ( <span style="font-style:italic">F</span> ( <span style="font-style:italic">b</span> ))/lcoeff ( <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> ) et
<span style="font-style:italic">Q</span><sub>0</sub> = <span style="font-style:italic">F</span> ( <span style="font-style:italic">b</span> )/<span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> lcoeff ( <span style="font-style:italic">F</span> ) ( <span style="font-style:italic">b</span> )/lcoeff (
<span style="font-style:italic">F</span> ( <span style="font-style:italic">b</span> )/<span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> ) sont premiers entre eux et de degré 0 par rapport aux
variables <span style="font-style:italic">X</span><sub>2</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>. Cherchons <span style="font-style:italic">P</span><sub>1</sub> = <span style="font-style:italic">O</span> ( 1 ) et <span style="font-style:italic">Q</span><sub>1</sub> = <span style="font-style:italic">O</span> ( 1 )
de degré 1 par rapport aux variables <span style="font-style:italic">X</span><sub>2</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> tels que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">F</span> lcoeff ( <span style="font-style:italic">F</span> ) = ( <span style="font-style:italic">P</span><sub>0</sub> + <span style="font-style:italic">P</span><sub>1</sub> ) ( <span style="font-style:italic">Q</span><sub>0</sub> + <span style="font-style:italic">Q</span><sub>1</sub> ) + <span style="font-style:italic">O</span> ( 2 ) </td></tr>
</table><p>
Il faut donc résoudre
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">F</span> lcoeff ( <span style="font-style:italic">F</span> ) − <span style="font-style:italic">P</span><sub>0</sub> <span style="font-style:italic">Q</span><sub>0</sub> = <span style="font-style:italic">P</span><sub>0</sub> <span style="font-style:italic">Q</span><sub>1</sub> + <span style="font-style:italic">Q</span><sub>0</sub> <span style="font-style:italic">P</span><sub>1</sub> + <span style="font-style:italic">O</span> ( 2 ) </td></tr>
</table><p>
On peut alors appliquer l’identité de Bézout qui permet de déterminer des
polynômes <span style="font-style:italic">P</span><sub>1</sub> et <span style="font-style:italic">Q</span><sub>1</sub> satisfaisant l’égalité ci-dessus (avec comme reste <span style="font-style:italic">O</span>
( 2 ) nul) puisque <span style="font-style:italic">P</span><sub>0</sub> et <span style="font-style:italic">Q</span><sub>0</sub> sont premiers entre eux. De plus, on
choisit <span style="font-style:italic">P</span><sub>1</sub> et <span style="font-style:italic">Q</span><sub>1</sub> tels que degre<sub><span style="font-style:italic">X</span><sub>1</sub></sub> <span style="font-style:italic">P</span><sub>1</sub> ⩽
degre<sub><span style="font-style:italic">X</span><sub>1</sub></sub> ( <span style="font-style:italic">F</span> ) − degre ( <span style="font-style:italic">Q</span><sub>0</sub> ) = degre ( <span style="font-style:italic">P</span><sub>0</sub> ) et
degre<sub><span style="font-style:italic">X</span><sub>1</sub></sub> ( <span style="font-style:italic">Q</span><sub>1</sub> ) ⩽ degre ( <span style="font-style:italic">Q</span><sub>0</sub> ) et
lcoeff<sub><span style="font-style:italic">X</span><sub>1</sub></sub> ( <span style="font-style:italic">P</span><sub>0</sub> + <span style="font-style:italic">P</span><sub>1</sub> ) + <span style="font-style:italic">O</span> ( 2 ) = lcoeff<sub><span style="font-style:italic">X</span><sub>1</sub></sub> ( <span style="font-style:italic">Q</span><sub>0</sub> + <span style="font-style:italic">Q</span><sub>1</sub>
) + <span style="font-style:italic">O</span> ( 2 ) = lcoeff<sub><span style="font-style:italic">X</span><sub>1</sub></sub> ( <span style="font-style:italic">F</span> ). On tronque ensuite <span style="font-style:italic">P</span><sub>1</sub> et <span style="font-style:italic">Q</span><sub>1</sub> en
ne conservant que les termes de degré 1 par rapport à <span style="font-style:italic">X</span><sub>2</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>.</p><p>On trouve de la même manière par récurrence <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> et <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> homogènes de degré
<span style="font-style:italic">k</span> par rapport à <span style="font-style:italic">X</span><sub>2</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span></sub>, de degré par rapport à <span style="font-style:italic">X</span><sub>1</sub>
respectivement inférieur aux degrés de <span style="font-style:italic">Q</span><sub>0</sub> et de <span style="font-style:italic">P</span><sub>0</sub> et tels que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
<span style="font-style:italic">F</span> lcoeff ( <span style="font-style:italic">F</span> ) = ( <span style="font-style:italic">P</span><sub>0</sub> + … . + <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> ) ( <span style="font-style:italic">Q</span><sub>0</sub> + … . + <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> ) +
<span style="font-style:italic">O</span> ( <span style="font-style:italic">k</span> + 1  ) <a id="ezgcd"></a>
    (10)</td></tr>
</table><p>
et lcoeff ( <span style="font-style:italic">F</span> ) = lcoeff<sub><span style="font-style:italic">X</span><sub>1</sub></sub> ( <span style="font-style:italic">P</span><sub>0</sub> + … . + <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> ) + <span style="font-style:italic">O</span> ( <span style="font-style:italic">k</span>
+ 1 ) = lcoeff<sub><span style="font-style:italic">X</span><sub>1</sub></sub> ( <span style="font-style:italic">Q</span><sub>0</sub> + … . + <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> ) + <span style="font-style:italic">O</span> ( <span style="font-style:italic">k</span> + 1 ).</p><p>Si on est bien en un point de bonne évaluation et si <span style="font-style:italic">k</span> est plus grand que le
degré total (par rapport aux variables <span style="font-style:italic">X</span><sub>2</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>) du polynôme
<span style="font-style:italic">F</span> lcoeff ( <span style="font-style:italic">F</span> ) on va vérifier que <span style="font-style:italic">P</span><sub>0</sub> + … . + <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> = <span style="font-style:italic">D</span>
lcoeff ( <span style="font-style:italic">F</span> )/lcoeff ( <span style="font-style:italic">D</span> ). En effet, si on a deux
suites de polynômes <span style="font-style:italic">P</span> et <span style="font-style:italic">P</span>′ et <span style="font-style:italic">Q</span> et <span style="font-style:italic">Q</span>′ satisfaisant (<a href="#ezgcd">10</a>) avec
les même termes de degré zéro <span style="font-style:italic">P</span><sub>0</sub> et <span style="font-style:italic">Q</span><sub>0</sub>, alors en prenant la différence,
on obtient:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">( <span style="font-style:italic">P</span><sub>0</sub> + <span style="font-style:italic">P</span><sub>1</sub> …  + <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> ) ( <span style="font-style:italic">Q</span><sub>0</sub> + <span style="font-style:italic">Q</span><sub>1</sub> …  + <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> ) = ( <span style="font-style:italic">P</span><sub>0</sub> + <span style="font-style:italic">P</span><sub>1</sub>′
…  + <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>′ ) ( <span style="font-style:italic">Q</span><sub>0</sub> + <span style="font-style:italic">Q</span><sub>1</sub>′ …  + <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub>′ ) + <span style="font-style:italic">O</span> ( <span style="font-style:italic">k</span> + 1 ) </td></tr>
</table><p>
On égale alors les termes homogènes de degré <span style="font-style:italic">j</span>, pour <span style="font-style:italic">j</span> = 1, on obtient
<span style="font-style:italic">P</span><sub>0</sub> ( <span style="font-style:italic">Q</span><sub>1</sub> − <span style="font-style:italic">Q</span><sub>1</sub>′ ) = <span style="font-style:italic">Q</span><sub>0</sub> ( <span style="font-style:italic">P</span><sub>1</sub> − <span style="font-style:italic">P</span><sub>1</sub>′ ), donc <span style="font-style:italic">Q</span><sub>0</sub> divise <span style="font-style:italic">Q</span><sub>1</sub> − <span style="font-style:italic">Q</span><sub>1</sub>′ qui
est de degré strictement inférieur au degré de <span style="font-style:italic">Q</span><sub>0</sub> par rapport à <span style="font-style:italic">X</span><sub>1</sub> (car
on a l’inégalité large et les termes de plus haut degré sont égaux),
donc <span style="font-style:italic">Q</span><sub>1</sub> = <span style="font-style:italic">Q</span><sub>1</sub>′ et <span style="font-style:italic">P</span><sub>1</sub> = <span style="font-style:italic">P</span><sub>1</sub>′. On montre de la même manière que <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> =
<span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub>′ et <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> = <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>′. L’écriture est donc unique, c’est donc l’écriture en
polynôme homogène de degré croissant de <span style="font-style:italic">D</span> lcoeff ( <span style="font-style:italic">F</span>
)/lcoeff ( <span style="font-style:italic">D</span> ) que l’on reconstruit.</p><p>Cet algorithme permet donc de reconstruire <span style="font-style:italic">D</span>, il suffit de tester à chaque
étape si <span style="font-style:italic">P</span><sub>0</sub> + … . + <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> divise <span style="font-style:italic">F</span> lcoeff ( <span style="font-style:italic">F</span> ). On appelle
cette méthode de remontée lemme de Hensel linéaire. Il existe une variante
dite lemme de Hensel quadratique qui consiste à passer de <span style="font-style:italic">O</span> ( <span style="font-style:italic">k</span> ) à <span style="font-style:italic">O</span> ( 2 <span style="font-style:italic">k</span>
). Elle nécessite toutefois un calcul supplémentaire, celui de l’identité de
Bézout à <span style="font-style:italic">O</span> ( 2 <span style="font-style:italic">k</span> ) près pour les polynômes <span style="font-style:italic">P</span><sub>0</sub> + … . + <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span> − 1</sub> et
<span style="font-style:italic">Q</span><sub>0</sub> + … . + <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span> − 1</sub>. Ce calcul se fait également par lifting.</p><p><span style="font-weight:bold">Algorithme EZGCD (Hensel linéaire)</span></p><p>Arguments: 2 polynômes <span style="font-style:italic">F</span> et <span style="font-style:italic">G</span> à coefficients entiers et primitifs. Renvoie
le pgcd de <span style="font-style:italic">F</span> et <span style="font-style:italic">G</span> ou false.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Evaluer <span style="font-style:italic">F</span> et <span style="font-style:italic">G</span> en ( <span style="font-style:italic">X</span><sub>2</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ) = ( 0, … ., 0 ),
vérifier que les coefficients dominants de <span style="font-style:italic">F</span> et de <span style="font-style:italic">G</span> ne s’annulent pas.
Calculer le pgcd <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> de <span style="font-style:italic">F</span> ( 0 ) et de <span style="font-style:italic">G</span> ( 0 ). Prendre un autre point
d’évaluation au hasard qui n’annule pas les coefficients dominants de <span style="font-style:italic">F</span> et
de <span style="font-style:italic">G</span> et vérifier que le pgcd a le même degré que <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub>. Sinon, renvoyer
false (on peut aussi faire une translation d’origine de <span style="font-style:italic">F</span> et de <span style="font-style:italic">G</span> en un
autre point mais cela diminue l’efficacité de l’algorithme).</li><li class="li-enumerate">On note lcF et lcG les coefficients dominants de <span style="font-style:italic">F</span>
et de <span style="font-style:italic">G</span> par rapport à <span style="font-style:italic">X</span><sub>1</sub>.</li><li class="li-enumerate">Si degre ( <span style="font-style:italic">F</span> ) ⩽ degre ( <span style="font-style:italic">G</span> ) et degre
( <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> ) = degre ( <span style="font-style:italic">G</span> ) et <span style="font-style:italic">F</span> divise <span style="font-style:italic">G</span> renvoyer <span style="font-style:italic">F</span></li><li class="li-enumerate">Si degre ( <span style="font-style:italic">G</span> ) &lt; degre ( <span style="font-style:italic">F</span> ) et degre ( <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> )
= degre ( <span style="font-style:italic">F</span> ) et <span style="font-style:italic">G</span> divise <span style="font-style:italic">F</span> renvoyer <span style="font-style:italic">G</span></li><li class="li-enumerate">Si degre ( <span style="font-style:italic">F</span> ) = degre ( <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> ) ou si degre ( <span style="font-style:italic">G</span>
) = degre ( <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> ) renvoyer false</li><li class="li-enumerate">Boucle infinie sur <span style="font-style:italic">j</span> entier initialisé à 0, incrémenté de 1 à chaque
itération: si pgcd ( <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub>, <span style="font-style:italic">F</span> ( 0 ) + <span style="font-style:italic">j</span> <span style="font-style:italic">G</span> ( 0 )/<span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> ) = <span style="font-style:italic">C</span>
constant, alors arrêter la boucle</li><li class="li-enumerate">Lifter l’égalité ( <span style="font-style:italic">F</span> + <span style="font-style:italic">j</span> <span style="font-style:italic">G</span> ) ( lcF + <span style="font-style:italic">j</span> lcG ) ( 0 ) =
( <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> ( lcF + <span style="font-style:italic">j</span> lcG ) ( 0 )/lcoeff ( <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span>
)</sub> ) ∗ … . par remontée de Hensel linéaire ou quadratique.
Si le résultat est false, renvoyer false. Sinon renvoyer le premier polynôme
du résultat divisé par son contenu vu comme polynôme en <span style="font-style:italic">X</span><sub>1</sub> à coefficients
dans ℤ [ <span style="font-style:italic">X</span><sub>2</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> ].
</li></ol><p>
<span style="font-weight:bold">Remontée de Hensel linéaire</span>:<a id="hevea_default59"></a></p><p>Arguments: <span style="font-style:italic">F</span> un polynôme, lcF=lcoeff(<span style="font-style:italic">F</span>) 
son coefficient dominant, <span style="font-style:italic">P</span><sub>0</sub> un
facteur de <span style="font-style:italic">F</span> ( 0 ) ayant comme coefficient dominant lcF ( 0 ) et
dont le cofacteur <span style="font-style:italic">Q</span><sub>0</sub> est premier avec <span style="font-style:italic">P</span><sub>0</sub>.</p><p>Renvoie deux polynômes <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> tels que <span style="font-style:italic">F</span> lcF = <span style="font-style:italic">P</span> <span style="font-style:italic">Q</span> et <span style="font-style:italic">P</span> ( 0 ) =
<span style="font-style:italic">P</span><sub>0</sub> et lcoeff ( <span style="font-style:italic">P</span> ) = lcoeff ( <span style="font-style:italic">Q</span> ) = lcF.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Soit <span style="font-style:italic">G</span> = <span style="font-style:italic">F</span> lcF, , <span style="font-style:italic">Q</span><sub>0</sub> = <span style="font-style:italic">G</span> ( 0 ) / <span style="font-style:italic">P</span><sub>0</sub>, <span style="font-style:italic">P</span> = <span style="font-style:italic">P</span><sub>0</sub>, <span style="font-style:italic">Q</span> =
<span style="font-style:italic">Q</span><sub>0</sub>.</li><li class="li-enumerate">Déterminer les deux polynômes <span style="font-style:italic">U</span> et <span style="font-style:italic">V</span> de l’identité de Bézout
(tels que <span style="font-style:italic">P</span><sub>0</sub> <span style="font-style:italic">U</span> + <span style="font-style:italic">Q</span><sub>0</sub> <span style="font-style:italic">V</span> = <span style="font-style:italic">d</span> où <span style="font-style:italic">d</span> est un entier).</li><li class="li-enumerate">Boucle infinie avec un compteur <span style="font-style:italic">k</span> initialisé à 1, incrémenté de 1 à
chaque itération
<ul class="itemize"><li class="li-itemize">
Si <span style="font-style:italic">k</span> &gt; degre<sub><span style="font-style:italic">X</span><sub>2</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub></sub> ( <span style="font-style:italic">G</span> ), renvoyer false.</li><li class="li-itemize">Si <span style="font-style:italic">P</span> divise <span style="font-style:italic">G</span>, renvoyer <span style="font-style:italic">P</span> et <span style="font-style:italic">G</span> / <span style="font-style:italic">P</span>.</li><li class="li-itemize">Soit <span style="font-style:italic">H</span> = <span style="font-style:italic">G</span> − <span style="font-style:italic">P</span> <span style="font-style:italic">Q</span> = <span style="font-style:italic">O</span> ( <span style="font-style:italic">k</span> ). Soit <span style="font-style:italic">u</span> = <span style="font-style:italic">U</span> <span style="font-style:italic">H</span>/<span style="font-style:italic">d</span> et <span style="font-style:italic">v</span> = <span style="font-style:italic">V</span>
<span style="font-style:italic">H</span>/<span style="font-style:italic">d</span>, on a <span style="font-style:italic">P</span><sub>0</sub> <span style="font-style:italic">u</span> + <span style="font-style:italic">Q</span><sub>0</sub> <span style="font-style:italic">v</span> = <span style="font-style:italic">H</span></li><li class="li-itemize">Remplacer <span style="font-style:italic">v</span> par le reste de la division euclidienne de <span style="font-style:italic">v</span> par
<span style="font-style:italic">P</span><sub>0</sub> et <span style="font-style:italic">u</span> par le reste de la division euclidienne de <span style="font-style:italic">u</span> par <span style="font-style:italic">Q</span><sub>0</sub>. La
somme des deux quotients est égale au quotient euclidien de <span style="font-style:italic">H</span> par <span style="font-style:italic">P</span><sub>0</sub>
<span style="font-style:italic">Q</span><sub>0</sub>, c’est-à-dire au coefficient dominant de <span style="font-style:italic">H</span> divisé par le produit
des coefficients dominants de <span style="font-style:italic">P</span><sub>0</sub> et <span style="font-style:italic">Q</span><sub>0</sub> (qui sont égaux) donc on a
l’égalité:
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub>0</sub> <span style="font-style:italic">u</span> + <span style="font-style:italic">Q</span><sub>0</sub> <span style="font-style:italic">v</span> = <span style="font-style:italic">H</span> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">lcoeff ( <span style="font-style:italic">H</span> )</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">lcoeff ( <span style="font-style:italic">P</span><sub>0</sub>
)<sup>2</sup></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">P</span><sub>0</sub> <span style="font-style:italic">Q</span><sub>0</sub> </td></tr>
</table>
</li><li class="li-itemize">Soit
α = ( lcoeff ( <span style="font-style:italic">F</span> ) − lcoeff ( <span style="font-style:italic">P</span> )) / lcoeff (
<span style="font-style:italic">P</span><sub>0</sub> ) et β = ( lcoeff ( <span style="font-style:italic">F</span> ) − lcoeff ( <span style="font-style:italic">Q</span> )) /
lcoeff ( <span style="font-style:italic">P</span><sub>0</sub> ).
On ajoute α <span style="font-style:italic">P</span><sub>0</sub> à <span style="font-style:italic">v</span>, ainsi lcoeff ( <span style="font-style:italic">P</span> + <span style="font-style:italic">v</span> ) =
lcoeff ( <span style="font-style:italic">F</span> ) + <span style="font-style:italic">O</span> ( <span style="font-style:italic">k</span> + 1 ) et β <span style="font-style:italic">Q</span><sub>0</sub> à <span style="font-style:italic">u</span>, ainsi
lcoeff ( <span style="font-style:italic">Q</span> + <span style="font-style:italic">u</span> ) = lcoeff ( <span style="font-style:italic">F</span> ) + <span style="font-style:italic">O</span> ( <span style="font-style:italic">k</span> + 1 ) <p>Remarque: on montre alors que α + β = lcoeff ( <span style="font-style:italic">H</span>
)/lcoeff ( <span style="font-style:italic">P</span><sub>0</sub> <span style="font-style:italic">Q</span><sub>0</sub> ) + <span style="font-style:italic">O</span> ( <span style="font-style:italic">k</span> + 1 ) donc <span style="font-style:italic">P</span><sub>0</sub> <span style="font-style:italic">u</span> + <span style="font-style:italic">Q</span><sub>0</sub> <span style="font-style:italic">v</span> = <span style="font-style:italic">H</span> + <span style="font-style:italic">O</span> (
<span style="font-style:italic">k</span> + 1 ) en utilisant les propriétés :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">lcoeff ( <span style="font-style:italic">F</span> ) = lcoeff ( <span style="font-style:italic">P</span> ) + <span style="font-style:italic">O</span> ( <span style="font-style:italic">k</span> ) =
lcoeff ( <span style="font-style:italic">Q</span> ) + <span style="font-style:italic">O</span> ( <span style="font-style:italic">k</span> ) = lcoeff ( <span style="font-style:italic">P</span><sub>0</sub> ) + <span style="font-style:italic">O</span> ( 1 ) </td></tr>
</table></li><li class="li-itemize">Réduire <span style="font-style:italic">u</span> et <span style="font-style:italic">v</span> en éliminant les termes de degré strictement
supérieur à <span style="font-style:italic">k</span> par rapport à <span style="font-style:italic">X</span><sub>2</sub>, … ., <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>. S’il reste un
coefficient non entier, renvoyer false</li><li class="li-itemize">Remplacer <span style="font-style:italic">P</span> par <span style="font-style:italic">P</span> + <span style="font-style:italic">v</span> et <span style="font-style:italic">Q</span> par <span style="font-style:italic">Q</span> + <span style="font-style:italic">u</span>, passer à l’itération
suivante.
</li></ul>
</li></ol><p>
<span style="font-weight:bold">Exemple</span>:</p><p><span style="font-style:italic">F</span> = (( <span style="font-style:italic">x</span> + 1 ) <span style="font-style:italic">y</span> + <span style="font-style:italic">x</span><sup>2</sup> + 1 ) ( <span style="font-style:italic">y</span><sup>2</sup> + <span style="font-style:italic">x</span> <span style="font-style:italic">y</span> + 1 ), <span style="font-style:italic">G</span> = (( <span style="font-style:italic">x</span> + 1 ) <span style="font-style:italic">y</span> + <span style="font-style:italic">x</span><sup>2</sup> + 1 )
( <span style="font-style:italic">y</span><sup>2</sup> − <span style="font-style:italic">x</span> <span style="font-style:italic">y</span> − 1 )</p><p>On a <span style="font-style:italic">F</span> ( 0, <span style="font-style:italic">y</span> ) = ( <span style="font-style:italic">y</span> + 1 ) ( <span style="font-style:italic">y</span><sup>2</sup> + 1 ) et <span style="font-style:italic">G</span> ( 0, <span style="font-style:italic">y</span> ) = ( <span style="font-style:italic">y</span> + 1 ) ( <span style="font-style:italic">y</span><sup>2</sup> − 1
), le pgcd est donc <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> = ( <span style="font-style:italic">y</span> + 1 ). On remarque que <span style="font-style:italic">D</span><sub><span style="font-style:italic">b</span></sub> est premier avec
le cofacteur de <span style="font-style:italic">F</span> mais pas avec le cofacteur de <span style="font-style:italic">G</span>. Si on évalue en un
autre point, par exemple <span style="font-style:italic">x</span> = 1, on trouve un pgcd <span style="font-style:italic">D</span><sub>1</sub> de même degré, donc
0 est vraissemblablement un bon point d’évaluation (ici on en est sûr puisque
le pgcd de <span style="font-style:italic">F</span> et <span style="font-style:italic">G</span> se calcule à vue...). On a lcoeff ( <span style="font-style:italic">F</span> ) = <span style="font-style:italic">x</span> +
1, on va donc lifter <span style="font-style:italic">G</span> = (( <span style="font-style:italic">x</span> + 1 ) <span style="font-style:italic">y</span> + <span style="font-style:italic">x</span><sup>2</sup> + 1 ) ( <span style="font-style:italic">y</span><sup>2</sup> + <span style="font-style:italic">x</span> <span style="font-style:italic">y</span> + 1 ) ( <span style="font-style:italic">x</span> + 1
) = <span style="font-style:italic">P</span> <span style="font-style:italic">Q</span> où <span style="font-style:italic">P</span><sub>0</sub> = ( <span style="font-style:italic">y</span> + 1 ) et <span style="font-style:italic">Q</span><sub>0</sub> = ( <span style="font-style:italic">y</span><sup>2</sup> + 1 ).</p><p>On calcule les polynômes de l’identité de Bézout <span style="font-style:italic">U</span> = ( 1 − <span style="font-style:italic">y</span> ) et <span style="font-style:italic">V</span> = 1
avec <span style="font-style:italic">d</span> = 2, puis à l’ordre <span style="font-style:italic">k</span> = 1:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">H</span> = <span style="font-style:italic">G</span> − <span style="font-style:italic">P</span><sub>0</sub> <span style="font-style:italic">Q</span><sub>0</sub> = ( 2 <span style="font-style:italic">y</span><sup>3</sup> + 2 <span style="font-style:italic">y</span><sup>2</sup> + 3 <span style="font-style:italic">y</span> + 1 ) <span style="font-style:italic">x</span> + <span style="font-style:italic">O</span> ( 2 ) </td></tr>
</table><p>
donc <span style="font-style:italic">u</span> = reste ( <span style="font-style:italic">U</span> <span style="font-style:italic">H</span> / <span style="font-style:italic">d</span>, <span style="font-style:italic">Q</span><sub>0</sub> ) = <span style="font-style:italic">x</span> <span style="font-style:italic">y</span> et <span style="font-style:italic">v</span> = reste ( <span style="font-style:italic">V</span> <span style="font-style:italic">H</span> / <span style="font-style:italic">d</span>,
<span style="font-style:italic">P</span><sub>0</sub> ) = − <span style="font-style:italic">x</span>.</p><p>Donc <span style="font-style:italic">Q</span><sub>1</sub> = <span style="font-style:italic">x</span> <span style="font-style:italic">y</span> + α <span style="font-style:italic">Q</span><sub>0</sub> avec α = ( <span style="font-style:italic">x</span> + 1 − 1 ) / lcoeff (
<span style="font-style:italic">P</span><sub>0</sub> ) = <span style="font-style:italic">x</span> et <span style="font-style:italic">Q</span><sub>0</sub> + <span style="font-style:italic">Q</span><sub>1</sub> = ( <span style="font-style:italic">y</span><sup>2</sup> + 1 ) ( <span style="font-style:italic">x</span> + 1 ) + <span style="font-style:italic">x</span> <span style="font-style:italic">y</span>. De
même, <span style="font-style:italic">P</span><sub>1</sub> = − <span style="font-style:italic">x</span> + β <span style="font-style:italic">P</span><sub>0</sub>, avec β = ( <span style="font-style:italic">x</span> + 1 − 1 ) / lcoeff (
<span style="font-style:italic">P</span><sub>0</sub> ) = <span style="font-style:italic">x</span> donc <span style="font-style:italic">P</span><sub>0</sub> + <span style="font-style:italic">P</span><sub>1</sub> = ( <span style="font-style:italic">y</span> + 1 ) ( <span style="font-style:italic">x</span> + 1 ) − <span style="font-style:italic">x</span>. On remarque que <span style="font-style:italic">P</span><sub>0</sub> +
<span style="font-style:italic">P</span><sub>1</sub> et <span style="font-style:italic">Q</span><sub>0</sub> + <span style="font-style:italic">Q</span><sub>1</sub> sont bien à <span style="font-style:italic">O</span> ( 2 ) près les facteurs de <span style="font-style:italic">F</span>
lcoeff ( <span style="font-style:italic">F</span> ):
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span> = ( <span style="font-style:italic">x</span> + 1 ) <span style="font-style:italic">y</span> + <span style="font-style:italic">x</span><sup>2</sup> + 1 = <span style="font-style:italic">P</span><sub>0</sub> + <span style="font-style:italic">P</span><sub>1</sub> + <span style="font-style:italic">O</span> ( 2 ),  <span style="font-style:italic">Q</span> = ( <span style="font-style:italic">x</span> +
1 ) ( <span style="font-style:italic">y</span><sup>2</sup> + <span style="font-style:italic">x</span> <span style="font-style:italic">y</span> + 1 ) = <span style="font-style:italic">Q</span><sub>0</sub> + <span style="font-style:italic">Q</span><sub>1</sub> + <span style="font-style:italic">O</span> ( 2 ) </td></tr>
</table><p>
Une deuxième itération est nécessaire. On calcule
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">H</span> = <span style="font-style:italic">G</span> − ( <span style="font-style:italic">P</span><sub>0</sub> + <span style="font-style:italic">P</span><sub>1</sub> ) ( <span style="font-style:italic">Q</span><sub>0</sub> + <span style="font-style:italic">Q</span><sub>1</sub> ) = ( 2 <span style="font-style:italic">y</span><sup>2</sup> + <span style="font-style:italic">y</span> + 1 ) <span style="font-style:italic">x</span><sup>2</sup> + <span style="font-style:italic">O</span> ( 3
) </td></tr>
</table><p>
puis reste ( <span style="font-style:italic">U</span> <span style="font-style:italic">H</span> / <span style="font-style:italic">d</span>, <span style="font-style:italic">Q</span><sub>0</sub> ) = <span style="font-style:italic">y</span> <span style="font-style:italic">x</span><sup>2</sup> et reste ( <span style="font-style:italic">V</span> <span style="font-style:italic">H</span> / <span style="font-style:italic">d</span>, <span style="font-style:italic">P</span><sub>0</sub> )
= <span style="font-style:italic">x</span><sup>2</sup>. Ici les coefficients α et β sont nuls car lcoeff
( <span style="font-style:italic">F</span> ) n’a pas de partie homogène de degré 2. On trouve alors <span style="font-style:italic">P</span> = <span style="font-style:italic">P</span><sub>0</sub> + <span style="font-style:italic">P</span><sub>1</sub> +
<span style="font-style:italic">P</span><sub>2</sub> et <span style="font-style:italic">Q</span> = <span style="font-style:italic">Q</span><sub>0</sub> + <span style="font-style:italic">Q</span><sub>1</sub> + <span style="font-style:italic">Q</span><sub>2</sub>. Pour calculer le pgcd, il suffit de calculer la
partie primitive de <span style="font-style:italic">P</span> vu comme polynôme en <span style="font-style:italic">y</span>, ici c’est encore <span style="font-style:italic">P</span> car le
contenu de <span style="font-style:italic">P</span> est 1 (remarque: pour <span style="font-style:italic">Q</span> le contenu est <span style="font-style:italic">x</span> + 1).<br>
On trouve donc <span style="font-style:italic">P</span> comme pgcd.</p>
<!--TOC subsection id="sec54" Quel algorithme choisir?-->
<h3 id="sec54" class="subsection">5.4  Quel algorithme choisir?</h3><!--SEC END --><p>Il est toujours judicieux de faire une évaluation en quelques <span style="font-style:italic">n</span> − 1 uplets
pour traquer les pgcd triviaux. (E)EZGCD sera efficace si (0,...,0) est un
point de bonne évaluation et si le nombre de remontées nécessaires pour le
lemme de Hensel est petit donc pour les pgcd de petit degré, GCDMOD est aussi
efficace si le degré du pgcd est petit. Le sous-résultant est efficace pour
les pgcd de grand degré car il y a alors peu de divisions euclidiennes à
effectuer et les coefficients n’ont pas trop le temps de croitre. SPMOD est
intéressant pour les polynômes creux de pgcd non trivial creux. GCDHEU est
intéressant pour les problèmes relativement petits.</p><p>Avec des machines multiprocesseurs, on a probablement intérêt à lancer en
parallèle plusieurs algorithmes et à s’arrêter dès que l’un deux recontre le
succès.</p>
<!--TOC subsection id="sec55" Pour en savoir plus.-->
<h3 id="sec55" class="subsection">5.5  Pour en savoir plus.</h3><!--SEC END --><p>
Parmi les références citées dans le premier article, ce sont les livres de
Knuth, H. Cohen, et Davenport-Siret-Tournier qui traitent des algorithmes de
pgcd. On peut bien sûr consulter le source de son système de calcul formel
lorsqu’il est disponible :
</p><ul class="itemize"><li class="li-itemize">
pour MuPAD sur un système Unix, depuis le
répertoire d’installation de MuPAD (en général <span style="font-family:monospace">/usr/local/MuPAD</span>)
après avoir désarchivé le fichier <span style="font-family:monospace">lib.tar</span> du répertoire <span style="font-family:monospace">share/lib</span> 
par la commande <br>
<span style="font-family:monospace">cd share/lib &amp;&amp; tar xvf lib.tar</span><br>
on trouve les algorithmes de calcul de PGCD dans le répertoire <br>
<span style="font-family:monospace">share/lib/lib/POLYLIB/GCD</span>
</li><li class="li-itemize">Pour l’algorithme EZGCD, je me suis inspiré de l’implémentation de 
Singular (logiciel libre disponible à <span style="font-family:monospace">www.singular.uni-kl.de</span>)
</li></ul><p>
Sur le web on trouve quelques articles en lignes sur le
sujet en cherchant les mots clefs GCDHEU, EZGCD, SPMOD sur un moteur de 
recherche, il y a par exemple une description un peu différente du pgcd
heuristique sur:<br>
<span style="font-family:monospace">www.inf.ethz.ch/personal/gonnet/CAII/HeuristicAlgorithms/node1.html</span><br>
et un article de comparaison de ces algorithmes 
par Fateman et Liao (dont la référence bibliographique est
Evaluation of the heuristic polynomial GCD.
in: ISSAC pages 240–247, 1995). Quelques autres références :
</p><ul class="itemize"><li class="li-itemize">
K.O.Geddes et al "Alg. for Computer Algebra", Kluwer 1992.
</li><li class="li-itemize">pour GCDHEU Char, Geddes, Gonnet, 
Gcdheu: Heuristic polynomial gcd algorithm based on integer gcd computation,
in: Journal of Symbolic Computation, 7:31–48, 1989.
</li><li class="li-itemize">pour SPMOD "Probabilistic Algorithms for Sparse Polynomials",
in: Symbolic &amp; Algebraic Comp. (Ed E.W.Ng), Springer 1979, pp216,
</li></ul>
<!--TOC section id="sec56" Le résultant-->
<h2 id="sec56" class="section">6  Le résultant</h2><!--SEC END --><p> <a id="sec:resultant"></a> <a id="hevea_default60"></a>
</p>
<!--TOC subsection id="sec57" Définition-->
<h3 id="sec57" class="subsection">6.1  Définition</h3><!--SEC END --><p>
Il s’agit d’un point de vue d’algèbre linéaire sur le PGCD. Considérons
deux polynômes <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> à coefficients dans un corps,
de degrés <span style="font-style:italic">p</span> et <span style="font-style:italic">q</span> et de pgcd <span style="font-style:italic">D</span> et 
l’identité de Bézout correspondante :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:bezout"></a>
<span style="font-style:italic">A</span> <span style="font-style:italic">U</span> + <span style="font-style:italic">B</span> <span style="font-style:italic">V</span> =<span style="font-style:italic">D</span>
    (11)</td></tr>
</table><p>
avec degré(<span style="font-style:italic">U</span>)&lt;<span style="font-style:italic">q</span> et degré(<span style="font-style:italic">V</span>)&lt;<span style="font-style:italic">p</span>.
Imaginons qu’on cherche <span style="font-style:italic">U</span> et <span style="font-style:italic">V</span> en oubliant qu’il s’agit d’une
identité de Bézout, en considérant simplement qu’il s’agit d’un
problème d’algèbre linéaire de <span style="font-style:italic">p</span>+<span style="font-style:italic">q</span> équations (obtenues en développant
et en identifiant chaque puissance de <span style="font-style:italic">X</span> de 0 à <span style="font-style:italic">p</span>+<span style="font-style:italic">q</span>−1) 
à <span style="font-style:italic">p</span>+<span style="font-style:italic">q</span> inconnues (les <span style="font-style:italic">p</span> coefficients de <span style="font-style:italic">V</span> et les <span style="font-style:italic">q</span> coefficients de <span style="font-style:italic">U</span>)
On sait que <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> sont premiers entre eux si et seulement si ce problème
d’algèbre linéaire a une solution pour <span style="font-style:italic">D</span>=1. Donc si le déterminant
du système est non nul, alors <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> sont premiers entre eux.
Réciproquement si <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> sont premiers entre eux, le système a
une solution unique non seulement avec comme second membre 1 mais avec
n’importe quel polynôme de degré inférieur <span style="font-style:italic">p</span>+<span style="font-style:italic">q</span>, donc le
déterminant du système est non nul.</p><p><span style="font-weight:bold">Définition:</span> <br>
On appelle résultant de <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> le déterminant de ce système 
(<a href="#eq%3Abezout">11</a>). Il s’annule si et seulement si <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span>
ne sont pas premiers entre eux (ont au moins une racine commune).
On appelle <span style="font-weight:bold">matrice de Sylvester</span><a id="hevea_default61"></a> la transposée de la matrice du système
(les inconnues étant par ordre décroissant les coefficients de <span style="font-style:italic">U</span>
et <span style="font-style:italic">V</span>)
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">M</span>(<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>)=</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span><sub><span style="font-style:italic">a</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span><sub><span style="font-style:italic">a</span>−1</sub></td><td style="text-align:center;white-space:nowrap" >…</td><td style="text-align:center;white-space:nowrap" >…</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span><sub>0</sub></td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >…</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span><sub><span style="font-style:italic">a</span></sub></td><td style="text-align:center;white-space:nowrap" >…</td><td style="text-align:center;white-space:nowrap" >…</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span><sub>1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span><sub>0</sub></td><td style="text-align:center;white-space:nowrap" >…</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >⋮ </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >…</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span><sub>0</sub> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span><sub><span style="font-style:italic">b</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span><sub><span style="font-style:italic">b</span>−1</sub></td><td style="text-align:center;white-space:nowrap" >…</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span><sub>0</sub></td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >…</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >⋮ </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >…</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span><sub>0</sub> 
</td></tr>
</table></td><td class="dcell">
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
(cette matrice contient <span style="font-style:italic">b</span>=degré(<span style="font-style:italic">B</span>) lignes de coefficients
du polynôme <span style="font-style:italic">A</span> et <span style="font-style:italic">a</span>=degré(<span style="font-style:italic">A</span>) lignes de coefficients du
polynôme <span style="font-style:italic">B</span>, les coefficients diagonaux sont les <span style="font-style:italic">A</span><sub><span style="font-style:italic">a</span></sub> et <span style="font-style:italic">B</span><sub>0</sub>)</p><p><span style="font-weight:bold">Remarques</span><br>
Le résultant s’exprime polynomialement en fonction
des coefficients des polynômes <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> donc aussi en fonction
des coefficients dominants de <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> et des racines 
α<sub>1</sub>,..., α<sub><span style="font-style:italic">a</span></sub> de <span style="font-style:italic">A</span> et β<sub>1</sub>,...,β<sub><span style="font-style:italic">b</span></sub> <span style="font-style:italic">B</span>,
or si on fait varier les racines de <span style="font-style:italic">B</span> on annulera le résultant
si l’une d’elle coincide avec une racine de <span style="font-style:italic">A</span>, ceci montre
que le résultant est divisible par le produit des 
différences des racines β<sub><span style="font-style:italic">j</span></sub>−α<sub><span style="font-style:italic">i</span></sub> de <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span>. 
On montre que le quotient 
est <span style="font-style:italic">A</span><sub><span style="font-style:italic">a</span></sub><sup><span style="font-style:italic">b</span></sup> <span style="font-style:italic">B</span><sub><span style="font-style:italic">b</span></sub><sup><span style="font-style:italic">a</span></sup> en regardant le coefficient
dominant du résultant en degré total par rapport aux β<sub><span style="font-style:italic">j</span></sub> :
dans le déterminant il faut prendre le produit des termes diagonaux
pour avoir le degré maximal en les β<sub><span style="font-style:italic">j</span></sub>.
On peut aussi l’écrire sous la forme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">resultant(<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>)=<span style="font-style:italic">A</span><sub><span style="font-style:italic">a</span></sub><sup><span style="font-style:italic">b</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">B</span>(α<sub><span style="font-style:italic">i</span></sub>)</td></tr>
</table><p>Soit <span style="font-style:italic">P</span> un polynôme de degré <span style="font-style:italic">n</span> et coefficient dominant <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub>.
Le coefficient dominant de <span style="font-style:italic">P</span>′ est <span style="font-style:italic">np</span><sub><span style="font-style:italic">n</span></sub>, un multiple de <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub>, 
le résultant de <span style="font-style:italic">P</span> et <span style="font-style:italic">P</span>′ est donc divisible
par <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub>, on appelle le quotient
<span style="font-weight:bold">discriminant</span><a id="hevea_default62"></a>. En terme des racines <span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span></sub> de <span style="font-style:italic">P</span>, on a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">disc(<span style="font-style:italic">P</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">resultant(<span style="font-style:italic">P</span>,<span style="font-style:italic">P</span>′)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">
=<span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub><sup><span style="font-style:italic">n</span>−2</sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">P</span>′(<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span></sub>) = <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub><sup>2<span style="font-style:italic">n</span>−2</sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center">1≤ <span style="font-style:italic">i</span>&lt;<span style="font-style:italic">j</span>≤ <span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span></sub>−<span style="font-style:italic">r</span><sub><span style="font-style:italic">j</span></sub>)<sup>2</sup></td></tr>
</table><p>
Ce résultat a un intérêt pour par exemple minorer à priori l’écart entre
2 racines d’un polynôme à coefficients entiers.</p>
<!--TOC subsection id="sec58" Applications-->
<h3 id="sec58" class="subsection">6.2  Applications</h3><!--SEC END --><p>
Revenons au cas où nos polynômes sont à coefficients dans un
anneau contenu dans un corps, par exemple ℤ ∈ ℚ ou un anneau 
de polynômes ℤ[<span style="font-style:italic">X</span><sub>2</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>]  dans son corps de fractions.
On remarque alors que l’équation :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">AU</span>+<span style="font-style:italic">BV</span>=<span style="font-style:italic">C</span></td></tr>
</table><p>
a une solution dans l’anneau si <span style="font-style:italic">C</span> est le résultant <span style="font-style:italic">r</span>
de <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> (ou un multiple). En effet, on écrit les solutions comme 
celles d’un système de Cramer, le dénominateur
de chaque inconnue est <span style="font-style:italic">r</span>, le numérateur 
est un déterminant ayant les coefficients de <span style="font-style:italic">C</span> dans une
des colonnes, on peut donc y factoriser <span style="font-style:italic">r</span> et simplifier.
On peut le voir directement à partir de la définition du
résultant en effectuant sur le déterminant
une manipulation de colonnes sur la dernière colonne,
on ajoute à cette dernière colonne <span style="font-style:italic">x</span> fois l’avant-dernière,
<span style="font-style:italic">x</span><sup>2</sup> fois l’avant-avant-dernière etc... La dernière colonne
devient 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">x</span><sup><span style="font-style:italic">b</span>−1</sup> <span style="font-style:italic">A</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">x</span><sup><span style="font-style:italic">a</span>−1</sup> <span style="font-style:italic">B</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >...</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span>
</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
et en développant le déterminant par rapport à cette 
dernière colonne, on obtient l’identité de Bézout.</p><p><span style="font-weight:bold">Exemple</span> : le résultant de <span style="font-style:italic">x</span>+1 et <span style="font-style:italic">x</span>−1 est 2, donc l’équation
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">x</span>+1)<span style="font-style:italic">U</span>+(<span style="font-style:italic">x</span>−1)<span style="font-style:italic">V</span>=2</td></tr>
</table><p> a une solution <span style="font-style:italic">U</span>=1 et <span style="font-style:italic">V</span>=−1 dans ℤ[<span style="font-style:italic">X</span>],
par contre </p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">x</span>+1)<span style="font-style:italic">U</span>+(<span style="font-style:italic">x</span>−1)<span style="font-style:italic">V</span>=1</td></tr>
</table><p> n’a pas de solution dans ℤ[<span style="font-style:italic">X</span>].</p>
<!--TOC subsubsection id="sec59" Systèmes polynomiaux-->
<h4 id="sec59" class="subsubsection">6.2.1  Systèmes polynomiaux</h4><!--SEC END --><p>
Ceci peut servir à éliminer des inconnues lorsqu’on résoud un
système d’équations polynomiales :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub>1</sub>(<span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>)=0, ..., <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>)=0</td></tr>
</table><p>
On pose 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub>1</sub><sup>1</sup>(<span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub>)=resultant(<span style="font-style:italic">P</span><sub>1</sub>,<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>), ..., 
<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub><sup>1</sup>(<span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub>)=resultant(<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>,<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>)
</td></tr>
</table><p>
Comme <span style="font-style:italic">P</span><sub>1</sub><sup>1</sup>, <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub><sup>1</sup>, ... sont des combinaisons linéaires des
polynômes de départ à coefficients dans l’anneau, si
(<span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>)
est solution du système de départ, alors <span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub>
est solution du deuxième système.
On élimine ainsi les variables les unes après les autres,
pour se ramener à une seule équation polynomiale <span style="font-style:italic">P</span><sub>1</sub><sup><span style="font-style:italic">n</span>−1</sup>(<span style="font-style:italic">X</span><sub>1</sub>)=0, dont on
cherche les racines, puis si <span style="font-style:italic">r</span><sub>1</sub> est une racine de <span style="font-style:italic">P</span><sub>1</sub><sup><span style="font-style:italic">n</span>−1</sup>, on
remonte au système précédent <span style="font-style:italic">P</span><sub>1</sub><sup><span style="font-style:italic">n</span>−2</sup>(<span style="font-style:italic">r</span><sub>1</sub>,<span style="font-style:italic">X</span><sub>2</sub>)=0,
<span style="font-style:italic">P</span><sub>2</sub><sup><span style="font-style:italic">n</span>−2</sup>(<span style="font-style:italic">r</span><sub>1</sub>,<span style="font-style:italic">X</span><sub>2</sub>)=0, que l’on résoud en cherchant
les racines de gcd(<span style="font-style:italic">P</span><sub>1</sub><sup><span style="font-style:italic">n</span>−2</sup>(<span style="font-style:italic">r</span><sub>1</sub>,<span style="font-style:italic">X</span><sub>2</sub>),<span style="font-style:italic">P</span><sub>2</sub><sup><span style="font-style:italic">n</span>−2</sup>(<span style="font-style:italic">r</span><sub>1</sub>,<span style="font-style:italic">X</span><sub>2</sub>)), et ainsi
de suite jusqu’au système de départ.</p><p>Lors des calculs de résultant, il peut arriver que le résultat
soit nul si les arguments ne sont pas premiers entre eux, dans
ce cas il faut diviser par le PGCD de ces 2 polynômes et traiter le cas
du PGCD à part.</p><p>Malheureusement, les calculs de résultant deviennent vite
impraticables (cf. infra), on ne peut guère traiter par cette méthode
que des systèmes 3x3 (ou 4x4 si on est patient). Pour
des systèmes plus ambitieux, on utilisera plutôt un
calcul de bases de Groebner. Mais le résultant est très bien
adapté par exemple à la recherche d’équations cartésiennes
d’une courbe ou surface paramétrée par des fractions rationnelles.</p>
<!--TOC subsubsection id="sec60" Identité de Bézout dans ℤ[<span style="font-style:italic">X</span>].-->
<h4 id="sec60" class="subsubsection">6.2.2  Identité de Bézout dans ℤ[<span style="font-style:italic">X</span>].</h4><!--SEC END --><p>
Lorsque les polynômes <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> sont à coefficients entiers,
on peut résoudre l’identité de Bézout en résolvant le
système linéaire <span style="font-style:italic">AU</span>+<span style="font-style:italic">BV</span>=<span style="font-style:italic">D</span> où <span style="font-style:italic">D</span> est calculé par
un algorithme de calcul de PGCD. C’est un système linéaire
de <span style="font-style:italic">a</span>+<span style="font-style:italic">b</span> équations en <span style="font-style:italic">a</span>+<span style="font-style:italic">b</span> inconnues, que l’on peut résoudre
par une méthode <span style="font-style:italic">p</span>-adique, permettant de calculer efficacement
les coefficients rationnels de <span style="font-style:italic">U</span> et <span style="font-style:italic">V</span>.</p><p>On peut étendre à des polynômes premiers entre eux ayant des coefficients
dans une extension algébrique de ℚ, en calculant l’identité
de Bézout pour Ã=norme(<span style="font-style:italic">A</span>) et 
B=norme(<span style="font-style:italic">B</span>) (norme au sens de norme
algébrique, obtenue en multipliant par les conjugués du
polynôme, calculé en pratique en prenant le résultant
du polynôme avec le polynôme minimal de l’extension
algébrique) et en observant que
la norme est divisible par le polynôme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">Ã Ũ+BṼ=1
⇒ <span style="font-style:italic">A</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Ã</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell"> Ũ+ 
<span style="font-style:italic">B</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">B</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell">Ṽ=1</td></tr>
</table><p>
On pose alors <span style="font-style:italic">u</span> le reste de  Ã/<span style="font-style:italic">A</span> Ũ par <span style="font-style:italic">B</span>
et <span style="font-style:italic">v</span> le reste de B/<span style="font-style:italic">B</span>Ṽ par <span style="font-style:italic">A</span>.
Si les polynômes ne sont pas premiers entre eux, on s’y ramène
en divisant par leur pgcd.</p>
<!--TOC subsection id="sec61" Résultant et degrés-->
<h3 id="sec61" class="subsection">6.3  Résultant et degrés</h3><!--SEC END --><p>
Si <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> sont des polynômes en <span style="font-style:italic">d</span> variables de degré
total <span style="font-style:italic">m</span> et <span style="font-style:italic">n</span> alors le résultant de <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> par rapport à
une des variables, disons la première notée <span style="font-style:italic">x</span>,
est un polynôme en <span style="font-style:italic">d</span>−1 variables, on va voir qu’on peut
majorer son degré total par <span style="font-style:italic">mn</span>.</p><p>Quitte à ajouter une variable d’homogénéisation (appelons-la <span style="font-style:italic">t</span>), on peut
supposer que <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> sont homogènes, par exemple
si <span style="font-style:italic">A</span>=<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">xy</span>+1 on considère <span style="font-style:italic">A</span><sub><span style="font-style:italic">t</span></sub>=<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">xyt</span>+<span style="font-style:italic">t</span><sup>3</sup>. Le degré total 
par rapport aux <span style="font-style:italic">d</span>−1 variables d’un
coefficient <span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub> de <span style="font-style:italic">A</span> est alors <span style="font-style:italic">m</span>−<span style="font-style:italic">j</span>, et pour <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub> c’est <span style="font-style:italic">n</span>−<span style="font-style:italic">k</span>.
On développe le déterminant comme somme sur toutes les
permutations de <span style="font-style:italic">a</span>+<span style="font-style:italic">b</span> éléments, et on regarde le degré
total d’un terme par rapport aux <span style="font-style:italic">d</span>−1 variables, on a donc
un produit de <span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span> σ(<span style="font-style:italic">i</span>)</sub> pour <span style="font-style:italic">i</span> entre 1 et <span style="font-style:italic">a</span>+<span style="font-style:italic">b</span>. Pour <span style="font-style:italic">i</span>
entre 1 et <span style="font-style:italic">b</span>, on est dans les <span style="font-style:italic">b</span> premières lignes, donc
avec des coefficients de <span style="font-style:italic">A</span>, le degré total de <span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span> σ<sub><span style="font-style:italic">i</span></sub></sub>
se déduit de la distance à la diagonale, il vaut
<span style="font-style:italic">m</span>−<span style="font-style:italic">a</span>+σ<sub><span style="font-style:italic">i</span></sub>−<span style="font-style:italic">i</span> puisque sur la diagonale c’est <span style="font-style:italic">m</span>−<span style="font-style:italic">a</span>.
Pour <span style="font-style:italic">i</span> entre <span style="font-style:italic">b</span>+1 et <span style="font-style:italic">b</span>+<span style="font-style:italic">a</span> on est dans les <span style="font-style:italic">a</span> dernières
lignes, donc avec des coefficients de <span style="font-style:italic">B</span>, le degré total est
<span style="font-style:italic">n</span>+σ<sub><span style="font-style:italic">i</span></sub>−<span style="font-style:italic">i</span>. Le degré total du produit vaut donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">b</span>(<span style="font-style:italic">m</span>−<span style="font-style:italic">a</span>)+<span style="font-style:italic">an</span>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>+<span style="font-style:italic">b</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=1</td></tr>
</table></td><td class="dcell"> σ<sub><span style="font-style:italic">i</span></sub> −<span style="font-style:italic">i</span> = <span style="font-style:italic">b</span>(<span style="font-style:italic">m</span>−<span style="font-style:italic">a</span>)+<span style="font-style:italic">an</span>=<span style="font-style:italic">mn</span>−(<span style="font-style:italic">m</span>−<span style="font-style:italic">a</span>)(<span style="font-style:italic">n</span>−<span style="font-style:italic">b</span>)</td></tr>
</table><p>
il est donc au plus <span style="font-style:italic">mn</span> avec égalité si <span style="font-style:italic">m</span>=<span style="font-style:italic">a</span> ou <span style="font-style:italic">n</span>=<span style="font-style:italic">b</span>
(c’est-à-dire si le degré total est identique au degré partiel
en <span style="font-style:italic">x</span> pour au moins un des deux polynômes).</p><p>Lorsqu’on enlève la variable d’homogénéisation (en posant
<span style="font-style:italic">t</span>=1), on peut également perdre un ou plusieurs degrés. Dans le
cas de polynômes en 2 variables <span style="font-style:italic">A</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>), <span style="font-style:italic">B</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>), cela correspond à un point
d’intersection à l’infini entre les 2 courbes <span style="font-style:italic">A</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)=<span style="font-style:italic">B</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)=0, en
coordonnées homogènes on a <span style="font-style:italic">t</span>=0 qui est solution, et on remplace
<span style="font-style:italic">t</span> par 0 dans <span style="font-style:italic">A</span><sub><span style="font-style:italic">t</span></sub>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>,<span style="font-style:italic">t</span>)=<span style="font-style:italic">B</span><sub><span style="font-style:italic">t</span></sub>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>,<span style="font-style:italic">t</span>)=0 pour trouver la direction.</p><p>Exemple (tiré d’un TP de Frédéric Han)
intersection des 2 courbes <span style="font-style:italic">x</span>*<span style="font-style:italic">y</span>=4 et <span style="font-style:italic">y</span><sup>2</sup>=(<span style="font-style:italic">x</span>−3)*(<span style="font-style:italic">x</span><sup>2</sup>−16).
On a donc <span style="font-style:italic">A</span>=<span style="font-style:italic">xy</span>−4, 
<span style="font-style:italic">B</span>=<span style="font-style:italic">y</span><sup>2</sup>−(<span style="font-style:italic">x</span>−3)(<span style="font-style:italic">x</span><sup>2</sup>−16), <span style="font-style:italic">m</span>=2, <span style="font-style:italic">n</span>=3
on définit alors :<br>
<code> A:=x*y-4t^2; B:=y^2*t-(x-3t)*(x^2-16t^2);</code><br>
On observe que <code>resultant(A,B,x)</code> est bien de degré 6 (car
<span style="font-style:italic">n</span>=<span style="font-style:italic">b</span>=3), alors que <code>resultant(A,B,y)</code> est de degré 5 (<span style="font-style:italic">m</span> ≠
<span style="font-style:italic">a</span>, <span style="font-style:italic">n</span> ≠ <span style="font-style:italic">b</span>).
On a donc 5 points d’intersection complexes et un point d’intersection
à l’infini correspondant à la racine <span style="font-style:italic">t</span>=0 du résultant en <span style="font-style:italic">x</span> 
de coordonnées homogènes
(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>,<span style="font-style:italic">t</span>)=(0,1,0). Illustration<br>
<code>solve(subst(resultant(A,B,y),t=1))</code><br>
<code>implicitplot(subst(A,t=1));implicitplot(subst(B,t=1))</code></p><p>Plus généralement, soit deux courbes algébriques d’équations respectives
<span style="font-style:italic">A</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)=0 et <span style="font-style:italic">B</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)=0 de degré totaux <span style="font-style:italic">m</span> et <span style="font-style:italic">n</span> et premiers
entre eux, alors <span style="font-style:italic">A</span> et
<span style="font-style:italic">B</span> ont au plus <span style="font-style:italic">mn</span> points d’intersection<a id="hevea_default63"></a> 
(<span style="font-weight:bold">théorème de Bézout</span><a id="hevea_default64"></a>). 
En effet, le résultant
en <span style="font-style:italic">x</span> par exemple est non nul puisque les 2 polynômes sont premiers
entre eux, donc est un polynôme en <span style="font-style:italic">y</span> qui a un nombre fini de
racines, puis on cherche les racines en <span style="font-style:italic">x</span> de gcd(<span style="font-style:italic">A</span>(.,<span style="font-style:italic">y</span>),<span style="font-style:italic">B</span>(.,<span style="font-style:italic">y</span>))
pour chaque valeur de <span style="font-style:italic">y</span> racine, il y a donc un nombre fini
d’intersections. On peut donc changer de repère et choisir un
repère tel que deux points d’intersections distincts aient leurs
abscisses distinctes. On refait le même
raisonnement, et on utilise la majoration du degré du résultant
par rapport à <span style="font-style:italic">y</span> par <span style="font-style:italic">mn</span>, on a donc au plus <span style="font-style:italic">mn</span> valeurs
de <span style="font-style:italic">y</span>, donc au plus <span style="font-style:italic">mn</span> points d’intersections, puisqu’une valeur
de <span style="font-style:italic">y</span> ne correspond qu’à une valeur de <span style="font-style:italic">x</span> par choix du repère.
Lorsqu’on travaille dans ℂ<sup>2</sup>, le défaut de nombre de points
d’intersection par rapport au majorant <span style="font-style:italic">mn</span> provient des points à
l’infini, à condition de prendre en compte la multiplicité des
intersections. Dans ℝ<sup>2</sup>, on perd aussi les points non réels.
Exemple : intersection de (<span style="font-style:italic">x</span>−2)<sup>2</sup>+<span style="font-style:italic">y</span><sup>2</sup>=4 et <span style="font-style:italic">y</span><sup>2</sup>=(<span style="font-style:italic">x</span>−3)*(<span style="font-style:italic">x</span><sup>2</sup>−16).</p><p>Le degré du résultant explique pourquoi on ne peut pas résoudre
en pratique de grands systèmes polynomiaux avec cet outil
d’élimination.
Par exemple pour un système de 5 équations en 5 inconnues de
degré 5, en éliminant une variable, on passe à 4 équation en
4 inconnues de degré 25, puis à 3 équations en 3 inconnues
de degré 25<sup>2</sup>=625, puis 2 équations en 2 inconnues de
degré 625<sup>2</sup>=390625 et enfin un polynôme de degré ...
152587890625. Pour <span style="font-style:italic">n</span> équations de degré <span style="font-style:italic">n</span>, on a une majoration
par <span style="font-style:italic">n</span><sup>(2<sup><span style="font-style:italic">n</span>−1</sup>)</sup>, ainsi pour <span style="font-style:italic">n</span>=4 on trouve 65536 qui est déjà discutable...</p>
<!--TOC subsection id="sec62" Lien avec l’algorithme du sous-résultant (calcul de PGCD)-->
<h3 id="sec62" class="subsection">6.4  Lien avec l’algorithme du sous-résultant (calcul de PGCD)</h3><!--SEC END --><p>
On peut calculer le déterminant avec la suite des restes de divisions
euclidiennes de la manière suivante, on part de la pseudo-division
de <span style="font-style:italic">A</span> par <span style="font-style:italic">B</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">B</span><sub><span style="font-style:italic">b</span></sub><sup><span style="font-style:italic">a</span>−<span style="font-style:italic">b</span>+1</sup> <span style="font-style:italic">A</span>=<span style="font-style:italic">BQ</span>+<span style="font-style:italic">R</span> </td></tr>
</table><p>
on effectue alors sur chaque ligne contenant les coefficients de <span style="font-style:italic">A</span>
la manipulation de ligne correspondante, c’est-à-dire multiplier
la ligne par <span style="font-style:italic">B</span><sub><span style="font-style:italic">b</span></sub><sup><span style="font-style:italic">a</span>−<span style="font-style:italic">b</span>+1</sup> et soustraire (<span style="font-style:italic">q</span><sub>0</sub> fois la ligne
de <span style="font-style:italic">B</span> terminant dans la même colonne+<span style="font-style:italic">q</span><sub>1</sub> fois la ligne
de <span style="font-style:italic">B</span> terminant une colonne avant+...). Toutes les lignes
contenant les coefficients de <span style="font-style:italic">A</span> ont été remplacées par des lignes 
contenant les coefficients de <span style="font-style:italic">R</span>. Ces lignes contiennent <span style="font-style:italic">k</span> zéros initiaux
avec <span style="font-style:italic">k</span> ≥ 1, ce qui permet de réduire le déterminant à celui
de la matrice de Sylvester de <span style="font-style:italic">R</span> et <span style="font-style:italic">B</span> (à un coefficient multiplicatif
près qui vaut <span style="font-style:italic">B</span><sub><span style="font-style:italic">b</span></sub><sup><span style="font-style:italic">k</span></sup> par rapport au précédent donc
<span style="font-style:italic">B</span><sub><span style="font-style:italic">b</span></sub><sup><span style="font-style:italic">k</span>−<span style="font-style:italic">b</span>(<span style="font-style:italic">a</span>−<span style="font-style:italic">b</span>+1)</sup> par rapport au déterminant de départ). 
On échange ensuite <span style="font-style:italic">R</span> et <span style="font-style:italic">B</span> ce qui change
éventuellement le signe et on continue en faisant les
divisions euclidiennes de l’algorithme du sous-résultant (cf.
Knuth où on utilise la matrice de Sylvester pour prouver que
l’algorithme du sous-résultant est correct). Rappelons que
le sous-résultant définit les suites <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub> (<span style="font-style:italic">A</span><sub>0</sub>=<span style="font-style:italic">A</span>, <span style="font-style:italic">A</span><sub>1</sub>=<span style="font-style:italic">B</span>),
<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub> le degré de <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>, δ<sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>−<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>+1</sub>,
<span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub> (<span style="font-style:italic">g</span><sub>0</sub>=1, si <span style="font-style:italic">k</span>≠ 0, <span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub> coefficient dominant de <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>) 
<span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span></sub> (<span style="font-style:italic">h</span><sub>0</sub>=1, <span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span></sub><sup>1−δ<sub><span style="font-style:italic">k</span></sub></sup> <span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span>+1</sub><sup>δ<sub><span style="font-style:italic">k</span></sub></sup>) et
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub><sup>δ<sub><span style="font-style:italic">k</span>−1</sub>+1</sup> <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−1</sub> = <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span>+1</sub> + 
<span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span>−1</sub> <span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span>−1</sub><sup>δ<sub><span style="font-style:italic">k</span>−1</sub></sup> <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>+1</sub> </td></tr>
</table><div class="theorem"><span style="font-weight:bold">Théorème 10</span>  <em>
Le résultant est égal au signe près au coefficient </em><span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span></sub><em> où </em><span style="font-style:italic">k</span><em>
correspond au reste </em><span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub><em> constant (en supposant que le résultant
soit non nul).
</em></div><p><span style="font-weight:bold">Preuve</span><br>
La transcription de l’égalité précédente sur les
résultants donne par la méthode ci-dessus :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub><sup>(δ<sub><span style="font-style:italic">k</span>−1</sub>+1)<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub></sup>Res(<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−1</sub>,<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>−1</sub>−<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>+1</sub></sup> Res(<span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span>−1</sub> <span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span>−1</sub><sup>δ<sub><span style="font-style:italic">k</span>−1</sub></sup> <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>+1</sub>,<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>−1</sub>−<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>+1</sub></sup> (<span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span>−1</sub> <span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span>−1</sub><sup>δ<sub><span style="font-style:italic">k</span>−1</sub></sup>)<sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub></sup>
Res(<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>+1</sub>,<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>)
</td></tr>
</table></td></tr>
</table><p>
On en déduit que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Res(<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−1</sub>,<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span>−1</sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub></sup> <span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span>−1</sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>−1</sub>−1</sup></td></tr>
</table></td><td class="dcell">
= <span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>−1</sub>−<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>+1</sub>−(δ<sub><span style="font-style:italic">k</span>−1</sub>+1)<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub></sup>  
<span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span>−1</sub><sup>δ<sub><span style="font-style:italic">k</span>−1</sub><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>+1−<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>−1</sub></sup> Res(<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>+1</sub>,<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>) </td></tr>
</table><p>
On observe que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span>−1</sub><sup>δ<sub><span style="font-style:italic">k</span>−1</sub><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>+1−<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>−1</sub></sup> =<span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span>−1</sub><sup>(δ<sub><span style="font-style:italic">k</span>−1</sub>−1)(<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>−1)</sup>
= </td><td class="dcell">⎛<br>
⎝</td><td class="dcell"><span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span>−1</sub><sup>δ<sub><span style="font-style:italic">k</span>−1</sub>−1</sup></td><td class="dcell">⎞<br>
⎠</td><td class="dcell"><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>−1</sup>
= </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub><sup>δ<sub><span style="font-style:italic">k</span>−1</sub></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>−1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td></tr>
</table><p>
donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Res(<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−1</sub>,<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span>−1</sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub></sup> <span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span>−1</sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>−1</sub>−1</sup></td></tr>
</table></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>−1</sub>−<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>+1</sub>−(δ<sub><span style="font-style:italic">k</span>−1</sub>+1)<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub></sup>  
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub><sup>δ<sub><span style="font-style:italic">k</span>−1</sub></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>−1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell"> 
Res(<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>+1</sub>,<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>) </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>−1</sub>−<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>+1</sub>−<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>−δ<sub><span style="font-style:italic">k</span>−1</sub></sup>  
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>−1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell"> 
Res(<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>+1</sub>,<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>) </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center"> Res(<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>+1</sub>,<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>) </td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"> <span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>+1</sub></sup> <span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>−1</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Donc en valeur absolue
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Res(<span style="font-style:italic">A</span><sub>0</sub>,<span style="font-style:italic">A</span><sub>1</sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">g</span><sub>0</sub><sup><span style="font-style:italic">d</span><sub>1</sub></sup> <span style="font-style:italic">h</span><sub>0</sub><sup><span style="font-style:italic">d</span><sub>0</sub>−1</sup></td></tr>
</table></td><td class="dcell">|
= |</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Res(<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−1</sub>,<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span>−1</sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub></sup> <span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span>−1</sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>−1</sub>−1</sup></td></tr>
</table></td><td class="dcell"> |</td></tr>
</table><p>
En prenant le rang <span style="font-style:italic">k</span> tel que <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub> est constant, on a <span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>=0
et le résultant est égal à <span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>−1</sub></sup>, on obtient donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|Res(<span style="font-style:italic">A</span><sub>0</sub>,<span style="font-style:italic">A</span><sub>1</sub>)|=|</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>−1</sub></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"> <span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span>−1</sub><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>−1</sub>−1</sup></td></tr>
</table></td><td class="dcell"> |
</td></tr>
</table><p>
Comme ici δ<sub><span style="font-style:italic">k</span>−1</sub>=<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>−1</sub>, le terme de droite est |<span style="font-style:italic">h</span><sub><span style="font-style:italic">k</span></sub>|.</p><p><span style="font-weight:bold">Remarque</span><br>
On peut calculer au fur et à mesure le signe du résultant en tenant 
compte des degrés de <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub> pour inverser l’ordre de <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>−1</sub> et
<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub> dans le résultant.</p><p><span style="font-weight:bold">Utilisation</span><br>
La valeur du résultant est très utile pour savoir si 2 polynômes
dépendant de paramètres sont premiers entre eux en fonction
de la valeur des paramètres. En effet, la fonction <span style="font-family:monospace">gcd</span> d’un
logiciel de calcul formel calculera le PGCD par rapport à toutes
les variables en incluant les paramètres. En cherchant quand le résultant
s’annule en fonction des paramètres on obtient un autre type
d’information.</p><p><span style="font-weight:bold">Exemple :</span><br>
Chercher quand le polynône <span style="font-style:italic">P</span>=<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">px</span>+<span style="font-style:italic">q</span> possède
une racine multiple en fonction de <span style="font-style:italic">p</span> et <span style="font-style:italic">q</span>. On calcule le
résultant de <span style="font-style:italic">P</span> et <span style="font-style:italic">P</span>′ et on trouve 4<span style="font-style:italic">p</span><sup>3</sup>+27<span style="font-style:italic">q</span><sup>2</sup>, donc <span style="font-style:italic">P</span>
a une racine multiple si et seulement si 4<span style="font-style:italic">p</span><sup>3</sup>+27<span style="font-style:italic">q</span><sup>2</sup>=0.</p>
<!--TOC subsection id="sec63" Calcul efficace du résultant-->
<h3 id="sec63" class="subsection">6.5  Calcul efficace du résultant</h3><!--SEC END --><p>
On dispose essentiellement de deux stratégies avec des sous-stratégies :
</p><ul class="itemize"><li class="li-itemize">
Calcul comme un déterminant.
On peut utiliser des méthodes modulaires ou <span style="font-style:italic">p</span>-adiques (par exemple
si <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> sont à coefficients entiers), ou/et de l’interpolation
(si <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> sont à coefficients polynomiaux), ou la méthode
de Gauss-Bareiss, ou le développement de Laplace. Il suffit
de forcer une stratégie dans l’appel à <code>det</code> sur
<code>sylvester(A,B)</code>
</li><li class="li-itemize">Algorithme du sous-résultant<br>
C’est cet algorithme qui est utilisé par Xcas.
Il peut aussi se décliner en méthode modulaire ou avec interpolation.
</li></ul><p>
Exemple de comparaison :<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">n:=100; A:=randpoly(n):; B:=randpoly(n):; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">time(resultant(A,B)); time(det(sylvester(A,B))) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p>
<!--TOC section id="sec64" Localisation des racines-->
<h2 id="sec64" class="section">7  Localisation des racines</h2><!--SEC END --><p> <a id="sec:racines"></a>
</p>
<!--TOC subsection id="sec65" Majoration-->
<h3 id="sec65" class="subsection">7.1  Majoration</h3><!--SEC END --><p>
On a vu au lemme <a href="#lemme%3Amajoration">5</a>, 
que si <span style="font-style:italic">z</span> est une racine complexe d’un polynôme <span style="font-style:italic">P</span> 
de coefficient dominant <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">z</span>| ≤ 1 + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">P</span>|<sub>∞</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub>|</td></tr>
</table></td></tr>
</table>
<!--TOC subsection id="sec66" Les suites de Sturm.-->
<h3 id="sec66" class="subsection">7.2  Les suites de Sturm.</h3><!--SEC END --><p><a id="hevea_default65"></a>
L’algorithme du sous-résultant appliqué à un polynôme sans
racine multiple <span style="font-style:italic">P</span> et à sa dérivée
permet, à condition de changer les signes dans la suite des restes, 
de connaitre le nombre de racines réelles d’un polynôme 
à coefficients réels dans un 
intervalle. Ceci est trè utile pour par exemple simplifier des valeurs
absolues de polynômes dans un intervalle.</p><p>On définit donc la suite de polynômes <span style="font-style:italic">A</span><sub>0</sub>=<span style="font-style:italic">P</span>, <span style="font-style:italic">A</span><sub>1</sub>=<span style="font-style:italic">P</span>′, ..., <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>,0
par :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:sturm"></a>
<span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub> = <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span>+1</sub> <span style="font-style:italic">Q</span><sub><span style="font-style:italic">i</span>+2</sub> − <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span>+2</sub> 
    (12)</td></tr>
</table><p>
avec <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>, le dernier reste non nul, un polynôme constant puisque
<span style="font-style:italic">P</span> n’a pas de racine multiple. On utilise plutot l’algorithme du 
sous-résultant que l’algorithme d’Euclide, il faut alors
s’assurer que les signes de <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub> et <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span>+2</sub> sont opposés lorsque
<span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span>+1</sub>  s’annule quitte à changer le signe de <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span>+2</sub> en fonction
du signe du coefficient dominant de <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span>+1</sub>, de la parité de
la différence des degrés et du signe du coefficient <span style="font-style:italic">gh</span><sup>1−δ</sup>.</p><p>On définit <span style="font-style:italic">s</span>(<span style="font-style:italic">a</span>) comme étant le nombre de changements de signes
de la suite <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub>(<span style="font-style:italic">a</span>) en ignorant les 0.
On a alors le 
</p><div class="theorem"><span style="font-weight:bold">Théorème 11</span>  <em>
Le nombre de racines réelles de </em><span style="font-style:italic">A</span><sub>0</sub>=<span style="font-style:italic">P</span><em> sur l’intervalle
</em>]<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>]<em> est égal à </em><span style="font-style:italic">s</span>(<span style="font-style:italic">a</span>)−<span style="font-style:italic">s</span>(<span style="font-style:italic">b</span>)<em>.
</em></div><p><span style="font-weight:bold">Preuve</span><br>
Par continuité de la suite des polynômes, <span style="font-style:italic">s</span> ne peut varier que
si l’un des polynômes s’annule.
On considére la suite des signes en un point : elle ne peut contenir
deux 0 successifs (sinon toute la suite vaudrait 0 en ce point en appliquant
(<a href="#eq%3Asturm">12</a>), or <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub> est constant non nul). Elle ne peut pas
non plus contenir +,0,+ ni -,0,- à cause de la convention de signe
sur les restes de (<a href="#eq%3Asturm">12</a>). Donc une racine <span style="font-style:italic">b</span>
de <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub> pour 0&lt;<span style="font-style:italic">i</span>&lt;<span style="font-style:italic">k</span>, n’influe pas sur la valeur de <span style="font-style:italic">s</span> au voisinage
de <span style="font-style:italic">b</span> (il y a toujours un changement de signe entre les positions
<span style="font-style:italic">i</span>−1 et <span style="font-style:italic">i</span>+1). Comme <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub> est constant, seules les racines de <span style="font-style:italic">A</span><sub>0</sub>=<span style="font-style:italic">P</span>
sont susceptibles de faire varier <span style="font-style:italic">s</span>. Comme <span style="font-style:italic">A</span><sub>1</sub>=<span style="font-style:italic">P</span>′, le sens de
variations de <span style="font-style:italic">A</span><sub>0</sub> au voisinage d’une racine de <span style="font-style:italic">A</span><sub>0</sub> est déterminé
par le signe de <span style="font-style:italic">A</span><sub>1</sub>, donc les possibilités sont -,+ vers +,+
ou +,- vers -,-, ce qui diminue <span style="font-style:italic">s</span> d’une unité.</p><p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">purge(x);sturmab(x^3+7x-5,0,1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p>
<!--TOC subsection id="sec67" Autres algorithmes-->
<h3 id="sec67" class="subsection">7.3  Autres algorithmes</h3><!--SEC END --><p> <a id="sec:autres_algorithmes"></a>
</p><ul class="itemize"><li class="li-itemize">
On peut localiser les racines réelles par dichotomie : on
sait que toutes les racines sont situées dans l’intervalle
[−<span style="font-style:italic">C</span>,<span style="font-style:italic">C</span>] avec <span style="font-style:italic">C</span>=|<span style="font-style:italic">P</span>|<sub>∞</sub>/|lcoeff(<span style="font-style:italic">P</span>)|. On coupe
l’intervalle en deux, on calcule le nombre de racines
dans chaque partie, et on continue en conservant uniquement
les intervalles contenant au moins une racine. Lorsqu’un
intervalle contient une seule racine, on passe à la dichotomie
classique (changement de signe), ou à la méthode de Newton
(avec évaluation exacte du polymôme et arrondi du dénominateur
à une puissance de 2). C’est ce qui est utilisé par
l’instruction <code>realroot</code> de Giac si on donne en argument
optionnel <code>sturm</code>.
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">realroot(sturm,x^3+7x-5)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
</li><li class="li-itemize">Il existe un autre algorithme de localisation de racines
réelles dû à <span style="font-weight:bold">Vincent, Akritas et 
Strzebonski</span><a id="hevea_default66"></a><a id="hevea_default67"></a><a id="hevea_default68"></a>, cf. la
commande <code>realroot</code> de Xcas qui renvoie des flottants de type intervalle.
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">realroot(x^3+7x-5)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
Cet algorithme est très
efficace pour donner des intervalles 
d’<span style="font-weight:bold">isolation</span><a id="hevea_default69"></a> des racines
(sur lesquels on peut ensuite faire de la dichotomie). 
La base de cet algorithme utilise la règle des signes de
Descartes<a id="hevea_default70"></a> <a id="hevea_default71"></a>
<div class="theorem"><span style="font-weight:bold">Proposition 12</span>  <em>
Soit </em><span style="font-style:italic">P</span>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup>+...+<span style="font-style:italic">a</span><sub>1</sub><span style="font-style:italic">x</span>+<span style="font-style:italic">a</span><sub>0</sub> ∈ ℝ[<span style="font-style:italic">x</span>]<em>, </em><span style="font-style:italic">r</span>(<span style="font-style:italic">P</span>)<em> le nombre de racines de
</em><span style="font-style:italic">P</span><em> sur </em>ℝ<sup>*+</sup><em>, et </em>σ(<span style="font-style:italic">P</span>)<em> le nombre de changements de signe
de la suite des coefficients </em><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>,...,<span style="font-style:italic">a</span><sub>0</sub><em> de </em><span style="font-style:italic">P</span><em>. Alors </em><span style="font-style:italic">r</span>(<span style="font-style:italic">P</span>) ≤ σ(<span style="font-style:italic">P</span>)<em>.
</em></div>
La preuve se fait par récurrence. Pour <span style="font-style:italic">n</span>=0 on a bien 0 ≤ 0.
Pour <span style="font-style:italic">n</span>&gt;0 on applique l’hypothèse de récurrence à <span style="font-style:italic">P</span>′ et on
utilise le fait que 1+le nombre de racines de <span style="font-style:italic">P</span>′ sur un intervalle
]<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>[ est supérieur ou égal au nombre de racines de <span style="font-style:italic">P</span> sur
[<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>]. Il y a deux cas possibles σ(<span style="font-style:italic">P</span>′)=σ(<span style="font-style:italic">P</span>) et
σ(<span style="font-style:italic">P</span>′)=σ(<span style="font-style:italic">P</span>)−1. Dans le deuxième cas, comme <span style="font-style:italic">r</span>(<span style="font-style:italic">P</span>′)+1≥
<span style="font-style:italic">r</span>(<span style="font-style:italic">P</span>), alors <span style="font-style:italic">r</span>(<span style="font-style:italic">P</span>) ≤ <span style="font-style:italic">r</span>(<span style="font-style:italic">P</span>′)+1 ≤ σ(<span style="font-style:italic">P</span>′)+1=σ(<span style="font-style:italic">P</span>). Dans le
premier cas, il faut trouver une racine supplémentaire pour
<span style="font-style:italic">P</span>′. Pour cela, on regarde ce qui se passe en 0<sup>+</sup>. Supposons que
<span style="font-style:italic">a</span><sub>0</sub>&gt;0 pour fixer les idées, comme <span style="font-style:italic">a</span><sub>0</sub> est du même signe
que <span style="font-style:italic">a</span><sub>1</sub> (ou que <span style="font-style:italic">a</span><sub>2</sub> si <span style="font-style:italic">a</span><sub>1</sub>=0 etc.), <span style="font-style:italic">P</span>′ est positif en 0<sup>+</sup>
donc <span style="font-style:italic">P</span> croit en 0<sup>+</sup>, donc doit atteindre un maximum local avant
la première racine de <span style="font-style:italic">P</span>, ce maximum local est une racine de <span style="font-style:italic">P</span>′.<p>On peut même montrer que <span style="font-style:italic">r</span>(<span style="font-style:italic">P</span>) et σ(<span style="font-style:italic">P</span>) sont de même
parité.
L’algorithme VAS utilise ce résultat et des changements de variable
homographique <span style="font-style:italic">x</span> → <span style="font-style:italic">ax</span>+<span style="font-style:italic">b</span>/<span style="font-style:italic">cx</span>+<span style="font-style:italic">d</span> pour isoler les racines.
</p></li><li class="li-itemize">Les suites de Sturm se générallisent dans le plan complexe, on
peut déterminer le nombre de racines contenues dans un
rectangle du plan complexe (cf. par exemple l’article
de Mickael Eiserman sur <code>www-fourier.ujf-grenoble.fr/~eiserm</code>). 
Malheureusement, il faut calculer une nouvelle suite de Sturm
pour chaque rectangle (alors que dans ℝ on peut réutiliser la
même suite de Sturm). Ce qui est donc beaucoup plus couteux,
en pratique on ne peut guère aller au-delà du degré 10 avec
l’instruction <code>complexroot</code> de Giac, analogue de <code>realroot</code>.
</li><li class="li-itemize">Une autre méthode dans le cas complexe, 
consiste à utiliser
un hybride numérique-exact. Les racines d’un polynôme <span style="font-style:italic">Q</span>
sont aussi les valeurs
propres complexes de sa matrice companion <span style="font-style:italic">M</span>. On factorise cette matrice
sous forme de Schur <span style="font-style:italic">M</span>=<span style="font-style:italic">P</span><sup>−1</sup> <span style="font-style:italic">S</span> <span style="font-style:italic">P</span> où <span style="font-style:italic">P</span> est unitaire
et S aux erreurs d’arrondis près diagonale supérieure 
avec éventuellement des blocs de taille
2 dans le cas réel correspondant à des couples de racines
complexes conjuguées<sup><a id="text7" href="#note7">7</a></sup>. On lit alors des valeurs approchées des valeurs
propres de <span style="font-style:italic">M</span> sur la diagonale de <span style="font-style:italic">S</span>. Puis on applique la
<div class="theorem"><span style="font-weight:bold">Proposition 13</span>  <em>
Le disque de centre </em><span style="font-style:italic">z</span><em> et de rayon degre</em>(<span style="font-style:italic">Q</span>) |<span style="font-style:italic">Q</span>(<span style="font-style:italic">z</span>)/<span style="font-style:italic">Q</span>′(<span style="font-style:italic">z</span>)|<em>
contient au moins une racine de </em><span style="font-style:italic">Q</span><em>.
</em></div>
En effet
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Q</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Q</span></td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">z</span>)= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">z</span>−<span style="font-style:italic">z</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td></tr>
</table>
donc si |<span style="font-style:italic">z</span>−<span style="font-style:italic">z</span><sub><span style="font-style:italic">k</span></sub>| &gt; degre(<span style="font-style:italic">Q</span>) |<span style="font-style:italic">Q</span>(<span style="font-style:italic">z</span>)/<span style="font-style:italic">Q</span>′(<span style="font-style:italic">z</span>)| pour toutes les racines <span style="font-style:italic">z</span><sub><span style="font-style:italic">k</span></sub> alors
|<span style="font-style:italic">Q</span>′/<span style="font-style:italic">Q</span>(<span style="font-style:italic">z</span>)| &gt; |<span style="font-style:italic">Q</span>′(<span style="font-style:italic">z</span>)/<span style="font-style:italic">Q</span>(<span style="font-style:italic">z</span>)| contradiction.<p>On prend pour <span style="font-style:italic">z</span> un rationnel complexe proche d’un coefficient
diagonal de <span style="font-style:italic">M</span>, on calcule un minorant <span style="font-style:italic">m</span> de |<span style="font-style:italic">Q</span>′(<span style="font-style:italic">z</span>)/<span style="font-style:italic">Q</span>(<span style="font-style:italic">z</span>)| 
pour <span style="font-style:italic">z</span> racine complexe approchée. On a alors au moins
une racine de <span style="font-style:italic">Q</span> dans le disque de centre <span style="font-style:italic">z</span> 
et de rayon degre(<span style="font-style:italic">Q</span>)/<span style="font-style:italic">m</span>, Si les disques obtenus sont
disjoints, on a ainsi une localisation certifiée des racines
complexes.<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">Q:=randpoly(5); M:=companion(Q); P,S:=schur(M):; S 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">P*S*trn(P); P*trn(P); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">l:=proot(Q); z:=exact(l[0]); evalf(degree(Q)*Q(x=z)/Q'(x=z),20) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
On peut aussi utiliser l’arithmétique d’intervalles pour
essayer de trouver un petit rectangle autour d’une racine approchée
qui est conservé par la méthode de Newton <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">x</span>−<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)/<span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span>),
le théorème du point fixe de Brouwer assure alors qu’il admet
un point fixe qui n’est autre qu’une racine de <span style="font-style:italic">g</span>.
</p></li></ul>
<!--TOC section id="sec68" Exercices (PGCD, résultant, ...)-->
<h2 id="sec68" class="section">8  Exercices (PGCD, résultant, ...)</h2><!--SEC END -->
<!--TOC subsection id="sec69" Instructions-->
<h3 id="sec69" class="subsection">8.1  Instructions</h3><!--SEC END --><p>
Elles sont dans les menus
Cmds-&gt;Integer et Cmds-&gt;Polynomes de <code>Xcas</code>.
</p>
<!--TOC subsubsection id="sec70" Entiers-->
<h4 id="sec70" class="subsubsection">8.1.1  Entiers</h4><!--SEC END --><ul class="itemize"><li class="li-itemize">
<code>chrem</code> :
restes chinois (entier)
</li><li class="li-itemize"><code>divisors</code>
(en maple <code>numtheory::divisors</code> :
liste des diviseurs d’un entier
</li><li class="li-itemize"><code>gcd, lcm</code> : PGCD et PPCM
</li><li class="li-itemize"><code>igcdex</code>: Bézout pour des entiers
</li><li class="li-itemize"><code>iquo</code> et <code>irem</code> quotient et reste de la division 
euclidienne de deux entiers
</li><li class="li-itemize"><code>isprime</code> test de primalité. 
Utiliser <code>is_pseudoprime</code> pour effectuer un test plus rapide
de pseudo-primalité.
</li><li class="li-itemize"><code>mods</code>: reste euclidien symétrique
</li><li class="li-itemize"><code>nextprime</code> et <code>prevprime</code> 
nombre premier suivant ou précédent
</li><li class="li-itemize"><code>powmod(a,b,n)</code> calcul de <span style="font-style:italic">a</span><sup><span style="font-style:italic">b</span></sup> (mod <span style="font-style:italic">n</span> ) par
l’algorithme de la puissance rapide
</li></ul>
<!--TOC subsubsection id="sec71" Polynômes-->
<h4 id="sec71" class="subsubsection">8.1.2  Polynômes</h4><!--SEC END --><p>
On peut représenter les polynômes par leur écriture symbolique
(par exemple <code>x^2+1</code>), ou par des listes (représentation dense
ou creuse, récursive ou distribuée). 
Xcas propose deux types
de représentation, dense à une variable (<code>poly1[ ]</code>), ou
distribuée (<code>%%%{ }%%%</code>) et des instructions de conversion
(<code>poly2symb</code> et <code>symb2poly</code>) entre représentations.
L’intérêt d’une représentation
non symbolique est l’efficacité des opérations polynomiales, (et la
possibilité de chronométrer des opérations comme le produit
de 2 polynômes).</p><p>Les instructions qui suivent
utilisent la représentation symbolique, certaines acceptent
les autres représentations.
</p><ul class="itemize"><li class="li-itemize">
<code>coeff</code> coefficient(s) d’un polynôme, 
</li><li class="li-itemize"><code>coeffs</code> liste des coefficients d’un polynôme
(à développer auparavant, en mupad on utilise <code>coeff</code>)
</li><li class="li-itemize"><code>content</code> contenu (pgcd des coefficients)
</li><li class="li-itemize"><code>degree</code> degré
</li><li class="li-itemize"><code>divide</code> division euclidienne, 
</li><li class="li-itemize"><code>gcd, lcm</code> PGCD et PPCM
</li><li class="li-itemize"><code>gcdex</code> Bézout, 
</li><li class="li-itemize"><code>genpoly</code> :
crée un polynôme à partir de la
représentation <span style="font-style:italic">z</span>-adique d’un entier (utile pour le PGCD heuristique) 
</li><li class="li-itemize"><code>icontent</code>: contenu entier pour un polynôme à plusieurs
variables
</li><li class="li-itemize"><code>indets</code>: 
liste des noms de variables d’une expression
</li><li class="li-itemize"><code>lcoeff</code>: coefficient dominant d’un polynôme
</li><li class="li-itemize"><code>ldegree</code>: valuation
</li><li class="li-itemize"><code>primpart</code>: partie primitive d’un polynôme
</li><li class="li-itemize"><code>quo</code>, <code>rem</code> quotient et reste euclidien
</li><li class="li-itemize"><code>tcoeff</code>: coefficient de plus bas degré d’un polynôme
</li><li class="li-itemize"><code>interp</code> 
interpolation de Lagrange
</li><li class="li-itemize"><code>convert(.,sqrfree)</code> 
décomposition en facteurs n’ayant pas de racine multiples
</li><li class="li-itemize"><code>convert(.,parfrac)</code> 
décomposition en éléments simples
</li><li class="li-itemize"><code>resultant</code> :
calcule le résultant de 2 polynômes par rapport à une variable.
</li><li class="li-itemize"><code>sturm~</code>: suites de Sturm, <code>sturmab</code> :
nombre de racines dans un intervalle réel ou un rectangle
du plan complexe.
</li></ul><p>Notez aussi que le menu <code>Exemples-&gt;poly-&gt;pgcd.xws</code> de Xcas contient 
des exemples de programmes de calcul de pgcd de type Euclide.</p>
<!--TOC subsubsection id="sec72" Calculs modulo <span style="font-style:italic">n</span>-->
<h4 id="sec72" class="subsubsection">8.1.3  Calculs modulo <span style="font-style:italic">n</span></h4><!--SEC END --><p>
Pour travailler dans ℤ/<span style="font-style:italic">n</span>ℤ[<span style="font-style:italic">X</span>] :
</p><ul class="itemize"><li class="li-itemize">
avec <code>Xcas</code> on utilise la notation % comme en C, par
exemple <span style="font-family:monospace">gcd(P % 3, Q % 3)</span>. On peut aussi utiliser la notation
Maple en mode “syntaxe Maple” (cf. ci-dessous)
</li><li class="li-itemize">en mode compatible Maple,
on utilise les formes inertes des instructions (qui renvoient l’instruction
non évaluée), dont le nom est le même que le nom de commande
habituel mais précédé par une majuscule, puis on indique
<code>mod n</code>, par exemple <code>Gcd(P,Q) mod 11</code>.
</li></ul>
<!--TOC subsection id="sec73" Exercices PGCD-->
<h3 id="sec73" class="subsection">8.2  Exercices PGCD</h3><!--SEC END --><ol class="enumerate" type=1><li class="li-enumerate">Calculez le pgcd de <span style="font-style:italic">x</span><sup>202</sup>+<span style="font-style:italic">x</span><sup>101</sup>+1
et sa dérivée modulo 3 et modulo 5. Conclusion?</li><li class="li-enumerate"><span style="font-style:italic">P</span>=51<span style="font-style:italic">x</span><sup>3</sup>−35<span style="font-style:italic">x</span><sup>2</sup>+39<span style="font-style:italic">x</span>−115 et <span style="font-style:italic">Q</span>=17<span style="font-style:italic">x</span><sup>4</sup>−23<span style="font-style:italic">x</span><sup>3</sup>+34<span style="font-style:italic">x</span><sup>2</sup>+39<span style="font-style:italic">x</span>−115.
Calculez le pgcd de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> modulo 5, 7 et 11. En déduire
le pgcd de <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span> par le théorème des restes chinois. Pourquoi
ne doit-on pas essayer modulo 17?</li><li class="li-enumerate">Écrire un programme qui détermine le degré probable
du pgcd de 2 polynômes en une variable en utilisant le pgcd modulaire 
(on considère le degré probable déterminé lorsqu’on trouve
deux nombres premiers réalisant le minimum des degrés trouvés)</li><li class="li-enumerate">Détaillez l’algorithme du PGCD heuristique pour les
polynômes <span style="font-style:italic">P</span>=(<span style="font-style:italic">x</span>+1)<sup>7</sup>−(<span style="font-style:italic">x</span>−1)<sup>6</sup> et sa dérivée. Comparez avec l’algorithme
d’Euclide naïf.</li><li class="li-enumerate">Écrire un programme mettant en oeuvre le pgcd heuristique
pour des polynômes à une variable.</li><li class="li-enumerate">On veut comprendre comment un logiciel de calcul formel calcule
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>6</sup>+2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">x</span><sup>3</sup>+1)<sup>2</sup></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dx</span> </td></tr>
</table>
On se ramène d’abord à une fraction propre (numérateur <span style="font-style:italic">N</span> de degré 
inférieur au dénominateur),
Soit <span style="font-style:italic">P</span>=<span style="font-style:italic">x</span><sup>3</sup>+1, calculez le PGCD de <span style="font-style:italic">P</span> et <span style="font-style:italic">P</span>′, puis
deux polynômes <span style="font-style:italic">U</span> et <span style="font-style:italic">V</span> tels que  <span style="font-style:italic">N</span>=<span style="font-style:italic">UP</span>+<span style="font-style:italic">VP</span>′ .
On décompose alors l’intégrale en deux morceaux :<br>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sup>2</sup></td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">U</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span></td></tr>
</table></td><td class="dcell">  + </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><span style="font-style:italic">V</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sup>2</sup></td></tr>
</table></td><td class="dcell">  </td></tr>
</table>
Faites une intégration par parties sur le deuxième terme
et en déduire la valeur de l’intégrale du départ.</li><li class="li-enumerate">Écrire un programme qui détermine le degré probable du PGCD 
par rapport à toutes les
variables de 2 polynôme à plusieurs variables
en utilisant l’évaluation en toutes les variables
sauf une.</li><li class="li-enumerate">Calculer le pgcd par une méthode modulaire de
(<span style="font-style:italic">xy</span>−<span style="font-style:italic">x</span>+1)(<span style="font-style:italic">xy</span>+<span style="font-style:italic">x</span><sup>2</sup>+1) et (<span style="font-style:italic">xy</span>−<span style="font-style:italic">x</span>−<span style="font-style:italic">y</span>)(<span style="font-style:italic">xy</span>−<span style="font-style:italic">x</span>+1)</li><li class="li-enumerate">En utilisant uniquement l’instruction de calcul de PGCD
déterminer la multiplicité maximale d’un facteur irréductible
de 
<span style="font-style:italic">x</span><sup>14</sup>−<span style="font-style:italic">x</span><sup>13</sup>−14<span style="font-style:italic">x</span><sup>12</sup>+12<span style="font-style:italic">x</span><sup>11</sup>+78<span style="font-style:italic">x</span><sup>10</sup>−54<span style="font-style:italic">x</span><sup>9</sup>−224<span style="font-style:italic">x</span><sup>8</sup>+116<span style="font-style:italic">x</span><sup>7</sup>+361<span style="font-style:italic">x</span><sup>6</sup>−129<span style="font-style:italic">x</span><sup>5</sup>−330<span style="font-style:italic">x</span><sup>4</sup>+72<span style="font-style:italic">x</span><sup>3</sup>+160<span style="font-style:italic">x</span><sup>2</sup>−16<span style="font-style:italic">x</span>−32</li></ol>
<!--TOC subsection id="sec74" Exercices (résultant)-->
<h3 id="sec74" class="subsection">8.3  Exercices (résultant)</h3><!--SEC END --><ol class="enumerate" type=1><li class="li-enumerate">
Pour quelles valeurs de <span style="font-style:italic">p</span> le polynôme <span style="font-style:italic">X</span><sup>5</sup>+<span style="font-style:italic">X</span><sup>3</sup>−<span style="font-style:italic">pX</span>+1 admet-il
une racine multiple?
</li><li class="li-enumerate">Résoudre le système en éliminant successivement les
variables grâce au résultant :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎧<br>
⎪<br>
⎨<br>
⎪<br>
⎩</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">a</span><sup>3</sup>+<span style="font-style:italic">b</span><sup>3</sup>+<span style="font-style:italic">c</span><sup>3</sup></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >8 </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">a</span><sup>2</sup>+<span style="font-style:italic">b</span><sup>2</sup>+<span style="font-style:italic">c</span><sup>2</sup></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >6 </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">a</span>+<span style="font-style:italic">b</span>+2<span style="font-style:italic">c</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >4
</td></tr>
</table></td></tr>
</table>
</li><li class="li-enumerate">Déterminer l’intersection de <span style="font-style:italic">xy</span>=4 et  <span style="font-style:italic">y</span><sup>2</sup>=(<span style="font-style:italic">x</span>−3)(<span style="font-style:italic">x</span><sup>2</sup>−16),
repésenter graphiquement les courbes. Discuter la multiplicité
et le nombre d’intersections.<br>
Même question pour (<span style="font-style:italic">x</span>−2)<sup>2</sup>+<span style="font-style:italic">y</span><sup>2</sup>=4 et <span style="font-style:italic">y</span><sup>2</sup>=(<span style="font-style:italic">x</span>−3)(<span style="font-style:italic">x</span><sup>2</sup>−16).
</li><li class="li-enumerate">Donner le détail des calculs avec Bézout de la décomposition
en éléments simples de :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">x</span><sup>2</sup>−1)<sup>2</sup>(<span style="font-style:italic">x</span>+2)</td></tr>
</table></td></tr>
</table>
puis calculer le coefficient de <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup> du développement en séries
entières de cette fraction en 0.
</li><li class="li-enumerate">Calculer 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">x</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">x</span><sup>4</sup></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dx</span> </td></tr>
</table>
en utilisant le résultant pour calculer les logarithmes.
</li><li class="li-enumerate">Courbe paramétrique dépendant d’un paramètre :
on considère la courbe <span style="font-style:italic">C</span><sub><span style="font-style:italic">m</span></sub> dépendant du réel <span style="font-style:italic">m</span> :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span>+<span style="font-style:italic">m</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup>+1+<span style="font-style:italic">m</span><sup>2</sup></td></tr>
</table></td><td class="dcell">,    <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span>−<span style="font-style:italic">m</span></td></tr>
</table></td></tr>
</table>
Représenter la courbe pour quelques valeurs de <span style="font-style:italic">m</span> (on pourra
utiliser dans un niveau de géométrie, le menu Edit, Ajouter un
paramètre pour créer un curseur représentant <span style="font-style:italic">m</span>, puis 
<code>plotparam</code>). Donner l’équation cartésienne de <span style="font-style:italic">C</span><sub><span style="font-style:italic">m</span></sub>.
Déterminer les valeurs de <span style="font-style:italic">m</span> pour lesquelles
la courbe admet un point singulier, représenter le graphe dans ce(s)
cas et faire l’étude de la courbe.
</li></ol>
<!--TOC subsection id="sec75" Exercice (Bézout modulaire)-->
<h3 id="sec75" class="subsection">8.4  Exercice (Bézout modulaire)</h3><!--SEC END --><p>
Soit <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> deux polynômes à coefficients entiers et premiers
entre eux. Soit <span style="font-style:italic">c</span> ∈ ℤ<sup>*</sup>  le résultant de <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span>,
on va calculer les polynômes <span style="font-style:italic">U</span> et <span style="font-style:italic">V</span> de l’identité de Bézout 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:bezoutmod"></a>
<span style="font-style:italic">A</span> <span style="font-style:italic">U</span> + <span style="font-style:italic">B</span> <span style="font-style:italic">V</span> = <span style="font-style:italic">c</span> ,    deg(<span style="font-style:italic">U</span>)&lt;deg(<span style="font-style:italic">B</span>), deg(<span style="font-style:italic">V</span>)&lt;deg(<span style="font-style:italic">A</span>)
    (13)</td></tr>
</table><p>
par une méthode modulaire.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Montrer, en utilisant les formules de Cramer,
que les coefficients de <span style="font-style:italic">U</span> et <span style="font-style:italic">V</span> sont des entiers de
valeur absolue inférieure ou égale à la borne de Hadamard <span style="font-style:italic">h</span> de
la matrice de Sylvester de <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> (dont le déterminant est <span style="font-style:italic">c</span>,
le résultant de <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span>). Calculer <span style="font-style:italic">h</span> en fonction
de la norme euclidienne de <span style="font-style:italic">A</span>, <span style="font-style:italic">B</span> et de leurs degrés. 
</li><li class="li-enumerate">On calcule <span style="font-style:italic">c</span> ∈ ℤ<sup>*</sup> puis on
résoud (<a href="#eq%3Abezoutmod">13</a>) dans ℤ/<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">Z</span>[<span style="font-style:italic">X</span>] pour
plusieurs nombres premiers <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> (choisis si possible inférieurs 
à √<span style="text-decoration:overline">2</span><sup><span style="text-decoration:overline">31</span></sup> pour des raisons d’efficacité), puis on calcule par le
théorème des restes chinois (<a href="#eq%3Abezoutmod">13</a>) 
dans ℤ/∏<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">Z</span>[<span style="font-style:italic">X</span>]. Donner une minoration de 
∏<sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> faisant intervenir <span style="font-style:italic">h</span> qui permette de garantir
que l’écriture en représentation symétrique de (<a href="#eq%3Abezoutmod">13</a>)
dans ℤ/∏<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">Z</span>[<span style="font-style:italic">X</span>] est identique à (<a href="#eq%3Abezoutmod">13</a>) dans ℤ[<span style="font-style:italic">X</span>].
</li><li class="li-enumerate">Application : résoudre de cette manière l’équation de
Bézout pour 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>=(<span style="font-style:italic">X</span>+1)<sup>4</sup>(<span style="font-style:italic">X</span>−3),    <span style="font-style:italic">B</span>=(<span style="font-style:italic">X</span>−1)<sup>4</sup>(<span style="font-style:italic">X</span>+2)</td></tr>
</table> 
(vous pouvez utiliser
sans justifications l’instruction de calcul de résultant,
des coefficients de Bézout dans ℤ/<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub><span style="font-style:italic">Z</span>[<span style="font-style:italic">X</span>] et 
de reste chinois de votre logiciel).
</li><li class="li-enumerate">Écrire une fonction mettant en oeuvre cet algorithme.
</li><li class="li-enumerate">Que pensez-vous de l’intérêt de cet algorithme par rapport à
l’algorithme d’Euclide étendu dans ℤ[<span style="font-style:italic">X</span>]?
</li></ol>
<!--TOC subsection id="sec76" Exercice (Géométrie et résultants).-->
<h3 id="sec76" class="subsection">8.5  Exercice (Géométrie et résultants).</h3><!--SEC END --><p>
On cherche une relation algébrique entre les coordonnées de 4 points
<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>,<span style="font-style:italic">C</span>,<span style="font-style:italic">D</span> qui traduise le fait que ces 4 points sont cocycliques. Cette
condition étant invariante par translation, on cherche une
relation entre les 6 coordonnées des 3 vecteurs <span style="font-style:italic">v</span><sub>1</sub>=(<span style="font-style:italic">x</span><sub>1</sub>,<span style="font-style:italic">y</span><sub>1</sub>), 
<span style="font-style:italic">v</span><sub>2</sub>=(<span style="font-style:italic">x</span><sub>2</sub>,<span style="font-style:italic">y</span><sub>2</sub>) et <span style="font-style:italic">v</span><sub>3</sub>=(<span style="font-style:italic">x</span><sub>3</sub>,<span style="font-style:italic">y</span><sub>3</sub>) 
d’origine <span style="font-style:italic">A</span> et d’extrémité <span style="font-style:italic">B</span>, <span style="font-style:italic">C</span> et <span style="font-style:italic">D</span>.
On peut supposer quitte à translater que le centre du cercle est
l’origine, on a donc 5 paramètres : le rayon du cercle <span style="font-style:italic">R</span> et les
4 angles des points sur le cercle θ<sub>0</sub>, θ<sub>1</sub>, θ<sub>2</sub> et
θ<sub>3</sub>. La relation cherchée va s’obtenir en éliminant les
5 paramètres des expressions des 6 coordonnées en fonction de
ces paramètres.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Exprimer les 6 coordonnées en fonction de 
<span style="font-style:italic">R</span> et <span style="font-style:italic">a</span>=tan(θ<sub>0</sub>/2), <span style="font-style:italic">b</span>=tan(θ<sub>1</sub>/2), <span style="font-style:italic">c</span>=tan(θ<sub>2</sub>/2)
et <span style="font-style:italic">d</span>=tan(θ<sub>3</sub>/2). On obtient ainsi 6 équations, par exemple les
deux premières sont de la forme
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span><sub>1</sub>− <span style="font-style:italic">F</span>(<span style="font-style:italic">R</span>,<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>)= 0,    <span style="font-style:italic">y</span><sub>1</sub>− <span style="font-style:italic">G</span>(<span style="font-style:italic">R</span>,<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>)= 0 </td></tr>
</table>
où <span style="font-style:italic">F</span> et <span style="font-style:italic">G</span> sont deux fractions rationnelles.
</li><li class="li-enumerate">En réduisant au même dénominateur, calculer 6 
polynômes, fonction de
<span style="font-style:italic">x</span><sub>1</sub>,<span style="font-style:italic">y</span><sub>1</sub>,<span style="font-style:italic">x</span><sub>2</sub>,<span style="font-style:italic">y</span><sub>2</sub>,<span style="font-style:italic">x</span><sub>3</sub>,<span style="font-style:italic">y</span><sub>3</sub>,<span style="font-style:italic">R</span>,<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>,<span style="font-style:italic">c</span>,<span style="font-style:italic">d</span>, qui doivent s’annuler
pour que les points soient cocycliques
(Vous pouvez utiliser l’instruction <code>numer</code> pour obtenir le
numérateur d’une fraction rationnelle).
</li><li class="li-enumerate">Éliminer <span style="font-style:italic">b</span> des polynômes
contenant <span style="font-style:italic">x</span><sub>1</sub> et <span style="font-style:italic">y</span><sub>1</sub> et factoriser
le polynôme obtenu, faire de même avec <span style="font-style:italic">c</span>, <span style="font-style:italic">x</span><sub>2</sub> et <span style="font-style:italic">y</span><sub>2</sub>
et <span style="font-style:italic">d</span>, <span style="font-style:italic">x</span><sub>3</sub> et <span style="font-style:italic">y</span><sub>3</sub>, en déduire (en supposant que les points sont
tous distincts) 3 polynômes en <span style="font-style:italic">x</span><sub>1</sub>,<span style="font-style:italic">y</span><sub>1</sub>,<span style="font-style:italic">x</span><sub>2</sub>,<span style="font-style:italic">y</span><sub>2</sub>,<span style="font-style:italic">x</span><sub>3</sub>,<span style="font-style:italic">y</span><sub>3</sub>,<span style="font-style:italic">R</span>,<span style="font-style:italic">a</span> qui
s’annulent.
</li><li class="li-enumerate">Éliminer <span style="font-style:italic">R</span> et <span style="font-style:italic">a</span>, en déduire la relation cherchée.
</li><li class="li-enumerate">Vérifier que cette relation est équivalente à la nullité
de la partie imaginaire du birapport des affixes α, β, γ,
δ des 4 points :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ℑ </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">α−β</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">α−γ</td></tr>
</table></td><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">δ−γ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">δ−β</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">= 0</td></tr>
</table>
</li></ol>
<!--TOC subsection id="sec77" Décalage entier entre racines.-->
<h3 id="sec77" class="subsection">8.6  Décalage entier entre racines.</h3><!--SEC END --><p>
Soit <span style="font-style:italic">P</span> un polynôme à coefficients entiers sans racines multiples. 
On dira que <span style="font-style:italic">P</span> a la propriété <span style="color:red"><span style="font-style:italic">I</span></span> si
deux des racines de <span style="font-style:italic">P</span> sont décalées d’un entier. 
En d’autres termes, si <span style="font-style:italic">r</span><sub>1</sub>,...,<span style="font-style:italic">r</span><sub><span style="font-style:italic">n</span></sub> désignent
les racines complexes distinctes de <span style="font-style:italic">P</span>, <span style="font-style:italic">P</span> possède la
propriété <span style="color:red"><span style="font-style:italic">I</span></span>
s’il existe 
au moins un entier parmi les différences <span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span></sub>−<span style="font-style:italic">r</span><sub><span style="font-style:italic">j</span></sub> pour <span style="font-style:italic">i</span> ≠ <span style="font-style:italic">j</span>. 
</p><ol class="enumerate" type=1><li class="li-enumerate">
Soit
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">R</span>(<span style="font-style:italic">t</span>)=resultant<sub><span style="font-style:italic">x</span></sub>(<span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>),<span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">t</span>)) </td></tr>
</table>
Montrer que <span style="font-style:italic">R</span> est à coefficients entiers.
Montrer que la propriété <span style="color:red"><span style="font-style:italic">I</span></span> est équivalente à
la propriété “<span style="font-style:italic">R</span> possède une racine entière non nulle”.
On va maintenant construire un algorithme déterminant les racines
entières du polynôme <span style="font-style:italic">R</span>.
</li><li class="li-enumerate">Après division de <span style="font-style:italic">R</span> par une puissance de <span style="font-style:italic">t</span>, on peut
supposer que <span style="font-style:italic">R</span> a un coefficient constant non nul. Après division de
<span style="font-style:italic">R</span> par son contenu, on peut aussi supposer
que le contenu de <span style="font-style:italic">R</span> est 1. En effectuant ensuite une factorisation
square-free de <span style="font-style:italic">R</span>, on peut se ramener au cas où <span style="font-style:italic">R</span> et <span style="font-style:italic">R</span>′ sont
premiers entre eux.
Soit <span style="font-style:italic">a</span> une racine de <span style="font-style:italic">R</span>.
<ol class="enumerate" type=a><li class="li-enumerate">
Donner une majoration de |<span style="font-style:italic">a</span>| 
en fonction du coefficient constant de <span style="font-style:italic">R</span>.
</li><li class="li-enumerate">Soit <span style="font-style:italic">p</span> un nombre premier ne divisant pas le coefficient dominant
de <span style="font-style:italic">R</span> et tel que <span style="font-style:italic">R</span> et <span style="font-style:italic">R</span>′ soient premiers entre eux modulo <span style="font-style:italic">p</span>. 
On peut calculer <span style="font-style:italic">a</span> à partir d’une racine
de <span style="font-style:italic">R</span> modulo <span style="font-style:italic">p</span> en la “remontant” modulo <span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup> pour <span style="font-style:italic">k</span>
assez grand (algorithme p-adique). Pour quelle valeur de <span style="font-style:italic">k</span> peut-on
reconstruire toutes les racines entières de <span style="font-style:italic">R</span> ? 
</li><li class="li-enumerate">Comparer l’algorithme ci-dessus avec les algorithmes suivants :
la factorisation de <span style="font-style:italic">R</span> sur ℤ, 
la recherche numérique des racines complexes de <span style="font-style:italic">R</span>,
la recherche des racines entières de <span style="font-style:italic">R</span> parmi les diviseurs 
entiers du coefficient constant de <span style="font-style:italic">R</span> et leurs opposés.
</li></ol>
</li><li class="li-enumerate">Une fois les racines entières de <span style="font-style:italic">R</span> connues, comment
peut-on en déduire les facteurs de <span style="font-style:italic">P</span> dont les racines diffèrent
de cet(ces) entier(s)?
</li><li class="li-enumerate">Soit 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">x</span><sup>6</sup>+9<span style="font-style:italic">x</span><sup>5</sup>+29<span style="font-style:italic">x</span><sup>4</sup>+41<span style="font-style:italic">x</span><sup>3</sup>+37 <span style="font-style:italic">x</span><sup>2</sup>+59<span style="font-style:italic">x</span>+31</td></tr>
</table>
Montrer que <span style="font-style:italic">P</span> a la propriété <span style="color:red"><span style="font-style:italic">I</span></span>. Calculer
la ou les racines entières de <span style="font-style:italic">R</span> et donner la factorisation
correspondante de <span style="font-style:italic">P</span>. 
</li><li class="li-enumerate">Écrire un programme qui effectue cet algorithme sur un
polynôme quelconque. On pourra utiliser la fonction 
<code>rationalroot</code> de Xcas pour déterminer les racines
entières de <span style="font-style:italic">R</span>.
</li><li class="li-enumerate">Application : on cherche à calculer
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq"></a>
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−9<span style="font-style:italic">x</span><sup>2</sup>−27<span style="font-style:italic">x</span>−30</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)</td></tr>
</table></td><td class="dcell">
    (14)</td></tr>
</table>
Décomposer cette fraction
en éléments simples (donner le détail des calculs en utilisant
la factorisation précédente et l’identité de Bezout 
<code>abcuv</code> en Xcas). 
</li><li class="li-enumerate">Calculer la somme précédente (<a href="#eq">14</a>).
On pourra remarquer que pour <span style="font-style:italic">k</span> entier strictement positif,
1/<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">k</span>)−1/<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)
s’exprime comme une somme de différences 
1/<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">j</span>+1)−1/<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">j</span>).
</li><li class="li-enumerate">Écrire un programme effectuant ce calcul avec une fraction
quelconque, lorsque cela est possible.
</li></ol>
<!--TOC subsection id="sec78" Exemple de correction de géométrie et résultant-->
<h3 id="sec78" class="subsection">8.7  Exemple de correction de géométrie et résultant</h3><!--SEC END --><pre class="verbatim">e1:=x1-R*((1-b^2)/(1+b^2)-(1-a^2)/(1+a^2));
e2:=y1-R*(2b/(1+b^2)-2*a/(1+a^2));
e3:=x2-R*((1-c^2)/(1+c^2)-(1-a^2)/(1+a^2));
e4:=y2-R*(2c/(1+c^2)-2*a/(1+a^2));
e5:=x3-R*((1-d^2)/(1+d^2)-(1-a^2)/(1+a^2));
e6:=y3-R*(2d/(1+d^2)-2*a/(1+a^2));
f1:=factor(resultant(numer(e1),numer(e2),b)/
 (-4)/(a^2+1)^3/R^2);
f2:=factor(resultant(numer(e3),numer(e4),c)/
 (-4)/(a^2+1)^3/R^2);
f3:=factor(resultant(numer(e5),numer(e6),d)/
 (-4)/(a^2+1)^3/R^2);
g1:=factor(resultant(f1,f2,R));
g2:=resultant(f1,f3,R);
r:=factor(resultant(g1/(a^2+1),g2/(a^2+1),a));
eq1:=r[1,3,1];
eq2:=numer(im((-x1-i*y1)/(-x2-i*y2)*
 (x3-x2+i*(y3-y2))/(x3-x1+i*(y3-y1))));
normal(eq1-eq2);
</pre>
<!--TOC section id="sec79" Bases de Gröbner.-->
<h2 id="sec79" class="section">9  Bases de Gröbner.</h2><!--SEC END --><p> <a id="sec:groebner"></a> <a id="hevea_default72"></a> <a id="hevea_default73"></a>
</p>
<!--TOC subsection id="sec80" Ordre et réduction-->
<h3 id="sec80" class="subsection">9.1  Ordre et réduction</h3><!--SEC END --><p><a id="hevea_default74"></a> <a id="hevea_default75"></a>
L’anneau des polynômes à plusieurs variables n’a pas de division
euclidienne. On est donc obligé d’utiliser des outils moins
performants.
La première chose à faire est de choisir un ordre total sur les monomes,
compatible avec la multiplication des monômes 
(<span style="font-style:italic">a</span>&lt;<span style="font-style:italic">b</span> doit entrainer <span style="font-style:italic">a</span> <span style="font-style:italic">c</span>&lt;<span style="font-style:italic">b</span> <span style="font-style:italic">c</span>) et tel que si un monôme <span style="font-style:italic">a</span> divise
un autre monôme <span style="font-style:italic">b</span> alors <span style="font-style:italic">a</span>&lt;<span style="font-style:italic">b</span>. 
Exemples d’ordres utilisés
fréquemment (ce sont les 3 ordres proposés par les fonctions
de Xcas) :
</p><ul class="itemize"><li class="li-itemize">
l’<span style="font-weight:bold">ordre lexicographique</span> <code>plex</code><a id="hevea_default76"></a>
(<span style="font-style:italic">a</span><sub>1</sub>,<span style="font-style:italic">a</span><sub>2</sub>,..,<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>)&gt;(<span style="font-style:italic">b</span><sub>1</sub>,...,<span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span></sub>) si <span style="font-style:italic">a</span><sub>1</sub>&gt;<span style="font-style:italic">b</span><sub>1</sub> ou si <span style="font-style:italic">a</span><sub>1</sub>=<span style="font-style:italic">b</span><sub>1</sub> et
<span style="font-style:italic">a</span><sub>2</sub>&gt;<span style="font-style:italic">b</span><sub>2</sub> ou si <span style="font-style:italic">a</span><sub>1</sub>=<span style="font-style:italic">b</span><sub>1</sub>, <span style="font-style:italic">a</span><sub>2</sub>=<span style="font-style:italic">b</span><sub>2</sub> et <span style="font-style:italic">a</span><sub>3</sub>&gt;<span style="font-style:italic">b</span><sub>3</sub>, etc.
</li><li class="li-itemize">le degré total <code>tdeg</code>: 
on commence par comparer le degré
total, et en cas d’égalité on utilise l’ordre lexicographique
</li><li class="li-itemize"><code>revlex</code><a id="hevea_default77"></a>: on commence par comparer le degré
total, et en cas d’égalité on renvoie le contraire
de l’ordre lexicographique (attention, cela ne veut
pas dire inverser l’ordre des variables!)
</li></ul><p>
On remarque sur ces 3 exemples qu’il ne peut exister de suite strictement
décroissante infinie pour l’ordre &gt;. Lorsque le degré total est
le premier critère, c’est évident, puisque le nombre de monomes &lt;
à un monome donné est fini. Pour l’ordre lexicographique, on
raisonne par l’absurde.
On regarde d’abord le premier indice, comme la suite est décroissante,
tous les monômes ont un indice inférieur ou égal au premier indice
du premier monôme. On peut donc extraire une sous-suite strictement
décroissante et infinie de monômes dont le 1er indice est constant. 
On passe alors au 2ème indice, et ainsi de suite jusqu’au dernier indice
qui donne une contradiction. On fait donc dans la suite l’hypothèse
qu’il n’existe pas de suite strictement décroissante infinie pour 
l’ordre &gt;.</p><p>On peut alors effectuer une sorte de remplacement de la division
euclidienne de <span style="font-style:italic">A</span> par <span style="font-style:italic">B</span>, appelée réduction qui consiste à comparer le
terme dominant de <span style="font-style:italic">B</span> au sens de l’ordre (noté <span style="font-style:italic">LT</span>(<span style="font-style:italic">B</span>)) aux monomes
de <span style="font-style:italic">A</span> par ordre décroissant, si l’un
des monomes de <span style="font-style:italic">A</span> a <span style="font-weight:bold">toutes</span> ses puissances
plus grandes que <span style="font-style:italic">LT</span>(<span style="font-style:italic">B</span>), alors on élimine ce terme, 
disons <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>, en retranchant
à <span style="font-style:italic">A</span> le polynôme <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>/<span style="font-style:italic">LT</span>(<span style="font-style:italic">B</span>) <span style="font-style:italic">B</span>. Ceci ne modifie pas le début
de <span style="font-style:italic">A</span> jusqu’au monôme <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>. Les termes retranchés peuvent eux-même
donner lieu à une réduction par <span style="font-style:italic">B</span>, par exemple <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>/<span style="font-style:italic">LT</span>(<span style="font-style:italic">B</span>) <span style="font-style:italic">B</span><sub>2</sub> peut
être divisible par <span style="font-style:italic">LT</span>(<span style="font-style:italic">B</span>). Le procédé de réduction
doit toutefois s’arrêter,
sinon on pourrait construire une suite décroissante infinie pour
l’ordre &gt; avec les <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>.
On peut même diviser <span style="font-style:italic">A</span> par plusieurs polynômes <span style="font-style:italic">B</span>,<span style="font-style:italic">C</span>,.. en utilisant
cet algorithme.</p>
<!--TOC subsection id="sec81" Idéaux-->
<h3 id="sec81" class="subsection">9.2  Idéaux</h3><!--SEC END --><p><a id="hevea_default78"></a>
En dimension 1, les idéaux sont engendrés par un polynôme <span style="font-style:italic">P</span> et
c’est la division euclidienne par <span style="font-style:italic">P</span> qui permet de savoir si on est
dans l’idéal. En dimension plus grande, l’analogue est la base
de Gröbner de l’idéal (relativement à un ordre monomial &lt;)
et on utilise la réduction par rapport aux polynômes de l’idéal
pour savoir si on est dans l’idéal.
On commence par montrer que les idéaux de monomes
sont engendrés par 
les monômes minimaux, qui ne sont divisibles par aucun
autre monôme de l’idéal. Supposons qu’ils soient en nombre infini.
Considérons le premier indice des monomes, s’il est borné, on 
aura une infinité de monomes ayant le même indice, sinon on
aura une suite infinie de monômes d’indice croissant, dans
les deux cas on peut extraire une suite infinie dont la première
composante est croissante au sens large. On fait le même
raisonnement sur la suite extraite pour la 2ème composante, etc.
et on aboutit à une suite infinie de monômes qui se divisent les
uns les autres ce qui est absurde. Donc les monômes minimaux
sont en nombre fini.</p><p>Une base de Gröbner s’obtient en prenant
des polynômes correspondant aux monômes minimaux 
de l’idéal de monômes <span style="font-style:italic">LT</span>(<span style="font-style:italic">I</span>) 
des coefficients dominants de <span style="font-style:italic">I</span>. La réduction
par rapport aux éléments de cette base donne alors 0
pour tous les éléments de <span style="font-style:italic">I</span>, ce qui montre que
<span style="font-style:italic">I</span> est engendré par cette base.</p><p>On appelle <span style="font-weight:bold">“s-polynôme”</span><a id="hevea_default79"></a> d’une paire de polynômes
<span style="font-style:italic">A</span> et <span style="font-style:italic">B</span>
le polynôme obtenu en calculant le monôme PPCM <span style="font-style:italic">L</span> de <span style="font-style:italic">LT</span>(<span style="font-style:italic">A</span>) 
et <span style="font-style:italic">LT</span>(<span style="font-style:italic">B</span>) et en créant la différence
qui annule ce monôme PPCM <span style="font-style:italic">L</span>/<span style="font-style:italic">LT</span>(<span style="font-style:italic">A</span>)<span style="font-style:italic">A</span> −<span style="font-style:italic">L</span>/<span style="font-style:italic">LT</span>(<span style="font-style:italic">B</span>)<span style="font-style:italic">B</span>.</p><p>On peut montrer que la base de Gröbner peut se calculer
à partir d’une famille génératrice en effectuant
la boucle suivante :
on calcule tous les s-polynômes de la famille génératrice
courante, on les réduit par rapport à la famille génératrice
courante, si tous les s-polynomes sont nuls la famille
courante est la base cherchée, sinon 
on garde les s-polynômes réduits non nuls, on réduit
la famille génératrice courante par rapport à ces s-polynômes réduits
non nuls et on fusionne les polynômes non nuls en la famille
génératrice courante pour l’itération suivante de la boucle.</p><p>Le problème est que cela devient très vite très long. Il existe
des méthodes permettant d’accélérer l’algorithme, par exemple
on peut savoir à l’avance qu’un s-polynôme se réduit à 0
(règles de Gebauer-Möller) il est donc inutile de le calculer.
On peut aussi précalculer tous les multiples des polynômes
par rapport auxquels on réduit et réduire simultanément
tous les polynômes à réduire en ramenant la réduction
à un algorithme de pivot de Gauß (c’est la partie
algèbre linéaire de l’algorithme F4). L’ordre choisi
est aussi très important pour l’efficacité. Enfin, pour le cas des
coefficients entiers, des méthodes modulaires permettent
d’accélérer les calculs. Xcas implémente un algorithme modulaire
très compétitif pour l’ordre <span style="font-family:monospace">revlex</span>, présenté
dans l’article en anglais qui suit.</p><p>Les instructions Xcas correspondantes sont <span style="font-family:monospace">gbasis, greduce</span>.</p>
<!--TOC subsection id="sec82" Introduction-->
<h3 id="sec82" class="subsection">9.3  Introduction</h3><!--SEC END --><p>
During the last decades, considerable improvements have been made 
in CAS like Maple or specialized systems like Magma, Singular, 
Cocoa, Macaulay... to compute Groebner basis. 
They were driven by
implementations of new algorithms speeding up the original Buchberger 
([<a href="#buchberger1985grobner"></a>])
algorithm: Gebauer and Möller criterion ([<a href="#Gebauer1988275"></a>]), F4 and F5
algorithms from J.-C. Faugère ([<a href="#F99a"></a>], [<a href="#Fau02a"></a>]), and are widely described in the
literature if the base field is a finite field.
Much less was said about computing over ℚ. It seems that
implementers are using the same algorithm as for finite fields,
this time working with coefficients in ℚ or in ℤ (sometimes
with fast integer linear algebra), 
despite the fact that an efficient p-adic or Chinese remaindering
algorithm were described as soon as in year 2000 by E. Arnold
([<a href="#Arnold2003403"></a>]). 
The reason might well be that these modular algorithms suffer from a
time-consuming step at the end: checking that the reconstructed
Groebner basis is indeed the correct Groebner basis.</p><p>Section <a href="#sec%3Aprobagb">9.4</a>
will show that if one accepts a small error probability, this check 
may be fast, so we can let the user choose between a fast conjectural
Groebner basis to make his own conjectures and a slower certified
Groebner basis once he needs a mathematical proof.</p><p>Section <a href="#sec%3Alearning">9.5</a>
will explain learning, a process that can accelerate the
computation of a Groebner basis modulo a prime <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> once the
same computation but modulo another prime <span style="font-style:italic">p</span> has already been
done ; learning is an alternative to the F5 algorithm
in order to avoid computing useless critical pairs that reduce to 0. The
idea is similar to <span style="font-family:monospace">F4remake</span> by Joux-Vitse ([<a href="#joux2011variant"></a>]) 
used in the context of computing Groebner basis in large finite fields.</p><p>Section <a href="#sec%3Agiacf4">9.6</a> 
will show in more details how the gbasis algorithm is implemented
in Giac/Xcas ([<a href="#giac"></a>]) and show that - at least for the classical academic
benchmarks Cyclic and Katsura - the deterministic modular algorithm
is competitive or faster than the best open-source implementations
and the modular probabilistic algorithm is comparable to Maple
and slower than Magma on one processor (at least for moderate integer coefficient
size) and may be faster than Magma on multi-processors, 
while computation modulo <span style="font-style:italic">p</span> are faster for characteristics in the
24-31 bits range.
Moreover the modular algorithm memory usage is essentially
twice the memory required to store the basis on ℚ, sometimes
much less than the memory required by other algorithms.</p>
<!--TOC subsection id="sec83" Checking a reconstructed Groebner basis-->
<h3 id="sec83" class="subsection">9.4  Checking a reconstructed Groebner basis</h3><!--SEC END --><p> <a id="sec:probagb"></a>
Let <span style="font-style:italic">f</span><sub>1</sub>,..,<span style="font-style:italic">f</span><sub><span style="font-style:italic">m</span></sub> be polynomials in ℚ[<span style="font-style:italic">x</span><sub>1</sub>,..,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>], <span style="font-style:italic">I</span>=&lt;<span style="font-style:italic">f</span><sub>1</sub>,...,<span style="font-style:italic">f</span><sub><span style="font-style:italic">m</span></sub>&gt;
be the ideal generated by <span style="font-style:italic">f</span><sub>1</sub>,...,<span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub>. Without loss of generality, we may
assume that the <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub> have coefficients in ℤ by multiplying
by the least common multiple of the denominators of the coefficients
of <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>. We may also assume that the <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub> are primitive by dividing
by their content.</p><p>Let &lt; be a total monomial ordering (for example <span style="font-family:monospace">revlex</span> the
total degree reverse lexicographic ordering). We want to compute
the Groebner basis <span style="font-style:italic">G</span> of <span style="font-style:italic">I</span> over ℚ (and more precisely
the inter-reduced Groebner basis, sorted with respect to &lt;).
Now consider the ideal <span style="font-style:italic">I</span><sub><span style="font-style:italic">p</span></sub> generated by the same <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub> but with
coefficients in ℤ/<span style="font-style:italic">p</span>ℤ for a prime <span style="font-style:italic">p</span>. Let <span style="font-style:italic">G</span><sub><span style="font-style:italic">p</span></sub> be the Groebner basis of <span style="font-style:italic">I</span><sub><span style="font-style:italic">p</span></sub>
(also assumed to be inter-reduced, sorted with respect to &lt;, and with
all leading coefficients equal to 1).</p><p>Assume we compute <span style="font-style:italic">G</span> by the Buchberger
algorithm with Gebauer and Möller criterion, and we reduce in ℤ
(by multiplying the s-poly to be reduced by appropriate leading
coefficients), if no leading coefficient in the polynomials are
divisible by <span style="font-style:italic">p</span>, we will get by the same process but computing modulo
<span style="font-style:italic">p</span> the <span style="font-style:italic">G</span><sub><span style="font-style:italic">p</span></sub> Groebner basis. Therefore the computation can be
done in parallel in ℤ and in ℤ/<span style="font-style:italic">p</span>ℤ except for a finite 
set of <em>unlucky</em> primes (since the number of intermediate polynomials
generated in the algorithm is finite). If we are choosing our primes
sufficiently large (e.g. about 2<sup>31</sup>), the probability to fall on
an unlucky prime is very small (less than the number of generated
polynomials divided by about 2<sup>31</sup>, even for really large 
examples like Cyclic9 where there are a few 10<sup>4</sup> polynomials 
involved, it would be about <span style="font-family:monospace">1e-5</span>).</p><p>The Chinese remaindering algorithm is as follow: compute <span style="font-style:italic">G</span><sub><span style="font-style:italic">p</span></sub> for
several primes, for all primes that have the same leading monomials
in <span style="font-style:italic">G</span><sub><span style="font-style:italic">p</span></sub> (i.e. if coefficient values are ignored), reconstruct
<span style="font-style:italic">G</span><sub>∏<span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub></sub> by Chinese remaindering, then reconstruct a
candidate Groebner basis <span style="font-style:italic">G</span><sub><span style="font-style:italic">c</span></sub> in ℚ by Farey reconstruction. Once it
stabilizes, do the checking step described below, and return <span style="font-style:italic">G</span><sub><span style="font-style:italic">c</span></sub>
on success.</p><p><span style="font-weight:bold">Checking step</span> : check that the original <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub> polynomials reduce
to 0 with respect to <span style="font-style:italic">G</span><sub><span style="font-style:italic">c</span></sub> and check that <span style="font-style:italic">G</span><sub><span style="font-style:italic">c</span></sub> is a Groebner basis.</p><div class="theorem"><span style="font-weight:bold">Théorème 14</span>  <em> (Arnold, Greuel and Pfister)
If the checking step succeeds, then </em><span style="font-style:italic">G</span><sub><span style="font-style:italic">c</span></sub><em> is the Groebner basis of </em><span style="font-style:italic">I</span><em>.
</em></div><p>This is a consequence of ideal inclusions (first check) and dimensions (second
check), for a complete proof, see [<a href="#Arnold2003403"></a>] and 
theorem 7.5.1 in Greuel,G.-M., Pfister,G., 2007, A Singular
Introduction to Commutative Algebra, Springer.</p><p><span style="font-weight:bold">Probabilistic checking algorithm</span>: instead of checking that s-polys
of critical
pairs of <span style="font-style:italic">G</span><sub><span style="font-style:italic">c</span></sub> reduce to 0, check that the s-polys reduce to 0 
modulo several primes that do not divide the leading coefficients of
<span style="font-style:italic">G</span><sub><span style="font-style:italic">c</span></sub> and stop
as soon as the inverse of the product of these primes is less than a
fixed ε&gt;0.</p><p><span style="font-weight:bold">Deterministic checking algorithm</span>: check that all s-polys
reduce to 0 over ℚ. This can be done either by integer computations
(or even by rational computations, I have not tried that),
or by reconstruction of the quotients using modular reduction to 0
over ℤ/<span style="font-style:italic">p</span>ℤ for sufficiently many primes. Once the reconstructed
quotients stabilize, we can check the 0-reduction identity, and this
can be done without computing the products quotients by elements of <span style="font-style:italic">G</span><sub><span style="font-style:italic">c</span></sub>
if we have enough primes (with appropriate bounds on
the coefficients of <span style="font-style:italic">G</span><sub><span style="font-style:italic">c</span></sub> and the lcm of the denominators of the
reconstructed quotients).</p>
<!--TOC subsection id="sec84" Speeding up by learning from previous primes-->
<h3 id="sec84" class="subsection">9.5  Speeding up by learning from previous primes</h3><!--SEC END --><p> <a id="sec:learning"></a>
Once we have computed a Groebner basis modulo an initial prime <span style="font-style:italic">p</span>, if <span style="font-style:italic">p</span> is
not an unlucky prime, then we can speedup computing Groebner basis
modulo other lucky primes. Indeed, if one s-poly reduce to 0 modulo
<span style="font-style:italic">p</span>, then it reduces most certainly to 0 on ℚ (non zero s-poly have
in general several terms, cancellation of one term mod <span style="font-style:italic">p</span> has
probability 1/<span style="font-style:italic">p</span>, simultaneous cancellation of several terms of a non-zero
s-poly modulo <span style="font-style:italic">p</span> is highly improbable), and we discard this s-poly in the
next primes computations. We name this speedup process <em>learning</em>. 
It can also
be applied on other parts of the Groebner basis computation, like the
symbolic preprocessing of the F4 algorithm, where we can reuse the
same collection of monomials that were used for the first prime <span style="font-style:italic">p</span> 
to build matrices for next primes (see Buchberger Algorithm with F4 
linear algebra in the next section).</p><p>If we use learning, we have no certification that the computation ends up
with a Groebner basis modulo the new primes. But this is not a problem,
since it is not required by the checking correctness proof, the only
requirement is that the new generated ideal is contained in the
initial ideal modulo all primes (which is still true) and 
that the reconstructed <span style="font-style:italic">G</span><sub><span style="font-style:italic">c</span></sub> is a Groebner basis.</p>
<!--TOC subsection id="sec85" Giac/Xcas implementation and experimentation-->
<h3 id="sec85" class="subsection">9.6  Giac/Xcas implementation and experimentation</h3><!--SEC END --><p> <a id="sec:giacf4"></a>
We describe here briefly some details of the Giac/Xcas gbasis implementation
and give a few benchmarks.</p><p>The optimized algorithm runs with revlex as &lt; ordering
if the polynomials have at most 15
variables (it’s easy to modify for more variables, adding multiples of
4, but this will increase a little memory required and
slow down a little).
Partial and total degrees are coded as 16 bits integers (hence the 15
variables limit, since 1 slot of 16 bits is kept for total degree). 
Modular coefficients are coded as 31 bit integers (or 24).</p><p>The Buchberger algorithm with linear algebra 
from the F4 algorithm is implemented modulo primes smaller than 2<sup>31</sup>
using total degree as selection criterion for critical pairs.<br>
<span style="font-weight:bold">Buchberger algorithm with F4 linear algebra modulo a prime</span>
</p><ol class="enumerate" type=1><li class="li-enumerate">
Initialize the basis to the empty list, and a list of critical
pairs to empty
</li><li class="li-enumerate">Add one by one all the <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub> to the basis and update
the list of critical pairs with Gebauer and Möller criterion, 
by calling the gbasis update procedure (described below step 9)
</li><li class="li-enumerate">Begin of a new iteration:<br>
All pairs of minimal total degree are
collected to be reduced simultaneously, they are removed from
the list of critical pairs.
</li><li class="li-enumerate">The symbolic preprocessing step begins by creating 
a list of monomials, gluing
together all monomials of the corresponding s-polys (this
is done with a heap data structure). 
</li><li class="li-enumerate">The list of monomials is “reduced” by division with respect 
to the current basis,
using heap division (like Monagan-Pearce [<a href="#monagan2011sparse"></a>]) 
without taking care
of the real value of coefficients. This gives a list of all possible remainder
monomials and a list of all possible quotient monomials and a list
of all quotient times corresponding basis element monomial products.
This last list together with the remainder monomial list is the
list of all possible monomials that may be generated reducing
the list of critical pairs of maximal total degree, 
it is ordered with respect to &lt;. We
record these lists for further primes during the first prime computation.
</li><li class="li-enumerate">The list
of quotient monomials is multiplied by the corresponding elements of the current
basis, this time doing the coefficient arithmetic.
The result is recorded in a sparse matrix, each row has a pointer
to a list of coefficients (the list of coefficients 
is in general shared by many rows, the rows have the
same reductor with a different monomial shift), 
and a list of monomial indices (where the index 
is relative to the ordered list of possible monomials). We sort
the matrix by decreasing order of leading monomial.
</li><li class="li-enumerate">Each s-polynomial is written as a dense vector with respect to the
list of all possible monomials, and reduced with respect to the
sparse matrix, by decreasing order with respect to &lt;.
(To avoid reducing modulo <span style="font-style:italic">p</span> each time, we are using a dense
vector of 128 bits integers on 64 bits architectures, 
and we reduce mod <span style="font-style:italic">p</span> only at the end of the reduction. If
we work on 24 bit signed integers, we can use a dense vector 
of 63 bits signed integer and reduce the vector if the number
of rows is greater than 2<sup>15</sup>).
</li><li class="li-enumerate">Then inter-reduction happens on all the dense vectors representing
the reduced s-polynomials, this is dense row
reduction to echelon form (0 columns are removed first). 
Care must be taken at this step
to keep row ordering when learning is active.
</li><li class="li-enumerate">gbasis update procedure<br>
Each non zero row will bring a new entry in the current
basis (we record zero reducing pairs during the first prime iteration,
this information will be used during later iterations with other
primes to avoid computing and reducing
useless critical pairs). 
New critical pairs are created with this new entry (discarding useless
pairs by applying Gebauer-Möller criterion).
An old entry in the basis may be removed if it’s leading monomial
has all partial degrees greater or equal to the leading monomial
corresponding degree of the new entry.
Old entries may also be reduced with respect to the new entries 
at this step or at the end of the main loop.
</li><li class="li-enumerate">If there are new critical pairs remaining start a new iteration
(step 3). Otherwise the current basis is the Groebner basis.
</li></ol><p><span style="font-weight:bold">Modular algorithm</span>
</p><ol class="enumerate" type=1><li class="li-enumerate">
Set a list of reconstructed basis to empty.
</li><li class="li-enumerate">Learning prime: Take a prime number of 31 bits 
or 29 bits for pseudo division, run the Buchberger algorithm modulo this
prime recording symbolic preprocessing data and the list of critical pairs
reducing to 0.
</li><li class="li-enumerate">Loop begin:
Take a prime of 29 bits size or a list of <span style="font-style:italic">n</span> primes if <span style="font-style:italic">n</span> processors
are available. Run the Buchberger algorithm.
Check if the output has the same leading terms than one of the
chinese remainder reconstructed outputs from previous primes,
if so combine them by Chinese remaindering and go to step 4, otherwise add
a new entry in the list of reconstructed basis and continue with
next prime at step 3 (clearing all learning data is probably a good
idea here).
</li><li class="li-enumerate">If the Farey ℚ-reconstructed basis is not 
identical to the previous one, go to the loop iteration step 3
(a fast way to check that is to reconstruct with all primes
but the last one, and check the value modulo the last prime).
If they are identical, run the final check : the initial polynomials <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub> must reduce
to 0 modulo the reconstructed basis and
the reconstructed basis s-polys must reduce to 0 (this is
done on ℚ either directly or by modular reconstruction
for the deterministic algorithm, or checked modulo several primes
for the probabilistic algorithm). On success output the ℚ
Groebner basis, otherwise continue with next prime at step 3.
</li></ol><p><span style="font-weight:bold">Benchmarks</span><br>
Comparison of giac (1.1.0-26) with Singular 3.1 from sage
5.10<sup><a id="text8" href="#note8">8</a></sup>
on Mac OS X.6, Dual Core i5 2.3Ghz, RAM 2*2Go:
</p><ul class="itemize"><li class="li-itemize">
Mod timings were computed modulo <code>nextprime(2^24)</code>
and modulo 1073741827 (<code>nexprime(2^30)</code>).
</li><li class="li-itemize">Probabilistic check on ℚ depends linearly on log of precision, two
timings are reported, one with error probability less than <code>1e-7</code>, and
the second one for <code>1e-16</code>.
</li><li class="li-itemize">Check on ℚ in giac can be done with integer or modular computations
hence two times are reported.
</li><li class="li-itemize"><code>&gt;&gt;</code> means timeout (3/4h or more) or memory exhausted
(Katsura12 modular <code>1e-16</code> check with giac) or test not done because
it would obviously timeout (e.g. Cyclic8 or 9 on ℚ with Singular)
</li></ul><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >giac mod <span style="font-style:italic">p</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" >giac</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >singular</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >giac ℚ prob.</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >giac ℚ</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >singular </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >24, 31 bits</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >run2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >mod <span style="font-style:italic">p</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><code>1e-7</code>, <code>1e-16</code></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > certified</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >std ℚ </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >Cyclic7</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0.5, 0.58</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0.1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >2.0</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >3.5, 4.2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >21, 29.3</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&gt;2700 </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >Cyclic8</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >7.2, 8.9</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >1.8</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >52.5</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >103, 106</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >258, 679</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&gt;&gt; </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >Cyclic9</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >633, 1340</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >200</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >?</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >1 day</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&gt;&gt;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&gt;&gt; </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >Kat8</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0.063, 0.074</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0.009</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0.2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0.33, 0.53</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >6.55, 4.35</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >4.9</td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >Kat9</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0.29, 0.39</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0.05</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >1.37</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >2.1, 3.2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >54, 36</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >41</td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >Kat10</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >1.53, 2.27</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0.3</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >11.65</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >14, 20.7</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >441, 335</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >480 </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >Kat11</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >10.4, 13.8</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >2.8</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >86.8</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >170, 210</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >4610</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >? </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >Kat12</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >76, 103</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >27</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >885</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >1950, RAM</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >RAM</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&gt;&gt; </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >alea6</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0.83, 1.08</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >.26</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >4.18</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >202, 204</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >738, &gt;&gt;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&gt;1h</td></tr>
</table><p><br>
This leads to the following observations :
</p><ul class="itemize"><li class="li-itemize">
Computation modulo <span style="font-style:italic">p</span> for 24 to 31 bits is faster that Singular, but seems also
faster than magma (and maple). For smaller primes, magma is 2 to 3
times faster.
</li><li class="li-itemize">The probabilistic algorithm on ℚ is much faster than Singular on these examples.
Compared to maple16, it is reported to be faster for Katsura10, 
and as fast for Cyclic8. Compared to magma, it is about 3 to 4
times slower. 
</li><li class="li-itemize">If [<a href="#magma"></a>] is up to date (except about giac), giac is the third software and first
open-source software to solve Cyclic9 on ℚ. It requires 378
primes of size 29 bits, takes a little more than 1 day, requires 5Gb
of memory on 1 processor, while with 6 processors it takes
8h30 (requires 16Gb). The answer has integer coefficients of about 1600 digits
(and not 800 unlike in J.-C. Faugère F4 article), for a little
more than 1 milliion monomials, that’s about 1.4Gb of RAM.
</li><li class="li-itemize">The deterministic modular algorithm is much faster than Singular for Cyclic examples,
and as fast for Katsura examples. 
</li><li class="li-itemize">For the random last example, the speed is comparable between
magma and giac. This is where there are less pairs reducing to
0 (learning is not as efficient as for Cyclic or Katsura) and larger
coefficients. This would suggest that advanced algorithms 
like f4/f5/etc. are probably
not much more efficient than Buchberger algorithm for these kind
of inputs without symmetries.
</li><li class="li-itemize">Certification is the most time-consuming part of the process (except
for Cyclic8). Integer certification is significantly faster than modular certification
for Cyclic examples, and almost as fast for Katsura.
</li></ul><p>Example of Giac/Xcas code:
</p><pre class="verbatim">alea6 := [5*x^2*t+37*y*t*u+32*y*t*v+21*t*v+55*u*v,
39*x*y*v+23*y^2*u+57*y*z*u+56*y*u^2+10*z^2+52*t*u*v,
33*x^2*t+51*x^2+42*x*t*v+51*y^2*u+32*y*t^2+v^3,
44*x*t^2+42*y*t+47*y*u^2+12*z*t+2*z*u*v+43*t*u^2,
49*x^2*z+11*x*y*z+39*x*t*u+44*x*t*u+54*x*t+45*y^2*u,
48*x*z*t+2*z^2*t+59*z^2*v+17*z+36*t^3+45*u];
l:=[x,y,z,t,u,v];
p1:=prevprime(2^24); p2:=prevprime(2^29);
time(G1:=gbasis(alea6 % p1,l,revlex));
time(G2:=gbasis(alea6 % p2,l,revlex));
threads:=2; // set the number of threads you want to use
// debug_infolevel(1); // uncomment to show intermediate steps
proba_epsilon:=1e-7; // probabilistic algorithm.
time(H0:=gbasis(alea6,indets(cyclic5),revlex));
proba_epsilon:=0; // deterministic
time(H1:=gbasis(alea6,indets(cyclic5),revlex));
time(H2:=gbasis(alea6,indets(cyclic5),revlex,modular_check));
size(G1),size(G2),size(H0),size(H1),size(H2);
write("Halea6",H0);
</pre><p>Note that for small examples (like Cyclic5), the system performs always the deterministic
check (this is the case if the number of elements of the reconstructed basis
to 50).</p>
<!--TOC subsection id="sec86" Conclusion-->
<h3 id="sec86" class="subsection">9.7  Conclusion</h3><!--SEC END --><p>
I have described some enhancements to a modular algorithm
to compute Groebner basis over ℚ which, combined to 
linear algebra from F4, gives
a sometimes much faster open-source implementation 
than state-of-the-art open-source implementations 
for the deterministic algorithm. 
The probabilistic algorithm is also not ridiculous
compared to the best publicly available closed-source implementations,
while being much easier to implement
(about 10K lines of code, while Fgb is said to be 200K lines of code,
no need to have highly optimized sparse linear algebra).</p><p>This should speed up conjectures with the probabilistic algorithm
and automated proofs using the deterministic
algorithm (e.g. for the Geogebra theorem prover
[<a href="#botanaimplementing"></a>]), 
either using Giac/Xcas (or one of it’s interfaces
to java and python) or adapting it’s implementation
to other open-source systems.
With fast closed-source implementations (like maple or magma), 
there is no certification that the result is a Groebner basis :
there might be some hidden probabilistic
step somewhere, in integer linear system reduction for example. I have
no indication that it’s the case but one can never know if the code is
not public, and at least for my implementation, certification
might take a lot more time than computation. </p><p>There is still room for additions and improvements
</p><ul class="itemize"><li class="li-itemize">
the checking step can certainly be improved using
knowledge on how the basis element modulo <span style="font-style:italic">p</span> where
built.
</li><li class="li-itemize">checking could also benefit from parallelization.
</li><li class="li-itemize">As an alternative to the modular algorithm,
a first learning run could be done modulo a 24 bits prime, and
the collected info used for f4 on ℚ as a probabilistic alternative
to F5.
</li><li class="li-itemize">FGLM conversion is still not optimized and therefore
slow in Giac/Xcas, 
</li></ul><p><span style="font-weight:bold">Acknowledgements</span> <br>
Thanks to Frédéric Han for interfacing giac with Python.
Thanks to Vanessa Vitse for insightfull discussions.</p>
<!--TOC subsection id="sec87" Représentation rationnelle univariée 
(rur).-->
<h3 id="sec87" class="subsection">9.8  Représentation rationnelle univariée 
(rur<a id="hevea_default80"></a><a id="hevea_default81"></a><a id="hevea_default82"></a>).</h3><!--SEC END --><p>
<a id="sec:rur"></a>
Lorsqu’on résoud un système polynomial, on a (en général) autant
d’équations que d’inconnues et en principe un nombre fini de solutions.
On peut utiliser une base de Groebner dans l’ordre lexicographique,
résoudre par rapport à la dernière variable, puis remonter, mais
d’une part le calcul d’une base de Groebner dans l’ordre lexicographique
est significativement plus long que dans l’ordre revlex, et d’autre
part il faut calculer des PGCD et 
factoriser des polynômes sur des extensions algébriques
dont la taille peut augmenter au fur et à mesure que l’on remonte (ou faire
des calculs approchés...). Il serait plus intéressant de calculer
d’un seul coup une extension algébrique de ℚ qui permette
d’exprimer toutes les variables. Ceci peut se faire si on arrive à
trouver une forme linéaire en les variables qui sépare
les solutions (la valeur de la forme est distincte si les points
solutions sont distincts). On rajoute cette variable et on résoud
l’équation obtenue en cette variable, pour chaque solution on aura
une unique solution en remontant les autres variables. La représentation
univariée rationnelle fait précisément cela, et donne même les
autres variables comme polynôme en la forme linéaire séparante.</p><p>La présentation classique de la représentation univariée rationnelle 
utilise des calculs de trace (cf. par exemple le rapport de l’Inria 1998
de Fabrice Rouillier), l’algorithme
implémenté dans Giac/Xcas (versions 1.1.1 et ultérieures)
est un algorithme modulaire. On commence par se ramener
au cas d’un idéal radical (c’est-à-dire que les
points solutions du système sont de multiplicité 1)
en ajoutant aux générateurs de l’idéal 
les parties squarefree des polynômes
minimaux de toutes les variables. Pour un idéal radical,
on montre qu’il existe une forme linéaire séparante, le degré
du polynôme minimal de cette forme linéaire séparante est
exactement égal à la dimension du quotient de 
l’anneau de polynômes par l’idéal radical. On peut donc tester si une forme
linéaire est séparante en calculant son polynôme minimal. En pratique,
on commence par calculer une base de Groebner pour l’ordre revlex 
(le plus efficace). On génère la liste des monomes du quotient
en commençant par majorer les degrés en chacune des variables,
puis on élimine parmi les monomes possibles 
ceux qui sont divisibles par le monome dominant d’un élément
de la base de Groebner. On calcule ensuite la classe d’un polynôme
dans le quotient en effectuant une réduction par la base
de Groebner, on obtient un vecteur de coordonnées dans cette base de monome.
Le calcul du polynôme minimal d’une forme linéaire
devient ainsi un problème d’algèbre linéaire.
Le calcul de chaque variable en fonction des puissances d’une forme linéaire
séparante est également un problème d’algèbre linéaire (on le fait
simultanément pour toutes les variables, si on veut optimiser on
peut même faire une décomposition LU lors du calcul du polynôme minimal
et la réutiliser). Pour éviter les problèmes de croissance de coefficients
dans les calculs intermédiaires,
ce calcul est effectué modulo plusieurs nombres premiers dans giac,
jusqu’à pouvoir reconstruire par les restes chinois le polynôme minimal
de la forme séparante sur ℚ et les expressions des variables comme
polynôme de la forme séparante (on n’a alors pas besoin
de reconstruire la base de Groebner sur ℚ). Bien entendu,
il faut traiter le cas des mauvaises réductions, pour cela
on regarde si les monomes de la base du quotient de l’anneau par l’idéal
sont indépendants du nombre premier choisi, en cas de différence,
il faut conserver le nombre premier correspondant à la liste
de monômes la plus grande (l’autre nombre premier est de mauvaise
réduction), ou rejeter les deux nombres premiers si aucune
des deux listes de monomes ne contient l’autre.</p><p>Les fonctions <code>solve</code>, <code>fsolve</code> et <code>cfsolve</code> 
utilisent cet algorithme
pour des systèmes polynomiaux qui s’y prêtent (en cherchant une
forme séparante d’abord parmi les variables puis avec des combinaisons
linéaires aléatoires à petits coefficients entiers),
<code>solve</code> essaie de renvoyer des solutions exactes
si le polynome minimal de la forme linéaire séparante
se factorise sur ℚ, <code>fsolve</code> (en mode réel)
localise les racines réelles par la méthode d’Akritas,
<code>cfsolve</code> localise les racines complexes par
factorisation de Schur de la matrice companion. La fonction
<code>gbasis(eqs,vars,rur)</code> avec comme paramètre optionnel <code>rur</code>
effectue le calcul de la représentation univariée rationnelle
et renvoie une liste contenant le polynôme minimal <span style="font-style:italic">P</span>
(exprimée arbitrairement en fonction de la 1ère variable du système),
sa dérivee <span style="font-style:italic">P</span>′ et les <span style="font-style:italic">P</span><sub>1</sub>,...,<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> qui permettent d’exprimer
la <span style="font-style:italic">i</span>-ème variable d’une solution comme étant <span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub>(<span style="font-style:italic">r</span>)/<span style="font-style:italic">P</span>′(<span style="font-style:italic">r</span>)
avec <span style="font-style:italic">r</span> racine de <span style="font-style:italic">P</span>. On peut alors
vérifier que l’on a bien une solution en remplaçant la variable
<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> par <span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub>/<span style="font-style:italic">P</span>′ dans les équations, le reste de la division
euclidienne du numérateur de la fraction obtenue par le polynome 
minimal <span style="font-style:italic">P</span> doit donner 0.</p><p>Exemple :
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">syst:=[x^2-y^2-1,x^3+y^3-x*y-5]:fsolve(syst,[x,y]) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
Calcul en mode pas à pas :
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">G:=gbasis(syst,[x,y],rur) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
l’élément d’indice 1 est la forme linéaire séparante,
en indice 2, le polynôme minimal de l’élément séparant
exprimé en fonction de <span style="font-style:italic">x</span>, en indice 3 sa dérivée qui
sera le dénominateur commun de la solution, en indices
de 4 à la fin le numérateur de la solution en fonction de <span style="font-style:italic">x</span>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">d:=G[3];[G[4]/d,G[5]/d]; G[2] 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
On vérifie :
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">N:=numer(normal(subst(syst,[x,y],[G[4]/d,G[5]/d]))) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">rem(N[0],G[2]); rem(N[1],G[2]) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
On trouve les solutions approchées
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">S:=proot(G[2]);subst([G[4]/d,G[5]/d],x=S[0]) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p><p>La représentation rationnelle univariée a des applications
au-delà de la seule résolution de systèmes polynomiaux.
On peut s’en servir pour trouver une extension algébrique unique de
ℚ permettant de calculer toutes les racines d’un polynôme, 
il suffit de poser le système formé par les relations
racines-coefficients de ce polynôme et d’en chercher la
représentation rationnelle univariée, cf. la section 
<a href="#sec%3Afactorisation_extension">18.6</a>.
On peut également s’en servir pour trouver une 
<span style="font-weight:bold">extension
algébrique</span><a id="hevea_default83"></a><a id="hevea_default84"></a> 
unique contenant plusieurs extensions de ℚ
dont on a le polynôme minimal. Par exemple pour
travailler dans ℚ[√<span style="text-decoration:overline">2</span>,√<span style="text-decoration:overline">3</span>,√<span style="text-decoration:overline">5</span>], on pose <br>
<code>G:=gbasis([a^2-2,b^2-3,c^2-5],[a,b,c],rur)</code>,<br>
on a alors ± √<span style="text-decoration:overline">2</span>=<code>rootof(G[4],G[2])/rootof(G[3],G[2])</code>,<br>
± √<span style="text-decoration:overline">3</span>=<code>rootof(G[5],G[2])/rootof(G[3],G[2])</code>,<br>
± √<span style="text-decoration:overline">5</span>=<code>rootof(G[6],G[2])/rootof(G[3],G[2])</code><br>
(on peut utiliser <code>normal</code> ou <code>evalf</code> pour décider du signe).</p>
<!--TOC section id="sec88" Courbes paramétriques et polaires-->
<h2 id="sec88" class="section">10  Courbes paramétriques et polaires</h2><!--SEC END --><p> <a id="sec:courbes"></a></p>
<!--TOC subsection id="sec89" Introduction-->
<h3 id="sec89" class="subsection">10.1  Introduction</h3><!--SEC END --><p>
Le graphe d’une fonction <span style="font-style:italic">f</span>: <span style="font-style:italic">I</span> ↦ ℝ (<span style="font-style:italic">I</span> un intervalle)
est un exemple de courbe du plan, mais il
n’est pas assez général pour représenter tous les types de
courbe du plan, par exemple un segment de droite vertical, ou
un cercle, car deux points distincts d’un graphe doivent avoir
des abscisses différentes. D’autre part, il apparait naturellement
d’autres types de courbes que les graphes de fonction, par exemple
la trajectoire d’un mobile dans le plan dont les coordonnées <span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>
dépendent du temps (selon une équation différentielle ou
un système différentiel), ce sont les courbes paramétriques,
ou des courbes vérifiant une
équation cartésienne (par exemple en géométrie
le cercle <span style="font-style:italic">x</span><sup>2</sup>+<span style="font-style:italic">y</span><sup>2</sup>=1, ou en cinématique des courbes
de niveau de l’énergie totale dans le plan position-impulsion)
ce sont les courbes implicites.</p><p>Dans cette section, on va étudier les courbes en paramétriques,
donnée par un couple de fonctions (<span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>),<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)) définies 
pour <span style="font-style:italic">t</span> dans un sous-ensemble des réels et à valeurs dans ℝ.
(Ceci ne restreint pas trop la généralité,
on peut montrer sous des hypothèses assez générales 
que l’allure locale d’une courbe implicite est identique à celle
d’une courbe paramétrique, sauf en certains points dits singuliers,
c’est le théorème des fonctions implicites).</p><p>Exemples :
</p><ul class="itemize"><li class="li-itemize">
le graphe d’une fonction <span style="font-style:italic">y</span>=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) est une courbe paramétré
d’équation (<span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>),<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>))=(<span style="font-style:italic">t</span>,<span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>)) (<span style="font-style:italic">x</span> est le temps). 
On aurait aussi pu choisir
(<span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>),<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>))=(<span style="font-style:italic">t</span>−1,<span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>−1)) (ce qui revient à changer l’origine des
temps) ou d’autres paramétrages.
Exemple : <br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plotfunc(sin(x))
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>


<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plotparam([t-1,sin(t-1)],t)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">une droite d’équation <span style="font-style:italic">y</span>=<span style="font-style:italic">ax</span>+<span style="font-style:italic">b</span> est le graphe d’une fonction,
donc paramétrable comme ci-dessus. Une droite verticale <span style="font-style:italic">x</span>=<span style="font-style:italic">a</span> peut
se paramétrer par (<span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>),<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>))=(<span style="font-style:italic">a</span>,<span style="font-style:italic">t</span>)
</li><li class="li-itemize">le cercle de centre l’origine et de rayon 1 peut se paramétrer
par (<span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>),<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>))=(cos(<span style="font-style:italic">t</span>),<span style="font-style:italic">sin</span>(<span style="font-style:italic">t</span>)), <span style="font-style:italic">t</span> ∈ [0,2π[. On peut bien sur
le paramétrer par <span style="font-style:italic">t</span> ∈ ℝ, mais dans ce cas on parcourt plusieurs
fois le cercle (périodicité). On peut aussi paramétrer tout le
cercle sauf un point avec le paramétrage rationnel
(<span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>),<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>))=(1−<span style="font-style:italic">t</span><sup>2</sup>/1+<span style="font-style:italic">t</span><sup>2</sup>,2<span style="font-style:italic">t</span>/1+<span style="font-style:italic">t</span><sup>2</sup>), <span style="font-style:italic">t</span> ∈ ℝ. Ce
paramétrage permet de calculer plus facilement des points
du cercle, mais contrairement au paramétrage trigonométrique,
il n’est pas “uniforme”.<br>
Exemple 

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plotparam([cos(t),sin(t)],t=0..2*pi)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:40px;font-size:large">plotparam([(1-t^2)/(1+t^2),2t/(1+t^2)],t=-10..10)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

ou avec les nombres complexes<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plotparam((1+i*t)/(1-i*t),t=-10..10)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</p></li></ul>
<!--TOC subsection id="sec90" Représentation graphique-->
<h3 id="sec90" class="subsection">10.2  Représentation graphique</h3><!--SEC END --><p> 
La plupart des calculatrices graphiques
et de nombreux logiciels de maths permettent de
représenter graphiquement un arc de courbe en donnant des valeurs
extrêmes <span style="font-style:italic">t</span><sub>−</sub> et <span style="font-style:italic">t</span><sub>+</sub> (souvent notées <code>tmin</code> et
<code>tmax</code>) et un pas Δ <span style="font-style:italic">t</span> (<code>tstep</code>). Le logiciel évalue
la valeur de <span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>) et <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>) en <span style="font-style:italic">t</span><sub>−</sub>, <span style="font-style:italic">t</span><sub>−</sub>+Δ <span style="font-style:italic">t</span>, <span style="font-style:italic">t</span><sub>−</sub>+2Δ
<span style="font-style:italic">t</span>, ... puis relie les points de la courbe obtenue par des segments
(parfois avec des autres arcs de courbes). La plupart du temps
cela donne une bonne idée de la courbe, mais parfois on peut
manquer un détail intéressant (valeur de Δ <span style="font-style:italic">t</span> trop
grande), ou un morceau de courbe (mauvaises
valeurs de <span style="font-style:italic">t</span><sub>−</sub> et <span style="font-style:italic">t</span><sub>+</sub>). Par exemple 

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:40px;font-size:large">plotfunc(x+0.01/(x-sqrt(2)),x=-2..2,xstep=0.1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>Il peut être nécessaire d’ajuster le cadrage graphique
à l’affichage (<code>xmin</code>, <code>xmax</code>, <code>ymin</code>, <code>ymax</code>) ou
de l’affiner avec un menu de <code>zoom</code>. Sur les calculatrices
les opérations de changement de cadrage graphique
provoquent un nouveau calcul complet qui peut durer une
dizaine de secondes.</p><p>Mise en oeuvre :
</p><ul class="itemize"><li class="li-itemize">
avec Xcas: on utilise la commande <code>plotparam</code>
dans le menu <code>Graphe, Courbes</code>. Le cadrage
graphique est calculé automatiquement et peut être
modifié par les touches menus à droite du graphe.
On peut spécifier le pas avec l’argument optionnel <code>tstep=</code>.
</li><li class="li-itemize">HP Prime : touche Apps puis Paramétrique, entrer les
formules donnant <span style="font-style:italic">X</span>1 et <span style="font-style:italic">Y</span>1 en fonction de <span style="font-style:italic">T</span>, puis touche
Plot. Pour régler la discrétisation, faire shift-Plot (Plot
setup).<br>
Ou touche Apps puis Géométrie et utiliser les mêmes commandes 
qu’avec Xcas.
</li><li class="li-itemize">sur les calculatrices TI89/92/voyage 200 : il faut sélectionner le mode
de tracé paramétrique avec la touche MODE,
puis sur <code>Y=</code>, l’écran de définition
de <span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>),<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>) apparait. Si les réglages graphiques
ne sont pas satisfaisants, la touche <code>WINDOW</code>
permet d’y accéder, puis la touche <code>GRAPH</code> lance
le tracé.
</li><li class="li-itemize">TI Nspire : lancer Graphes depuis Home puis touche Menu,
3. Graph puis 3. Parametric. On peut aussi régler le zoom depuis Menu.
</li></ul><p>Exemples : essayez de tracer quelques courbes en paramétriques
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(2cos(<span style="font-style:italic">t</span>),3sin(<span style="font-style:italic">t</span>)),    (cos(2<span style="font-style:italic">t</span>),sin(3<span style="font-style:italic">t</span>)),    (<span style="font-style:italic">t</span><sup>2</sup>,<span style="font-style:italic">t</span><sup>3</sup>),
   (<span style="font-style:italic">t</span>+1/<span style="font-style:italic">t</span>, <span style="font-style:italic">t</span><sup>2</sup>+2/<span style="font-style:italic">t</span>),    (</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">t</span>−1</td></tr>
</table></td><td class="dcell">,</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2−<span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">) </td></tr>
</table>
<!--TOC subsection id="sec91" Paramétrage-->
<h3 id="sec91" class="subsection">10.3  Paramétrage</h3><!--SEC END --><p>
On adoptera souvent la convention d’appeler temps le paramétre <span style="font-style:italic">t</span>.
Mais cela ne signifie pas que le paramétrage est réellement le
temps mesuré en secondes. On peut très bien paramétrer une
courbe avec un paramètre autre, qui peut être un multiple 
constant ou variable du temps (c’est d’ailleurs conforme au
principe de la relativité). Le paramétrage n’est jamais unique,
on peut changer de paramétrage pourvu que la fonction donnant
le nouveau en fonction de l’ancien paramétrage soit une bijection
(qui peut même renverser le sens de déroulement du temps
c’est-à-dire le sens de parcours de la courbe). On utilisera
d’ailleurs plus loin un paramétrage par la longueur,
où la courbe est parcourue à vitesse constante égale à 1.</p><p>Le choix d’un paramétrage est ce qui fait la différence
entre la cinématique (on prend le temps comme paramètre) et la 
géométrie
(où on cherche à décrire les propriétés intrinséques
de la courbe indépendamment
du paramétrage). Ainsi, l’équation cartésienne d’une courbe
est une propriété géométrique, indépendante du choix
de paramétrage choisi pour l’obtenir. </p><p>On observe aussi que l’opération
inverse, trouver un paramétrage à partir d’une équation
cartésienne de courbe n’est pas possible de manière
explicite, sauf dans quelques cas particuliers. C’est pour cette
raison qu’il est beaucoup plus difficile (et couteux en temps)
d’obtenir une représentation graphique d’une courbe donnée
par son équation cartésienne.</p>
<!--TOC subsection id="sec92" Étude analytique d’une courbe en paramétrique-->
<h3 id="sec92" class="subsection">10.4  Étude analytique d’une courbe en paramétrique</h3><!--SEC END --><p>
<a id="hevea_default85"></a></p>
<!--TOC subsubsection id="sec93" Rappel sur les graphes de fonction-->
<h4 id="sec93" class="subsubsection">10.4.1  Rappel sur les graphes de fonction</h4><!--SEC END --><p>
Pour tracer le graphe d’une fonction <span style="font-style:italic">f</span>, on commence par
déterminer le domaine de
définition, on restreint éventuellement l’intervalle d’étude
(parité, périodicité). Puis on calcule les limites aux bornes
du domaine de définition :
</p><ul class="itemize"><li class="li-itemize">
une limite infinie en <span style="font-style:italic">x</span>=<span style="font-style:italic">a</span> fini correspond à une asymptote
verticale d’équation <span style="font-style:italic">x</span>=<span style="font-style:italic">a</span>.<br>
Exemple 
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:40px;font-size:large">purge(x);plot((x+1)/(x-2),x=0..4); line(x=2,color=red)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">une limite finie <span style="font-style:italic">l</span> lorsque <span style="font-style:italic">x</span>→ ± ∞ correspond
à une asymptote horizontale d’équation <span style="font-style:italic">y</span>=<span style="font-style:italic">l</span>.<br>
Exemple 
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:40px;font-size:large">purge(y);plot((x^2-1)/(x^2+1),x=0..10); line(y=1,color=red)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">si <span style="font-style:italic">y</span> tend vers ± ∞ lorsque <span style="font-style:italic">x</span>→ ± ∞,
on a une branche infinie. S’il s’agit d’une asymptote <span style="font-style:italic">y</span>=<span style="font-style:italic">ax</span>+<span style="font-style:italic">b</span>+<span style="font-style:italic">o</span>(1), alors
<span style="font-style:italic">y</span>/<span style="font-style:italic">x</span>=<span style="font-style:italic">a</span>+<span style="font-style:italic">b</span>/<span style="font-style:italic">x</span>+<span style="font-style:italic">o</span>(1/<span style="font-style:italic">x</span>) tend vers <span style="font-style:italic">a</span> lorsque <span style="font-style:italic">x</span> tend vers +∞ ce qui
permet de trouver <span style="font-style:italic">a</span> en calculant lim<sub><span style="font-style:italic">x</span>→ +∞</sub> <span style="font-style:italic">y</span>/<span style="font-style:italic">x</span>,
puis <span style="font-style:italic">b</span>=lim<sub><span style="font-style:italic">x</span>→ +∞</sub><span style="font-style:italic">y</span>−<span style="font-style:italic">ax</span>. Si <span style="font-style:italic">b</span> est fini, on a une
asymptote, sinon une branche parabolique de direction <span style="font-style:italic">y</span>=<span style="font-style:italic">ax</span>. 
On remarque que si <span style="font-style:italic">a</span>=0,
comme <span style="font-style:italic">y</span> tend vers l’infini, on ne peut pas avoir d’asymptote, on
parle de branche parabolique de direction <span style="font-style:italic">Ox</span>. Si <span style="font-style:italic">y</span>/<span style="font-style:italic">x</span> tend vers
l’infini, on a une branche parabolique de direction <span style="font-style:italic">Oy</span>.<br>
Exemple 
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:40px;font-size:large">plot(x^2/(x+1),x=0..10);line(y=x-1,color=red)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-itemize">Lorsqu’il y a une asymptote d’équation <span style="font-style:italic">y</span>=<span style="font-style:italic">ax</span>+<span style="font-style:italic">b</span>, 
on peut raffiner en cherchant la
position de la courbe par rapport à l’asymptote en étudiant le
signe de <span style="font-style:italic">y</span>−(<span style="font-style:italic">ax</span>+<span style="font-style:italic">b</span>)
</li></ul><p>
On calcule la dérivée première de <span style="font-style:italic">f</span> pour déterminer le sens
de variations, les points d’annulation correspondent à des tangentes
horizontales. On peut étudier la convexité de <span style="font-style:italic">f</span> (signe de
<span style="font-style:italic">f</span>′′), les points d’inflexion de la courbe se produisent lorsque
<span style="font-style:italic">f</span>′′ s’annule.
On trace alors la courbe en faisant apparaitre les points particuliers
et les asymptotes.</p><p>Pour une courbe en paramétrique, le plan général est analogue,
mais l’étude est un peu plus compliquée puisqu’on a 
deux fonctions <span style="font-style:italic">t</span> → <span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>) et <span style="font-style:italic">t</span> → <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)
au lieu d’une seule <span style="font-style:italic">x</span> → <span style="font-style:italic">y</span>(<span style="font-style:italic">x</span>).</p>
<!--TOC subsubsection id="sec94" Domaine et périodicité-->
<h4 id="sec94" class="subsubsection">10.4.2  Domaine et périodicité</h4><!--SEC END --><p>
On supposera dans toute la suite que les fonctions <span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>) et <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)
sont continument dérivables au moins 2 fois, sauf peut-être
en un nombre fini de réels d’un intervalle <span style="font-style:italic">I</span> de ℝ.</p><p>On commence par déterminer le domaine de définition de <span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>)
et de <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>), et on essaie de le réduire si possible, soit par
périodicité (par exemple pour le cercle ci-dessus, <span style="font-style:italic">t</span> ∈ [0,2 π])
soit par l’existence de symétries si les fonctions
<span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>) et <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>) sont paires ou impaires. Par exemple, si <span style="font-style:italic">x</span> et <span style="font-style:italic">y</span>
sont paires, alors on parcourt deux fois le même arc de courbe
sur ℝ<sup>+</sup> et ℝ<sup>−</sup>, on peut restreindre le domaine d’étude
à <span style="font-style:italic">t</span>≥ 0. Si <span style="font-style:italic">x</span> est pair et <span style="font-style:italic">y</span> impair, alors 
(<span style="font-style:italic">x</span>(−<span style="font-style:italic">t</span>),<span style="font-style:italic">y</span>(−<span style="font-style:italic">t</span>))=(<span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>),−<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)), il y a une symétrie par rapport à
l’axe des <span style="font-style:italic">x</span>, on se restreint à <span style="font-style:italic">t</span> ∈ <span style="font-style:italic">R</span><sup>+</sup>.
Dans le cas périodique, on peut tester des symétries correspondant
à des demi (voire quart) de période.
Exemple : (3cos(<span style="font-style:italic">t</span>)+2cos(3<span style="font-style:italic">t</span>),3sin(<span style="font-style:italic">t</span>)−2sin(3<span style="font-style:italic">t</span>)) </p>
<!--TOC subsubsection id="sec95" Branches infinies-->
<h4 id="sec95" class="subsubsection">10.4.3  Branches infinies</h4><!--SEC END --><p><a id="hevea_default86"></a>
On s’intéresse ensuite aux bornes du domaine de définition
et aux points où <span style="font-style:italic">x</span> ou/et <span style="font-style:italic">y</span> ne sont pas définis.
Si <span style="font-style:italic">x</span> et <span style="font-style:italic">y</span> admettent une limite finie, on peut prolonger la
courbe. Si les limites existent mais ne sont pas finies, 
on a une branche infinie (<span style="font-style:italic">x</span> ou <span style="font-style:italic">y</span>). Si l’une des deux
valeurs tend vers l’infini, l’autre restant finie, on a une
asymptote (horizontale si <span style="font-style:italic">x</span> tend vers l’infini, verticale
si <span style="font-style:italic">y</span> tend vers l’infini), on peut déterminer la position
de l’arc de courbe par rapport à l’asymptote en
cherchant le signe de <span style="font-style:italic">y</span>−<span style="font-style:italic">l</span> ou <span style="font-style:italic">x</span>−<span style="font-style:italic">l</span> lorsque <span style="font-style:italic">t</span> tend
vers la valeur particulière (limite à droite et limite
à gauche). Enfin si <span style="font-style:italic">x</span> et <span style="font-style:italic">y</span> tendent vers l’infini
tous les deux, on cherche la limite de <span style="font-style:italic">y</span>/<span style="font-style:italic">x</span>,
Si <span style="font-style:italic">y</span>/<span style="font-style:italic">x</span> → <span style="font-style:italic">a</span> ≠ 0, on a une 
<span style="font-weight:bold">branche parabolique</span><a id="hevea_default87"></a> 
de direction asymptotique<a id="hevea_default88"></a> <span style="font-style:italic">y</span>=<span style="font-style:italic">ax</span>,
on cherche alors la limite
<span style="font-style:italic">y</span>−<span style="font-style:italic">ax</span>, si cette limite est finie et vaut <span style="font-style:italic">b</span> 
on a une <span style="font-weight:bold">asymptote</span><a id="hevea_default89"></a> oblique <span style="font-style:italic">y</span>=<span style="font-style:italic">ax</span>+<span style="font-style:italic">b</span> (on peut déterminer
la position en cherchant le signe de <span style="font-style:italic">y</span>−(<span style="font-style:italic">ax</span>+<span style="font-style:italic">b</span>).</p><p>Exemples : 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span>+1</td></tr>
</table></td><td class="dcell">,<span style="font-style:italic">t</span>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup>+1</td></tr>
</table></td><td class="dcell">), 
(<span style="font-style:italic">t</span><sup>2</sup>,<span style="font-style:italic">t</span><sup>3</sup>), 
(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup>+1</td></tr>
</table></td><td class="dcell">,<span style="font-style:italic">t</span>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup>+2</td></tr>
</table></td><td class="dcell">), 
(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup>−1</td></tr>
</table></td><td class="dcell">,</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span>+1</td></tr>
</table></td><td class="dcell">), </td></tr>
</table><p>
On peut utiliser la commande <code>limit</code> dans Xcas pour étudier
une asymptote, par exemple dans le premier cas, pour étudier la
branche infinie pour <span style="font-style:italic">t</span> → +∞<sup><a id="text9" href="#note9">9</a></sup><br>
On définit les fonctions
<br><textarea onkeypress="UI.ckenter(event,this,2)" style="width:400px;height:20px;font-size:large">X(t):=t^2/(t+1);Y(t):=t+1/(t^2+1); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML='&nbsp;'+tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><span></span><br>
puis on calcule les limites lorsque <span style="font-style:italic">t</span> → +∞
<br><textarea onkeypress="UI.ckenter(event,this,2)" style="width:400px;height:40px;font-size:large">a:=limit(Y(t)/X(t),t=inf);
b:=limit(Y(t)-a*X(t),t=inf) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML='&nbsp;'+tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><span></span><br><br>
Si <span style="font-style:italic">a</span> est fini non nul et <span style="font-style:italic">b</span> fini, on en déduit que <span style="font-style:italic">y</span>=<span style="font-style:italic">ax</span>+<span style="font-style:italic">b</span> est asymptote à la courbe. Il y a une
autre asymptote pour <span style="font-style:italic">t</span>=−1 (<span style="font-style:italic">Y</span> fini, <span style="font-style:italic">X</span> tend vers l’infini)<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:100px;font-size:large">gl_x=-7..7;gl_y=-7..7;
purge(x,y);plotparam([X(t),Y(t)],t=-7..7);
line(y=a*x+b,color=red);line(y=Y(-1),color=green)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

Autre exemple :

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">X(t):=t^3/(t^2+1);Y(t):=t+1/(t^2+2);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p>
<!--TOC subsubsection id="sec96" Étude locale-->
<h4 id="sec96" class="subsubsection">10.4.4  Étude locale</h4><!--SEC END --><p>
On se place en une valeur de <span style="font-style:italic">t</span><sub>0</sub> où <span style="font-style:italic">x</span> et <span style="font-style:italic">y</span> sont continument
dérivables au moins deux fois. On notera la dérivation par rapport 
au paramètre par le signe ’ (en physique on utilise aussi le point).
On a alors un développement de Taylor à l’ordre 2
du vecteur
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">M</span>(<span style="font-style:italic">t</span><sub>0</sub>)<span style="font-style:italic">M</span>(<span style="font-style:italic">t</span><sub>0</sub>+<span style="font-style:italic">h</span>)</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">x</span>(<span style="font-style:italic">t</span><sub>0</sub>+<span style="font-style:italic">h</span>)−<span style="font-style:italic">x</span>(<span style="font-style:italic">t</span><sub>0</sub>),<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>+<span style="font-style:italic">h</span>)−<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>)) 
</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">h</span>
(<span style="font-style:italic">x</span>′(<span style="font-style:italic">t</span><sub>0</sub>),<span style="font-style:italic">y</span>′(<span style="font-style:italic">t</span><sub>0</sub>))+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">x</span>′′(<span style="font-style:italic">t</span><sub><span style="font-style:italic">x</span></sub>),<span style="font-style:italic">y</span>′′(<span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub>))
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
où <span style="font-style:italic">t</span><sub><span style="font-style:italic">x</span></sub> et <span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub> sont compris entre <span style="font-style:italic">t</span><sub>0</sub> et <span style="font-style:italic">t</span><sub>0</sub>+<span style="font-style:italic">h</span>.
Si le vecteur vitesse <span style="font-style:italic">v</span>=(<span style="font-style:italic">x</span>′(<span style="font-style:italic">t</span><sub>0</sub>),<span style="font-style:italic">y</span>′(<span style="font-style:italic">t</span><sub>0</sub>)) est non nul, on en déduit
un équivalent
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">M</span>(<span style="font-style:italic">t</span><sub>0</sub>)<span style="font-style:italic">M</span>(<span style="font-style:italic">t</span><sub>0</sub>+<span style="font-style:italic">h</span>)</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td><td class="dcell">≈ <span style="font-style:italic">h</span> (<span style="font-style:italic">x</span>′(<span style="font-style:italic">t</span><sub>0</sub>),<span style="font-style:italic">y</span>′(<span style="font-style:italic">t</span><sub>0</sub>))</td></tr>
</table><p>
Lorsque <span style="font-style:italic">h</span> est proche de 0, le vecteur <span style="font-style:italic">M</span>(<span style="font-style:italic">t</span><sub>0</sub>)<span style="font-style:italic">M</span>(<span style="font-style:italic">t</span><sub>0</sub>+<span style="font-style:italic">h</span>)
est équivalent à un vecteur colinéaire à
<span style="font-style:italic">v</span>=(<span style="font-style:italic">x</span>′(<span style="font-style:italic">t</span><sub>0</sub>),<span style="font-style:italic">y</span>′(<span style="font-style:italic">t</span><sub>0</sub>))
(supposé non nul),
qui est donc vecteur tangent à la courbe en (<span style="font-style:italic">x</span>(<span style="font-style:italic">t</span><sub>0</sub>),<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>)).</p><div class="theorem"><span style="font-weight:bold">Définition 15</span>  <em>
On appelle </em><em><span style="font-weight:bold">point régulier</span></em><a id="hevea_default90"></a><em> d’une courbe paramétrique
un point où la vitesse </em><span style="font-style:italic">v</span>(<span style="font-style:italic">t</span>)=(<span style="font-style:italic">x</span>′(<span style="font-style:italic">t</span>),<span style="font-style:italic">y</span>′(<span style="font-style:italic">t</span>))<em> est non nulle.
En un point régulier, la courbe est tangente au vecteur vitesse
(la direction du vecteur vitesse est donc une propriété
géométrique, alors que le vecteur vitesse est une propriété
cinématique).
On notera en particulier que la tangente est horizontale si </em><span style="font-style:italic">y</span>′=0<em>
et verticale si </em><span style="font-style:italic">x</span>′=0<em>.</em><p><em>On appelle </em><em><span style="font-weight:bold">point singulier</span></em><a id="hevea_default91"></a><em> 
un point où la vitesse s’annulle.
</em></p></div><p>
On verra dans la suite comment étudier la tangente en un point
singulier d’une courbe. Génériquement, une courbe n’a pas
de points singuliers, car il faut annuler simultanément les
deux dérivées, or on n’a qu’un seul paramètre libre <span style="font-style:italic">t</span>. Par contre
une famille de courbes (<span style="font-style:italic">x</span><sub><span style="font-style:italic">m</span></sub>(<span style="font-style:italic">t</span>),<span style="font-style:italic">y</span><sub><span style="font-style:italic">m</span></sub>(<span style="font-style:italic">t</span>)) dépendant d’un paramètre
<span style="font-style:italic">m</span> (par exemple <span style="font-style:italic">x</span><sub><span style="font-style:italic">m</span></sub>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">t</span><sup>2</sup>−<span style="font-style:italic">mt</span>, <span style="font-style:italic">y</span><sub><span style="font-style:italic">m</span></sub>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">m</span>/(1+<span style="font-style:italic">t</span><sup>2</sup>)+<span style="font-style:italic">t</span>)
possède en général un nombre discret de valeurs du
paramètre pour lesquelles la courbe admet un point singulier.
Dans l’exemple, <span style="font-style:italic">x</span><sub><span style="font-style:italic">m</span></sub>′=2<span style="font-style:italic">t</span>−<span style="font-style:italic">m</span>, <span style="font-style:italic">y</span><sub><span style="font-style:italic">m</span></sub>′=−2<span style="font-style:italic">mt</span>/(1+<span style="font-style:italic">t</span><sup>2</sup>)<sup>2</sup>+1, les deux 
dérivées s’annulent si <span style="font-style:italic">m</span>=−2 
(en <span style="font-style:italic">t</span>=−1, <span style="font-style:italic">x</span>=−1, <span style="font-style:italic">y</span>=−2) ou <span style="font-style:italic">m</span>=2 (en <span style="font-style:italic">t</span>=1).
Commandes Xcas :<br>
<code>x:=t^2-m*t; y:=m/(1+t^2)+t;</code><br>
<code>solve([diff(x,t),diff(y,t)],[m,t]);</code><br>
<code>supposons(m=[-2.0,-5,5,0.1]);</code> <br>
<code>plotparam([x,y],t=((-3) .. 3));</code><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">x:=t^2-m*t; y:=m/(1+t^2)+t;solve([diff(x,t),diff(y,t)],[m,t]); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>


<div><form onsubmit="setTimeout(function(){UI.eval_form(form);});return false;">
<input type="text" name="name" size="1" value=
"m">

=<input type="number" name="valname" onchange="UI.eval_form(form);" value=
"-2">

<input type="button" value="-" onclick="valname.value -= stepname.value;UI.eval_form(form);">
<input type="button" value="+" onclick="valname.value -= -stepname.value;UI.eval_form(form);">
<input type="number" name="stepname" value=
"0.1">

<input type="range" name="rangename"
onclick="valname.value=value;UI.eval_form(form);" value=
"-2" min="-5" max="5" step="0.1">

<textarea name="prog" onchange="UI.eval_form(form)" style="width:400px;height:120px;vertical-align:bottom;font-size:large">

gl_x=-3..3;gl_y=-4..4;
x:=t^2-m*t;y:=m/(1+t^2)+t;
plotparam([x,y],t=-3..3)

</textarea>
</form>
<span>Not evaled</span></div>

</p><p><span style="font-weight:bold">Remarque </span>: en cinématique, si la vitesse et l’accélération
sont nulles en un point
et que les équations ne dépendent pas explicitement du temps,
on reste indéfiniment en ce point qui est un point d’équilibre,
la notion de tangente à la courbe n’a alors pas de sens.
On peut aussi suivre une trajectoire qui se rapproche 
de plus en plus d’un point d’équilibre (la limite de (<span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>),<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>))
est alors ce point, pour <span style="font-style:italic">t</span> → +∞ si l’équilibre
est stable ou <span style="font-style:italic">t</span> → − ∞ si l’équilibre est instable).</p><p>Pour faire une étude locale plus précise dans le cas d’un point
régulier, ou pour déterminer la tangente en un point singulier,
il faut poursuivre le développement de Taylor à un ordre plus
grand. Á l’ordre 2, si <span style="font-style:italic">x</span> et <span style="font-style:italic">y</span> sont 3 fois continument
dérivables, il existe <span style="font-style:italic">t</span><sub><span style="font-style:italic">x</span></sub>,<span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub>∈ [<span style="font-style:italic">t</span><sub>0</sub>,<span style="font-style:italic">t</span><sub>0</sub>+<span style="font-style:italic">h</span>] tels que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">M</span>(<span style="font-style:italic">t</span><sub>0</sub>)<span style="font-style:italic">M</span>(<span style="font-style:italic">t</span><sub>0</sub>+<span style="font-style:italic">h</span>)</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td><td class="dcell">= 
<span style="font-style:italic">h</span> (<span style="font-style:italic">x</span>′(<span style="font-style:italic">t</span><sub>0</sub>),<span style="font-style:italic">y</span>′(<span style="font-style:italic">t</span><sub>0</sub>))+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">x</span>′′(<span style="font-style:italic">t</span><sub>0</sub>),<span style="font-style:italic">y</span>′′(<span style="font-style:italic">t</span><sub>0</sub>))
+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span><sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">x</span>′′′(<span style="font-style:italic">t</span><sub><span style="font-style:italic">x</span></sub>),<span style="font-style:italic">y</span>′′′(<span style="font-style:italic">t</span><sub><span style="font-style:italic">y</span></sub>))
</td></tr>
</table><p>
Si les vecteurs vitesse <span style="font-style:italic">v</span>=(<span style="font-style:italic">x</span>′(<span style="font-style:italic">t</span><sub>0</sub>),<span style="font-style:italic">y</span>′(<span style="font-style:italic">t</span><sub>0</sub>))
et accélération <span style="font-style:italic">a</span>=(<span style="font-style:italic">x</span>′′(<span style="font-style:italic">t</span><sub>0</sub>),<span style="font-style:italic">y</span>′′(<span style="font-style:italic">t</span><sub>0</sub>))
ne sont pas colinéaires, 
alors {<span style="font-style:italic">v</span>,<span style="font-style:italic">a</span>} forme 
une base, et dans cette base <span style="font-style:italic">M</span>(<span style="font-style:italic">t</span><sub>0</sub>)<span style="font-style:italic">M</span>(<span style="font-style:italic">t</span><sub>0</sub>+<span style="font-style:italic">h</span>)
a pour coordonnées (<span style="font-style:italic">h</span>,<span style="font-style:italic">h</span><sup>2</sup>/2)+un terme d’ordre 3 en puissances de <span style="font-style:italic">h</span>, l’arc
de courbe est à l’ordre 2 identique à un arc de parabole. 
On parle de <span style="font-weight:bold">point birégulier</span><a id="hevea_default92"></a>.
Si {<span style="font-style:italic">v</span>,<span style="font-style:italic">a</span>} est une base directe,
l’arc est <span style="font-weight:bold">convexe</span><a id="hevea_default93"></a> (la vitesse
“tourne” dans le sens trigonométrique),
sinon il est concave. On peut tester cela en calculant
le déterminant des coordonnées de 
{<span style="font-style:italic">v</span>,<span style="font-style:italic">a</span>} ou le sens
de variations de <span style="font-style:italic">m</span>, la pente de la tangente 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">m</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>′</td></tr>
</table></td><td class="dcell">,    <span style="font-style:italic">m</span>′=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>′<span style="font-style:italic">y</span>′′−<span style="font-style:italic">x</span>′′<span style="font-style:italic">y</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>′<sup>2</sup></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><div class="theorem"><span style="font-weight:bold">Théorème 16</span>  <em>
Si det</em>(<span style="font-style:italic">v</span>,<span style="font-style:italic">a</span>)=<span style="font-style:italic">x</span>′<span style="font-style:italic">y</span>′′−<span style="font-style:italic">x</span>′′<span style="font-style:italic">y</span>′&gt;0<em> [resp </em>&lt;0<em>] 
sur un intervalle du domaine de définition,
la courbe n’a que des points réguliers, 
la direction de la tangente en un point
est donnée par le vecteur vitesse, et la courbe est convexe</em><a id="hevea_default94"></a><em>
[resp. concave].
Si </em><span style="font-style:italic">x</span>′<span style="font-style:italic">y</span>′′−<span style="font-style:italic">x</span>′′<span style="font-style:italic">y</span>′=0<em>, on parle de 
</em><em><span style="font-weight:bold">point d’inflexion</span></em><a id="hevea_default95"></a><em> analytique.
</em></div><p>
<span style="font-weight:bold">Remarque </span>: pour un graphe de fonction, <span style="font-style:italic">x</span>=<span style="font-style:italic">t</span>, on retrouve le
critère usuel <span style="font-style:italic">y</span>′′&gt;0.</p><p><span style="font-weight:bold">Exemple </span>: point d’inflexion en <span style="font-style:italic">t</span>=0 de
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup>+1</td></tr>
</table></td><td class="dcell">,<span style="font-style:italic">t</span>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup>+2</td></tr>
</table></td><td class="dcell">) </td></tr>
</table><p>
La courbe admet deux autres points d’inflexion (<span style="font-style:italic">t</span>=−3.16... et
<span style="font-style:italic">t</span>=1.31...) qu’on peut déterminer avec les commandes Xcas suivantes :<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">purge(x,y);X:=x^3/(x^2+1); Y:=x+1/(x^2+2); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<br><textarea onkeypress="UI.ckenter(event,this,2)" style="width:400px;height:20px;font-size:large">fsolve(X'*Y''-X''*Y',x) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML='&nbsp;'+tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><span></span><br><br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:40px;font-size:large">tabvar([X,Y]);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

Note : on utilise comme paramètre <code>x</code> au lieu de <code>t</code> pour pouvoir 
utiliser la notation <code>'</code> pour dériver (si on utilise <code>t</code>
comme paramètre, il faut utiliser <code>diff(.,t)</code> pour calculer
la dérivée par rapport à <span style="font-style:italic">t</span>). L’instruction <code>fsolve</code>
effectue une résolution numérique, pour tenter une résolution
exacte, utiliser <code>solve</code>, mais on risque alors de manquer
certaines solutions.</p><p>On observe que la convexité est (presque) une propriété géométrique,
en effet si on change de paramétrage
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>′=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> =</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">s</span>′ </td></tr>
</table><p>
on dérive par rapport à <span style="font-style:italic">t</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>′′ = (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">s</span>′)′=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span><sup>2</sup><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">s</span>′<sup>2</sup> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell">
<span style="font-style:italic">s</span>′′ </td></tr>
</table><p>
puis :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>′<span style="font-style:italic">y</span>′′− <span style="font-style:italic">y</span>′ <span style="font-style:italic">x</span>′′ = 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">s</span>′ (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span><sup>2</sup><span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">s</span>′<sup>2</sup> +</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">s</span>′′ ) − 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">s</span>′ (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span><sup>2</sup><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">s</span>′<sup>2</sup> +</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">s</span>′′ ) 
= <span style="font-style:italic">s</span>′<sup>3</sup> (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span><sup>2</sup><span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> − 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span><sup>2</sup><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> )
</td></tr>
</table><p>
on retrouve en facteur <span style="font-style:italic">s</span>′<sup>3</sup> qui est positif si on parcourt la courbe
dans le même sens ou négatif sinon.</p><p>La convexité décrit qualitativement la géométrie
de la courbe (orientée) à l’ordre 1. 
On verra plus loin que le rayon de courbure décrit
quantitativement la géométrie de la courbe à l’ordre
2 (comme la tangente décrit la géométrie de la courbe
à l’ordre 1).</p><p>Dans le cas d’un point singulier (<span style="font-style:italic">v</span>=0), si 
l’accélération <span style="font-style:italic">a</span>≠ 0, alors la
tangente est portée par <span style="font-style:italic">a</span>. L’étude complète
de la nature
d’un point singulier ou de la convexité d’un point régulier
tel que <span style="font-style:italic">a</span> est colinéaire à <span style="font-style:italic">v</span> 
nécessite de faire un
développement de Taylor en <span style="font-style:italic">t</span>=<span style="font-style:italic">t</span><sub>0</sub>
jusqu’au premier ordre <span style="font-style:italic">q</span>, s’il existe, tel que : 
</p><ul class="itemize"><li class="li-itemize">
les dérivées d’ordre 1, .., <span style="font-style:italic">p</span>−1 de (<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) s’annulent
</li><li class="li-itemize">la dérivée d’ordre <span style="font-style:italic">p</span>&gt;0 est non nulle, on la note <span style="font-style:italic">T</span>
</li><li class="li-itemize">les dérivées d’ordre <span style="font-style:italic">p</span>+1,...,<span style="font-style:italic">q</span>−1 sont colinéaires
à la dérivée d’ordre <span style="font-style:italic">p</span> (ce qui inclus le cas où elles
sont nulles)
</li><li class="li-itemize">la dérivée d’ordre <span style="font-style:italic">q</span> est non colinéaire à <span style="font-style:italic">p</span>,
on la note <span style="font-style:italic">A</span>.
</li></ul><p>
Dans la base { <span style="font-style:italic">T</span>,<span style="font-style:italic">A</span>}, les
composantes de <span style="font-style:italic">M</span>(<span style="font-style:italic">t</span><sub>0</sub>)<span style="font-style:italic">M</span>(<span style="font-style:italic">t</span>)
sont alors respectivement équivalentes à <span style="font-style:italic">h</span><sup><span style="font-style:italic">p</span></sup>/<span style="font-style:italic">p</span>! et <span style="font-style:italic">h</span><sup><span style="font-style:italic">q</span></sup>/<span style="font-style:italic">q</span>!
où <span style="font-style:italic">h</span>=<span style="font-style:italic">t</span>−<span style="font-style:italic">t</span><sub>0</sub>.
On en déduit que la tangente à la courbe est portée par
<span style="font-style:italic">T</span>.
</p><ul class="itemize"><li class="li-itemize">
si <span style="font-style:italic">p</span> est pair, on a un rebroussement<a id="hevea_default96"></a> 
de première espèce 
si <span style="font-style:italic">q</span> est impair (cas générique d’un point singulier, <span style="font-style:italic">p</span>=2, <span style="font-style:italic">q</span>=3)
ou de deuxième espèce si <span style="font-style:italic">q</span> est pair. On ne peut pas
régulariser le point singulier par changement de paramétrage.
</li><li class="li-itemize">Si <span style="font-style:italic">p</span> est impair, on peut reparamétriser la courbe
pour rendre le point non singulier (prendre <span style="font-style:italic">t</span>′=(<span style="font-style:italic">t</span>−<span style="font-style:italic">t</span><sub>0</sub>)<sup>1/<span style="font-style:italic">p</span></sup>)
mais au risque de perdre de la régularité,
</li><li class="li-itemize">Si <span style="font-style:italic">p</span> est impair et <span style="font-style:italic">q</span> impair on a un point d’inflexion 
géométrique (changement de sens de convexité).
</li></ul><p>Exemples de points singuliers en <span style="font-style:italic">t</span>=0 avec dans l’ordre rebroussement
de 1ère puis 2ième espèce, méplat et inflexion : 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">t</span><sup>2</sup>,<span style="font-style:italic">t</span><sup>3</sup>),  (<span style="font-style:italic">t</span><sup>2</sup>+<span style="font-style:italic">t</span><sup>4</sup>,<span style="font-style:italic">t</span><sup>4</sup>+<span style="font-style:italic">t</span><sup>5</sup>),  (<span style="font-style:italic">t</span><sup>3</sup>,<span style="font-style:italic">t</span><sup>4</sup>),  (<span style="font-style:italic">t</span><sup>3</sup>,<span style="font-style:italic">t</span><sup>5</sup>) </td></tr>
</table><p><br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plotparam([t^2,t^3],t=-1..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plotparam([t^2+t^4,t^4+t^5],t=-1..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plotparam([t^3,t^4],t=-1..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plotparam([t^3,t^5],t=-1..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

Les deux derniers cas peuvent être reparamétrés (au prix
de la perte de dérivabilité seconde) en posant <span style="font-style:italic">t</span>′=<span style="font-style:italic">t</span><sup>1/3</sup>.</p><p>Pour faire l’étude d’un point singulier avec Xcas, on peut utiliser
la fonction <code>series</code> sur <span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>) et <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>) (ici c’est inutile,
le développement de Taylor est déjà fait).</p><p>Remarque : il peut arriver dans des cas pathologiques
que toutes les dérivées de (<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) s’annulent en
un point sans que la fonction (<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) soit nulle (par exemple si <span style="font-style:italic">x</span>
et <span style="font-style:italic">y</span> contiennent un facteur exp(−1/<span style="font-style:italic">t</span><sup>2</sup>) en <span style="font-style:italic">t</span>=0, on parle
de fonction plate). Il peut aussi
arriver que toutes les dérivées soit colinéaires à la
première dérivée non nulle, si on se déplace sur une droite
ou si la tangeance est plate.</p>
<!--TOC subsection id="sec97" Plan d’étude d’une courbe-->
<h3 id="sec97" class="subsection">10.5  Plan d’étude d’une courbe</h3><!--SEC END --><ol class="enumerate" type=1><li class="li-enumerate">
On détermine et on restreint le domaine de définition
(périodicité, symétries). 
</li><li class="li-enumerate">On étudie les branches infinies (point exclus du domaine,
± ∞) : asymptotes horizontales, verticales, directions
asymptotiques, asymptotes obliques.
</li><li class="li-enumerate">Recherche de <span style="font-style:italic">x</span>′ et <span style="font-style:italic">y</span>′, on étudie l’annulation conjointe
des deux (points singuliers).
</li><li class="li-enumerate">Signe de <span style="font-style:italic">x</span>′ et <span style="font-style:italic">y</span>′, double tableau de variations faisant
apparaitre <span style="font-style:italic">x</span>,<span style="font-style:italic">x</span>′,<span style="font-style:italic">y</span>,<span style="font-style:italic">y</span>′ et mise
en évidence des tangentes horizontales et verticales
</li><li class="li-enumerate">Pour préciser le tracé, on peut chercher la convexité
en étudiant le signe de <span style="font-style:italic">x</span>′<span style="font-style:italic">y</span>′′−<span style="font-style:italic">x</span>′′<span style="font-style:italic">y</span>′.
</li><li class="li-enumerate">Tracé des points remarquables et des asymptotes et
on les relie entre eux en suivant les sens de variations
du tableau de variations.
</li></ol><p>

<a href="http://www-fourier.ujf-grenoble.fr/~parisse/xcasfr.html#+//%20Etude%20analytique%20de%20la%20courbe%20parametrique%20ci-dessous,%20assistee%20par%20le%20calcul%20formel&+xt:=2t+1/%282t+1%29;%20yt:=t^2-1/%282t+1%29&+//%20Branches%20infinies&+limit%28xt,t,-1/2%29;%20limit%28yt,t,-1/2%29;%20a:=limit%28yt/xt,t=-1/2%29&+b:=limit%28yt-a*xt,t=-1/2%29&+//%20Donc%20asymptote%20oblique%20pour%20t=-1/2%20d%27equation%20y=a*x+b=-x-3/4%3Cbr%3EOn%20peut%20faire%20la%20meme%20etude%20en%20-inf%20et%20+inf&+limit%28xt,t,-inf%29;%20limit%28yt,t,-inf%29;%20a:=limit%28yt/xt,t,-inf%29&+//%20Branche%20parabolique%20de%20direction%20asymptotique%20Oy%20en%20t=-inf,%20meme%20chose%20en%20+inf%3Cbr%3EOn%20passe%20aux%20point%20singuliers&+x1:=factor%28diff%28xt,t%29%29;%20y1:=factor%28diff%28yt,t%29%29&+//%20Donc%20un%20seul%20point%20singulier%20en%20t=-1,%20on%20cherche%20la%20tangente%20en%20ce%20point%20%28acceleration%29%3Cbr%3E%20et%20le%20type%20de%20point%20%28rebroussement%201ere%20espece%29&+x2:=diff%28xt,t,2%29;%20y2:=diff%28yt,t,2%29;%20x3:=diff%28xt,t,3%29;%20y3:=diff%28yt,t,3%29&+[x2,y2]%28t=-1%29;%20&+//%20Acceleration%20non%20nulle%20donc%20vecteur%20directeur%20de%20la%20tangente%20au%20point%20singulier.%3Cbr%3EOn%20peut%20aussi%20faire%20le%20DL%20en%20t=-1%20a%20un%20ordre%20suffisant&+series%28xt,t=-1,3%29;%20series%28yt,t=-1,3%29&+subst%28x2*y3-x3*y2,t=-1%29;%20//%20Si%20non%20nul,%20on%20a%20un%20rebroussement%20de%201ere%20espece&+//%20Etude%20de%20la%20convexite&+factor%28x1*y2-x2*y1%29&+//%20Point%20d%27inflexion%20analytique%20pout%20t=1/2,%20coordonnes%20du%20point%20et%20vecteur%20directeur%20de%20la%20tangente&+[xt,yt]%28t=1/2%29;%20[x1,y1]%28t=1/2%29&+//%20Tableau%20de%20variations%20commun%20de%20xt%20et%20yt,%20calcule%20par%20Xcas&+tabvar%28[xt,yt]%29&+&" target="_blank">Exemple</a>
</p>
<!--TOC subsection id="sec98" Courbes en polaires-->
<h3 id="sec98" class="subsection">10.6  Courbes en polaires</h3><!--SEC END --><p><a id="hevea_default97"></a>
Une courbe en polaire est essentiellement
donnée par la distance au centre <span style="font-style:italic">O</span> d’un
point <span style="font-style:italic">M</span> de la courbe en fonction de l’angle θ 
entre la direction <span style="font-style:italic">Ox</span> et le vecteur <span style="font-style:italic">OM</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">OM</span> = <span style="font-style:italic">r</span>(θ)</td></tr>
</table><p> 
On s’autorise toutefois des valeurs négatives pour <span style="font-style:italic">r</span>,
si c’est le cas, on prend alors le symétrique par rapport
à l’origine du point situé à distance −<span style="font-style:italic">r</span> et d’angle θ.</p><p>Représentation graphique : avec Xcas, on utilise
la commande <code>plotpolar</code>, sur calculatrices
graphiques, sélectionner le mode de tracé en polaire (touche Mode
sur TI89/92/V200) ou
l’application Polaire ou Géométrie sur les HP Prime.
Par exemple 

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:40px;font-size:large">circle(0,1,color=red); plotpolar(1,x=0..2*pi)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plotpolar(cos(2x),x=0..2*pi,tstep=0.01)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:40px;font-size:large">circle(0,1,color=red); plotpolar(1/(2+cos(x)),x=0..2*pi);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:60px;font-size:large">purge(x,y);plotpolar(1/(1+2*cos(x)),x=0..2*pi); rotation(0,2*pi/3,line(y=-sqrt(3)/3),color=red)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plotpolar(x,x=-10..10)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>Remarque : une courbe en polaires est toujours parcourue dans le sens
trigonométrique.</p><p>C’est un cas particulier de courbe en paramétriques puisque
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)=(<span style="font-style:italic">r</span>(θ) cos(θ), <span style="font-style:italic">r</span>(θ) sin(θ))</td></tr>
</table><p>
mais on préfère souvent faire l’étude directement sur la
fonction <span style="font-style:italic">r</span>. Le plan d’étude est calqué sur celui
d’une courbe en paramétrique, mais on n’a qu’une seule fonction
<span style="font-style:italic">r</span> à étudier.
</p><ol class="enumerate" type=1><li class="li-enumerate">
domaine de définition de <span style="font-style:italic">r</span>, recherche
de périodicités et symétries (θ → −θ
ou ajout d’une demi ou d’un quart de période).
Si la période n’est pas un multiple de 2π, cela correspond
à obtenir un arc de la courbe par rotation à partir d’un autre arc
de la courbe.
</li><li class="li-enumerate">branches infinies pour θ<sub>0</sub> (non infini)
où <span style="font-style:italic">r</span> n’est pas défini. La branche a pour direction
asymptotique la droite faisant un angle θ<sub>0</sub> avec
l’axe des <span style="font-style:italic">x</span>. On calcule alors la limite si elle existe de 
<span style="font-style:italic">r</span> sin(θ−θ<sub>0</sub>)), c’est l’ordonnée dans
le repère obtenu par rotation d’angle θ<sub>0</sub>, si la limite
est finie et vaut <span style="font-style:italic">l</span>
on a une asymptote (d’équation <span style="font-style:italic">Y</span>=<span style="font-style:italic">l</span> dans le repère tourné).<br>
Exemple <span style="font-style:italic">r</span>=1/(1+2cos(θ)). <span style="font-style:italic">r</span> n’est pas défini pour
cos(θ)=−1/2, donc θ=± 2π/3. Pour θ<sub>0</sub>=2π/3,
on calcule lim<sub>θ → 2π/3</sub><span style="font-style:italic">r</span>sin(θ−2π/3)<br>
<br><textarea onkeypress="UI.ckenter(event,this,2)" style="width:400px;height:40px;font-size:large">limit(1/(1+2cos(x))*sin(x-2pi/3),x=2pi/3) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML='&nbsp;'+tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><span></span><br><br>
La tangente est donc l’image par la rotation de centre <span style="font-style:italic">O</span> et d’angle
2π/3 de la droite <span style="font-style:italic">Y</span>=−√<span style="text-decoration:overline">3</span>/3
</li><li class="li-enumerate">si la fonction n’est pas périodique, il y a lieu
d’étudier l’existence de limites de <span style="font-style:italic">r</span> en ± ∞, si la limite
est nulle on s’approche en spiralant de l’origine, si
elle est finie, il y a un cercle asymptote, si elle est
infinie une spirale.
</li><li class="li-enumerate">comme <span style="font-style:italic">OM</span>=<span style="font-style:italic">r</span> <span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub>, 
<span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub>=(cos(θ),sin(θ)), 
la vitesse (si le temps est θ) est donnée par 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">v</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td><td class="dcell">= <span style="font-style:italic">r</span>′ <span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub> + <span style="font-style:italic">r</span> <span style="font-style:italic">e</span><sub>θ</sub></td></tr>
</table>
où { <span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub>,<span style="font-style:italic">e</span><sub>θ</sub>} est une base orthonormée directe.<br>
Donc si <span style="font-style:italic">r</span>≠ 0 ou <span style="font-style:italic">r</span>′ ≠ 0, le point est régulier et
l’angle <span style="font-style:italic">V</span> de la tangente avec <span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub> vérifie 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">tan(<span style="font-style:italic">V</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span>′</td></tr>
</table></td><td class="dcell"> ∈ ℝ ⋃ { ± ∞ } </td></tr>
</table>
(si <span style="font-style:italic">r</span> ≠ 0 et <span style="font-style:italic">r</span>′=0, la tangente est portée par <span style="font-style:italic">e</span><sub>θ</sub>).
Si <span style="font-style:italic">r</span>=0, la tangente est portée par <span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub>.<sup><a id="text10" href="#note10">10</a></sup>
</li><li class="li-enumerate">On ne peut avoir un point singulier que pour <span style="font-style:italic">r</span>=0. On ne fait
pas leur étude comme en paramétriques, en effet la tangente est
toujours portée par <span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub>, si <span style="font-style:italic">r</span> change de signe la courbe
a la même allure que pour un point régulier, si <span style="font-style:italic">r</span> ne change pas
de signe on a un rebroussement de première espèce (puisqu’on
traverse la tangente lorsque θ augmente)<br>
Exemple : 
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:80px;font-size:large">plotpolar(sin(x)^2*cos(x),x=-pi/4..pi/4,tstep=pi/100);plotpolar(sin(x)^2*cos(x),x=pi/4..3*pi/4,tstep=pi/100,color=red)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Convexité : pour avoir un point d’inflexion, il faut que 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span></td></tr>
</table></td><td class="dcell"> + </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">′′=0
⇔
<span style="font-style:italic">r</span><sup>2</sup>+2<span style="font-style:italic">r</span>′<sup>2</sup>−<span style="font-style:italic">rr</span>′′=0
</td></tr>
</table>
On peut le montrer de différentes manières :
<ul class="itemize"><li class="li-itemize">
En calculant le déterminant de {vitesse,accélération }
par rapport à θ dans le repère <span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub>,<span style="font-style:italic">e</span><sub>θ</sub>, on a
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">v</span>=<span style="font-style:italic">r</span>′<span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub>+<span style="font-style:italic">re</span><sub>θ</sub>   <span style="font-style:italic">a</span>=<span style="font-style:italic">r</span>′′<span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub>+2<span style="font-style:italic">r</span>′<span style="font-style:italic">e</span><sub>θ</sub>−<span style="font-style:italic">re</span><sub><span style="font-style:italic">r</span></sub></td></tr>
</table>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⇒ det(<span style="font-style:italic">v</span>,<span style="font-style:italic">a</span>)=</td><td class="dcell">⎪<br>
⎪<br>
⎪</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">r</span>′</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">r</span>′′−<span style="font-style:italic">r</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">r</span></td><td style="text-align:center;white-space:nowrap" >2<span style="font-style:italic">r</span>′</td></tr>
</table></td><td class="dcell">⎪<br>
⎪<br>
⎪</td><td class="dcell">=2<span style="font-style:italic">r</span>′<sup>2</sup>−<span style="font-style:italic">r</span> <span style="font-style:italic">r</span>′′+<span style="font-style:italic">r</span><sup>2</sup></td></tr>
</table> 
</li><li class="li-itemize">En calculant la dérivée de l’angle fait avec l’axe Ox
θ+arctan(<span style="font-style:italic">r</span>/<span style="font-style:italic">r</span>′) 
</li><li class="li-itemize">avec Xcas en se ramenant en paramétriques
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:400px;height:60px;font-size:large">
X:=r(x)*cos(x); Y:=r(x)*sin(x); simplify(X'*Y''-Y'*X'');
simplify(1/r(x)+(1/r(x))''); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
où on a noté <span style="font-style:italic">x</span> l’angle θ pour pouvoir dériver avec <code>'</code>
et <span style="font-style:italic">X</span> et <span style="font-style:italic">Y</span> les deux coordonnées.
</li></ul>
</li><li class="li-enumerate">de même on calcule la courbure définie en section <a href="#sec%3Acourbure">11.2</a>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">κ = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span><sup>2</sup>+2<span style="font-style:italic">r</span>′<sup>2</sup>−<span style="font-style:italic">rr</span>′′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">r</span><sup>2</sup>+<span style="font-style:italic">r</span>′<sup>2</sup></td></tr>
</table></td><td class="dcell"><sup>3</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table>
</li></ol>
<!--TOC subsection id="sec99" Coniques-->
<h3 id="sec99" class="subsection">10.7  Coniques</h3><!--SEC END --><p><a id="hevea_default98"></a>
Les coniques sont des courbes implicites dont l’équation
cartésienne est du second degré 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">ax</span><sup>2</sup>+<span style="font-style:italic">cy</span><sup>2</sup>+<span style="font-style:italic">bxy</span>+<span style="font-style:italic">dx</span>+<span style="font-style:italic">ey</span>+<span style="font-style:italic">f</span>=0</td></tr>
</table><p>
Exemples:<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">purge(x,y);plotimplicit(x^2+y^2+x*y=4)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plotimplicit(x^2+y^2+3*x*y=4)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>On va voir qu’elles sont de trois types : ellipses, hyperbole,
parabole<sup><a id="text11" href="#note11">11</a></sup> 
et on va les paramétriser, à partir de leur équation
cartésienne ou à partir de leurs éléments géométriques
(le calcul des éléments géométrique à partir de l’équation
cartésienne fait intervenir l’étude des formes quadratiques, il ne
sera pas abordé dans ce cours).
Les coniques sont des courbes importantes en géométrie, 
ce qui a un intérêt en optique 
(parabole), mais aussi en cinématique (première loi de Kepler :
l’orbite décrite par une planète est une ellipse dont
le Soleil occupe un foyer).</p>
<!--TOC subsubsection id="sec100" Ellipse-->
<h4 id="sec100" class="subsubsection">10.7.1  Ellipse</h4><!--SEC END --><p><a id="hevea_default99"></a>
</p><div class="theorem"><span style="font-weight:bold">Définition 17</span>  <em>
L’ellipse </em><span style="font-style:italic">E</span><em> de foyers </em><span style="font-style:italic">F</span><sub>1</sub><em> et </em><span style="font-style:italic">F</span><sub>2</sub><em> de demi-grand axe
</em><span style="font-style:italic">a</span><em> est l’ensemble des points </em><span style="font-style:italic">M</span><em> du plan tels que 
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">MF</span><sub>1</sub>+<span style="font-style:italic">MF</span><sub>2</sub>=2<span style="font-style:italic">a</span></td></tr>
</table><em>
</em></div><p>
Exemple : ouvrir un niveau de géométrie 2d dans Xcas,
choisir le mode ellipse cliquer 2 points (ce sont les foyers)
puis un 3ème point (point de l’ellipse), passer en mode
pointeur et faire bouger l’un des points, observer la forme
de l’ellipse qui en résulte. Ou dans une ligne de commande
normale taper la commande <code>ellipse()</code> avec
en arguments les 2 points foyers et un point de l’ellipse
ou l’équation cartésienne de l’ellipse, par exemple
<code>ellipse(-1,1,3+i)</code> trace l’ellipse de foyers (−1,0), (1,0)
et passant par le point (3,1).</p><p>On note 2<span style="font-style:italic">c</span>=<span style="font-style:italic">F</span><sub>1</sub><span style="font-style:italic">F</span><sub>2</sub> la distance entre les deux foyers, qui doit être
plus petite que 2<span style="font-style:italic">a</span> pour que l’ellipse soit non vide.
L’excentricité de l’ellipse est définie par <span style="font-style:italic">e</span>=<span style="font-style:italic">c</span>/<span style="font-style:italic">a</span> &lt; 1. Si <span style="font-style:italic">e</span>=0,
on obtient un cercle de centre <span style="font-style:italic">F</span><sub>1</sub>=<span style="font-style:italic">F</span><sub>2</sub> et de rayon <span style="font-style:italic">a</span>. Si <span style="font-style:italic">e</span>≠ 0,
on va voir qu’il s’agit d’un cercle contracté
selon l’axe perpendiculaire à <span style="font-style:italic">F</span><sub>1</sub><span style="font-style:italic">F</span><sub>2</sub> dans un rapport de 
√<span style="text-decoration:overline">1−</span><span style="text-decoration:overline"><span style="font-style:italic">e</span></span><sup><span style="text-decoration:overline">2</span></sup>. On va également calculer l’équation en
coordonnées polaires de <span style="font-style:italic">E</span> (c’est sous cette forme
que l’on montre que la Terre décrit une ellipse 
dont le Soleil occupe un foyer).</p><p>Soit <span style="font-style:italic">O</span> le milieu de <span style="font-style:italic">F</span><sub>1</sub> et <span style="font-style:italic">F</span><sub>2</sub>, on se place dans le repère 
orthonormé
dont le premier axe <span style="font-style:italic">Ox</span> contient <span style="font-style:italic">F</span><sub>1</sub> et <span style="font-style:italic">F</span><sub>2</sub> donc les
coordonnées de <span style="font-style:italic">F</span><sub>1</sub> sont (<span style="font-style:italic">c</span>,0) et celles de <span style="font-style:italic">F</span><sub>2</sub> sont (−<span style="font-style:italic">c</span>,0). 
Soit <span style="font-style:italic">M</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) un
point de l’ellipse, on a d’une part :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">MF</span><sub>1</sub><sup>2</sup> − <span style="font-style:italic">MF</span><sub>2</sub><sup>2</sup> = (<span style="font-style:italic">x</span>−<span style="font-style:italic">c</span>)<sup>2</sup>−(<span style="font-style:italic">x</span>+<span style="font-style:italic">c</span>)<sup>2</sup> = −4<span style="font-style:italic">cx</span> </td></tr>
</table><p>
et d’autre part :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">MF</span><sub>1</sub><sup>2</sup> − <span style="font-style:italic">MF</span><sub>2</sub><sup>2</sup> = (<span style="font-style:italic">MF</span><sub>1</sub> + <span style="font-style:italic">MF</span><sub>2</sub>)(<span style="font-style:italic">MF</span><sub>1</sub> − <span style="font-style:italic">MF</span><sub>2</sub> ) = 2<span style="font-style:italic">a</span> (<span style="font-style:italic">MF</span><sub>1</sub> − <span style="font-style:italic">MF</span><sub>2</sub> )</td></tr>
</table><p>
donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">MF</span><sub>1</sub> − <span style="font-style:italic">MF</span><sub>2</sub> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−2<span style="font-style:italic">cx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
en additionnant avec <span style="font-style:italic">MF</span><sub>1</sub>+<span style="font-style:italic">MF</span><sub>2</sub>=2<span style="font-style:italic">a</span> et en appliquant <span style="font-style:italic">c</span>=<span style="font-style:italic">ea</span>, on en déduit :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:MF1"></a>
<span style="font-style:italic">MF</span><sub>1</sub> = <span style="font-style:italic">a</span> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">cx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> = <span style="font-style:italic">a</span>−<span style="font-style:italic">ex</span> 
    (15)</td></tr>
</table><p>
En prenant le carré, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">x</span>−<span style="font-style:italic">ea</span>)<sup>2</sup> + <span style="font-style:italic">y</span><sup>2</sup> = (<span style="font-style:italic">a</span>−<span style="font-style:italic">ex</span>)<sup>2</sup></td></tr>
</table><p>
d’où :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span><sup>2</sup> + <span style="font-style:italic">x</span><sup>2</sup> (1−<span style="font-style:italic">e</span><sup>2</sup>) = <span style="font-style:italic">a</span><sup>2</sup>(1−<span style="font-style:italic">e</span><sup>2</sup>) </td></tr>
</table><p>
finalement :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span><sup>2</sup> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">e</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> = <span style="font-style:italic">a</span><sup>2</sup> </td></tr>
</table><p>
qui est bien la contraction selon <span style="font-style:italic">Oy</span> de rapport √<span style="text-decoration:overline">1−</span><span style="text-decoration:overline"><span style="font-style:italic">e</span></span><sup><span style="text-decoration:overline">2</span></sup> du
cercle de centre <span style="font-style:italic">O</span> et de rayon <span style="font-style:italic">a</span> (appelé grand cercle de
l’ellipse).</p><p>En coordonnées paramétriques, on peut utiliser le paramétrage suivant :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)=(<span style="font-style:italic">a</span>cos(<span style="font-style:italic">t</span>),<span style="font-style:italic">b</span>sin(<span style="font-style:italic">t</span>))</td></tr>
</table><p>En coordonnées polaires, on note ρ la distance de <span style="font-style:italic">F</span><sub>1</sub> à
<span style="font-style:italic">M</span>, et θ l’angle entre l’axe <span style="font-style:italic">Ox</span> et <span style="font-style:italic">F</span><sub>1</sub><span style="font-style:italic">M</span>. L’abscisse de <span style="font-style:italic">M</span>
est donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>= <span style="font-style:italic">ea</span> + ρ cos(θ)</td></tr>
</table><p>
que l’on combine avec (<a href="#eq%3AMF1">15</a>) pour obtenir :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ρ = <span style="font-style:italic">a</span>−<span style="font-style:italic">ex</span> =<span style="font-style:italic">a</span>(1−<span style="font-style:italic">e</span><sup>2</sup>) − <span style="font-style:italic">e</span> ρ cos(θ) </td></tr>
</table><p>
donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ρ = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>(1−<span style="font-style:italic">e</span><sup>2</sup>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">e</span>cos(θ)</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p><span style="font-weight:bold">Remarques</span> :
</p><ul class="itemize"><li class="li-itemize">
La première loi de Képler dit que l’orbite d’une planète
autour du Soleil est une ellipse dont le Soleil occupe un des foyers.
La troisième loi de Képler donne la relation suivante entre le
demi-grand axe <span style="font-style:italic">a</span>, la période de révolution <span style="font-style:italic">T</span> et µ
le produit de la masse du Soleil<sup><a id="text12" href="#note12">12</a></sup> par la constante de gravitation :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">µ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4π<sup>2</sup></td></tr>
</table></td></tr>
</table>
</li><li class="li-itemize">Attention, <span style="font-style:italic">t</span>≠ θ. Et dans le cas de l’orbite
de la Terre autour du Soleil, aucun de ces deux paramétrages n’est
le temps τ. Le paramétrage par le temps se déduit de la loi
des aires
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">r</span><sup>2</sup> <span style="font-style:italic">d</span>θ =  <span style="font-style:italic">L</span> <span style="font-style:italic">d</span>τ ,   
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">L</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">µ</td></tr>
</table></td><td class="dcell">= <span style="font-style:italic">a</span>(1−<span style="font-style:italic">e</span><sup>2</sup>) </td></tr>
</table>
Il nécessite de résoudre
une équation , cf. l’équation du temps dans le cours :<br>
<code>www-fourier.ujf-grenoble.fr/~parisse/climat/orbite.html</code><br>
L’excentricité de la Terre est faible, <span style="font-style:italic">e</span>=0.0167 en
ce moment, elle est responsable d’une petite différence 
de durée des saisons, elle varie très lentement au cours des siècles sous
l’action des autres planètes du système solaire, cette lente variation
est une des raisons des glaciations du quartenaire.
</li><li class="li-itemize">On peut aussi définir géométriquement l’ellipse
par un foyer <span style="font-style:italic">F</span> et une directrice <span style="font-style:italic">D</span>, c’est l’ensemble des <span style="font-style:italic">M</span> tels
que <span style="font-style:italic">d</span>(<span style="font-style:italic">M</span>,<span style="font-style:italic">F</span>)=<span style="font-style:italic">ed</span>(<span style="font-style:italic">M</span>,<span style="font-style:italic">D</span>). Dans le repère d’origine <span style="font-style:italic">O</span>, <span style="font-style:italic">D</span>
a pour équation <span style="font-style:italic">x</span>=<span style="font-style:italic">a</span>/<span style="font-style:italic">e</span> (dans le repère d’origine <span style="font-style:italic">F</span>, c’est
<span style="font-style:italic">x</span>=<span style="font-style:italic">a</span>/<span style="font-style:italic">e</span>−<span style="font-style:italic">e</span>=<span style="font-style:italic">a</span>(1−<span style="font-style:italic">e</span><sup>2</sup>)/<span style="font-style:italic">e</span>). En effet <span style="font-style:italic">MF</span>=<span style="font-style:italic">a</span>−<span style="font-style:italic">ex</span>=<span style="font-style:italic">e</span>(<span style="font-style:italic">a</span>/<span style="font-style:italic">e</span>−<span style="font-style:italic">x</span>).
</li></ul><p>
Exemple : faites varier la valeur de l’excentricité ci-dessous, que
voit-on pour E=0.0, E un peu inférieur à 1 (par exemple 0.8) et un peu supérieur
à 1 (par exemple 1.3)<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:60px;font-size:large">E:=0.5; gl_x=-5..5;gl_y=-3..3;plotpolar(1/(1+E*cos(t)),t=0..2*pi,tstep=pi/100)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p>
<!--TOC subsubsection id="sec101" Parabole-->
<h4 id="sec101" class="subsubsection">10.7.2  Parabole</h4><!--SEC END --><p><a id="hevea_default100"></a>
Si <span style="font-style:italic">F</span> est un point et <span style="font-style:italic">D</span> une droite ne passant pas par <span style="font-style:italic">F</span>, la
parabole de foyer <span style="font-style:italic">F</span> et directrice <span style="font-style:italic">D</span> est l’ensemble des points
équidistants de <span style="font-style:italic">F</span> et <span style="font-style:italic">D</span>.
En choisissant un repère tel que la droite <span style="font-style:italic">D</span> ait pour équation
<span style="font-style:italic">y</span>=0 et en prenant <span style="font-style:italic">F</span>(0,1), <span style="font-style:italic">M</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) appartient à la parabole
si 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">y</span>|=<span style="font-style:italic">d</span>(<span style="font-style:italic">M</span>,<span style="font-style:italic">D</span>)=<span style="font-style:italic">d</span>(<span style="font-style:italic">M</span>,<span style="font-style:italic">F</span>)=</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">y</span>−1)<sup>2</sup>+<span style="font-style:italic">x</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
donc en passant au carré :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span><sup>2</sup>=(<span style="font-style:italic">y</span>−1)<sup>2</sup>+<span style="font-style:italic">x</span><sup>2</sup> ⇒ <span style="font-style:italic">y</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2</sup>+1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
</table><p>
La parabole est donc (ici) un graphe de fonction, donc
un cas particulier de courbe paramétrique.
On peut trouver son équation en polaire,
en prenant <span style="font-style:italic">F</span> comme origine et la directrice
verticale (donc l’équation de la droite
devient par exemple <span style="font-style:italic">y</span>=−1) sous la forme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ρ=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+sin(θ)</td></tr>
</table></td></tr>
</table><p>
cf. l’exercice sur les coniques données par foyer et directrice,
qui traite aussi le cas des hyperboles. On peut aussi faire à
titre d’exercice l’étude de la courbe en polaire :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ρ = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">e</span>cos(θ)</td></tr>
</table></td></tr>
</table><p>
lorsque <span style="font-style:italic">e</span>=1 et <span style="font-style:italic">e</span>&gt;1.</p><p>Un intérêt majeur de la parabole en optique est que
les rayons incidents perpendiculaires à la directrice
se réfléchissent en passant par le
foyer (on peut même montrer que cela caractérise
une parabole). Illustration-démonstration
avec Xcas dans un niveau de géométrie taper les commandes
</p><pre class="verbatim">P:=plotfunc(x^2/2+1/2,x=-5..5);
supposons(a=[-1.4,-5,5,0.1]);
D:=line(x=a,color=red);
M:=inter_unique(P,D);
T:=tangent(P,M);
R:=symetrie(T,D,color=red);
trace(R);
</pre><p>puis faire varier <span style="font-style:italic">a</span> en cliquant sur les flèches. Pour tester en
ligne, commencez par initialiser la trace en exécutant

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">purge(x,y);L:=[]
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

puis faites varier <span style="font-style:italic">a</span> en cliquant sur le bouton <code>+</code> ou <code>-</code> : 


<div><form onsubmit="setTimeout(function(){UI.eval_form(form);});return false;">
<input type="text" name="name" size="1" value=
"a">

=<input type="number" name="valname" onchange="UI.eval_form(form);" value=
"0.6">

<input type="button" value="-" onclick="valname.value -= stepname.value;UI.eval_form(form);">
<input type="button" value="+" onclick="valname.value -= -stepname.value;UI.eval_form(form);">
<input type="number" name="stepname" value=
"0.1">

<input type="range" name="rangename"
onclick="valname.value=value;UI.eval_form(form);" value=
"0.6" min="-5" max="5" step="0.1">

<textarea name="prog" onchange="UI.eval_form(form)" style="width:400px;height:120px;vertical-align:bottom;font-size:large">
gl_x=-5..5;gl_y=0..6;P:=plotfunc(x^2/2+1/2,x=-5..5);D:=line(x=evalf(a),color=red);M:=single_inter(P,D);T:=tangent(P,M);R:=symetrie(T,D,color=red);L:=append(L,R)

</textarea>
</form>
<span>Not evaled</span></div>

Noter la valeur<br>
<code>inter_unique(R,line(x=0))</code><br>
elle est indépendante de <span style="font-style:italic">a</span> et est le foyer. On peut
montrer qu’une courbe ayant cette propriété est
une parabole.</p>
<!--TOC subsubsection id="sec102" Hyperbole-->
<h4 id="sec102" class="subsubsection">10.7.3  Hyperbole</h4><!--SEC END --><p>
Une hyperbole de foyers <span style="font-style:italic">F</span> et <span style="font-style:italic">F</span>′ est définie comme l’ensemble
des points <span style="font-style:italic">M</span> tels que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">MF</span>−<span style="font-style:italic">MF</span>′|=2<span style="font-style:italic">a</span></td></tr>
</table><p>
où <span style="font-style:italic">a</span> est une constante telle que 2<span style="font-style:italic">a</span>&gt;2<span style="font-style:italic">c</span>=<span style="font-style:italic">FF</span>′, avec une excentricité
<span style="font-style:italic">e</span>=<span style="font-style:italic">c</span>/<span style="font-style:italic">a</span>&gt;1.</p><p>En physique, les hyperboles interviennent dans les trajectoires non
périodiques en mécanique céleste, mais aussi comme courbes 
de déphasage constant entre deux sources situées aux deux foyers
(les figures d’interférence font apparaitre des hyperboles).</p><p>On peut faire un calcul analogue à celui de l’ellipse, 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">MF</span>−<span style="font-style:italic">MF</span>′=± 2<span style="font-style:italic">a</span>,  <span style="font-style:italic">MF</span>+<span style="font-style:italic">MF</span>′=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">MF</span><sup>2</sup>−<span style="font-style:italic">MF</span>′<sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">MF</span>−<span style="font-style:italic">MF</span>′</td></tr>
</table></td><td class="dcell">=−± 2<span style="font-style:italic">ex</span></td></tr>
</table><p>
on en déduit que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">MF</span>=± (<span style="font-style:italic">a</span>−<span style="font-style:italic">ex</span>)</td></tr>
</table><p>
l’équation cartésienne de l’hyperbole dans le repère centré au milieu
des foyers, d’axe <span style="font-style:italic">Ox</span> l’axe des foyers est donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sup>2</sup></td></tr>
</table></td><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sup>2</sup>(<span style="font-style:italic">e</span><sup>2</sup>−1)</td></tr>
</table></td><td class="dcell">=1</td></tr>
</table><p>
On peut paramétrer les deux branches de l’hyperbole par
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>)=± <span style="font-style:italic">a</span>cosh(<span style="font-style:italic">t</span>), <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">a</span></td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">e</span><sup>2</sup>−1</td></tr>
</table></td><td class="dcell"> sinh(<span style="font-style:italic">t</span>)</td></tr>
</table><p>
et en polaires
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ρ=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>(1−<span style="font-style:italic">e</span><sup>2</sup>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">e</span>cos(θ)</td></tr>
</table></td></tr>
</table><p>Exercice : faire l’étude de la courbe paramétrée et montrer que
l’hyperbole admet deux asymptotes d’équation <span style="font-style:italic">y</span> = ± <span style="font-style:italic">b</span>/<span style="font-style:italic">a</span> <span style="font-style:italic">x</span>.</p>
<!--TOC subsubsection id="sec103" Paramétrisation rationnelle-->
<h4 id="sec103" class="subsubsection">10.7.4  Paramétrisation rationnelle</h4><!--SEC END --><p>
Si on connait un point d’une conique, on peut effectuer
un changement d’origine en ce point, l’équation cartésienne
devient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)=<span style="font-style:italic">ax</span><sup>2</sup>+<span style="font-style:italic">bxy</span>+<span style="font-style:italic">cy</span><sup>2</sup>+<span style="font-style:italic">dx</span>+<span style="font-style:italic">ey</span>=0</td></tr>
</table><p>
On suppose que (<span style="font-style:italic">d</span>,<span style="font-style:italic">e</span>)≠(0,0)<sup><a id="text13" href="#note13">13</a></sup>.
On cherche alors l’intersection de la conique avec la droite <span style="font-style:italic">y</span>=<span style="font-style:italic">tx</span>
(de pente <span style="font-style:italic">t</span>), on va voir que la droite coupe en général la
conique en deux points, l’origine et un autre point dont on
calcule les coordonnées en fonction de <span style="font-style:italic">t</span><sup><a id="text14" href="#note14">14</a></sup>.
Graphiquement, par exemple<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">L:=NULL:;
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>


<div><form onsubmit="setTimeout(function(){UI.eval_form(form);});return false;">
<input type="text" name="name" size="1" value=
"T">

=<input type="number" name="valname" onchange="UI.eval_form(form);" value=
"1">

<input type="button" value="-" onclick="valname.value -= stepname.value;UI.eval_form(form);">
<input type="button" value="+" onclick="valname.value -= -stepname.value;UI.eval_form(form);">
<input type="number" name="stepname" value=
"0.1">

<input type="range" name="rangename"
onclick="valname.value=value;UI.eval_form(form);" value=
"1" min="-10" max="10" step="0.1">

<textarea name="prog" onchange="UI.eval_form(form)" style="width:400px;height:120px;vertical-align:bottom;font-size:large">
purge(x,y);
eq:=x^2+y^2+x*y-4:; gl_x=-3..3;gl_y=-3..3;G:=implicitplot(eq);D:=line(y=evalf(T)*x); L:=L,inter(G,D,color=red)

</textarea>
</form>
<span>Not evaled</span></div>

puis faire varier la valeur de <span style="font-style:italic">t</span> ou d’un des coefficients de
l’équation.
En effet on obtient une équation du second degré en <span style="font-style:italic">x</span>,
qui se factorise par <span style="font-style:italic">x</span>, l’autre solution donne alors <span style="font-style:italic">x</span> comme
fraction rationnelle en <span style="font-style:italic">t</span>, puis <span style="font-style:italic">y</span>=<span style="font-style:italic">tx</span>.
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">ax</span>+<span style="font-style:italic">btx</span>+<span style="font-style:italic">ct</span><sup>2</sup><span style="font-style:italic">x</span>+<span style="font-style:italic">d</span>+<span style="font-style:italic">et</span>)<span style="font-style:italic">x</span>=0 ⇒ <span style="font-style:italic">x</span>=0, <span style="font-style:italic">x</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−<span style="font-style:italic">d</span>−<span style="font-style:italic">et</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ct</span><sup>2</sup>+<span style="font-style:italic">bt</span>+<span style="font-style:italic">a</span></td></tr>
</table></td></tr>
</table><p>
Comme dans le premier exemple sur le cercle trigonométrique,
on n’obtient pas toujours toute la conique (s’il existe un autre
point d’abscisse <span style="font-style:italic">x</span>=0).</p><p>Si on cherche les points où le dénominateur en <span style="font-style:italic">t</span> s’annule, on doit
calculer (pour <span style="font-style:italic">c</span>≠ 0 et en supposant que la fraction
−<span style="font-style:italic">d</span>−<span style="font-style:italic">et</span>/<span style="font-style:italic">ct</span><sup>2</sup>+<span style="font-style:italic">bt</span>+<span style="font-style:italic">a</span> est irréductible<sup><a id="text15" href="#note15">15</a></sup>)
le discriminant<sup><a id="text16" href="#note16">16</a></sup> 
de l’équation du second degré
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">Δ= <span style="font-style:italic">b</span><sup>2</sup>−4<span style="font-style:italic">ac</span></td></tr>
</table><p>
Il y a trois cas possibles: 
</p><ul class="itemize"><li class="li-itemize">
si <span style="font-style:italic">b</span><sup>2</sup>&lt;4<span style="font-style:italic">ac</span>, il n’y a pas de racine, le
paramétrage est défini pour tout <span style="font-style:italic">t</span> et les limites en ±
∞ de <span style="font-style:italic">x</span> sont nulles (car <span style="font-style:italic">c</span> ≠ 0 puisque 4<span style="font-style:italic">ac</span>&gt;<span style="font-style:italic">b</span><sup>2</sup>),
la conique est bornée, c’est une ellipse.
</li><li class="li-itemize">si <span style="font-style:italic">b</span><sup>2</sup>=4<span style="font-style:italic">ac</span>, il y a une racine double, qui engendre
une étude de branche infinie en <span style="font-style:italic">t</span>=−<span style="font-style:italic">b</span>/(2<span style="font-style:italic">c</span>), on
obtient une parabole (deux branches selon que <span style="font-style:italic">t</span> tend
vers −<span style="font-style:italic">b</span>/(2<span style="font-style:italic">c</span>) par la droite ou la gauche). Il n’y a pas
d’asymptote, on a bien <span style="font-style:italic">y</span>/<span style="font-style:italic">x</span>=<span style="font-style:italic">t</span> qui tend vers <span style="font-style:italic">t</span><sub>0</sub>=−<span style="font-style:italic">b</span>/(2<span style="font-style:italic">c</span>),
mais <span style="font-style:italic">y</span>−<span style="font-style:italic">t</span><sub>0</sub><span style="font-style:italic">x</span> ne converge pas (le numérateur a une racine simple
qui ne compense pas la racine double au dénominateur)
</li><li class="li-itemize">si <span style="font-style:italic">b</span><sup>2</sup>&gt;4<span style="font-style:italic">ac</span>, il y a deux racines distinctes <span style="font-style:italic">t</span><sub>±</sub> , 
donc deux valeurs de <span style="font-style:italic">t</span> où il faut faire une étude
de branche infinie, on a alors une
hyperbole<a id="hevea_default101"></a>
avec 4 branches infinies et deux asymptotes parallèles à
<span style="font-style:italic">y</span>=<span style="font-style:italic">t</span><sub>±</sub><span style="font-style:italic">x</span> (en effet le rapport <span style="font-style:italic">y</span>/<span style="font-style:italic">x</span>=<span style="font-style:italic">t</span> tend bien
vers <span style="font-style:italic">t</span><sub>±</sub> et <span style="font-style:italic">y</span>−<span style="font-style:italic">t</span><sub>±</sub><span style="font-style:italic">x</span> a une limite car la racine au
dénominateur de <span style="font-style:italic">x</span> et <span style="font-style:italic">y</span> est simple 
donc il y a simplification avec le numérateur)
</li></ul><p>
<span style="font-weight:bold">Exercice</span> : paramétrer et faire l’étude des coniques :<br>
<span style="font-style:italic">x</span><sup>2</sup>+4<span style="font-style:italic">y</span><sup>2</sup>+2<span style="font-style:italic">xy</span>=4, <span style="font-style:italic">x</span><sup>2</sup>−3<span style="font-style:italic">y</span><sup>2</sup>+2<span style="font-style:italic">xy</span>=4</p><p><span style="font-weight:bold">Remarque</span> : 
on a vu que les ellipses, paraboles, hyperboles admettent une
équation réduite du second degré. On en déduit facilement que
leur équation dans un repère quelconque est toujours
du second degré. Réciproquement, pour une équation cartésienne
on a calculé une paramétrisation rationnelle, mais pas
démontré que c’était forcément une conique. Pour faire
cela, l’outil adapté est l’étude des formes quadratiques. On peut
toutefois le faire à la main en dimension 2, en faisant une rotation
<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span> → <span style="font-style:italic">X</span>,<span style="font-style:italic">Y</span> pour annuler le coefficient de <span style="font-style:italic">XY</span>. Par exemple<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:40px;font-size:large">restart; z:=(X+i*Y)*exp2trig(exp(i*alpha));x:=re(z); y:=im(z);tlin(coeff(a*x^2+b*x*y+c*y^2,[X,Y],[1,1]))  
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
on voit que l’angle de la rotation à effectuer vérifie
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">c</span>−<span style="font-style:italic">a</span>)sin(2<span style="font-style:italic">d</span>)+<span style="font-style:italic">b</span>cos(2<span style="font-style:italic">d</span>)=0    ⇒    tan(2<span style="font-style:italic">d</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>−<span style="font-style:italic">c</span></td></tr>
</table></td></tr>
</table>
<!--TOC section id="sec104" Propriétés métriques des courbes.-->
<h2 id="sec104" class="section">11  Propriétés métriques des courbes.</h2><!--SEC END --><p> <a id="sec:courbes_m"></a>
</p>
<!--TOC subsection id="sec105" Longueur d’arc-->
<h3 id="sec105" class="subsection">11.1  Longueur d’arc</h3><!--SEC END --><p>
La longueur <span style="font-style:italic">ds</span> d’un morceau de courbe régulier parcouru
pendant un petit intervalle de temps <span style="font-style:italic">dt</span> est égal
au premier ordre à la longueur du segment tangent parcouru,
ou encore au produit de la norme de la vitesse instantanée 
par <span style="font-style:italic">dt</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">ds</span>=</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">x</span>′<sup>2</sup>+<span style="font-style:italic">y</span>′<sup>2</sup></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">dt</span></td></tr>
</table><p>
On remarque que cette quantité est invariante par changement de 
paramétrage, si <span style="font-style:italic">t</span>=<span style="font-style:italic">t</span>(τ) alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">ds</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"><sup>2</sup>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"><sup>2</sup></td></tr>
</table></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:8em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>τ</td></tr>
</table></td><td class="dcell"><sup>2</sup>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>τ</td></tr>
</table></td><td class="dcell"><sup>2</sup></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>τ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">2</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> |</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>τ</td></tr>
</table></td><td class="dcell">| <span style="font-style:italic">d</span>τ </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>τ</td></tr>
</table></td><td class="dcell"><sup>2</sup>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>τ</td></tr>
</table></td><td class="dcell"><sup>2</sup></td></tr>
</table></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">d</span>τ
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
On en déduit
</p><div class="theorem"><span style="font-weight:bold">Proposition 18</span>  <em> 
La longueur d’un arc de courbe entre les points
de paramètre </em><span style="font-style:italic">t</span><sub>0</sub><em> et </em><span style="font-style:italic">t</span><sub>1</sub><em> vaut
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">x</span>′<sup>2</sup>+<span style="font-style:italic">y</span>′<sup>2</sup></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">dt</span></td></tr>
</table><em><br>
En coordonnées polaires :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">θ<sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">θ<sub>0</sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">r</span>′<sup>2</sup>+<span style="font-style:italic">r</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">d</span>θ</td></tr>
</table><em>
</em></div><p><span style="font-weight:bold">Remarque</span> : il est très rare que l’on puisse effectuer
le calcul explicite d’une primitive de √<span style="text-decoration:overline"><span style="font-style:italic">x</span></span><span style="text-decoration:overline">′</span><sup><span style="text-decoration:overline">2</span></sup><span style="text-decoration:overline">+</span><span style="text-decoration:overline"><span style="font-style:italic">y</span></span><span style="text-decoration:overline">′</span><sup><span style="text-decoration:overline">2</span></sup>,
il faut alors se contenter d’une valeur approchée de l’intégrale
lorsque <span style="font-style:italic">t</span><sub>0</sub> et <span style="font-style:italic">t</span><sub>1</sub> ont des valeurs numériques, calculée
par des méthodes numériques qui généralisent la méthode
des rectangles (cf. le cours de mat249).
Ce calcul se fait avec Xcas (ou une calculatrice formelle) en donnant
une valeur approchée à l’une des bornes.
Il y a quelques exceptions  par exemple la longueur d’un arc de 
parabole se calcule avec une formule explicite (essayez la
commande <code>int(sqrt(1+4t^2),t,t0,t1)</code> ou<br>
<br><textarea onkeypress="UI.ckenter(event,this,2)" style="width:400px;height:20px;font-size:large">t:='t';arclen([t,t^2],t,t0,t1) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML='&nbsp;'+tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><span></span><br><br>
La cycloïde<a id="hevea_default102"></a><sup><a id="text17" href="#note17">17</a></sup> 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">R</span>(<span style="font-style:italic">t</span>−sin(<span style="font-style:italic">t</span>)), <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">R</span>(1−cos(<span style="font-style:italic">t</span>))</td></tr>
</table><p>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plotparam([t-sin(t),1-cos(t)],t,0,2*pi)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
 
admet aussi une formule simple pour sa longueur 

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">arclen([t-sin(t),1-cos(t)],t,0,2*pi)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
Par contre, la
longueur d’un arc d’ellipse ne se calcule pas avec les fonctions
usuelles (pour pouvoir le faire, il faut introduire des fonctions spéciales
adaptées, appelées intégrales elliptiques) :<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">a:=int(sqrt(sin(t)^2+4*cos(t)^2),t,0,2*pi); evalf(a) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p>
<!--TOC subsection id="sec106" Courbure, repère de Frenet, accélération normale et
tangentielle.-->
<h3 id="sec106" class="subsection">11.2  Courbure, repère de Frenet, accélération normale et
tangentielle.</h3><!--SEC END --><p> <a id="sec:courbure"></a>
Si on choisit <span style="font-style:italic">s</span>, la longueur d’arc, comme nouveau paramètre de temps, 
la longueur parcourue est égale au temps, donc la vitesse instantannée
par rapport à <span style="font-style:italic">s</span> est de norme 1. On peut aussi le voir en notant <span style="font-style:italic">M</span>(<span style="font-style:italic">t</span>)=(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dM</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> =</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dM</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> 
 ⇒  || </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dM</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> || = || </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dM</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"> || |</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">|
 ⇒  <span style="font-style:italic">v</span> = || </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dM</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"> || <span style="font-style:italic">v</span></td></tr>
</table><p>
où <span style="font-style:italic">v</span> est la norme de la vitesse avec <span style="font-style:italic">t</span> comme paramètre,
donc || <span style="font-style:italic">dM</span>/<span style="font-style:italic">ds</span> || est bien égal à 1.</p><p>Calculons maintenant l’accélération avec ce nouveau paramètre <span style="font-style:italic">s</span>. Comme
la vitesse est de norme constante égale à 1, donc de carré 1, 
en dérivant (<span style="font-style:italic">dM</span>/<span style="font-style:italic">ds</span>)<sup>2</sup> par rapport à <span style="font-style:italic">s</span>,
on vérifie que l’accélération est perpendiculaire à la vitesse
pour ce paramétrage par la longueur d’arc <span style="font-style:italic">s</span>. 
L’accélération par rapport à <span style="font-style:italic">s</span> est donc portée par la normale à la trajectoire,
et sa mesure algébrique est appelé courbure (signée), notée κ,
la valeur absolue de l’inverse de κ est appelé le rayon de courbure
(la direction de l’accélération pointe vers le centre
de courbure). 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span><sup>2</sup><span style="font-style:italic">M</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> ⊥ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">,    || </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span><sup>2</sup><span style="font-style:italic">M</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span><sup>2</sup></td></tr>
</table></td><td class="dcell">|| =
|κ| = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">R</span></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Si on se déplace sur un cercle de centre <span style="font-style:italic">O</span>
et de rayon <span style="font-style:italic">R</span> à vitesse 1, alors <span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>)+<span style="font-style:italic">iy</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">Re</span><sup><span style="font-style:italic">it</span>/<span style="font-style:italic">R</span></sup>, la vitesse
est donnée par <span style="font-style:italic">x</span>′+<span style="font-style:italic">iy</span>′=<span style="font-style:italic">ie</span><sup><span style="font-style:italic">it</span>/<span style="font-style:italic">R</span></sup> donc de norme 1, et l’accélération
par <span style="font-style:italic">x</span>″+<span style="font-style:italic">iy</span>″=−1/<span style="font-style:italic">R</span> <span style="font-style:italic">e</span><sup><span style="font-style:italic">it</span>/<span style="font-style:italic">R</span></sup>, sa norme vaut 1/<span style="font-style:italic">R</span> et sa direction
pointe vers le centre du cercle. Donc la courbe est, 
à l’ordre 2 au point considéré, identique à un cercle de rayon <span style="font-style:italic">R</span>.</p><p>Revenons au paramètrage initial <span style="font-style:italic">t</span>. Dérivons par rapport à <span style="font-style:italic">t</span> la vitesse
<span style="font-style:italic">dM</span>/<span style="font-style:italic">dt</span> = <span style="font-style:italic">v</span> <span style="font-style:italic">dM</span>/<span style="font-style:italic">ds</span>, on obtient :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell"> =</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span><sup>2</sup><span style="font-style:italic">M</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dv</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dM</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"> + <span style="font-style:italic">v</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dM</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dv</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dM</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"> + <span style="font-style:italic">v</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span><sup>2</sup><span style="font-style:italic">M</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dv</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dM</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"> + <span style="font-style:italic">v</span><sup>2</sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span><sup>2</sup><span style="font-style:italic">M</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
L’accélération se décompose donc en deux parties 
</p><ul class="itemize"><li class="li-itemize">
le premier
terme colinéaire au vecteur tangent est l’accélération 
tangentielle<a id="hevea_default103"></a>, 
de norme <span style="font-style:italic">v</span>′, 
</li><li class="li-itemize">le second terme perpendiculaire au vecteur tangent
est l’accélération normale<a id="hevea_default104"></a>, 
dont la norme est <span style="font-style:italic">v</span><sup>2</sup>/<span style="font-style:italic">R</span>,
où <span style="font-style:italic">R</span> est le rayon de courbure<a id="hevea_default105"></a>
</li></ul><p>Autre formule de calcul du rayon de courbure : l’accélération normale <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> vaut <span style="font-style:italic">v</span><sup>2</sup>/<span style="font-style:italic">R</span> donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|| </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell"> ∧ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell"> ||=
<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> ||</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">||=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">R</span></td></tr>
</table></td><td class="dcell"> 
 ⇒  <span style="font-style:italic">R</span> =<span style="font-style:italic">v</span><sup>3</sup>/||</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell"> ∧ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">||
=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">x</span>′<sup>2</sup>+<span style="font-style:italic">y</span>′<sup>2</sup></td></tr>
</table></td><td class="dcell"><sup>3</sup></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">x</span>′<span style="font-style:italic">y</span>′′−<span style="font-style:italic">y</span>′<span style="font-style:italic">x</span>′′|</td></tr>
</table></td></tr>
</table><div class="theorem"><span style="font-weight:bold">Proposition 19</span>  <em>
On appelle repère de Frenet</em><a id="hevea_default106"></a><em> 
en un point </em><span style="font-style:italic">M</span><em> régulier d’une courbe, 
le repère orthonormé direct formé par
le point de la courbe, le vecteur tangent </em><span style="font-style:italic">T</span><sup>→</sup><em> 
et le vecteur normal </em><span style="font-style:italic">N</span><sup>→</sup><em>. On a alors
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">=<span style="font-style:italic">v</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">,    </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">=κ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">, 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">=−κ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">,
   <span style="font-style:italic">R</span>=±</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">κ</td></tr>
</table></td><td class="dcell">, 
</td></tr>
</table><em>
(l’avant-dernière formule vient du fait que </em>{ <span style="font-style:italic">T</span><sup>→</sup>
,<span style="font-style:italic">N</span><sup>→</sup> }<em> est une base orthonormée directe, le signe
</em>±<em> est déterminé par la convexité de la courbe), et :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dv</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell"> ±
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">R</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">,   
<span style="font-style:italic">R</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">x</span>′<sup>2</sup>+<span style="font-style:italic">y</span>′<sup>2</sup></td></tr>
</table></td><td class="dcell"><sup>3</sup></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">x</span>′<span style="font-style:italic">y</span>′′−<span style="font-style:italic">y</span>′<span style="font-style:italic">x</span>′′|</td></tr>
</table></td></tr>
</table><em>
On appelle centre de courbure le point </em>Ω=<span style="font-style:italic">M</span>+1/κ<span style="font-style:italic">N</span><sup>→</sup><em>. Le cercle de centre </em>Ω<em> passant par </em><span style="font-style:italic">M</span><em>
(de rayon </em><span style="font-style:italic">R</span><em>)
est appelé cercle osculateur</em><a id="hevea_default107"></a><em> en </em><span style="font-style:italic">M</span><em> à la courbe.
</em></div><p>
<span style="font-weight:bold">Exemple</span> : calcul du cercle osculateur en un point d’une parabole
(<span style="font-style:italic">t</span>,<span style="font-style:italic">t</span><sup>2</sup>).
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>′=1, <span style="font-style:italic">y</span>′=2<span style="font-style:italic">t</span>,  
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">=(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+4<span style="font-style:italic">t</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">,</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+4<span style="font-style:italic">t</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">),   
<span style="font-style:italic">y</span>′′=2   <span style="font-style:italic">R</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+4<span style="font-style:italic">t</span><sup>2</sup></td></tr>
</table></td><td class="dcell"><sup>3</sup></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
</table><p>


<div><form onsubmit="setTimeout(function(){UI.eval_form(form);});return false;">
<input type="text" name="name" size="1" value=
"t0">

=<input type="number" name="valname" onchange="UI.eval_form(form);" value=
"0">

<input type="button" value="-" onclick="valname.value -= stepname.value;UI.eval_form(form);">
<input type="button" value="+" onclick="valname.value -= -stepname.value;UI.eval_form(form);">
<input type="number" name="stepname" value=
"0.1">

<input type="range" name="rangename"
onclick="valname.value=value;UI.eval_form(form);" value=
"0" min="-5" max="5" step="0.1">

<textarea name="prog" onchange="UI.eval_form(form)" style="width:400px;height:120px;vertical-align:bottom;font-size:large">
gl_x=-5..5; gl_y=0..6;G:=plotparam([t,t^2],t=-2.3..2.3,color=red);M:=point(evalf(t0),t0^2,affichage=point_croix+epaisseur_point_3);T:=tangent(G,evalf(t0));N:=normalize([-slope(T),1]); R:=(1+4t0^2)^(3/2)/2;C:=circle(M+R*N,R);

</textarea>
</form>
<span>Not evaled</span></div>

Avec Xcas version 1.1.1-18 ou supérieure, on peut taper directement :<br>
<code>C:=cercle_osculateur(G,M)</code></p><p><span style="font-weight:bold">Remarques </span>: 
</p><ul class="itemize"><li class="li-itemize">
La courbure<a id="hevea_default108"></a> est aussi la dérivée par
rapport à l’abscisse curviligne de 
l’angle θ fait par la
tangente avec une direction fixe, par exemple l’axe <span style="font-style:italic">Ox</span>.
En effet <span style="font-style:italic">T</span><sup>→</sup>=(cos(θ),sin(θ)),
dont la dérivée est le produit de θ′ par le vecteur
normal <span style="font-style:italic">N</span><sup>→</sup>.
</li><li class="li-itemize">Génériquement, une courbe reste du même coté de
sa tangente (car le terme suivant dans le développement est d’ordre
2, de signe constant en 0), les exceptions sont les points
d’inflexion. Par contre,
génériquement une courbe traverse son cercle osculateur (en y
rentrant ou en en sortant), car le terme suivant dans le
développement de la différence entre les points des deux courbes 
est d’ordre 3 et change donc de signe en 0. Les exceptions
(tangeance courbe-cercle osculateur d’ordre 3 au lieu de 2)
sont appelés sommets d’une courbe, par exemple le sommet d’une
parabole.
</li><li class="li-itemize">on peut calculer les coordonnées du centre du cercle
osculateur de manière algébrique (i.e. sans introduire de racines
carrées) à partir des
coordonnées paramétriques de <span style="font-style:italic">M</span> et de ses dérivées
</li><li class="li-itemize">la courbe <span style="font-style:italic">D</span> décrite par les Ω lorsque <span style="font-style:italic">M</span> parcourt
la courbe étudiée <span style="font-style:italic">C</span> est appelée
<span style="font-weight:bold">développée</span><a id="hevea_default109"></a> 
de la courbe <span style="font-style:italic">C</span>. 
La vitesse de Ω vaut
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">M</span>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">κ</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">)=<span style="font-style:italic">v</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell"> +
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">d</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">κ</td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">κ</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">v</span>(−κ
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell">)
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">d</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">κ</td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">→</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
<tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
</table></td><td class="dcell"> </td></tr>
</table>
on en déduit que la tangente à la développée en Ω a
pour direction la normale <span style="font-style:italic">N</span><sup>→</sup> (si κ admet un
point critique, par exemple en un sommet de la courbe,
la développée admet génériquement
un point de rebroussement<sup><a id="text18" href="#note18">18</a></sup>). 
<em>L’enveloppe</em><a id="hevea_default110"></a><sup><a id="text19" href="#note19"><em>19</em></a></sup><em> 
des normales à une courbe est donc sa développée.</em><br>
Exemple : développée de l’ellipse (2cos(<span style="font-style:italic">t</span>),sin(<span style="font-style:italic">t</span>))<br>
Initialiser la trace avec 
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">L:=[]
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
puis faire varier <span style="font-style:italic">t</span>0 :


<div><form onsubmit="setTimeout(function(){UI.eval_form(form);});return false;">
<input type="text" name="name" size="1" value=
"t0">

=<input type="number" name="valname" onchange="UI.eval_form(form);" value=
"0.7">

<input type="button" value="-" onclick="valname.value -= stepname.value;UI.eval_form(form);">
<input type="button" value="+" onclick="valname.value -= -stepname.value;UI.eval_form(form);">
<input type="number" name="stepname" value=
"0.1">

<input type="range" name="rangename"
onclick="valname.value=value;UI.eval_form(form);" value=
"0.7" min="-5" max="5" step="0.1">

<textarea name="prog" onchange="UI.eval_form(form)" style="width:400px;height:120px;vertical-align:bottom;font-size:large">
gl_x=-6..6;gl_y=-4..4;G:=plotparam([2*cos(t),sin(t)],t=0..2*pi);M:=element(G,evalf(t0));T:=tangent(M);N:=perpendiculaire(M,T);L:=append(L,N);evolute(G,color=red)

</textarea>
</form>
<span>Not evaled</span></div>

On observe 4 sommets pour l’ellipse, situés sur les grands et
petits axes, et donc 4 points de rebroussements pour la développée.
Ouvrir un niveau de géométrie 2d dans Xcas, taper une commande
par ligne<br>
<code>G:=plotparam([2*cos(t),sin(t)],t=0..2*pi);</code><br>
<code>M:=element(G);</code><br>
<code>T:=tangent(M);</code><br>
<code>N:=perpendiculaire(M,T);</code><br>
<code>trace(N)</code><br>
passer en mode pointeur (menu mode du niveau
de géométrie) et faire bouger le point <span style="font-style:italic">M</span> le long
d’un quart de l’ellipse, ceci trace un faisceau de normales
à l’ellipse, dont on voit apparaitre l’enveloppe (limite
entre la région couverte et non couverte par des points
du faisceau de normales), cette enveloppe est
la développée de l’ellipse (vous pouvez utiliser 
le menu M à droite
du dessin pour effacer les traces). Avec Xcas version 1.1.1-18
ou ultérieure on peut tracer la développée avec
la commande <code>developpee(G)</code>.<br>
Cf. aussi les animations de l’article Développée de wikipedia.<br>
<span style="font-weight:bold">Exercice</span> : calculer le repère de Frenet pour une ellipse <span style="font-style:italic">E</span>,
par exemple <span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>)=4cos(<span style="font-style:italic">t</span>), <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=3sin(<span style="font-style:italic">t</span>)
puis le rayon de courbure, puis la développée <span style="font-style:italic">A</span>
(on obtient une courbe image par affinité
d’une astroïde<a id="hevea_default111"></a>). Donner une équation
paramétrique simple de <span style="font-style:italic">A</span>.<br>
Vérification avec Xcas (version à jour) :<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:120px;font-size:large">E:=plotparam([4cos(t),3sin(t)],t,0,2pi); A:=evolute(E);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">eq:=simplify(parameq(A)); trigcos(re(eq)); im(eq) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</li><li class="li-itemize">De plus, comme <span style="font-style:italic">N</span><sup>→</sup> est normé,
la longueur d’arc de courbe de la développée est donnée par :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">d</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">κ</td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪</td><td class="dcell"> <span style="font-style:italic">dt</span> = 
</td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪</td><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">κ</td></tr>
</table></td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪</td><td class="dcell">
= |<span style="font-style:italic">R</span>(<span style="font-style:italic">t</span><sub>1</sub>)−<span style="font-style:italic">R</span>(<span style="font-style:italic">t</span><sub>0</sub>)|
</td></tr>
</table>
<br>
Conséquence : si on enroule un fil sur la développée <span style="font-style:italic">D</span>,
que ce fil est tendu et que son extrémité coïncide, avant de
commencer à le dérouler, avec un point de la courbe <span style="font-style:italic">C</span> 
alors dans la suite du déroulé, l’extrémité parcoura la courbe
<span style="font-style:italic">C</span> (on dit que <span style="font-style:italic">C</span> est une développante de <span style="font-style:italic">D</span>).
</li><li class="li-itemize">si la courbure est de signe constant, les cercles osculateurs
sont inclus les uns dans les autres, c’est une conséquence
de la remarque précédente, de l’inégalité triangulaire
et du fait que la distance entre deux centres de cercles
osculateurs est plus petite que la longueur d’arc sur la
développée. Comme les points de la courbe sont
sur des cercles osculateurs, il en résulte que la courbe
entre ou sort définitivement du cercle osculateur au point
de contact.
</li><li class="li-itemize">La développée peut servir à calculer une caustique en
optique. On envoie des rayons lumineux parallèle à une
direction fixée vers un miroir ayant la forme de la courbe <span style="font-style:italic">C</span>
la <span style="font-weight:bold">caustique</span><a id="hevea_default112"></a> 
est l’enveloppe des rayons lumineux réfléchis
(que l’on observe par une plus grande intensité lumineuse).
On peut montrer que la caustique est la développée 
de l’anticaustique de <span style="font-style:italic">C</span> par rapport à une droite perpendiculaire
aux rayons lumineux (pour déterminer 
l’anticaustique d’une courbe par rapport
à une droite, on prend un point de la courbe, on le projète sur
la droite puis on prend le symétrique du projeté par rapport à la
tangente à la courbe au point choisi, 
l’anticaustique est le lieu de ces symétriques). 
Cf. dans Xcas la session exemple du
menu <code>Exemple, geometrie, caustique</code>.
Les développées peuvent aussi servir dans le calcul de caustiques
par réfraction :
<code>http://www.mathcurve.com/courbes2d/caustic/caustic.htm</code>
</li><li class="li-itemize">On peut faire une étude analogue pour une courbe dans
l’espace, dans ce cas la dérivée de <span style="font-style:italic">N</span><sup>→</sup>
par rapport à l’abscisse curviligne <span style="font-style:italic">s</span> fait intervenir une
composante sur le troisième vecteur du repère direct
<span style="font-style:italic">T</span><sup>→</sup> ∧<span style="font-style:italic">N</span><sup>→</sup>=<span style="font-style:italic">B</span><sup>→</sup> 
(<span style="font-style:italic">B</span><sup>→</sup> comme binormal), appelé
torsion.
</li><li class="li-itemize"><span style="font-weight:bold">Équation intrinsèque d’une courbe :</span><br>
Il s’agit de trouver une courbe vérifiant une relation entre la
courbure (ou rayon de courbure) et l’abscisse curviligne, par exemple
la relation <span style="font-style:italic">Rs</span>=<span style="font-style:italic">b</span><sup>2</sup> avec <span style="font-style:italic">b</span>&gt;0 fixé.<sup><a id="text20" href="#note20">20</a></sup>
Pour trouver une telle courbe, on la paramètre par l’abscisse
curviligne <span style="font-style:italic">s</span>, donc la vitesse <span style="font-style:italic">dM</span>/<span style="font-style:italic">ds</span> est de norme 1 et caractérisée
par l’angle φ(<span style="font-style:italic">s</span>) fait avec une direction fixe, on a alors
φ′(<span style="font-style:italic">s</span>)=1/<span style="font-style:italic">R</span> et on en tire φ(<span style="font-style:italic">s</span>) puis <span style="font-style:italic">M</span>(<span style="font-style:italic">s</span>). 
Dans l’exemple, on a φ′(<span style="font-style:italic">s</span>)=<span style="font-style:italic">s</span>/<span style="font-style:italic">b</span><sup>2</sup>, donc φ(<span style="font-style:italic">s</span>)=<span style="font-style:italic">s</span><sup>2</sup>/(2<span style="font-style:italic">b</span><sup>2</sup>) (en
choisissant la direction fixe pour annuler la constante
d’intégration), puis :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dM</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ds</span></td></tr>
</table></td><td class="dcell">=</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">cos</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">s</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">b</span><sup>2</sup></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">,sin</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">s</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">b</span><sup>2</sup></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table>
puis en choisissant l’origine du repère :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">M</span>(<span style="font-style:italic">s</span>)=</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">
</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">s</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> cos</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">b</span><sup>2</sup></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"> <span style="font-style:italic">du</span> ,
</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">s</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> sin</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">b</span><sup>2</sup></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
 <span style="font-style:italic">du</span>
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table>
en posant <span style="font-style:italic">u</span>=√<span style="text-decoration:overline">2</span><span style="font-style:italic">b</span> <span style="font-style:italic">v</span> on a aussi
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">M</span>(<span style="font-style:italic">s</span>)=</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">b</span> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">s</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">b</span></td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> cos(<span style="font-style:italic">v</span><sup>2</sup>)  <span style="font-style:italic">dv</span> ,
</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">s</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">b</span></td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> sin(<span style="font-style:italic">v</span><sup>2</sup>)  <span style="font-style:italic">dv</span>
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table>
Pour <span style="font-style:italic">b</span>=1/√<span style="text-decoration:overline">2</span>, le tracé est obtenu par la commande<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plotparam(int(exp(i*t^2),t,0,s),s=-3..3,tstep=0.03)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li></ul>
<!--TOC section id="sec107" Représentation des courbes implicites.-->
<h2 id="sec107" class="section">12  Représentation des courbes implicites.</h2><!--SEC END --><p> <a id="sec:implicite"></a>
Certaines représentations graphiques nécessitent peu d’outillage
mathématique, ainsi les fonctions, les courbes paramétrique
et polaires peuvent être représentées en échantillonant 
une ou plusieurs expressions
selon une discrétisation donnée explicitement par l’utilisateur
ou par des paramètres par défaut, les points obtenus
étant ensuite reliés par des segments.
On pourrait bien sur automatiser avec le calcul
formel l’étude de la courbe (tableaux de variations,
asymptotes, points singuliers, etc.).</p><p>Par contre les courbes données par une équation implicite
font intervenir des algorithmes et des mathématiques
plus intéressantes. En dimension 2, on se donne donc
une équation <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)=0 et on suppose <span style="font-style:italic">f</span> suffisamment
régulière. Supposons la courbe non vide, soit (<span style="font-style:italic">x</span><sub>0</sub>,<span style="font-style:italic">y</span><sub>0</sub>)
un point de cette courbe, si (∂<sub><span style="font-style:italic">x</span></sub> <span style="font-style:italic">f</span>,∂<sub><span style="font-style:italic">y</span></sub> <span style="font-style:italic">f</span>)(<span style="font-style:italic">x</span><sub>0</sub>,<span style="font-style:italic">y</span><sub>0</sub>) ≠
0 on peut appliquer le théorème des fonctions implicites
et la courbe est localement comme une courbe de fonction (en <span style="font-style:italic">x</span> ou
en <span style="font-style:italic">y</span>). On en calcule la tangente et on peut suivre cette tangente
un pas de discrétisation puis utiliser une méthode numérique
de recherche de solution près de la tangente. Ces points
sont appelés <span style="font-weight:bold">points réguliers</span><a id="hevea_default116"></a><a id="hevea_default117"></a></p><p>Les points où (∂<sub><span style="font-style:italic">x</span></sub> <span style="font-style:italic">f</span>,∂<sub><span style="font-style:italic">y</span></sub> <span style="font-style:italic">f</span>)=0 sont
les <span style="font-weight:bold">points singuliers</span><a id="hevea_default118"></a><a id="hevea_default119"></a>. 
Génériquement, il n’y en a pas puisque
cela donne 3 équations à 2 inconnues, par contre si on
s’intéresse à une famille de courbes dépendant d’un
paramètre, il en apparait. En ces points, on calcule le
développement de Taylor et on recherche le premier
terme homogène non nul (homogène après translation bien sur), 
par exemple
<span style="font-style:italic">P</span><sub>2</sub>=<span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">y</span><sup>2</sup> pour <span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">y</span><sup>2</sup> en (0,0). 
Supposons que le polynôme
correspondant <span style="font-style:italic">P</span><sub><span style="font-style:italic">m</span></sub> est sans racines multiples, et (quitte
à faire une rotation) que le coefficient de <span style="font-style:italic">y</span><sup><span style="font-style:italic">m</span></sup> est non nul.
<span style="font-style:italic">P</span><sub><span style="font-style:italic">m</span></sub> est un polynôme homogène 
donc se factorise au moins numériquement
(en remplaçant une des variables par 1, on est ramené en dimension 1),
et on montre qu’il y a <span style="font-style:italic">m</span> arcs de courbe complexes tangents
aux droites d’équations ces <span style="font-style:italic">m</span> facteurs (et au plus
<span style="font-style:italic">m</span> arcs de courbe réels si on ne garde
que les racines réelles). En effet, on pose <span style="font-style:italic">y</span>=<span style="font-style:italic">xY</span> et on 
est amené à résoudre
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">xY</span>)=0=<span style="font-style:italic">x</span><sup><span style="font-style:italic">m</span></sup><span style="font-style:italic">P</span><sub><span style="font-style:italic">m</span></sub>(1,<span style="font-style:italic">Y</span>) + <span style="font-style:italic">x</span><sup><span style="font-style:italic">m</span>+1</sup> <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">Y</span>)</td></tr>
</table><p>
où <span style="font-style:italic">g</span> est un polynôme si <span style="font-style:italic">f</span> est un polynôme 
(plus généralement a la même régularité que <span style="font-style:italic">f</span>). 
Après simplification par <span style="font-style:italic">x</span><sup><span style="font-style:italic">m</span></sup>, on peut appliquer le théorème des
fonctions implicites pour déterminer <span style="font-style:italic">Y</span> en fonction de <span style="font-style:italic">x</span> au
voisinage de <span style="font-style:italic">x</span>=0 et de chacune des racines de <span style="font-style:italic">P</span><sub><span style="font-style:italic">m</span></sub>(1,<span style="font-style:italic">Y</span>) en <span style="font-style:italic">Y</span>
(puisque les racines sont simples).
Le point 
est dit <span style="font-weight:bold">singulier-régulier</span><a id="hevea_default120"></a> ou
singulier ordinaire<a id="hevea_default121"></a>. 
C’est ce que fait la commande <code>implicitplot</code><a id="hevea_default122"></a><a id="hevea_default123"></a> de Xcas
(affichage des informations intermédiaires).</p><p>Si le point singulier n’est pas ordinaire, l’équation devient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">Y</span>−<span style="font-style:italic">t</span>)<sup><span style="font-style:italic">k</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">Y</span>−<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>) + <span style="font-style:italic">xg</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">Y</span>)=0,    <span style="font-style:italic">k</span>&gt;1</td></tr>
</table><p>
et il faut faire intervenir des puissances fractionnaires en <span style="font-style:italic">x</span>
(dépendant de termes supérieurs du développement de Taylor
de <span style="font-style:italic">f</span> en (0,0))
pour désingulariser les <span style="font-style:italic">k</span> arcs de courbes ayant même tangente
<span style="font-style:italic">y</span>=<span style="font-style:italic">tx</span> en (0,0). Par exemple si <span style="font-style:italic">g</span>(0,<span style="font-style:italic">t</span>) ≠ 0, 
on pose <span style="font-style:italic">X</span>=<span style="font-style:italic">x</span><sup>1/<span style="font-style:italic">k</span></sup>, <span style="font-style:italic">Y</span>=<span style="font-style:italic">t</span>+<span style="font-style:italic">XZ</span>
qui donne 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Z</span><sup><span style="font-style:italic">k</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">t</span>−<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>+<span style="font-style:italic">XZ</span>) + <span style="font-style:italic">g</span>(<span style="font-style:italic">X</span><sup><span style="font-style:italic">k</span></sup>,<span style="font-style:italic">t</span>+<span style="font-style:italic">XZ</span>)=0</td></tr>
</table><p>
pour <span style="font-style:italic">X</span>=0 on a alors <span style="font-style:italic">k</span> solutions non nulles <span style="font-style:italic">Z</span> qui
se prolongent au voisinage de <span style="font-style:italic">X</span>=0 par le théorème des
fonctions implicites.</p><p>Certains cas particuliers peuvent être traités en
transformant la courbe implicite en courbe paramétrique,
c’est le cas des courbes algébriques de degré 2, qui
sont des <span style="font-weight:bold">coniques</span><a id="hevea_default124"></a>. On peut les paramétrer rationnellement
si on en connait un point (en prenant la droite passant par ce point
de pente <span style="font-style:italic">m</span> et en cherchant l’autre point d’intersection
avec la conique (il y en a forcément un et un seul autre,
parce que l’équation correspondant aux points
d’intersection est de degré 2
et on connait déjà une solution), cette paramétrisation
est intéressante pour faire du calcul formel, mais moins
pour des représentations graphiques, on lui préferera
une paramétrisation trigonométrique pour une conique
ou exponentielle pour une hypebole, par exemple
(cos(<span style="font-style:italic">t</span>),sin(<span style="font-style:italic">t</span>)) plutot que 1+<span style="font-style:italic">it</span>/1−<span style="font-style:italic">it</span> pour
le cercle unité, paramétrisation obtenue en calculant
les éléments propres de la conique (<code>conique_reduite</code>). 
Pour les courbes algébriques de degré
plus grand, on commence par factoriser le polynôme,
c’est une factorisation absolue (section <a href="#sec%3Afactorisation_absolue">18.7</a>) qui est nécessaire (ou
au moins numérique dans ℂ[<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>]). Pour le moment,
Xcas fait simplement une factorisation sur le corps
des coefficients, et repère les équations de coniques.</p>
<!--TOC section id="sec108" Formes différentielles et intégrales curvilignes-->
<h2 id="sec108" class="section">13  Formes différentielles et intégrales curvilignes</h2><!--SEC END --><p> 
<a id="sec:diff"></a>
Il s’agit dans cette section de calculer des intégrales
le long de l’arc. Cela intervient
par exemple pour calculer le travail d’une force au cours d’un
déplacement le long d’une courbe 
ou la quantité de chaleur/travail pendant
un cycle en thermodynamique (le long d’une courbe
dans le plan défini par deux coordonnées indépendantes 
comme par exemple pression-température ou pression-volume). 
Dans les cas favorables, on a un analogue des primitives, on peut
calculer un potentiel et faire la différence de potentiel entre les
deux extrémités du chemin pour calculer l’intégrale curviligne.
On va d’abord définir ce
qu’on peut intégrer le long d’une courbe, à savoir une
forme différentielle (aussi appelée 1-forme), puis on
donnera quelques résultats sur les formes fermées et
exactes (c’est le cas favorable, il correspond aux forces
conservatives en mécanique ou aux différentielles totales
de fonctions d’état en thermodynamique).</p>
<!--TOC subsection id="sec109" Forme différentielle-->
<h3 id="sec109" class="subsection">13.1  Forme différentielle</h3><!--SEC END --><p>
Soit <span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) une fonction de deux variables continument dérivable.
On s’intéresse aux variations de <span style="font-style:italic">V</span> lorsqu’on se déplace dans le
plan depuis le point <span style="font-style:italic">M</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) dans une direction donnée à
la vitesse <span style="font-style:italic">w</span>.
On a alors une formule équivalente à celle de 
la dérivée d’une fonction d’une variable :
</p><div class="theorem"><span style="font-weight:bold">Proposition 20</span>  <em>
Pour tout vecteur </em><span style="font-style:italic">w</span>=(<span style="font-style:italic">w</span><sub>1</sub>,<span style="font-style:italic">w</span><sub>2</sub>)<em>, la dérivée de </em><span style="font-style:italic">V</span><em> en </em>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)<em>
dans la direction </em><span style="font-style:italic">w</span><em> est donnée par :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center">lim</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span>→ 0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">V</span>((<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)+<span style="font-style:italic">wh</span>)−<span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
</table></td><td class="dcell">=
∂<sub><span style="font-style:italic">x</span></sub><span style="font-style:italic">Vw</span><sub>1</sub>+∂<sub><span style="font-style:italic">y</span></sub><span style="font-style:italic">V</span> <span style="font-style:italic">w</span><sub>2</sub></td></tr>
</table><em>
On appelle </em><em><span style="font-weight:bold">différentielle</span></em><a id="hevea_default125"></a><em> 
de </em><span style="font-style:italic">V</span><em> et on note </em><span style="font-style:italic">dV</span><em> l’application
qui en un point </em>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)<em> associe au vecteur </em><span style="font-style:italic">w</span><em> la valeur de la
dérivée directionnelle de </em><span style="font-style:italic">V</span><em> en </em>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)<em> selon </em><span style="font-style:italic">w</span><em>
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">dV</span>(<span style="font-style:italic">w</span>)=∂<sub><span style="font-style:italic">x</span></sub><span style="font-style:italic">V</span> <span style="font-style:italic">w</span><sub>1</sub>+∂<sub><span style="font-style:italic">y</span></sub><span style="font-style:italic">V</span> <span style="font-style:italic">w</span><sub>2</sub></td></tr>
</table><em>
Cette application est linéaire par rapport à </em><span style="font-style:italic">w</span><em>.
</em></div><p>
En effet :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">w</span><sub>1</sub><span style="font-style:italic">h</span>,<span style="font-style:italic">y</span>+<span style="font-style:italic">w</span><sub>2</sub><span style="font-style:italic">h</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">w</span><sub>1</sub><span style="font-style:italic">h</span>,<span style="font-style:italic">y</span>)+∂<sub><span style="font-style:italic">y</span></sub><span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">w</span><sub>1</sub><span style="font-style:italic">h</span>,<span style="font-style:italic">y</span>) <span style="font-style:italic">w</span><sub>2</sub><span style="font-style:italic">h</span> + <span style="font-style:italic">o</span>(<span style="font-style:italic">h</span>)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)+∂<sub><span style="font-style:italic">x</span></sub><span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) <span style="font-style:italic">w</span><sub>1</sub> <span style="font-style:italic">h</span> + ∂<sub><span style="font-style:italic">y</span></sub><span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">w</span><sub>1</sub><span style="font-style:italic">h</span>,<span style="font-style:italic">y</span>) <span style="font-style:italic">w</span><sub>2</sub><span style="font-style:italic">h</span> + <span style="font-style:italic">o</span>(<span style="font-style:italic">h</span>)
</td></tr>
</table></td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">w</span><sub>1</sub><span style="font-style:italic">h</span>,<span style="font-style:italic">y</span>+<span style="font-style:italic">w</span><sub>2</sub><span style="font-style:italic">h</span>)−<span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >∂<sub><span style="font-style:italic">x</span></sub><span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) <span style="font-style:italic">w</span><sub>1</sub> + ∂<sub><span style="font-style:italic">y</span></sub><span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">w</span><sub>1</sub><span style="font-style:italic">h</span>,<span style="font-style:italic">y</span>) <span style="font-style:italic">w</span><sub>2</sub> +<span style="font-style:italic">o</span>(1) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >→<sub><span style="font-style:italic">h</span>→ 0</sub></td><td style="text-align:left;white-space:nowrap" >∂<sub><span style="font-style:italic">x</span></sub><span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) <span style="font-style:italic">w</span><sub>1</sub>
+ ∂<sub><span style="font-style:italic">y</span></sub><span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) <span style="font-style:italic">w</span><sub>2</sub> 
</td></tr>
</table></td></tr>
</table><p><span style="font-weight:bold">Exemples </span>: 
</p><ul class="itemize"><li class="li-itemize">
la dérivée de <span style="font-style:italic">V</span> selon la direction (1,0) (axe des <span style="font-style:italic">x</span>)
est ∂<sub><span style="font-style:italic">x</span></sub><span style="font-style:italic">V</span> et selon la direction (0,1) (axe des <span style="font-style:italic">y</span>)
est ∂<sub><span style="font-style:italic">y</span></sub> <span style="font-style:italic">V</span>.
</li><li class="li-itemize">Soit <span style="font-style:italic">A</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>) et <span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)=√<span style="text-decoration:overline">(</span><span style="text-decoration:overline"><span style="font-style:italic">x</span></span><span style="text-decoration:overline">−</span><span style="text-decoration:overline"><span style="font-style:italic">a</span></span><span style="text-decoration:overline">)</span><sup><span style="text-decoration:overline">2</span></sup><span style="text-decoration:overline">+(</span><span style="text-decoration:overline"><span style="font-style:italic">y</span></span><span style="text-decoration:overline">−</span><span style="text-decoration:overline"><span style="font-style:italic">b</span></span><span style="text-decoration:overline">)</span><sup><span style="text-decoration:overline">2</span></sup> 
la distance de <span style="font-style:italic">A</span> au point <span style="font-style:italic">M</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>).
Alors <span style="font-style:italic">dV</span> existe en tout point <span style="font-style:italic">M</span> différent de <span style="font-style:italic">A</span>
et (∂<sub><span style="font-style:italic">x</span></sub> <span style="font-style:italic">V</span>,∂<sub><span style="font-style:italic">y</span></sub> <span style="font-style:italic">V</span>)=(<span style="font-style:italic">x</span>−<span style="font-style:italic">a</span>,<span style="font-style:italic">y</span>−<span style="font-style:italic">b</span>)/<span style="font-style:italic">AM</span> est le vecteur
unitaire porté par →<span style="font-style:italic">AM</span>.
</li></ul><p><span style="font-weight:bold">Remarque : Différentielle et gradient</span><br>
La différentielle <span style="font-style:italic">dV</span> a les mêmes composantes que
le <span style="font-weight:bold">gradient</span><a id="hevea_default126"></a> de <span style="font-style:italic">V</span> (<code>gradient(V,[x,y])</code> avec Xcas), 
mais ce ne sont pas les mêmes objets : 
en un point donné
<span style="font-style:italic">dV</span> est une application linéaire (qui a un sens indépendamment
de la définition d’un produit scalaire)
alors que ∇ <span style="font-style:italic">V</span> est un vecteur (dont la relation
avec la dérivée directionnelle dépend du produit scalaire), 
on a pour tout vecteur <span style="font-style:italic">w</span> la relation 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">dV</span>(<span style="font-style:italic">w</span>)=∇ <span style="font-style:italic">V</span>. <span style="font-style:italic">w</span> </td></tr>
</table><p>
On a la même relation entre le travail d’une force (qui est une
forme linéaire qui s’applique sur les vecteurs déplacement) 
et la force correspondante (qui est un vecteur
défini à l’aide du produit scalaire). On parle parfois de vecteur
covariant pour la différentielle (et vecteur contravariant pour le
gradient).</p><p><span style="font-weight:bold">Applications </span>: 
</p><ul class="itemize"><li class="li-itemize">
Tangente à une courbe de niveau :<br>
le vecteur tangent en un point <span style="font-style:italic">M</span> d’une courbe de niveau de <span style="font-style:italic">V</span>
est dans le noyau de l’application linéaire <span style="font-style:italic">dV</span> en ce point
(puisque <span style="font-style:italic">V</span> est constant le long de le courbe), ou de
manière équivalente ∇ <span style="font-style:italic">V</span> est orthogonal à la
courbe de niveau.
</li><li class="li-itemize">Calcul du gradient en coordonnées polaires.<br>
le repère {<span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub>,<span style="font-style:italic">e</span><sub>θ</sub>} est orthonormé, pour
connaitre les coordonnées de ∇ <span style="font-style:italic">V</span> dans ce repère
il suffit de calculer la dérivée directionnelle de <span style="font-style:italic">V</span>
dans les directions <span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub> et <span style="font-style:italic">e</span><sub>θ</sub> car : 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">∇ <span style="font-style:italic">V</span>. <span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub> = <span style="font-style:italic">dV</span>(<span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub>),    ∇ <span style="font-style:italic">V</span>.<span style="font-style:italic">e</span><sub>θ</sub>=<span style="font-style:italic">dV</span>(<span style="font-style:italic">e</span><sub>θ</sub>)</td></tr>
</table> 
Or la dérivée directionnelle selon <span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub> est
la dérivée partielle de <span style="font-style:italic">V</span> par rapport à <span style="font-style:italic">r</span>, et la dérivée
directionnelle selon <span style="font-style:italic">e</span><sub>θ</sub> est la dérivée partielle de <span style="font-style:italic">V</span>
par rapport à θ divisée par <span style="font-style:italic">r</span> (il faut diviser par <span style="font-style:italic">r</span>
parce qu’on se déplace tangentiellement au cercle de rayon <span style="font-style:italic">r</span>), donc
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">∇ <span style="font-style:italic">V</span> = ∂<sub><span style="font-style:italic">r</span></sub> <span style="font-style:italic">V</span> <span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span></td></tr>
</table></td><td class="dcell"> ∂<sub>θ</sub><span style="font-style:italic">V</span> <span style="font-style:italic">e</span><sub>θ</sub></td></tr>
</table>
</li><li class="li-itemize">Tangente et la normale en un point <span style="font-style:italic">M</span> d’une ellipse :<br>
Ce sont la bissectrice extérieure et intérieure issues de <span style="font-style:italic">M</span> 
du triangle défini par <span style="font-style:italic">M</span> et les foyers. 
Cela vient du fait que le gradient de la
distance <span style="font-style:italic">FM</span> est le vecteur unitaire porté par
<span style="font-style:italic">FM</span>
et que l’ellipse est courbe de niveau de la somme des distances aux
foyers. On retrouve ainsi qu’un rayon lumineux issu d’un foyer
se réfléchit sur l’ellipse en passant par l’autre foyer.
</li><li class="li-itemize">De même on peut déterminer géométriquement la
tangente et la normale à une parabole,
ce sont les bissectrices issues de <span style="font-style:italic">M</span> 
de la droite <span style="font-style:italic">MF</span> (où <span style="font-style:italic">F</span> est le foyer) et de la
perpendiculaire en <span style="font-style:italic">M</span> à la directrice de la parabole,
on retrouve ainsi que les rayons lumineux perpendiculaires
à la directrice se réflechissent sur la parabole en passant
par le foyer) et à une hyperbole (comme pour une ellipse).
</li></ul><p>On note donc <span style="font-style:italic">dx</span> [resp. <span style="font-style:italic">dy</span>] la différentielle de
<span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)=<span style="font-style:italic">x</span> [resp. <span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)=<span style="font-style:italic">y</span>]<sup><a id="text21" href="#note21">21</a></sup>
on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">dV</span>=∂<sub><span style="font-style:italic">x</span></sub><span style="font-style:italic">V</span> <span style="font-style:italic">dx</span> + ∂<sub><span style="font-style:italic">y</span></sub><span style="font-style:italic">V</span> <span style="font-style:italic">dy</span></td></tr>
</table><p>Une <span style="font-weight:bold">forme 
différentielle</span><a id="hevea_default127"></a><a id="hevea_default128"></a>
ω est la généralisation
de la différentielle d’une fonction, elle s’écrit sous la forme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ω=<span style="font-style:italic">M</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) <span style="font-style:italic">dx</span> + <span style="font-style:italic">N</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) <span style="font-style:italic">dy</span></td></tr>
</table><p>
où <span style="font-style:italic">M</span> et <span style="font-style:italic">N</span> sont des fonctions 
des deux variables <span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>, mais pas forcément les dérivées
partielles d’une fonction <span style="font-style:italic">V</span>.</p><p>La définition géométrique d’une forme différentielle ω
est la donnée en tout point du plan (ou d’un domaine ouvert
du plan) d’une application linéaire de ℝ<sup>2</sup> à valeur dans ℝ
<sup><a id="text22" href="#note22">22</a></sup>
(ou en tout point de l’espace d’une application linéraire de ℝ<sup>3</sup>
à valeurs dans ℝ pour une courbe de ℝ<sup>3</sup>). 
Si on prend la base canonique de ℝ<sup>2</sup>,
une application linéaire de ℝ<sup>2</sup> dans ℝ est caractérisée
par sa matrice qui possède une ligne et deux colonnes et
a donc deux coefficients <span style="font-style:italic">M</span> et <span style="font-style:italic">N</span>, une forme différentielle
équivaut donc bien à la donnée d’un couple de fonction 
<span style="font-style:italic">M</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>),<span style="font-style:italic">N</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>).</p>
<!--TOC subsection id="sec110" Intégrale curviligne-->
<h3 id="sec110" class="subsection">13.2  Intégrale curviligne</h3><!--SEC END --><p>
Ceci permet de donner la :
</p><div class="theorem"><span style="font-weight:bold">Définition 21</span>  <em>
Pour calculer </em><em><span style="font-weight:bold">l’intégrale 
curviligne</span></em><a id="hevea_default129"></a><a id="hevea_default130"></a><em>
d’une forme différentielle 
le long d’un arc de courbe orienté,
on choisit un paramétrage de l’arc continument dérivable par morceaux
(on suppose qu’il en existe un), 
et on calcule l’intégrale usuelle par rapport au paramètre
de la forme différentielle appliquée au vecteur tangent entre les
deux valeurs du paramètre correspondant à l’origine
et extrémité de l’arc de courbe :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">γ</td></tr>
</table></td><td class="dcell">ω = </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell">
ω</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>γ(<span style="font-style:italic">t</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><span style="font-style:italic">dt</span> </td></tr>
</table><em>
En coordonnées,
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">γ</td></tr>
</table></td><td class="dcell">ω =</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> 
(<span style="font-style:italic">M</span>(<span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>),<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)) </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> + <span style="font-style:italic">N</span>(<span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>),<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>) </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">)  <span style="font-style:italic">dt</span></td></tr>
</table><em>
</em></div><p>
Exemple: on prend ω=<span style="font-style:italic">ydx</span> et on calcule l’intégrale
curviligne le long de l’arc de parabole (<span style="font-style:italic">t</span>,<span style="font-style:italic">t</span><sup>2</sup>) pour <span style="font-style:italic">t</span>∈[0,1],
on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">t</span><sup>2</sup>  <span style="font-style:italic">dt</span> =</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td></tr>
</table><p>
En paramétrant par (<span style="font-style:italic">u</span><sup>2</sup>,<span style="font-style:italic">u</span><sup>4</sup>) avec <span style="font-style:italic">u</span>∈[0,1]
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">u</span><sup>4</sup> (2<span style="font-style:italic">u</span>  <span style="font-style:italic">du</span>) = </td><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell">2</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sup>6</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td></tr>
</table><p>
on retrouve le même résultat.</p><p>La valeur de l’intégrale est bien définie
indépendamment du paramétrage, 
en effet si on change de paramétrage avec une bijection
<span style="font-style:italic">t</span> → <span style="font-style:italic">u</span>(<span style="font-style:italic">t</span>) envoyant [<span style="font-style:italic">t</span><sub>0</sub>,<span style="font-style:italic">t</span><sub>1</sub>] sur [<span style="font-style:italic">u</span><sub>0</sub>,<span style="font-style:italic">u</span><sub>1</sub>], on a (en
utilisant la linéarité de ω à la deuxième ligne) :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">u</span><sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">u</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> ω</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>γ(<span style="font-style:italic">u</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">du</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><span style="font-style:italic">du</span></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> ω</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">du</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>γ(<span style="font-style:italic">t</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">du</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell">  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">du</span></td></tr>
</table></td><td class="dcell"> ω</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>γ(<span style="font-style:italic">t</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">du</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell">  ω</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>γ(<span style="font-style:italic">t</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">  </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><span style="font-style:italic">dt</span>
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>Attention à l’orientation, si on change d’orientation, on change le
signe, par exemple si on parcourt l’arc de parabole de (1,1)
vers (0,0), en utilisant le paramétrage (1−<span style="font-style:italic">t</span>,(1−<span style="font-style:italic">t</span>)<sup>2</sup>), <span style="font-style:italic">t</span> ∈
[0,1], on obtient l’opposé :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> (1−<span style="font-style:italic">t</span>) (−<span style="font-style:italic">dt</span>) = </td><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">t</span>−1)<sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> = −</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td></tr>
</table><p>Remarque : le travail d’une force <span style="font-style:italic">F</span>=(<span style="font-style:italic">F</span><sub><span style="font-style:italic">x</span></sub>,<span style="font-style:italic">F</span><sub><span style="font-style:italic">y</span></sub>) le 
long d’un arc de courbe est donné par l’intégrale curviligne de la forme
différentielle <span style="font-style:italic">F</span><sub><span style="font-style:italic">x</span></sub> <span style="font-style:italic">dx</span>+<span style="font-style:italic">F</span><sub><span style="font-style:italic">y</span></sub><span style="font-style:italic">dy</span>. </p>
<!--TOC subsection id="sec111" Forme différentielle exacte-->
<h3 id="sec111" class="subsection">13.3  Forme différentielle exacte</h3><!--SEC END --><p><a id="hevea_default131"></a>
Voyons maintenant à quelle condition il existe un analogue du calcul
avec une primitive. On a:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">γ</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">dV</span>=<span style="font-style:italic">V</span>(γ(<span style="font-style:italic">t</span><sub>1</sub>))−<span style="font-style:italic">V</span>(γ(<span style="font-style:italic">t</span><sub>0</sub>)), </td></tr>
</table><p>
En effet, si on est sur un morceau d’arc où on peut paramétrer 
par <span style="font-style:italic">x</span> alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">γ</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">dV</span>=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span><sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> ∂<sub><span style="font-style:italic">x</span></sub> <span style="font-style:italic">V</span>  <span style="font-style:italic">dx</span> =
<span style="font-style:italic">V</span>(γ(<span style="font-style:italic">t</span><sub>1</sub>))−<span style="font-style:italic">V</span>(γ(<span style="font-style:italic">t</span><sub>0</sub>))</td></tr>
</table><p>
De même si on peut paramétrer par <span style="font-style:italic">y</span>. On recolle
alors les morceaux d’arcs (on peut paramétrer par <span style="font-style:italic">x</span>
ou par <span style="font-style:italic">y</span> en tout point régulier de γ).</p><p>Pour une force qui dérive d’un potentiel,
on a donc montré que le travail de la force se calcule 
en faisant la différence
de potentiel entre les deux extrémités. Cette propriété, 
analogue au calcul d’intégrale classique en utilisant une primitive
n’est pas automatique, car elle implique que l’intégrale curviligne
ne dépend pas du chemin choisi pour relier les deux points.
Or en thermodynamique, la
chaleur est modélisée par une forme différentielle, 
mais la chaleur échangée dépend du chemin
suivi (c’est vrai aussi en mécanique pour le travail de forces non
conservatives comme les forces de frottement).
En mathématiques, on parle de forme différentielle exacte ou non exacte.
</p><div class="theorem"><span style="font-weight:bold">Définition 22</span>  <em>
Une forme différentielle </em>ω<em> est exacte s’il existe une
fonction </em><span style="font-style:italic">V</span><em> telle que sur tout arc de courbe </em>γ<em> d’origine </em><span style="font-style:italic">A</span><em> et 
extrémité </em><span style="font-style:italic">B</span><em>
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">γ</td></tr>
</table></td><td class="dcell">ω = <span style="font-style:italic">V</span>(<span style="font-style:italic">B</span>)−<span style="font-style:italic">V</span>(<span style="font-style:italic">A</span>)</td></tr>
</table><em>
Attention la convention de signe est opposée à celle utilisée
pour le </em><em><span style="font-weight:bold">potentiel</span></em><a id="hevea_default132"></a><em> d’une force en physique.
</em></div><p>
Si on choisit comme chemin un segment entre deux points <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span>
d’ordonnées identiques <span style="font-style:italic">y</span> et d’abscisses <span style="font-style:italic">x</span> et <span style="font-style:italic">x</span>+<span style="font-style:italic">h</span>, alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span>+<span style="font-style:italic">h</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">M</span> <span style="font-style:italic">dx</span>+<span style="font-style:italic">Ndy</span> = <span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">h</span>,<span style="font-style:italic">y</span>)−<span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) </td></tr>
</table><p>
en faisant tendre <span style="font-style:italic">h</span> vers 0, on a 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">M</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center">lim</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span>→ 0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">h</span>,<span style="font-style:italic">y</span>)−<span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
</table></td><td class="dcell"> = ∂<sub><span style="font-style:italic">x</span></sub> <span style="font-style:italic">V</span></td></tr>
</table><p>
De même <span style="font-style:italic">N</span>=∂<sub><span style="font-style:italic">y</span></sub> <span style="font-style:italic">V</span>.
Réciproquement, si <span style="font-style:italic">M</span>=∂<sub><span style="font-style:italic">x</span></sub> <span style="font-style:italic">V</span> et <span style="font-style:italic">N</span>=∂<sub><span style="font-style:italic">y</span></sub> <span style="font-style:italic">V</span> alors
ω=<span style="font-style:italic">dV</span> donc ∫<sub>γ</sub>ω=<span style="font-style:italic">V</span>(<span style="font-style:italic">B</span>)−<span style="font-style:italic">V</span>(<span style="font-style:italic">A</span>)
</p><div class="theorem"><span style="font-weight:bold">Proposition 23</span>  <em>
Une forme différentielle </em>ω<em> est exacte si et seulement si il 
existe une fonction </em><span style="font-style:italic">V</span><em> telle que :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ω=∂<sub><span style="font-style:italic">x</span></sub> <span style="font-style:italic">V</span> <span style="font-style:italic">dx</span> + ∂<sub><span style="font-style:italic">y</span></sub> <span style="font-style:italic">V</span> <span style="font-style:italic">dy</span>=<span style="font-style:italic">dV</span></td></tr>
</table><em>
</em></div><p>
Si <span style="font-style:italic">V</span> est deux fois continument différentiable alors
∂<sub><span style="font-style:italic">yx</span></sub> <span style="font-style:italic">V</span> = ∂<sub><span style="font-style:italic">xy</span></sub> <span style="font-style:italic">V</span>. D’où
une condition nécessaire pour que ω soit exacte :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">∂<sub><span style="font-style:italic">y</span></sub> <span style="font-style:italic">M</span> = ∂<sub><span style="font-style:italic">yx</span></sub> <span style="font-style:italic">V</span> = ∂<sub><span style="font-style:italic">xy</span></sub> <span style="font-style:italic">V</span> = ∂<sub><span style="font-style:italic">x</span></sub> <span style="font-style:italic">N</span></td></tr>
</table><div class="theorem"><span style="font-weight:bold">Définition 24</span>  <em>
On appelle forme différentielle
fermée</em><a id="hevea_default133"></a><em> une forme
différentielle </em>ω=<span style="font-style:italic">Mdx</span>+<span style="font-style:italic">Ndy</span><em> telle que
</em>∂<sub><span style="font-style:italic">y</span></sub> <span style="font-style:italic">M</span>=∂<sub><span style="font-style:italic">x</span></sub> <span style="font-style:italic">N</span><em> 
</em></div><p>
Une forme exacte est toujours fermée, mais la réciproque n’est pas
toujours vraie, une forme fermée n’est pas forcément exacte, cela
dépend où elle est définie. Si elle est définie dans un
domaine ouvert de ℝ<sup>2</sup> sans trou (ℝ<sup>2</sup> tout entier,
un rectangle, un disque, etc.), 
on peut montrer qu’une forme 
fermée est une forme exacte, en appliquant le théorème 
de Stokes (voir section suivante). Sinon, il existe des
contre-exemples, comme sur le cercle unité
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ω=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ydx</span>−<span style="font-style:italic">xdy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2</sup>+<span style="font-style:italic">y</span><sup>2</sup></td></tr>
</table></td></tr>
</table><p>
La forme est fermée :<br>
<code>simplify(diff(y/(x^2+y^2),y)-diff(-x/(x^2+y^2),x))</code><br>
mais elle n’est pas exacte :<br>
<code>x:=cos(t); y:=sin(t);</code><br>
<code>int((y*diff(x,t)-x*diff(y,t))/(x^2+y^2),t,0,2*pi)</code></p><p>Pour trouver le potentiel<a id="hevea_default134"></a> 
<span style="font-style:italic">V</span> dont une forme différentielle fermée
ω=<span style="font-style:italic">M</span> <span style="font-style:italic">dx</span>+<span style="font-style:italic">Ndy</span> est la différentielle, on résoud d’abord par exemple 
 <span style="font-style:italic">M</span> = ∂<sub><span style="font-style:italic">x</span></sub> <span style="font-style:italic">V</span> 
en intégrant <span style="font-style:italic">M</span> par rapport à <span style="font-style:italic">x</span>, <span style="font-style:italic">y</span> étant considéré
comme un paramètre, on obtient <span style="font-style:italic">V</span> à une constante d’intégration
près, cette constante d’intégration en <span style="font-style:italic">x</span> peut dépendre
de <span style="font-style:italic">y</span>, c’est donc une fonction <span style="font-style:italic">C</span>(<span style="font-style:italic">y</span>), 
on remplace dans <span style="font-style:italic">N</span>=∂<sub><span style="font-style:italic">y</span></sub> <span style="font-style:italic">V</span> et on intègre
en <span style="font-style:italic">y</span> pour trouver la valeur de <span style="font-style:italic">C</span>(<span style="font-style:italic">y</span>) (à une constante près).
Cette opération est executée par la commande <code>potential()</code>
de Xcas.</p><p>Si une forme n’est pas fermée, elle n’est pas exacte, et on ne peut
pas calculer une intégrale curviligne par différence de potentiel.
Il peut arriver qu’en multipliant la forme par une fonction, on trouve
une nouvelle forme qui elle est fermée, on parle alors de facteur
intégrant. Par exemple en thermodynamique, la forme chaleur
n’est pas fermée, mais en divisant par la température on
obtient une forme fermée dont le potentiel est l’entropie.
Cela peut aussi servir à trouver des constantes du mouvement
pour certaines équations différentielles. En effet, si on
se déplace le long d’une courbe de niveau du potentiel
d’une forme exacte, alors le long de cette courbe le potentiel
est constant, donc la forme appliquée au vecteur tangent
est nulle, on dit que la courbe de niveau est une courbe
intégrale de la forme différentielle (exacte).</p>
<!--TOC subsection id="sec112" Intégrale curviligne et intégrales doubles.-->
<h3 id="sec112" class="subsection">13.4  Intégrale curviligne et intégrales doubles.</h3><!--SEC END --><p>
Terminons ce chapitre par le lien entre intégrale curviligne
sur un lacet (chemin fermé) et intégrale double à l’intérieur 
du lacet. C’est évidemment surtout intéressant pour les
formes non exactes, car si γ est un lacet et ω
une forme exacte, alors ∫<sub>γ</sub>ω=0.
On a le théorème de <span style="font-weight:bold">Stokes</span><a id="hevea_default135"></a>, 
aussi appelé en dimension 2 
formule de <span style="font-weight:bold">Green-Riemann</span><a id="hevea_default136"></a> :
</p><div class="theorem"><span style="font-weight:bold">Théorème 25</span>  <em>
Si </em><span style="font-style:italic">U</span><em> est un domaine de frontière orientée
</em>γ<em> continument dérivable 
(</em>γ<em> est donc un chemin fermé parcouru une fois que
l’on oriente dans le sens trigonométrique), et si 
</em>ω=<span style="font-style:italic">Mdx</span> + <span style="font-style:italic">N</span> <span style="font-style:italic">dy</span><em> est une forme
différentielle continument dérivable alors :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">γ</td></tr>
</table></td><td class="dcell">ω = </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">U</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">d</span>ω := 
</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">U</span></td></tr>
</table></td><td class="dcell"> (∂<sub><span style="font-style:italic">x</span></sub> <span style="font-style:italic">N</span> −∂<sub><span style="font-style:italic">y</span></sub> <span style="font-style:italic">M</span>)  <span style="font-style:italic">dx</span> <span style="font-style:italic">dy</span></td></tr>
</table><em>
</em></div><p>
Idée de la preuve : on commence par le cas où <span style="font-style:italic">U</span> est un
rectangle [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>] × [α,β], on peut alors calculer 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">U</span></td></tr>
</table></td><td class="dcell"> ∂<sub><span style="font-style:italic">x</span></sub> <span style="font-style:italic">N</span>   <span style="font-style:italic">dx</span> <span style="font-style:italic">dy</span> 
= </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell">(</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">b</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> ∂<sub><span style="font-style:italic">x</span></sub> <span style="font-style:italic">N</span>   <span style="font-style:italic">dx</span>) <span style="font-style:italic">dy</span>
= </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">N</span>(<span style="font-style:italic">b</span>,<span style="font-style:italic">y</span>)−<span style="font-style:italic">N</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">y</span>)) <span style="font-style:italic">dy</span> </td></tr>
</table><p>
on compare avec les intégrales curvilignes sur les segments verticaux
{(<span style="font-style:italic">a</span>,<span style="font-style:italic">y</span>), <span style="font-style:italic">y</span> ∈ [α,β]} et {(<span style="font-style:italic">b</span>,<span style="font-style:italic">y</span>), <span style="font-style:italic">y</span> ∈ [β,α]}.
De même pour <span style="font-style:italic">M</span> et les segments horizontaux.</p><p>Pour le cas d’un domaine d’intégration <span style="font-style:italic">U</span> plus général, on approche <span style="font-style:italic">U</span>
par une réunion disjointe de petits rectangles.</p><p><span style="font-weight:bold">Application </span>: pour calculer l’aire d’un domaine <span style="font-style:italic">U</span> de frontière
γ, il suffit de
calculer l’une des intégrales curvilignes :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">γ</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">y</span> <span style="font-style:italic">dx</span>= </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">γ</td></tr>
</table></td><td class="dcell">−<span style="font-style:italic">x</span> <span style="font-style:italic">dy</span> = </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">γ</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span> <span style="font-style:italic">dx</span> − <span style="font-style:italic">x</span>
<span style="font-style:italic">dy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
</table><p>
Par exemple, l’aire à l’intérieur de l’ellipse <span style="font-style:italic">x</span>=<span style="font-style:italic">a</span>cos(<span style="font-style:italic">t</span>),
<span style="font-style:italic">y</span>=<span style="font-style:italic">b</span>sin(<span style="font-style:italic">t</span>) vaut
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">2π</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span> sin(<span style="font-style:italic">t</span>) <span style="font-style:italic">d</span>(<span style="font-style:italic">a</span>cos(<span style="font-style:italic">t</span>)) − <span style="font-style:italic">a</span>cos(<span style="font-style:italic">t</span>)
<span style="font-style:italic">d</span>(<span style="font-style:italic">b</span>sin(<span style="font-style:italic">t</span>))</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> = <span style="font-style:italic">ab</span>π </td></tr>
</table><p>On peut aussi calculer des moments d’<span style="font-weight:bold">inertie</span><a id="hevea_default137"></a> 
ou la position d’un <span style="font-weight:bold">centre de gravité</span><a id="hevea_default138"></a>
en se ramenant à une intégrale curviligne.<br>
<span style="font-weight:bold">Exemple </span>: Calculer la position du centre d’inertie d’un quart
de cercle <span style="font-style:italic">C</span>={(cos(<span style="font-style:italic">t</span>),sin(<span style="font-style:italic">t</span>)),  <span style="font-style:italic">t</span> ∈ [0,π/2]}.<br>
On a donc <span style="font-style:italic">U</span> délimité par γ, réunion de {(<span style="font-style:italic">x</span>,0),  <span style="font-style:italic">x</span>
∈ [0,1]} , <span style="font-style:italic">C</span> et {(0,<span style="font-style:italic">y</span>), <span style="font-style:italic">y</span> ∈ [1,0]}.
Pour trouver la position du centre
d’inertie en <span style="font-style:italic">x</span> (en <span style="font-style:italic">y</span> c’est identique), on doit calculer
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">U</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span>  <span style="font-style:italic">dx</span> <span style="font-style:italic">dy</span> = </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">γ</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sup>2</sup>  <span style="font-style:italic">dy</span>
= 0 + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> cos(<span style="font-style:italic">t</span>)<sup>2</sup> cos(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> + 0= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td></tr>
</table><p>
et on divise par π/4 l’aire du quart de cercle, on trouve
donc (4/3π,4/3π), on peut visualiser avec
la commande <code>cercle(0,1); G:=point(4/(3*pi),4/(3*pi))</code></p>
<!--TOC section id="sec113" Équations et systèmes différentiels.-->
<h2 id="sec113" class="section">14  Équations et systèmes différentiels.</h2><!--SEC END --><p> <a id="sec:ode"></a></p>
<!--TOC subsection id="sec114" Introduction et représentation graphique.-->
<h3 id="sec114" class="subsection">14.1  Introduction et représentation graphique.</h3><!--SEC END --><p>
On s’intéresse à l’équation différentielle
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:diff"></a>
<span style="font-style:italic">y</span>′=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">=<span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>,<span style="font-style:italic">t</span>)
    (16)</td></tr>
</table><p>
où <span style="font-style:italic">y</span> ∈ ℝ<sup><span style="font-style:italic">n</span></sup> et <span style="font-style:italic">f</span>: ℝ<sup><span style="font-style:italic">n</span></sup> × ℝ → ℝ<sup><span style="font-style:italic">n</span></sup>.
Si <span style="font-style:italic">n</span>=1, c’est une équation différentielle, si <span style="font-style:italic">n</span>&gt;1 c’est
un système différentiel.</p><p>Exemple : en dimension <span style="font-style:italic">n</span>=1, <span style="font-style:italic">y</span>′=<span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>,<span style="font-style:italic">t</span>)=<span style="font-style:italic">ay</span>. On sait résoudre cette
équation, les solutions sont de la forme <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">Ce</span><sup><span style="font-style:italic">at</span></sup>. Si on trace
la courbe représentative de ces solutions (appelée
courbe intégrale), on observe que par
tout point du plan, il passe une solution unique. La tangente
à une courbe intégrale a pour pente <span style="font-style:italic">y</span>′=<span style="font-style:italic">ay</span> donc pour
vecteur directeur le vecteur de composantes (1,<span style="font-style:italic">ay</span>).</p><p>C’est vrai de manière plus générale, le vecteur directeur
de la tangente à une courbe intégrale est (1,<span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>,<span style="font-style:italic">t</span>)). Si
on représente dans le plan selon un quadrillage régulier
les vecteurs (1,<span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>,<span style="font-style:italic">t</span>)), une courbe intégrale doit être
tangente à ces vecteurs chaque fois qu’elle passe en un point
du quadrillage, (et à peu près tangente si elle passe à
proximité). Un tel quadrillage est appelé champ des tangentes
(commande <code>plotfield</code> en Xcas, mode également disponible
sur certaines calculatrices).</p><p>Exercice : tracer le champ des tangentes et quelques solutions
pour quelques exemples de fonction <span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>,<span style="font-style:italic">t</span>), avec Xcas créer
une figure 2d, puis choisir le mode Champ des tangentes
du menu Geo, Graphe, entrer la fonction, puis cliquer en quelques
points pour faire tracer la solution passant par ces points.</p><p>L’équation (<a href="#eq%3Adiff">16</a>) est d’ordre 1, or certaines équations
différentielles se présentent naturellement comme des
équations d’ordre 2, par exemple l’équation fondementale
de la dynamique (accélération=somme des forces divisée par
la masse). Mais on peut facilement se ramener à un
système différentiel d’ordre
1, en augmentant la dimension de <span style="font-style:italic">y</span>. Par exemple, si
on pose <span style="font-style:italic">y</span>=(<span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>),<span style="font-style:italic">v</span>(<span style="font-style:italic">t</span>)), où <span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>) est la position
et <span style="font-style:italic">v</span>(<span style="font-style:italic">t</span>) la vitesse, alors l’équation devient un système d’ordre 1
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>) </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">v</span>(<span style="font-style:italic">t</span>) </td></tr>
</table></td><td class="dcell">
</td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell">
= </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">v</span>(<span style="font-style:italic">t</span>) </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">F</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
où <span style="font-style:italic">F</span> est la force, qui dépend de la position <span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>) 
(champ électrique, gravitation...) et
éventuellement de la vitesse (force de frottement, champ magnétique...).
On utilise aussi assez fréquemment <span style="font-style:italic">y</span>=(<span style="font-style:italic">q</span>(<span style="font-style:italic">t</span>),<span style="font-style:italic">p</span>(<span style="font-style:italic">t</span>))
où <span style="font-style:italic">q</span>(<span style="font-style:italic">t</span>) est la position, et <span style="font-style:italic">p</span>(<span style="font-style:italic">t</span>) la quantité de mouvement
(qui dépend de la vitesse, linéairement en mécanique classique).</p><p>Représentation graphique : comme précédemment,
on peut se placer dans l’espace
des (<span style="font-style:italic">t</span>,<span style="font-style:italic">x</span>,<span style="font-style:italic">v</span>) (si <span style="font-style:italic">x</span> est en dimension 1), mais il est souvent
plus difficile d’observer des phénomènes sur un graphe
en 3-d que dans le plan, on préfère ne pas représenter explicitement le
temps <span style="font-style:italic">t</span>, mais uniquement (<span style="font-style:italic">x</span>,<span style="font-style:italic">v</span>), on est donc naturellement
ramené à représenter une solution (une courbe intégrale)
par une courbe paramétrique en (<span style="font-style:italic">x</span>,<span style="font-style:italic">v</span>) (ou en position
impulsion). On a encore la notion de champ des tangentes
si <span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>,<span style="font-style:italic">t</span>)=<span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>) ne dépend pas explicitement du temps
(on dit que le système est <em>autonome</em>), dans ce
cas une courbe intégrale a pour tangente en <span style="font-style:italic">y</span>∈ ℝ<sup>2</sup> 
de direction portée par le vecteur <span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>) ∈ ℝ<sup>2</sup>.<br>
<span style="font-weight:bold">Exemple</span> : (<span style="font-style:italic">x</span>,<span style="font-style:italic">v</span>)′=5(−<span style="font-style:italic">v</span>,<span style="font-style:italic">x</span>). La commande <br>
<code>plotfield(5*[-y,x],[x=-1..1,y=-1..1],normalize)</code><br>
permet d’en représenter le champ des tangentes
et d’avoir une idée approximative de l’allure des solutions.
On sait résoudre ce système différentiel, soit en appliquant
une technique matricielle présentée ci-dessous, 
soit en se ramenant à une équation
linéaire d’ordre 2 à coefficients constants:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>′′=−5<span style="font-style:italic">v</span>′=−25<span style="font-style:italic">x</span></td></tr>
</table><p>
donc <span style="font-style:italic">x</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">A</span>cos(5<span style="font-style:italic">t</span>)+<span style="font-style:italic">B</span>sin(5<span style="font-style:italic">t</span>), <span style="font-style:italic">A</span>, <span style="font-style:italic">B</span> étant déterminés
par les conditions initiales sur (<span style="font-style:italic">x</span>,<span style="font-style:italic">v</span>).</p><p>Une équation donnée sous la forme (<a href="#eq%3Adiff">16</a>) 
est appelée une équation résolue en <span style="font-style:italic">y</span>,
car on a exprimé la dérivée en fonction de <span style="font-style:italic">y</span> et de <span style="font-style:italic">t</span>. Il
existe (plus fréquemment en mathématiques) d’autres formes d’équations
différentielles (non résolues) où le premier travail de résolution
peut consister à exprimer
<span style="font-style:italic">y</span>′ en fonction de <span style="font-style:italic">y</span> et <span style="font-style:italic">t</span> (ce qui n’est pas toujours possible 
explicitement).</p><p>Exemple : en dimension 1, <span style="font-style:italic">ty</span>′=<span style="font-style:italic">y</span>, on sait résoudre exactement
cette équation à variables séparables, les solutions sont de la 
forme <span style="font-style:italic">Ct</span>. On observe que contrairement à <span style="font-style:italic">y</span>′=<span style="font-style:italic">ay</span>
où passe une solution et une seule par chaque point du plan,
ici toutes les solutions valent 0 en <span style="font-style:italic">t</span>=0 : il passe une
infinité de solutions par le point (0,0) et il n’en passe aucune
par (0,<span style="font-style:italic">a</span>),  <span style="font-style:italic">a</span> ≠ 0. Ce phénomène de non unicité/non
existence vient de la mise sous forme résolue <span style="font-style:italic">y</span>′=<span style="font-style:italic">y</span>/<span style="font-style:italic">t</span> qui
fait apparaitre une singularité de <span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>,<span style="font-style:italic">t</span>) en <span style="font-style:italic">t</span>=0.</p><p>On présente dans la suite de cette section 
des résultats qualitatifs sur les équations sous forme résolue
lorsqu’on ne sait pas les résoudre, ainsi que 
quelques méthodes explicites
pour certaines équations différentielles que l’on sait
résoudre.</p>
<!--TOC subsection id="sec115" Existence et unicité-->
<h3 id="sec115" class="subsection">14.2  Existence et unicité</h3><!--SEC END --><p> <a id="sec:existence"></a>
Il s’agit ici de préciser dans quelles conditions le résultat
intuitif suivant est vrai : étant donné une condition initiale
<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>)=<span style="font-style:italic">y</span><sub>0</sub>, il y a une et une seule évolution possible, donc
une solution unique <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>) de l’équation ou du système
(<a href="#eq%3Adiff">16</a>).</p><p>On a le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 26</span>  <em> </em><a id="thm:eqdiff"></a><em> (Cauchy-Lipschitz)
Si </em><span style="font-style:italic">f</span><em> est continument dérivable en </em><span style="font-style:italic">y</span><em> et </em><span style="font-style:italic">t</span><em> sur </em>ℝ<sup><span style="font-style:italic">n</span></sup> × ℝ<em>
ou sur un domaine ouvert </em><span style="font-style:italic">D</span><em> inclus dans </em>ℝ<sup><span style="font-style:italic">n</span></sup> × ℝ<em>, alors l’équation
(ou le système) résolu (</em><a href="#eq%3Adiff"><em>16</em></a><em>) admet pour toute condition
initiale </em><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>)=<span style="font-style:italic">y</span><sub>0</sub><em> une solution unique
sur un intervalle maximal ouvert en temps contenant </em><span style="font-style:italic">t</span><sub>0</sub><em>.
</em></div><p>
<span style="font-weight:bold">Remarques</span>
</p><ul class="itemize"><li class="li-itemize">
Attention, l’existence d’une solution ne signifie absolument pas que
l’on sait calculer explicitement <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>).
</li><li class="li-itemize">L’existence et l’unicité d’une solution permet d’affirmer le
caractère déterministe de l’équation. Mais la méconnaissance
précise de la condition initiale peut au cours du temps
provoquer une erreur tellement grande sur <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)
que celle-ci devient imprédictible.
</li><li class="li-itemize">Le théorème ne dit rien sur la taille de l’intervalle
d’existence de la solution (en temps). Certaines solutions
peuvent exploser en temps fini, par exemple<br>
<code>desolve([y'=y^2,y(0)=1])</code><br>
Bien entendu, si on modélise une quantité physique par <span style="font-style:italic">y</span>, dire
que <span style="font-style:italic">y</span> explose (en temps fini ou infini du reste)
signifie que les approximations utilisées pour la modélisation
ne sont plus valable bien avant.
</li></ul><p>
On admettra ce théorème, voici quelques idées heuristiques
de la preuve. L’équation <span style="font-style:italic">y</span>′=<span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>,<span style="font-style:italic">t</span>) peut se réécrire sous la forme
intégrale équivalente 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>)+</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">y</span>′(<span style="font-style:italic">u</span>)  <span style="font-style:italic">du</span> =
<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>)+</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>(<span style="font-style:italic">u</span>),<span style="font-style:italic">u</span>) <span style="font-style:italic">du</span> </td></tr>
</table><p> 
Si <span style="font-style:italic">t</span> est assez proche de <span style="font-style:italic">t</span><sub>0</sub>, on peut approcher l’intégrale par 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>) = <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>) + (<span style="font-style:italic">t</span>−<span style="font-style:italic">t</span><sub>0</sub>) <span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>),<span style="font-style:italic">t</span><sub>0</sub>) + petite erreur</td></tr>
</table><p>
C’est exactement ce qu’on fait en suivant le champ des tangentes
pour approcher une courbe intégrale graphiquement, et si on
discrétise le temps avec un pas petit, cette méthode
d’approximation est appelée méthode d’Euler. On peut
bien sur utiliser d’autres approximations (meilleures) de
l’intégrale pour avoir une meilleure approximation de la solution,
et les méthodes dites de Runge-Kutta utilisent cette idée. D’un
point de vue théorique, la preuve repose plutôt sur ce qu’on
appelle le théorème du point fixe, on met la valeur approchée
de <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>) trouvée dans l’équation intégrale pour avoir
une nouvelle valeur approchée de <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>), on recommence,
ainsi de suite, et on montre que
le processus converge (il s’agit mathématiquement parlant
d’une suite récurrente de fonctions, la preuve rigoureuse
de la convergence nécessite des outils mathématiques 
de niveau L3-M1 de maths, c’est l’analogue des suites
récurrentes de réels qui permettent de résoudre
numériquement des équations comme <span style="font-style:italic">x</span>=cos(<span style="font-style:italic">x</span>)
abordées en mat249).</p><p><span style="font-weight:bold">Conséquence du théorème </span><a href="#thm%3Aeqdiff"><span style="font-weight:bold">26</span></a> : 
deux courbes intégrales de la même équation
différentielle ne peuvent se couper dans <span style="font-style:italic">D</span>. Donc si on connait
une courbe intégrale <span style="font-style:italic">C</span> de <span style="font-style:italic">D</span> et qu’on prend une condition initiale
en-dehors de cette courbe, la courbe intégrale unique passant
par cette condition initiale restera du même coté de <span style="font-style:italic">D</span>. Si on
connait deux courbes intégrales de <span style="font-style:italic">D</span>, une courbe intégrale
passant par une condition initiale entre les deux courbes restera
entre les deux courbes.</p><p><span style="font-weight:bold">Exemple</span> : <span style="font-style:italic">y</span>′=<span style="font-style:italic">y</span>(1−<span style="font-style:italic">y</span>). Cette équation autonome admet deux solutions
évidentes <span style="font-style:italic">y</span>=0 et <span style="font-style:italic">y</span>=1. Donc pour toute condition initiale <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>)
∈ ]0,1[, on a <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>) ∈ ]0,1[<sup><a id="text23" href="#note23">23</a></sup>. 
On en déduit que <span style="font-style:italic">y</span>′=<span style="font-style:italic">y</span>(1−<span style="font-style:italic">y</span>)&gt;0
donc la solution <span style="font-style:italic">y</span> est strictement croissante, comme elle est
bornée par 0 et 1, elle admet une limite pour <span style="font-style:italic">t</span> → ±
∞, donc <span style="font-style:italic">y</span>′ tend vers 0 pour <span style="font-style:italic">t</span> → ±
∞, donc <span style="font-style:italic">y</span> tend vers 0 ou 1, et comme <span style="font-style:italic">y</span> croit, 
<span style="font-style:italic">y</span> → 0 en <span style="font-style:italic">t</span>=−∞ et <span style="font-style:italic">y</span> → 1 en <span style="font-style:italic">t</span>=+∞.
Le comportement à l’infini est donc indépendant de la valeur
précise de la condition initiale, pourvu qu’elle soit dans ]0,1[.</p><p><span style="font-weight:bold">Exercice </span>: toujours pour <span style="font-style:italic">y</span>′=<span style="font-style:italic">y</span>(1−<span style="font-style:italic">y</span>) que se passe-t-il pour une
condition initiale <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>)&gt;1 ?</p>
<!--TOC subsection id="sec116" Quelques méthodes de résolution explicite.-->
<h3 id="sec116" class="subsection">14.3  Quelques méthodes de résolution explicite.</h3><!--SEC END -->
<!--TOC subsubsection id="sec117" Équations à variables
séparables-->
<h4 id="sec117" class="subsubsection">14.3.1  Équations à variables
séparables</h4><!--SEC END --><p><a id="hevea_default139"></a><a id="hevea_default140"></a>
Si on peut factoriser <span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>,<span style="font-style:italic">t</span>) en termes ne dépendant que
de <span style="font-style:italic">y</span> ou ne dépendant que de <span style="font-style:italic">t</span>, on dit que l’équation
est à variable séparable, et on intègre
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>′=<span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>,<span style="font-style:italic">t</span>)=<span style="font-style:italic">g</span>(<span style="font-style:italic">t</span>)<span style="font-style:italic">h</span>(<span style="font-style:italic">y</span>) ⇒ </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span>(<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><span style="font-style:italic">g</span>(<span style="font-style:italic">t</span>) 
<span style="font-style:italic">dt</span></td></tr>
</table><p>
On obtient une équation implicite de la forme <span style="font-style:italic">H</span>(<span style="font-style:italic">y</span>)=<span style="font-style:italic">G</span>(<span style="font-style:italic">t</span>)+<span style="font-style:italic">C</span> où
<span style="font-style:italic">G</span> est une primitive de <span style="font-style:italic">g</span>, <span style="font-style:italic">H</span> de 1/<span style="font-style:italic">h</span> et <span style="font-style:italic">C</span> une constante
arbitraire. Dans les cas favorables, on peut exprimer <span style="font-style:italic">y</span> en fonction
de <span style="font-style:italic">t</span> (par exemple si l’équation est linéaire sans second membre,
on a <span style="font-style:italic">h</span>(<span style="font-style:italic">y</span>)=<span style="font-style:italic">y</span> donc <span style="font-style:italic">H</span> est le log que l’on sait
inverser). Dans les cas moins favorables, on peut exprimer <span style="font-style:italic">y</span> et
<span style="font-style:italic">t</span> en fonction d’un paramètre <span style="font-style:italic">u</span> : la courbe intégrale est
une courbe paramétrée. Dans les cas défavorables, on reste
sous forme implicite.</p><p><span style="font-weight:bold">Exercice </span>: résoudre explicitement l’équation <span style="font-style:italic">y</span>′=<span style="font-style:italic">y</span>(1−<span style="font-style:italic">y</span>)
et retrouver les résultats qualitatifs de la section précédente.</p>
<!--TOC subsubsection id="sec118" Équations linéaires-->
<h4 id="sec118" class="subsubsection">14.3.2  Équations linéaires</h4><!--SEC END --><p><a id="hevea_default141"></a><a id="hevea_default142"></a>
On commence par résoudre l’équation sans second membre
(aussi appelée homogène)
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">t</span>) <span style="font-style:italic">y</span><sup>[<span style="font-style:italic">n</span>]</sup> +...+<span style="font-style:italic">a</span><sub>1</sub>(<span style="font-style:italic">t</span>)<span style="font-style:italic">y</span>′+<span style="font-style:italic">a</span><sub>0</sub>(<span style="font-style:italic">t</span>)=0</td></tr>
</table><p>
L’ensemble
des solutions est un espace vectoriel (car l’équation
est linéaire) et de dimension l’ordre de
l’équation : pour le prouver on peut appliquer le théorème
de Cauchy-Lipschitz au système d’ordre 1 équivalent, ce
système est tel que <span style="font-style:italic">y</span> est un vecteur de ℝ<sup><span style="font-style:italic">n</span></sup>, on a ensuite
un isomorphisme entre les solutions et la condition initiale.</p><p>Si l’ordre est 1, on a une équation à variables séparables
 <span style="font-style:italic">y</span>′/<span style="font-style:italic">y</span>=−<span style="font-style:italic">a</span><sub>0</sub>(<span style="font-style:italic">t</span>)/<span style="font-style:italic">a</span><sub>1</sub>(<span style="font-style:italic">t</span>) et la solution est une exponentielle :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">Ce</span></td><td class="dcell"><table class="display"><tr><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">−</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub>0</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub>1</sub></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span></td></tr>
</table></td></tr>
<tr><td class="dcell">&nbsp;</td></tr>
</table></td></tr>
</table><p>
<span style="font-weight:bold">Exemple</span> : <span style="font-style:italic">y</span>′−<span style="font-style:italic">ty</span>=0, on a <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">Ce</span><sup>∫<span style="font-style:italic">t</span>  <span style="font-style:italic">dt</span></sup>=<span style="font-style:italic">Ce</span><sup><span style="font-style:italic">t</span><sup>2</sup>/2</sup></p><p>Si l’ordre est plus grand que 1, on n’a en général pas de solution
explicitable avec les fonctions usuelles et des primitives, 
pour certaines équations importantes en physique, 
des fonctions spéciales
ont été créées pour exprimer les solutions, par
exemple les fonctions de Bessel. Il existe quelques
cas particuliers où le calcul explicite est possible, dont
le cas où les coefficients sont constants (section suivante).
Si on connait une solution <span style="font-style:italic">w</span> d’une équation linéaire, alors 
en posant <span style="font-style:italic">y</span>=<span style="font-style:italic">wz</span>, la fonction <span style="font-style:italic">z</span>′ vérifie une équation linéaire
d’ordre un de moins, ainsi si on connait une solution d’une équation
linéaire d’ordre 2, on peut la résoudre complètement.</p><p>Le calcul d’une solution particulière 
d’une équation linéaire avec second
membre se fait en faisant varier les constantes d’intégration :
on prend la forme générale de la solution de l’équation
homogène,
on remplace les constantes d’intégration par des fonctions inconnues,
on remplace dans l’équation avec second membre et on
résoud en les fonctions inconnues.
La solution générale est la somme d’une solution particulière
et de la solution générale de l’équation sans second membre.</p><p><span style="font-weight:bold">Exemple </span>: <span style="font-style:italic">y</span>′−<span style="font-style:italic">ty</span>=−<span style="font-style:italic">t</span>, solution générale de l’équation
homogène <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">Ce</span><sup><span style="font-style:italic">t</span><sup>2</sup>/2</sup>, variation de la constante
on remplace <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">C</span>(<span style="font-style:italic">t</span>)<span style="font-style:italic">e</span><sup><span style="font-style:italic">t</span><sup>2</sup>/2</sup> dans <span style="font-style:italic">y</span>′−<span style="font-style:italic">ty</span>=−<span style="font-style:italic">t</span> et on obtient
<span style="font-style:italic">C</span>′ <span style="font-style:italic">e</span><sup><span style="font-style:italic">t</span><sup>2</sup>/2</sup>=−<span style="font-style:italic">t</span>, donc <span style="font-style:italic">C</span>′=−<span style="font-style:italic">te</span><sup>−<span style="font-style:italic">t</span><sup>2</sup>/2</sup> et <span style="font-style:italic">C</span>=<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span><sup>2</sup>/2</sup>+<span style="font-style:italic">K</span>,
d’où la solution générale <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=(<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span><sup>2</sup>/2</sup>+<span style="font-style:italic">K</span>)<span style="font-style:italic">e</span><sup><span style="font-style:italic">t</span><sup>2</sup>/2</sup>=1+<span style="font-style:italic">Ke</span><sup><span style="font-style:italic">t</span><sup>2</sup>/2</sup>.</p>
<!--TOC subsubsection id="sec119" Équations linéaires à coefficients constants-->
<h4 id="sec119" class="subsubsection">14.3.3  Équations linéaires à coefficients constants</h4><!--SEC END --><p>
On peut chercher des solutions de l’équation sans second membre
sous la forme d’exponentielles
<span style="font-style:italic">e</span><sup><span style="font-style:italic">rt</span></sup>, <span style="font-style:italic">r</span> doit alors vérifier une équation polynomiale <span style="font-style:italic">P</span>(<span style="font-style:italic">r</span>)=0
appelée <span style="font-weight:bold">équation caractéristique</span><a id="hevea_default143"></a><a id="hevea_default144"></a>,
de degré le degré de l’équation différentielle. 
Plus précisément, si on remplace <span style="font-style:italic">e</span><sup><span style="font-style:italic">rt</span></sup> dans
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">y</span><sup>[<span style="font-style:italic">n</span>]</sup>+...+<span style="font-style:italic">a</span><sub>1</sub> <span style="font-style:italic">y</span>′+<span style="font-style:italic">a</span><sub>0</sub><span style="font-style:italic">y</span>=0</td></tr>
</table><p> alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">r</span><sup><span style="font-style:italic">n</span></sup> +...+<span style="font-style:italic">a</span><sub>1</sub><span style="font-style:italic">r</span> +<span style="font-style:italic">a</span><sub>0</sub>=<span style="font-style:italic">P</span>(<span style="font-style:italic">r</span>)=0</td></tr>
</table><p>
Si <span style="font-style:italic">P</span> n’a que des racines simples <span style="font-style:italic">r</span><sub>1</sub>,...,<span style="font-style:italic">r</span><sub><span style="font-style:italic">n</span></sub> ∈ ℂ, 
l’ensemble des solutions
est alors l’espace vectoriel engendré par 
{ <span style="font-style:italic">e</span><sup><span style="font-style:italic">r</span><sub>1</sub><span style="font-style:italic">t</span></sup>, ... , <span style="font-style:italic">e</span><sup><span style="font-style:italic">r</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">t</span></sup> }.
En effet, on a le bon nombre
d’éléments (<span style="font-style:italic">n</span>), il suffit donc de montrer 
qu’il s’agit d’une famille libre. Cela se fait
par récurrence. Au rang <span style="font-style:italic">n</span>=1 c’est évident.
Si <span style="font-style:italic">n</span>&gt;1 et si (λ<sub>1</sub>,...,λ<sub><span style="font-style:italic">n</span></sub>) vérifient :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> λ<sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">e</span><sup><span style="font-style:italic">r</span><sub><span style="font-style:italic">j</span></sub><span style="font-style:italic">t</span></sup> = 0</td></tr>
</table><p>
on factorise <span style="font-style:italic">e</span><sup><span style="font-style:italic">r</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">t</span></sup> et on dérive, on a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> λ<sub><span style="font-style:italic">j</span></sub> (<span style="font-style:italic">r</span><sub><span style="font-style:italic">j</span></sub>−<span style="font-style:italic">r</span><sub><span style="font-style:italic">n</span></sub>) <span style="font-style:italic">e</span><sup>(<span style="font-style:italic">r</span><sub><span style="font-style:italic">j</span></sub>−<span style="font-style:italic">r</span><sub><span style="font-style:italic">n</span></sub>)<span style="font-style:italic">t</span></sup> =0 </td></tr>
</table><p>
on est ramené à l’identité précédente au rang <span style="font-style:italic">n</span>−1
donc par récurrence, λ<sub><span style="font-style:italic">j</span></sub> (<span style="font-style:italic">r</span><sub><span style="font-style:italic">j</span></sub>−<span style="font-style:italic">r</span><sub><span style="font-style:italic">n</span></sub>)=0 et λ<sub><span style="font-style:italic">j</span></sub>=0
si <span style="font-style:italic">j</span> ≠ <span style="font-style:italic">n</span>, puis λ<sub><span style="font-style:italic">n</span></sub>=0 avec la relation du départ.</p><p>Si <span style="font-style:italic">P</span> a des racines multiples, on peut montrer que pour chaque
racine <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub> de multiplicité <span style="font-style:italic">m</span>&gt;1, il faut rajouter
{ <span style="font-style:italic">te</span><sup><span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">t</span></sup>, ..., <span style="font-style:italic">t</span><sup><span style="font-style:italic">m</span>−1</sup> <span style="font-style:italic">e</span><sup><span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">t</span></sup> } pour former une base
de solutions. En effet
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">ty</span>)<sup>[<span style="font-style:italic">j</span>]</sup> = <span style="font-style:italic">t</span> <span style="font-style:italic">y</span><sup>[<span style="font-style:italic">j</span>]</sup> + <span style="font-style:italic">j</span> <span style="font-style:italic">y</span><sup>[<span style="font-style:italic">j</span>−1]</sup></td></tr>
</table><p>
donc si <span style="font-style:italic">y</span> est solution de l’équation alors <span style="font-style:italic">ty</span> est encore solution
si :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">na</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">y</span><sup>[<span style="font-style:italic">n</span>−1]</sup> + (<span style="font-style:italic">n</span>−1)<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">y</span><sup>[<span style="font-style:italic">n</span>−2]</sup>+...+<span style="font-style:italic">a</span><sub>1</sub>=0</td></tr>
</table><p>
on reconnait l’équation différentielle linéaire à coefficients
constants dont l’équation caractéristique est <span style="font-style:italic">P</span>′.
L’indépendance linéaire de ces fonctions
se montre en faisant <span style="font-style:italic">t</span>=0 (on est ramené au cas précédent), 
puis en divisant par <span style="font-style:italic">t</span> et en faisant <span style="font-style:italic">t</span>=0, etc.</p><p>Si <span style="font-style:italic">P</span> est à coefficients réels et admet une racine non réelle
<span style="font-style:italic">z</span> alors <span style="text-decoration:overline"><span style="font-style:italic">z</span></span> est encore racine, on peut réécrire 
avec des fonctions trigonométriques
les combinaisons linéaires de <span style="font-style:italic">e</span><sup><span style="font-style:italic">zt</span></sup> et <span style="font-style:italic">e</span><sup><span style="text-decoration:overline"><span style="font-style:italic">z</span></span><span style="font-style:italic">t</span></sup> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(α + <span style="font-style:italic">i</span> β) <span style="font-style:italic">e</span><sup>(<span style="font-style:italic">a</span>+<span style="font-style:italic">ib</span>)<span style="font-style:italic">t</span></sup> + (α − <span style="font-style:italic">i</span> β)  <span style="font-style:italic">e</span><sup>(<span style="font-style:italic">a</span>−<span style="font-style:italic">ib</span>)<span style="font-style:italic">t</span></sup>
=  <span style="font-style:italic">e</span><sup><span style="font-style:italic">at</span></sup> ( 2 α cos(<span style="font-style:italic">bt</span>) − 2 β sin(<span style="font-style:italic">bt</span>) )</td></tr>
</table><p><span style="font-weight:bold">Exemples </span>: 
</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">y</span>′′+3<span style="font-style:italic">y</span>′−4<span style="font-style:italic">y</span>=0, équation caractéristique <span style="font-style:italic">r</span><sup>2</sup>+3<span style="font-style:italic">r</span>−4=0,
deux racines distinctes <span style="font-style:italic">r</span>=1, <span style="font-style:italic">r</span>=−4, donc <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=α <span style="font-style:italic">e</span><sup><span style="font-style:italic">t</span></sup>+β <span style="font-style:italic">e</span><sup>−4<span style="font-style:italic">t</span></sup>
</li><li class="li-itemize"><span style="font-style:italic">y</span>′′+2<span style="font-style:italic">y</span>′+<span style="font-style:italic">y</span>=0, équation caractéristique <span style="font-style:italic">r</span><sup>2</sup>+2<span style="font-style:italic">r</span>+1=0,
a une racine double <span style="font-style:italic">r</span>=−1, donc <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=α <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>+β <span style="font-style:italic">t</span> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>
</li><li class="li-itemize"><span style="font-style:italic">y</span>′′+2<span style="font-style:italic">y</span>′+2<span style="font-style:italic">y</span>=0, équation caractéristique <span style="font-style:italic">r</span><sup>2</sup>+2<span style="font-style:italic">r</span>+2=0,
deux racines conjuguées <span style="font-style:italic">r</span>=−1± <span style="font-style:italic">i</span>, donc
<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>(α cos(<span style="font-style:italic">t</span>)+β sin(<span style="font-style:italic">t</span>))
</li></ul><p>On peut trouver une solution particulière de l’équation avec
second membre comme dans le cas général (méthode de variation
des constantes). Si la solution générale est engendrée par
<span style="font-style:italic">y</span><sub>1</sub>,...,<span style="font-style:italic">y</span><sub><span style="font-style:italic">n</span></sub>, on pose :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=1</td></tr>
</table></td><td class="dcell"> λ<sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table><p>
On pose
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=1</td></tr>
</table></td><td class="dcell"> λ<sub><span style="font-style:italic">i</span></sub>′ <span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub>=0  ⇒  
<span style="font-style:italic">y</span>′=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=1</td></tr>
</table></td><td class="dcell"> λ<sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub>′</td></tr>
</table><p>
et ainsi de suite jusqu’à la dérivée d’ordre <span style="font-style:italic">n</span> de <span style="font-style:italic">y</span>, ces
<span style="font-style:italic">n</span>−1 équations et léquation différentielle donnent 
alors un système linéaire <span style="font-style:italic">n</span>,<span style="font-style:italic">n</span> en
les λ<sub><span style="font-style:italic">i</span></sub>′.</p><p>Pour des second membre combinaison linéaire
de termes <span style="font-style:italic">b</span>(<span style="font-style:italic">t</span>)<span style="font-style:italic">e</span><sup><span style="font-style:italic">rt</span></sup> avec <span style="font-style:italic">b</span> polynôme,
on peut chercher une solution particulière
combinaison linéaire de <span style="font-style:italic">a</span>(<span style="font-style:italic">t</span>)<span style="font-style:italic">e</span><sup><span style="font-style:italic">rt</span></sup> où <span style="font-style:italic">a</span> est de même
degré que <span style="font-style:italic">b</span> si <span style="font-style:italic">r</span> n’est pas racine de <span style="font-style:italic">P</span>, ou de degré le
degré de <span style="font-style:italic">b</span> plus la multiplicité de <span style="font-style:italic">r</span> comme racine de <span style="font-style:italic">P</span>.
On peut aussi utiliser la transformation de Laplace et son inverse.</p>
<!--TOC subsubsection id="sec120" Systèmes différentiels linéaires à coefficients
constants d’ordre 1.-->
<h4 id="sec120" class="subsubsection">14.3.4  Systèmes différentiels linéaires à coefficients
constants d’ordre 1.</h4><!--SEC END --><p><a id="hevea_default145"></a>
Il s’agit donc de systèmes de la forme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>′=<span style="font-style:italic">Ay</span>+<span style="font-style:italic">b</span>(<span style="font-style:italic">t</span>)</td></tr>
</table><p>
où <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)∈ ℝ<sup><span style="font-style:italic">n</span></sup>, <span style="font-style:italic">A</span> est une matrice carrée de taille <span style="font-style:italic">n</span> 
indépendante du temps, et <span style="font-style:italic">b</span>(<span style="font-style:italic">t</span>) ∈ ℝ<sup><span style="font-style:italic">n</span></sup>.</p><p>On commence par résoudre l’équation homogène <span style="font-style:italic">y</span>′=<span style="font-style:italic">Ay</span>.
Si la matrice <span style="font-style:italic">A</span> est diagonalisable, alors <span style="font-style:italic">A</span>=<span style="font-style:italic">PDP</span><sup>−1</sup> où
<span style="font-style:italic">D</span>=diag(<span style="font-style:italic">d</span><sub>1</sub>,...,<span style="font-style:italic">d</span><sub><span style="font-style:italic">n</span></sub>) est diagonale et <span style="font-style:italic">P</span> inversible, le système devient :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>′=<span style="font-style:italic">PDP</span><sup>−1</sup> <span style="font-style:italic">y</span></td></tr>
</table><p>
donc en posant <span style="font-style:italic">y</span>=<span style="font-style:italic">Pz</span>, on a (puisque <span style="font-style:italic">P</span> est indépendant du temps) :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">z</span>′=<span style="font-style:italic">Dz</span>    ⇔    <span style="font-style:italic">z</span><sub><span style="font-style:italic">k</span></sub>′=<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">z</span><sub><span style="font-style:italic">k</span></sub>,  <span style="font-style:italic">k</span>=1..<span style="font-style:italic">n</span></td></tr>
</table><p>
donc <span style="font-style:italic">z</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">e</span><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">t</span></sup>, puis la solution générale
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">P</span></td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">c</span><sub>1</sub> <span style="font-style:italic">e</span><sup><span style="font-style:italic">d</span><sub>1</sub><span style="font-style:italic">t</span></sup> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">e</span><sup><span style="font-style:italic">d</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">t</span></sup>
</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
Le calcul avec Xcas se fait en utilisant la commande <code>desolve</code>,
par exemple<br>
<code>desolve(y'=[[1,2],[2,1]]*y)</code><br>
ou avec conditions initiales<br>
<code>desolve([y'=[[1,2],[2,1]]*y,y(0)=[1,2]])</code><br>
On peut aussi utiliser la fonction <code>exp</code>
avec comme argument <span style="font-style:italic">At</span> (on généralise ainsi 
la notation <span style="font-style:italic">e</span><sup><span style="font-style:italic">at</span></sup> 
de la dimension 1), multiplié par la condition initiale :<br>
<code>exp([[1,2],[2,1]]*t)*[1,2]</code><br>
Les calculs intermédiaires pour diagonaliser la matrice <span style="font-style:italic">A</span> sont
exécutés par les commandes <code>eigenvals</code>, <code>eigenvects</code>,
<code>jordan</code>.</p><p>On peut ensuite calculer une solution particulière par la méthode
de variation des constantes, ou encore en résolvant 
<span style="font-style:italic">z</span>′=<span style="font-style:italic">Dz</span>+<span style="font-style:italic">P</span><sup>−1</sup><span style="font-style:italic">b</span>(<span style="font-style:italic">t</span>) composante par composante (ou par transformation
de Laplace). Avec Xcas,
il suffit d’ajouter le second membre dans la commande <code>desolve</code><br>
<code>desolve(y'=[[1,2],[2,1]]*y+[x,x+1])</code></p><p>Si la matrice <span style="font-style:italic">A</span> n’est pas diagonalisable (ce qui entraine
qu’elle a au moins une valeur propre de
multiplicité plus grande que 1), on peut alors
la trigonaliser, on se ramene à résoudre un système
triangulaire, ce qui revient à résoudre pour chaque
composante une équation
différentielle linéaire d’ordre 1 avec un éventuel 
second membre. </p><p><span style="font-weight:bold">Remarque </span>: il y a un lien avec la section
précédente. En effet une équation d’ordre <span style="font-style:italic">n</span> peut
s’écrire comme un système différentiel d’ordre 1,
on peut calculer le polynôme caractéristique de la matrice
on retrouve alors l’équation caractéristique. Inversement,
toute matrice <span style="font-style:italic">A</span> admet un polynôme <span style="font-style:italic">P</span>
annulateur tel que <span style="font-style:italic">P</span>(<span style="font-style:italic">A</span>)=0<sup><a id="text24" href="#note24">24</a></sup>,
le polynôme caractéristique de <span style="font-style:italic">A</span> est un polynôme annulateur
(théorème de Cayley-Hamilton).
Les composantes des solutions du système différentiel sont des 
solutions de l’équation différentielle dont l’équation
caractéristique est <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)=0. En effet :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">0=<span style="font-style:italic">P</span>(<span style="font-style:italic">A</span>)<span style="font-style:italic">y</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">A</span><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">y</span> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">y</span><sup>[<span style="font-style:italic">k</span>]</sup></td></tr>
</table><p><span style="font-weight:bold">Exemple en dimension 2.</span>
Soit <span style="font-style:italic">A</span>=(</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">b</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">c</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">d</span>
</td></tr>
</table><p>) . Si <span style="font-style:italic">b</span>=0 alors <span style="font-style:italic">y</span><sub>1</sub>′=<span style="font-style:italic">ay</span><sub>1</sub> on en déduit
<span style="font-style:italic">y</span><sub>1</sub> puis <span style="font-style:italic">y</span><sub>2</sub>. Supposons donc <span style="font-style:italic">b</span>≠ 0, alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">x</span><sup>2</sup> − <span style="font-style:italic">x</span> (<span style="font-style:italic">a</span>+<span style="font-style:italic">d</span>) +<span style="font-style:italic">a</span> <span style="font-style:italic">d</span>−<span style="font-style:italic">b</span> <span style="font-style:italic">c</span></td></tr>
</table><p>
(on peut vérifier que <span style="font-style:italic">P</span>(<span style="font-style:italic">A</span>)=0)
donc si <span style="font-style:italic">y</span>′=<span style="font-style:italic">Ay</span> alors 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span><sub>1</sub>′′−(<span style="font-style:italic">a</span>+<span style="font-style:italic">d</span>)<span style="font-style:italic">y</span><sub>1</sub>′+<span style="font-style:italic">ad</span>−<span style="font-style:italic">bc</span>=0</td></tr>
</table><p>
et <span style="font-style:italic">y</span><sub>2</sub> s’en déduit avec <span style="font-style:italic">y</span><sub>1</sub>′−<span style="font-style:italic">ay</span><sub>1</sub>=<span style="font-style:italic">by</span><sub>2</sub> (on peut du reste
partir de cette relation pour établir l’équation d’ordre 2
vérifiée par <span style="font-style:italic">y</span><sub>1</sub>). On peut ainsi
résoudre tous les systèmes de dimension 2, même
si la matrice <span style="font-style:italic">A</span> n’est pas diagonalisable.</p><p><span style="font-weight:bold">Exercice </span>: Résoudre de cette manière le système<br>
<code>desolve([y'=[[1,2],[2,1]]*y,y(0)=[1,2]])</code></p><p><span style="font-weight:bold">Remarque :</span> allure des courbes en dimension 2.<br>
Si on se place dans le repère propre (en prenant les vecteurs
propres comme vecteurs de base), et si <span style="font-style:italic">A</span> a deux valeurs
propres distinctes (<span style="font-style:italic">A</span> est alors diagonalisable),
alors chaque coordonnée suit une exponentielle, dans ce repère
<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=(α <span style="font-style:italic">e</span><sup><span style="font-style:italic">at</span></sup>, β <span style="font-style:italic">e</span><sup><span style="font-style:italic">bt</span></sup>) avec <span style="font-style:italic">a</span> ≠ <span style="font-style:italic">b</span>. Si <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span>
sont réels, l’une des exponentielles domine l’autre lorsque
<span style="font-style:italic">t</span>→ +∞ et c’est l’inverse lorsque <span style="font-style:italic">t</span>→
−∞, la courbe est donc asymptote aux directions propres.
Si <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> sont complexes conjugués de partie réelle non nulle, 
on a une spirale qui
tend vers 0 d’un coté et vers l’infini de l’autre (selon le signe
de la partie réelle). Si <span style="font-style:italic">A</span> est
symétrique, alors <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> sont réels, ce cas ne peut
pas se produire, de plus on peut choisir un repère propre
orthonormé, les courbes ressemblent à des hyperboles.
Ce sont des hyperboles si trace(<span style="font-style:italic">A</span>)=0 (la somme des valeurs
propres vaut 0 donc le produit des coordonnées dans
le repère propre vaut une constante),
ces hyperboles sont équilatères si <span style="font-style:italic">A</span> est symétrique.</p><p><span style="font-weight:bold">Remarque :</span>pour un système différentiel à coefficients
non constants, il n’existe pas de méthode générale de
résolution. Il arrive que dans certains cas particuliers,
on puisse résoudre le système, par exemple si on trouve
une matrice de passage indépendante du temps ramenant
le système à un système diagonal ou triangulaire :
un exemple avec
<span style="font-style:italic">A</span>=(</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">cc</span> 1+<span style="font-style:italic">t</span></td><td style="text-align:center;white-space:nowrap" >−<span style="font-style:italic">t</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−<span style="font-style:italic">t</span></td><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">t</span></td></tr>
</table><p>).
Ou si ∫<span style="font-style:italic">A</span>(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> commute avec <span style="font-style:italic">A</span>, on peut prendre 
exp(∫<span style="font-style:italic">A</span>(<span style="font-style:italic">t</span>)) comme solution.</p>
<!--TOC subsubsection id="sec121" Intégrales premières.-->
<h4 id="sec121" class="subsubsection">14.3.5  Intégrales premières.</h4><!--SEC END --><p><a id="hevea_default146"></a><a id="hevea_default147"></a>
Lorsqu’on ne sait pas résoudre explicitement une équation
ou un système différentiel, il peut arriver qu’on connaisse
une ou des constantes du mouvement en cinématique, appelées
aussi intégrales premières. </p><p>C’est le cas par exemple de
l’énergie totale (mécanique plus cinétique) pour des forces
conservatives. En dimension un, la connaissance de l’intégrale 
première énergie
totale permet de ramener l’équation fondamentale de la
dynamique d’ordre 2 à une équation
du premier ordre à variables séparables :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">m</span> <span style="font-style:italic">x</span>′<sup>2</sup>+ <span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">C</span> </td></tr>
</table><p>
En dimension plus grande, cela peut permettre de 
connaitre la forme de la courbe intégrale et même
parfois de résoudre complètement l’équation (cas du problème
à deux corps ci-dessous).</p><p>Autre exemple, la découverte d’un facteur 
intégrant pour la forme différentielle <span style="font-style:italic">Mdx</span>+<span style="font-style:italic">Ndy</span>
donne une intégrale première pour l’équation <span style="font-style:italic">dy</span>/<span style="font-style:italic">dx</span>=<span style="font-style:italic">M</span>/<span style="font-style:italic">N</span>,
en effet ω=φ(<span style="font-style:italic">Mdx</span>+<span style="font-style:italic">Ndy</span>)=<span style="font-style:italic">dV</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) est nul
sur une courbe intégrale, donc <span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)
est constant, les courbes intégrales sont donc 
les courbes de niveau de <span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>). Une équation à variables
séparables est un cas particulier, avec <span style="font-style:italic">M</span> ne dépendant que de
<span style="font-style:italic">x</span> et <span style="font-style:italic">N</span> de <span style="font-style:italic">y</span>.</p><p>Pour un système autonome, <span style="font-style:italic">E</span> est une intégrale première si
grad(<span style="font-style:italic">E</span>).<span style="font-style:italic">f</span>=0, en effet
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">E</span>(<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>))= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">E</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">y</span><sub><span style="font-style:italic">j</span></sub></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub></td></tr>
</table><p><span style="font-weight:bold">Problème à deux corps </span> 
Cas d’un point de ℝ<sup>3</sup>
soumis à une <span style="font-weight:bold">force centrale</span><a id="hevea_default148"></a><a id="hevea_default149"></a>
comme la gravité ou la force coulombienne :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">d</span><sup>2</sup> </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">r</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span><sup>2</sup></td></tr>
</table></td><td class="dcell">=−µ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">r</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span><sup>3</sup></td></tr>
</table></td></tr>
</table><p> 
on montre
</p><ul class="itemize"><li class="li-itemize">
la conservation du moment cinétique 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">L</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td><td class="dcell">=
</td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">r</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td><td class="dcell">∧ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">d</span> </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">r</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td></tr>
</table>
(vérification immédiate en dérivant).
Ceci entraine que
le mouvement est dans un plan orthogonal à 
<span style="font-style:italic">L</span>=<span style="font-style:italic">L</span><span style="font-style:italic">k</span>
et la loi des aires (où θ est l’angle formé par 
<span style="font-style:italic">r</span> avec une direction fixe du plan) :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">r</span><sup>2</sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>θ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">=<span style="font-style:italic">L</span></td></tr>
</table>
(ceci est vrai dès que la force est centrale, indépendamment
de la norme de la force)
</li><li class="li-itemize">la conservation du vecteur excentricité défini par :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">E</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td><td class="dcell">= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">µ</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">d</span></td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">r</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> ∧ 
</td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">L</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td><td class="dcell">− </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">r</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span></td></tr>
</table></td><td class="dcell"> 
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">L</span> </td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">µ</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">d</span></td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">r</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> ∧ 
</td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td><td class="dcell">− </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td></tr>
</table>
En effet <span style="font-style:italic">d</span> <span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub>/<span style="font-style:italic">dt</span>=<span style="font-style:italic">d</span>θ/<span style="font-style:italic">dt</span>
<span style="font-style:italic">e</span><sub>θ</sub> où { <span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub>,
<span style="font-style:italic">e</span><sub>θ</sub>, <span style="font-style:italic">k</span> } est orthonormé direct
et <span style="font-style:italic">L</span>=<span style="font-style:italic">r</span><sup>2</sup> <span style="font-style:italic">d</span>θ/<span style="font-style:italic">dt</span>.
</li></ul><p>
Si on prend l’axe des <span style="font-style:italic">x</span> porté par <span style="font-style:italic">E</span>,
en faisant le produit scalaire avec <span style="font-style:italic">r</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">rE</span> cos(θ)=</td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">r</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">E</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td><td class="dcell">
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">µ</td></tr>
</table></td><td class="dcell"> 
(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">d</span></td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">r</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> ∧ </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">L</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td><td class="dcell">) . </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell"   style="width:90%;text-align:center"><hr class="hbar"></td><td class="dcell"   style="width:10%;text-align:center">▸</td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"><span style="font-style:italic">r</span></td></tr>
<tr><td class="dcell"  colspan="2" style="text-align:center"> </td></tr>
</table></td><td class="dcell">− <span style="font-style:italic">r</span></td></tr>
</table><p>
on obtient en appliquant les propriétés du produit mixte et la
définition de <span style="font-style:italic">L</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">r</span> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">L</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">µ(1+<span style="font-style:italic">E</span> cos(θ))</td></tr>
</table></td></tr>
</table><p>
la courbe intégrale est donc une conique d’excentricité <span style="font-style:italic">E</span>
ayant l’origine pour foyer et parcourue selon la loi des aires
(l’aire balayée par le segment origine-point mobile est
proportionnelle au temps).</p>
<!--TOC subsubsection id="sec122" Quelques autres méthodes-->
<h4 id="sec122" class="subsubsection">14.3.6  Quelques autres méthodes</h4><!--SEC END --><p>
On peut encore citer : 
changement de fonction, changement de variables, 
équation homogène, équations de Bernoulli,
de Clairault, de Ricatti, développements en séries
entières..., certaines de ces méthodes sont
implémentées par les logiciels de calcul formel.</p>
<!--TOC subsection id="sec123" Comportement asymptotique des solutions-->
<h3 id="sec123" class="subsection">14.4  Comportement asymptotique des solutions</h3><!--SEC END --><p>
Les équations de la physique sont souvent des équations
autonomes sans second membre (pas de dépendance explicite en temps) 
ou avec un second membre
qui est le seul terme de l’équation dépendant du temps (il
s’agit d’un forçage extérieur). Dans le premier cas,
les solutions doivent rester bornées (par exemple en énergie), donc
ne peuvent pas tendre vers l’infini. Dans le second cas,
une question naturelle
est alors la suivante : le système atteint-il un équilibre,
peut-on décomposer la solution en deux parties : un régime
permanent et un régime transitoire ?</p><p>On a déjà fait une étude de comportement asymptotique
pour l’équation <span style="font-style:italic">y</span>′=<span style="font-style:italic">y</span>(1−<span style="font-style:italic">y</span>), la solution <span style="font-style:italic">y</span>=0 se comporte
comme un point déquilibre instable, si on en dévie même
légèrement, on s’en éloigne définitivement, alors que <span style="font-style:italic">y</span>=1 se
comporte comme un point déquilibre stable.
Nous allons généraliser cette étude, pour les équations
linéaires à coefficients constants (avec ou sans second membre,
perturbation dépendant du temps),
les équations autonomes sans second membre,
et dans le cas de systèmes différentiels linéaires à
coefficients constants.</p>
<!--TOC subsubsection id="sec124" Équations linéaires à coefficients constants 
d’ordre 1 et 2-->
<h4 id="sec124" class="subsubsection">14.4.1  Équations linéaires à coefficients constants 
d’ordre 1 et 2</h4><!--SEC END --><p>
Pour les équations homogènes d’ordre 1 <span style="font-style:italic">y</span>′+<span style="font-style:italic">ay</span>=0, 
la solution générale est <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">Ce</span><sup>−<span style="font-style:italic">at</span></sup>, le comportement
asymptotique lorsque <span style="font-style:italic">t</span> → +∞ dépend du signe
de <span style="font-style:italic">a</span>, si <span style="font-style:italic">a</span>&gt;0 la limite est 0 et la solution décroit
exponentiellement vite. Donc si <span style="font-style:italic">a</span>&gt;0, quelle
que soit la condition initiale, toutes les solutions de 
l’équation avec second membre <span style="font-style:italic">y</span>′+<span style="font-style:italic">ay</span>=<span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>) ont
le même comportement asymptotique, celui
d’une solution particulière de l’équation :on a donc
un régime transitoire exponentiellement décroissant
et un régime permanent.</p><p>Pour les équations homogènes d’ordre 2 <span style="font-style:italic">ay</span>′′+<span style="font-style:italic">by</span>′+<span style="font-style:italic">cy</span>=0,
la solution générale est <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">Ae</span><sup><span style="font-style:italic">r</span><sub>1</sub><span style="font-style:italic">t</span></sup>+<span style="font-style:italic">Be</span><sup><span style="font-style:italic">r</span><sub>2</sub><span style="font-style:italic">t</span></sup>
si <span style="font-style:italic">r</span><sub>1</sub> et <span style="font-style:italic">r</span><sub>2</sub> sont les deux racines simples de <span style="font-style:italic">ar</span><sup>2</sup>+<span style="font-style:italic">br</span>+<span style="font-style:italic">c</span>=0
ou <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">e</span><sup><span style="font-style:italic">r</span><sub>1</sub><span style="font-style:italic">t</span></sup>(<span style="font-style:italic">A</span>+<span style="font-style:italic">Bt</span>) si l’équation caractéristique admet
une racine double. Le comportement à l’infini dépend
du signe de la partie réelle de <span style="font-style:italic">r</span><sub>1</sub> et <span style="font-style:italic">r</span><sub>2</sub>. Il faut que
les deux parties réelles soient strictement négatives pour que 
la solution tende vers 0, à vitesse exponentielle, si l’une au moins
des parties réelles est positive ou nulle, alors il n’y a pas
convergence vers 0. Plus précisément
</p><ul class="itemize"><li class="li-itemize">
Si Δ=<span style="font-style:italic">b</span><sup>2</sup>−4<span style="font-style:italic">ac</span>&lt;0, il y a deux racines complexes
conjuguées distinctes de partie réelle −<span style="font-style:italic">b</span>/(2<span style="font-style:italic">a</span>), donc la
solution décroit exponentiellement vers 0 si <span style="font-style:italic">b</span>/<span style="font-style:italic">a</span>&gt;0,
comme <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">b</span>/(2<span style="font-style:italic">a</span>)<span style="font-style:italic">t</span></sup>, avec des oscillations périodiques
en <span style="font-style:italic">e</span><sup><span style="font-style:italic">i</span>√<span style="text-decoration:overline">−Δ</span>/(2<span style="font-style:italic">a</span>)<span style="font-style:italic">t</span></sup>, de période <span style="font-style:italic">T</span>=4π
<span style="font-style:italic">a</span>/√<span style="text-decoration:overline">−Δ</span> (régime oscillatoire amorti enveloppé
par <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">b</span>/(2<span style="font-style:italic">a</span>)<span style="font-style:italic">t</span></sup>). 
Si <span style="font-style:italic">b</span>=0, la solution ne tend pas vers 0, reste de taille bornée,
elle est périodique de période <span style="font-style:italic">T</span>=4π <span style="font-style:italic">a</span>/√<span style="text-decoration:overline">−Δ</span>
(régime oscillatoire)
</li><li class="li-itemize">Si Δ=<span style="font-style:italic">b</span><sup>2</sup>−4<span style="font-style:italic">ac</span>&gt;0, on a deux racines réelles distinctes,
qui sont toutes les deux strictement négatives si l’opposé de
leur somme et leur produit sont positifs : <span style="font-style:italic">b</span>/<span style="font-style:italic">a</span>&gt;0, <span style="font-style:italic">c</span>/<span style="font-style:italic">a</span>&gt;0
(régime amorti équivalent à la plus grande des deux
exponentielles)
</li><li class="li-itemize">Si Δ=<span style="font-style:italic">b</span><sup>2</sup>−4<span style="font-style:italic">ac</span>=0, on a une racine double −<span style="font-style:italic">b</span>/(2<span style="font-style:italic">a</span>),
il y a convergence vers 0 si <span style="font-style:italic">b</span>/<span style="font-style:italic">a</span>&gt;0.
</li><li class="li-itemize">Dans tous les autres cas, la partie réelle d’une
des racines est positive ou nulle et il n’y a pas de convergence
vers 0 de la solution générale. Si on a deux racines
imaginaires pures conjuguées, la solution est périodique,
sinon la solution tend vers l’infini pour une condition initiale
générique.
</li></ul><p><span style="font-weight:bold">Exemples </span>
</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">y</span>′′+<span style="font-style:italic">y</span>=0, deux racines imaginaires pures conjuguées,
solution générale <span style="font-style:italic">a</span>sin(<span style="font-style:italic">x</span>)+<span style="font-style:italic">b</span>cos(<span style="font-style:italic">x</span>) périodique
</li><li class="li-itemize"><span style="font-style:italic">y</span>′′+<span style="font-style:italic">y</span>′+<span style="font-style:italic">y</span>=0, deux racines complexes conjuguées de partie
réelle négative, il y a convergence exponentielle vers 0 avec
des oscillations, la
solution générale est <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">x</span>/2</sup>(<span style="font-style:italic">a</span> cos(√<span style="text-decoration:overline">3</span><span style="font-style:italic">x</span>/2) + <span style="font-style:italic">b</span>
sin(√<span style="text-decoration:overline">3</span><span style="font-style:italic">x</span>/2)).
</li><li class="li-itemize"><span style="font-style:italic">y</span>′′−2<span style="font-style:italic">y</span>′−3<span style="font-style:italic">y</span>=0, deux racines réelles, une positive, une
négative. La solution générale est <span style="font-style:italic">ae</span><sup><span style="font-style:italic">x</span></sup>+<span style="font-style:italic">be</span><sup>−3<span style="font-style:italic">x</span></sup>, elle
tend génériquement vers l’infini (sauf condition initiale annulant
<span style="font-style:italic">a</span>).
</li><li class="li-itemize">...
</li></ul><p>On peut généraliser à un ordre quelconque.
Si toutes les racines de l’équation caractéristique sont
de partie réelle négative, la solution générale
de l’équation homogène tend vers 0 à l’infini,
elle est appelée régime transitoire. Quelle que
soit la condition initiale, on tend vers la solution particulière
appelée régime permanent.</p>
<!--TOC subsubsection id="sec125" Forçage périodique-->
<h4 id="sec125" class="subsubsection">14.4.2  Forçage périodique</h4><!--SEC END --><p><a id="hevea_default150"></a>
Il arrive souvent qu’un système physique soit soumis à
un forçage extérieur périodique, par exemple
pour la température à échelle fine, l’alternance jour-nuit,
ou à grande échelle, l’alternance des saisons, ou
circuit RCL soumis à un courant périodique. Il est donc
utile de déterminer les caractéristiques de la solution
en régime permanent.</p><p>Exemple : ordre 1
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>′+<span style="font-style:italic">ay</span>=<span style="font-style:italic">A</span> <span style="font-style:italic">e</span><sup><span style="font-style:italic">i</span>ω <span style="font-style:italic">t</span></sup>,    <span style="font-style:italic">a</span>&gt;0</td></tr>
</table><p>
On sait qu’une solution particulière est donnée par
 <span style="font-style:italic">B</span> <span style="font-style:italic">e</span><sup><span style="font-style:italic">i</span> ω <span style="font-style:italic">t</span></sup>, on remplace et on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">B</span>(<span style="font-style:italic">i</span>ω +<span style="font-style:italic">a</span>)=<span style="font-style:italic">A</span> ⇒ <span style="font-style:italic">B</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>+<span style="font-style:italic">i</span>ω</td></tr>
</table></td></tr>
</table><p>
L’amplitude de la solution particulière est donc l’amplitude
du second membre divisée par le module 
|<span style="font-style:italic">a</span>+<span style="font-style:italic">i</span>ω|=√<span style="text-decoration:overline"><span style="font-style:italic">a</span></span><sup><span style="text-decoration:overline">2</span></sup><span style="text-decoration:overline">+ω</span><sup><span style="text-decoration:overline">2</span></sup>, et l’exponentielle subit
un déphasage donné par l’argument de <span style="font-style:italic">B</span> soit
−arctan(ω/<span style="font-style:italic">a</span>) ∈ ]−π/2,0[. La solution
particulière suit donc le second membre, avec un déphasage
compris entre 0 et un quart de période, selon la valeur de <span style="font-style:italic">a</span>.
Si le système a une forte inertie intrinsèque (<span style="font-style:italic">a</span> petit
pour avoir une exponentielle décroissant lentement), on s’approche
du quart de période, c’est pour cette raison que la température
près de la mer atteint son maximum en été environ 2 mois
après le solstice, alors que dans les terres, c’est plutot 3
semaines après (le maximum d’un quart de période
étant presque réalisé par la banquise qui atteint son
minimum d’extend presque 3 mois après le solstice).</p><p>À l’ordre 2, on peut faire la même étude, cette fois l’amplitude
est divisée par
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|−<span style="font-style:italic">a</span>ω<sup>2</sup>+<span style="font-style:italic">ib</span>ω+<span style="font-style:italic">c</span>|
=</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <span style="font-style:italic">b</span><sup>2</sup>ω<sup>2</sup>+(<span style="font-style:italic">a</span>ω<sup>2</sup>−<span style="font-style:italic">c</span>)<sup>2</sup></td></tr>
</table></td><td class="dcell">
=ω<sup>2</sup> </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> <span style="font-style:italic">b</span><sup>2</sup>+(<span style="font-style:italic">a</span>ω−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">c</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ω</td></tr>
</table></td><td class="dcell">)<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table>
<!--TOC subsubsection id="sec126" Équation autonome sans second membre-->
<h4 id="sec126" class="subsubsection">14.4.3  Équation autonome sans second membre</h4><!--SEC END --><p><a id="hevea_default151"></a>
Il s’agit d’une équation de la forme <span style="font-style:italic">y</span>′=<span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>) où on
suppose <span style="font-style:italic">f</span> continument dérivable. Les solutions
stationnaires sont données par les racines de <span style="font-style:italic">f</span> (les
<span style="font-style:italic">r</span> telles que <span style="font-style:italic">f</span>(<span style="font-style:italic">r</span>)=0). Pour toute condition initiale entre
deux racines consécutive de <span style="font-style:italic">f</span>, la solution va rester entre
ces deux racines consécutives. Comme <span style="font-style:italic">f</span> ne s’annule pas
entre deux racines consécutives, <span style="font-style:italic">f</span> est de signe constant
donc la solution est monotone,
et tend vers une des racines lorsque <span style="font-style:italic">t</span> → ± ∞
<sup><a id="text25" href="#note25">25</a></sup>.
Si <span style="font-style:italic">f</span>&gt;0, on tend vers la plus grande des racines lorsque <span style="font-style:italic">t</span>
→ +∞, sinon vers la plus petite. Si la condition 
initiale est au-delà de la plus grande racine ou en-deça
de la plus petite racine, on tend soit vers l’infini, soit vers la racines.</p><p>On peut préciser
la vitesse de convergence. Si <span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>)=<span style="font-style:italic">c</span>(<span style="font-style:italic">y</span>−<span style="font-style:italic">r</span>), <span style="font-style:italic">c</span>&lt;0, (<span style="font-style:italic">f</span> linéaire)
la convergence vers <span style="font-style:italic">r</span> se fait comme <span style="font-style:italic">e</span><sup><span style="font-style:italic">ct</span></sup> pour <span style="font-style:italic">t</span> →
+∞. Dans le cas
général, si <span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span>) ≠ 0, 
ce résultat est encore valable, heuristiquement :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>)=(<span style="font-style:italic">y</span>−<span style="font-style:italic">r</span>)(<span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span>)+<span style="font-style:italic">o</span>(1)) ⇒ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell">=
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span>)(<span style="font-style:italic">y</span>−<span style="font-style:italic">r</span>)</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">o</span>(1)</td></tr>
</table></td><td class="dcell">
=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span>)(<span style="font-style:italic">y</span>−<span style="font-style:italic">r</span>)</td></tr>
</table></td><td class="dcell">(1 + <span style="font-style:italic">o</span>(1))</td></tr>
</table><p>
où <span style="font-style:italic">o</span>(1) est une fonction qui tend vers 0 lorsque <span style="font-style:italic">y</span> tend vers
<span style="font-style:italic">r</span>, donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span>)(<span style="font-style:italic">y</span>−<span style="font-style:italic">r</span>)</td></tr>
</table></td><td class="dcell">(1 + <span style="font-style:italic">o</span>(1)) <span style="font-style:italic">dy</span> 
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ln|<span style="font-style:italic">y</span>−<span style="font-style:italic">r</span>|</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span>)</td></tr>
</table></td><td class="dcell"> (1 + <span style="font-style:italic">o</span>(1)) = </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"> <span style="font-style:italic">dt</span> = <span style="font-style:italic">t</span>+<span style="font-style:italic">K</span>  </td></tr>
</table><p>
d’où le résultat (pour une justification plus rigoureuse
il faut appliquer le théorème des fonctions implicites
pour déterminer <span style="font-style:italic">y</span> et vérifier que <span style="font-style:italic">o</span>(1) s’intègre).</p><div class="theorem"><span style="font-weight:bold">Théorème 27</span>  <em>
On considère l’équation différentielle </em><span style="font-style:italic">y</span>′=<span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>)<em> où
</em><span style="font-style:italic">f</span><em> est continument dérivable, et a des racines réelles
classées par ordre croissant </em>...,<span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub>,...<em>. Si la condition
initiale </em><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>)<em> est
située entre deux racines, la solution est monotone entre
ces deux racines et tend vers une des racines lorsque </em><span style="font-style:italic">t</span>→
± ∞<em>. Si </em><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>)<em> est situé au-delà de la dernière racine
ou en-decà de la première racine (si elles existent), 
la solution est monotone et
tend vers cette racine lorsque </em><span style="font-style:italic">t</span>→ ± ∞<em>
ou diverge (en temps fini ou infini).</em><p><em>Si </em><span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub>) &lt; 0<em>, la solution </em><span style="font-style:italic">y</span>=<span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub><em> est appelée équilibre
stable : pour toute condition initiale situé entre </em><span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>−1</sub><em> et </em><span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+1</sub><em>
la solution tend vers </em><span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub><em> lorsque </em><span style="font-style:italic">t</span> → +∞<em> 
et la convergence se fait à vitesse
exponentielle, comme </em><span style="font-style:italic">Ce</span><sup><span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub>)<span style="font-style:italic">t</span>(1+<span style="font-style:italic">o</span>(1))</sup><em>.
</em></p></div><p><span style="font-weight:bold">Exemple </span>: pour l’équation logistique <span style="font-style:italic">y</span>′=<span style="font-style:italic">y</span>(1−<span style="font-style:italic">y</span>),
<span style="font-style:italic">f</span>(<span style="font-style:italic">r</span>)=<span style="font-style:italic">r</span>(1−<span style="font-style:italic">r</span>)=<span style="font-style:italic">r</span>−<span style="font-style:italic">r</span><sup>2</sup>, <span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span>)=1−2<span style="font-style:italic">r</span>, 
il y a deux équilibres <span style="font-style:italic">r</span><sub>0</sub>=0 et <span style="font-style:italic">r</span><sub>1</sub>=1, avec <span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span><sub>0</sub>)=1&gt;0
et <span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span><sub>1</sub>)=−1&lt;0 donc un équilibre stable en 1, et un équilibre
instable en 0.</p>
<!--TOC subsubsection id="sec127" Systèmes linéaires-->
<h4 id="sec127" class="subsubsection">14.4.4  Systèmes linéaires</h4><!--SEC END --><p><a id="hevea_default152"></a>
<span style="font-weight:bold">Cas linéaire</span><br>
L’évolution du système est gouvernée par les valeurs propres
de la matrice <span style="font-style:italic">A</span> du système, exactement comme pour les équations
linéaires où ce sont les racines de l’équation
caractéristique.
La solution générale tend vers 0 si toutes les valeurs propres
ont une partie réelle strictement négative. S’il y a des paires
de valeurs propres conjuguées de partie réelle négative,
des phénomènes cycliques amortis apparaissent.
Si les valeurs propres sont négatives ou nulles mais distinctes, la solution
reste bornée (avec des composantes qui peuvent être
périodiques).
Si une des valeurs propres a une partie réelle strictement positive,
alors pour une condition initiale générique, la solution tend vers
l’infini.</p><p><span style="font-weight:bold">Exemples </span>
</p><ul class="itemize"><li class="li-itemize">
<code>[Y]:=desolve([y'=A*y,y(0)=[1,0,0]])</code> pour<br>
<code>A:=[[1,2,3],[4,5,6],[7,8,9]]</code>, 
puis <code>plot(Y[0],x=0..4)</code> la solution tend vers l’infini,
à vitesse exponentielle comme on peut
le voir avec <code>plot(ln(Y[0]),x=0..4)</code>.
En effet 16.12... est valeur propre de <span style="font-style:italic">A</span>
(<code>eigenvalues(approx(A))</code>). On observe le même
comportement en remplaçant <span style="font-style:italic">A</span> par −<span style="font-style:italic">A</span> (ceci
diffère de la dimension 1, où en changeant le sens
du temps une solution divergente devient convergente).
On peut représenter le graphe de la courbe décrite
dans l’espace par exemple avec <code>plotparam(Y,x=0..2)</code>
</li><li class="li-itemize"><code>[Y]:=desolve([y'=A*y,y(0)=[1,0]])</code> pour 
<code>A:=[[-3,1],[1,-5]]</code>, la courbe dans le plan est
obtenue par <code>plotparam(Y,x=0..10)</code>, en faisant
plusieurs zoom out, on voit la courbe partir de la condition
initiale le point (1,0) et aboutir (presque) en l’origine.
Les valeurs propres sont en effet −4± √<span style="text-decoration:overline">2</span>&lt;0.
</li><li class="li-itemize">Même chose avec <code>A:=[[-1,2],[-2,-1]];</code>.
La courbe part toujours du point (1,0) pour
aboutir presque en l’origine, cette fois en spiralant
(car les valeurs propres sont complexes conjuguées)
</li><li class="li-itemize">Pour <code>A:=[[0,2],[-2,0]];</code>, les valeurs
propres sont imaginaires pures, la courbe est un cercle
décrite de manière périodique.
</li></ul><p><span style="font-weight:bold">Cas autonome</span><a id="hevea_default153"></a><br>
On ne sait pas intégrer un système <span style="font-style:italic">y</span>′=<span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>) sans plus
de précision sur <span style="font-style:italic">f</span> (ce n’est plus une équation à
variables séparables et il n’y a pas d’ordre dans ℝ<sup><span style="font-style:italic">n</span></sup>,
donc pas de monotonie des solutions à attendre).
On ne peut donc
espérer un résultat général que si la condition initiale 
est proche d’un point d’équilibre (une solution de <span style="font-style:italic">f</span>(<span style="font-style:italic">r</span>)=0).
Dans la plupart des cas, on peut conclure sur la stabilité
ou l’instabilité du point déquilibre en fonction de la partie
réelle des valeurs propres de <span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span>), un peu comme en dimension 1.
Si toutes les valeurs propres ont des parties strictement négative
on peut montrer que
le système revient à l’équilibre exponentiellement vite, si
l’une des parties réelles est strictement positive,
pour une condition initiale générique, le système s’en
éloigne, et s’il y a des parties réelles nulles, on ne peut pas
conclure.</p>
<!--TOC subsubsection id="sec128" Le modèle proie-prédateur-->
<h4 id="sec128" class="subsubsection">14.4.5  Le modèle proie-prédateur</h4><!--SEC END --><p>
<a id="hevea_default154"></a>
<a id="hevea_default155"></a>
C’est un système autonome en dimension 2 pour lequel on sait
calculer une intégrale première. Il se présente sous la forme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >ẋ</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">x</span>(<span style="font-style:italic">a</span>−<span style="font-style:italic">by</span>)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >ẏ</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >−<span style="font-style:italic">y</span>(<span style="font-style:italic">c</span>−<span style="font-style:italic">dx</span>)
</td></tr>
</table></td></tr>
</table><p>
avec <span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>,<span style="font-style:italic">c</span>,<span style="font-style:italic">d</span> des constantes positives, <span style="font-style:italic">x</span> l’effectif des proies,
<span style="font-style:italic">y</span> celui des prédateurs,
<span style="font-style:italic">a</span> correspond à la reproduction naturelle des proies, 
<span style="font-style:italic">b</span> à la mortalité par
rencontre d’un prédateur, <span style="font-style:italic">c</span> à la mortalité naturelle
des prédateurs et <span style="font-style:italic">d</span> à la natalité dépendant du nombre de
proies.
On peut déterminer les points d’équilibre et leur stabilité
comme pour n’importe quel système autonome (exercice),
on trouve (0,0) qui est instable et (<span style="font-style:italic">c</span>/<span style="font-style:italic">d</span>,<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>), les valeurs propres
du linéarisé 
sont 2 imaginaires purs conjugués, donc on ne peut pas conclure sur
la stabilité à ce stade.</p><p>On peut déterminer une intégrale première en faisant apparaitre
des dérivées logarthmiques
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">(ln(<span style="font-style:italic">x</span>))=<span style="font-style:italic">a</span>−<span style="font-style:italic">by</span>,    </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">(ln(<span style="font-style:italic">y</span>))=−<span style="font-style:italic">c</span>+<span style="font-style:italic">dx</span> </td></tr>
</table><p>
donc en posant <span style="font-style:italic">X</span>=ln(<span style="font-style:italic">x</span>), <span style="font-style:italic">Y</span>=ln(<span style="font-style:italic">y</span>) on a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">Ẋ=<span style="font-style:italic">a</span>−<span style="font-style:italic">be</span><sup><span style="font-style:italic">Y</span></sup>,    Ẏ=−<span style="font-style:italic">c</span>+<span style="font-style:italic">de</span><sup><span style="font-style:italic">X</span></sup></td></tr>
</table><p>
d’où :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">Ẋ (<span style="font-style:italic">de</span><sup><span style="font-style:italic">X</span></sup>−<span style="font-style:italic">c</span>) + Ẏ(<span style="font-style:italic">be</span><sup><span style="font-style:italic">Y</span></sup>−<span style="font-style:italic">a</span>)=0</td></tr>
</table><p>
donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">X</span>,<span style="font-style:italic">Y</span>)=<span style="font-style:italic">de</span><sup><span style="font-style:italic">X</span></sup>−<span style="font-style:italic">cX</span>+<span style="font-style:italic">be</span><sup><span style="font-style:italic">Y</span></sup>−<span style="font-style:italic">aY</span></td></tr>
</table><p>
est une intégrale première du mouvement, qui se passe donc sur
les courbes de niveau de <span style="font-style:italic">f</span> en (<span style="font-style:italic">X</span>,<span style="font-style:italic">Y</span>) ou de <span style="font-style:italic">dx</span>−<span style="font-style:italic">c</span>ln(<span style="font-style:italic">x</span>)+<span style="font-style:italic">by</span>−<span style="font-style:italic">a</span>ln(<span style="font-style:italic">y</span>)
en (<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>). On observe que ces courbes de niveau sont fermées, 
impliquant un mouvement périodique, si on exprime <span style="font-style:italic">y</span> en fonction
de <span style="font-style:italic">x</span> par le théorème des fonctions implicites donc sur toute la
courbe à l’exception des deux points <span style="font-style:italic">x</span><sub>±</sub> où la tangente est verticale
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">dx</span>−<span style="font-style:italic">c</span>ln(<span style="font-style:italic">x</span>)+<span style="font-style:italic">by</span>−<span style="font-style:italic">a</span>ln(<span style="font-style:italic">y</span>)=<span style="font-style:italic">K</span> ⇒ <span style="font-style:italic">y</span>=<span style="font-style:italic">y</span><sub>±</sub>(<span style="font-style:italic">x</span>)</td></tr>
</table><p>
alors on peut calculer la période du mouvement en appliquant :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>(<span style="font-style:italic">a</span>−<span style="font-style:italic">by</span>(<span style="font-style:italic">x</span>))</td></tr>
</table></td><td class="dcell">=<span style="font-style:italic">dt</span></td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">T</span>=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><span style="font-style:italic">dt</span> = </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span><sub>+</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span><sub>−</sub></td></tr>
</table></td><td class="dcell">  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>(<span style="font-style:italic">a</span>−<span style="font-style:italic">by</span><sub>+</sub>(<span style="font-style:italic">x</span>))</td></tr>
</table></td><td class="dcell">
+ </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span><sub>−</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span><sub>+</sub></td></tr>
</table></td><td class="dcell">  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>(<span style="font-style:italic">a</span>−<span style="font-style:italic">by</span><sub>−</sub>(<span style="font-style:italic">x</span>))</td></tr>
</table></td></tr>
</table>
<!--TOC subsubsection id="sec129" Forçage près d’un point d’équilibre de système.-->
<h4 id="sec129" class="subsubsection">14.4.6  Forçage près d’un point d’équilibre de système.</h4><!--SEC END --><p>
Si on ajoute un terme dépendant du temps <span style="font-style:italic">y</span>′=<span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>)+<span style="font-style:italic">g</span>(<span style="font-style:italic">t</span>),
on ne sait plus résoudre l’équation ni décrire
son comportement qualitatif en toute généralité. Si
la condition initiale est proche d’un équilibre stable, et si
la perturbation est “petite” (en tenant compte de l’échelle
de temps des exponentielles du système linéarisé)
on peut alors linéariser et espérer que
la solution se comporte comme la solution de
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>′=<span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub>)(<span style="font-style:italic">y</span>−<span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub>) + <span style="font-style:italic">g</span>(<span style="font-style:italic">t</span>)</td></tr>
</table><p>
au moins pendant un certain intervalle de temps.</p><p><span style="font-weight:bold">Exemple</span> : modèle couplé d’évolution température-CO2.<br>
On modélise l’évolution de la température
<span style="font-style:italic">T</span> de la Terre par
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dT</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> = <span style="font-style:italic">k</span> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">6 ln(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">CO</span>2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">280</td></tr>
</table></td><td class="dcell">) − σ (<span style="font-style:italic">T</span><sup>4</sup>−<span style="font-style:italic">T</span><sub><span style="font-style:italic">e</span></sub><sup>4</sup>) </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
où <span style="font-style:italic">T</span><sub><span style="font-style:italic">e</span></sub>=288<span style="font-style:italic">K</span> est la température d’équiibre de la Terre et 
<span style="font-style:italic">CO</span>2(<span style="font-style:italic">t</span>) la concentration en ppm de gaz carbonique, <span style="font-style:italic">k</span> modélise
la capacité calorifique de la Terre (on peut estimer <span style="font-style:italic">k</span>=0.0025<span style="font-style:italic">K</span>/<span style="font-style:italic">yr</span>),
σ la constante de Stefan-Boltzmann (5.67e-8 S.I.).</p><p>Le taux de CO2 de l’atmosphère peut être considéré comme
un forçage extérieur (dépendant de scénarios d’émissions
de CO2) mais il dépend aussi de la température de l’océan,
on peut donc modéliser l’évolution conjointe des deux
variables par un système différentiel autonome auquel on
ajoute une composante dépendant du temps (émissions
anthropiques).</p><p>On peut raffiner ce modèle en ajoutant par exemple la glace
et ses interactions avec la température (si la température
monte, la glace fond, si la glace fond, l’albédo de la Terre diminue
ce qui va faire monter la température), ce qui amène à un
système différentiel en dimension 3
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">T</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">G</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">C</span>
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">=
<span style="font-style:italic">F</span>(<span style="font-style:italic">T</span>,<span style="font-style:italic">G</span>,<span style="font-style:italic">C</span>) = </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">k</span> (σ(<span style="font-style:italic">T</span><sub>0</sub><sup>4</sup>−<span style="font-style:italic">T</span><sup>4</sup>)+6 ln(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">C</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">280</td></tr>
</table></td><td class="dcell">) − β <span style="font-style:italic">G</span><sup>2/3</sup> ) </td></tr>
</table></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">f</span>(<span style="font-style:italic">T</span>) </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">g</span>(<span style="font-style:italic">C</span>,<span style="font-style:italic">T</span>) + <span style="font-style:italic">a</span>(<span style="font-style:italic">t</span>)
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
où <span style="font-style:italic">f</span> est une fonction décroissante, ∂<sub><span style="font-style:italic">T</span></sub> <span style="font-style:italic">g</span> est positif,
et <span style="font-style:italic">a</span>(<span style="font-style:italic">t</span>) représente la perturbation anthropique (la puissance deux
tiers appliquée à la masse de glace sert à passer d’un volume
à une surface pour représenter l’effet de la variation de volume
de glace sur l’albédo).</p>
<!--TOC subsection id="sec130" Résolution numérique-->
<h3 id="sec130" class="subsection">14.5  Résolution numérique</h3><!--SEC END -->
<!--TOC subsubsection id="sec131" Méthodes à un pas-->
<h4 id="sec131" class="subsubsection">14.5.1  Méthodes à un pas</h4><!--SEC END --><p>
On considère l’équation différentielle 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>′=<span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>,<span style="font-style:italic">y</span>),    <span style="font-style:italic">t</span> ∈ ℝ,    <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>) ∈ ℝ<sup><span style="font-style:italic">d</span></sup>, <span style="font-style:italic">y</span>(0)=<span style="font-style:italic">y</span><sub>0</sub></td></tr>
</table><p> 
où <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>) est la fonction inconnue cherchée
et où <span style="font-style:italic">f</span> est une fonction régulière de <span style="font-style:italic">t</span> et <span style="font-style:italic">y</span> (par exemple
<span style="font-style:italic">C</span><sup>1</sup> sur un domaine pour avoir existence et non recoupement des courbes
intégrales dans ce domaine). On cherche
à approcher numériquement <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>) pour <span style="font-style:italic">t</span>&gt;0. 
On présente ici des méthodes de résolution numérique à un pas,
dont le principe consiste à discrétiser l’intervalle [0,<span style="font-style:italic">t</span>] en des
subdivisions en temps de petite taille [0,<span style="font-style:italic">t</span><sub>1</sub>], [<span style="font-style:italic">t</span><sub>1</sub>,<span style="font-style:italic">t</span><sub>2</sub>], ..., 
[<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span>−1</sub>,<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">t</span>]. Si <span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub> est une valeur approchée de <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>)
la méthode à un pas se traduit par une relation de récurrence entre
<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub> et <span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span>+1</sub> qui reflète une méthode d’intégration
approchée de
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span>+1</sub>)=<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>)+</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span>+1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>,<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>))  <span style="font-style:italic">dt</span></td></tr>
</table><p>
Par exemple, la <span style="font-weight:bold">méthode d’Euler explicite</span><a id="hevea_default156"></a> 
utilise la méthode des
rectangles à gauche
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span>+1</sub> = <span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub> + (<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span>+1</sub>−<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>) <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>,<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub>)=<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub>+<span style="font-style:italic">hf</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>,<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub>)</td></tr>
</table><p>
où <span style="font-style:italic">h</span>=<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span>+1</sub>−<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub><sup><a id="text26" href="#note26">26</a></sup> 
alors que la méthode d’Euler implicite utilise la méthode 
des rectangles à droite
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span>+1</sub> = <span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub> + (<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span>+1</sub>−<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>) <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span>+1</sub>,<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span>+1</sub>)=<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub>+<span style="font-style:italic">hf</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>+<span style="font-style:italic">h</span>,<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span>+1</sub>)</td></tr>
</table><p>
cette dernière relation nécéssite de résoudre une équation pour
déterminer <span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span>+1</sub> d’où son nom de méthode implicite.
Plus généralement, la méthode de résolution revient à
se donner une fonction Φ(<span style="font-style:italic">t</span>,<span style="font-style:italic">y</span>,<span style="font-style:italic">h</span>) et à poser :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span>+1</sub>=<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub>+<span style="font-style:italic">h</span>Φ(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>,<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub>,<span style="font-style:italic">h</span>)</td></tr>
</table><p>
pour la méthode d’Euler explicite, Φ(<span style="font-style:italic">t</span>,<span style="font-style:italic">y</span>,<span style="font-style:italic">h</span>)=<span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>,<span style="font-style:italic">y</span>), pour
la méthode d’Euler implicite, Φ s’obtient en résolvant une 
équation (par exemple avec la méthode du point fixe, pour <span style="font-style:italic">h</span>
suffisamment petit).</p><p>Lorsqu’on compare la solution de l’équation et une valeur
approchée obtenue par une méthode à un pas, il faut distinguer 
</p><ul class="itemize"><li class="li-itemize">
l’erreur locale (ou erreur de consistance)
de la méthode qui est une majoration
de |<span style="font-style:italic">y</span><sub>1</sub>−<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>1</sub>)| en fonction du pas <span style="font-style:italic">h</span>=<span style="font-style:italic">t</span><sub>1</sub>−<span style="font-style:italic">t</span><sub>0</sub>, on dit 
qu’une méthode est d’ordre au moins <span style="font-style:italic">n</span> si |<span style="font-style:italic">y</span><sub>1</sub>−<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>1</sub>)|≤
<span style="font-style:italic">C</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">h</span><sup><span style="font-style:italic">n</span>+1</sup> (cette notion est reliée à l’ordre
de la méthode numérique d’intégration approchée utilisée).
</li><li class="li-itemize">l’erreur globale de la méthode, qui accumule deux phénomènes,
l’erreur locale à chaque pas et l’erreur sur la condition initiale
pour les subdivisions [<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>,<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span>+1</sub>], <span style="font-style:italic">i</span>&gt;0, conséquence des erreurs
précédentes (en pratique il faudrait aussi ajouter les erreurs
d’arrondis et l’erreur
éventuelle sur la condition initiale). Pour majorer cette erreur,
il est nécessaire de supposer que la fonction <span style="font-style:italic">f</span> est lipschitzienne
par rapport à la variable <span style="font-style:italic">y</span>, l’erreur globale fera alors intervenir
un terme en <span style="font-style:italic">e</span><sup><span style="font-style:italic">Ct</span></sup> multiplié par l’erreur locale
(accumulation exponentielle des erreurs au cours du temps).
</li></ul><p>
Plus précisément, on a le résultat suivant :
</p><div class="theorem"><span style="font-weight:bold">Théorème 28</span>  <em>
Soit </em><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)<em> la solution de </em><span style="font-style:italic">y</span>′=<span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>,<span style="font-style:italic">y</span>), <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>)=<span style="font-style:italic">y</span><sub>0</sub><em> sur </em>[<span style="font-style:italic">t</span><sub>0</sub>,<span style="font-style:italic">T</span>]<em>.
On considére une méthode de résolution à un pas :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span>+1</sub>=<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub>+<span style="font-style:italic">h</span><sub><span style="font-style:italic">i</span></sub>Φ(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>,<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub>,<span style="font-style:italic">h</span><sub><span style="font-style:italic">i</span></sub>)</td></tr>
</table><em> 
Si la méthode est d’ordre </em><span style="font-style:italic">p</span><em>, i.e. si pour </em><span style="font-style:italic">h</span>=<span style="font-style:italic">max</span>(<span style="font-style:italic">h</span><sub><span style="font-style:italic">i</span></sub>)<em> 
l’erreur locale satisfait 
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>) + <span style="font-style:italic">h</span>Φ(<span style="font-style:italic">t</span>,<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>),<span style="font-style:italic">h</span>)−<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>+<span style="font-style:italic">h</span>)|≤ <span style="font-style:italic">C</span><sub><span style="font-style:italic">p</span></sub> <span style="font-style:italic">h</span><sup><span style="font-style:italic">p</span>+1</sup>,    ∀ <span style="font-style:italic">t</span> ∈ [<span style="font-style:italic">t</span><sub>0</sub>,<span style="font-style:italic">T</span>], <span style="font-style:italic">h</span> ≤ <span style="font-style:italic">H</span> </td></tr>
</table><em> 
et si la fonction </em>Φ<em> est 
lipschitzienne en </em><span style="font-style:italic">y</span><em> de constante </em>Λ<em> pour </em><span style="font-style:italic">h</span>≤ <span style="font-style:italic">H</span><em> et </em><span style="font-style:italic">y</span><em> dans un 
voisinage de la solution </em><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)<em>, 
i.e. si
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|Φ(<span style="font-style:italic">t</span>,<span style="font-style:italic">z</span>,<span style="font-style:italic">h</span>)−Φ(<span style="font-style:italic">t</span>,<span style="font-style:italic">y</span>,<span style="font-style:italic">h</span>)| ≤ Λ |<span style="font-style:italic">z</span>−<span style="font-style:italic">y</span>| </td></tr>
</table><em>
alors l’erreur globale vérifie
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>)−<span style="font-style:italic">y</span><sub><span style="font-style:italic">n</span></sub>| ≤ <span style="font-style:italic">h</span><sup><span style="font-style:italic">p</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">C</span><sub><span style="font-style:italic">p</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">Λ</td></tr>
</table></td><td class="dcell"><em>
(</em><em><span style="font-style:italic">e</span></em><sup><em>Λ(</em><em><span style="font-style:italic">t</span></em><sub><em><span style="font-style:italic">n</span></em></sub><em>−</em><em><span style="font-style:italic">t</span></em><sub><em>0</em></sub><em>)</em></sup><em>−1)</em></td></tr>
</table><em>
</em></div><p>
Par exemple, pour Euler explicite, Φ(<span style="font-style:italic">t</span>,<span style="font-style:italic">y</span>,<span style="font-style:italic">h</span>)=<span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>,<span style="font-style:italic">y</span>), la constante
Λ est la constante de Lipschitz de <span style="font-style:italic">f</span>, et on prendra pour
<span style="font-style:italic">C</span><sub>1</sub> un majorant de 1/2|∂<sub><span style="font-style:italic">y</span></sub> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>,<span style="font-style:italic">y</span>)| dans un voisinage de la
solution <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>) pour <span style="font-style:italic">t</span> ∈ [<span style="font-style:italic">t</span><sub>0</sub>,<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>].</p><p>Pour prouver ce résultat, il faut déterminer comment se propagent
les erreurs locales introduites à chaque pas.
Par exemple, on a une erreur locale au pas 1 <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>1</sub>)−<span style="font-style:italic">y</span><sub>1</sub> donc une
condition initiale modifiée pour le pas 2 <span style="font-style:italic">y</span><sub>1</sub> au lieu de <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>1</sub>).
Cette erreur se propage au pas 2 en une erreur 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| <span style="font-style:italic">y</span><sub>1</sub>−<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>1</sub>)+<span style="font-style:italic">h</span><sub>1</sub>(Φ(<span style="font-style:italic">t</span><sub>1</sub>,<span style="font-style:italic">y</span><sub>1</sub>,<span style="font-style:italic">h</span><sub>1</sub>)−Φ(<span style="font-style:italic">t</span><sub>1</sub>,<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>1</sub>),<span style="font-style:italic">h</span><sub>1</sub>)| 
≤ (1+<span style="font-style:italic">h</span><sub>1</sub> Λ)|<span style="font-style:italic">y</span><sub>1</sub>−<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>1</sub>)| ≤ <span style="font-style:italic">e</span><sup><span style="font-style:italic">h</span><sub>1</sub> Λ</sup> |<span style="font-style:italic">y</span><sub>1</sub>−<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>1</sub>)|</td></tr>
</table><p>
De même aux pas suivants, donc au pas <span style="font-style:italic">n</span> l’erreur locale au pas 1
s’est propagée en une erreur inférieure ou égale à 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">e</span><sup><span style="font-style:italic">h</span><sub><span style="font-style:italic">n</span>−1</sub> Λ</sup>... <span style="font-style:italic">e</span><sup><span style="font-style:italic">h</span><sub>2</sub> Λ</sup> <span style="font-style:italic">e</span><sup><span style="font-style:italic">h</span><sub>1</sub> Λ</sup> |<span style="font-style:italic">y</span><sub>1</sub>−<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>1</sub>)|
= <span style="font-style:italic">e</span><sup>Λ (<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">t</span><sub>0</sub>)</sup> |<span style="font-style:italic">y</span><sub>1</sub>−<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>1</sub>)| ≤ <span style="font-style:italic">C</span><sub><span style="font-style:italic">p</span></sub><span style="font-style:italic">h</span><sub>0</sub><sup><span style="font-style:italic">p</span>+1</sup> <span style="font-style:italic">e</span><sup>Λ (<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">t</span><sub>0</sub>)</sup></td></tr>
</table><p>
Il faut ensuite sommer les erreurs locales propagées de chaque pas
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">C</span><sub><span style="font-style:italic">p</span></sub> <span style="font-style:italic">h</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">p</span>+1</sup> <span style="font-style:italic">e</span><sup>Λ (<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>)</sup> 
≤ <span style="font-style:italic">C</span><sub><span style="font-style:italic">p</span></sub> <span style="font-style:italic">h</span><sup><span style="font-style:italic">p</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">h</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">e</span><sup>Λ (<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>)</sup> </td></tr>
</table><p>
Comme <span style="font-style:italic">e</span><sup>Λ(<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">t</span>)</sup> est positive décroissante sur
[<span style="font-style:italic">t</span><sub>0</sub>,<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>], on peut majorer la somme par l’intégrale
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">C</span><sub><span style="font-style:italic">p</span></sub> <span style="font-style:italic">h</span><sup><span style="font-style:italic">p</span></sup> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>Λ (<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">t</span>)</sup>  <span style="font-style:italic">dt</span> </td></tr>
</table><p>
d’où le résultat.</p><p>On observe qu’on peut atteindre n’importe quelle précision pourvu
que <span style="font-style:italic">h</span> soit suffisamment petit. Mais en pratique, ce n’est pas le cas.
En effet, le théorème ne tient pas compte des erreurs d’arrondis.
Si le pas est trop petit, les erreurs d’arrondi ne sont plus négligeables,
elles s’ajoutent aux erreurs locales et se propagent comme les erreurs
locales avec amplification exponentielle.
Il y a donc un pas optimal, et une précision maximale que l’on peut
atteindre.</p><p>Références : Hairer, Demailly.</p>
<!--TOC subsubsection id="sec132" Méthodes de Runge-Kutta (explicites)-->
<h4 id="sec132" class="subsubsection">14.5.2  Méthodes de Runge-Kutta (explicites)</h4><!--SEC END --><p><a id="hevea_default157"></a>
Ce sont des méthodes explicites qui 
utilisent une méthode de Newton-Cotes pour approcher
∫<span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>,<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>))  <span style="font-style:italic">dt</span> sur [<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>,<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span>+1</sub>].
Pour simplifier les notations, notons <span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>=α, <span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span>+1</sub>=β,
on a alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>,<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>)) 
≡ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"> ω<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">f</span>(α<sub><span style="font-style:italic">k</span></sub>,<span style="font-style:italic">y</span>(α<sub><span style="font-style:italic">k</span></sub>)))</td></tr>
</table><p>
Pour estimer la valeur de <span style="font-style:italic">f</span>(α<sub><span style="font-style:italic">k</span></sub>,<span style="font-style:italic">y</span>(α<sub><span style="font-style:italic">k</span></sub>)), il est nécessaire
d’approcher <span style="font-style:italic">y</span>(α<sub><span style="font-style:italic">k</span></sub>) ce qui se fait par une méthode
de Newton-Cotes, en utilisant les estimations des
valeurs des <span style="font-style:italic">y</span>(α<sub><span style="font-style:italic">j</span></sub>), <span style="font-style:italic">j</span>&lt;<span style="font-style:italic">k</span>. On a 
donc des méthodes de Newton-Cotes avec un sous-ensemble croissant
de points d’interpolation, donc pour chaque valeur de <span style="font-style:italic">k</span> une
suite de coefficients ω<sub><span style="font-style:italic">j</span>,<span style="font-style:italic">k</span></sub>, <span style="font-style:italic">j</span>&lt;<span style="font-style:italic">k</span> correspondant à la
méthode de Newton-Cotes utilisée. Il faut aussi indiquer la valeur de
α<sub><span style="font-style:italic">k</span></sub> en donnant un coefficient <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> ∈ [0,1] tel que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">α<sub><span style="font-style:italic">k</span></sub> = <span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub> + <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> (<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span>+1</sub>−<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>) = <span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>+<span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">h</span></td></tr>
</table><p>En pratique on stocke un tableau dont les lignes donnent <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> et les <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub>ω<sub><span style="font-style:italic">j</span>,<span style="font-style:italic">k</span></sub>, <span style="font-style:italic">j</span>&lt;<span style="font-style:italic">k</span>,
et le calcul de <span style="font-style:italic">y</span>(α<sub><span style="font-style:italic">k</span></sub>) se fait ligne par ligne
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>(α<sub><span style="font-style:italic">k</span></sub>) ≈ <span style="font-style:italic">Y</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">y</span>(α<sub>0</sub>) +
<span style="font-style:italic">h</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub>ω<sub><span style="font-style:italic">j</span>,<span style="font-style:italic">k</span></sub> <span style="font-style:italic">f</span>(α<sub><span style="font-style:italic">j</span></sub>,<span style="font-style:italic">y</span>(α<sub><span style="font-style:italic">j</span></sub>)) </td></tr>
</table><p>.
Par exemple pour la méthode d’Euler explicite, il y a deux lignes
contenant 0 et un seul coefficient :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >:</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >:</td><td style="text-align:center;white-space:nowrap" >1
</td></tr>
</table></td></tr>
</table><p>.
Pour la méthode du point milieu, il y a trois lignes, la deuxière
ligne exprime comment on estime <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>+<span style="font-style:italic">h</span>/2), la troisième
<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span>+1</sub>)=<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>+<span style="font-style:italic">h</span>) :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >:</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >:</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >:</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1
</td></tr>
</table></td></tr>
</table><p>
on a donc 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">h</span>) ≈ <span style="font-style:italic">Y</span><sub>1</sub>=<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>)+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">hf</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>,<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>))</td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>+<span style="font-style:italic">h</span>) ≈ <span style="font-style:italic">Y</span><sub>2</sub>=<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>)+<span style="font-style:italic">hf</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">,<span style="font-style:italic">Y</span><sub>1</sub>)=<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>)+<span style="font-style:italic">hf</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">,<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>)+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>,<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>)))</td></tr>
</table><p>La suite des temps α<sub><span style="font-style:italic">k</span></sub> est croissante, mais pas forcément
de manière stricte, on peut avoir α<sub><span style="font-style:italic">k</span></sub>=α<sub><span style="font-style:italic">k</span>+1</sub>, la valeur
de <span style="font-style:italic">y</span>(α<sub><span style="font-style:italic">k</span></sub>) n’étant pas estimée par la même méthode de Newton-Cotes
que <span style="font-style:italic">y</span>(α<sub><span style="font-style:italic">k</span>+1</sub>).
La valeur des coefficients est ensuite déterminée pour obtenir un ordre
le plus grand possible pour l’erreur locale (ce qui peut nécessiter
la résolution de systèmes avec pas mal d’inconnues).</p><p>Ainsi, la méthode RK4 utilise le tableau suivant
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >:</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >:</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >:</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >:</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >:</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Ce qui se traduit par
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">Y</span><sub>1</sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>)+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">t</span><sub>0</sub>,<span style="font-style:italic">y</span><sub>0</sub>) </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">Y</span><sub>2</sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>)+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">t</span><sub>0</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">,<span style="font-style:italic">Y</span><sub>1</sub>) </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">Y</span><sub>3</sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>)+<span style="font-style:italic">h</span> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span><sub>0</sub>+<span style="font-style:italic">h</span>,<span style="font-style:italic">Y</span><sub>2</sub>) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">Y</span><sub>4</sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>) + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">t</span><sub>0</sub>,<span style="font-style:italic">y</span>(<span style="font-style:italic">t</span><sub>0</sub>))+
2<span style="font-style:italic">f</span>(<span style="font-style:italic">t</span><sub>0</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">,<span style="font-style:italic">Y</span><sub>1</sub>)+2<span style="font-style:italic">f</span>(<span style="font-style:italic">t</span><sub>0</sub>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">,<span style="font-style:italic">Y</span><sub>2</sub>)+<span style="font-style:italic">f</span>(<span style="font-style:italic">t</span><sub>0</sub>+<span style="font-style:italic">h</span>,<span style="font-style:italic">Y</span><sub>3</sub>)</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Les méthodes de Newton-Cotes utilisées sont les rectangles à
gauche puis à droite pour estimer le point milieu, et la méthode
de Simpson (en prenant la moyenne des deux estimations pour le
point milieu).
On peut montrer qu’elle est d’ordre 4 (erreur locale en <span style="font-style:italic">O</span>(<span style="font-style:italic">h</span><sup>5</sup>))</p><p>Les méthodes de résolution numériques implémentées dans Xcas sont
des méthodes explicites de Runge-Kutta emboitées avec pas adaptatif, 
(le pas adaptatif est calculé en estimant l’erreur 
avec 2 méthodes emboitées RK4 et
Prince-Dormand, cf. Hairer).</p>
<!--TOC section id="sec133" Introduction au calcul variationnel-->
<h2 id="sec133" class="section">15  Introduction au calcul variationnel</h2><!--SEC END --><p> <a id="sec:lagrangien"></a>
La recherche de minimas/maximas est une des application 
du calcul différentiel : en dimension 1, la dérivée s’annule
lorsque la fonction est maximale ou minimale, en dimension plus
grande c’est le gradient qui s’annule. Le calcul variationnel
est une généralisation du principe précédent lorsque
l’inconnue n’est pas l’endroit <span style="font-style:italic">x</span> où l’extrêmum est atteint
(un réel ou un point), mais une fonction. Par exemple, si on recherche
le plus court chemin entre 2 points de l’espace, ou entre 2 points
situé sur une sphère ou une surface : dans ce cas l’inconnue
est le chemin, que l’on peut représenter par une courbe 
paramétrée. On obtient alors une équation différentielle
qui permet de déterminer le chemin, de même que l’équation
<span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span>)=0 ou ∇ <span style="font-style:italic">f</span>=0 permettait de trouver la position
d’un extrêmum. Réciproquement, certaines équations
différentielles de la physique peuvent se mettre sous la forme minimiser une
fonction dépendant d’un chemin, le chemin étant la courbe
intégrale de l’équation différentielle. C’est le cas par
exemple des équations de la dynamique en mécanique
classique aussi bien qu’en relativité. Un des intérêts d’une
formulation variationnelle de ces équations, c’est que ce type
de formulation est plus intrinsèque (plus géométrique) 
elle ne dépend pas des coordonnées.</p><p>Le problème est donc le suivant : on se donne un 
<span style="font-weight:bold">lagrangien</span><a id="hevea_default158"></a>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">L</span>(<span style="font-style:italic">x</span>,ẋ,<span style="font-style:italic">t</span>): ℝ<sup><span style="font-style:italic">n</span></sup> × ℝ<sup><span style="font-style:italic">n</span></sup> × ℝ → ℝ</td></tr>
</table><p> 
où :
</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">L</span> est une fonction dépendant de la position <span style="font-style:italic">x</span> ∈ ℝ<sup><span style="font-style:italic">n</span></sup>,
de la vitesse ẋ ∈ ℝ<sup><span style="font-style:italic">n</span></sup> et du temps <span style="font-style:italic">t</span>,
deux fois continument dérivable,
</li><li class="li-itemize"><span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> ∈ ℝ<sup><span style="font-style:italic">n</span></sup> sont deux points
</li></ul><p>
et on cherche parmi les courbes paramétrées
deux fois continument dérivables
γ(<span style="font-style:italic">t</span>) d’origine γ(<span style="font-style:italic">t</span><sub>0</sub>)=<span style="font-style:italic">A</span> 
et extrémité γ(<span style="font-style:italic">t</span><sub>1</sub>)=<span style="font-style:italic">B</span> le(s) chemin(s) réalisant le
minimum (s’il existe) de l’<span style="font-weight:bold">action</span><a id="hevea_default159"></a> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">S</span>=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">L</span>(γ(<span style="font-style:italic">t</span>),</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>γ(<span style="font-style:italic">t</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">,<span style="font-style:italic">t</span>) <span style="font-style:italic">dt</span> </td></tr>
</table><p>Exemples : 
</p><ul class="itemize"><li class="li-itemize">
longueur minimale dans le plan, <span style="font-style:italic">n</span>=2 et 
<span style="font-style:italic">L</span>(<span style="font-style:italic">x</span>,ẋ,<span style="font-style:italic">t</span>)=|| ẋ ||=√<span style="text-decoration:overline">x_1</span><sup><span style="text-decoration:overline">2</span></sup><span style="text-decoration:overline">+x_2</span><sup><span style="text-decoration:overline">2</span></sup>.
</li><li class="li-itemize">lagrangien de la mécanique classique (<span style="font-style:italic">n</span>=1,2 ou 3, dans un
référentiel galiléen) :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">L</span>(<span style="font-style:italic">x</span>,ẋ,<span style="font-style:italic">t</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">m</span>ẋ<sup>2</sup>−<span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">t</span>)</td></tr>
</table>
</li><li class="li-itemize">lagrangien en relativité restreinte :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">L</span>(<span style="font-style:italic">x</span>,ẋ,<span style="font-style:italic">t</span>)=−<span style="font-style:italic">mc</span><sup>2</sup></td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ẋ<sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">c</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">−<span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">t</span>)</td></tr>
</table>
</li></ul><div class="theorem"><span style="font-weight:bold">Proposition 29</span>  <em>
Équations d’</em><em><span style="font-weight:bold">Euler-Lagrange</span></em><a id="hevea_default160"></a><em> : 
ce sont des conditions nécessaires
pour que </em>γ(<span style="font-style:italic">t</span>)<em> soit un extrêmum, si
</em><span style="font-style:italic">x</span>=(<span style="font-style:italic">x</span><sub>1</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>)<em> est un système de coordonnées (pas
forcément dans un repère orthonormé),
elles sont données par :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ x_i</td></tr>
</table></td><td class="dcell"> = 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell">    pour  <span style="font-style:italic">i</span>=1,...,<span style="font-style:italic">n</span></td></tr>
</table><em>
(On vérifie que cette équation a la bonne homogénéité.)
</em></div><p>Sur les exemples, on obtient
</p><ul class="itemize"><li class="li-itemize">
pour la longueur minimale dans le plan, on a 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">x</span><sub>1</sub></td></tr>
</table></td><td class="dcell">=0,   
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ x_1</td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">x_1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >x_1<sup>2</sup>+x_2<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table>
qui est la première composante du vecteur tangent,
de même pour la deuxième composante, 
donc le long de la courbe le vecteur tangent a sa dérivée
nulle, donc est constant. Une
courbe réalisant un extrêmum de la distance entre deux points
dans le plan est donc portée par une droite, c’est le segment
reliant ces deux points.
</li><li class="li-itemize">Pour le deuxième exemple
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">x</span><sub>1</sub></td></tr>
</table></td><td class="dcell">=−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">V</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">x</span><sub>1</sub></td></tr>
</table></td><td class="dcell">,
   </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">x</span><sub>1</sub></td></tr>
</table></td><td class="dcell">=<span style="font-style:italic">m</span>x_1
</td></tr>
</table>
c’est-à-dire la composante sur <span style="font-style:italic">x</span><sub>1</sub> de la force et
de la quantité de mouvement, donc l’équation d’Euler-Lagrange
donne l’équation fondamentale de la dynamique.
</li><li class="li-itemize">Pour le troisième exemple, on a
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">x</span><sub>1</sub></td></tr>
</table></td><td class="dcell">=−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">V</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">x</span><sub>1</sub></td></tr>
</table></td><td class="dcell">,
   </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">x</span><sub>1</sub></td></tr>
</table></td><td class="dcell">=<span style="font-style:italic">m</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">x_1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1− 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ẋ<sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">c</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table>
c’est-à-dire la composante sur <span style="font-style:italic">x</span> de la force et
de la quantité de mouvement en relativité restreinte,
on retrouve donc l’équation fondamentale de la dynamique.
</li></ul><p><span style="font-weight:bold">Démonstration (idée) :</span><br>
On fait varier le chemin en ajoutant à 
γ(<span style="font-style:italic">t</span>)=(<span style="font-style:italic">x</span><sub>1</sub>(<span style="font-style:italic">t</span>),...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">t</span>))
un vecteur <span style="font-style:italic">u</span> Δ(<span style="font-style:italic">t</span>) avec Δ(<span style="font-style:italic">t</span><sub>0</sub>)=Δ(<span style="font-style:italic">t</span><sub>1</sub>)=0, on obtient
une action <span style="font-style:italic">S</span>(<span style="font-style:italic">u</span>), on calcule la dérivée en <span style="font-style:italic">u</span>=0
de <span style="font-style:italic">S</span>(<span style="font-style:italic">u</span>), elle doit s’annuler pour avoir un extrêmum, et
ce quel que soit la valeur de la fonction Δ 
telle que Δ(<span style="font-style:italic">t</span><sub>0</sub>)=Δ(<span style="font-style:italic">t</span><sub>1</sub>)=0. Prenons pour commencer Δ
uniquement sur la première composante
Δ(<span style="font-style:italic">t</span>)=(δ(<span style="font-style:italic">t</span>),0,...,0), on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">S</span>(<span style="font-style:italic">u</span>) = </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell">
<span style="font-style:italic">L</span>(<span style="font-style:italic">x</span><sub>1</sub>(<span style="font-style:italic">t</span>)+<span style="font-style:italic">u</span>δ(<span style="font-style:italic">t</span>),<span style="font-style:italic">x</span><sub>2</sub>(<span style="font-style:italic">t</span>),...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>,x_1+<span style="font-style:italic">u</span>δ,x_2,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>′,<span style="font-style:italic">t</span>)   <span style="font-style:italic">dt</span></td></tr>
</table><p>
on dérive par rapport à <span style="font-style:italic">u</span> sous le signe intégrale (on peut
intervertir dérivée et intégrale car γ, δ, <span style="font-style:italic">L</span> sont
deux fois continument dérivables). Comme <span style="font-style:italic">u</span> intervient dans deux
composantes de <span style="font-style:italic">L</span>, il y a deux dérivées partielles qui
interviennent :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">S</span>′(0) =</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">x</span><sub>1</sub></td></tr>
</table></td><td class="dcell"> δ + 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ x_1</td></tr>
</table></td><td class="dcell"> δ </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"> <span style="font-style:italic">dt</span></td></tr>
</table><p>
On intègre par parties le deuxième terme (δ=<span style="font-style:italic">d</span>
δ/<span style="font-style:italic">dt</span>), le terme tout intégré est nul 
car δ(<span style="font-style:italic">t</span><sub>0</sub>)=δ(<span style="font-style:italic">t</span><sub>1</sub>)=0, d’où :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">0=<span style="font-style:italic">S</span>′(0)=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">x</span><sub>1</sub></td></tr>
</table></td><td class="dcell"> δ 
−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ x_1</td></tr>
</table></td><td class="dcell"> δ </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
<span style="font-style:italic">dt</span>
=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>1</sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">x</span><sub>1</sub></td></tr>
</table></td><td class="dcell"> 
−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ x_1</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">δ 
<span style="font-style:italic">dt</span></td></tr>
</table><p>
Comme le résultat doit être nul
pour toute valeur de δ, on en déduit la première
équation d’Euler-Lagrange (en prenant
δ=(<span style="font-style:italic">t</span>−<span style="font-style:italic">t</span><sub>0</sub>)(<span style="font-style:italic">t</span><sub>1</sub>−<span style="font-style:italic">t</span>) (∂ <span style="font-style:italic">L</span>/∂ <span style="font-style:italic">x</span><sub>1</sub> 
−<span style="font-style:italic">d</span>/<span style="font-style:italic">dt</span> ∂ <span style="font-style:italic">L</span>/∂ x_1) si la régularité
est suffisante, ou sinon en raisonnant par l’absurde :
si l’équation n’est pas vérifiée
en un point, alors on prend δ non nulle seulement
au voisinage de ce point et nulle ailleurs, et on choisit δ
de même signe que l’autre facteur, l’intégrale est alors
strictement positive, absurde).</p><p>Un des intérêts de cette écriture des équations de la
mécanique, c’est de pouvoir effectuer un changement de coordonnées
plus facilement, car la propriété de rendre l’action extrêmale pour un
chemin est indépendant du choix des coordonnées.
Par exemple, si <span style="font-style:italic">n</span>=2, on peut utiliser les coordonnées polaires 
(<span style="font-style:italic">r</span>,θ), on a alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">L</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">m</span>(ṙ<sup>2</sup>+<span style="font-style:italic">r</span><sup>2</sup> θ<sup>2</sup>) − <span style="font-style:italic">V</span>(<span style="font-style:italic">r</span>,θ)</td></tr>
</table><p>
Si le potentiel est à symétrie sphérique, alors <span style="font-style:italic">L</span> ne
dépend pas de θ (seulement de θ) donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ θ</td></tr>
</table></td><td class="dcell"> = 0</td></tr>
</table><p>
on a donc une intégrale première, qui est le moment cinétique
<span style="font-style:italic">mr</span><sup>2</sup> θ.</p><p>Plus généralement, si <span style="font-style:italic">L</span> ne dépend pas explicitement du temps,
alors le <span style="font-weight:bold">hamiltonien</span><a id="hevea_default161"></a> défini par :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">H</span> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> ẋ<sub><span style="font-style:italic">i</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ ẋ<sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell"> − <span style="font-style:italic">L</span></td></tr>
</table><p>
est une intégrale première, en effet
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dH</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂
ẋ<sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> ẋ<sub><span style="font-style:italic">i</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂
<span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ ẋ<sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell">
− </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span><sub><span style="font-style:italic">i</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">
+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ ẋ<sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>ẋ<sub><span style="font-style:italic">i</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂
ẋ<sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> ẋ<sub><span style="font-style:italic">i</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂  <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell">
− </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell"> ẋ<sub><span style="font-style:italic">i</span></sub>
+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ ẋ<sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >0
</td></tr>
</table></td></tr>
</table><p><span style="font-weight:bold">Exercice</span> : calculer <span style="font-style:italic">H</span> pour le lagrangien de la mécanique
classique et de la relativité restreinte.</p><p><span style="font-weight:bold">Exemple </span>: On cherche la forme d’un toboggan qui permette
de se rendre le plus rapidement possible d’un point <span style="font-style:italic">A</span> (origine
du repère) à un point <span style="font-style:italic">B</span> situé à une altitude plus basse 
sous l’action de la gravité (en négligeant les frottements). 
Si cette courbe est un graphe de fonction <span style="font-style:italic">y</span>(<span style="font-style:italic">x</span>) alors la vitesse
est donnée par 
<span style="font-style:italic">v</span>=(<span style="font-style:italic">dx</span>/<span style="font-style:italic">dt</span>,<span style="font-style:italic">dy</span>/<span style="font-style:italic">dt</span>)=<span style="font-style:italic">dx</span>/<span style="font-style:italic">dt</span>(1,<span style="font-style:italic">y</span>′).
D’autre part <span style="font-style:italic">v</span>=√<span style="text-decoration:overline">−2</span><span style="text-decoration:overline"><span style="font-style:italic">gy</span></span>. Donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">y</span>′<sup>2</sup></td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−2<span style="font-style:italic">gy</span></td></tr>
</table></td></tr>
</table><p>
on en déduit :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">dt</span> = <span style="font-style:italic">dx</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">y</span>′<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−2<span style="font-style:italic">gy</span></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
donc le temps à minimiser est
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span><sub><span style="font-style:italic">B</span></sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span><sub><span style="font-style:italic">A</span></sub>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">dt</span> = </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span><sub><span style="font-style:italic">B</span></sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">y</span>′<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−2<span style="font-style:italic">gy</span></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">dx</span></td></tr>
</table><p>
Pour se ramener au problème précédent, 
on change de notations, <span style="font-style:italic">x</span> devient un “temps virtuel”
τ et <span style="font-style:italic">y</span>′=ẏ est la dérivée de <span style="font-style:italic">y</span> par
rapport à ce temps virtuel, il faut minimiser
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">τ<sub><span style="font-style:italic">B</span></sub></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">L</span>(τ,<span style="font-style:italic">y</span>,ẏ) <span style="font-style:italic">d</span>τ,    
<span style="font-style:italic">L</span>(τ,<span style="font-style:italic">y</span>,ẏ)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+ẏ<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−2<span style="font-style:italic">gy</span></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
le lagrangien ne dépend pas explicitement de τ, donc le
hamiltonient correspondant
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">H</span>=ẏ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ẏ</td></tr>
</table></td><td class="dcell">  − <span style="font-style:italic">L</span> </td></tr>
</table><p>
est conservé, donc indépendant de τ donc en revenant
à la notation <span style="font-style:italic">x</span> pour l’abscisse on a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">H</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>′  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"> ∂</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">y</span>′<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−2<span style="font-style:italic">gy</span></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">∂ <span style="font-style:italic">y</span>′</td></tr>
</table></td><td class="dcell">− 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">y</span>′<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−2<span style="font-style:italic">gy</span></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−2<span style="font-style:italic">gy</span></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><span style="font-style:italic">y</span>′ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">y</span>′<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> −
</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">y</span>′<sup>2</sup></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−2<span style="font-style:italic">gy</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">y</span>′<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> 
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Après simplification, on obtient l’équation différentielle :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">−2<span style="font-style:italic">gH</span><sup>2</sup><span style="font-style:italic">y</span> (1+<span style="font-style:italic">y</span>′<sup>2</sup>) = 1</td></tr>
</table><p>
soit 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>′<sup>2</sup>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−2<span style="font-style:italic">c</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell">−1,    <span style="font-style:italic">c</span>=<span style="font-style:italic">gH</span><sup>2</sup>   </td></tr>
</table><p>
Comme <span style="font-style:italic">y</span>≤ 0 et <span style="font-style:italic">y</span>′(0)=0, on en déduit que <span style="font-style:italic">y</span>′ est négatif :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">−<span style="font-style:italic">dy</span> = </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−2<span style="font-style:italic">c</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell">−1</td></tr>
</table></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dx</span></td></tr>
</table><p>
Il s’agit d’une équation à variables séparables. En posant
<span style="font-style:italic">y</span>=−<span style="font-style:italic">c</span>+<span style="font-style:italic">cY</span>, <span style="font-style:italic">x</span>=<span style="font-style:italic">cX</span>
on obtient une équation indépendante de <span style="font-style:italic">c</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">−<span style="font-style:italic">dY</span>=</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">Y</span></td></tr>
</table></td><td class="dcell">−1</td></tr>
</table></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dX</span>=</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">Y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">Y</span></td></tr>
</table></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">dX</span></td></tr>
</table><p>
Donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">−</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">Y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">Y</span></td></tr>
</table></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">dY</span> = </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><span style="font-style:italic">dX</span> </td></tr>
</table><p>
puis (pour trouver la constante d’intégration, on observe que
<span style="font-style:italic">Y</span>=1 pour <span style="font-style:italic">X</span>=0) :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">−</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">Y</span><sup>2</sup></td></tr>
</table></td><td class="dcell">+arccos(<span style="font-style:italic">Y</span>)=<span style="font-style:italic">X</span></td></tr>
</table><p>
Si on pose <span style="font-style:italic">Y</span>=cos(<span style="font-style:italic">t</span>), <span style="font-style:italic">t</span> ∈ [0,π], on a <span style="font-style:italic">X</span>=<span style="font-style:italic">t</span> − sin(<span style="font-style:italic">t</span>),
la solution est donc une cycloïde<a id="hevea_default162"></a> renversée.
On peut aussi le vérifier directement
en remplaçant dans l’équation <span style="font-style:italic">x</span> et <span style="font-style:italic">y</span>
par les équations paramétriques de la cycloïde renversée
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>=<span style="font-style:italic">c</span>(<span style="font-style:italic">t</span>−sin(<span style="font-style:italic">t</span>)),  <span style="font-style:italic">y</span>=−<span style="font-style:italic">c</span>+<span style="font-style:italic">c</span>cos(<span style="font-style:italic">t</span>)),  <span style="font-style:italic">t</span> ∈ [0,π]</td></tr>
</table><p>
on trouve pour le membre de droite :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−2<span style="font-style:italic">c</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell">−1</td></tr>
</table></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dx</span></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">c</span> </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−cos(<span style="font-style:italic">t</span>)</td></tr>
</table></td><td class="dcell">−1</td></tr>
</table></td></tr>
</table></td><td class="dcell"> 
(1−cos(<span style="font-style:italic">t</span>))  <span style="font-style:italic">dt</span></td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">c</span> </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">1+cos(<span style="font-style:italic">t</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−cos(<span style="font-style:italic">t</span>)</td></tr>
</table></td></tr>
</table></td><td class="dcell">   (1−cos(<span style="font-style:italic">t</span>))  <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">c</span> </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−cos(<span style="font-style:italic">t</span>)<sup>2</sup></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span></td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">c</span> sin(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >−<span style="font-style:italic">dy</span>
</td></tr>
</table></td></tr>
</table>
<!--TOC section id="sec134" Corps finis.-->
<h2 id="sec134" class="section">16  Corps finis.</h2><!--SEC END --><p> <a id="sec:gf"></a><a id="hevea_default163"></a><a id="hevea_default164"></a>
</p>
<!--TOC subsection id="sec135" Rappels-->
<h3 id="sec135" class="subsection">16.1  Rappels</h3><!--SEC END --><p>
Soit <span style="font-style:italic">K</span> un corps fini. Le plus petit entier <span style="font-style:italic">p</span> tel que
<span style="font-style:italic">p</span>.1=0 est la caractéristique du corps, c’est un nombre premier
(car <span style="font-style:italic">xy</span>=0 ⇒ <span style="font-style:italic">x</span>=0 ou <span style="font-style:italic">y</span>=0), et <span style="font-style:italic">K</span> est un ℤ/<span style="font-style:italic">p</span>ℤ
espace vectoriel de dimension finie <span style="font-style:italic">n</span>, donc son cardinal est <span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup>.</p><p>Les inversibles pour la multiplication forment un groupe de cardinal
<span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup>−1 et ce groupe est cyclique (sinon on construit un élément
d’ordre <span style="font-style:italic">d</span> le PPCM des ordres des éléments de <span style="font-style:italic">K</span><sup>*</sup>, cet ordre
est donc un diviseur strict de <span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup>−1, mais c’est impossible car
le polynôme <span style="font-style:italic">x</span><sup><span style="font-style:italic">d</span></sup>−<span style="font-style:italic">x</span> a alors <span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup>−1&gt;<span style="font-style:italic">d</span> racines).</p><p>L’application φ:<span style="font-style:italic">x</span> → <span style="font-style:italic">x</span><sup><span style="font-style:italic">p</span></sup> est une application linéaire
et le noyau de φ-id est ℤ/<span style="font-style:italic">p</span>ℤ. Si <span style="font-style:italic">P</span> est un polynôme 
irréductible à coefficients dans ℤ/<span style="font-style:italic">p</span>ℤ de degré divisant <span style="font-style:italic">n</span>, alors
<span style="font-style:italic">P</span> se décompose en produit de facteurs de degré 1 et on passe
d’une racine de <span style="font-style:italic">P</span> dans <span style="font-style:italic">K</span> à une autre en appliquant φ
(en effet <span style="font-style:italic">P</span> divise <span style="font-style:italic">x</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup></sup>−<span style="font-style:italic">x</span> modulo <span style="font-style:italic">p</span> et
<span style="font-style:italic">x</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup></sup>−<span style="font-style:italic">x</span>=∏<sub>α ∈ <span style="font-style:italic">K</span></sub> (<span style="font-style:italic">x</span>−α)).
Exemple : faire <code>GF(3,5)</code> pour créer le corps <span style="font-style:italic">K</span>
de cardinal 3<sup>5</sup>, puis 
<code>P:=randpoly(5) % 3; factor(P)</code>
et exécuter à niveau la commande jusqu’à ce que <span style="font-style:italic">P</span> soit
irréductible, puis tester <code>factor(P,g)</code>.
Evidemment, ce résultat n’est plus vrai si <span style="font-style:italic">P</span> a des coefficients
dans <span style="font-style:italic">K</span> au lieu de ℤ/<span style="font-style:italic">p</span>ℤ (essayer avec <code>P:=randpoly(5,g)</code>).</p>
<!--TOC subsection id="sec136" Représentation des corps non premiers.-->
<h3 id="sec136" class="subsection">16.2  Représentation des corps non premiers.</h3><!--SEC END -->
<!--TOC subsubsection id="sec137" Cas général.-->
<h4 id="sec137" class="subsubsection">16.2.1  Cas général.</h4><!--SEC END --><p>
Pour représenter <span style="font-style:italic">K</span>, on utilise généralement la
représentation dite additive, c’est-à-dire que <span style="font-style:italic">K</span>
est isomorphe à ℤ/<span style="font-style:italic">p</span>ℤ[<span style="font-style:italic">X</span>]/<span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>) avec <span style="font-style:italic">P</span> un polynôme
irréductible de ℤ/<span style="font-style:italic">p</span>ℤ[<span style="font-style:italic">X</span>] de degré <span style="font-style:italic">n</span>. Si la classe de <span style="font-style:italic">X</span>
est d’ordre <span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup>−1 dans <span style="font-style:italic">K</span><sup>*</sup> on dit que <span style="font-style:italic">P</span> est <span style="font-weight:bold">primitif</span><a id="hevea_default165"></a>.
Dans Xcas, c’est cette représentation qui est utilisée,
l’instruction <code>GF(p,n)</code> génère aléatoirement
un polynôme irréductible de degré <span style="font-style:italic">n</span> sur ℤ/<span style="font-style:italic">p</span>ℤ,
puis cherche un élément cyclique, calcule son polynôme
minimal (qui est donc primitif), et affiche le nom d’un
générateur (par défaut <code>g</code>), 
il suffit alors d’écrire n’importe quelle
expression symbolique polynomiale en ce générateur
pour créer un élément de <span style="font-style:italic">K</span>. En interne, Xcas stocke
les éléments de <span style="font-style:italic">K</span> comme des polynômes-listes
à coefficients dans ℤ/<span style="font-style:italic">p</span>ℤ, et les affiche comme polynôme
symbolique en fonction du générateur. On peut aussi
utiliser un entier entre 0 et <span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup>−1 dont l’écriture en base
<span style="font-style:italic">p</span> représente les coefficients du polynôme.</p><p>Pour générer un polynôme <span style="font-weight:bold">irréductible</span><a id="hevea_default166"></a>, on utilise
un génerateur aléatoire d’entiers dans [0,<span style="font-style:italic">p</span>[,
on crée un polynôme unitaire de degré <span style="font-style:italic">n</span>, et
on teste son irréductibilité en calculant le PGCD
de <span style="font-style:italic">P</span> avec les <span style="font-style:italic">x</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup></sup>−<span style="font-style:italic">x</span> pour <span style="font-style:italic">k</span> de 1 jusque <span style="font-style:italic">n</span>/2.
En pratique, on calcule les <code>powmod(x,p^k,p,P)</code>
(en prenant la puissance modulaire <span style="font-style:italic">p</span>-ième
du précédent), on retire <span style="font-style:italic">x</span> et on calcule le pgcd avec <span style="font-style:italic">P</span>,
si on trouve un résultat différent de 1, on passe au polynôme
suivant (généré aléatoirement).
On peut calculer la probabilité de réussir en dénombrant
les polynômes irréductibles de degré <span style="font-style:italic">n</span> à l’aide
de la formule <span style="font-style:italic">x</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup></sup>−<span style="font-style:italic">x</span>=∏<sub><span style="font-style:italic">P</span>  irréductible unitaire / deg(<span style="font-style:italic">P</span>) divise  <span style="font-style:italic">n</span></sub> <span style="font-style:italic">P</span>.</p><p>Trouver un élément <span style="font-weight:bold">cyclique</span><a id="hevea_default167"></a> se fait aussi au hasard
(<code>rand(g)</code> en Xcas si <code>g</code> est le générateur
d’un corps fini), la
probabilité se calcule à l’aide de l’indicatrice d’Euler de
<span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup>−1. Déterminer le polynome minimal d’un élément
est alors un problème d’algèbre linéaire, il se résoud
en calculant le noyau de la matrice dont les colonnes sont
les coefficients des puissances de l’élément (instruction
<code>pmin</code> en Xcas).</p><p>La représentation additive est pratique pour additionner
ou soustraire des éléments de <span style="font-style:italic">K</span>, multiplier
nécessite de faire une division euclidienne par <span style="font-style:italic">P</span> et prendre
le reste, inverser nécessite de faire une identité de Bézout
avec <span style="font-style:italic">P</span>. Il existe une représentation alternative, dite
multiplicative, on représente alors un élément <span style="font-style:italic">g</span><sup><span style="font-style:italic">k</span></sup> de <span style="font-style:italic">K</span><sup>*</sup>
par la puissance <span style="font-style:italic">k</span> ∈ [0,<span style="font-style:italic">p</span><sup>−</sup>2] du générateur <span style="font-style:italic">g</span>, et on
représente 0<sub><span style="font-style:italic">K</span></sub> par -1 ou par <span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup>−1. Mais l’addition
est alors difficile sauf si on dispose d’une table passant
de la représentation additive à la représentation
multiplicative.</p>
<!--TOC subsubsection id="sec138" Corps de petit cardinal, cas de la caractéristique 2-->
<h4 id="sec138" class="subsubsection">16.2.2  Corps de petit cardinal, cas de la caractéristique 2</h4><!--SEC END --><p>
Si le cardinal du corps n’est pas trop grand (par exemple
moins que quelques milliers), il est intéressant de construire
une table de passage entre représentation additive et
multiplicative, c’est-à-dire une permutation de [0,<span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup>−1]
si on utilise des entiers pour la représentation additive.
On calcule donc une fois pour toutes la représentation additive
de toutes les puissances de <span style="font-style:italic">g</span> ce qui fournit la table de passage
multiplicatif vers additif, puis la permutation inverse, on peut alors
effectuer toutes les opérations sur le corps <span style="font-style:italic">K</span> très
rapidement : la multiplication devient un test si l’un
des éléments vaut <span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup>−1 suivi d’une addition modulo <span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup>−1 si
ce n’est pas le cas, l’addition une écriture en base <span style="font-style:italic">p</span> et <span style="font-style:italic">n</span>
additions dans ℤ/<span style="font-style:italic">p</span>ℤ.</p><p>En caractéristique 2, l’addition est encore plus simple, il s’agit
d’un ou exclusif bit à bit (sur un type entier court 8 ou 16 ou 32 bits). 
De plus le calcul de la permutation
de passage est très rapide, pour trouver <span style="font-style:italic">g</span><sup><span style="font-style:italic">k</span>+1</sup> en fonction
de <span style="font-style:italic">g</span><sup><span style="font-style:italic">k</span></sup> il faut multiplier par <span style="font-style:italic">g</span> ce qui est un décalage
de bit vers la gauche, tester si l’entier est supérieur à 2<sup><span style="font-style:italic">n</span></sup>
et si oui faire un ou exclusif avec l’entier représentant le
polynôme minimal de <span style="font-style:italic">g</span>. Si le cardinal du corps est assez petit
(par exemple 2<sup>8</sup>, ou disons moins que 2<sup>13</sup>),
la permutation et son inverse tiennent dans le cache du
microprocesseur et les opérations sur le corps <span style="font-style:italic">K</span> se font
en une dizaine de cycles du microprocesseur.</p>
<!--TOC subsection id="sec139" Exercices-->
<h3 id="sec139" class="subsection">16.3  Exercices</h3><!--SEC END --><p>
Dans Xcas, pour travailler dans ℤ/<span style="font-style:italic">p</span>ℤ, on utilise l’opérateur <code>%</code>.
Attention à bien laisser un espace avant ou/et après <code>%</code> si vous 
utilisez des noms de variables. Par exemple <code>p:=7; 3 % p</code> représente
la classe de 3 dans ℤ/7ℤ.
Pour travailler dans un corps fini non premier de caractéristique <span style="font-style:italic">p</span>
et de cardinal <span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup>,
on crée le corps avec la commande <code>GF(p,n)</code> ou une variante.
Les variantes permettent de préciser le nom de variable pour 
générer les éléments du corps comme polynômes en cette variable, 
ou pour préciser le polynôme minimal ou pour indiquer si on ne souhaite
pas que le polynôme minimal soit primitif (i.e. que les puissances
de la variable engendre le corps moins 0). Par exemple
</p><ul class="itemize"><li class="li-itemize">
<code>GF(2,8,r)</code> utilisera <code>r</code> comme variable
</li><li class="li-itemize"><code>GF(2,128,0)</code> utilisera un polynôme minimal pas forcément 
primitif
</li><li class="li-itemize"><code>GF(2,128,r,0)</code> combine les deux
</li><li class="li-itemize"><code>GF(2,w^8+w^7+w^5+w+1,w,0)</code> utilise <code>w</code> comme variable,
le polynôme minimal <code>w^8+w^7+w^5+w+1</code> qui n’est pas forcément
primitif.
</li></ul><p>Exercices :
</p><ol class="enumerate" type=1><li class="li-enumerate">
Trouver un polynôme irréductible <span style="font-style:italic">P</span> de degré 5 sur ℤ/7ℤ.
En déduire une représentation de <code>GF(7,5)</code>. Factoriser 
le polynôme <span style="font-style:italic">P</span> sur votre représentation de <code>GF(7,5)</code> (on pourra utiliser
l’application <span style="font-style:italic">x</span> → <span style="font-style:italic">x</span><sup>7</sup>).
</li><li class="li-enumerate">Déterminer le polynôme minimal de quelques éléments
de <code>GF(7,5)</code> en utilisant votre représentation ou celle de Xcas.
Même question mais en degré 4 avec la représentation de Xcas.
</li><li class="li-enumerate">Factoriser avec Xcas <span style="font-style:italic">x</span><sup>16</sup>−<span style="font-style:italic">x</span> modulo 2 (on pourra utiliser
<code>factors()</code>, <code>% 2</code> et <code>% 0</code>). 
En déduire les polynômes irréductibles de degré 4 sur
ℤ/2ℤ, déterminez les polynômes irréductibles
primitif de degré 4, pour l’un d’entre eux construire une table entre représentation
multiplicative et additive de <code>GF(2,4)</code>.
</li><li class="li-enumerate">Écrire une fonction permettant de déterminer si un
polynôme <span style="font-style:italic">A</span> est irréductible modulo <span style="font-style:italic">p</span>, en utilisant le
PGCD avec les <span style="font-style:italic">x</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup></sup>−<span style="font-style:italic">x</span> modulo <span style="font-style:italic">p</span>. Quelle est sa complexité
si <span style="font-style:italic">A</span> est irréductible de degré <span style="font-style:italic">d</span> ?
</li><li class="li-enumerate">Créer une matrice carrée <span style="font-style:italic">M</span> d’ordre 3 à coefficients
dans un corps de cardinal 25, déterminer son polynome
minimal et son ordre. Quels sont les ordres possibles ?
</li></ol>
<!--TOC subsection id="sec140" Rappels de quelques complexités de base-->
<h3 id="sec140" class="subsection">16.4  Rappels de quelques complexités de base</h3><!--SEC END --><p>
<span style="font-style:italic">n</span> désigne un majorant commun de la taille des arguments, ou bien
<span style="font-style:italic">n</span><sub>1</sub> et <span style="font-style:italic">n</span><sub>2</sub> désignent la taille des 2 arguments.</p>
<!--TOC subsubsection id="sec141" Polynomes denses et entiers-->
<h4 id="sec141" class="subsubsection">16.4.1  Polynomes denses et entiers</h4><!--SEC END --><p>
Pour un polynôme en une variable
à coefficients dans un corps fini, la taille est
le degré du polynôme, on prend comme convention que
la somme et le produit des coefficients se fait en temps <span style="font-style:italic">O</span>(1).</p><p>Pour un entier, la taille est le nombre de chiffres dans l’écriture
dans une base quelconque, <span style="font-style:italic">n</span> est donc un majorant de log<sub><span style="font-style:italic">b</span></sub>(<span style="font-style:italic">N</span>).
</p><ul class="itemize"><li class="li-itemize">
Addition, soustraction : <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span>) ou <span style="font-style:italic">O</span>(max(<span style="font-style:italic">n</span><sub>1</sub>,<span style="font-style:italic">n</span><sub>2</sub>))
</li><li class="li-itemize">Multiplication naïve : <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>2</sup>) ou <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sub>1</sub><span style="font-style:italic">n</span><sub>2</sub>)
</li><li class="li-itemize">Division naïve : <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>2</sup>) ou <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sub>2</sub>(<span style="font-style:italic">n</span><sub>1</sub>−<span style="font-style:italic">n</span><sub>2</sub>)).
</li><li class="li-itemize">Multiplication rapide : Karatsuba <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>log(3)/log(2)</sup>), ..., FFT
<span style="font-style:italic">O</span>(<span style="font-style:italic">n</span>ln(<span style="font-style:italic">n</span>)) pour des polynômes
</li><li class="li-itemize">PGCD, Bézout : <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>2</sup>)
</li><li class="li-itemize">calcul de <span style="font-style:italic">a</span><sup><span style="font-style:italic">N</span></sup> (mod <span style="font-style:italic">p</span> ) ou cout d’un test de Miller-Rabin : 
en <span style="font-style:italic">O</span>(ln(<span style="font-style:italic">N</span>)) étapes, donc en <span style="font-style:italic">O</span>(ln(<span style="font-style:italic">N</span>)ln(<span style="font-style:italic">p</span>)<sup>2</sup>)
</li></ul><p><span style="font-weight:bold">Remarques</span>
</p><ul class="itemize"><li class="li-itemize">
Attention, le cout est plus important si les coefficients sont entiers
ou rationnels. 
</li><li class="li-itemize">Si on tient compte du cout des opérations sur le corps fini
de cardinal <span style="font-style:italic">c</span>. Il faut multiplier les couts par <span style="font-style:italic">O</span>(ln(<span style="font-style:italic">c</span>)) pour +,−
et par <span style="font-style:italic">O</span>(ln(<span style="font-style:italic">c</span>)<sup>2</sup>) pour les autres opérations.
</li><li class="li-itemize">Pour des polynômes creux, les couts sont
estimés en fonction du nombre de coefficients non nuls.
</li></ul>
<!--TOC subsubsection id="sec142" Algèbre linéaire dense-->
<h4 id="sec142" class="subsubsection">16.4.2  Algèbre linéaire dense</h4><!--SEC END --><p>
Pour une matrice carrée <span style="font-style:italic">n</span>,<span style="font-style:italic">n</span> à coefficients dans un corps fini où
les opérations se font en temps <span style="font-style:italic">O</span>(1).
</p><ul class="itemize"><li class="li-itemize">
Addition, soustraction, multiplication par un scalaire,
multiplication par un vecteur : <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>2</sup>)
</li><li class="li-itemize">Multiplication de 2 matrices, pivot de Gauss
(décomposition <span style="font-style:italic">LU</span>, inverse, déterminant...) : <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>3</sup>)
</li><li class="li-itemize">Multiplication rapide par blocs (Strassen) en <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>log(7)/log(2)</sup>),
que l’on peut généraliser au pivot de Gauss
</li></ul><p><span style="font-weight:bold">Remarques</span>
</p><ul class="itemize"><li class="li-itemize">
Attention, le cout est plus important si les coefficients sont entiers
ou rationnels.
</li><li class="li-itemize">Pour des matrices creuses, les couts sont estimés en fonction du nombre
de coefficients non nuls.
</li></ul>
<!--TOC subsection id="sec143" Codes linéaires et polynomiaux.-->
<h3 id="sec143" class="subsection">16.5  Codes linéaires et polynomiaux.</h3><!--SEC END --><p>
<a id="hevea_default168"></a> <a id="hevea_default169"></a>
<a id="hevea_default170"></a>
Les corps finis premiers servent dans tous les algorithmes modulaires,
on en a vu par exemple l’intérêt pour le PGCD, la factorisation...</p><p>Les corps finis premiers et non premiers servent aussi dans le
domaine de la cryptographie et des codes correcteurs d’erreurs, 
on présente ici ce dernier point.</p><p>Références : Demazure, G. Zémor, wikipedia (pour les codes de
Hamming binaires).</p><p>On appellera symbole d’information l’unité de base transmise, qu’on
supposera appartenir à un corps fini <span style="font-style:italic">K</span>, par
exemple pour un bit un élément de <span style="font-style:italic">K</span>=ℤ/2ℤ, ou pour un octet 
un élément du corps à 256 éléments <span style="font-style:italic">K</span>=<span style="font-style:italic">F</span><sub>256</sub>=<span style="font-style:italic">F</span><sub><span style="font-style:italic">d</span></sub>.</p><p>On veut coder un message de longueur <span style="font-style:italic">k</span> avec des possibilités
de détection et de correction d’erreurs, pour cela on rajoute
des symboles calculés à partir des précédents, 
on envoie un élément d’un code ayant <span style="font-style:italic">n</span> symboles.</p>
<!--TOC subsubsection id="sec144" Le bit de parité.-->
<h4 id="sec144" class="subsubsection">16.5.1  Le bit de parité.</h4><!--SEC END --><p><a id="hevea_default171"></a>
On prend <span style="font-style:italic">k</span>=7 bits et <span style="font-style:italic">n</span>=8 bits. On compte
le nombre de 1 parmi les 7 bits envoyés, si ce nombre est pair, 
on envoie 0 comme 8ième bit, sinon 1. 
Au final le nombre de bits à 1 de l’octet (1 octet=8 bits)
est pair. On peut ainsi détecter une erreur de transmission si
à la réception le nombre de bits d’un octet est impair, mais on
ne peut pas corriger d’erreurs.
On peut aussi dire que l’octet
représente un polynôme à coefficients dans ℤ/2ℤ divisible
par <span style="font-style:italic">X</span>+1.</p><p><span style="font-weight:bold">Exercice</span> :
Écrire un programme Xcas permettant de rajouter un bit de parité
à une liste composée de 7 bits. Puis un programme de vérification
qui accepte ou non un octet selon sa parité. Vous représenterez
l’octet par une liste de bits, avec le délimiteur <code>poly1[</code>
pour pouvoir effectuer des opérations arithmétiques polynomiales,
et vous effectuerez la vérification de deux manières, en comptant
le nombre de 1 ou avec l’instruction <code>rem</code>.</p>
<!--TOC subsubsection id="sec145" Codes linéaires-->
<h4 id="sec145" class="subsubsection">16.5.2  Codes linéaires</h4><!--SEC END --><p>
<span style="font-weight:bold">Définition</span> :
On multiplie le vecteur des <span style="font-style:italic">k</span> symboles par
une matrice <span style="font-style:italic">M</span> à coefficients dans <span style="font-style:italic">K</span> de taille <span style="font-style:italic">n</span> × <span style="font-style:italic">k</span>
et on transmet l’image.
Pour assurer qu’on peut identifier un antécédent
unique à partir d’une image, il faut que <span style="font-style:italic">M</span> corresponde 
à une application linéaire injective, ce qui entraine <span style="font-style:italic">n</span>≥ <span style="font-style:italic">k</span>. 
On dit qu’un vecteur de <span style="font-style:italic">n</span> symboles est un mot du code 
s’il est dans l’image de l’application linéaire.</p><p>Pour assurer l’injectivité tout en facilitant le décodage, 
on utilise souvent une matrice identité <span style="font-style:italic">k</span>,<span style="font-style:italic">k</span> comme sous-bloc
de la matrice <span style="font-style:italic">n</span>,<span style="font-style:italic">k</span>, par exemple on prend l’identité pour
les <span style="font-style:italic">k</span> premières lignes de <span style="font-style:italic">M</span>, on ajoute ensuite <span style="font-style:italic">n</span>−<span style="font-style:italic">k</span> lignes.</p><p>Pour savoir si un vecteur est un mot de code, il faut vérifier
qu’il est dans l’image de <span style="font-style:italic">M</span>. On peut par exemple vérifier
qu’en ajoutant la colonne de ses coordonnées à <span style="font-style:italic">M</span>, on ne change
pas le rang de <span style="font-style:italic">M</span> (qui doit être <span style="font-style:italic">k</span>) mais c’est assez couteux.
On préfère utiliser une matrice de controle <span style="font-style:italic">H</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span> ∈ Im(<span style="font-style:italic">M</span>) ⇔ <span style="font-style:italic">Hx</span>=0</td></tr>
</table><p>
Si la matrice <span style="font-style:italic">M</span> est composée de l’identité <span style="font-style:italic">I</span><sub><span style="font-style:italic">k</span></sub>
et d’une matrice <span style="font-style:italic">C</span> sur ses <span style="font-style:italic">n</span>−<span style="font-style:italic">k</span> dernières lignes, 
alors <span style="font-style:italic">H</span>=(−<span style="font-style:italic">C</span>,<span style="font-style:italic">I</span><sub><span style="font-style:italic">n</span>−<span style="font-style:italic">k</span></sub>).</p><p><span style="font-weight:bold">Exercice</span> : créez une matrice <span style="font-style:italic">M</span> de taille 7,4 injective. Puis
un programme qui teste si un vecteur est un mot de code et en
extrait alors la partie avant codage. Vérifiez votre programme
avec un vecteur <span style="font-style:italic">Mv</span>, on doit obtenir un mot de code.<br>
Instructions utiles : <code>idn</code> (matrice identité)
<code>ker</code> (noyau d’une application linéaire), <code>rank</code> (rang),
<code>tran</code> (tranposée), ... Pour créer une matrice, on peut coller
les lignes de 2 matrices <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> par <code>[op(A),op(B)]</code> ou avec
<code>blockmatrix</code>.</p>
<!--TOC subsubsection id="sec146" Codes polynomiaux-->
<h4 id="sec146" class="subsubsection">16.5.3  Codes polynomiaux</h4><!--SEC END --><p>
<span style="font-weight:bold">Définition</span> :
Il s’agit d’un cas particulier de codes linéaires.
On se donne un polynôme <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>) de degré <span style="font-style:italic">n</span>−<span style="font-style:italic">k</span>,
On représente le message de longueur <span style="font-style:italic">k</span> à coder par un polynôme 
<span style="font-style:italic">P</span> de degré <span style="font-style:italic">k</span>−1.
On multiplie <span style="font-style:italic">P</span> par <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>−<span style="font-style:italic">k</span></sup>, on calcule le reste <span style="font-style:italic">R</span> de la division
de <span style="font-style:italic">P</span> <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>−<span style="font-style:italic">k</span></sup> par <span style="font-style:italic">g</span>. On émet alors <span style="font-style:italic">P</span> <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>−<span style="font-style:italic">k</span></sup>−<span style="font-style:italic">R</span> qui est divisible
par <span style="font-style:italic">g</span>. Les mots de code sont les polynômes divisibles par <span style="font-style:italic">g</span>.</p><p><span style="font-weight:bold">Exercice</span> : écrire de cette façon le codage du bit de parité. Puis
une procédure Xcas de codage utilisant <span style="font-style:italic">g</span>=<span style="font-style:italic">X</span><sup>7</sup>+<span style="font-style:italic">X</span><sup>3</sup>+1 
(ce polynôme était utilisé par le Minitel).
N.B. on obtient le polynôme <span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span>−<span style="font-style:italic">k</span></sup> sous forme
de polynome-liste dans Xcas par <span style="font-family:monospace">poly1[1,0$(n-k)]</span>.</p>
<!--TOC subsubsection id="sec147" Détection et correction d’erreur-->
<h4 id="sec147" class="subsubsection">16.5.4  Détection et correction d’erreur</h4><!--SEC END --><p><a id="hevea_default172"></a>
Si le mot recu n’est pas dans l’image de l’application
linéaire il y a eu erreur de transmission. Sinon, il n’y
a pas eu d’erreur <em>détectable</em> (il pourrait y avoir eu plusieurs
erreurs qui se “compensent”).</p><p>Plutôt que de demander la réémission du mot mal transmis
(ce qui serait par exemple impossible en temps réel 
depuis un robot en orbite autour de Mars),
on essaie d’ajouter suffisamment d’information pour 
pouvoir corriger des erreurs en supposant
que leur nombre est majoré par <span style="font-style:italic">N</span>. 
Si les erreurs de
transmissions sont indépendantes, la probabilité d’avoir
au moins <span style="font-style:italic">N</span>+1 erreurs dans un message de longueur <span style="font-style:italic">L</span>
est ∑<sub><span style="font-style:italic">k</span>=<span style="font-style:italic">N</span>+1</sub><sup><span style="font-style:italic">L</span></sup> ( <sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">L</span></sup> ) є<sup><span style="font-style:italic">k</span></sup> (1−є)<sup><span style="font-style:italic">L</span>−<span style="font-style:italic">k</span></sup>, 
où є est la probabilité d’une erreur
de transmission, c’est aussi <code>1-binomial_cdf(L,epsilon,N)</code>. 
Par exemple, pour un message de 10<sup>3</sup> caractères,
chacun ayant une probabilité d’erreur de transmission de 10<sup>−3</sup>,
si on prend <span style="font-style:italic">N</span>=3, alors la probabilité d’avoir au moins 4 erreurs
est de 0.019 (arrondi par excès) :<br>
<code>P(N,eps,L):=sum(comb(L,k)*eps^k*(1-eps)^(L-k),k,N+1,L):;</code><br>
<code>P(3,1e-3,10^3)</code><br>
ou directement <code>1-binomial_cdf(1000,1e-3,3)</code>.</p><p><span style="font-weight:bold">Exemple</span> : On ne peut pas corriger d’erreur avec le bit de parité.</p>
<!--TOC subsubsection id="sec148" Distances-->
<h4 id="sec148" class="subsubsection">16.5.5  Distances</h4><!--SEC END --><p><a id="hevea_default173"></a> <a id="hevea_default174"></a>
La distance de Hamming de 2 mots est le nombre de symboles qui diffèrent.
(il s’agit bien d’une distance au sens mathématique, 
elle vérifie l’inégalité triangulaire). </p><p>Exercice : écrire une procédure de calcul de la distance de Hamming
de 2 mots. En Xcas, la fonction s’appelle <span style="font-family:monospace">hamdist</span>.</p><p>La distance d’un code est la distance de Hamming minimale
de 2 mots différents du code.
Pour un code linéaire, la distance est aussi le nombre minimal
de coefficients non nuls d’un vecteur non nul de l’image.
Pour un code polynomial, la distance du code
est le nombre minimal de coefficients non nuls d’un multiple
de <span style="font-style:italic">g</span> de degré inférieur à <span style="font-style:italic">n</span>.</p><p>Exercice : quelle est la distance du code linéaire que
vous avez créé plus haut ?</p><p><span style="font-weight:bold">Majoration de la distance du code:</span><br>
<a id="hevea_default175"></a>
La distance minimale d’un code linéaire est inférieure ou 
égale à <span style="font-style:italic">n</span>−<span style="font-style:italic">k</span>+1 : en effet on écrit en ligne les coordonnées
des images de la base canonique (ce qui revient à transposer la
matrice) et on réduit par le pivot de Gauss,
comme l’application linéaire est injective, le rang de la matrice
est <span style="font-style:italic">k</span>, donc la réduction de Gauss crée <span style="font-style:italic">k</span>−1
zéros dans chaque ligne, donc le nombre de coefficients non nuls
de ces <span style="font-style:italic">k</span> lignes (qui sont toujours des mots de code) est 
au plus de <span style="font-style:italic">n</span>−<span style="font-style:italic">k</span>+1.</p><p>Exercice : si votre code linéaire n’est pas de distance 3, modifiez
les 3 dernières lignes pour réaliser un code de distance 3. On
ne peut pas obtenir une distance <span style="font-style:italic">n</span>−<span style="font-style:italic">k</span>+1=4 avec <span style="font-style:italic">n</span>=7 et <span style="font-style:italic">k</span>=4 
dans ℤ/2ℤ, essayez! Essayez sur ℤ/3ℤ et ℤ/5ℤ.</p><p>N.B. : Pour les codes non
polynomiaux, par exemple convolutifs, la distance n’est pas
forcément le
paramètre le mieux adapté à la correction d’erreurs.</p>
<!--TOC subsubsection id="sec149" Correction au mot le plus proche-->
<h4 id="sec149" class="subsubsection">16.5.6  Correction au mot le plus proche</h4><!--SEC END --><p>
Une stratégie de correction basée sur la distance consiste à
trouver le mot de code le plus proche d’un mot donné.
Si la distance d’un code est supérieure ou égale
à 2<span style="font-style:italic">t</span>+1, et s’il existe un mot de code de distance inférieure
à <span style="font-style:italic">t</span> au mot donné, alors ce mot de code est unique.
On corrige alors le mot transmis en le remplaçant par le mot de code
le plus proche.</p><p>Exercice : écrivez un programme permettant de corriger une erreur
dans un mot dans votre code linéaire.</p><p>On dit qu’un code <span style="font-style:italic">t</span>-correcteur est parfait si la réunion des boules
de centre un mot de code et de rayon <span style="font-style:italic">t</span> (pour la distance de Hamming)
est disjointe et recouvre l’ensemble des mots (<span style="font-style:italic">K</span><sup><span style="font-style:italic">n</span></sup>).</p><p>Exercice : votre code linéaire sur ℤ/2ℤ (celui de distance 3) 
est-il un code 1-correcteur parfait ?</p>
<!--TOC subsubsection id="sec150" Codes de Hamming-->
<h4 id="sec150" class="subsubsection">16.5.7  Codes de Hamming</h4><!--SEC END --><p>
Soit un code de longueur <span style="font-style:italic">n</span>, de dimension <span style="font-style:italic">k</span>, le nombre
d’informations supplémentaires est noté <span style="font-style:italic">m</span>=<span style="font-style:italic">n</span>−<span style="font-style:italic">k</span>. Un code
de Hamming permet une correction, donc la distance du code
δ est (au moins) 3. Si le code est parfait sur <span style="font-style:italic">K</span>=<span style="font-style:italic">F</span><sub><span style="font-style:italic">d</span></sub>, on a 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(1+<span style="font-style:italic">n</span>(<span style="font-style:italic">d</span>−1))<span style="font-style:italic">d</span><sup><span style="font-style:italic">k</span></sup>=<span style="font-style:italic">d</span><sup><span style="font-style:italic">n</span></sup> ⇒ <span style="font-style:italic">n</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span><sup><span style="font-style:italic">m</span></sup>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>−1</td></tr>
</table></td></tr>
</table><p>Par exemple si <span style="font-style:italic">d</span>=2 et <span style="font-style:italic">m</span>=4 alors <span style="font-style:italic">n</span>=15. 
Il n’y a qu’une matrice de controle possible de taille
(15,4) telle que <span style="font-style:italic">Hx</span> donne la position de l’erreur (en base 2),
elle est obtenue en écrivant les entiers de 1 à 15 en base 2
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">H</span>=</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1
</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
on déplace les colonnes de la matrice identité 
(colonnes 1, 2, 4, 8)
en fin pour écrire <span style="font-style:italic">H</span>=(−<span style="font-style:italic">C</span>,<span style="font-style:italic">I</span><sub>4</sub>), le code correspondant est
( <sub><span style="font-style:italic">C</span></sub><sup><span style="font-style:italic">I</span><sub>11</sub></sup> ), il permet de corriger une erreur,
on calcule <span style="font-style:italic">Hx</span> et si le résultat est non nul, on change le
bit d’indice <span style="font-style:italic">Hx</span> en tenant compte du déplacement des colonnes
1, 2, 4 et 8. En fait, il est plus simple de ne pas faire ce
déplacement de colonnes.</p><p>Code systématique : 
</p><ol class="enumerate" type=1><li class="li-enumerate">
On repère les indices de bit en commençant
à 1
</li><li class="li-enumerate">On écrit les indices de bit en base 2
</li><li class="li-enumerate">Les bits dont les indices sont des puissance de 2
sont des bits de parité
</li><li class="li-enumerate">Les autres bits sont des bits de donnée
</li><li class="li-enumerate">Les bits de parité sont calculés pour avoir parité
paire selon les bits d’indice respectifs 1 mod 2 pour le bit de
parité p1, selon les bits d’indice divisé par 2 valant 1 mod 2 pour le bit de parité p2, etc.
</li><li class="li-enumerate">Pour corriger une erreur, on corrige le bit dont la position
écrite en base 2 a des 1 là où la parité est fausse.
</li></ol><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:right;border:solid 1px;white-space:nowrap" >Indice</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >3</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >4</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >5</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >6</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >7</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >8</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >9</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >10</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >11</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >12</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >13</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >14</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >15 </td></tr>
<tr><td style="text-align:right;border:solid 1px;white-space:nowrap" >p1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x </td></tr>
<tr><td style="text-align:right;border:solid 1px;white-space:nowrap" >p2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x </td></tr>
<tr><td style="text-align:right;border:solid 1px;white-space:nowrap" >p4</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x </td></tr>
<tr><td style="text-align:right;border:solid 1px;white-space:nowrap" >p8</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x </td></tr>
<tr><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >p1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >p2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >p4</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d3</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d4</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >p8</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d5</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d6</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d7</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d8</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d9</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d10</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d11 </td></tr>
</table><p>Autre exemple : le minitel utilisait <span style="font-style:italic">d</span>=2, <span style="font-style:italic">m</span>=7, <span style="font-style:italic">n</span>=2<sup><span style="font-style:italic">m</span></sup>−1.</p>
<!--TOC subsection id="sec151" Les codes de Reed-Solomon-->
<h3 id="sec151" class="subsection">16.6  Les codes de Reed-Solomon</h3><!--SEC END --><p><a id="hevea_default176"></a>
Il s’agit de codes polynomiaux qui réalisent la distance maximale
possible <span style="font-style:italic">n</span>−<span style="font-style:italic">k</span>+1. De plus la recherche du mot de code le plus
proche peut se faire par un algorithme de Bézout avec arrêt 
prématuré.</p>
<!--TOC subsubsection id="sec152" Théorie-->
<h4 id="sec152" class="subsubsection">16.6.1  Théorie</h4><!--SEC END --><p>
On se donne un générateur <span style="font-style:italic">a</span> 
de <span style="font-style:italic">F</span><sub><span style="font-style:italic">q</span></sub><sup>*</sup> et le polynôme <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>)=(<span style="font-style:italic">x</span>−<span style="font-style:italic">a</span>)...(<span style="font-style:italic">x</span>−<span style="font-style:italic">a</span><sup>2<span style="font-style:italic">t</span></sup>) (donc <span style="font-style:italic">n</span>−<span style="font-style:italic">k</span>=2<span style="font-style:italic">t</span>). 
Typiquement <span style="font-style:italic">q</span>=2<sup><span style="font-style:italic">m</span></sup> avec <span style="font-style:italic">m</span>=8, 
<span style="font-style:italic">a</span> est une racine d’un polynôme irréductible
de degré <span style="font-style:italic">m</span> à coefficients dans ℤ/2 
qui ne divise pas <span style="font-style:italic">x</span><sup><span style="font-style:italic">l</span></sup>−1 pour <span style="font-style:italic">l</span> diviseur
strict de 2<sup><span style="font-style:italic">m</span></sup>−1, en pratique, on factorise le quotient de <span style="font-style:italic">x</span><sup>2<sup><span style="font-style:italic">m</span></sup>−1</sup>−1
par le ppcm des <span style="font-style:italic">x</span><sup>(2<sup><span style="font-style:italic">m</span></sup>−1)/<span style="font-style:italic">p</span></sup>−1 où <span style="font-style:italic">p</span> parcourt les
diviseurs premiers de 2<sup><span style="font-style:italic">m</span></sup>−1 et on en extrait un facteur de degré <span style="font-style:italic">m</span>.</p><p><span style="font-weight:bold">Distance du code</span><br>
Si la longueur <span style="font-style:italic">n</span> d’un mot vérifie
<span style="font-style:italic">n</span> ≤ 2<sup><span style="font-style:italic">m</span></sup>−1, alors la distance entre 2 mots du code est au moins
de 2<span style="font-style:italic">t</span>+1.
En effet, si un polynome <span style="font-style:italic">P</span> de degré &lt;<span style="font-style:italic">n</span> est un multiple de <span style="font-style:italic">g</span>
ayant moins de 2<span style="font-style:italic">t</span>+1 coefficients non nuls,
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">t</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup>,    <span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub>&lt;<span style="font-style:italic">n</span> </td></tr>
</table><p>
en écrivant <span style="font-style:italic">P</span>(<span style="font-style:italic">a</span>)=...=<span style="font-style:italic">P</span>(<span style="font-style:italic">a</span><sup>2<span style="font-style:italic">t</span></sup>)=0, on obtient
un déterminant de Van der Monde, on prouve qu’il est non nul en
utilisant la condition <span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub>&lt;<span style="font-style:italic">n</span> et le fait que la première puissance
de <span style="font-style:italic">a</span> telle que <span style="font-style:italic">a</span><sup><span style="font-style:italic">x</span></sup>=1 est <span style="font-style:italic">x</span>=2<sup><span style="font-style:italic">m</span></sup>−1.</p><p><span style="font-weight:bold">Correction des erreurs</span><br>
Soit <span style="font-style:italic">c</span>(<span style="font-style:italic">x</span>) le polynome envoyé, <span style="font-style:italic">d</span>(<span style="font-style:italic">x</span>)
le polynôme recu, on suppose qu’il y a moins de <span style="font-style:italic">t</span> erreurs
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">d</span>(<span style="font-style:italic">x</span>)−<span style="font-style:italic">c</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">e</span>(<span style="font-style:italic">x</span>)= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ν</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell">α<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup>,    ν ≤ <span style="font-style:italic">t</span></td></tr>
</table><p>
On calcule le polynome syndrome :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>)= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">t</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=0</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">d</span>(<span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span>+1</sup>) <span style="font-style:italic">x</span><sup><span style="font-style:italic">i</span></sup>= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">t</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=0</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">e</span>(<span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span>+1</sup>) <span style="font-style:italic">x</span><sup><span style="font-style:italic">i</span></sup> </td></tr>
</table><p>
on a donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">t</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=0</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ν</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell">α<sub><span style="font-style:italic">k</span></sub> (<span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span>+1</sup>)<sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup> <span style="font-style:italic">x</span><sup><span style="font-style:italic">i</span></sup> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ν</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell">α<sub><span style="font-style:italic">k</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">t</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=0</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span>+1</sup>)<sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup> <span style="font-style:italic">x</span><sup><span style="font-style:italic">i</span></sup></td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ν</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell">α<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup><span style="font-style:italic">x</span>)<sup>2<span style="font-style:italic">t</span></sup>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup><span style="font-style:italic">x</span>−1</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
On pose <span style="font-style:italic">l</span>(<span style="font-style:italic">x</span>) le produit des dénominateurs (que l’on appelle polynôme
localisateur, car ses racines permettent de trouver la position
des symboles à corriger), on a alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:lsw"></a>
<span style="font-style:italic">l</span>(<span style="font-style:italic">x</span>) <span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>) = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ν</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell">α<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup> ( (<span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup><span style="font-style:italic">x</span>)<sup>2<span style="font-style:italic">t</span></sup> −1 )
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span>, <span style="font-style:italic">j</span> ∈ [1,ν]</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">j</span></sub></sup><span style="font-style:italic">x</span> −1) 
    (17)</td></tr>
</table><p>
Modulo <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">t</span></sup>, <span style="font-style:italic">l</span>(<span style="font-style:italic">x</span>)<span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>) est donc un polynôme <span style="font-style:italic">w</span> de degré inférieur
ou égal à ν −1, donc strictement inférieur à <span style="font-style:italic">t</span>.
Pour le calculer, on applique l’algorithme de Bézout à <span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>)
et <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">t</span></sup> (dans <span style="font-style:italic">F</span><sub><span style="font-style:italic">q</span></sub>), en s’arrêtant au premier reste <span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>)
dont le degré est strictement inférieur à <span style="font-style:italic">t</span> (au lieu
d’aller jusqu’au calcul du PGCD de <span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>) et <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">t</span></sup>).
Les relations sur les degrés (cf. approximants de Padé et
la preuve ci-dessous) donnent
alors en coefficient de <span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>) le polynôme <span style="font-style:italic">l</span>(<span style="font-style:italic">x</span>) de degré inférieur ou
égal à <span style="font-style:italic">t</span>. On en calcule les racines (en testant tous les éléments
du corps avec Horner), donc la place des symboles erronés.</p><p>Pour calculer les valeurs α<sub><span style="font-style:italic">k</span></sub>, on reprend la définition de <span style="font-style:italic">w</span>,
c’est le terme de droite de l’équation (<a href="#eq%3Alsw">17</a>) modulo <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">t</span></sup>,
donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ν</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell">α<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup> (−1)
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span>, <span style="font-style:italic">j</span> ∈ [1,ν]</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">j</span></sub></sup><span style="font-style:italic">x</span>−1) </td></tr>
</table><p>
Donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">w</span>(<span style="font-style:italic">a</span><sup>−<span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup>) = − α<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup>  
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span>, <span style="font-style:italic">j</span> ∈ [1,ν]</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">j</span></sub></sup> <span style="font-style:italic">a</span><sup>−<span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup> −1) </td></tr>
</table><p>
Comme :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">l</span>(<span style="font-style:italic">x</span>)=(<span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup><span style="font-style:italic">x</span>−1)</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span>, <span style="font-style:italic">j</span> ∈ [1,ν]</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">j</span></sub></sup><span style="font-style:italic">x</span>−1) </td></tr>
</table><p>
on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">l</span>′(<span style="font-style:italic">a</span><sup>−<span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup>)=<span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span>, <span style="font-style:italic">j</span> ∈ [1,ν]</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">a</span><sup><span style="font-style:italic">i</span><sub><span style="font-style:italic">j</span></sub></sup><span style="font-style:italic">a</span><sup>−<span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup>−1) </td></tr>
</table><p>
Finalement :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">α<sub><span style="font-style:italic">k</span></sub> = −</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">w</span>(<span style="font-style:italic">a</span><sup>−<span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span>′(<span style="font-style:italic">a</span><sup>−<span style="font-style:italic">i</span><sub><span style="font-style:italic">k</span></sub></sup>)</td></tr>
</table></td><td class="dcell"> </td></tr>
</table>
<!--TOC subsubsection id="sec153" Preuve du calcul de <span style="font-style:italic">l</span>-->
<h4 id="sec153" class="subsubsection">16.6.2  Preuve du calcul de <span style="font-style:italic">l</span></h4><!--SEC END --><p>
On avait <span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>) avec deg(<span style="font-style:italic">s</span>)&lt;=2<span style="font-style:italic">t</span>−1,
il s’agissait de voir comment la solution <span style="font-style:italic">u</span>,<span style="font-style:italic">v</span>,<span style="font-style:italic">r</span> calculee par Bezout
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">   <a id="eq:loc"></a>
<span style="font-style:italic">u</span>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">t</span></sup>+ <span style="font-style:italic">v</span>(<span style="font-style:italic">x</span>) <span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">r</span>(<span style="font-style:italic">x</span>) 
    (18)</td></tr>
</table><p>
avec arrêt prématuré au 1er reste <span style="font-style:italic">r</span>(<span style="font-style:italic">x</span>) de degré &lt;=<span style="font-style:italic">t</span>−1 
correspondait à l’équation
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">l</span>(<span style="font-style:italic">x</span>) <span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>) <span style="font-style:italic">mod</span> <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">t</span></sup> </td></tr>
</table><p>
avec deg(<span style="font-style:italic">l</span>)&lt;=<span style="font-style:italic">t</span> et deg(<span style="font-style:italic">w</span>)&lt;=<span style="font-style:italic">t</span>−1</p><p>On a vu que deg(<span style="font-style:italic">v</span>)&lt;=<span style="font-style:italic">t</span>.
On commence par factoriser la puissance de <span style="font-style:italic">x</span> de degré maximal <span style="font-style:italic">p</span> dans
<span style="font-style:italic">v</span>(<span style="font-style:italic">x</span>), et on simplifie (<a href="#eq%3Aloc">18</a>) par <span style="font-style:italic">x</span><sup><span style="font-style:italic">p</span></sup>. 
Quitte à changer <span style="font-style:italic">v</span> et <span style="font-style:italic">r</span>, on se
ramene donc à:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">t</span>−<span style="font-style:italic">p</span></sup>+ <span style="font-style:italic">v</span>(<span style="font-style:italic">x</span>) <span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">r</span>(<span style="font-style:italic">x</span>) </td></tr>
</table><p>
avec <span style="font-style:italic">v</span>(<span style="font-style:italic">x</span>) premier avec <span style="font-style:italic">x</span>, deg(<span style="font-style:italic">v</span>)&lt;= <span style="font-style:italic">t</span>−<span style="font-style:italic">p</span> et deg(<span style="font-style:italic">r</span>)&lt;= <span style="font-style:italic">t</span>−1−<span style="font-style:italic">p</span>.
On simplifie ensuite par le pgcd de <span style="font-style:italic">v</span>(<span style="font-style:italic">x</span>) et de <span style="font-style:italic">r</span>(<span style="font-style:italic">x</span>)
(qui divise <span style="font-style:italic">u</span>(<span style="font-style:italic">x</span>) car premier avec <span style="font-style:italic">x</span> puisqu’on a déjà traité les
puissances de <span style="font-style:italic">x</span>).
On a donc, quitte à changer de notation <span style="font-style:italic">u</span>,<span style="font-style:italic">v</span>,<span style="font-style:italic">r</span> tels que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">t</span>−<span style="font-style:italic">p</span></sup>+ <span style="font-style:italic">v</span>(<span style="font-style:italic">x</span>) <span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">r</span>(<span style="font-style:italic">x</span>) </td></tr>
</table><p>
avec <span style="font-style:italic">v</span> et <span style="font-style:italic">r</span> premiers entre eux, <span style="font-style:italic">v</span> premier avec <span style="font-style:italic">x</span>,
deg(<span style="font-style:italic">v</span>)&lt;=<span style="font-style:italic">t</span>−<span style="font-style:italic">p</span> et deg(<span style="font-style:italic">r</span>)&lt;=<span style="font-style:italic">t</span>−1−<span style="font-style:italic">p</span> (N.B.: <span style="font-style:italic">p</span>=0 en general)</p><p>On observe que <span style="font-style:italic">l</span>(<span style="font-style:italic">x</span>) est premier avec <span style="font-style:italic">x</span> (0 n’est pas racine de <span style="font-style:italic">l</span>).
On raisonne modulo <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">t</span>−<span style="font-style:italic">p</span></sup>, <span style="font-style:italic">l</span> et <span style="font-style:italic">v</span> sont inversibles modulo <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">t</span>−<span style="font-style:italic">p</span></sup>,
donc 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>)*<span style="font-style:italic">inv</span>(<span style="font-style:italic">l</span>) (mod  <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">t</span>−<span style="font-style:italic">p</span></sup> ),
   <span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">r</span>(<span style="font-style:italic">x</span>)*<span style="font-style:italic">inv</span>(<span style="font-style:italic">v</span>) (mod <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">t</span>−<span style="font-style:italic">p</span></sup> ) </td></tr>
</table><p>
donc 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>)*<span style="font-style:italic">inv</span>(<span style="font-style:italic">l</span>)=<span style="font-style:italic">r</span>(<span style="font-style:italic">x</span>)*<span style="font-style:italic">inv</span>(<span style="font-style:italic">v</span>) (mod <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">t</span>−<span style="font-style:italic">p</span></sup> ) 
   ⇒    <span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>)*<span style="font-style:italic">v</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">r</span>(<span style="font-style:italic">x</span>)*<span style="font-style:italic">l</span>(<span style="font-style:italic">x</span>) (mod <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">t</span>−<span style="font-style:italic">p</span></sup> ) </td></tr>
</table><p>
donc <span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>)*<span style="font-style:italic">v</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">r</span>(<span style="font-style:italic">x</span>)*<span style="font-style:italic">l</span>(<span style="font-style:italic">x</span>) à cause des majorations de degres</p><p>D’autre part par construction <span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>) est premier avec <span style="font-style:italic">l</span>(<span style="font-style:italic">x</span>) (car chacun
des facteurs de <span style="font-style:italic">l</span>(<span style="font-style:italic">x</span>) divise tous les éléments de la somme définissant
<span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>) sauf un), donc <span style="font-style:italic">l</span>(<span style="font-style:italic">x</span>) divise <span style="font-style:italic">v</span>(<span style="font-style:italic">x</span>), et comme <span style="font-style:italic">v</span>(<span style="font-style:italic">x</span>) est premier
avec <span style="font-style:italic">r</span>(<span style="font-style:italic">x</span>), on en déduit que <span style="font-style:italic">v</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">C</span> <span style="font-style:italic">l</span>(<span style="font-style:italic">x</span>) où <span style="font-style:italic">C</span> est une constante non
nulle, puis <span style="font-style:italic">r</span>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">C</span> <span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>).</p><p>Bezout donne donc (après simplifications du couple <span style="font-style:italic">v</span>(<span style="font-style:italic">x</span>), <span style="font-style:italic">r</span>(<span style="font-style:italic">x</span>) par
son pgcd) le polynome localisateur à une constante près (donc les
racines et les positions des erreurs), et on peut calculer
les valeurs des erreurs avec <span style="font-style:italic">v</span> et <span style="font-style:italic">r</span> car la constante <span style="font-style:italic">C</span> se simplifie.</p>
<!--TOC subsubsection id="sec154" Avec Xcas-->
<h4 id="sec154" class="subsubsection">16.6.3  Avec Xcas</h4><!--SEC END --><p>
Ouvrir la session <code>Aide-&gt;Exemples-&gt;crypto-&gt;reed_s</code></p>
<!--TOC section id="sec155" Factorisation des entiers et primalité.-->
<h2 id="sec155" class="section">17  Factorisation des entiers et primalité.</h2><!--SEC END --><p> <a id="sec:ifactor"></a>
<a id="hevea_default177"></a>
Les principaux algorithmes utilisés dans Xcas sont les suivants :
</p><ul class="itemize"><li class="li-itemize">
la division : pour les nombres premiers plus petits que 10000,
stockés dans une table. Cela permet de factoriser les entiers
plus petits que 10<sup>10</sup> et de détecter les premiers, on teste
si <span style="font-style:italic">k</span> divise <span style="font-style:italic">N</span> pour <span style="font-style:italic">k</span> dans la table tel que <span style="font-style:italic">k</span><sup>2</sup>≤ <span style="font-style:italic">N</span>.
Cela permet la factorisation partielle des entiers plus grands.
Le temps d’exécution est proportionnel au nombre de premiers
dans la table plus petits que √<span style="text-decoration:overline"><span style="font-style:italic">N</span></span>, multiplié par un facteur
ln(<span style="font-style:italic">N</span>) pour la factorisation partielle.
</li><li class="li-itemize">Le <span style="font-weight:bold">crible</span> d’Eratosthène<a id="hevea_default178"></a> permet de trouver la liste des premiers
plus petits qu’une valeur donnée <span style="font-style:italic">n</span>. On écrit tous les entiers dans
une table, on barre les multiples de 2, puis les multiples du premier
entier non barré (qui est premier), puis etc. et on s’arrête
lorsque le premier entier non barré au carré est strictement plus
grand que <span style="font-style:italic">n</span>.
On montre facilement que la complexité de <code>crible(n)</code> est
celle du nombre de cases que l’on barre dans la boucle 
<code>for (j:=p*p;j&lt;=n;j+=p)</code>
elle est majorée par 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">+...+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td></tr>
</table>
où <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> est le dernier nombre premier inférieur ou égal à
√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>, que l’on peut facilement majorer par <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span> ln(<span style="font-style:italic">n</span>)) puisque
la somme des inverses des premiers est inférieure à la somme des
inverses jusque √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>. Une analyse plus fine donne une majoration
en <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span> ln(ln(<span style="font-style:italic">n</span>))), en pratique l’obstacle principal au crible reste la taille
mémoire nécessaire au calcul qui empêche de dépasser des
valeurs de <span style="font-style:italic">n</span> de l’ordre du milliard.
</li><li class="li-itemize">le test de pseudo-primalité de <span style="font-weight:bold">Miller-Rabin</span><a id="hevea_default179"></a><a id="hevea_default180"></a> (voir
le manuel de programmation de Xcas) : effectué
pour 20 bases <span style="font-style:italic">a</span>, il donne en cas de réussite la primalité
pour les entiers plus petits que 10<sup>14</sup>, au-delà le nombre
est très probablement premier (moins de 1/4<sup>20</sup> malchance
d’avoir un non premier au sens où le nombre de bases <span style="font-style:italic">a</span>&lt;<span style="font-style:italic">p</span> qui passent
le test alors que le nombre <span style="font-style:italic">p</span> n’est pas premier est plus petit
que <span style="font-style:italic">p</span>/4). Si on veut certifier qu’un nombre est premier, on peut 
utiliser le test de Pocklington (voir la section
dédiée) ou le test APRCL via PARI.
</li><li class="li-itemize">la méthode ρ de Pollard qui permet de trouver
les“petits” facteurs d’un entier <span style="font-style:italic">N</span> (plus petits que
10<sup>10</sup> environ). Cette méthode est détaillée plus bas.
La commande <code>ifactor</code> de PARI permet de détecter
des “petits” facteurs de plus grande taille par la méthode
des courbes elliptiques (ECM, cf. Cohen par exemple). Pollard-ρ
et ECM sont des méthodes de factorisation de type I, dont le
temps d’exécution est fonction de la taille du plus petit facteur
de l’entier à factoriser (supposé non premier).
</li><li class="li-itemize">le crible quadratique qui permet de factoriser
en un temps raisonnable les entiers jusqu’à 10<sup>70</sup> environ.
Une esquisse de cette méthode est présentée plus bas.
Cette méthode est dite de type II, son temps d’exécution
est fonction de la taille de l’entier.
</li></ul><pre class="verbatim">crible(n):={
  local tab,prem,p;
  tab:=seq(j,j,0,n);
  prem:=[];
  tab[0]=&lt;0; tab[1]=&lt;0;
  p:=2;
  while (p*p&lt;=n) {
    for (j:=p*p;j&lt;=n;j+=p){
      tab[j]=&lt;0;
    }
    p:=p+1;
    //afficher(tab);
    while ((p*p&lt;=n) and (tab[p]==0)) {
      p:=p+1;
    } 
  }
  for (j:=2;j&lt;=n;j++) {
    if (tab[j]!=0) { 
      prem:=append(prem,j);
    }
  } 
  return(prem);
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;t.value=tmp;tmp=UI.caseval(tmp);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML);field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>


<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">crible(100)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p>
<!--TOC subsection id="sec156" Le test de primalité de Pocklington.-->
<h3 id="sec156" class="subsection">17.1  Le test de primalité de Pocklington.</h3><!--SEC END --><p><a id="hevea_default181"></a> <a id="hevea_default182"></a>
</p><div class="theorem"><span style="font-weight:bold">Théorème 30</span>  <em>
Soit </em><span style="font-style:italic">N</span>&gt;1<em> entier. S’il existe deux entiers </em><span style="font-style:italic">a</span><em> et </em><span style="font-style:italic">q</span><em> tels que
</em><ul class="itemize"><li class="li-itemize"><em>
</em><span style="font-style:italic">q</span><em> est un facteur premier de </em><span style="font-style:italic">N</span>−1<em> plus grand que </em>√<span style="text-decoration:overline"><span style="font-style:italic">N</span></span>−1<em>,
</em></li><li class="li-itemize"><span style="font-style:italic">a</span><sup><span style="font-style:italic">N</span>−1</sup>=1 (mod <span style="font-style:italic">N</span> )<em>
</em></li><li class="li-itemize"><span style="font-style:italic">a</span><sup>(<span style="font-style:italic">N</span>−1)/<span style="font-style:italic">q</span></sup>−1<em> est premier avec </em><span style="font-style:italic">N</span><em>
</em></li></ul><em>
alors </em><span style="font-style:italic">N</span><em> est premier.
</em></div><p>
Preuve : Si <span style="font-style:italic">N</span> n’est pas premier, alors il a un facteur premier
<span style="font-style:italic">p</span>≤ √<span style="text-decoration:overline"><span style="font-style:italic">N</span></span>. Donc <span style="font-style:italic">q</span> et <span style="font-style:italic">p</span>−1 sont premiers entre eux
(car <span style="font-style:italic">q</span> est premier et <span style="font-style:italic">q</span>&gt;<span style="font-style:italic">p</span>−1). Soit <span style="font-style:italic">u</span> l’inverse de <span style="font-style:italic">q</span> modulo
<span style="font-style:italic">p</span>−1. Alors 1=<span style="font-style:italic">a</span><sup><span style="font-style:italic">N</span>−1</sup> (mod <span style="font-style:italic">p</span> ) car <span style="font-style:italic">p</span> divise <span style="font-style:italic">N</span>. Donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">1=<span style="font-style:italic">a</span><sup><span style="font-style:italic">u</span>(<span style="font-style:italic">N</span>−1)</sup> (mod <span style="font-style:italic">p</span> ) = </td><td class="dcell">⎛<br>
⎝</td><td class="dcell"><span style="font-style:italic">a</span><sup><span style="font-style:italic">uq</span></sup></td><td class="dcell">⎞<br>
⎠</td><td class="dcell"><sup>(<span style="font-style:italic">N</span>−1)/<span style="font-style:italic">q</span></sup> (mod <span style="font-style:italic">p</span> ) =
<span style="font-style:italic">a</span><sup>(<span style="font-style:italic">N</span>−1)/<span style="font-style:italic">q</span></sup> (mod <span style="font-style:italic">p</span> )</td></tr>
</table><p>
d’après le petit théorème de Fermat. Ceci contredit 
le fait que <span style="font-style:italic">a</span><sup>(<span style="font-style:italic">N</span>−1)/<span style="font-style:italic">q</span></sup>−1 soit premier avec <span style="font-style:italic">N</span>.</p><p>Le couple (<span style="font-style:italic">a</span>,<span style="font-style:italic">q</span>) est alors un 
<span style="font-weight:bold">certificat de primalité</span><a id="hevea_default183"></a><a id="hevea_default184"></a> pour <span style="font-style:italic">N</span>.
Le problème c’est que trouver <span style="font-style:italic">a</span>,<span style="font-style:italic">q</span> peut être très difficile
voire impossible. Mais il existe une généralisation de ce
théorème qui est plus facile à réaliser
</p><div class="theorem"><span style="font-weight:bold">Théorème 31</span>  <em>
Supposons que l’on sache factoriser </em><span style="font-style:italic">N</span>−1=<span style="font-style:italic">AB</span><em> comme produit de deux entiers
premiers entre eux avec </em><span style="font-style:italic">A</span>&gt;√<span style="text-decoration:overline"><span style="font-style:italic">N</span></span><em> dont la factorisation en produit
de facteurs premiers est connue. Si pour tout facteur </em><span style="font-style:italic">p</span><em> de </em><span style="font-style:italic">A</span><em> il
existe un entier </em><span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub><em> tel que </em><span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub><sup><span style="font-style:italic">N</span>−1</sup>=1 (mod <span style="font-style:italic">N</span> )<em> et
</em><span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub><sup>(<span style="font-style:italic">N</span>−1)/<span style="font-style:italic">p</span></sup>−1<em> et </em><span style="font-style:italic">N</span><em> sont premiers entre eux, alors </em><span style="font-style:italic">N</span><em> est premier.
</em></div><p>
Preuve : soit <span style="font-style:italic">v</span> un facteur premier de <span style="font-style:italic">N</span>. 
Soit <span style="font-style:italic">p</span> premier divisant <span style="font-style:italic">A</span> et <span style="font-style:italic">p</span><sup><span style="font-style:italic">e</span></sup> la plus grande
puissance de <span style="font-style:italic">p</span> divisant <span style="font-style:italic">A</span>. On va montrer que <span style="font-style:italic">v</span>=1 (mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">e</span></sup> ).
Par le lemme chinois on en déduira <span style="font-style:italic">v</span>=1 (mod <span style="font-style:italic">A</span> ) puis <span style="font-style:italic">v</span>&gt;√<span style="text-decoration:overline"><span style="font-style:italic">N</span></span>
ce qui est impossible pour au moins un facteur premier de <span style="font-style:italic">N</span>.<br>
Montrons donc que <span style="font-style:italic">v</span>=1 (mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">e</span></sup> ). Soit <span style="font-style:italic">b</span>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub><sup>(<span style="font-style:italic">N</span>−1)/<span style="font-style:italic">p</span><sup><span style="font-style:italic">e</span></sup></sup> (mod <span style="font-style:italic">v</span> ). Alors <span style="font-style:italic">b</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">e</span></sup></sup>=1 (mod <span style="font-style:italic">v</span> )
puisque <span style="font-style:italic">v</span> divise <span style="font-style:italic">N</span> et <span style="font-style:italic">b</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">e</span>−1</sup></sup> = <span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub><sup>(<span style="font-style:italic">N</span>−1)/<span style="font-style:italic">p</span></sup> (mod <span style="font-style:italic">v</span> ) ≠ 1
(mod <span style="font-style:italic">v</span> ) puisque <span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub><sup>(<span style="font-style:italic">N</span>−1)/<span style="font-style:italic">p</span></sup>−1 et <span style="font-style:italic">N</span> sont premiers entre eux.
Donc l’ordre de <span style="font-style:italic">b</span> modulo <span style="font-style:italic">v</span> est <span style="font-style:italic">p</span><sup><span style="font-style:italic">e</span></sup>, et <span style="font-style:italic">p</span><sup><span style="font-style:italic">e</span></sup> divise <span style="font-style:italic">v</span>−1 CQFD.</p><p>Ce test nécessite de savoir factoriser <span style="font-style:italic">N</span>−1, au moins
partiellement. Pour des <span style="font-style:italic">N</span> grands, cela peut nécessiter
de certifier que les facteurs obtenus sont eux-même premiers,
ce qui peut nécessiter une sorte d’appel récursif du test. C’est
l’étape difficile, la recherche des <span style="font-style:italic">a</span><sub><span style="font-style:italic">p</span></sub> n’est pas un blocage en pratique.</p>
<!--TOC subsection id="sec157" La méthode ρ de Pollard-->
<h3 id="sec157" class="subsection">17.2  La méthode ρ de Pollard</h3><!--SEC END --><p> <a id="hevea_default185"></a>
<span style="font-weight:bold">Théorème des anniversaires </span>: la probabilité que <span style="font-style:italic">n</span> éléments pris au
hasard parmi <span style="font-style:italic">N</span> soient distincts 2 à 2 pour 
<span style="font-style:italic">n</span>=<span style="font-style:italic">a</span> √<span style="text-decoration:overline">(</span><span style="font-style:italic">N</span>)) et <span style="font-style:italic">N</span>→ ∞ 
est équivalente à <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">a</span><sup>2</sup>/2</sup>, 
et peut donc être rendue arbitrairement petite.</p><p>En effet, cette probabilité vaut
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>=1(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell">)(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell">)...(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell">)</td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">−ln(<span style="font-style:italic">P</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"> −ln(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell">)  </td></tr>
</table><p>
on reconnait une méthode de rectangles pour approcher ∫
−ln(1−<span style="font-style:italic">t</span>), fonction croissante positive sur ℝ<sup>+</sup> d’où l’encadrement
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> −ln(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell">)   <span style="font-style:italic">dt</span> ≤ −ln(<span style="font-style:italic">P</span>) ≤
</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">1</td></tr>
</table></td><td class="dcell"> −ln(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell">)    <span style="font-style:italic">dt</span> </td></tr>
</table><p>
On intègre par parties, en posant −1=(<span style="font-style:italic">N</span>−<span style="font-style:italic">t</span>)′ 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell">−ln(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell">)   <span style="font-style:italic">dt</span> 
= (<span style="font-style:italic">N</span>−<span style="font-style:italic">t</span>) ln(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell">) + </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"> <span style="font-style:italic">dt</span> 
= (<span style="font-style:italic">N</span>−<span style="font-style:italic">t</span>) ln(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell">) + <span style="font-style:italic">t</span> </td></tr>
</table><p>
Si <span style="font-style:italic">t</span>/<span style="font-style:italic">N</span>=<span style="font-style:italic">o</span>(1) la primitive vaut :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">N</span>−<span style="font-style:italic">t</span>)(−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">N</span><sup>2</sup></td></tr>
</table></td><td class="dcell">+<span style="font-style:italic">O</span>(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span><sup>3</sup></td></tr>
</table></td><td class="dcell">)+<span style="font-style:italic">t</span>
=−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell"> + <span style="font-style:italic">O</span>(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span><sup>2</sup></td></tr>
</table></td><td class="dcell">) </td></tr>
</table><p>
Donc pour <span style="font-style:italic">n</span>=<span style="font-style:italic">a</span>√<span style="text-decoration:overline"><span style="font-style:italic">N</span></span>, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">+ <span style="font-style:italic">O</span>(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell"><sup>−1</sup>)
≤ −ln(<span style="font-style:italic">P</span>) 
≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">+ <span style="font-style:italic">O</span>(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell"><sup>−1</sup>)</td></tr>
</table><p>
d’où le résultat annoncé.</p><p><span style="font-weight:bold">Application </span>: si <span style="font-style:italic">n</span> est composé, on prend des entiers modulo <span style="font-style:italic">n</span>
générés par une suite 
récurrente <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>) (mod <span style="font-style:italic">n</span> ), 
on espère qu’ils ont de bonne propriétés de répartition, 
et on regarde s’ils sont distincts modulo <span style="font-style:italic">p</span> où <span style="font-style:italic">p</span> est 
le plus petit facteur de <span style="font-style:italic">n</span>. Il suffira d’en générer 
<span style="font-style:italic">O</span>(√<span style="text-decoration:overline"><span style="font-style:italic">p</span></span>) pour avoir une bonne proba d’en trouver 
deux égaux modulo <span style="font-style:italic">p</span>. 
Comme on ne connait pas <span style="font-style:italic">p</span>, le test d’égalité modulo <span style="font-style:italic">p</span> 
se fait en calculant le pgcd de <span style="font-style:italic">n</span> et
de la différence des 2 entiers modulo <span style="font-style:italic">n</span>,
qui doit être non trivial. 
La fonction <span style="font-style:italic">f</span> peut par exemple être <span style="font-style:italic">x</span> → <span style="font-style:italic">x</span><sup>2</sup>+1 
(ou <span style="font-style:italic">x</span><sup>2</sup>−1 ou <span style="font-style:italic">x</span><sup>2</sup>+3)<sup><a id="text27" href="#note27">27</a></sup>. 
On ne teste pas toutes les différences de paires d’entiers générés,
car ce serait trop long,
mais les <span style="font-style:italic">x</span><sub>2<span style="font-style:italic">k</span></sub>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub> pour <span style="font-style:italic">k</span>=1,2,... 
ce qui suffit car la suite <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub> est ultimement périodique 
(le dessin d’une suite ultimement périodique est un ρ
d’où la méthode tire son nom). 
Le calcul nécessite donc <span style="font-style:italic">O</span>(√<span style="text-decoration:overline"><span style="font-style:italic">p</span></span>*ln(<span style="font-style:italic">n</span>)<sup>2</sup>) opérations 
(ce qui est toujours mieux que la division triviale car <span style="font-style:italic">p</span> ≤ √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>).</p>
<!--TOC subsection id="sec158" Le crible quadratique-->
<h3 id="sec158" class="subsection">17.3  Le crible quadratique</h3><!--SEC END --><p><a id="hevea_default186"></a>
<a id="hevea_default187"></a>
On cherche des relations <span style="font-style:italic">x</span><sup>2</sup>=<span style="font-style:italic">y</span><sup>2</sup> (mod <span style="font-style:italic">N</span> ), en espérant trouver un
facteur de <span style="font-style:italic">N</span> en calculant pgcd(<span style="font-style:italic">x</span>−<span style="font-style:italic">y</span>,<span style="font-style:italic">N</span>).
Problème trop difficile, à la place on va essayer de factoriser sur
une base de "petits" nombre premiers des <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub><sup>2</sup>−<span style="font-style:italic">N</span> pour <span style="font-style:italic">x</span> 
proche de √<span style="text-decoration:overline"><span style="font-style:italic">N</span></span> (nombre friable). 
La taille de la base dépend de la taille de <span style="font-style:italic">N</span>. 
La recherche de <span style="font-style:italic">x</span><sup>2</sup> se fait par produit de <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> 
tel qu’il n’apparaisse que des carrés de la base des petits 
nombres premiers, ce qui s’obtient en résolvant 
un gros système linéaire à coefficient dans ℤ/2ℤ.
Pour trouver les <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> on utilise un crible: 
sachant que si on a une solution de <span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">N</span>=0 (mod <span style="font-style:italic">p</span> ), 
alors <span style="font-style:italic">x</span>+<span style="font-style:italic">p</span>, <span style="font-style:italic">x</span>+2<span style="font-style:italic">p</span>, etc. le seront aussi, on a facilement les <span style="font-style:italic">x</span> 
tels que <span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">N</span> est divisible par <span style="font-style:italic">p</span> à partir des 2 racines carrées 
de <span style="font-style:italic">N</span> modulo <span style="font-style:italic">p</span> si elles existent 
(sinon on ne met pas ces racines dans la base de petits premiers!). 
Le crible consiste à incrémenter de log(<span style="font-style:italic">p</span>) 
tous les éléments d’un tableau dont l’indice correspond 
à un <span style="font-style:italic">x</span> tel que <span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">N</span> est divisible par <span style="font-style:italic">p</span>. 
Lorsqu’on a parcouru tous les premiers de la base de nombres premiers, 
on regarde dans le tableau les valeurs assez grandes 
vont correspondre à des possibilités d’entiers friables, 
on factorise alors les <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub><sup>2</sup>−<span style="font-style:italic">N</span> correspondants pour avoir des relations. 
Dès qu’on a <span style="font-style:italic">k</span>+une marge de sécurité (par exemple 20 ou 50) 
relations où <span style="font-style:italic">k</span> est le nombre de premiers de la base 
on est sur qu’on trouvera une vingtaine ou une cinquantaine de
relations 
<span style="font-style:italic">x</span><sup>2</sup>=<span style="font-style:italic">y</span><sup>2</sup> (mod <span style="font-style:italic">N</span> ). 
Comme chaque relation a une chance sur 2 de donner un facteur de <span style="font-style:italic">N</span>, 
on pourra factoriser <span style="font-style:italic">N</span>, sauf malchance vraiment exceptionnelle!</p>
<!--TOC subsubsection id="sec159" Recherche de racine carrée modulo p-->
<h4 id="sec159" class="subsubsection">17.3.1  Recherche de racine carrée modulo p</h4><!--SEC END --><p><a id="hevea_default188"></a>
Pour trouver les solutions <span style="font-style:italic">x</span> de <span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">N</span> divisible par <span style="font-style:italic">p</span>, il
faut calculer les racines carrées de <span style="font-style:italic">N</span> modulo <span style="font-style:italic">p</span>. On procède
comme suit :
</p><ul class="itemize"><li class="li-itemize">
si <span style="font-style:italic">p</span>=2, alors √<span style="text-decoration:overline"><span style="font-style:italic">N</span></span>=<span style="font-style:italic">N</span>
</li><li class="li-itemize">si <span style="font-style:italic">p</span>+1=0 (mod 4 ), si <span style="font-style:italic">N</span> est un carré alors <span style="font-style:italic">N</span><sup>(<span style="font-style:italic">p</span>−1)/2</sup>=1 (mod <span style="font-style:italic">p</span> ) 
donc ± <span style="font-style:italic">N</span><sup>(<span style="font-style:italic">p</span>+1)/4</sup> (mod <span style="font-style:italic">p</span> ) est la racine cherchée (calcul
effectué par l’algorithme de la puissance rapide).
</li><li class="li-itemize">sinon on cherche le pgcd de <span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">N</span> avec
powmod(<span style="font-style:italic">x</span>+<span style="font-style:italic">r</span>,(<span style="font-style:italic">p</span>−1)/2,<span style="font-style:italic">p</span>,<span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">N</span>) 
où <span style="font-style:italic">r</span> est aléatoire, il y a une chance sur 2 que le pgcd soit de degré 1.<br>
Si <span style="font-style:italic">p</span> est assez petit (disons <span style="font-style:italic">p</span>&lt; √<span style="text-decoration:overline">2</span><sup><span style="text-decoration:overline">31</span></sup>), il est plus rapide de
tester les carrés mod <span style="font-style:italic">p</span> de <span style="font-style:italic">k</span>=1,2,3, ..., (<span style="font-style:italic">p</span>−1)/2. Comme
(<span style="font-style:italic">k</span>+1)<sup>2</sup>=<span style="font-style:italic">k</span><sup>2</sup>+2*<span style="font-style:italic">k</span>+1 (mod <span style="font-style:italic">p</span> ), cela se résume à faire un shift (*2) une
addition, un test si ≥ <span style="font-style:italic">p</span> et dans ce cas une soustraction, puis un test
d’égalité avec <span style="font-style:italic">N</span>, le tout avec des entiers courts (32 bits) ce qui est
très rapide.
</li></ul>
<!--TOC section id="sec160" Factorisation des polynômes.-->
<h2 id="sec160" class="section">18  Factorisation des polynômes.</h2><!--SEC END --><p> <a id="sec:factor"></a>
On présente ici quelques algorithmes utilisés pour factoriser un polynôme 
à coefficients entiers, pour la recherche de racines approchées
d’un polynôme, cf. la section <a href="#sec%3Aproot">21.6</a>.
Pour un polynôme en une variable,
cele se fait en plusieurs étapes : on commence
par se ramener à un polynôme <span style="font-style:italic">P</span> dont tous les facteurs sont de multiplicité
un, ensuite on factorise <span style="font-style:italic">P</span> dans ℤ/<span style="font-style:italic">p</span>ℤ (par la méthode de Berlekamp
ou Cantor-Zassenhauss), puis on remonte à ℤ/<span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">Z</span>
pour <span style="font-style:italic">k</span> suffisamment grand (en fonction de la borne de Landau sur les
facteurs de <span style="font-style:italic">P</span>), et on recombine enfin les facteurs modulaires pour
trouver les facteurs de <span style="font-style:italic">P</span>. Lorsque <span style="font-style:italic">P</span> à plusieurs variables, on utilise
une méthode analogue à celle permettant de trouver le pgcd de polynômes
à plusieurs variables. 
</p><p><span style="font-weight:bold">Rappel</span><br>
Le pgcd des coefficients d’un polynôme est appelé contenu de ce polynôme.
Un polynôme est dit primitif si son contenu est égal à 1.</p>
<!--TOC subsection id="sec161" Les facteurs multiples-->
<h3 id="sec161" class="subsection">18.1  Les facteurs multiples</h3><!--SEC END --><p><a id="hevea_default189"></a> <a id="hevea_default190"></a> <a id="hevea_default191"></a>
Étant donné un polynôme <span style="font-style:italic">P</span> à coefficients entiers, on cherche à 
écrire :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>=Π<sub><span style="font-style:italic">k</span>=1</sub><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">k</span></sup> </td></tr>
</table><p>
où les <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> n’ont pas de facteurs multiples et sont premiers entre
eux deux à deux. Comme on est en
caractéristique 0, cela revient à dire que pgcd(<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>,<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>′)=1
et pgcd(<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>,<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>)=1. Bien entendu
on va utiliser la dérivée de <span style="font-style:italic">P</span> dans l’algorithme de recherche des <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>′=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">kP</span><sub><span style="font-style:italic">k</span></sub>′ <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">k</span>−1</sup> Π<sub><span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub><sup><span style="font-style:italic">j</span></sup> </td></tr>
</table><p>
Soit <span style="font-style:italic">G</span> le pgcd de <span style="font-style:italic">P</span> et de <span style="font-style:italic">P</span>′. On a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">G</span>=Π<sub><span style="font-style:italic">k</span>=1</sub><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">k</span>−1</sup>, </td></tr>
</table><p>
en effet <span style="font-style:italic">G</span> divise <span style="font-style:italic">P</span> et <span style="font-style:italic">P</span>′ :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">W</span><sub>1</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">G</span></td></tr>
</table></td><td class="dcell">=Π<sub><span style="font-style:italic">k</span>=1</sub><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>,    
<span style="font-style:italic">Z</span><sub>1</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">G</span></td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">kP</span><sub><span style="font-style:italic">k</span></sub>′Π<sub><span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> </td></tr>
</table><p>
il s’agit de vérifier que <span style="font-style:italic">W</span><sub>1</sub> et <span style="font-style:italic">Z</span><sub>1</sub> sont premiers entre eux. Soit <span style="font-style:italic">F</span> un
facteur irréductible du pgcd de <span style="font-style:italic">W</span><sub>1</sub> et <span style="font-style:italic">Z</span><sub>1</sub>, alors <span style="font-style:italic">F</span> divise l’un des 
<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>,
appelons <span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub> ce facteur. Comme <span style="font-style:italic">F</span> divise Π<sub><span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> si <span style="font-style:italic">k</span>≠ <span style="font-style:italic">l</span>,
on en déduit que <span style="font-style:italic">F</span> divise le dernier terme de la somme de <span style="font-style:italic">Z</span><sub>1</sub>, c’est-à-dire
que <span style="font-style:italic">F</span> divise <span style="font-style:italic">lP</span><sub><span style="font-style:italic">l</span></sub>′Π<sub><span style="font-style:italic">j</span>≠ <span style="font-style:italic">l</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> donc <span style="font-style:italic">F</span> divise <span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub>′ puisque
les <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> sont premiers entre eux. Donc <span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub> et <span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub>′ ont un facteur
en commun, ce qui est contraire aux hypothèses.</p><p>On pose alors :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Y</span><sub>1</sub>=<span style="font-style:italic">Z</span><sub>1</sub>−<span style="font-style:italic">W</span><sub>1</sub>′=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>&gt;1</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">k</span>−1)<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>′ Π<sub><span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> </td></tr>
</table><p>
On définit alors par récurrence des suites de polynômes <span style="font-style:italic">W</span><sub><span style="font-style:italic">n</span></sub>, <span style="font-style:italic">Y</span><sub><span style="font-style:italic">n</span></sub> et
<span style="font-style:italic">G</span><sub><span style="font-style:italic">m</span></sub> par :
</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">G</span><sub><span style="font-style:italic">m</span></sub>=pgcd(<span style="font-style:italic">W</span><sub><span style="font-style:italic">m</span></sub>,<span style="font-style:italic">Y</span><sub><span style="font-style:italic">m</span></sub>)
</li><li class="li-itemize"><span style="font-style:italic">W</span><sub><span style="font-style:italic">m</span>+1</sub>=<span style="font-style:italic">W</span><sub><span style="font-style:italic">m</span></sub>/<span style="font-style:italic">G</span><sub><span style="font-style:italic">m</span></sub> et <span style="font-style:italic">Y</span><sub><span style="font-style:italic">m</span>+1</sub>=<span style="font-style:italic">Y</span><sub><span style="font-style:italic">m</span></sub>/<span style="font-style:italic">G</span><sub><span style="font-style:italic">m</span></sub>−<span style="font-style:italic">W</span><sub><span style="font-style:italic">m</span>+1</sub>′
</li></ul><p>
On va montrer que <span style="font-style:italic">P</span><sub><span style="font-style:italic">m</span></sub>=<span style="font-style:italic">G</span><sub><span style="font-style:italic">m</span></sub>. Commençons au rang <span style="font-style:italic">n</span>=1, on voit que <span style="font-style:italic">P</span><sub>1</sub>
divise <span style="font-style:italic">Y</span><sub>1</sub> (puisqu’il est commun à tous les Π<sub><span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> car
<span style="font-style:italic">k</span>&gt;1) et divise <span style="font-style:italic">W</span><sub>1</sub>. Et c’est le seul facteur commun, car tout autre
facteur irréductible serait un diviseur d’un <span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub> pour <span style="font-style:italic">l</span>&gt;1, donc diviserait
(<span style="font-style:italic">l</span>−1)<span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub>′Π<sub><span style="font-style:italic">j</span>≠ <span style="font-style:italic">l</span>,<span style="font-style:italic">j</span>&gt;1</sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>, donc diviserait <span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub>′.
Le raisonnement en un rang quelconque est identique, les polynômes sont
donnés par :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">G</span><sub><span style="font-style:italic">m</span></sub>=<span style="font-style:italic">P</span><sub><span style="font-style:italic">m</span></sub>,  <span style="font-style:italic">W</span><sub><span style="font-style:italic">m</span></sub>=Π<sub><span style="font-style:italic">k</span>&gt;=<span style="font-style:italic">m</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>,  
<span style="font-style:italic">Y</span><sub><span style="font-style:italic">m</span></sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>&gt;<span style="font-style:italic">m</span></td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">k</span>−<span style="font-style:italic">m</span>)<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>′Π<sub><span style="font-style:italic">j</span>≥ <span style="font-style:italic">m</span>, <span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> </td></tr>
</table><p>Lorsqu’on programme cet algorithme, le test d’arrêt est <span style="font-style:italic">G</span><sub><span style="font-style:italic">m</span></sub>=1.</p><p><span style="font-weight:bold">Square-free factorisation (Algorithme de Yun)</span><br>
Argument: un polynôme primitif <span style="font-style:italic">P</span> à coefficients entiers (ou dans ℤ[<span style="font-style:italic">i</span>]
ou dans un corps de caractéristique nulle).<br>
Valeur renvoyée: une liste de polynômes <span style="font-style:italic">P</span><sub><span style="font-style:italic">m</span></sub> telle que 
<span style="font-style:italic">P</span>=Π<sub><span style="font-style:italic">k</span>=1</sub><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">k</span></sup>.<br>
</p><ol class="enumerate" type=1><li class="li-enumerate">
Initialiser la liste résultat à liste vide.
</li><li class="li-enumerate">Initialiser <span style="font-style:italic">W</span> à <span style="font-style:italic">P</span> et <span style="font-style:italic">Y</span> à <span style="font-style:italic">P</span>′. Calculer le pgcd <span style="font-style:italic">G</span> de <span style="font-style:italic">W</span> et <span style="font-style:italic">Y</span>
et simplifier <span style="font-style:italic">W</span> et <span style="font-style:italic">Y</span> par leur pgcd puis poser <span style="font-style:italic">Y</span>=<span style="font-style:italic">Y</span>−<span style="font-style:italic">W</span>′.
</li><li class="li-enumerate">Boucle tant que <span style="font-style:italic">Y</span>≠ 0.
</li><li class="li-enumerate">Calculer le pgcd <span style="font-style:italic">G</span> de <span style="font-style:italic">W</span> et <span style="font-style:italic">Y</span>. Ajouter <span style="font-style:italic">G</span> à la liste résultat.
</li><li class="li-enumerate">Simplifier <span style="font-style:italic">W</span> et <span style="font-style:italic">Y</span> par <span style="font-style:italic">G</span>, puis poser <span style="font-style:italic">Y</span>=<span style="font-style:italic">Y</span>−<span style="font-style:italic">W</span>′ et passer à 
l’itération suivante.
</li></ol><p>Remarque : lorsqu’on veut factoriser un polynôme à coefficients modulaires,
il faut aussi se ramener à un polynôme sans facteurs multiples mais
on ne peut pas utiliser cet algorithme tel quel car la caractéristique
du corps n’est pas nulle.</p><p><span style="font-weight:bold">Exemple</span> :<br>
Factorisation sans facteurs multiples de 
<span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>)=(<span style="font-style:italic">X</span><sup>3</sup>−1)(<span style="font-style:italic">X</span>+2)<sup>2</sup>(<span style="font-style:italic">X</span><sup>2</sup>+3)<sup>3</sup>.
En mode interactif avec un logiciel de calcul formel, effectuons l’étape
d’initialisation :
</p><pre class="verbatim">W:=normal((x^3-1)*(x+2)^2*(x^2+3)^3);
Y:=diff(W,x);
G:=gcd(W,Y);
        x^5+2*x^4+6*x^3+12*x^2+9*x+18
W:=normal(W/G); 
        x^6+2*x^5+3*x^4+5*x^3+-2*x^2+-3*x-6
Y:=normal(Y/G);
Y:=normal(Y-diff(W,x));
        5*x^5+8*x^4+3*x^3+-5*x^2+-8*x-3
</pre><p>On vérifie bien que <span style="font-style:italic">W</span>=(<span style="font-style:italic">x</span>+2)*(<span style="font-style:italic">x</span><sup>3</sup>−1)*(<span style="font-style:italic">x</span><sup>2</sup>+3) est le produit 
des facteurs <span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub>. On entame maintenant la boucle :
</p><pre class="verbatim">G:=gcd(W,Y);
        x^3-1   -&gt; P1
Y:=normal(Y/G);
W:=normal(W/G);
Y:=normal(Y-diff(W,x));
        2*x^2+4*x
G:=gcd(W,Y);
        x+2     -&gt; P2
Y:=normal(Y/G);
W:=normal(W/G);
Y:=normal(Y-diff(W,x));
        0
G:=gcd(W,Y);
        x^2+3   -&gt;  P3
</pre><p>puis <span style="font-style:italic">W</span>=1 et <span style="font-style:italic">Y</span>=0 et le prochain <span style="font-style:italic">G</span> vaut 1, on a bien trouvé tous
les facteurs <span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub>.</p>
<!--TOC subsection id="sec162" Factorisation en une variable-->
<h3 id="sec162" class="subsection">18.2  Factorisation en une variable</h3><!--SEC END --><p>
On suppose maintenant qu’on veut factoriser un polynôme <span style="font-style:italic">P</span> sans facteur
multiple (et primitif). En général on commence par simplifier <span style="font-style:italic">P</span> par
ses facteurs linéaires (détectés avec l’algorithme présenté dans le
premier article de cette série). On commence par chercher un nombre premier <span style="font-style:italic">p</span>
tel que <span style="font-style:italic">P</span> dans ℤ/<span style="font-style:italic">p</span>ℤ conserve le même degré et reste sans facteur 
multiple (donc pgcd(<span style="font-style:italic">P</span>,<span style="font-style:italic">P</span>′)=1 dans ℤ/<span style="font-style:italic">p</span>ℤ), ce qui est toujours
possible (il suffit de prendre <span style="font-style:italic">p</span> plus grand que le plus grand entier 
apparaissant dans l’algorithme du sous-résultant pour calculer
le pgcd de <span style="font-style:italic">P</span> et <span style="font-style:italic">P</span>′ dans ℤ).</p><p><span style="font-weight:bold">Convention</span><br>
Tous les polynômes ayant leurs coefficients dans un corps fini sont
supposés avoir comme coefficient dominant 1 lorsque le choix
existe (par exemple les facteurs d’un polynôme modulo <span style="font-style:italic">p</span>).</p>
<!--TOC subsubsection id="sec163" Factorisation dans ℤ/<span style="font-style:italic">p</span>ℤ[<span style="font-style:italic">X</span>]-->
<h4 id="sec163" class="subsubsection">18.2.1  Factorisation dans ℤ/<span style="font-style:italic">p</span>ℤ[<span style="font-style:italic">X</span>]</h4><!--SEC END --><p>
On suppose qu’on a un polynôme <span style="font-style:italic">P</span> à coefficients dans ℤ/<span style="font-style:italic">p</span>ℤ sans
facteur multiple. Il s’agit de factoriser <span style="font-style:italic">P</span> dans ℤ/<span style="font-style:italic">p</span>ℤ[<span style="font-style:italic">X</span>].
Il existe essentiellement deux stratégies, l’une commence par factoriser par
groupes de facteurs de même degré puis casse les facteurs et l’autre 
plus directe à base d’algèbre linéaire modulaire (méthode de Berlekamp). 
Dans les deux cas, on utilise le fait que si <span style="font-style:italic">F</span> est un polynôme, 
alors les polynômes à coefficients dans ℤ/<span style="font-style:italic">p</span>ℤ
modulo <span style="font-style:italic">F</span> forment un anneau <span style="font-style:italic">A</span> qui est aussi un espace vectoriel 
sur ℤ/<span style="font-style:italic">p</span>ℤ de dimension le degré de <span style="font-style:italic">F</span> 
(si <span style="font-style:italic">F</span> est irréductible, alors <span style="font-style:italic">A</span> est un corps).
On s’intéresse alors aux propriétés de l’application 
ϕ: <span style="font-style:italic">x</span> ∈ <span style="font-style:italic">A</span> ↦ <span style="font-style:italic">x</span><sup><span style="font-style:italic">p</span></sup>.
On observe d’abord que cette application est une application <em>linéaire</em>.
Cela découle du petit théorème de Fermat pour ϕ(λ <span style="font-style:italic">x</span>)=λ
ϕ(<span style="font-style:italic">x</span>) et de la formule de Newton et de la primalité de <span style="font-style:italic">p</span> pour
ϕ(<span style="font-style:italic">x</span>+<span style="font-style:italic">y</span>)=ϕ(<span style="font-style:italic">x</span>)+ϕ(<span style="font-style:italic">y</span>).</p><p><span style="font-weight:bold">Calcul de </span>ϕ<br>
Pour mettre en oeuvre ces algorithmes, on commence par déterminer la matrice
de l’endomorphisme ϕ: <span style="font-style:italic">x</span> ↦ <span style="font-style:italic">x</span><sup><span style="font-style:italic">p</span></sup> dans ℤ/<span style="font-style:italic">p</span>ℤ[<span style="font-style:italic">X</span>] (mod <span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>) )
muni de sa base canonique { 1, <span style="font-style:italic">X</span>,...,<span style="font-style:italic">X</span><sup>deg(<span style="font-style:italic">P</span>)−1</sup> }.</p>
<!--TOC subsubsection id="sec164" Distinct degree factorization-->
<h4 id="sec164" class="subsubsection">18.2.2  Distinct degree factorization</h4><!--SEC END --><p> <a id="hevea_default192"></a>
Cette méthode consiste à détecter les groupes de facteurs
ayant un degré donné (distinct degree factorization). Si nécessaire, 
on utilise ensuite un autre algorithme pour casser ces groupes.
On utilise ici les propriétés des itérées de l’application linéaire 
ϕ sur des espaces vectoriels de corps de base ℤ/<span style="font-style:italic">p</span>ℤ.
On va déterminer le produit <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> de tous les facteurs de <span style="font-style:italic">P</span> de degré <span style="font-style:italic">k</span>
en calculant le pgcd de <span style="font-style:italic">P</span> et de <span style="font-style:italic">X</span><sup>(<span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup>)</sup>−<span style="font-style:italic">X</span> dans ℤ/<span style="font-style:italic">p</span>ℤ[<span style="font-style:italic">X</span>].</p><p>Pour <span style="font-style:italic">k</span>=1, <span style="font-style:italic">X</span><sup><span style="font-style:italic">p</span></sup>−<span style="font-style:italic">X</span> est le produit des <span style="font-style:italic">X</span>−<span style="font-style:italic">k</span> pour tout <span style="font-style:italic">k</span>∈ ℤ/<span style="font-style:italic">p</span>ℤ
par le petit théorème de Fermat (<span style="font-style:italic">k</span><sup><span style="font-style:italic">p</span></sup>=<span style="font-style:italic">k</span> (mod <span style="font-style:italic">p</span> )), donc le pgcd
de <span style="font-style:italic">P</span> et de <span style="font-style:italic">X</span><sup>(<span style="font-style:italic">p</span><sup>1</sup>)</sup>−<span style="font-style:italic">X</span> dans ℤ/<span style="font-style:italic">p</span>ℤ[<span style="font-style:italic">X</span>] est le produit des facteurs
de <span style="font-style:italic">P</span> de degré 1.</p><p>Pour <span style="font-style:italic">k</span>&gt;1, le raisonnement se généralise de la manière suivante : on
considère un facteur irréductible <span style="font-style:italic">F</span>(<span style="font-style:italic">X</span>) de <span style="font-style:italic">P</span> de degré <span style="font-style:italic">k</span> et le corps
<span style="font-style:italic">K</span>=(ℤ/<span style="font-style:italic">p</span>ℤ)[<span style="font-style:italic">Y</span>] (mod <span style="font-style:italic">F</span>(<span style="font-style:italic">Y</span>) ). Le corps <span style="font-style:italic">K</span> est un corps fini, c’est
aussi un espace vectoriel sur ℤ/<span style="font-style:italic">p</span>ℤ de dimension <span style="font-style:italic">k</span>, donc <span style="font-style:italic">K</span> possède
<span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup> éléments et <span style="font-style:italic">K</span><sup>*</sup> est un groupe multiplicatif à <span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup>−1 éléments,
donc tout élément de <span style="font-style:italic">K</span><sup>*</sup> vérifie l’équation <span style="font-style:italic">x</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup>−1</sup>=1 donc
tout élément de <span style="font-style:italic">K</span> vérifie <span style="font-style:italic">x</span><sup>(<span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup>)</sup>=<span style="font-style:italic">x</span>. En particulier pour 
<span style="font-style:italic">x</span>=<span style="font-style:italic">Y</span> (mod <span style="font-style:italic">F</span>(<span style="font-style:italic">Y</span>) ) 
on trouve que <span style="font-style:italic">Y</span><sup>(<span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup>)</sup>=<span style="font-style:italic">Y</span> (mod <span style="font-style:italic">F</span>(<span style="font-style:italic">Y</span>) ) donc <span style="font-style:italic">F</span>(<span style="font-style:italic">X</span>) divise <span style="font-style:italic">X</span><sup>(<span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup>)</sup>−<span style="font-style:italic">X</span>
dans ℤ/<span style="font-style:italic">p</span>ℤ.</p><p>Réciproquement, si on se donne un facteur irréductible <span style="font-style:italic">F</span> qui divise
<span style="font-style:italic">X</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup></sup>−<span style="font-style:italic">X</span>, soit <span style="font-style:italic">K</span> le corps correspondant à <span style="font-style:italic">F</span>, 
alors le noyau de l’application linéaire
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span> ∈ <span style="font-style:italic">K</span> ↦ <span style="font-style:italic">x</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup></sup>−<span style="font-style:italic">x</span> ∈ <span style="font-style:italic">K</span> </td></tr>
</table><p>
est <span style="font-style:italic">K</span> tout entier, car <span style="font-style:italic">Y</span>=<span style="font-style:italic">Y</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup></sup> (mod <span style="font-style:italic">F</span> )
entraine (<span style="font-style:italic">Y</span><sup>2</sup>)<sup>(<span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup>)</sup>=<span style="font-style:italic">Y</span><sup>2 <span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup></sup>=(<span style="font-style:italic">Y</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup></sup>)<sup>2</sup>=<span style="font-style:italic">Y</span><sup>2</sup> (mod <span style="font-style:italic">F</span> ) et de même
pour les autres puissances de <span style="font-style:italic">Y</span> qui, avec <span style="font-style:italic">Y</span><sup>0</sup>=1 également dans le
noyau, forment une base de l’espace vectoriel <span style="font-style:italic">K</span> sur ℤ/<span style="font-style:italic">p</span>ℤ. Donc le
nombre d’éléments de <span style="font-style:italic">K</span> est inférieur ou égal au degré du polynôme
<span style="font-style:italic">X</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup></sup>−<span style="font-style:italic">X</span> (puisque <span style="font-style:italic">X</span><sup>(<span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup>)</sup>−<span style="font-style:italic">X</span> est divisible par
<span style="font-style:italic">X</span>−<span style="font-style:italic">x</span> pour tout <span style="font-style:italic">x</span>∈ <span style="font-style:italic">K</span>),
donc le degré de <span style="font-style:italic">F</span> est inférieur ou égal à <span style="font-style:italic">k</span>.
(En fait <span style="font-style:italic">f</span>, le degré de <span style="font-style:italic">F</span>, doit diviser <span style="font-style:italic">k</span>, en effet
si <span style="font-style:italic">q</span> et <span style="font-style:italic">r</span> sont le quotient et le reste de la division de <span style="font-style:italic">k</span> par <span style="font-style:italic">f</span>,
<span style="font-style:italic">X</span>=<span style="font-style:italic">X</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup></sup> (mod <span style="font-style:italic">F</span> ) =<span style="font-style:italic">X</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">qf</span>+<span style="font-style:italic">r</span></sup></sup> (mod <span style="font-style:italic">F</span> )=<span style="font-style:italic">X</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">r</span></sup></sup> (mod <span style="font-style:italic">F</span> )
le polynôme <span style="font-style:italic">x</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">r</span></sup></sup>−<span style="font-style:italic">x</span> admet alors <span style="font-style:italic">p</span><sup><span style="font-style:italic">f</span></sup> racines dans le corps
ce qui n’est possible que si <span style="font-style:italic">r</span>=0 car sinon son degré 
<span style="font-style:italic">p</span><sup><span style="font-style:italic">r</span></sup> serait trop petit <span style="font-style:italic">p</span><sup><span style="font-style:italic">r</span></sup>&lt;<span style="font-style:italic">p</span><sup><span style="font-style:italic">f</span></sup>).</p><p>Donc <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> est égal au pgcd de <span style="font-style:italic">P</span>/Π<sub><span style="font-style:italic">j</span>&lt;<span style="font-style:italic">k</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> avec <span style="font-style:italic">X</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup></sup>−<span style="font-style:italic">X</span>.</p><p><span style="font-weight:bold">Algorithme distinct degree factorization</span><br>
Argument: un polynôme <span style="font-style:italic">P</span> à coefficients entiers 
sans facteur multiple et primitif.<br>
Valeur renvoyée: la liste <span style="font-style:italic">L</span> des produits des facteurs irréductibles et du
degré correspondant de <span style="font-style:italic">P</span> (ordonné par ordre croissant de degré).<br>
On commence par initialiser <span style="font-style:italic">L</span> à vide et un polynôme auxiliaire <span style="font-style:italic">Q</span> à <span style="font-style:italic">X</span>
(il contiendra les valeurs de <span style="font-style:italic">X</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup></sup>−<span style="font-style:italic">X</span> (mod <span style="font-style:italic">P</span> )), on fait une boucle
indéfinie sur <span style="font-style:italic">k</span> commençant à 1 et incrémenté de 1 à chaque itération
</p><ul class="itemize"><li class="li-itemize">
Si <span style="font-style:italic">k</span> est strictement plus grand que le degré de <span style="font-style:italic">P</span> divisé par 2,
on rajoute le couple (<span style="font-style:italic">P</span>,degre(<span style="font-style:italic">P</span>)) à <span style="font-style:italic">L</span> et on renvoie <span style="font-style:italic">L</span>
</li><li class="li-itemize">On remplace <span style="font-style:italic">Q</span> par <span style="font-style:italic">Q</span><sup><span style="font-style:italic">p</span></sup> (mod <span style="font-style:italic">P</span> ) en utilisant le calcul de ϕ
modulo <span style="font-style:italic">P</span>
</li><li class="li-itemize">On calcule le pgcd <span style="font-style:italic">G</span> de <span style="font-style:italic">Q</span>−<span style="font-style:italic">X</span> et de <span style="font-style:italic">P</span>. 
</li><li class="li-itemize">Si <span style="font-style:italic">G</span> vaut 1, on passe à l’itération suivante
</li><li class="li-itemize">On rajoute le couple (<span style="font-style:italic">G</span>,<span style="font-style:italic">k</span>) à la liste <span style="font-style:italic">L</span> et on remplace <span style="font-style:italic">P</span>
par le quotient de <span style="font-style:italic">P</span> par <span style="font-style:italic">G</span>.
</li></ul><p><span style="font-weight:bold">Exemple</span> :<br>
Factorisation en degré distincts de (<span style="font-style:italic">X</span><sup>3</sup>+<span style="font-style:italic">X</span>+1)(<span style="font-style:italic">X</span><sup>4</sup>−<span style="font-style:italic">X</span>+1) dans
ℤ/5ℤ. On regarde d’abord si <span style="font-style:italic">P</span> reste sans facteur multiple après
réduction modulo 5.
</p><pre class="verbatim">P:=normal((x^3+x+1)*(x^4-x+1) mod 5);
gcd(P,diff(P,x));
    1 mod 5  -&gt; ok P est sans facteur multiple
P1:=gcd(P,(x^5-x)mod 5);
    (1 mod 5)*x -2 mod 5  -&gt; P1
P:=normal(P/P1);
P2:=gcd(P,(x^(5^2)-x)mod 5);
    1 mod 5  -&gt; pas de facteur de degre 2
P3:=gcd(P,(x^(5^3)-x)mod 5);
    (x^6+2*x^5+x^2+x+2) mod 5
</pre><p>Donc <span style="font-style:italic">P</span> admet 3 facteurs dans ℤ/5ℤ: un de degré 1 (<span style="font-style:italic">x</span>−2) et
deux de degré 3 (dont le produit est <span style="font-style:italic">x</span><sup>6</sup>+2<span style="font-style:italic">x</span><sup>5</sup>+<span style="font-style:italic">x</span><sup>2</sup>+<span style="font-style:italic">x</span>+2).</p><p>Le même calcul dans ℤ/7ℤ donne
</p><pre class="verbatim">P:=normal((x^3+x+1)*(x^4-x+1) mod 7);
gcd(P,diff(P,x));
    1 mod 7  -&gt; ok P est sans facteur multiple
P1:=gcd(P,(x^7-x)mod 7);
    1 mod 7
P2:=gcd(P,(x^(7^2)-x)mod 7);
    1 mod 7
P3:=gcd(P,(x^(7^3)-x)mod 7);
    (x^3+x+1) mod 7
</pre><p>donc <span style="font-style:italic">P</span> possède un facteur de degré 3 modulo 7, donc le facteur restant
de degré 4 est forcément irréductible.</p><p>On remarque sur cet exemple que 7 est plus intéressant que 5, car
la factorisation modulo 7 donne moins de facteurs (à recombiner pour
trouver la factorisation dans ℤ) et la factorisation est
complète modulo 7 alors que modulo 5 il faut casser le facteur de
degré 6 en deux facteurs de degré 3. La plupart des algorithmes
de factorisation effectuent la factorisation en degré distinct
modulo plusieurs entiers (ce qui peut de plus être parallélisé)
et choisissent le meilleur.</p>
<!--TOC subsubsection id="sec165" La méthode de Cantor-Zassenhaus-->
<h4 id="sec165" class="subsubsection">18.2.3  La méthode de Cantor-Zassenhaus</h4><!--SEC END --><p>
<a id="hevea_default193"></a>
Cet algorithme sert à casser des groupes de facteurs de même degré,
c’est une méthode probabiliste. On suppose donc qu’on a un produit <span style="font-style:italic">P</span>
d’au moins deux facteurs irréductibles de degré <span style="font-style:italic">d</span> à casser.
Soit <span style="font-style:italic">D</span> l’un des polynômes irréductibles de degré <span style="font-style:italic">d</span> à coefficients
dans ℤ/<span style="font-style:italic">p</span>ℤ, et soit <span style="font-style:italic">K</span>=ℤ/<span style="font-style:italic">p</span>ℤ[<span style="font-style:italic">Y</span>] (mod <span style="font-style:italic">D</span>(<span style="font-style:italic">Y</span>) ), on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">X</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup></sup>−<span style="font-style:italic">X</span>=Π<sub>α ∈ <span style="font-style:italic">K</span> </sub>(<span style="font-style:italic">X</span>−α) </td></tr>
</table><p>
puisque le corps <span style="font-style:italic">K</span> possède <span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup> éléments tous racines
de l’équation <span style="font-style:italic">X</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup></sup>=<span style="font-style:italic">X</span>.</p><p>On considère un polynôme <span style="font-style:italic">T</span> non constant, et le polynôme
<span style="font-style:italic">T</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup></sup>−<span style="font-style:italic">T</span>. En remplaçant <span style="font-style:italic">X</span> par <span style="font-style:italic">T</span> ci-dessus, on en déduit :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">T</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup></sup>−<span style="font-style:italic">T</span>=Π<sub>α ∈ <span style="font-style:italic">K</span> </sub>(<span style="font-style:italic">T</span>−α) </td></tr>
</table><p>
Donc pour tout élément β ∈ <span style="font-style:italic">K</span>=ℤ/<span style="font-style:italic">p</span>ℤ[<span style="font-style:italic">Y</span>] (mod <span style="font-style:italic">D</span>(<span style="font-style:italic">Y</span>) ), on a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">T</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup></sup>−<span style="font-style:italic">T</span>)(β)=Π<sub>α ∈ <span style="font-style:italic">K</span> </sub>(<span style="font-style:italic">T</span>(β)−α)=0</td></tr>
</table><p>
Donc <span style="font-style:italic">T</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup></sup>−<span style="font-style:italic">T</span> est divisible par <span style="font-style:italic">X</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup></sup>−<span style="font-style:italic">X</span> (puisque toutes les racines
du second sont racines du premier), donc est divisible par tout polynôme
irréductible de degré inférieur ou égal à <span style="font-style:italic">d</span> à coefficients dans <span style="font-style:italic">Z</span>/<span style="font-style:italic">p</span>ℤ.
Comme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:cantor"></a>
<span style="font-style:italic">T</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup></sup>−<span style="font-style:italic">T</span>=<span style="font-style:italic">T</span>(<span style="font-style:italic">T</span></td><td class="dcell"><table class="display"><tr><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell">&nbsp;</td></tr>
</table></td><td class="dcell">−1)(<span style="font-style:italic">T</span></td><td class="dcell"><table class="display"><tr><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell">&nbsp;</td></tr>
</table></td><td class="dcell">+1)
    (19)</td></tr>
</table><p>
et que ces trois facteurs sont premiers entre eux, on en déduit que tout 
polynôme irréductible de degré inférieur ou égal à <span style="font-style:italic">d</span> à coefficients dans 
<span style="font-style:italic">Z</span>/<span style="font-style:italic">p</span>ℤ divise l’un des trois facteurs ci-dessus. Pour casser <span style="font-style:italic">P</span>, l’idée
consiste alors à calculer le pgcd de <span style="font-style:italic">P</span> et <span style="font-style:italic">T</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup>−1/2</sup>−1
pour un polynôme pris au hasard. On sait que <span style="font-style:italic">P</span> divise le produit des
3 termes de (<a href="#eq%3Acantor">19</a>), et on espère que les facteurs irréductibles
de <span style="font-style:italic">P</span> ne diviseront pas tous le même terme.</p><p>On va montrer que si <span style="font-style:italic">T</span> est un polynôme de degré ≤ 2<span style="font-style:italic">d</span>−1 choisi au hasard,
la probabilité que deux facteurs irréductibles de <span style="font-style:italic">P</span> ne divisent pas 
<span style="font-style:italic">T</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup></sup>−<span style="font-style:italic">T</span> est proche de 0.5. Soient donc <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> deux facteurs
irréductibles de <span style="font-style:italic">P</span> de degré <span style="font-style:italic">d</span>. D’après l’identité de Bézout, tout 
polynôme <span style="font-style:italic">T</span> de degré ≤ 2<span style="font-style:italic">d</span>−1 s’écrit de manière unique sous la forme :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:bezout2"></a> 
<span style="font-style:italic">T</span> = <span style="font-style:italic">A</span> <span style="font-style:italic">U</span> + <span style="font-style:italic">B</span> <span style="font-style:italic">V</span> 
    (20)</td></tr>
</table><p>
avec degre(<span style="font-style:italic">U</span> ≤ <span style="font-style:italic">d</span>−1) et degre(<span style="font-style:italic">V</span> ≤ <span style="font-style:italic">d</span>−1) et réciproquement 
une combinaison linéaire de cette forme est un polynôme de degré ≤ 2<span style="font-style:italic">d</span>−1.
Choisir <span style="font-style:italic">T</span> au hasard revient donc à choisir un couple (<span style="font-style:italic">U</span>,<span style="font-style:italic">V</span>) de polynômes
à coefficients dans ℤ/<span style="font-style:italic">p</span>ℤ au hasard et
de manière indépendante. D’autre part, <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> étant de degré <span style="font-style:italic">d</span>, on
sait que dans <span style="font-style:italic">K</span>=ℤ/<span style="font-style:italic">p</span>ℤ[<span style="font-style:italic">Y</span>] (mod <span style="font-style:italic">D</span>(<span style="font-style:italic">Y</span>) ) ces polynômes admettent <span style="font-style:italic">d</span> racines.
Soit donc α [respectivement β] une racine de <span style="font-style:italic">A</span> [resp. <span style="font-style:italic">B</span>]
dans <span style="font-style:italic">K</span>. Alors <span style="font-style:italic">A</span> divise <span style="font-style:italic">T</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup>−1/2</sup>−1
si et seulement si <span style="font-style:italic">T</span>(α )<sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup>−1/2</sup>=1 (et de même pour
<span style="font-style:italic">B</span> et β) car <span style="font-style:italic">T</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup>−1/2</sup>−1 a ses coefficients dans
ℤ/<span style="font-style:italic">p</span>ℤ (et non dans <span style="font-style:italic">K</span>). 
En appliquant (<a href="#eq%3Abezout2">20</a>), <span style="font-style:italic">A</span> divise <span style="font-style:italic">T</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup>−1/2</sup>−1
si et seulement si :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">B</span>(α )</td><td class="dcell"><table class="display"><tr><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell">&nbsp;</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">V</span>(α )</td><td class="dcell"><table class="display"><tr><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell">&nbsp;</td></tr>
</table></td><td class="dcell">=1 </td></tr>
</table><p>
Le premier terme de cette égalité est une constante égale à 1 ou -1, 
le second a une probabilité proche de 0.5 (égale à <span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup>−1/2<span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup>)
de valoir 1 ou -1 car, comme <span style="font-style:italic">A</span> est irréductible,
<span style="font-style:italic">V</span>(α) décrit <span style="font-style:italic">K</span> lorsque <span style="font-style:italic">V</span> décrit les 
polynômes de degré ≤ <span style="font-style:italic">d</span>−1.
De même, <span style="font-style:italic">B</span> a une probabilité proche de 0.5 de diviser 
<span style="font-style:italic">T</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup>−1/2</sup>−1, et ces 2 probabilités sont indépendantes
puisque <span style="font-style:italic">U</span> et <span style="font-style:italic">V</span> le sont, donc la probabilité que soit <span style="font-style:italic">A</span> soit <span style="font-style:italic">B</span> divise
divise <span style="font-style:italic">T</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup>−1/2</sup>−1 est proche de 0.5.</p><p><span style="font-weight:bold">Algorithme de Cantor-Zassenhaus</span><br>
Argument: Un polynôme <span style="font-style:italic">P</span> à coefficients dans ℤ/<span style="font-style:italic">p</span>ℤ de degré <span style="font-style:italic">k</span>
dont tous les facteurs irréductibles sont de degré <span style="font-style:italic">d</span>.<br>
Valeur renvoyée: la liste des facteurs irréductibles de <span style="font-style:italic">P</span>.<br>
</p><ul class="itemize"><li class="li-itemize">
Si <span style="font-style:italic">k</span>=<span style="font-style:italic">d</span> renvoyer une liste contenant <span style="font-style:italic">P</span>.
</li><li class="li-itemize">Déterminer un polynôme <span style="font-style:italic">T</span> aléatoire de degré inférieur ou égal
à 2<span style="font-style:italic">d</span>−1 et de coefficient dominant 1. Calculer le pgcd <span style="font-style:italic">D</span> de <span style="font-style:italic">P</span>
et de <span style="font-style:italic">T</span><sup>(<span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup>−1)/2</sup>−1. Si le degré de <span style="font-style:italic">T</span> est égal à 0 ou à <span style="font-style:italic">k</span> 
recommencer cette étape.
</li><li class="li-itemize">Appeler récursivement cet algorithme avec <span style="font-style:italic">T</span> et <span style="font-style:italic">P</span>/<span style="font-style:italic">T</span> et
renvoyer la liste réunion des deux listes renvoyées.
</li></ul><p><span style="font-weight:bold">Exemple</span> :<br>
Cassons le polynôme de degré 6 obtenu dans l’exemple précédent
(modulo 5). Donc <span style="font-style:italic">P</span>:=(<span style="font-style:italic">x</span><sup>6</sup>+2*<span style="font-style:italic">x</span><sup>5</sup>+<span style="font-style:italic">x</span><sup>2</sup>+<span style="font-style:italic">x</span>+2) (mod 5 ) et <span style="font-style:italic">d</span>=3, 2<span style="font-style:italic">d</span>−1=5,
(<span style="font-style:italic">p</span><sup><span style="font-style:italic">d</span></sup>−1)/2=62.
On choisit au hasard un polynôme de degré inférieur ou égal à 5, par exemple
<span style="font-style:italic">T</span>=<span style="font-style:italic">x</span><sup>4</sup>−<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span>+1, puis on calcule <span style="font-style:italic">T</span><sup>62</sup> modulo <span style="font-style:italic">P</span> ce qui donne
(<span style="font-style:italic">x</span><sup>5</sup>+<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span><sup>2</sup>+1) (mod 5 ) puis le pgcd de <span style="font-style:italic">T</span><sup>62</sup>−1 et de <span style="font-style:italic">P</span>
qui vaut <span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span>+1 (mod 5 ), on a donc cassé <span style="font-style:italic">P</span> en deux. 
En prenant <span style="font-style:italic">T</span>:=<span style="font-style:italic">x</span><sup>4</sup>−<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span>+2, on trouve <span style="font-style:italic">T</span><sup>62</sup>=1 (mod <span style="font-style:italic">P</span> ), donc
ce <span style="font-style:italic">T</span> n’aurait pas permis de casser <span style="font-style:italic">P</span>.</p>
<!--TOC subsubsection id="sec166" La méthode de Berlekamp-->
<h4 id="sec166" class="subsubsection">18.2.4  La méthode de Berlekamp</h4><!--SEC END --><p><a id="hevea_default194"></a>
Cette méthode permet de factoriser un polynôme sans facteurs multiples,
elle peut aussi servir à casser des groupes de facteurs de même degré.
Ici on travaille dans l’anneau des polynômes à coefficients dans ℤ/<span style="font-style:italic">p</span>ℤ
modulo le polynôme <span style="font-style:italic">P</span> et on s’intéresse au noyau de ϕ−<span style="font-style:italic">Id</span>
(où ϕ: <span style="font-style:italic">x</span> ↦ <span style="font-style:italic">x</span><sup><span style="font-style:italic">p</span></sup>). On
suppose que <span style="font-style:italic">P</span>=Π<sub><span style="font-style:italic">j</span>=1</sub><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">F</span><sub><span style="font-style:italic">j</span></sub> où les <span style="font-style:italic">F</span><sub><span style="font-style:italic">j</span></sub> sont irréductibles et
premiers entre eux. On va montrer que le noyau de ϕ−<span style="font-style:italic">Id</span> est
composé des polynômes <span style="font-style:italic">Q</span> tels que <span style="font-style:italic">Q</span> (mod <span style="font-style:italic">F</span><sub><span style="font-style:italic">j</span></sub> ) est constant
(dans ℤ/<span style="font-style:italic">p</span>ℤ) pour tout <span style="font-style:italic">j</span>.</p><p>Si <span style="font-style:italic">Q</span> (mod <span style="font-style:italic">F</span><sub><span style="font-style:italic">j</span></sub> )=<span style="font-style:italic">s</span><sub><span style="font-style:italic">j</span></sub> ∈ ℤ/<span style="font-style:italic">p</span>ℤ, alors <span style="font-style:italic">Q</span><sup><span style="font-style:italic">p</span></sup> (mod <span style="font-style:italic">F</span><sub><span style="font-style:italic">j</span></sub> )=<span style="font-style:italic">s</span><sub><span style="font-style:italic">j</span></sub><sup><span style="font-style:italic">p</span></sup>=<span style="font-style:italic">s</span><sub><span style="font-style:italic">j</span></sub>, donc
par le théorème des restes chinois, <span style="font-style:italic">Q</span>=<span style="font-style:italic">Q</span><sup><span style="font-style:italic">p</span></sup> (mod <span style="font-style:italic">P</span> ). </p><p>Réciproquement, si
<span style="font-style:italic">Q</span><sup><span style="font-style:italic">p</span></sup>−<span style="font-style:italic">Q</span>=0 (mod <span style="font-style:italic">P</span> ), en utilisant la factorisation :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">X</span><sup><span style="font-style:italic">p</span></sup>−<span style="font-style:italic">X</span>= Π<sub><span style="font-style:italic">j</span> ∈ ℤ/<span style="font-style:italic">p</span>ℤ </sub> (<span style="font-style:italic">X</span>−<span style="font-style:italic">j</span>)</td></tr>
</table><p>
on en tire <span style="font-style:italic">P</span> divise <span style="font-style:italic">Q</span><sup><span style="font-style:italic">p</span></sup>−<span style="font-style:italic">Q</span>=Π<sub><span style="font-style:italic">j</span> ∈ ℤ/<span style="font-style:italic">p</span>ℤ </sub> (<span style="font-style:italic">Q</span>(<span style="font-style:italic">X</span>)−<span style="font-style:italic">j</span>),
donc <span style="font-style:italic">F</span><sub><span style="font-style:italic">j</span></sub> divise l’un des facteurs et <span style="font-style:italic">Q</span>(<span style="font-style:italic">X</span>) (mod <span style="font-style:italic">F</span><sub><span style="font-style:italic">j</span></sub> ) ∈ ℤ/<span style="font-style:italic">p</span>ℤ.
Le noyau de ϕ −<span style="font-style:italic">Id</span>
est donc un espace vectoriel de dimension <span style="font-style:italic">n</span>, le nombre
de facteurs irréductibles de <span style="font-style:italic">P</span> et possède donc <span style="font-style:italic">p</span><sup><span style="font-style:italic">n</span></sup> éléments
(en effet pour tout <span style="font-style:italic">n</span> uplet de <span style="font-style:italic">s</span><sub><span style="font-style:italic">j</span></sub>, on peut construire un polynôme
<span style="font-style:italic">Q</span> du noyau par le théorème des restes chinois en posant <span style="font-style:italic">Q</span>(mod <span style="font-style:italic">F</span><sub><span style="font-style:italic">j</span></sub> )=<span style="font-style:italic">s</span><sub><span style="font-style:italic">j</span></sub>).</p><p>L’intérêt du noyau de ϕ−<span style="font-style:italic">Id</span> est qu’on peut le calculer sans connaitre
les <span style="font-style:italic">F</span><sub><span style="font-style:italic">j</span></sub>. Une fois ce calcul fait, voyons comment on peut remonter 
aux <span style="font-style:italic">F</span><sub><span style="font-style:italic">j</span></sub>. On connait déjà la dimension du noyau donc le nombre de facteurs
irréductibles. De plus, on remarque que le polynome constant 1 est un
élément du noyau qu’on appellera <span style="font-style:italic">T</span><sub>1</sub>, on note alors <span style="font-style:italic">T</span><sub>2</sub>,...,<span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub> les
autres polynômes unitaires d’une base du noyau. 
Ensuite, on calcule le pgcd de <span style="font-style:italic">P</span> avec <span style="font-style:italic">T</span><sub>2</sub>−<span style="font-style:italic">jT</span><sub>1</sub>
pour <span style="font-style:italic">j</span>∈ ℤ/<span style="font-style:italic">p</span>ℤ. On sait que <span style="font-style:italic">T</span><sub>2</sub>=<span style="font-style:italic">s</span><sub>2,<span style="font-style:italic">k</span></sub> (mod <span style="font-style:italic">F</span><sub><span style="font-style:italic">k</span></sub> ), donc pgcd(<span style="font-style:italic">P</span>,<span style="font-style:italic">T</span><sub>2</sub>−<span style="font-style:italic">jT</span><sub>1</sub>)
est égal au produit des facteurs <span style="font-style:italic">F</span><sub><span style="font-style:italic">k</span></sub> tels que <span style="font-style:italic">s</span><sub>2,<span style="font-style:italic">k</span></sub>=<span style="font-style:italic">jT</span><sub>1</sub>. L’un au moins
des pgcd calculés est non trivial car sinon <span style="font-style:italic">T</span><sub>2</sub>=<span style="font-style:italic">T</span><sub>1</sub> (mod <span style="font-style:italic">F</span><sub><span style="font-style:italic">j</span></sub> ) pour
tout <span style="font-style:italic">j</span> donc <span style="font-style:italic">T</span><sub>2</sub>=<span style="font-style:italic">T</span><sub>1</sub>. Si on a de la chance tous les <span style="font-style:italic">s</span><sub>2,<span style="font-style:italic">j</span></sub> seront
distincts et les pgcd non triviaux de <span style="font-style:italic">P</span> avec <span style="font-style:italic">T</span><sub>2</sub>−<span style="font-style:italic">jT</span><sub>1</sub> donneront les <span style="font-style:italic">F</span><sub><span style="font-style:italic">k</span></sub>.
Sinon il faudra continuer avec <span style="font-style:italic">T</span><sub>3</sub>−<span style="font-style:italic">jT</span><sub>1</sub> etc.</p><p><span style="font-weight:bold">Exemple</span> :<br>
Revenons sur la factorisation de <span style="font-style:italic">P</span>:=(<span style="font-style:italic">x</span><sup>6</sup>+2<span style="font-style:italic">x</span><sup>5</sup>+<span style="font-style:italic">x</span><sup>2</sup>+<span style="font-style:italic">x</span>+2) (mod 5 ).
Commençons par calculer la matrice de ϕ dans la base
{ 1,<span style="font-style:italic">x</span>,<span style="font-style:italic">x</span><sup>2</sup>,...,<span style="font-style:italic">x</span><sup>5</sup>}. On a évidemment ϕ(1)=1 et
ϕ(<span style="font-style:italic">x</span>)=<span style="font-style:italic">x</span><sup>5</sup>, puis ϕ(<span style="font-style:italic">x</span><sup>2</sup>)=<span style="font-style:italic">x</span><sup>10</sup>=<span style="font-style:italic">x</span><sup>5</sup>+<span style="font-style:italic">x</span><sup>4</sup>−2<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span> (mod <span style="font-style:italic">P</span> ),
puis en multipliant par <span style="font-style:italic">x</span><sup>5</sup> et en divisant par <span style="font-style:italic">P</span>,
ϕ(<span style="font-style:italic">x</span><sup>3</sup>)=−<span style="font-style:italic">x</span><sup>4</sup>+2<span style="font-style:italic">x</span><sup>3</sup>, de la même manière on obtient 
ϕ(<span style="font-style:italic">x</span><sup>4</sup>)=−<span style="font-style:italic">x</span><sup>5</sup>+2<span style="font-style:italic">x</span><sup>4</sup>+<span style="font-style:italic">x</span><sup>3</sup>−<span style="font-style:italic">x</span><sup>2</sup>−2 et ϕ(<span style="font-style:italic">x</span><sup>5</sup>)=<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">x</span>.
La matrice de ϕ est donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">M</span>=</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">
</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >−2</td><td style="text-align:center;white-space:nowrap" >0</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >−1</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >1</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >−2</td><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >0</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >0</td></tr>
</table></td><td class="dcell">
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
On calcule ensuite le noyau de ϕ−<span style="font-style:italic">Id</span> (comme matrice à coefficients
dans ℤ/5ℤ), on obtient une
base du noyau en prenant par exemple les vecteurs (−1,0,0,0,0,0)
et (0,0,−1,−1,0,−1). Donc le polynôme <span style="font-style:italic">P</span> possède 2 facteurs dans
ℤ/5ℤ[<span style="font-style:italic">X</span>]. Pour déterminer les facteurs, on calcule le pgcd de <span style="font-style:italic">P</span>
avec le polynôme <span style="font-style:italic">T</span><sub>2</sub>−<span style="font-style:italic">s</span> où <span style="font-style:italic">T</span><sub>2</sub>=−<span style="font-style:italic">x</span><sup>5</sup>−<span style="font-style:italic">x</span><sup>3</sup>−<span style="font-style:italic">x</span><sup>2</sup> correspond au 2ème
vecteur de la base du noyau. On obtient pour <span style="font-style:italic">s</span>=0 un pcgd non trivial
(<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span>+1), ce qui permet de calculer les 2 facteurs. Si on avait
essayé d’autres valeurs de <span style="font-style:italic">s</span>, pour <span style="font-style:italic">s</span>=1 on obtient comme pgcd 1, pour
<span style="font-style:italic">s</span>=2 on trouve le 2ème facteur <span style="font-style:italic">x</span><sup>3</sup>+2<span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">x</span>+2.</p>
<!--TOC subsubsection id="sec167" Remontée (Hensel)-->
<h4 id="sec167" class="subsubsection">18.2.5  Remontée (Hensel)</h4><!--SEC END --><p> <a id="hevea_default195"></a>
Il s’agit de passer d’une factorisation de <span style="font-style:italic">P</span> dans ℤ/<span style="font-style:italic">p</span>ℤ[<span style="font-style:italic">X</span>] à une
factorisation de <span style="font-style:italic">P</span> dans ℤ/<span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">Z</span>[<span style="font-style:italic">X</span>], la méthode est analogue à celle
de l’algorithme EZGCD de calcul de pgcd de polynômes.</p><p>On suppose donc que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>=Π<sub><span style="font-style:italic">j</span>=1</sub><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> (mod <span style="font-style:italic">p</span> ) </td></tr>
</table><p>
où les <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> sont premiers entre eux deux à deux dans ℤ/<span style="font-style:italic">p</span>ℤ.
Il s’agit de trouver des polynômes <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">k</span></sub>=<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> (mod <span style="font-style:italic">p</span> ) tels que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>=Π<sub><span style="font-style:italic">j</span>=1</sub><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">k</span></sub> (mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup> ) </td></tr>
</table><p>
Commençons par le cas <span style="font-style:italic">k</span>=2. On pose
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span>,2</sub>=<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>+<span style="font-style:italic">pQ</span><sub><span style="font-style:italic">j</span></sub>=<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> (mod <span style="font-style:italic">p</span> ) </td></tr>
</table><p>
On a alors :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">P</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >Π<sub><span style="font-style:italic">j</span>=1</sub><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span>,2</sub> (mod <span style="font-style:italic">p</span><sup>2</sup> ) =Π<sub><span style="font-style:italic">j</span>=1</sub><sup><span style="font-style:italic">n</span></sup> (<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>+<span style="font-style:italic">pQ</span><sub><span style="font-style:italic">j</span></sub>) (mod <span style="font-style:italic">p</span><sup>2</sup> )</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">Π<sub><span style="font-style:italic">j</span>=1</sub><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> + <span style="font-style:italic">p</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> Π<sub><span style="font-style:italic">k</span>≠ <span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> (mod <span style="font-style:italic">p</span><sup>2</sup> ) 
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> Π<sub><span style="font-style:italic">k</span>≠ <span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span>−Π<sub><span style="font-style:italic">j</span>=1</sub><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span></td></tr>
</table></td><td class="dcell"> (mod <span style="font-style:italic">p</span> ) </td></tr>
</table><p>
On est ramené à résoudre une identité de Bézout généralisée.
On montrera dans l’appendice le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 32</span>  <em> (Identité de Bézout généralisée)
Soit </em><span style="font-style:italic">P</span><sub>1</sub><em>, ..., </em><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub><em> (</em><span style="font-style:italic">n</span>≥ 2<em>) des polynômes premiers entre eux deux 
à deux modulo </em><span style="font-style:italic">p</span><em>. Alors pour tout polynôme </em><span style="font-style:italic">Q</span><em>, il existe des polynômes 
</em><span style="font-style:italic">Q</span><sub>1</sub><em>, ..., </em><span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span></sub><em> tels que :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> Π<sub><span style="font-style:italic">k</span>≠ <span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">Q</span> (mod <span style="font-style:italic">p</span> ) </td></tr>
</table><em>
</em></div><p>On a donc réussi à remonter l’égalité <span style="font-style:italic">P</span>=Π <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> (mod <span style="font-style:italic">p</span> ) à 
<span style="font-style:italic">P</span>=Π <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span>,2</sub> (mod <span style="font-style:italic">p</span><sup>2</sup> ). Le passage de <span style="font-style:italic">P</span>=Π <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">l</span></sub> (mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup> )
à <span style="font-style:italic">P</span>=Π <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">l</span>+1</sub> (mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span>+1</sup> ) est identique, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">l</span>+1</sub>=<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">l</span></sub>+<span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup><span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> </td></tr>
</table><p>
où les <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> sont les solutions de l’identité de Bézout généralisée avec :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Q</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span>−Π<sub><span style="font-style:italic">j</span>=1</sub><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">l</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup></td></tr>
</table></td></tr>
</table><p>Lorsqu’on programme cet algorithme (cf. l’appendice), 
on calcule une fois pour toutes les
solutions de l’identité de Bézout pour <span style="font-style:italic">Q</span>=1, et on multiplie par <span style="font-style:italic">Q</span>.</p><p><span style="font-weight:bold">Algorithme de remontée de Hensel linéaire</span><br>
Arguments: Un polynôme <span style="font-style:italic">P</span> à coefficients entiers, la liste <span style="font-style:italic">L</span>={ <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> } 
de ses facteurs dans ℤ/<span style="font-style:italic">p</span>ℤ[<span style="font-style:italic">X</span>]<br>
Valeur renvoyée: la liste des facteurs de <span style="font-style:italic">P</span> dans ℤ/<span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup> ℤ[<span style="font-style:italic">X</span>]<br>
On calcule la borne de Landau-Mignotte<sup><a id="text28" href="#note28">28</a></sup> 
pour les facteurs de <span style="font-style:italic">P</span>, on multiplie
par le coefficient dominant de <span style="font-style:italic">P</span> et on calcule <span style="font-style:italic">l</span> tel que <span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup> est
strictement plus grand que deux fois cette quantité. On calcule
aussi les polynômes <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> de l’identité de Bézout généralisée pour <span style="font-style:italic">Q</span>=1<br>
Puis on fait une boucle pour <span style="font-style:italic">k</span> variant de 2 à <span style="font-style:italic">l</span>:
</p><ul class="itemize"><li class="li-itemize">
On détermine <span style="font-style:italic">P</span>−Π<sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> (mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup> ), on divise par <span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span>−1</sup>
et on place le résultat dans <span style="font-style:italic">Q</span>
</li><li class="li-itemize">On multiplie les polynômes <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> de l’identité de Bézout 
généralisée (correspondants au polynôme 1) par <span style="font-style:italic">Q</span>
et on détermine le reste de la division euclidienne de <span style="font-style:italic">Q</span> <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> par <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>,
on multiplie par <span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span>−1</sup> et on ajoute le résultat à <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>.
</li></ul><p>Il existe une version quadratique de cette méthode. On passe alors de
<span style="font-style:italic">P</span>=Π <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">l</span></sub> (mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup> ) à <span style="font-style:italic">P</span>=Π <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span>,2<span style="font-style:italic">l</span></sub> (mod <span style="font-style:italic">p</span><sup>2<span style="font-style:italic">l</span></sup> ). Pour
cela, il faut trouver les polynômes <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> solutions de l’équation :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> Π<sub><span style="font-style:italic">k</span>≠ <span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span>,<span style="font-style:italic">l</span></sub>=<span style="font-style:italic">Q</span> (mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup> )</td></tr>
</table><p>
Pour <span style="font-style:italic">l</span>=1, c’est l’identité de Bézout généralisée, mais ce n’est plus le
cas pour <span style="font-style:italic">l</span>&gt;1. En fait, on résout cette égalité en remontant l’identité
de Bézout quadratiquement, plus précisément pour trouver les <span style="font-style:italic">S</span><sub><span style="font-style:italic">j</span></sub>
solutions de
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">S</span><sub><span style="font-style:italic">j</span></sub> Π<sub><span style="font-style:italic">k</span>≠ <span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span>,2<span style="font-style:italic">l</span></sub>=<span style="font-style:italic">Q</span> (mod <span style="font-style:italic">p</span><sup>2<span style="font-style:italic">l</span></sup> )</td></tr>
</table><p>
on pose <span style="font-style:italic">S</span><sub><span style="font-style:italic">j</span></sub>=<span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub>+<span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup> <span style="font-style:italic">R</span><sub><span style="font-style:italic">j</span></sub>, il s’agit donc de trouver les <span style="font-style:italic">R</span><sub><span style="font-style:italic">j</span></sub> solutions de
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub>+<span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup> <span style="font-style:italic">R</span><sub><span style="font-style:italic">j</span></sub>) Π<sub><span style="font-style:italic">k</span>≠ <span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span>,2<span style="font-style:italic">l</span></sub>=<span style="font-style:italic">Q</span> (mod <span style="font-style:italic">p</span><sup>2<span style="font-style:italic">l</span></sup> )</td></tr>
</table><p>
soit :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">R</span><sub><span style="font-style:italic">j</span></sub> Π<sub><span style="font-style:italic">k</span>≠ <span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span>,<span style="font-style:italic">l</span></sub>
=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Q</span>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> Π<sub><span style="font-style:italic">k</span>≠ <span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span>,<span style="font-style:italic">l</span></sub> </td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup></td></tr>
</table></td><td class="dcell"> (mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup> )</td></tr>
</table><p>
on en déduit les <span style="font-style:italic">R</span><sub><span style="font-style:italic">j</span></sub>.</p><p><span style="font-weight:bold">Algorithme de remontée de Hensel quadratique</span><br>
Arguments et valeur renvoyée identiques à l’algorithme de remontée de Hensel
linéaire ci-dessus.<br>
On commence comme dans le cas linéaire par calculer les coefficients
de l’identité de Bézout généralisée pour <span style="font-style:italic">Q</span>=1 et la valeur de <span style="font-style:italic">l</span> telle
que <span style="font-style:italic">p</span><sup>2<sup><span style="font-style:italic">l</span></sup></sup> soit supérieur à deux fois la borne de Landau des facteurs
de <span style="font-style:italic">P</span> fois le coefficient dominant de <span style="font-style:italic">P</span>.<br>
On fait une boucle sur <span style="font-style:italic">k</span> variant de 1 à <span style="font-style:italic">l</span>:
</p><ul class="itemize"><li class="li-itemize">
On calcule <span style="font-style:italic">P</span>−Π<sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> (mod <span style="font-style:italic">p</span><sup>2<sup><span style="font-style:italic">k</span></sup></sup> ), on divise par <span style="font-style:italic">p</span><sup>2<sup><span style="font-style:italic">k</span>−1</sup></sup>
et on place le résultat dans <span style="font-style:italic">Q</span>
</li><li class="li-itemize">On multiplie par <span style="font-style:italic">Q</span> les polynômes <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> de l’identité de Bézout
généralisée (avec comme second membre le polynôme 1),
on calcule le reste euclidien du résultat par <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> (modulo <span style="font-style:italic">p</span><sup>2<sup><span style="font-style:italic">k</span>−1</sup></sup>), 
on multiplie par <span style="font-style:italic">p</span><sup>2<sup><span style="font-style:italic">k</span>−1</sup></sup> et on ajoute à <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> (avec les notations
précédentes, on passe ainsi des <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span>,2<sup><span style="font-style:italic">k</span>−1</sup></sub> aux <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span>,2<sup><span style="font-style:italic">k</span></sup></sub>)
</li><li class="li-itemize">Si <span style="font-style:italic">k</span>=<span style="font-style:italic">l</span> on renvoie la liste des <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>
</li><li class="li-itemize">On calcule 1−∑<sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> Π<sub><span style="font-style:italic">k</span>≠ <span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> (mod <span style="font-style:italic">p</span><sup>2<sup><span style="font-style:italic">k</span></sup></sup> ), on
divise par <span style="font-style:italic">p</span><sup>2<sup><span style="font-style:italic">k</span>−1</sup></sup> et on place le résultat dans <span style="font-style:italic">Q</span>
</li><li class="li-itemize">On multiplie par <span style="font-style:italic">Q</span> les polynômes <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> de l’identité de Bézout,
généralisée et on calcule le reste euclidien du résultat par 
<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> (modulo <span style="font-style:italic">p</span><sup>2<sup><span style="font-style:italic">k</span>−1</sup></sup>), on multiplie par <span style="font-style:italic">p</span><sup>2<sup><span style="font-style:italic">k</span>−1</sup></sup> et 
on ajoute à <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> (ce qui ajuste les polynômes <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> qui vérifient
maintenant l’identité de Bézout modulo <span style="font-style:italic">p</span><sup>2<sup><span style="font-style:italic">k</span></sup></sup>)
</li></ul><p><span style="font-weight:bold">Remarque</span><br>
Pendant l’étape de remontée de Hensel, une optimisation classique
consiste à tester la divisibilité dans ℤ du polynôme <span style="font-style:italic">P</span> par le 
facteur lifté <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> (<sup><a id="text29" href="#note29">29</a></sup>)
lorsqu’il n’a pas subi de modification pendant 2 étapes successives
(autrement dit lorsque <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> (mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup> )=<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> (mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span>+1</sup> ) (ou
(mod <span style="font-style:italic">p</span><sup>2<span style="font-style:italic">l</span></sup> ) pour le lift quadratique). Si la division
est exacte, on obtient un facteur irréductible de <span style="font-style:italic">P</span> dans ℤ.
On recalcule alors la borne de Landau de <span style="font-style:italic">P</span>/<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> pour diminuer
le nombre d’itérations à effectuer dans cette étape.</p><p><span style="font-weight:bold">Exemple</span> :<br>
Reprenons le polynôme <span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>)=(<span style="font-style:italic">X</span><sup>3</sup>+<span style="font-style:italic">X</span>+1)(<span style="font-style:italic">X</span><sup>4</sup>−<span style="font-style:italic">X</span>+1)
et supposons qu’on ait choisi de le factoriser modulo 5 puis 
de remonter. On a 3 facteurs
<span style="font-style:italic">a</span>=<span style="font-style:italic">x</span>−2, <span style="font-style:italic">b</span>=<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span>+1 et <span style="font-style:italic">c</span>=<span style="font-style:italic">x</span><sup>3</sup>+2<span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">x</span>+2. Si on développe <span style="font-style:italic">P</span>, on trouve 6
coefficients non nuls de valeur absolue 1, 
on peut calculer la borne de Landau-Mignotte correspondante
sur les coefficients d’un facteur entier : 2<sup>5</sup> (√<span style="text-decoration:overline">(</span>6)+1)
soit un peu plus de 110, il suffit donc d’effectuer 3 étapes de
remontée linéaire (5<sup>4</sup>=625&gt;111/2).
On commence par trouver 3 polynômes <span style="font-style:italic">A</span>, <span style="font-style:italic">B</span>, <span style="font-style:italic">C</span> tels que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">A</span>(<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span>+1)(<span style="font-style:italic">x</span><sup>3</sup>+2<span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">x</span>+2)+<span style="font-style:italic">B</span>(<span style="font-style:italic">x</span>−2)(<span style="font-style:italic">x</span><sup>3</sup>+2<span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">x</span>+2)+</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >+<span style="font-style:italic">C</span>(<span style="font-style:italic">x</span>−2)(<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span>+1)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >1 (mod 5 )
</td></tr>
</table></td></tr>
</table><p>
On commence par résoudre <span style="font-style:italic">D</span>(<span style="font-style:italic">x</span><sup>3</sup>+2<span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">x</span>+2)+<span style="font-style:italic">C</span>(<span style="font-style:italic">x</span>−2)(<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span>+1)=1(mod 5 ),
on trouve <span style="font-style:italic">C</span>=2<span style="font-style:italic">x</span><sup>2</sup>−2 et <span style="font-style:italic">D</span>=−2<span style="font-style:italic">x</span><sup>3</sup>−2<span style="font-style:italic">x</span><sup>2</sup>+2<span style="font-style:italic">x</span>+1. Puis on calcule
<span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> en résolvant <span style="font-style:italic">E</span>(<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span>+1)+<span style="font-style:italic">F</span>(<span style="font-style:italic">x</span>−2)=1 qui donne <span style="font-style:italic">E</span>=1 et 
<span style="font-style:italic">F</span>=−<span style="font-style:italic">x</span><sup>2</sup>−2<span style="font-style:italic">x</span> qu’on multiplie par <span style="font-style:italic">D</span>, donc <span style="font-style:italic">A</span>=<span style="font-style:italic">D</span> et <span style="font-style:italic">B</span>=2<span style="font-style:italic">x</span><sup>5</sup>+<span style="font-style:italic">x</span><sup>4</sup>+2<span style="font-style:italic">x</span><sup>3</sup>−2<span style="font-style:italic">x</span>.
Ce qui donne l’identité de Bézout généralisée.</p><p>Passons aux calculs de remontée. On a <span style="font-style:italic">abc</span>=<span style="font-style:italic">x</span><sup>7</sup>−4<span style="font-style:italic">x</span><sup>5</sup>+5<span style="font-style:italic">x</span><sup>4</sup>+−9<span style="font-style:italic">x</span><sup>3</sup>−<span style="font-style:italic">x</span><sup>2</sup>−4
et <span style="font-style:italic">P</span>=<span style="font-style:italic">x</span><sup>7</sup>+<span style="font-style:italic">x</span><sup>5</sup>+<span style="font-style:italic">x</span><sup>3</sup>−<span style="font-style:italic">x</span><sup>2</sup>+1, donc <span style="font-style:italic">Q</span>=(<span style="font-style:italic">P</span>−<span style="font-style:italic">abc</span>)/5=<span style="font-style:italic">x</span><sup>5</sup>−<span style="font-style:italic">x</span><sup>4</sup>+2<span style="font-style:italic">x</span><sup>3</sup>+1. On pose
alors 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">a</span><sub>1</sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">a</span>+5  (<span style="font-style:italic">QA</span> (mod <span style="font-style:italic">a</span> ))(mod 25 ), </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">b</span><sub>1</sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">b</span>+5  (<span style="font-style:italic">QB</span> (mod <span style="font-style:italic">b</span> )) (mod 25 ), </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">c</span><sub>1</sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">c</span>+5  (<span style="font-style:italic">QC</span> (mod <span style="font-style:italic">c</span> )) (mod 25 ) 
</td></tr>
</table></td></tr>
</table><p>
donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub>1</sub>= <span style="font-style:italic">a</span>+5 × (−2),    <span style="font-style:italic">b</span><sub>1</sub>=<span style="font-style:italic">b</span>+5 × 0, 
   <span style="font-style:italic">c</span><sub>1</sub>=<span style="font-style:italic">c</span>+5 × (2<span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">x</span>) </td></tr>
</table><p>
En principe, on continue encore 2 itérations de la même manière.
La 2ème itération donne : 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Q</span>=(<span style="font-style:italic">P</span>−<span style="font-style:italic">a</span><sub>1</sub> <span style="font-style:italic">b</span><sub>1</sub> <span style="font-style:italic">c</span><sub>1</sub>)/25= 6<span style="font-style:italic">x</span><sup>5</sup>−3<span style="font-style:italic">x</span><sup>4</sup>+7<span style="font-style:italic">x</span><sup>3</sup>+3<span style="font-style:italic">x</span><sup>2</sup>−2<span style="font-style:italic">x</span>+1</td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">a</span><sub>2</sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">a</span><sub>1</sub>+25  (<span style="font-style:italic">QA</span> (mod <span style="font-style:italic">a</span> )) (mod 125 ), </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">b</span><sub>2</sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">b</span><sub>1</sub>+25  (<span style="font-style:italic">QB</span> (mod <span style="font-style:italic">b</span> )) (mod 125 ),</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">c</span><sub>2</sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">c</span><sub>1</sub>+25  (<span style="font-style:italic">QC</span> (mod <span style="font-style:italic">c</span> )) (mod 125 )
</td></tr>
</table></td></tr>
</table><p>
donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub>2</sub>=<span style="font-style:italic">a</span><sub>1</sub> +25(−1)=<span style="font-style:italic">x</span>−37,  <span style="font-style:italic">b</span><sub>2</sub>=<span style="font-style:italic">b</span><sub>1</sub>=<span style="font-style:italic">b</span>,  <span style="font-style:italic">c</span><sub>2</sub>=<span style="font-style:italic">c</span><sub>1</sub>+25(<span style="font-style:italic">x</span><sup>2</sup>+1) 
=<span style="font-style:italic">x</span><sup>3</sup>+37<span style="font-style:italic">x</span><sup>2</sup>−6<span style="font-style:italic">x</span>+27 </td></tr>
</table><p>On peut aussi observer que <span style="font-style:italic">b</span><sub>1</sub>=<span style="font-style:italic">b</span>, ceci laisse à penser que <span style="font-style:italic">b</span> est 
un facteur de <span style="font-style:italic">P</span> dans ℤ ce qu’on vérifie en effectuant la
division euclidienne de <span style="font-style:italic">P</span> par <span style="font-style:italic">b</span>=<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span>+1. Comme elle tombe
juste, on est ramené à factoriser <span style="font-style:italic">x</span><sup>4</sup>−<span style="font-style:italic">x</span>+1 et donc à remonter
la factorisation de <span style="font-style:italic">ac</span>. La borne de Landau diminue à 8(√<span style="text-decoration:overline">3</span>+1)
puisque le degré est 4 et la norme euclidienne du polynôme est √<span style="text-decoration:overline">3</span>.
Il suffit alors de remonter dans ℤ/125 ℤ au lieu de ℤ/625 ℤ
(on gagne ainsi une itération).</p>
<!--TOC subsubsection id="sec168" Combinaison de facteurs-->
<h4 id="sec168" class="subsubsection">18.2.6  Combinaison de facteurs</h4><!--SEC END --><p>
Lorsqu’on a les facteurs de <span style="font-style:italic">P</span> dans ℤ/<span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup>ℤ[<span style="font-style:italic">X</span>] avec <span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup> plus grand
que le produit du coefficient dominant de <span style="font-style:italic">P</span> multiplié par la borne
de Landau-Mignotte sur les coefficients de <span style="font-style:italic">P</span>, on commence par
tester la divisibilité dans ℤ[<span style="font-style:italic">X</span>] de <span style="font-style:italic">P</span> par chaque facteur trouvé
multiplié par le coefficient dominant de <span style="font-style:italic">P</span>. Si la division est
exacte, on a un facteur irréductible, mais si elle n’est pas exacte
il peut se produire qu’un facteur irréductible de <span style="font-style:italic">P</span> dans ℤ[<span style="font-style:italic">X</span>] soit un
produit de deux, voir plusieurs, facteurs modulaires. Il faut
donc tester la divisibilité de <span style="font-style:italic">P</span> dans ℤ[<span style="font-style:italic">X</span>] par toutes les combinaisons 
possibles de produits de facteurs modulaires (toujours multiplié par
le coefficient dominant de <span style="font-style:italic">P</span>). Cette étape peut être exponentiellement
longue si le nombre de facteurs modulaires est grand et si par
exemple <span style="font-style:italic">P</span> est irréductible, bien que les cas soient très rares. </p><p><span style="font-weight:bold">Algorithme de recombinaison</span><br>
Arguments: un polynôme à coefficients entiers, primitif et sans facteur 
multiple <span style="font-style:italic">P</span> de coefficient dominant <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub>,
la liste <span style="font-style:italic">L</span> des facteurs de <span style="font-style:italic">P</span> dans ℤ/<span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup> <span style="font-style:italic">Z</span>[<span style="font-style:italic">X</span>] pour 
<span style="font-style:italic">l</span> assez grand et <span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup><br>
Valeur de retour: la liste <span style="font-style:italic">F</span> des facteurs de <span style="font-style:italic">P</span> dans ℤ.<br>
Initialiser <span style="font-style:italic">F</span> à vide, initialiser le nombre de facteurs à combine <span style="font-style:italic">c</span> 
à 1, entamer une boucle infinie :
</p><ul class="itemize"><li class="li-itemize">
Si <span style="font-style:italic">c</span> est strictement supérieur au cardinal de <span style="font-style:italic">L</span> divisé par 2,
ajouter le quotient de <span style="font-style:italic">P</span> par le produit des facteurs de <span style="font-style:italic">F</span> à <span style="font-style:italic">F</span> 
et retourner <span style="font-style:italic">F</span>
</li><li class="li-itemize">Initialiser un vecteur <span style="font-style:italic">v</span>=(<span style="font-style:italic">v</span><sub>1</sub>,...,<span style="font-style:italic">v</span><sub><span style="font-style:italic">c</span></sub>) à <span style="font-style:italic">c</span> composantes à
la valeur (1,...,<span style="font-style:italic">c</span>)
</li><li class="li-itemize">Boucle indéfinie intérieure :
<ol class="enumerate" type=1><li class="li-enumerate">
Faire le produit des facteurs de <span style="font-style:italic">F</span> d’indice <span style="font-style:italic">v</span>, multiplier
par <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> dans ℤ/<span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup> <span style="font-style:italic">Z</span>, écrire le facteur en représentation symétrique,
le rendre primitif et tester si c’est un facteur de <span style="font-style:italic">P</span> dans ℤ.
</li><li class="li-enumerate">Si on a trouvé un facteur, le rajouter à la liste <span style="font-style:italic">F</span> et supprimer les
indices de <span style="font-style:italic">v</span> de la liste <span style="font-style:italic">L</span>, terminer cette boucle intérieure.
</li><li class="li-enumerate">Sinon, incrémenter <span style="font-style:italic">v</span> de la manière suivante:<br>
On fait une boucle sur un index <span style="font-style:italic">m</span> initialisé à la taille de <span style="font-style:italic">v</span>,
diminuant de 1 à chaque itération: on ajoute 1 à l’élement de <span style="font-style:italic">v</span>
d’indice <span style="font-style:italic">m</span>, si l’élément obtenu est inférieur ou égal
au cardinal de <span style="font-style:italic">L</span>+<span style="font-style:italic">m</span>−<span style="font-style:italic">n</span>, on arrête cette boucle, sinon on passe
à l’itération suivante. Si <span style="font-style:italic">m</span>=0 à la fin de la boucle, <span style="font-style:italic">v</span>
ne peut pas être incrémenté. 
</li><li class="li-enumerate">Si <span style="font-style:italic">v</span> ne peut être incrémenté, on incrémente <span style="font-style:italic">c</span> et on termine
la boucle intérieure.
</li><li class="li-enumerate">Sinon on fait une boucle à nouveau
sur <span style="font-style:italic">m</span> en partant de la valeur actuelle incrémentée de 1, et tant
que <span style="font-style:italic">m</span>≤ <span style="font-style:italic">n</span> on pose <span style="font-style:italic">v</span><sub><span style="font-style:italic">m</span></sub>=<span style="font-style:italic">v</span><sub><span style="font-style:italic">m</span>−1</sub>+1. Puis on passe à l’itération
suivante de la boucle intérieure.
</li></ol>
</li></ul><p>Il existe différentes méthodes
qui améliorent la complexité de cette étape :
</p><ul class="itemize"><li class="li-itemize">
La recherche des degré possibles de facteurs fondée sur
la factorisation en degrés distincts pour différents nombres premiers 
permet d’éviter des tests de division si une combinaison de facteurs
est d’un degré exclu par la factorisation pour d’autres nombres premiers.
</li><li class="li-itemize">Le test de divisibilité du coefficient dominant ou du coefficient
constant permet aussi d’éviter des divisions complètes de polynômes.
</li></ul><p>
Mais ces astuces n’évitent pas l’énumération de toutes les combinaisons
possibles de facteurs et donc la complexité exponentielle. Lorsque
les combinaisons d’un petit nombre de facteurs (par exemple 3)
échouent, les systèmes récents utilisent
l’algorithme <span style="font-weight:bold">knapsack</span><a id="hevea_default196"></a> de Van Hoeij basé sur l’algorithme LLL
(recherche de base d’un réseau ayant des vecteurs de petite norme) 
qui permet d’eliminer complètement cette complexité exponentielle.</p><p><span style="font-weight:bold">Exemple</span> :<br>
Toujours le même exemple, il nous restait deux
facteurs dans ℤ/125 ℤ, le facteur <span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span>+1 ayant été
détecté comme un facteur de <span style="font-style:italic">P</span>=<span style="font-style:italic">x</span><sup>7</sup>+<span style="font-style:italic">x</span><sup>5</sup>+<span style="font-style:italic">x</span><sup>3</sup>−<span style="font-style:italic">x</span><sup>2</sup>+1 dans ℤ.
On teste chacun des facteurs <span style="font-style:italic">a</span><sub>2</sub>=<span style="font-style:italic">x</span>−37 et <span style="font-style:italic">c</span><sub>2</sub>=<span style="font-style:italic">x</span><sup>3</sup>+37<span style="font-style:italic">x</span><sup>2</sup>−6*<span style="font-style:italic">x</span>+27
séparément, sans succès. On les multiplie alors modulo 125,
ce qui donne <span style="font-style:italic">x</span><sup>4</sup>−<span style="font-style:italic">x</span>+1 en représentation symétrique qui est bien
un facteur de <span style="font-style:italic">P</span> (donc un facteur irréductible).</p>
<!--TOC subsection id="sec169" Factorisation à plusieurs variables-->
<h3 id="sec169" class="subsection">18.3  Factorisation à plusieurs variables</h3><!--SEC END --><p>
Comme pour le PGCD en plusieurs variables, on se ramène d’abord en
une variable, en général on évalue toutes les variables sauf celle
correspondant au degré partiel le plus faible. On factorise ensuite
en une variable puis on remonte. A chaque étape de remontée, il peut
être à nouveau nécessaire de combiner plusieurs facteurs. Différentes
stratégies existent, comme pour le PGCD : factorisarion heuristique
(avec reconstruction <span style="font-style:italic">z</span>-adique), remontée variable par variable
ou toutes les variables en même temps comme dans EZGCD.
On va présenter ici plus en détails l’algorithme de factorisation heuristique.</p><p>Soit <span style="font-style:italic">P</span> un polynôme en <span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub> à coefficients entiers avec <span style="font-style:italic">n</span>&gt;1,
on choisit une des variables par exemple <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>, qu’on notera <span style="font-style:italic">X</span> dans la suite.
On considère <span style="font-style:italic">P</span> comme un polynôme en <span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub> à coefficients dans 
ℤ[<span style="font-style:italic">X</span>]. On suppose que <span style="font-style:italic">P</span> est primitif (quitte à extraire
son contenu qui est dans ℤ[<span style="font-style:italic">X</span>]). On calcule ensuite
<span style="font-style:italic">P</span>(<span style="font-style:italic">z</span>) pour un entier <span style="font-style:italic">z</span> tel que<sup><a id="text30" href="#note30">30</a></sup> |<span style="font-style:italic">z</span>| ≥ 2|<span style="font-style:italic">P</span>|+2. On factorise <span style="font-style:italic">P</span>(<span style="font-style:italic">z</span>)
dans ℤ[<span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub>] :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:heu1"></a>
<span style="font-style:italic">P</span>(<span style="font-style:italic">z</span>)(<span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub>)=<span style="font-style:italic">c</span>(<span style="font-style:italic">z</span>) Π<sub><span style="font-style:italic">j</span>=1</sub><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>(<span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub>)
    (21)</td></tr>
</table><p>
où <span style="font-style:italic">c</span> est le contenu du polynôme <span style="font-style:italic">P</span>(<span style="font-style:italic">z</span>) (comme polynôme en <span style="font-style:italic">n</span>−1 
variables à coefficients entiers). Il s’agit de reconstruire les facteurs
de <span style="font-style:italic">P</span> à partir des <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub> et de <span style="font-style:italic">c</span>. Deux problèmes se posent alors,
celui de la recombinaison possible de plusieurs facteurs <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub> pour
obtenir un facteur irréductible de <span style="font-style:italic">P</span>, et l’existence d’un facteur entier du
contenu <span style="font-style:italic">c</span> à combiner avec un ou plusieurs <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub> pour obtenir ce
facteur irréductible. Plus précisément, si <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> est un facteur 
irréductible de <span style="font-style:italic">P</span>, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:heu2"></a>
<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>(<span style="font-style:italic">z</span>)=<span style="font-style:italic">d</span>(<span style="font-style:italic">z</span>) Π<sub>certains  <span style="font-style:italic">j</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>,    où  
<span style="font-style:italic">d</span>(<span style="font-style:italic">z</span>)  divise  <span style="font-style:italic">c</span>(<span style="font-style:italic">z</span>)
    (22)</td></tr>
</table><p>On a le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 33</span>  <em>
Soit </em><span style="font-style:italic">P</span>(<span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub>,<span style="font-style:italic">X</span>)<em> un polynôme à coefficients 
entiers ayant au moins 2 variables. On suppose que </em><span style="font-style:italic">P</span><em> est primitif
vu comme polynôme en les variables </em><span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub><em>
à coefficients dans </em><span style="font-style:italic">Z</span>[<span style="font-style:italic">X</span>]<em>.
Il existe une majoration </em><span style="font-style:italic">C</span><em> du contenu </em>|<span style="font-style:italic">c</span>(<span style="font-style:italic">z</span>)|<em> de </em><span style="font-style:italic">P</span><em> évalué en </em><span style="font-style:italic">X</span>=<span style="font-style:italic">z</span><em>
(plus précisément on peut trouver un entier </em><span style="font-style:italic">C</span><em> tel que </em><span style="font-style:italic">c</span>(<span style="font-style:italic">z</span>)<em> divise
</em><span style="font-style:italic">C</span><em>).<br>
Il existe un nombre fini de </em><span style="font-style:italic">z</span><em> tels que l’un des facteurs irréductibles
</em><span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub><em> de </em><span style="font-style:italic">P</span><em> évalué en </em><span style="font-style:italic">X</span>=<span style="font-style:italic">z</span><em> soit
réductible (c’est-à-dire tels que (</em><a href="#eq%3Aheu2"><em>22</em></a><em>) admette 
plusieurs facteurs </em><span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub><em> distincts)
</em></div><p><span style="font-weight:bold">Preuve</span><br>
Pour déterminer <span style="font-style:italic">C</span>, on remarque que les facteurs du contenu de <span style="font-style:italic">P</span>(<span style="font-style:italic">z</span>)
sont des facteurs communs des coefficients de <span style="font-style:italic">P</span> évalués en <span style="font-style:italic">z</span>
vu comme polynôme en <span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub> à coefficients dans ℤ[<span style="font-style:italic">X</span>].
Donc <span style="font-style:italic">c</span>(<span style="font-style:italic">z</span>) divise le générateur de l’idéal engendré par ces coefficients
(ce générateur est un polynôme de ℤ[<span style="font-style:italic">X</span>] qui est constant car on a supposé
<span style="font-style:italic">P</span> primitif), on peut aussi dire que deux au moins des coefficients
dans ℤ[<span style="font-style:italic">X</span>] de <span style="font-style:italic">P</span> sont premiers entre eux, alors <span style="font-style:italic">c</span>(<span style="font-style:italic">z</span>) divise le
coefficient de l’identité de Bézout de ces 2 coefficients vu
comme polynômes en <span style="font-style:italic">X</span>.</p><p>Considérons maintenant un facteur irréductible <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> de <span style="font-style:italic">P</span> de degré <span style="font-style:italic">d</span>
par rapport à <span style="font-style:italic">X</span>. Pour <span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub> fixés, on factorise <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> sur ℂ :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>(<span style="font-style:italic">X</span>)=<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> Π<sub><span style="font-style:italic">j</span>=1</sub><sup><span style="font-style:italic">d</span></sup> (<span style="font-style:italic">X</span>−<span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub>) </td></tr>
</table><p>
On va maintenant se restreindre à un domaine des <span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub> sur
lequel les <span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub> ont une dépendance analytique par rapport à <span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub>.
Pour cela on veut appliquer le théorème des fonctions implicites pour 
déterminer <span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub> au voisinage d’une solution donnée. On calcule donc
la dérivée <span style="font-style:italic">P</span>′<sub><span style="font-style:italic">k</span></sub> de <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> par rapport à <span style="font-style:italic">X</span>. On sait que <span style="font-style:italic">P</span> n’a pas
de facteurs multiples, donc <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> et <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>′ sont premiers entre
eux, donc d’après l’identité de Bézout, il existe un polynôme non nul <span style="font-style:italic">D</span>
dépendant de <span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub> et deux polynômes <span style="font-style:italic">U</span> et <span style="font-style:italic">V</span> dépendant
de <span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub>,<span style="font-style:italic">X</span> tels que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">U</span> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> + <span style="font-style:italic">V</span> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>′ = <span style="font-style:italic">D</span> </td></tr>
</table><p>
Si <span style="font-style:italic">D</span>(<span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub>) ne s’annule pas, on va pouvoir appliquer le théorème
des fonctions implicites. On se fixe <span style="font-style:italic">x</span><sub>1</sub>,..,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>,
on calcule dans ℂ les racines <span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub> du polynôme <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span><sub>1</sub>,..,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>,<span style="font-style:italic">X</span>)
pour une solution <span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub> telle que <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span><sub>1</sub>,..,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>,<span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub>)=0, 
comme <span style="font-style:italic">D</span> est non nul, on a <span style="font-style:italic">P</span>′(<span style="font-style:italic">x</span><sub>1</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>,<span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub>)≠ 0, donc on peut 
écrire au voisinage de (<span style="font-style:italic">x</span><sub>1</sub>,..,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>)
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub>=<span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub>(<span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub>),    <span style="font-style:italic">P</span>(<span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub>,<span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub>)=0</td></tr>
</table><p> 
avec des fonctions <span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub> analytiques. 
Si <span style="font-style:italic">D</span> est constant, <span style="font-style:italic">D</span> ne s’annule pas, 
sinon quitte à permuter les variables, on peut supposer que
le degré de <span style="font-style:italic">D</span> par rapport à <span style="font-style:italic">X</span><sub>1</sub> est non nul.
On peut alors se restreindre à une zone <span style="font-style:italic">X</span><sub>1</sub> &gt;&gt; <span style="font-style:italic">X</span><sub>2</sub> &gt;&gt; .. &gt;&gt; <span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub> &gt;&gt; 1
où <span style="font-style:italic">D</span> sera non nul ce qui permet de suivre analytiquement les <span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub>.</p><p>Supposons maintenant qu’il existe un nombre infini de <span style="font-style:italic">z</span> tels <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>(<span style="font-style:italic">z</span>) 
soit réductible. Alors il existe un ensemble infini <span style="font-style:italic">Z</span>
de ces valeurs de <span style="font-style:italic">z</span> pour lesquels l’un des facteurs à coefficients
entiers <span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub> de <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>(<span style="font-style:italic">z</span>) correspond à un même
sous-ensemble <span style="font-style:italic">R</span> des racines <span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub> de <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> et à un même contenu
<span style="font-style:italic">c</span> (puisqu’il y a un nombre fini de combinaisons possibles des
racines en facteur et un nombre fini de diviseurs possibles
du contenu de <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>). Pour <span style="font-style:italic">z</span> ∈ <span style="font-style:italic">Z</span>, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub>(<span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">z</span>)=<span style="font-style:italic">c</span> Π<sub><span style="font-style:italic">l</span> ∈ <span style="font-style:italic">R</span></sub> (<span style="font-style:italic">z</span>−<span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub>),    
<span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub> ∈ ℤ[<span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub>] </td></tr>
</table><p>
Soit <span style="font-style:italic">L</span>(<span style="font-style:italic">X</span>) le polynôme obtenu par interpolation de Lagrange 
en cardinal(<span style="font-style:italic">R</span>)+1 points <span style="font-style:italic">z</span> de <span style="font-style:italic">Z</span>, égal à <span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub> en <span style="font-style:italic">X</span>=<span style="font-style:italic">z</span>.
Pour des raisons de degré, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">L</span>=<span style="font-style:italic">c</span> Π<sub><span style="font-style:italic">l</span> ∈ <span style="font-style:italic">R</span></sub> (<span style="font-style:italic">X</span>−<span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub>) </td></tr>
</table><p>
donc <span style="font-style:italic">L</span> est un facteur de <span style="font-style:italic">P</span>.
De plus <span style="font-style:italic">L</span> est un polynôme en <span style="font-style:italic">X</span><sub>1</sub>,...,<span style="font-style:italic">X</span><sub><span style="font-style:italic">n</span>−1</sub>,<span style="font-style:italic">X</span> à coefficients
rationnels (par construction). Ceci vient en contradiction avec l’hypothèse 
<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> irréductible, car on a construit un facteur de <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> à coefficients
rationnels <span style="font-style:italic">L</span> de degré strictement inférieur.</p><p><span style="font-weight:bold">Corollaire</span><br>
Pour <span style="font-style:italic">z</span> assez grand, la reconstruction <span style="font-style:italic">z</span>-adique de <span style="font-style:italic">c</span>(<span style="font-style:italic">z</span>) <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>(<span style="font-style:italic">z</span>) est
un polynôme dont la partie primitive est un facteur irréductible de <span style="font-style:italic">P</span>.</p><p><span style="font-weight:bold">Preuve du corollaire</span><br>
On prend <span style="font-style:italic">z</span> assez grand pour que tous les facteurs irréductibles de <span style="font-style:italic">P</span>
évalués en <span style="font-style:italic">z</span> aient un seul facteur polynomial (i.e. soient de la forme 
<span style="font-style:italic">d</span>(<span style="font-style:italic">z</span>)<span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>(<span style="font-style:italic">z</span>)). Quitte à augmenter <span style="font-style:italic">z</span>, on peut supposer que 
|<span style="font-style:italic">z</span>|&gt; 2 <span style="font-style:italic">C</span> <span style="font-style:italic">L</span>  où <span style="font-style:italic">C</span> est la majoration de |<span style="font-style:italic">c</span>(<span style="font-style:italic">z</span>)| et <span style="font-style:italic">L</span> est la borne 
de Landau sur les facteurs de <span style="font-style:italic">P</span>. Alors la reconstruction <span style="font-style:italic">z</span>-adique
de <span style="font-style:italic">c</span>(<span style="font-style:italic">z</span>)<span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>(<span style="font-style:italic">z</span>) est <span style="font-style:italic">c</span>(<span style="font-style:italic">z</span>)/<span style="font-style:italic">d</span>(<span style="font-style:italic">z</span>)<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>, donc sa partie primitive est un
facteur irréductible de <span style="font-style:italic">P</span>.</p><p><span style="font-weight:bold">Algorithme de factorisation heuristique à plusieurs variables</span><br>
Argument: un polynôme <span style="font-style:italic">P</span> primitif en au moins 2 variables.<br>
Valeur renvoyée: les facteurs irréductibles de <span style="font-style:italic">P</span><br>
Choisir la variable <span style="font-style:italic">X</span> par rapport à laquelle <span style="font-style:italic">P</span> est de plus bas degré puis
factoriser le contenu de <span style="font-style:italic">P</span> vu comme polynôme à coefficients dans ℤ[<span style="font-style:italic">X</span>].
Initialiser un entier <span style="font-style:italic">z</span> à 2|<span style="font-style:italic">P</span>|+2 (où |<span style="font-style:italic">P</span>| est le plus grand coefficient 
entier de <span style="font-style:italic">P</span> en valeur absolue) et une liste <span style="font-style:italic">L</span> à la factorisation de
du contenu de <span style="font-style:italic">P</span>.<br>
Boucle indéfinie :
</p><ul class="itemize"><li class="li-itemize">
Si <span style="font-style:italic">P</span>=1 renvoyer la liste <span style="font-style:italic">L</span> des facteurs de <span style="font-style:italic">P</span>.
</li><li class="li-itemize">Tant que pgcd(<span style="font-style:italic">P</span>(<span style="font-style:italic">z</span>),<span style="font-style:italic">P</span>′(<span style="font-style:italic">z</span>))=0 incrémenter <span style="font-style:italic">z</span> de 1.
</li><li class="li-itemize">Factoriser <span style="font-style:italic">P</span>(<span style="font-style:italic">z</span>)=<span style="font-style:italic">c</span>(<span style="font-style:italic">z</span>)Π <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>
</li><li class="li-itemize">Pour tous les facteurs <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>, déterminer le polynôme <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> tel que 
<span style="font-style:italic">c</span>(<span style="font-style:italic">z</span>)<span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>=<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>(<span style="font-style:italic">z</span>) par remontée
<span style="font-style:italic">z</span>-adique (avec les coefficients de <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> écrit en représentation
symétrique, de valeur absolue plus petite que |<span style="font-style:italic">z</span>|/2). Tester si
la partie primitive de <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> divise <span style="font-style:italic">P</span>. Si oui, rajouter un facteur
irréductible à la liste <span style="font-style:italic">L</span>, et diviser <span style="font-style:italic">P</span> par ce facteur.
</li><li class="li-itemize">Augmenter <span style="font-style:italic">z</span>, par exemple remplacer <span style="font-style:italic">z</span> par la partie entière de
√<span style="text-decoration:overline">2</span><span style="font-style:italic">z</span>.
</li></ul>
<!--TOC subsection id="sec170" Preuve de l’identité de Bézout généralisée-->
<h3 id="sec170" class="subsection">18.4  Preuve de l’identité de Bézout généralisée</h3><!--SEC END --><p>
Elle se fait par récurrence. Pour <span style="font-style:italic">n</span>=2, c’est l’identité de Bézout usuelle. 
Pour passer
du rang <span style="font-style:italic">n</span>−1 au rang <span style="font-style:italic">n</span>, on isole <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> dans l’identité à résoudre :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> (Π<sub>1 ≤ <span style="font-style:italic">k</span> ≤ <span style="font-style:italic">n</span>−1,<span style="font-style:italic">k</span>≠ <span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>) </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> + 
<span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span></sub> Π<sub><span style="font-style:italic">k</span>≤ <span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> =<span style="font-style:italic">Q</span> (mod <span style="font-style:italic">p</span> )</td></tr>
</table><p>
Comme <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> est premier avec Π<sub><span style="font-style:italic">k</span>≤ <span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>, en appliquant Bézout,
on trouve deux polynômes <span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span></sub> et <span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub> tels que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:Qn"></a>
<span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> + <span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span></sub> Π<sub><span style="font-style:italic">k</span>≤ <span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> =<span style="font-style:italic">Q</span> (mod <span style="font-style:italic">p</span> ) 
    (23)</td></tr>
</table><p>
Il reste à résoudre
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> Π<sub>1 ≤ <span style="font-style:italic">k</span> ≤ <span style="font-style:italic">n</span>−1,<span style="font-style:italic">k</span>≠ <span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub> (mod <span style="font-style:italic">p</span> )</td></tr>
</table><p>
ce que l’on peut faire par hypothèse de récurrence.</p>
<!--TOC subsection id="sec171" Algorithme de Bézout généralisé-->
<h3 id="sec171" class="subsection">18.5  Algorithme de Bézout généralisé</h3><!--SEC END --><p><a id="hevea_default197"></a>
Arguments: une liste <span style="font-style:italic">P</span><sub>1</sub>,...,<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> de polynômes premiers entre eux 2 à 2 
et un polynôme <span style="font-style:italic">Q</span> à coefficients dans ℤ/<span style="font-style:italic">p</span>ℤ<br>
Valeur renvoyée: la liste de polynômes <span style="font-style:italic">Q</span><sub>1</sub>,...,<span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span></sub> tels que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> Π<sub><span style="font-style:italic">k</span>≠ <span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">Q</span> (mod <span style="font-style:italic">p</span> ) </td></tr>
</table><p>
On peut commencer par calculer le produit de tous les <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> puis faire une 
boucle sur <span style="font-style:italic">j</span> pour calculer les produits des <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> pour <span style="font-style:italic">k</span>≠ <span style="font-style:italic">j</span> en divisant
le produit complet par <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> (on fait ainsi <span style="font-style:italic">n</span>−1 multiplications et
<span style="font-style:italic">n</span> divisions au lieu de <span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>−1) multiplications).<br>
Boucle indéfinie sur <span style="font-style:italic">n</span> décrémenté de 1 par itération :
</p><ul class="itemize"><li class="li-itemize">
Si <span style="font-style:italic">n</span>=2, on rajoute à la liste résultat les polynômes 
<span style="font-style:italic">Q</span><sub>1</sub> et <span style="font-style:italic">Q</span><sub>2</sub> de l’algorithme de Bézout usuel et on renvoie la liste
</li><li class="li-itemize">Sinon, on calcule les polynômes <span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub> et <span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span></sub> vérifiant (<a href="#eq%3AQn">23</a>),
on rajoute <span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span></sub> en début de liste, on remplace <span style="font-style:italic">Q</span> par <span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub>.
</li></ul><p>
Remarquons que lorsque nous utiliserons cet algorithme, <span style="font-style:italic">Q</span> sera la différence
entre deux polynômes de même degré (le degré de <span style="font-style:italic">P</span>) et de même coefficient
dominant 1, on peut donc
remplacer les <span style="font-style:italic">Q</span><sub><span style="font-style:italic">i</span></sub> par le reste euclidien de <span style="font-style:italic">Q</span><sub><span style="font-style:italic">i</span></sub> par <span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub> sans
changer l’égalité.</p>
<!--TOC subsection id="sec172" Factorisation rationnelle et sur une extension-->
<h3 id="sec172" class="subsection">18.6  Factorisation rationnelle et sur une extension</h3><!--SEC END --><p>
<a id="sec:factorisation_extension"></a>
<a id="hevea_default198"></a> <a id="hevea_default199"></a><a id="hevea_default200"></a> 
Pour factoriser des polynômes ayant des coefficients dans des
extensions algébriques, il existe un algorithme assez simple, 
l’algorithme de Trager, qui n’est pas forcément le plus performant 
(la recherche est encore active dans ce domaine), cf. le livre de 
Henri Cohen pp. 142-144. Cet algorithme est utilisé lorsqu’on
met l’extension algébrique en deuxième argument de <code>factor</code>
dans Xcas. Pour trouver l’extension algébrique qui permet de
factoriser, on peut dans les cas simples essayer <code>solve</code>. Si
le polynôme <span style="font-style:italic">P</span> à factoriser est irréductible sur ℚ, 
on peut essayer <code>factor(P,rootof(P))</code>. Mais en général
cela ne permettra d’extraire qu’un seul facteur de degré 1. Pour
obtenir une décomposition complète si <span style="font-style:italic">P</span> est de petit
degré, on peut essayer de construire une extension en
formant une expression non symétrique à partir des racines approchées,
puis en appliquant toutes les permutations de racines à cette
expression et en construisant le polynôme ayant ces racines,
si on a suffisamment de précision sur les racines, on peut arrondir
le polynôme obtenu, le factoriser sur ℚ, et prendre un des
facteurs irréductibles de degré suffisant comme argument de
<code>rootof</code>.</p><p>Par exemple soit à factoriser <span style="font-style:italic">P</span>=<span style="font-style:italic">x</span><sup>4</sup>+3<span style="font-style:italic">x</span>+1 sur <span style="text-decoration:overline">ℚ</span>.
On entre la fonction suivante :
</p><pre class="verbatim">f(P):={
  local k,l,p,r,j;
  l:=proot(P);
  if (dim(l)!=4) return "erreur";
  k:=max(abs(l));
  k:=floor(24*log10(1+4*k))+4; // 4 chiffres de precision en plus
  l:=proot(P,k);
  p:=[0,1,2,3];
  r:=[];
  for j from 0 to 23 do
    k:=l[p[0]]-l[p[1]]+2*l[p[2]];
    r:=append(r,k);
    p:=nextperm(p);
  od;
  retourne r;
}:;
</pre><p>puis <code>q:=pcoef(f(x^4+3x+1))</code>, on voit que les
coefficients sont presque entiers, on fait donc
<code>factor(x^4+3x+1,rootof(round(q)))</code>
qui décompose <span style="font-style:italic">x</span><sup>4</sup>+3<span style="font-style:italic">x</span>+1 en 4 facteurs de degré 1. Le polynôme
obtenu est de degré 24 (cas générique), si <span style="font-style:italic">P</span> est de degré
<span style="font-style:italic">n</span>, on s’attend à un degré <span style="font-style:italic">n</span>!, au-delà de <span style="font-style:italic">n</span>=5, cette
méthode est trop couteuse! Attention aussi, même pour <span style="font-style:italic">n</span>=4, il peut être
nécessaire de calculer les racines en multi-précision, 
par exemple ci-dessus les éléments
de <code>r</code> sont majorés par 4<span style="font-style:italic">R</span> où <span style="font-style:italic">R</span> est un majorant du module 
des racines de <span style="font-style:italic">P</span>, donc
les coefficients de <code>q</code> sont majorés par exemple par (1+4<span style="font-style:italic">R</span>)<sup>24</sup>
≈ 2<span style="font-style:italic">e</span>20 donc on prend 24 chiffres.</p><p>Autre méthode utilisant la représentation rationnelle
univariée (section <a href="#sec%3Arur">9.8</a>) : 
on écrit le système vérifié par les relations
racines-coefficients, ici<br>
<code>P:=x^4+3x+1;eq:=lcoeff(P)*pcoef([a,b,c,d])-symb2poly(P)</code><br>
on vérifie qu’on obtient les 24 permutations de racines par<br>
<code>cfsolve(eq,[a,b,c,d])</code><br>
Le polynôme permettant de factoriser complètement <span style="font-style:italic">P</span> se lit dans<br>
<code>G:=gbasis(eq,[a,b,c,d],rur);</code><br>
on obtient la factorisation complète par :<br>
<code>factor(x^4+3x+1,rootof(G[2]))</code><br>
On peut aussi la déduire de l’expressions des racines<br>
<code>Q:=product(x-rootof(G[k],G[2])/rootof(G[3],G[2]),</code><br>
<code>   k,4,size(G)-1);normal(Q)</code><br>
Pour un polynome quelconque, on peut utiliser le script suivant<br>
</p><pre class="verbatim">extension(p):={
local l,s,g;
 l:=seq(expr("x"+j),j,1,degree(p));
 s:=lcoeff(p)*pcoeff(l)-symb2poly(p);
 g:=gbasis(s,l,rur);
 return g[2];
}
</pre><p>mais les calculs deviennent très vite monstrueux!</p><p>Pour les polynômes à plusieurs variables, Giac commence par donner
la valeur 0 à toutes les variables sauf celle correspondant à la variable de
degré partiel minimum. Si le polynôme obtenu est square-free, alors Giac
reconstruit par remontée de Hensel les facteurs, en augmentant
au fur et à mesure le degré des facteurs par rapport aux autres
variables. En cas d’échec, l’algorithme de Trager est utilisé,
ce qui est en général beaucoup plus lent (à commencer par le
calcul de la “norme” du polynôme à factoriser par un résultant).</p>
<!--TOC subsection id="sec173" Factorisation absolue-->
<h3 id="sec173" class="subsection">18.7  Factorisation absolue</h3><!--SEC END --><p><a id="hevea_default201"></a> <a id="sec:factorisation_absolue"></a>
On peut aussi se demander pour un polynôme à coefficients
rationnels (squarefree) quelle extension<a id="hevea_default202"></a><a id="hevea_default203"></a> 
permet la factorisation la plus
complète. Par exemple <span style="font-style:italic">x</span><sup>2</sup>+<span style="font-style:italic">y</span><sup>2</sup> est irréductible sur ℚ[<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>]
mais pas sur ℚ[<span style="font-style:italic">i</span>][<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>] ou <span style="font-style:italic">x</span><sup>4</sup>+<span style="font-style:italic">y</span><sup>4</sup> est irréductible sur ℚ[<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>]
mais pas sur ℚ[√<span style="text-decoration:overline">2</span>][<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>]. Ceci amène à la notion
de <em>factorisation absolue</em> d’un polynôme. Une méthode simple
(mais pas forcément très efficace) pour déterminer une telle
extension algébrique consiste à évaluer toutes les variables
sauf une “au hasard" jusqu’à obtenir un polynôme irréductible <span style="font-style:italic">M</span>.
On factorise alors sur le corps correspondant à <span style="font-style:italic">M</span>. Mais cela
peut être très long, par exemple pour 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)=<span style="font-style:italic">y</span><sup>10</sup>−2<span style="font-style:italic">x</span><sup>2</sup><span style="font-style:italic">y</span><sup>4</sup>+4<span style="font-style:italic">x</span><sup>6</sup><span style="font-style:italic">y</span><sup>2</sup>−2<span style="font-style:italic">x</span><sup>10</sup></td></tr>
</table><p>
on a <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>,1) irréductible, on obtient donc la factorisation
absolue par les commande<br>
<code>p(x,y):=y^10-2x^2*y^4+4x^6*y^2-2x^10;</code><br>
<code>p1:=p(1,y); factor(p1);</code> (vérification)<br>
<code>factor(p(x,y),rootof(p1));</code><br>
mais c’est beaucoup plus long que de faire <code>factor(p1,sqrt(2))</code>.</p><p>Pour un polynôme à 2 variables (on peut toujours s’y ramener) de
degrés partiels <span style="font-style:italic">m</span>,<span style="font-style:italic">n</span> en <span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>,
on remarque que le degré <span style="font-style:italic">q</span> ≥ 2 de l’extension nécessaire est
égal au nombre de facteurs (chaque facteur étant conjugué d’un
facteur donné par échange des racines), qui sont donc tous de même
bi-degré <span style="font-style:italic">m</span>/<span style="font-style:italic">q</span>,<span style="font-style:italic">n</span>/<span style="font-style:italic">q</span>, en particulier <span style="font-style:italic">q</span> divise le PGCD de <span style="font-style:italic">m</span> et <span style="font-style:italic">n</span>
qui doit être non trivial. Ainsi par exemple pour 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>,<span style="font-style:italic">Y</span>)=<span style="font-style:italic">Y</span><sup>4</sup> +2<span style="font-style:italic">Y</span><sup>2</sup>*<span style="font-style:italic">X</span>+14<span style="font-style:italic">Y</span><sup>2</sup> −7*<span style="font-style:italic">X</span><sup>2</sup> +6<span style="font-style:italic">X</span>+47</td></tr>
</table><p>
<span style="font-style:italic">m</span>=2 donc <span style="font-style:italic">q</span> ne peut être égal qu’à 2, en faisant <span style="font-style:italic">Y</span>=0 on
obtient que la seule extension possible est √<span style="text-decoration:overline">2</span>.</p><p>Voir aussi la session <code>afactor.xws</code> du menu Exemple, poly de Xcas.</p>
<!--TOC subsection id="sec174" Compléments-->
<h3 id="sec174" class="subsection">18.8  Compléments</h3><!--SEC END --><p>
Pour factoriser sur des corps finis, on peut consulter la thèse
de Bernardin disponible sur le web (<code>http://www.bernardin.lu</code>).</p><p>L’algorithme récursif qui suit permet d’écrire un <span style="font-weight:bold">polynôme
symétrique</span><a id="hevea_default204"></a><a id="hevea_default205"></a>
en <span style="font-style:italic">n</span> variables (noté <code>s</code> dans le programme)
en fonction des polynômes symétriques élémentaires. L’idée
est de remplacer la dernière variable <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> par 0, le polynôme
obtenu <span style="font-style:italic">Q</span> est symétrique en les autres variables, on appelle
récursivement la procédure (avec une variable de moins),
elle renvoie un polynôme
<span style="font-style:italic">V</span>. On crée dans <code>S</code> les polynômes symétriques
élémentaires avec la fonction <code>pcoeff</code>, on les utilise
pour substituer
dans <span style="font-style:italic">V</span> par les polynômes symétriques élémentaires sauf
le dernier, ce qui donne <span style="font-style:italic">V</span><sub><span style="font-style:italic">s</span></sub> symétrisé de <span style="font-style:italic">V</span> par rapport aux
<span style="font-style:italic">n</span> variables, puis on retranche <span style="font-style:italic">V</span><sub><span style="font-style:italic">s</span></sub> de <span style="font-style:italic">P</span>. Par construction on doit 
obtenir un polynôme divisible par le produit des <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>&gt;: en effet
<span style="font-style:italic">P</span>−<span style="font-style:italic">Q</span> est divisible par <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> donc <span style="font-style:italic">P</span>−<span style="font-style:italic">V</span><sub><span style="font-style:italic">s</span></sub> aussi donc par symétrie
il est divisible par le produit des <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>. C’est le polynôme
<span style="font-style:italic">q</span> ci-dessous, auquel on applique récursivement l’algorithme
(le degré a été dimuné de <span style="font-style:italic">n</span>).

</p><pre class="verbatim">restart;
sym(P,X):={ // P polynome symetrique, X liste des variables
  local s,xs,Q,V,W,S,q,r;
  s:=size(X);
  si s&lt;=1 alors return P; fsi;
  xs:=X[s-1];
  si !contains(lname(P),xs) alors return P; fsi; // polynome constant
  Q:=normal(subst(P,xs=0)); // Q est symetrique en X[0..s-2]
  V:=sym(Q,X[0..s-2]); // appel recursif
  S:=pcoeff(X[0..s-1]); // polynomes symetriques en les X
  pour k de 0 jusque size(S)-1 faire S[k]=(-1)^k*S[k]; fpour;
  q,r:=quorem((P-subst(V,X[0..s-2],S[1..s-1])),S[s],xs); // reste nul
  si r!=0 alors throw("non symetrique"); fsi;
  W:=sym(q,X);
  retourne V+W*xs;
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;t.value=tmp;tmp=UI.caseval(tmp);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML);field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>

Par exemple
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">p:=sym(x^3+y^3+z^3,[x,y,z]) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
exprime <span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">y</span><sup>3</sup>+<span style="font-style:italic">z</span><sup>3</sup> en fonction de <span style="font-style:italic">x</span>+<span style="font-style:italic">y</span>+<span style="font-style:italic">z</span>,<span style="font-style:italic">xy</span>+<span style="font-style:italic">xz</span>+<span style="font-style:italic">yz</span>,<span style="font-style:italic">xyz</span>,
on vérifie 
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">normal(subst(p,[x,y,z],[x+y+z,x*y+x*z+y*z,x*y*z])) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p>
<!--TOC subsection id="sec175" Exercices (factorisation des polynômes)-->
<h3 id="sec175" class="subsection">18.9  Exercices (factorisation des polynômes)</h3><!--SEC END --><ol class="enumerate" type=1><li class="li-enumerate">
Déterminer le nombre de racines de −<span style="font-style:italic">x</span><sup>7</sup>+<span style="font-style:italic">x</span><sup>4</sup>+12<span style="font-style:italic">x</span>−5 comprises
entre 0 et 6 (en utilisant les suites de Sturm, on donnera les
détails des calculs).
</li><li class="li-enumerate">Écrire un programme calculant la suite de Sturm d’un polynôme
supposé squarefree (on peut tester avec <code>sqrfree</code>), en utilisant
l’algorithme d’Euclide.
</li><li class="li-enumerate">Prendre un polynôme de degré 100 à coefficients
aléatoires (<code>randpoly</code>), le factoriser numériquement
(<code>proot</code>) puis donner pour les premières racines
approchées renvoyées des intervalles ou disques où
on peut certifier qu’il existe une racine.
</li><li class="li-enumerate">Calculer avec un logiciel les valeurs numériques des racines
complexes de <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">x</span><sup>5</sup>+<span style="font-style:italic">x</span>+1. Trouver les combinaisons de racines
dont la somme est entière (aux arrondis près). En déduire la factorisation
en facteurs irréductibles sur ℤ de <span style="font-style:italic">P</span>.
</li><li class="li-enumerate">Soit <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">x</span><sup>5</sup>+3<span style="font-style:italic">x</span>+1. Déterminer des valeurs approchées
des racines complexes de <span style="font-style:italic">P</span>. En déduire des boules dans le
plan complexe contenant exactement une racine de <span style="font-style:italic">P</span> et
de rayon plus petit que <code>1e-12</code>. En utilisant la méthode
de Newton avec du calcul exact, déterminer des valeurs approchées
certifiées à <code>1e-40</code> près des racines complexes de <span style="font-style:italic">P</span>.
</li><li class="li-enumerate">Localiser les parties réelles et imaginaires des racines
complexes de <span style="font-style:italic">P</span>(<span style="font-style:italic">z</span>)=<span style="font-style:italic">z</span><sup>5</sup>+3<span style="font-style:italic">z</span>+1 en utilisant les suites de Sturm
et le résultant de la partie réelle et imaginaire de
<span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">iy</span>). Comparer cette méthode avec celle de l’exercice
précédent (en particulier que se passe-t-il pour un polynôme
de degré <span style="font-style:italic">n</span>).
</li><li class="li-enumerate">Factorisation numérique sur ℂ. Écrire un programme
qui calcule une racine d’un polynôme à coefficients complexes
en utilisant une méthode itérative de type méthode de Newton 
(avec éventuellement un préfacteur lorsqu’on débute la recherche).
Les polynômes seront représentés par la liste de leurs coefficients
et l’évaluation faite par la méthode de Horner.
Trouver ensuite toutes les racines du polynôme en éliminant la
racine trouvée (toujours avec Horner). Trouver les combinaisons
de racines correspondant à un facteur à coefficients entiers.
</li><li class="li-enumerate">Soit <span style="font-style:italic">p</span> un entier premier et <span style="font-style:italic">P</span> un polynôme à
coefficients dans ℤ/<span style="font-style:italic">p</span>ℤ. On a la relation
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">gcd</span>(<span style="font-style:italic">X</span><sup><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup></sup>−<span style="font-style:italic">X</span>,<span style="font-style:italic">P</span>) = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"> <span style="font-style:italic">f</span> | <span style="font-style:italic">P</span>, <span style="font-size:small">deg</span>(<span style="font-style:italic">f</span>) | <span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>, 
   <span style="font-style:italic">f</span>  irréductible </td></tr>
</table>
En utilisant cette relation, 
déterminer les degrés des facteurs de 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span>+1)(<span style="font-style:italic">x</span><sup>4</sup>+<span style="font-style:italic">x</span>+1) </td></tr>
</table>
modulo 5 et 7 (sans utiliser la commande factor). 
Peut-on en déduire que <span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span>+1 et
<span style="font-style:italic">x</span><sup>4</sup>+<span style="font-style:italic">x</span>+1 sont irréductibles sur ℤ?
</li><li class="li-enumerate">Utiliser les options “verbose” de votre logiciel de calcul formel
pour factoriser <span style="font-style:italic">x</span><sup>202</sup>+<span style="font-style:italic">x</span><sup>101</sup>+1 et vérifiez que vous avez compris
la méthode utilisée.
</li><li class="li-enumerate">Trouver les facteurs de degré 1 s’ils existent de
3<span style="font-style:italic">x</span><sup>5</sup>+25<span style="font-style:italic">x</span><sup>4</sup>+67<span style="font-style:italic">x</span><sup>3</sup>+77<span style="font-style:italic">x</span><sup>2</sup>+55<span style="font-style:italic">x</span>+13 en remontant ses racines
dans ℤ/<span style="font-style:italic">pZ</span>[<span style="font-style:italic">X</span>] pour <span style="font-style:italic">p</span> premier bien choisi.
</li><li class="li-enumerate">Factoriser le polynôme <span style="font-style:italic">x</span><sup>5</sup>+<span style="font-style:italic">x</span>+1 par la méthode 
de Berlekamp.
</li><li class="li-enumerate">Montrer que 2<span style="font-style:italic">x</span>+<span style="font-style:italic">x</span><sup>2</sup><span style="font-style:italic">y</span>+<span style="font-style:italic">x</span><sup>3</sup>+2<span style="font-style:italic">x</span><sup>4</sup>+<span style="font-style:italic">y</span><sup>3</sup>+<span style="font-style:italic">x</span><sup>5</sup> est irréductible sur ℤ
sans utiliser l’instruction factor à 2 variables (on pourra factoriser 
pour quelques valeurs de <span style="font-style:italic">x</span> ou de <span style="font-style:italic">y</span>)</li><li class="li-enumerate">Que se passe-t-il lorsqu’on exécute l’algorithme de Yun
dans ℤ/<span style="font-style:italic">n</span>ℤ?</li><li class="li-enumerate">Recherche des facteurs de degré 2 d’un polynôme à coefficients
réels sans racines réelles en utilisant la méthode de Bairstow décrite
ci-dessous.<br>
On cherche un facteur <span style="font-style:italic">F</span>=<span style="font-style:italic">x</span><sup>2</sup>+<span style="font-style:italic">sx</span>+<span style="font-style:italic">p</span> de <span style="font-style:italic">P</span>, on calcule le quotient et le reste
de la division <span style="font-style:italic">P</span>=<span style="font-style:italic">FQ</span>+<span style="font-style:italic">R</span> par une méthode de type Horner, il s’agit de 
rendre <span style="font-style:italic">R</span> (vu comme un vecteur à 2 composantes) nul. On calcule
donc ∂<sub><span style="font-style:italic">s</span>,<span style="font-style:italic">p</span></sub> <span style="font-style:italic">R</span> (en cherchant le quotient et le reste
de <span style="font-style:italic">xQ</span> et <span style="font-style:italic">Q</span> par <span style="font-style:italic">F</span>, pourquoi?) et on pose :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">s</span>,<span style="font-style:italic">p</span>)<sub><span style="font-style:italic">n</span>+1</sub>=(<span style="font-style:italic">s</span>,<span style="font-style:italic">p</span>)<sub><span style="font-style:italic">n</span></sub>− λ (∂<sub><span style="font-style:italic">s</span>,<span style="font-style:italic">p</span></sub> <span style="font-style:italic">R</span>)<sup>−1</sup> <span style="font-style:italic">R</span> (<span style="font-style:italic">s</span>,<span style="font-style:italic">p</span>)<sub><span style="font-style:italic">n</span></sub></td></tr>
</table>
où λ est un préfacteur compris entre 0 et 1 et ajusté à 1 
lorsqu’on est proche du facteur.</li></ol>
<!--TOC section id="sec176" Intégration formelle.-->
<h2 id="sec176" class="section">19  Intégration formelle.</h2><!--SEC END --><p><a id="sec:intg"></a><a id="hevea_default206"></a> <a id="hevea_default207"></a>
</p>
<!--TOC subsection id="sec177" Introduction-->
<h3 id="sec177" class="subsection">19.1  Introduction</h3><!--SEC END --><p>
Que peut-on espérer d’un système de calcul formel lorsqu’il s’agit
de calculer une primitive? Tout d’abord, on peut espérer qu’il
sache résoudre ce que l’on donne en exercice à nos étudiants!
Ceci suppose donc de connaitre quelques méthodes classiques, par
exemple: intégration de polynômes (!), polynômes multipliés par exponentielle
ou/et fonctions trigonométriques, de polynômes trigonométriques par
linéarisation, de fractions rationnelles,
de fractions trigonométriques, de fractions de racines carrées de 
polynômes du second ordre, de fonctions s’y ramenant par une ou plusieurs
intégrations par parties ou par
changement de fonction (par exemple reconnaissance de formes <span style="font-style:italic">F</span>(<span style="font-style:italic">u</span>)<span style="font-style:italic">u</span>′ )
ou par changement de variables, etc.</p><p>Mais au-delà de ces méthodes (qui ont l’avantage de la rapidité mais
tiennent parfois plus de la
recette de cuisine que de l’algorithme...), on peut se demander 
si la primitive d’une fonction donnée peut ou non s’exprimer en terme 
des fonctions “élémentaires”. Par exemple, tout le monde “sait”
que la fonction <span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span><sup>2</sup></sup> n’admet pas de primitive “simple”, encore
faut-il donner un sens mathématique précis à cette affirmation.
Ceci nécessite de donner une définition rigoureuse du terme fonction
élémentaire. On peut alors appliquer un algorithme développé
par Risch (pour les extensions dites transcendantes, obtenue par ajout
des fonctions exponentielle et logarithme) 
qui permet de répondre à la question :
il s’agit vu de très loin d’une extension de l’algorithme d’intégration
des fractions rationnelles.</p><p>Cet article se décompose en deux parties principales :
</p><ul class="itemize"><li class="li-itemize">
la section <a href="#sec%3Aelem">19.2</a> présente les définitions de fonctions
élémentaires, de tour de variables, et donne deux théorèmes,
le théorème de structure de Risch qui permet d’écrire une fonction 
contenant des exponentielles et des logarithmes comme une fonction 
élémentaire par rapport à une tour de variable, et 
le théorème de Liouville qui donne la forme que peut prendre
une primitive d’une fonction élémentaire lorsqu’elle est aussi élémentaire.
</li><li class="li-itemize">la section <a href="#sec%3Arisch">19.3</a> décrit l’algorithme d’intégration de Risch
permettant de décider si une fonction élémentaire donnée possède
ou non une primitive élémentaire et de la calculer dans le premier
cas. Nous ne présentons ici l’algorithme de Risch que pour les extensions
transcendantes pures (ln et exp).
</li></ul><p>
Le lecteur intéressé par le cas des extensions algébriques 
pourra consulter la thèse de Trager. Pour les extensions
plus générales (incluant en particulier les fonctions
tangente, arctangente), la référence est le livre de Bronstein 
donnée en section <a href="#sec%3Arischref">19.4</a>.</p>
<!--TOC subsection id="sec178" Fonctions élémentaires-->
<h3 id="sec178" class="subsection">19.2  Fonctions élémentaires</h3><!--SEC END --><p> <a id="sec:elem"></a></p>
<!--TOC subsubsection id="sec179" Extensions transcendantes, tour de variables-->
<h4 id="sec179" class="subsubsection">19.2.1  Extensions transcendantes, tour de variables</h4><!--SEC END --><p>
On se donne une expression <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) dépendant de la variable <span style="font-style:italic">x</span> que l’on 
souhaite intégrer par rapport à <span style="font-style:italic">x</span>. L’algorithme de Risch s’applique à
cette expression si on peut l’écrire comme une fraction rationnelle à
plusieurs variables algébriquement indépendantes
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>, <span style="font-style:italic">f</span><sub>1</sub>(<span style="font-style:italic">x</span>), <span style="font-style:italic">f</span><sub>2</sub>(<span style="font-style:italic">x</span>,<span style="font-style:italic">f</span><sub>1</sub>(<span style="font-style:italic">x</span>)), ..., 
<span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>,<span style="font-style:italic">f</span><sub>1</sub>(<span style="font-style:italic">x</span>),<span style="font-style:italic">f</span><sub>2</sub>(<span style="font-style:italic">x</span>,<span style="font-style:italic">f</span><sub>1</sub>(<span style="font-style:italic">x</span>)),...,<span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span>−1</sub>(<span style="font-style:italic">x</span>,<span style="font-style:italic">f</span><sub>1</sub>(<span style="font-style:italic">x</span>),...,<span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span>−2</sub>(<span style="font-style:italic">x</span>))) </td></tr>
</table><p>
où les <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub> sont soit l’exponentielle soit le logarithme d’une fraction
rationnelle (le corps de base appelé aussi corps de
constantes ici est soit ℂ, soit une extension algébrique de ℚ ou une
extension algébrique d’un corps de fractions rationnelles s’il
y a des paramètres). 
On appelle tour de variables
la suite des <span style="font-style:italic">x</span>,<span style="font-style:italic">f</span><sub>1</sub>,...,<span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub> (chaque étage est donc une exponentielle
d’une fraction rationnelle ou le logarithme d’une fraction rationnelle
dépendant des étages précédents) 
et on dira que <span style="font-style:italic">f</span> est une fonction élémentaire
par rapport à cette tour de variables.</p><p>L’intérêt de l’écriture d’une expression sous forme de tour est 
qu’elle est stable par dérivation : 
si on dérive par rapport à <span style="font-style:italic">x</span>
une fonction élémentaire dépendant d’une tour de variables, on obtient encore 
une fonction élémentaire dépendant de la même tour de variables.
Autrement dit, l’ensemble des fonctions élémentaires pour une tour 
fixée est un corps différentiel.</p><p><span style="font-weight:bold">Exemples: </span>
</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span><sup>2</sup></sup> est bien dans ce cas, pour <span style="font-style:italic">n</span>=1, <span style="font-style:italic">f</span><sub>1</sub>
est l’exponentielle de <span style="font-style:italic">x</span><sup>2</sup> qui est algébriquement indépendant
de <span style="font-style:italic">x</span>. Les fonctions (2<span style="font-style:italic">x</span><sup>2</sup>−1)<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span><sup>2</sup></sup>
ou <span style="font-style:italic">x</span>/(<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span><sup>2</sup></sup>−1) sont aussi élémentaires par rapport à
la tour de variables {<span style="font-style:italic">x</span>,<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span><sup>2</sup></sup> }. 
</li><li class="li-itemize"><span style="font-style:italic">x</span> ln(<span style="font-style:italic">x</span>) exp(<span style="font-style:italic">x</span>) est élémentaire par rapport à la tour
{ <span style="font-style:italic">x</span>, ln(<span style="font-style:italic">x</span>), exp(<span style="font-style:italic">x</span>)}, mais aussi par rapport à la tour
{ <span style="font-style:italic">x</span>, exp(<span style="font-style:italic">x</span>), ln(<span style="font-style:italic">x</span>)}.
</li><li class="li-itemize"><span style="font-style:italic">xe</span><sup><span style="font-style:italic">x</span> ln(<span style="font-style:italic">x</span>)</sup> est élémentaire, en prenant <span style="font-style:italic">n</span>=2, <span style="font-style:italic">f</span><sub>1</sub>=ln(<span style="font-style:italic">x</span>)
et <span style="font-style:italic">f</span><sub>2</sub>=<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span> <span style="font-style:italic">f</span><sub>1</sub></sup>.
</li><li class="li-itemize"><span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup>=<span style="font-style:italic">e</span><sup><span style="font-style:italic">n</span>ln(<span style="font-style:italic">x</span>)</sup>, où <span style="font-style:italic">n</span> est un paramètre, convient avec
comme tour {<span style="font-style:italic">x</span>, ln(<span style="font-style:italic">x</span>), <span style="font-style:italic">e</span><sup><span style="font-style:italic">n</span> ln(<span style="font-style:italic">x</span>) </sup>
</li><li class="li-itemize"><span style="font-style:italic">e</span><sup>ln(<span style="font-style:italic">x</span>)</sup> ne convient pas car il n’est pas algébriquement
indépendant de <span style="font-style:italic">x</span>,ln(<span style="font-style:italic">x</span>) mais on peut le réécrire sous une forme
acceptable puisque <span style="font-style:italic">e</span><sup>ln(<span style="font-style:italic">x</span>)</sup>=<span style="font-style:italic">x</span>.
</li><li class="li-itemize"><span style="font-style:italic">e</span><sup>ln(<span style="font-style:italic">x</span>)/2</sup> ne convient pas non plus car son carré est égal à <span style="font-style:italic">x</span>.
Une réécriture ne suffit pas, cet exemple est bien sûr une extension
algébrique et non transcendante.
</li></ul><p>Dans la suite, on va s’intéresser aux tours de variables dans lesquelles 
on a effectué des simplifications évidentes.
On élimine les ln∘ exp de la manière suivante :
si <span style="font-style:italic">f</span><sub><span style="font-style:italic">k</span></sub>=ln(<span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub>), on regarde si <span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub> vu comme fraction 
en <span style="font-style:italic">f</span><sub>1</sub>,...,<span style="font-style:italic">f</span><sub><span style="font-style:italic">k</span>−1</sub> possède un facteur <span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub><sup><span style="font-style:italic">m</span></sup> (avec <span style="font-style:italic">m</span> ∈ ℤ)
lorsque <span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub>=exp(<span style="font-style:italic">g</span><sub><span style="font-style:italic">j</span></sub>) est une exponentielle.
Si c’est le cas, on a <span style="font-style:italic">f</span><sub><span style="font-style:italic">k</span></sub>= <span style="font-style:italic">m</span> <span style="font-style:italic">g</span><sub><span style="font-style:italic">j</span></sub> + ln(<span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub>/<span style="font-style:italic">g</span><sub><span style="font-style:italic">j</span></sub><sup><span style="font-style:italic">m</span></sup>). On change
alors de tour en remplaçant <span style="font-style:italic">f</span><sub><span style="font-style:italic">k</span></sub> par f<sub><span style="font-style:italic">k</span></sub>=ln(<span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub>/<span style="font-style:italic">g</span><sub><span style="font-style:italic">j</span></sub><sup><span style="font-style:italic">m</span></sup>)=<span style="font-style:italic">f</span><sub><span style="font-style:italic">k</span></sub>−<span style="font-style:italic">mg</span><sub><span style="font-style:italic">j</span></sub>.
On élimine aussi les exp∘ ln, si
<span style="font-style:italic">f</span><sub><span style="font-style:italic">k</span></sub>=exp(<span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub>), pour <span style="font-style:italic">j</span>&lt;<span style="font-style:italic">k</span> si <span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub> est un logarithme,
on regarde si <span style="font-style:italic">c</span><sub><span style="font-style:italic">j</span></sub>=∂<sub><span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub></sub><span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub>|<sub><span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub>=0</sub> est un entier, si
c’est le cas on remplace <span style="font-style:italic">f</span><sub><span style="font-style:italic">k</span></sub> par f<sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">f</span><sub><span style="font-style:italic">k</span></sub>/<span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">c</span><sub><span style="font-style:italic">j</span></sub></sup>.</p><p><span style="font-weight:bold">Exemples: </span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> ln(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span><sup>2</sup></sup>+1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span><sup>2</sup></sup></td></tr>
</table></td><td class="dcell">)</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >→</td><td style="text-align:left;white-space:nowrap" >−<span style="font-style:italic">x</span><sup>2</sup> + ln(<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span><sup>2</sup></sup>+1) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">e</span><sup>3 ln(<span style="font-style:italic">x</span>)+ln(<span style="font-style:italic">x</span>)<sup>2</sup>+5</sup></td><td style="text-align:center;white-space:nowrap" >→</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">x</span><sup>3</sup> <span style="font-style:italic">e</span><sup>ln(<span style="font-style:italic">x</span>)<sup>2</sup>+5</sup> 
</td></tr>
</table></td></tr>
</table>
<!--TOC subsubsection id="sec180" Théorème de structure de Risch-->
<h4 id="sec180" class="subsubsection">19.2.2  Théorème de structure de Risch</h4><!--SEC END --><p>
On voit donc qu’il est nécessaire de disposer d’un algorithme
pour décider si des exponentielles et logarithmes sont
algébriquement indépendants. Cet algorithme est basé sur
un théorème de structure dû à Risch :
</p><div class="theorem"><span style="font-weight:bold">Théorème 34</span>  <em>
Soit </em><span style="font-style:italic">f</span>=ln(<span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>))<em> le logarithme d’une fonction élémentaire
</em><span style="font-style:italic">g</span><em> par rapport à une tour de variables </em><span style="font-style:italic">T</span><em>, alors soit </em><span style="font-style:italic">f</span><em>
est algébriquement indépendant des variables de </em><span style="font-style:italic">T</span><em>, soit </em><span style="font-style:italic">f</span><em> est
élémentaire et plus précisément combinaison linéaire rationnelle
des logarithmes et des arguments des exponentielles de la tour </em><span style="font-style:italic">T</span><em>.</em><p><em>Soit </em><span style="font-style:italic">f</span>=exp(<span style="font-style:italic">g</span>)<em> l’exponentielle d’une fonction élémentaire </em><span style="font-style:italic">g</span><em>
par rapport à une tour de variables </em><span style="font-style:italic">T</span><em>, alors soit </em><span style="font-style:italic">f</span><em>
est algébriquement indépendante des variables de </em><span style="font-style:italic">T</span><em>, soit
il existe </em><span style="font-style:italic">n</span><em> tel que </em><span style="font-style:italic">f</span><sup><span style="font-style:italic">n</span></sup><em> soit élémentaire par rapport à </em><span style="font-style:italic">T</span><em> 
(on peut alors appliquer le cas précédent à </em><span style="font-style:italic">ng</span>=ln(<span style="font-style:italic">f</span><sup><span style="font-style:italic">n</span></sup>)<em>)
</em></p></div><p><span style="font-weight:bold">Démonstration</span> :<br>
Commençons par le cas de l’exponentielle. On considère le polynôme minimal
de <span style="font-style:italic">f</span>=exp(<span style="font-style:italic">g</span>) :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">f</span><sup><span style="font-style:italic">n</span></sup>+...+<span style="font-style:italic">a</span><sub>0</sub>=0,    <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> ≠ 0 , <span style="font-style:italic">a</span><sub>0</sub> ≠ 0</td></tr>
</table><p>
où les <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub> sont des fractions rationnelles en <span style="font-style:italic">T</span>. On dérive
et on applique <span style="font-style:italic">f</span>′=<span style="font-style:italic">g</span>′<span style="font-style:italic">f</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>′+<span style="font-style:italic">n</span> <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">g</span>′) <span style="font-style:italic">f</span><sup><span style="font-style:italic">n</span></sup> +   ... + ( <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub>′ + <span style="font-style:italic">ka</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">g</span>′)<span style="font-style:italic">f</span><sup><span style="font-style:italic">k</span></sup> +... =0</td></tr>
</table><p>
c’est un multiple du polynôme minimal donc il existe une fraction rationnelle
<span style="font-style:italic">C</span> (par rapport à la tour de variables) telle que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">∀ <span style="font-style:italic">k</span>,    (<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub>′+<span style="font-style:italic">k</span> <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">g</span>′) = <span style="font-style:italic">C</span> <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table><p>
Comme <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>≠ 0, cela entraine <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>′/<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>+<span style="font-style:italic">ng</span>′=<span style="font-style:italic">C</span>. Le coefficient
constant <span style="font-style:italic">a</span><sub>0</sub> est aussi non nul, donc <span style="font-style:italic">a</span><sub>0</sub>′/<span style="font-style:italic">a</span><sub>0</sub>=<span style="font-style:italic">C</span> et 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">n</span> <span style="font-style:italic">g</span>′ = <span style="font-style:italic">a</span><sub>0</sub>′/<span style="font-style:italic">a</span><sub>0</sub> − <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>′/<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> ⇒ <span style="font-style:italic">ng</span>=ln(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub>0</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">) + <span style="font-style:italic">k</span></td></tr>
</table><p>
où <span style="font-style:italic">k</span> est constant, donc <span style="font-style:italic">f</span><sup><span style="font-style:italic">n</span></sup>=exp(<span style="font-style:italic">ng</span>)=<span style="font-style:italic">e</span><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">a</span><sub>0</sub>/<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> est élémentaire.</p><p>Passons au cas du logarithme, supposons que <span style="font-style:italic">f</span>=ln(<span style="font-style:italic">g</span>) dépende
algébriquement de la tour <span style="font-style:italic">T</span>, on va commencer par montrer que
<span style="font-style:italic">f</span> est élémentaire. On écrit :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">f</span><sup><span style="font-style:italic">n</span></sup>+...+<span style="font-style:italic">a</span><sub>0</sub>=0</td></tr>
</table><p>
où les <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub> sont des fractions rationnelles en <span style="font-style:italic">T</span>. On dérive en
appliquant <span style="font-style:italic">f</span>′=<span style="font-style:italic">g</span>′/<span style="font-style:italic">g</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>′ <span style="font-style:italic">f</span><sup><span style="font-style:italic">n</span></sup> + (<span style="font-style:italic">n</span> <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">f</span>′ + <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub>′)<span style="font-style:italic">f</span><sup><span style="font-style:italic">n</span>−1</sup>  ... + <span style="font-style:italic">a</span><sub>1</sub> <span style="font-style:italic">f</span>′+<span style="font-style:italic">a</span><sub>0</sub> ′</td></tr>
</table><p>
Comme <span style="font-style:italic">f</span>′ est une fraction rationnelle en <span style="font-style:italic">T</span>, le polynôme
<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>′ <span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span></sup> + (<span style="font-style:italic">n</span> <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">f</span>′+<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub>′) <span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span>−1</sup>+...+ <span style="font-style:italic">a</span><sub>1</sub> <span style="font-style:italic">f</span>′+<span style="font-style:italic">a</span><sub>0</sub>′ qui annule <span style="font-style:italic">f</span>
doit être un multiple du polynôme minimal de <span style="font-style:italic">f</span>, il existe donc
une fraction rationnelle <span style="font-style:italic">C</span> par rapport à <span style="font-style:italic">T</span> telle que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>′ = <span style="font-style:italic">C</span> <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>    (<span style="font-style:italic">n</span> <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">f</span>′+<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub>′) = <span style="font-style:italic">C</span> <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub>    ... </td></tr>
</table><p>
On en déduit <span style="font-style:italic">f</span>′ :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>′=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub>−<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub>′</td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span> <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell"> = 
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span> <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">′</td></tr>
</table><p>
donc il existe une constante <span style="font-style:italic">c</span> telle que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span> <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">+<span style="font-style:italic">c</span></td></tr>
</table><p>
donc <span style="font-style:italic">f</span> est élémentaire par rapport à la même tour <span style="font-style:italic">T</span> que <span style="font-style:italic">g</span>.</p><p>Montrons maintenant qu’un logarithme <span style="font-style:italic">f</span>=ln(<span style="font-style:italic">g</span>) qui est élémentaire
par rapport à une tour de variable <span style="font-style:italic">T</span> est combinaison linéaire à
coefficients rationnelles des logarithmes et des arguments
des exponentielles de <span style="font-style:italic">T</span><sup><a id="text31" href="#note31">31</a></sup>.
Soit <span style="font-style:italic">X</span> la dernière variable de la tour <span style="font-style:italic">T</span>.
On factorise maintenant le numérateur et le dénominateur de <span style="font-style:italic">g</span> en
∏<sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub><sup><span style="font-style:italic">j</span></sup> où les <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> sont sans facteurs multiples et 
premiers entre eux 2 à 2 (par rapport à <span style="font-style:italic">X</span>), il existe
<span style="font-style:italic">C</span> indépendant de <span style="font-style:italic">X</span> tel que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:g"></a>
<span style="font-style:italic">g</span>=<span style="font-style:italic">C</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span> ∈ ℤ</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub><sup><span style="font-style:italic">j</span></sup> ⇒ 
ln(<span style="font-style:italic">g</span>)=ln(<span style="font-style:italic">C</span>)+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span> ∈ ℤ</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">j</span> ln(<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>)
    (24)</td></tr>
</table><p>
Alors <span style="font-style:italic">f</span>′=ln(<span style="font-style:italic">C</span>)′+∑<sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">j</span> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>′/<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> donc ∏<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">f</span>′ est un 
polynôme en <span style="font-style:italic">X</span>. 
Soit <span style="font-style:italic">N</span>/<span style="font-style:italic">D</span> la fraction irréductible représentant <span style="font-style:italic">f</span>, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>′=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>′ <span style="font-style:italic">D</span> −<span style="font-style:italic">N</span> <span style="font-style:italic">D</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">D</span><sup>2</sup></td></tr>
</table></td></tr>
</table><p>
on vient donc de montrer que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:prodpj"></a>
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>′ <span style="font-style:italic">D</span> − <span style="font-style:italic">N</span> <span style="font-style:italic">D</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">D</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> 
 est un polynôme en <span style="font-style:italic">X</span>
    (25)</td></tr>
</table><p>
Soit <span style="font-style:italic">P</span> un facteur irréductible de <span style="font-style:italic">D</span> de multiplicité
<span style="font-style:italic">k</span> tel que <span style="font-style:italic">D</span>=<span style="font-style:italic">P</span><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">Q</span> (donc <span style="font-style:italic">P</span> premier avec <span style="font-style:italic">Q</span>, mais <span style="font-style:italic">P</span> est aussi
premier avec <span style="font-style:italic">N</span> car <span style="font-style:italic">f</span>=<span style="font-style:italic">N</span>/<span style="font-style:italic">D</span> est irréductible). Alors en simplifiant
numérateur et dénominateur par <span style="font-style:italic">P</span><sup><span style="font-style:italic">k</span>−1</sup>, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:estpolynome"></a>
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>′ <span style="font-style:italic">P</span> <span style="font-style:italic">Q</span> − <span style="font-style:italic">N</span> (<span style="font-style:italic">kP</span>′<span style="font-style:italic">Q</span>+<span style="font-style:italic">PQ</span>′)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"> <span style="font-style:italic">P</span><sup><span style="font-style:italic">k</span>+1</sup> <span style="font-style:italic">Q</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> 
 est un polynôme en <span style="font-style:italic">X</span>. 
    (26)</td></tr>
</table><p>
On en déduit, après simplification d’au plus un facteur <span style="font-style:italic">P</span> au dénominateur 
avec l’un des <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>, que <span style="font-style:italic">P</span><sup><span style="font-style:italic">k</span></sup> divise 
<span style="font-style:italic">N</span>′ <span style="font-style:italic">P</span> <span style="font-style:italic">Q</span> − <span style="font-style:italic">N</span> (<span style="font-style:italic">kP</span>′<span style="font-style:italic">Q</span>+<span style="font-style:italic">PQ</span>′) donc <span style="font-style:italic">P</span> divise <span style="font-style:italic">P</span>′. Ceci n’est possible
que si <span style="font-style:italic">P</span>=1 (et donc le dénominateur de <span style="font-style:italic">f</span> est égal à 1) 
ou si la variable <span style="font-style:italic">X</span> est une exponentielle et <span style="font-style:italic">P</span>=<span style="font-style:italic">X</span>.</p><p>Montrons que ce deuxième cas est en fait exclus:
en effet si <span style="font-style:italic">P</span>=<span style="font-style:italic">X</span>=exp(<span style="font-style:italic">Y</span>) est une exponentielle, on a alors 
<span style="font-style:italic">D</span>=<span style="font-style:italic">X</span><sup><span style="font-style:italic">k</span></sup> et <span style="font-style:italic">Q</span>=1.
Comme <span style="font-style:italic">P</span>′=<span style="font-style:italic">Y</span>′<span style="font-style:italic">X</span>, (<a href="#eq%3Aestpolynome">26</a>) devient :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">X</span> (<span style="font-style:italic">N</span>′ − <span style="font-style:italic">k</span> <span style="font-style:italic">N</span> <span style="font-style:italic">Y</span>′ )</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">X</span><sup><span style="font-style:italic">k</span>+1</sup></td></tr>
</table></td><td class="dcell">
 est un polynôme en <span style="font-style:italic">X</span> </td></tr>
</table><p>
Comme <span style="font-style:italic">X</span> ne divise pas <span style="font-style:italic">N</span>, <span style="font-style:italic">N</span> possède donc un coefficient constant 
<span style="font-style:italic">a</span><sub>0</sub> non nul. Le coefficient constant de <span style="font-style:italic">N</span>′−<span style="font-style:italic">kNY</span>′ est <span style="font-style:italic">a</span><sub>0</sub>′−<span style="font-style:italic">ka</span><sub>0</sub> <span style="font-style:italic">Y</span>′. 
Si ce terme était nul alors <span style="font-style:italic">a</span><sub>0</sub>′=<span style="font-style:italic">ka</span><sub>0</sub> <span style="font-style:italic">Y</span>′ donc <span style="font-style:italic">a</span><sub>0</sub>=<span style="font-style:italic">c</span> exp(<span style="font-style:italic">kY</span>)=<span style="font-style:italic">cX</span><sup><span style="font-style:italic">k</span></sup> 
or <span style="font-style:italic">a</span><sub>0</sub> ne dépend pas de <span style="font-style:italic">X</span> donc <span style="font-style:italic">c</span>=0 donc <span style="font-style:italic">a</span><sub>0</sub>=0, absurde. 
Donc <span style="font-style:italic">X</span> ne divise pas <span style="font-style:italic">N</span>′−<span style="font-style:italic">kNY</span>′.
Comme <span style="font-style:italic">X</span><sup><span style="font-style:italic">k</span>+1</sup> divise  ∏<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">X</span> (<span style="font-style:italic">N</span>′ − <span style="font-style:italic">k</span> <span style="font-style:italic">N</span> <span style="font-style:italic">Y</span>′ ), on en déduit que
<span style="font-style:italic">X</span><sup><span style="font-style:italic">k</span></sup> divise un des <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>. Donc <span style="font-style:italic">k</span>=1 et <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>=<span style="font-style:italic">XQ</span><sub><span style="font-style:italic">j</span></sub>. 
Revenons maintenant à (<a href="#eq%3Ag">24</a>), on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>=ln(<span style="font-style:italic">g</span>) = ln(<span style="font-style:italic">C</span>)+<span style="font-style:italic">j</span> ln(<span style="font-style:italic">XQ</span><sub><span style="font-style:italic">j</span></sub>)+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span> ≠ <span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">l</span> ln(<span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub>) </td></tr>
</table><p>
on dérive :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>′=ln(<span style="font-style:italic">C</span>)′+<span style="font-style:italic">jY</span>′+<span style="font-style:italic">j</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub></td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span> ≠ <span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">l</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub></td></tr>
</table></td></tr>
</table><p>
on voit qu’il n’est plus nécessaire de multiplier <span style="font-style:italic">f</span>′ par <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>
pour avoir un polynôme, multiplier par <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> suffit, plus précisément
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span> ≠ <span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>′ <span style="font-style:italic">D</span> − <span style="font-style:italic">N</span> <span style="font-style:italic">D</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">D</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> 
 est un polynôme en <span style="font-style:italic">X</span>. 
</td></tr>
</table><p>
donc <span style="font-style:italic">X</span><sup><span style="font-style:italic">k</span>+1</sup> divise 
 (∏<sub><span style="font-style:italic">l</span> ≠ <span style="font-style:italic">j</span></sub><span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub> ) <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">X</span> (<span style="font-style:italic">N</span>′ − <span style="font-style:italic">k</span> <span style="font-style:italic">N</span> <span style="font-style:italic">Y</span>′ ) 
ce qui est impossible.</p><p>Donc <span style="font-style:italic">D</span>=1 dans tous les cas et on a <span style="font-style:italic">f</span>=<span style="font-style:italic">N</span>. Donc 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>′=<span style="font-style:italic">N</span>′=ln(<span style="font-style:italic">C</span>)′+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">j</span> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>′/<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> 
 est un polynôme par rapport à <span style="font-style:italic">X</span> </td></tr>
</table><p>
On en déduit que les <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> ne dépendent pas de <span style="font-style:italic">X</span> sauf si
<span style="font-style:italic">X</span> est une exponentielle et <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>=<span style="font-style:italic">X</span>. 
Dans les deux cas <span style="font-style:italic">N</span>′ ne
dépend pas de <span style="font-style:italic">X</span> donc le polynôme <span style="font-style:italic">N</span> est de degré 0 ou 1 en <span style="font-style:italic">X</span>
(si <span style="font-style:italic">X</span> est une exponentielle, <span style="font-style:italic">N</span> est forcément de degré 0)
</p><ul class="itemize"><li class="li-itemize">
Si <span style="font-style:italic">X</span>=exp(<span style="font-style:italic">Y</span>) est une exponentielle (avec <span style="font-style:italic">Y</span> élémentaire
ne dépendant pas de <span style="font-style:italic">X</span>), alors <span style="font-style:italic">f</span>=<span style="font-style:italic">N</span> est indépendant de <span style="font-style:italic">X</span>.
On retire <span style="font-style:italic">jY</span> à <span style="font-style:italic">f</span> et on divise <span style="font-style:italic">g</span> par <span style="font-style:italic">X</span><sup><span style="font-style:italic">j</span></sup> 
(en posant <span style="font-style:italic">j</span>=0 si aucun des <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> n’est égal à <span style="font-style:italic">X</span>), 
qui devient indépendant de <span style="font-style:italic">X</span>, on conserve ainsi l’égalité <span style="font-style:italic">f</span>=ln(<span style="font-style:italic">g</span>)
mais avec une variable de moins dans la tour de variables par
rapport à laquelle <span style="font-style:italic">f</span> et <span style="font-style:italic">g</span> sont élémentaires.
</li><li class="li-itemize">Si <span style="font-style:italic">X</span> n’est pas une exponentielle, <span style="font-style:italic">N</span>=<span style="font-style:italic">cX</span>+<span style="font-style:italic">d</span> avec <span style="font-style:italic">c</span>
dans le corps de constantes, et <span style="font-style:italic">d</span> indépendant de <span style="font-style:italic">X</span>.
Si <span style="font-style:italic">X</span>=<span style="font-style:italic">x</span>, on a <span style="font-style:italic">g</span>=exp(<span style="font-style:italic">cx</span>+<span style="font-style:italic">d</span>) qui n’est rationnel que si
<span style="font-style:italic">c</span>=0. On a alors <span style="font-style:italic">d</span> donc <span style="font-style:italic">f</span> et <span style="font-style:italic">g</span> constants.
Si <span style="font-style:italic">X</span>=ln(<span style="font-style:italic">Y</span>) est un logarithme (avec <span style="font-style:italic">Y</span> élémentaire
ne dépendant pas de <span style="font-style:italic">X</span>), alors ∀ <span style="font-style:italic">j</span>, <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>=1 donc <span style="font-style:italic">g</span> est élémentaire
indépendante de <span style="font-style:italic">X</span>. 
On a alors :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>=<span style="font-style:italic">N</span>=<span style="font-style:italic">c</span>ln(<span style="font-style:italic">Y</span>)+<span style="font-style:italic">d</span> = ln(<span style="font-style:italic">g</span>) </td></tr>
</table>
avec <span style="font-style:italic">c</span> dans le corps des constantes, <span style="font-style:italic">d</span> et <span style="font-style:italic">g</span> élémentaires
indépendants de <span style="font-style:italic">X</span>. On cherche maintenant la fonction
élémentaire <span style="font-style:italic">d</span>. Cette fonction n’est pas le logarithme d’une
fonction élémentaire en général car <span style="font-style:italic">c</span> n’est pas forcément entier,
mais <span style="font-style:italic">d</span>′ a les mêmes propriétés que la dérivée du logarithme
d’une fonction élémentaire.
On peut donc reprendre le même raisonnement mais avec une variable de moins
dans la tour de variables. Si la tour qu’on a choisie est normalisée,
alors <span style="font-style:italic">Y</span> ne contient au numérateur et au dénominateur aucune puissance
d’une exponentielle d’une variable de la tour donc le polynôme <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>
du cas précédent ne peut provenir de <span style="font-style:italic">Y</span> ce qui entraine que <span style="font-style:italic">j</span>
est bien entier dans le cas précédent (bien que <span style="font-style:italic">c</span> ne le soit
pas forcément).
</li></ul><p>Après avoir fait une récurrence sur le nombre de variables de la tour,
on a donc <span style="font-style:italic">f</span> qui s’exprime comme combinaison linéaire à coefficients
entiers des arguments <span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub> des variables exponentielles <span style="font-style:italic">f</span><sub><span style="font-style:italic">k</span></sub>=exp(<span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub>)
de la tour et à coefficients a priori quelconque des variables logarithmes
<span style="font-style:italic">f</span><sub><span style="font-style:italic">l</span></sub>=ln(<span style="font-style:italic">g</span><sub><span style="font-style:italic">l</span></sub>) de la tour :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">j</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">l</span></sub> ln(<span style="font-style:italic">g</span><sub><span style="font-style:italic">l</span></sub>) = ln(<span style="font-style:italic">g</span>) </td></tr>
</table><p>
Comme <span style="font-style:italic">g</span> est élémentaire, <span style="font-style:italic">h</span>=<span style="font-style:italic">g</span>/∏<sub><span style="font-style:italic">k</span></sub> exp(<span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub>)<sup><span style="font-style:italic">j</span><sub><span style="font-style:italic">k</span></sub></sup>
est élémentaire de logarithme ∑<sub><span style="font-style:italic">l</span></sub> <span style="font-style:italic">x</span><sub><span style="font-style:italic">l</span></sub> ln(<span style="font-style:italic">g</span><sub><span style="font-style:italic">l</span></sub>) .
Montrons que si les arguments des ln sont des polynômes
sans facteurs multiples, alors
les <span style="font-style:italic">x</span><sub><span style="font-style:italic">l</span></sub> sont entiers. Rappelons
que les ln(<span style="font-style:italic">g</span><sub><span style="font-style:italic">l</span></sub>) sont algébriquement indépendants, on peut donc
construire des polynômes irréductibles <span style="font-style:italic">I</span><sub><span style="font-style:italic">l</span></sub> par rapport aux variables
de la tour tels que <span style="font-style:italic">I</span><sub><span style="font-style:italic">l</span></sub> divise une fois <span style="font-style:italic">g</span><sub><span style="font-style:italic">l</span></sub> mais ne divise pas les <span style="font-style:italic">g</span><sub><span style="font-style:italic">k</span></sub>
précédents. Soit <span style="font-style:italic">h</span>=∏<sub><span style="font-style:italic">j</span> ∈ ℤ</sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub><sup><span style="font-style:italic">j</span></sup> la factorisation
sans facteurs multiples de <span style="font-style:italic">h</span>. On dérive alors ln(<span style="font-style:italic">h</span>) ce qui donne :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">l</span></sub> <span style="font-style:italic">g</span><sub><span style="font-style:italic">l</span></sub>′/<span style="font-style:italic">g</span><sub><span style="font-style:italic">l</span></sub> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">j</span> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>′/<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> </td></tr>
</table><p>
où ∏<sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub><sup><span style="font-style:italic">j</span></sup> est la décomposition sans facteurs multiples
de <span style="font-style:italic">h</span>. Comme <span style="font-style:italic">I</span><sub><span style="font-style:italic">l</span></sub> divise un et un seul des <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> on en déduit
que <span style="font-style:italic">x</span><sub><span style="font-style:italic">l</span></sub> est égal au <span style="font-style:italic">j</span> correspondant et est donc entier.
(Remarque: si on n’impose pas aux arguments des logarithmes
d’être des polynômes sans facteurs carrés, 
on obtiendrait ici des coefficients rationnels).</p><p><span style="font-weight:bold">En pratique</span>:<br>
On peut effecter l’algorithme de la manière suivante : 
</p><ul class="itemize"><li class="li-itemize">
on cherche les variables généralisées de l’expression
qui dépendent de <span style="font-style:italic">x</span>.
</li><li class="li-itemize">On ajoute les variables généralisées en commençant par
la moins longue
</li><li class="li-itemize">Si c’est un logarithme, on extrait les puissances des
exponentielles précédentes dont il dépend.
On cherche des relations entre fonctions ln en les réécrivant
comme combinaison linéaire de ln indépendants. Pour avoir
des ln indépendants, on se ramène d’abord à des polynômes
sans facteurs multiples en utilisant la relation ln(<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>)=ln(<span style="font-style:italic">a</span>)−ln(<span style="font-style:italic">b</span>) 
et en écrivant la factorisation sans facteurs multiples 
de chaque polynôme argument, puis
on extrait le PGCD 2 à 2 des arguments de logarithmes jusqu’à
obtenir des arguments de ln premiers entre eux.
</li><li class="li-itemize">Si c’est une exponentielle, on teste
si son argument est combinaison linéaire à coefficients rationnels :
<ul class="itemize"><li class="li-itemize">
des arguments des exponentielles précédentes, 
</li><li class="li-itemize">des ln des logarithmes précédents,
</li><li class="li-itemize">de ln(<span style="font-style:italic">x</span>) et de <span style="font-style:italic">i</span>*π.
</li></ul>
Pour cela on substitue les ln par des indéterminées,
et on dérive une fois par rapport à cette indéterminée, le
résultat doit être un rationnel, pour les variables exponentielles,
il faut réduire au même dénominateur et résoudre le système
linéaire obtenu en identifiant les coefficients du numérateur.
Si l’exponentielle est indépendante des précédentes, 
on extrait de l’exponentielle à rajouter la partie linéaire de la 
dépendance en les ln précédents si le coefficient correspondant est
entier. Par exemple, on réécrit :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">xe</span><sup>2 ln(<span style="font-style:italic">x</span>)+ln(<span style="font-style:italic">x</span>)<sup>2</sup></sup> = <span style="font-style:italic">x</span><sup>3</sup> <span style="font-style:italic">e</span><sup>ln(<span style="font-style:italic">x</span>)<sup>2</sup></sup> </td></tr>
</table>
</li></ul><p><span style="font-weight:bold">Remarque</span><br>
On n’est pas obligé de se limiter aux seules fonctions logarithmes
et exponentielles, l’essentiel est de pouvoir tester l’indépendance
algébrique des expressions créées. Pour éviter d’avoir à introduire
des exponentielles et logarithmes complexes dans une expression
réelle, on peut autoriser
par exemple des extensions en tangente ou en arctangente.</p>
<!--TOC subsubsection id="sec181" Théorème de Liouville-->
<h4 id="sec181" class="subsubsection">19.2.3  Théorème de Liouville</h4><!--SEC END --><p><a id="hevea_default208"></a>
On a vu que la dérivée d’une fonction élémentaire dépendant 
d’une tour de variables est une fonction élémentaire dépendant 
de la même tour de variables.
Réciproquement, supposons qu’une fonction élémentaire admette
une primitive qui soit élémentaire, c’est-à-dire qu’elle doit
être une fraction rationelle par rapport à une tour de variables
mais pas forcément identique à celle de départ. Alors, si une telle
écriture existe, à des termes logarithmiques près, elle
ne peut dépendre que de la même tour de variables, plus précisément
on a le théorème de Liouville :
</p><div class="theorem"><span style="font-weight:bold">Théorème 35</span>  <em>
Soit </em><span style="font-style:italic">f</span><em> une fonction élémentaire par rapport à une tour de variables </em><span style="font-style:italic">T</span><em>
et un corps de constantes </em><span style="font-style:italic">K</span><em> admettant une primitive élémentaire </em><span style="font-style:italic">F</span><em>. Alors 
il existe un nombre fini de constantes </em><span style="font-style:italic">c</span><sub>1</sub>,...,<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub><em> et de fonctions
élémentaires </em><span style="font-style:italic">v</span><sub>1</sub>,...,<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub><em> par rapport à </em><span style="font-style:italic">T</span><em> avec comme corps de constantes
une extension algébrique </em><span style="font-style:italic">K</span>′<em> de </em><span style="font-style:italic">K</span><em> tel que </em><span style="font-style:italic">F</span> − ∑<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> ln(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>) <em>
soit élémentaire par rapport à </em><span style="font-style:italic">T</span><em> et </em><span style="font-style:italic">K</span><em>.
</em></div><p><span style="font-weight:bold">Preuve:</span><sup><a id="text32" href="#note32">32</a></sup><br>
Soit <span style="font-style:italic">f</span> élémentaire de tour <span style="font-style:italic">T</span><sub>1</sub> (corps <span style="font-style:italic">K</span>) et 
<span style="font-style:italic">F</span> sa primitive supposée élémentaire de tour <span style="font-style:italic">T</span><sub>2</sub> et de corps <span style="font-style:italic">K</span>′
une extension algébrique de <span style="font-style:italic">K</span>. 
On commence par rajouter après les élements de <span style="font-style:italic">T</span><sub>1</sub> les 
élements nécessaires de <span style="font-style:italic">T</span><sub>2</sub> pour obtenir une tour <span style="font-style:italic">T</span> par rapport
à laquelle <span style="font-style:italic">f</span> et <span style="font-style:italic">F</span> sont élémentaires (plus précisément <span style="font-style:italic">F</span> sera
élémentaire quitte à autoriser des puissances fractionnaires
des variables exponentielles de <span style="font-style:italic">T</span><sub>1</sub>). Le théorème de structure
de Risch permet de faire cela, en effet on regarde pour chaque
élément de <span style="font-style:italic">T</span><sub>2</sub> s’il est algébriquement indépendant des éléments
de <span style="font-style:italic">T</span><sub>1</sub> ou non. S’il l’est, on le rajoute à la tour <span style="font-style:italic">T</span>, s’il
ne l’est pas alors dans le cas d’un logarithme il est élémentaire
et dans le cas d’une exponentielle, une de ses puissances est
élémentaire. Donc <span style="font-style:italic">F</span> est bien une fraction rationnelle par rapport
aux éléments logarithmiques de <span style="font-style:italic">T</span><sub>1</sub>, aux racines <span style="font-style:italic">n</span>-ième
des éléments exponentiels de <span style="font-style:italic">T</span><sub>1</sub> et à des éléments de <span style="font-style:italic">T</span><sub>2</sub>
dans cet ordre (le corps des constantes étant <span style="font-style:italic">K</span>′).</p><p><span style="font-weight:bold">Première étape:</span><br>
Commençons par les éléments restant de <span style="font-style:italic">T</span><sub>2</sub>. Soit <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span></sub> l’élément
au sommet de la tour <span style="font-style:italic">T</span>. La dérivée <span style="font-style:italic">f</span> de <span style="font-style:italic">F</span> par rapport à <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span></sub>
ne dépend pas de <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span></sub>. Donc soit <span style="font-style:italic">F</span> ne dépend pas de <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span></sub> et
on passe à la variable suivante, soit <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span></sub>=ln(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>) est un logarithme
et <span style="font-style:italic">F</span>=<span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> ln(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>)+<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub> avec <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> ∈ <span style="font-style:italic">K</span>′ et <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> et <span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub> 
indépendants de <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span></sub>. S’il
n’y a pas d’autres éléments restants de <span style="font-style:italic">T</span><sub>2</sub>, on passe à la 2ème étape.
Sinon soit <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span>−1</sub> la variable suivante 
(juste en-dessous de <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span></sub> dans la tour).
En dérivant, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">F</span>′= <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td><td class="dcell"> + <span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>′ = <span style="font-style:italic">f</span></td></tr>
</table><p>
Supposons que <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> dépende de <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span>−1</sub>, on fait alors un raisonnement 
analogue à celui de la preuve du théorème de structure de Risch, en décomposant
<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> en produit/quotient de facteurs sans multiplicités <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>=∏<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub><sup><span style="font-style:italic">j</span></sup>
et en écrivant <span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">N</span>/<span style="font-style:italic">D</span> on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>′ <span style="font-style:italic">D</span> − <span style="font-style:italic">N</span> <span style="font-style:italic">D</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">D</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
est un polynôme en <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span>−1</sub>. On en déduit comme précédemment que
<span style="font-style:italic">D</span>=1, <span style="font-style:italic">N</span>′=<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>′ est indépendant de <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span>−1</sub>. Comme on a supposé que
<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> dépend de <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span>−1</sub>, <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span>−1</sub>=exp(<span style="font-style:italic">Y</span><sub><span style="font-style:italic">k</span>−1</sub>) est alors une 
exponentielle, <span style="font-style:italic">N</span>=<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub> ne dépend pas de <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span>−1</sub> et l’un des <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>=<span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span>−1</sub>
(sinon tous les <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> seraient constants en <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span>−1</sub> donc <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> aussi).
On élimine alors la variable <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span>−1</sub> en écrivant 
ln(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>)=<span style="font-style:italic">jY</span><sub><span style="font-style:italic">k</span>−1</sub>+ln(<span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>), avec <span style="font-style:italic">Y</span><sub><span style="font-style:italic">k</span>−1</sub> et <span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub> élémentaires et
indépendants de <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span>−1</sub>.</p><p>Si <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> est indépendant de <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span>−1</sub>, alors <span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>′ aussi donc
soit <span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub> est indépendant de <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span>−1</sub> et on passe à la variable
suivante, soit <span style="font-style:italic">X</span><sub><span style="font-style:italic">k</span>−1</sub> est un logarithme et 
<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span>−1</sub>ln(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>−1</sub>)+<span style="font-style:italic">d</span><sub><span style="font-style:italic">k</span>−1</sub>.
En continuant pour toutes les variables restantes de <span style="font-style:italic">T</span><sub>2</sub>, on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">F</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> ln<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> +<span style="font-style:italic">d</span> </td></tr>
</table><p>
avec <span style="font-style:italic">d</span> et <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> élémentaires pour <span style="font-style:italic">T</span><sub>1</sub> (avec exponentielles
modifiées en en prenant une racine <span style="font-style:italic">n</span>-ième) et <span style="font-style:italic">K</span>′.</p><p><span style="font-weight:bold">Deuxième étape</span>
Il s’agit de montrer que pour les exponentielles, il n’est en fait pas
nécessaire de prendre de racines <span style="font-style:italic">n</span>-ième. La compréhension
de cette étape demande
un peu de familiarité avec l’algorithme de Risch (cf. infra).
On va faire la preuve pour la variable au sommet de la tour <span style="font-style:italic">T</span><sub>1</sub> si
c’est une exponentielle. On verra dans le déroulement
de l’algorithme de Risch que pour les autres variables, il y a
appel récursif de l’algorithme d’intégration, donc traiter
la variable au sommet suffira.
Soit donc exp(<span style="font-style:italic">Y</span>) la variable au sommet de la tour <span style="font-style:italic">T</span><sub>1</sub>, on note
<span style="font-style:italic">X</span>=exp(<span style="font-style:italic">Y</span>/<span style="font-style:italic">n</span>) la racine <span style="font-style:italic">n</span>-ième de cette variable qui est utilisée
pour exprimer <span style="font-style:italic">F</span>=∑<span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> ln<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> + <span style="font-style:italic">N</span>/<span style="font-style:italic">D</span> comme une fraction
rationnelle en <span style="font-style:italic">X</span> alors que <span style="font-style:italic">f</span>=<span style="font-style:italic">F</span>′ est une fraction rationnelle en <span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span></sup>.
On a donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∑</span><span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">D</span></td></tr>
</table></td><td class="dcell">′ 
=<span style="font-style:italic">f</span>=fraction rationnelle en (<span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span></sup>) </td></tr>
</table><p>
Notons que le fait que <span style="font-style:italic">X</span> soit une exponentielle est essentiel, 
car par exemple l’intégrale d’une fraction rationnelle dépendant de <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup> 
comme <span style="font-style:italic">x</span><sup>3</sup> ou 1/(<span style="font-style:italic">x</span><sup>3</sup>−1) ne s’exprime pas en fonction de <span style="font-style:italic">x</span><sup>3</sup>.
On traite d’abord la partie polynomiale généralisée de <span style="font-style:italic">f</span> en <span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span></sup>:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>∈ ℤ</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> (<span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span></sup>)<sup><span style="font-style:italic">j</span></sup></td></tr>
</table><p>
Son intégrale est un polynôme généralisé, éventuellement dépendant
de <span style="font-style:italic">X</span>, soit ∑<sub><span style="font-style:italic">j</span>∈ ℤ</sub> <span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">X</span><sup><span style="font-style:italic">j</span></sup>. On dérive, et on obtient
pour <span style="font-style:italic">k</span> non multiple de <span style="font-style:italic">n</span>, <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">Y</span>/<span style="font-style:italic">n</span>+<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>′=0 dont <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>=0 est
solution. La partie polynôme généralisé ne dépend donc que de <span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span></sup>.
On effectue aussi les intégrations par parties pour réduire le 
dénominateur de <span style="font-style:italic">f</span> à un polynôme sans facteurs multiples (réduction
de Hermite), ce qui se fait en introduisant des fractions rationnelles 
en <span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span></sup> uniquement. Reste la partie logarithmique. On utilise le critère
du résultant, les coefficients des logarithmes sont les racines 
<span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> du polynôme en <span style="font-style:italic">t</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">Res<sub><span style="font-style:italic">X</span></sub> (<span style="font-style:italic">D</span>,<span style="font-style:italic">N</span>−<span style="font-style:italic">tD</span>′) </td></tr>
</table><p>
où ces racines doivent être indépendantes de <span style="font-style:italic">x</span> (puisque <span style="font-style:italic">F</span> existe)
et les <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> correspondants sont égaux à
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">gcd(<span style="font-style:italic">D</span>,<span style="font-style:italic">N</span>−<span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">D</span>′) </td></tr>
</table><p>
Or comme <span style="font-style:italic">X</span> est une exponentielle, <span style="font-style:italic">D</span>′ est un polynôme en
<span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span></sup>, de même que <span style="font-style:italic">D</span> et <span style="font-style:italic">N</span>, donc <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> est un polynôme
en <span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span></sup>.</p><p><span style="font-weight:bold">Troisième étape</span>
Il reste enfin à montrer que seuls les <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> et <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> nécessitent
une extension algébrique de <span style="font-style:italic">K</span>. Ceci est encore une conséquence
de l’algorithme de Risch, la construction
de la partie polynomiale (éventuellement généralisée) et de la 
partie fractionnaire ne font en effet intervenir que des coefficients
dans le corps <span style="font-style:italic">K</span>.</p>
<!--TOC subsection id="sec182" L’algorithme de Risch-->
<h3 id="sec182" class="subsection">19.3  L’algorithme de Risch</h3><!--SEC END --><p> <a id="sec:risch"></a>
On suppose dans la suite qu’on s’est ramené à une fraction rationnelle
par rapport à une tour de variables (où on a effectué les simplifications
évidentes ln∘ exp, ainsi que exp∘ ln, dans le
premier cas en extrayant les facteurs évidents en les variables
précédentes exponentielles, dans le deuxième cas en extrayant la
partie linéaire à coefficient entier en les variables logarithmes
précédentes).
On note <span style="font-style:italic">X</span> la variable au sommet de la tour et <span style="font-style:italic">N</span><sub>0</sub>/<span style="font-style:italic">D</span><sub>0</sub> l’écriture
de la fonction élémentaire comme fraction irréductible avec
<span style="font-style:italic">N</span><sub>0</sub> et <span style="font-style:italic">D</span><sub>0</sub> polynômes en <span style="font-style:italic">X</span>.</p><p><span style="font-weight:bold">Exemples</span><br>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell">(2<span style="font-style:italic">x</span><sup>2</sup>+1) <span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span><sup>2</sup></sup></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">X</span>=<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span><sup>2</sup></sup></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">N</span><sub>0</sub>=(2<span style="font-style:italic">x</span><sup>2</sup>+1) <span style="font-style:italic">X</span>, <span style="font-style:italic">D</span><sub>0</sub>=1 </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span> ln(<span style="font-style:italic">x</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>+ln(<span style="font-style:italic">x</span>)</td></tr>
</table></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">X</span>=ln(<span style="font-style:italic">x</span>)</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">N</span><sub>0</sub>=<span style="font-style:italic">xX</span>, <span style="font-style:italic">D</span><sub>0</sub>=<span style="font-style:italic">x</span>+<span style="font-style:italic">X</span>
</td></tr>
</table></td></tr>
</table><p>La première étape va consister à se ramener à un dénominateur sans facteurs
multiples. Elle est analogue au cas des fractions
rationnelles de <span style="font-style:italic">x</span> et est basée sur l’identité de Bézout entre
<span style="font-style:italic">P</span> et <span style="font-style:italic">P</span>′ vu comme polynômes en la variable du haut de la tour. 
Il apparait toutefois une difficulté pour les
extensions exponentielles, à savoir que <span style="font-style:italic">X</span>=<span style="font-style:italic">e</span><sup><span style="font-style:italic">f</span></sup> et <span style="font-style:italic">X</span>′=<span style="font-style:italic">f</span>′ <span style="font-style:italic">X</span>
ne sont pas premiers entre eux comme polynômes en <span style="font-style:italic">X</span>, on devra
traiter le pôle 0 d’une fraction rationnelle en une exponentielle <span style="font-style:italic">X</span> comme
on traite l’intégration d’un polynôme en <span style="font-style:italic">x</span>.
Si <span style="font-style:italic">P</span> est sans facteurs multiples et premier avec <span style="font-style:italic">X</span>, alors
<span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>) et <span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>)′=<span style="font-style:italic">f</span>′ <span style="font-style:italic">X</span> <span style="font-style:italic">P</span>′(<span style="font-style:italic">X</span>) vu comme
polynômes en <span style="font-style:italic">X</span> n’ont pas de facteurs en commun.</p><p>On commence donc, si <span style="font-style:italic">X</span> est une exponentielle et <span style="font-style:italic">D</span><sub>0</sub> un
multiple de <span style="font-style:italic">X</span>, par appliquer Bézout pour décomposer la fraction <span style="font-style:italic">N</span><sub>0</sub>/<span style="font-style:italic">D</span><sub>0</sub>
en :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span><sub>0</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">D</span><sub>0</sub></td></tr>
</table></td><td class="dcell">
=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span><sub>1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">D</span><sub>1</sub></td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">X</span><sup><span style="font-style:italic">k</span></sup> </td></tr>
</table></td><td class="dcell"> ,    gcd(<span style="font-style:italic">X</span>,<span style="font-style:italic">D</span><sub>1</sub>)=1, <span style="font-style:italic">D</span><sub>0</sub>=<span style="font-style:italic">X</span><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">D</span><sub>1</sub></td></tr>
</table><p>
On isole aussi la partie polynômiale en effectuant
la division euclidienne de <span style="font-style:italic">N</span><sub>0</sub> par <span style="font-style:italic">D</span><sub>0</sub> (ou de <span style="font-style:italic">N</span><sub>1</sub> par <span style="font-style:italic">D</span><sub>1</sub> si <span style="font-style:italic">X</span>
est une exponentielle),
on obtient alors une écriture sous la forme :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">D</span></td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">X</span><sup><span style="font-style:italic">j</span></sup></td></tr>
</table><p>
où la somme sur <span style="font-style:italic">j</span> est finie et porte sur des entiers positifs ou nul 
si <span style="font-style:italic">X</span> n’est pas une exponentielle, ou sur des entiers relatifs si <span style="font-style:italic">X</span>
est une exponentielle.</p><p>On effectue la même écriture sur la partie fractionnaire de <span style="font-style:italic">F</span>,
et en identifiant les parties polynomiales et éventuellement la partie
polaire en 0 si <span style="font-style:italic">X</span> est une exponentielle, on peut séparer l’intégration
en 2 parties: intégration de la partie polynomiale (généralisée)
et intégration de la partie fractionnaire propre.</p><p><span style="font-weight:bold">Exemples</span>
</p><ul class="itemize"><li class="li-itemize">
 (2<span style="font-style:italic">x</span><sup>2</sup>+1) <span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span><sup>2</sup></sup> = 0+(2<span style="font-style:italic">x</span><sup>2</sup>+1)<span style="font-style:italic">X</span> est un polynôme,
</li><li class="li-itemize"><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span> ln(<span style="font-style:italic">x</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>+ln(<span style="font-style:italic">x</span>)</td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">xX</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>+<span style="font-style:italic">X</span></td></tr>
</table></td><td class="dcell">=−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>+<span style="font-style:italic">X</span></td></tr>
</table></td><td class="dcell">+<span style="font-style:italic">x</span></td></tr>
</table>
la partie polynomiale est <span style="font-style:italic">x</span> (de degré 0 en <span style="font-style:italic">X</span>), la partie fractionnaire
est −<span style="font-style:italic">x</span><sup>2</sup>/(<span style="font-style:italic">x</span>+<span style="font-style:italic">X</span>)
</li><li class="li-itemize"><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>(<span style="font-style:italic">e</span><sup>2<span style="font-style:italic">x</span></sup>+1)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup>(<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup>+1)<sup>2</sup></td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>(<span style="font-style:italic">X</span><sup>2</sup>+1)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">X</span>(<span style="font-style:italic">X</span>+1)<sup>2</sup></td></tr>
</table></td><td class="dcell">
= −</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">X</span>+1)<sup>2</sup></td></tr>
</table></td><td class="dcell"> + <span style="font-style:italic">xX</span><sup>−1</sup></td></tr>
</table>
la partie polynôme généralisé est <span style="font-style:italic">xX</span><sup>−1</sup>
</li></ul>
<!--TOC subsubsection id="sec183" Intégration d’une fraction propre-->
<h4 id="sec183" class="subsubsection">19.3.1  Intégration d’une fraction propre</h4><!--SEC END --><p><a id="hevea_default209"></a>
</p>
<!--TOC subsubsection id="sec184" Réduction sans facteurs multiples-->
<h4 id="sec184" class="subsubsection">19.3.2  Réduction sans facteurs multiples</h4><!--SEC END --><p>
On factorise <span style="font-style:italic">D</span> en ∏<sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">i</span></sup> avec <span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub> sans facteurs multiples 
(et les <span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub> premiers entre eux 2 à 2) et on décompose
en éléments simples relativement à cette factorisation (en appliquant
Bézout) :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">D</span></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>&gt;0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span><sub><span style="font-style:italic">i</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">i</span></sup></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Pour chaque polynome <span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub>, on applique Bézout à <span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub> et <span style="font-style:italic">P</span>′<sub><span style="font-style:italic">i</span></sub> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">N</span><sub><span style="font-style:italic">i</span></sub> = <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub><span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub>+<span style="font-style:italic">B</span><sub><span style="font-style:italic">i</span></sub><span style="font-style:italic">P</span>′<sub><span style="font-style:italic">i</span></sub> ⇒ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span><sub><span style="font-style:italic">i</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">i</span></sup></td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">i</span>−1</sup></td></tr>
</table></td><td class="dcell">
+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub><span style="font-style:italic">i</span></sub><span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">i</span></sup></td></tr>
</table></td></tr>
</table><p>
on intègre par parties le second terme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span><sub><span style="font-style:italic">i</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">i</span></sup></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">i</span>−1</sup></td></tr>
</table></td><td class="dcell">
− </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub><span style="font-style:italic">i</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">i</span>−1)<span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">i</span>−1</sup></td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub><span style="font-style:italic">i</span></sub>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">i</span>−1)<span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">i</span>−1</sup></td></tr>
</table></td><td class="dcell">  </td></tr>
</table><p>
on rassemble les deux intégrales ayant <span style="font-style:italic">P</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">i</span>−1</sup> au dénominateur
et on recommence jusqu’à avoir une puissance 1 au dénominateur. Il reste
alors à intégrer une somme de fractions du type <span style="font-style:italic">N</span>/<span style="font-style:italic">D</span> avec
<span style="font-style:italic">D</span> et <span style="font-style:italic">D</span>′ premiers entre eux.</p><p><span style="font-weight:bold">Exemple</span><br>
On reprend le dernier exemple de la section précédente pour
éliminer la puissance 2 au dénominateur:
<span style="font-style:italic">N</span><sub>2</sub>=2<span style="font-style:italic">x</span> et <span style="font-style:italic">P</span><sub>2</sub>=(<span style="font-style:italic">X</span>+1) avec <span style="font-style:italic">X</span>=<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup>. On a <span style="font-style:italic">P</span><sub>2</sub>′=<span style="font-style:italic">X</span>, donc <span style="font-style:italic">A</span><sub>2</sub>=2<span style="font-style:italic">x</span> et
<span style="font-style:italic">B</span><sub>2</sub>=−2<span style="font-style:italic">x</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">X</span>+1)<sup>2</sup></td></tr>
</table></td><td class="dcell"> =</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub>2</sub></td></tr>
</table></td><td class="dcell"> + 
</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−2<span style="font-style:italic">x</span> <span style="font-style:italic">P</span><sub>2</sub>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub>2</sub><sup>2</sup></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub>2</sub></td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub>2</sub></td></tr>
</table></td><td class="dcell">
− </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub>2</sub></td></tr>
</table></td></tr>
</table><p>
il reste donc à intégrer (2<span style="font-style:italic">x</span>−2)/(<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup>+1).</p>
<!--TOC subsubsection id="sec185" La partie logarithmique-->
<h4 id="sec185" class="subsubsection">19.3.3  La partie logarithmique</h4><!--SEC END --><p>
Comme on l’a vu lors de la preuve du théorème de structure de Risch,
si on dérive une fraction en <span style="font-style:italic">X</span>, le dénominateur de la dérivée ne
peut se décomposer qu’en produit de facteurs de multiplicité supérieure
ou égale à 2. Il en résulte que la fraction à intégrer résiduelle (encore
notée <span style="font-style:italic">f</span>=<span style="font-style:italic">N</span>/<span style="font-style:italic">D</span>) après l’étape de réduction ci-dessus ne peut provenir que de la
dérivation de <span style="font-style:italic">F</span>=∑<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> ln(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>) :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">D</span></td></tr>
</table></td><td class="dcell">=<span style="font-style:italic">F</span>′= (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> ln(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>))′= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td></tr>
</table><p>
En identifiant les décompositions
en éléments simples de <span style="font-style:italic">F</span>′ et <span style="font-style:italic">f</span>, on montre également que 
les <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> divisent <span style="font-style:italic">D</span>, plus précisément on peut imposer aux <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>
d’être premiers entre eux 2 à 2 et dans ce cas <span style="font-style:italic">D</span>=∏<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>. 
Donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">D</span></td></tr>
</table></td></tr>
</table><p>
et :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">N</span> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>′ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub> </td></tr>
</table><p>
Soit <span style="font-style:italic">t</span> un paramètre, formons le polynôme <span style="font-style:italic">N</span>−<span style="font-style:italic">tD</span>′ :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">N</span>−<span style="font-style:italic">tD</span>′ = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">(<span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> −<span style="font-style:italic">t</span>) <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>′ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
donc le pgcd en <span style="font-style:italic">X</span> des polynômes <span style="font-style:italic">N</span>−<span style="font-style:italic">tD</span>′ et <span style="font-style:italic">D</span> est :
</p><ul class="itemize"><li class="li-itemize">
si <span style="font-style:italic">t</span> n’est égal à aucun des <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub>, <span style="font-style:italic">N</span>−<span style="font-style:italic">tD</span>′ est premier
avec <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> pour tout <span style="font-style:italic">k</span> car <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> divise
∑<sub><span style="font-style:italic">l</span> ≠ <span style="font-style:italic">k</span></sub> (<span style="font-style:italic">c</span><sub><span style="font-style:italic">l</span></sub> −<span style="font-style:italic">t</span>) <span style="font-style:italic">v</span><sub><span style="font-style:italic">l</span></sub>′ ∏<sub><span style="font-style:italic">j</span>≠ <span style="font-style:italic">l</span></sub> <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub>
et <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>′∏<sub><span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span></sub> <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub>  est premier avec <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>. Donc
le pgcd est 1.
</li><li class="li-itemize">si <span style="font-style:italic">t</span> est égal à l’un des <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub>, alors le pgcd est le produit
des <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> tels que <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">t</span> (notons que dans ce cas on peut
rassembler ces <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> à l’intérieur d’un même logarithme)
</li></ul><p>
Considérons le polynôme <span style="font-style:italic">R</span> de la variable <span style="font-style:italic">t</span> égal au résultant par rapport
à <span style="font-style:italic">X</span> des polynômes <span style="font-style:italic">D</span> et <span style="font-style:italic">N</span>−<span style="font-style:italic">tD</span>′ (rappelons qu’il s’agit du
déterminant du système linéaire <span style="font-style:italic">AD</span>+<span style="font-style:italic">B</span>(<span style="font-style:italic">N</span>−<span style="font-style:italic">tD</span>′)=1
où les inconnues sont les coefficients des polynômes <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span>, 
ce déterminant est nul si et seulement si le système n’a pas
de solution donc si et seulement si <span style="font-style:italic">D</span> et <span style="font-style:italic">N</span>−<span style="font-style:italic">tD</span>′ ne sont pas
premiers entre eux), alors ce polynôme en <span style="font-style:italic">t</span>
s’annule si et seulement si <span style="font-style:italic">t</span>=<span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub>. 
On cherche les racines <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> en <span style="font-style:italic">t</span> de ce polynôme,
elles doivent être indépendantes de <span style="font-style:italic">x</span> si <span style="font-style:italic">F</span> est élémentaire,
et dans ce cas la primitive <span style="font-style:italic">F</span> de <span style="font-style:italic">f</span>=<span style="font-style:italic">N</span>/<span style="font-style:italic">D</span> vaut
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">F</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub>  racine de  <span style="font-style:italic">R</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> ln(gcd(<span style="font-style:italic">N</span>−<span style="font-style:italic">c</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">D</span>′,<span style="font-style:italic">D</span>)) </td></tr>
</table><p><span style="font-weight:bold">Exemples</span>
</p><ul class="itemize"><li class="li-itemize">
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">x</span>−2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup>+1</td></tr>
</table></td><td class="dcell">,    <span style="font-style:italic">D</span>=<span style="font-style:italic">X</span>+1, <span style="font-style:italic">D</span>′=<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup>=<span style="font-style:italic">X</span>,    <span style="font-style:italic">N</span>−<span style="font-style:italic">tD</span>′=2<span style="font-style:italic">x</span>−2−<span style="font-style:italic">tX</span> </td></tr>
</table>
On calcule <span style="font-style:italic">R</span>=−2*<span style="font-style:italic">x</span>−<span style="font-style:italic">t</span>+2, l’unique racine est <span style="font-style:italic">t</span>=2−2<span style="font-style:italic">x</span> qui n’est
pas constante donc cette fonction n’admet pas de primitive élémentaire.
</li><li class="li-itemize"><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">x</span>−2)<span style="font-style:italic">X</span>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">X</span><sup>2</sup>+(<span style="font-style:italic">x</span>+1)<span style="font-style:italic">X</span>+<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell">,    <span style="font-style:italic">X</span>=exp(<span style="font-style:italic">x</span><sup>2</sup>+<span style="font-style:italic">x</span>)</td></tr>
</table>
On a <span style="font-style:italic">D</span>′=2(2<span style="font-style:italic">x</span>+1)<span style="font-style:italic">X</span><sup>2</sup>+(1+(2<span style="font-style:italic">x</span>+1)(<span style="font-style:italic">x</span>+1))<span style="font-style:italic">X</span>+1
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">R</span>=−(2<span style="font-style:italic">x</span>−1)(<span style="font-style:italic">x</span>+1)(2<span style="font-style:italic">x</span>+1)(<span style="font-style:italic">x</span>−1)<sup>2</sup>(<span style="font-style:italic">t</span>+1)(<span style="font-style:italic">t</span>−1) </td></tr>
</table>
les racines en <span style="font-style:italic">t</span> sont constantes et égales à 1 et -1, donc <span style="font-style:italic">c</span><sub>1</sub>=1
et <span style="font-style:italic">v</span><sub>1</sub>=gcd(<span style="font-style:italic">N</span>−<span style="font-style:italic">D</span>′,<span style="font-style:italic">D</span>)=<span style="font-style:italic">X</span>+1 et <span style="font-style:italic">c</span><sub>2</sub>=−1, <span style="font-style:italic">v</span><sub>2</sub>=gcd(<span style="font-style:italic">N</span>+<span style="font-style:italic">D</span>′,<span style="font-style:italic">D</span>)=<span style="font-style:italic">x</span>+<span style="font-style:italic">X</span>
donc :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">x</span>−2)<span style="font-style:italic">X</span>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">X</span><sup>2</sup>+(<span style="font-style:italic">x</span>+1)<span style="font-style:italic">X</span>+<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> = ln(<span style="font-style:italic">X</span>+1)−ln(<span style="font-style:italic">x</span>+<span style="font-style:italic">X</span>)</td></tr>
</table>
</li></ul><p><span style="font-weight:bold">Remarque importante</span><br>
Pour les extensions exponentielles ou logarithmiques, 
la dérivée de la partie logarithmique
calculée comme ci-dessus contiendra en général 
une partie entière constante par rapport à <span style="font-style:italic">X</span>, il faut
donc retirer cette partie entière à la partie polynomiale.</p>
<!--TOC subsubsection id="sec186" La partie polynomiale (généralisée)-->
<h4 id="sec186" class="subsubsection">19.3.4  La partie polynomiale (généralisée)</h4><!--SEC END --><p>
On doit résoudre :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">X</span><sup><span style="font-style:italic">j</span></sup>)′=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">X</span><sup><span style="font-style:italic">j</span></sup> </td></tr>
</table><p>
avec une somme sur <span style="font-style:italic">j</span> ∈ℤ si <span style="font-style:italic">X</span> est une exponentielle et
<span style="font-style:italic">j</span>∈ ℕ sinon.</p><p>Si <span style="font-style:italic">X</span>=<span style="font-style:italic">x</span>, <span style="font-style:italic">j</span>≥ 0 et la résolution est immédiate: on prend <span style="font-style:italic">A</span><sub>0</sub>=0 et 
<span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span>+1</sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub>/(<span style="font-style:italic">j</span>+1).</p>
<!--TOC subsubsection id="sec187" Extension logarithmique-->
<h4 id="sec187" class="subsubsection">19.3.5  Extension logarithmique</h4><!--SEC END --><p>
Si <span style="font-style:italic">X</span>=ln(<span style="font-style:italic">Y</span>) est un logarithme, <span style="font-style:italic">j</span> ≥ 0 et on doit résoudre :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>≥ 0</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub>′+(<span style="font-style:italic">j</span>+1)<span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span>+1</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Y</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Y</span></td></tr>
</table></td><td class="dcell">) <span style="font-style:italic">X</span><sup><span style="font-style:italic">j</span></sup> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">X</span><sup><span style="font-style:italic">j</span></sup> </td></tr>
</table><p>
Soit <span style="font-style:italic">k</span> la plus grande puissance non nulle de <span style="font-style:italic">f</span> (<span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub>=0 
si <span style="font-style:italic">j</span>&gt;<span style="font-style:italic">k</span> et <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub>≠ 0). Pour <span style="font-style:italic">j</span>&gt;<span style="font-style:italic">k</span>, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub>′+(<span style="font-style:italic">j</span>+1)<span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span>+1</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Y</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Y</span></td></tr>
</table></td><td class="dcell">  =0 </td></tr>
</table><p>
On résout pour des valeurs de <span style="font-style:italic">j</span> décroissante, pour <span style="font-style:italic">j</span> suffisamment
grand, on a <span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span>+1</sub>=0 car la somme sur <span style="font-style:italic">j</span> est finie, donc <span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub>
est constant. Si <span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub> ≠ 0, alors au rang <span style="font-style:italic">j</span>−1, on a 
<span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span>−1</sub> ′ = −<span style="font-style:italic">j</span> <span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">Y</span>′/<span style="font-style:italic">Y</span>  qui n’admet pas de solutions car 
<span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span>−1</sub> ne peut pas dépendre de <span style="font-style:italic">X</span>=ln(<span style="font-style:italic">Y</span>). On en déduit que pour
<span style="font-style:italic">j</span>&gt;<span style="font-style:italic">k</span>+1, on a <span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub>=0 et <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>+1</sub> est constant. En fait la
valeur constante de <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>+1</sub> sera déterminée par une condition
de compatibilité en résolvant l’équation au rang du dessous.
On continue la résolution de 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub>′+(<span style="font-style:italic">j</span>+1)<span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span>+1</sub> ln(<span style="font-style:italic">Y</span>)′  = <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> </td></tr>
</table><p>
par valeur décroissante de <span style="font-style:italic">j</span>, à chaque
rang on va déterminer <span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub> à une constante près en résolvant
un problème d’intégration (par appel récursif de l’algorithme
de Risch, mais si <span style="font-style:italic">j</span> ≠ 0 sans autoriser l’ajout de nouveaux 
logarithmes sauf ln(<span style="font-style:italic">Y</span>))
et la valeur de la constante de <span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span>+1</sub> (on fait varier <span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span>+1</sub>
de la constante nécessaire pour absorber le terme en ln(<span style="font-style:italic">Y</span>)
qui apparait lors de l’appel récursif de Risch).
Au rang 0, on est ramené à un problème d’intégration avec
une variable de moins (la constante
indéterminée dans <span style="font-style:italic">A</span><sub>1</sub> peut par exemple être choisie comme
le coefficient constant de ln(<span style="font-style:italic">Y</span>) s’il en apparait un en intégrant).</p><p><span style="font-weight:bold">Exemple</span><br>
<span style="font-style:italic">X</span>=ln(<span style="font-style:italic">x</span><sup>2</sup>+1) et on cherche l’intégrale de <span style="font-style:italic">X</span><sup>2</sup>. On a donc <span style="font-style:italic">A</span><sub>3</sub>
est constant,
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span><sub>2</sub>′ + 3 <span style="font-style:italic">A</span><sub>3</sub> ln(<span style="font-style:italic">x</span><sup>2</sup>+1)′ = 1</td></tr>
</table><p>
La primitive de 1 est élémentaire et ne fait pas intervenir de ln
donc <span style="font-style:italic">A</span><sub>3</sub>=0 et <span style="font-style:italic">A</span><sub>2</sub>=<span style="font-style:italic">x</span>+<span style="font-style:italic">C</span><sub>2</sub>. Au rang 1, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span><sub>1</sub>′ + 3 <span style="font-style:italic">x</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2</sup>+1</td></tr>
</table></td><td class="dcell"> + <span style="font-style:italic">C</span><sub>2</sub> ln(<span style="font-style:italic">x</span><sup>2</sup>+1)′ = 0</td></tr>
</table><p>
On calcule la primitive de 6<span style="font-style:italic">x</span><sup>2</sup>/(<span style="font-style:italic">x</span><sup>2</sup>+1) qui doit être une fraction
rationnelle à un <span style="font-style:italic">C</span>ln(<span style="font-style:italic">x</span><sup>2</sup>+1) près, on voit que ce n’est pas le cas
donc <span style="font-style:italic">X</span><sup>2</sup> n’admet pas de primitive élémentaire.
Remarque: si on avait voulu intégrer <span style="font-style:italic">X</span> au lieu de <span style="font-style:italic">X</span><sup>2</sup>, la même
méthode montre que la primitive existe, car au rang 0 il n’y
a plus de contraintes sur les ln qu’on peut rajouter.</p>
<!--TOC subsubsection id="sec188" Extension exponentielle-->
<h4 id="sec188" class="subsubsection">19.3.6  Extension exponentielle</h4><!--SEC END --><p>
Si <span style="font-style:italic">X</span>=exp(<span style="font-style:italic">Y</span>) est une exponentielle, on doit résoudre :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub>′+<span style="font-style:italic">j</span> <span style="font-style:italic">Y</span>′<span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub>) <span style="font-style:italic">X</span><sup><span style="font-style:italic">j</span></sup> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">X</span><sup><span style="font-style:italic">j</span></sup> </td></tr>
</table><p>
Ceci va se faire degré par degré :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:rischdiffeq"></a>
<span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub>′+<span style="font-style:italic">j</span> <span style="font-style:italic">Y</span>′ <span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub> = <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub>
    (27)</td></tr>
</table><p>
<span style="font-weight:bold">Exemple</span><br>
Pour calculer ∫<span style="font-style:italic">a</span>(<span style="font-style:italic">x</span>) exp(<span style="font-style:italic">x</span><sup>2</sup>), on a <span style="font-style:italic">j</span>=1, et on doit résoudre
l’équation différentielle :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span><sub>1</sub>′+2<span style="font-style:italic">xA</span><sub>1</sub>= <span style="font-style:italic">a</span>(<span style="font-style:italic">x</span>)</td></tr>
</table><p>Pour <span style="font-style:italic">j</span>=0, il suffit de faire un appel récursif à l’algorithme de Risch,
mais pour <span style="font-style:italic">j</span>≠ 0, la situation se complique!
Notons <span style="font-style:italic">Z</span> la variable située juste en-dessous de <span style="font-style:italic">X</span> dans la tour
de variables (dans l’exemple ci-dessus <span style="font-style:italic">Z</span>=<span style="font-style:italic">x</span>), il s’agit de résoudre : 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:rischdiffeq2"></a>
<span style="font-style:italic">y</span>′+<span style="font-style:italic">f</span> <span style="font-style:italic">y</span>=<span style="font-style:italic">g</span>
    (28)</td></tr>
</table><p>
avec <span style="font-style:italic">f</span>, <span style="font-style:italic">g</span> élémentaires par rapport à une tour dont le
variable au sommet est <span style="font-style:italic">Z</span>, on cherche <span style="font-style:italic">y</span> élémentaire par rapport
à cette tour (ici <span style="font-style:italic">f</span>=<span style="font-style:italic">jY</span>′ est une dérivée mais dans certains
cas nous devrons résoudre par appel récursif des équations
du type ci-dessus où <span style="font-style:italic">f</span> ne sera pas une dérivée).</p><p><span style="font-weight:bold">Élimination des dénominateurs</span><br>
Soit <span style="font-style:italic">P</span> un facteur irréductible du dénominateur de <span style="font-style:italic">y</span>, notons 
α&lt;0 la valuation de <span style="font-style:italic">y</span> par rapport à <span style="font-style:italic">P</span>, 
β celle de <span style="font-style:italic">f</span>, γ celle de <span style="font-style:italic">g</span>. 
Si <span style="font-style:italic">P</span> n’est pas une exponentielle,
la valuation de <span style="font-style:italic">y</span>′ est α−1, celle de  <span style="font-style:italic">f</span> <span style="font-style:italic">y</span>  est α +β . 
Si β ≠ −1, 
il n’y a pas de simplification possible dans le membre de gauche
donc α + min(β,−1) =γ. Autrement dit, si 
β ≥ 0 alors α=γ+1 et si β&lt;−1 
alors α=γ−β.
On observe que γ&lt;0 donc
<span style="font-style:italic">P</span> est un facteur du dénominateur <span style="font-style:italic">g</span><sub><span style="font-style:italic">d</span></sub> de <span style="font-style:italic">g</span>. De plus, on va montrer
que la valuation α de <span style="font-style:italic">P</span> dans <span style="font-style:italic">y</span> est l’opposé de celle
de <span style="font-style:italic">P</span> dans :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:defD"></a>
<span style="font-style:italic">D</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">gcd(<span style="font-style:italic">g</span><sub><span style="font-style:italic">d</span></sub>,∂<sub><span style="font-style:italic">Z</span></sub> <span style="font-style:italic">g</span><sub><span style="font-style:italic">d</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">gcd(<span style="font-style:italic">c</span>,∂<sub><span style="font-style:italic">Z</span></sub> <span style="font-style:italic">c</span>)</td></tr>
</table></td><td class="dcell">, 
   <span style="font-style:italic">c</span>=gcd(<span style="font-style:italic">f</span><sub><span style="font-style:italic">d</span></sub>,<span style="font-style:italic">g</span><sub><span style="font-style:italic">d</span></sub>)
    (29)</td></tr>
</table><p>
En effet, si β ≥ 0, <span style="font-style:italic">P</span> ne divise pas <span style="font-style:italic">f</span><sub><span style="font-style:italic">d</span></sub> donc ne divise
pas <span style="font-style:italic">c</span>, donc la valuation de <span style="font-style:italic">P</span> dans <span style="font-style:italic">D</span> est −γ−1. Si β &lt; −1,
alors α=γ − β &lt;0 entraine −γ &gt; −β donc la
valuation de <span style="font-style:italic">P</span> dans <span style="font-style:italic">c</span> est −β et la valuation de <span style="font-style:italic">P</span> dans <span style="font-style:italic">D</span>
est −γ−1 − (−β−1).</p><p>Si β=−1, s’il n’y a pas de simplifications dans le membre
de gauche pour les termes de plus petite puissance en <span style="font-style:italic">P</span>, alors 
α=γ+1. S’il y a simplification,
on décompose en éléments
simples (avec Bézout) puis on ordonne par puissances croissantes
de <span style="font-style:italic">P</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>= <span style="font-style:italic">N</span><sub>1</sub> <span style="font-style:italic">P</span><sup>α</sup>+..., <span style="font-style:italic">f</span>= <span style="font-style:italic">N</span><sub>2</sub> <span style="font-style:italic">P</span><sup>−1</sup>+...,</td></tr>
</table><p>
avec <span style="font-style:italic">N</span><sub>1</sub>,<span style="font-style:italic">N</span><sub>2</sub> de degré plus petit que <span style="font-style:italic">P</span>, puis on remplace dans 
(<a href="#eq%3Arischdiffeq2">28</a>). On cherche les termes de valuation α−1
en <span style="font-style:italic">P</span> qui doivent se simplifier :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">α <span style="font-style:italic">N</span><sub>1</sub> <span style="font-style:italic">P</span>′ <span style="font-style:italic">P</span><sup>α−1</sup> + <span style="font-style:italic">N</span><sub>2</sub> <span style="font-style:italic">P</span><sup>−1</sup> <span style="font-style:italic">N</span><sub>1</sub> <span style="font-style:italic">P</span><sup>α</sup>=0 </td></tr>
</table><p>
donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">N</span><sub>2</sub> = −α <span style="font-style:italic">P</span>′ </td></tr>
</table><p>
ce qui détermine α.</p><p><span style="font-weight:bold">Récapitulons</span><br>
Si <span style="font-style:italic">f</span> est une dérivée, alors β=−1 est exclus et on peut
appliquer (<a href="#eq%3AdefD">29</a>) pour déterminer <span style="font-style:italic">D</span>. Si <span style="font-style:italic">f</span> n’est
pas une dérivée, on calcule les facteurs de degré 1 de <span style="font-style:italic">f</span><sub><span style="font-style:italic">d</span></sub> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span><sub>1</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span><sub><span style="font-style:italic">d</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">gcd(<span style="font-style:italic">f</span><sub><span style="font-style:italic">d</span></sub>,∂<sub><span style="font-style:italic">Z</span></sub> <span style="font-style:italic">f</span><sub><span style="font-style:italic">d</span></sub>)</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
on décompose <span style="font-style:italic">f</span> par Bézout en isolant la partie <span style="font-style:italic">N</span>/<span style="font-style:italic">f</span><sub>1</sub>
les α possibles sont alors les racines entières (en <span style="font-style:italic">t</span>)
du résultant en <span style="font-style:italic">Z</span> de <span style="font-style:italic">N</span>−<span style="font-style:italic">tf</span><sub>1</sub>′ et <span style="font-style:italic">f</span><sub>1</sub>, ils correspondent aux
facteurs gcd(<span style="font-style:italic">N</span>−α <span style="font-style:italic">f</span><sub>1</sub>′,<span style="font-style:italic">f</span><sub>1</sub>) que l’on retire de <span style="font-style:italic">f</span><sub><span style="font-style:italic">d</span></sub> pour
appliquer (<a href="#eq%3AdefD">29</a>).</p><p><span style="font-weight:bold">Exemple</span><br>
Reprenons <span style="font-style:italic">y</span>′+2<span style="font-style:italic">xy</span>=<span style="font-style:italic">a</span>(<span style="font-style:italic">x</span>). Si <span style="font-style:italic">a</span>(<span style="font-style:italic">x</span>)=1 (résolution de ∫exp(<span style="font-style:italic">x</span><sup>2</sup>)),
ou plus généralement si <span style="font-style:italic">a</span>(<span style="font-style:italic">x</span>) est un polynôme,
alors <span style="font-style:italic">D</span>=1. Si <span style="font-style:italic">a</span>(<span style="font-style:italic">x</span>)=1/<span style="font-style:italic">x</span><sup>2</sup>, on trouve <span style="font-style:italic">D</span>=<span style="font-style:italic">x</span> et on pose <span style="font-style:italic">y</span>=<span style="font-style:italic">xz</span>,
donc <span style="font-style:italic">x</span><sup>2</sup>(<span style="font-style:italic">xz</span>′+<span style="font-style:italic">z</span>)+2<span style="font-style:italic">x</span><sup>4</sup><span style="font-style:italic">z</span>=1 soit <span style="font-style:italic">x</span><sup>3</sup><span style="font-style:italic">z</span>′+(2<span style="font-style:italic">x</span><sup>4</sup>+1)<span style="font-style:italic">z</span>=1.</p><p>Reste le cas où <span style="font-style:italic">Z</span> est une exponentielle et <span style="font-style:italic">P</span>=exp(<span style="font-style:italic">z</span>). On reprend
le même raisonnement, <span style="font-style:italic">y</span>′ a pour valuation −α&lt;0, <span style="font-style:italic">fy</span> a pour
valuation −β−α, donc si β &gt; 0,
α=γ et si β&lt;0, α=γ−β.
Si β=0, s’il n’y a pas de simplifications du terme de plus bas
degré, on est ramené au cas précédent. 
Si β=0 et s’il y a simplification des termes de plus
bas degré en <span style="font-style:italic">Z</span>, notons <span style="font-style:italic">f</span><sub>0</sub> le coefficient constant de <span style="font-style:italic">f</span> 
par rapport à <span style="font-style:italic">Z</span> et <span style="font-style:italic">y</span><sub>α</sub> le coefficient de <span style="font-style:italic">Z</span><sup>α</sup>
dans <span style="font-style:italic">y</span>, on a 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span><sub>α</sub>′ + (α <span style="font-style:italic">z</span>′ + <span style="font-style:italic">f</span><sub>0</sub>) <span style="font-style:italic">y</span><sub>α</sub>=0 </td></tr>
</table><p>
donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span><sub>α</sub>= exp(−α <span style="font-style:italic">z</span>−</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><span style="font-style:italic">f</span><sub>0</sub>)</td></tr>
</table><p>
Comme <span style="font-style:italic">y</span><sub>α</sub> est élémentaire et indépendant de <span style="font-style:italic">Z</span>
on en déduit par le théorème de structure de Risch
que −α <span style="font-style:italic">z</span> −∫<span style="font-style:italic">f</span><sub>0</sub> est combinaison linéaire à coefficients
rationnels des logarithmes et des arguments des exponentielles de la tour,
de plus le coefficient de <span style="font-style:italic">z</span> doit être nul pour que <span style="font-style:italic">y</span><sub>α</sub> soit
indépendant de <span style="font-style:italic">Z</span>, ce qui impose la valeur de α (après avoir
résolu récursivement le problème d’intégration pour <span style="font-style:italic">f</span><sub>0</sub>)</p><p><span style="font-weight:bold">Majoration du degré du numérateur de </span><span style="font-style:italic">y</span><br>
En multipliant <span style="font-style:italic">y</span> par <span style="font-style:italic">D</span> <span style="font-style:italic">Z</span><sup>−α</sup>, puis en réduisant au
même dénominateur,
on se ramène alors à une équation différentielle à coefficients
polynomiaux par rapport à la variable <span style="font-style:italic">Z</span> dont l’inconnue est un polynôme 
<span style="font-style:italic">N</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:rischdepol"></a>
<span style="font-style:italic">R</span> <span style="font-style:italic">N</span>′ + <span style="font-style:italic">S</span> <span style="font-style:italic">N</span> = <span style="font-style:italic">T</span>
    (30)</td></tr>
</table><p>
On va chercher une majoration sur le degré possible de <span style="font-style:italic">N</span> puis
utiliser l’identité de Bézout pour simplifier
cette équation. </p><p>On écrit maintenant <span style="font-style:italic">N</span>=∑<sub><span style="font-style:italic">k</span>=0</sub><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">N</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">Z</span><sup><span style="font-style:italic">k</span></sup> et on remplace, 
il y a à nouveau trois cas selon le type de <span style="font-style:italic">Z</span>.</p><p><span style="font-weight:bold">Si </span><span style="font-style:italic">Z</span>=<span style="font-style:italic">x</span><span style="font-weight:bold">: cas exponentielle rationnelle</span><br>
Donc <span style="font-style:italic">Z</span>′=1, le degré de <span style="font-style:italic">RN</span>′ est <span style="font-style:italic">r</span>+<span style="font-style:italic">n</span>−1 (si <span style="font-style:italic">N</span> est non constant
c’est-à-dire si <span style="font-style:italic">T</span> n’est pas un multiple de <span style="font-style:italic">S</span>), le degré de
<span style="font-style:italic">SN</span> est <span style="font-style:italic">s</span>+<span style="font-style:italic">n</span>. Si <span style="font-style:italic">r</span>−1≠ <span style="font-style:italic">s</span>, on en déduit que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">n</span>=<span style="font-style:italic">t</span>−max(<span style="font-style:italic">r</span>−1,<span style="font-style:italic">s</span>)</td></tr>
</table><p>
Si <span style="font-style:italic">r</span>−1=<span style="font-style:italic">s</span>, on peut avoir
une simplification du terme de plus haut degré <span style="font-style:italic">s</span>+<span style="font-style:italic">n</span> (sinon
on est dans le cas précédent) si <span style="font-style:italic">n</span> <span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub> =<span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub> 
d’où on déduit le degré <span style="font-style:italic">n</span> de <span style="font-style:italic">N</span>.</p><p>Par exemple, pour <span style="font-style:italic">y</span>′+2<span style="font-style:italic">xy</span>=<span style="font-style:italic">T</span> ou pour <span style="font-style:italic">x</span><sup>3</sup><span style="font-style:italic">z</span>′+(2<span style="font-style:italic">x</span><sup>4</sup>+1)<span style="font-style:italic">z</span>=1 on a <span style="font-style:italic">r</span>=<span style="font-style:italic">s</span>−1 donc
<span style="font-style:italic">n</span>+<span style="font-style:italic">s</span>=<span style="font-style:italic">t</span>, donc pas de solution dans le deuxième cas, dans le premier cas
il ne peut y avoir de solutions que si <span style="font-style:italic">t</span> ≥ <span style="font-style:italic">s</span>, en particulier
il n’y a pas de solution pour <span style="font-style:italic">t</span>=1, on a donc démontré que ∫exp(<span style="font-style:italic">x</span><sup>2</sup>)
n’admet pas de primitive élémentaire.</p><p><span style="font-weight:bold">Si </span><span style="font-style:italic">Z</span>=exp(<span style="font-style:italic">z</span>)<span style="font-weight:bold">: cas exponentielle d’exponentielle</span><br>
Ici les <span style="font-style:italic">N</span><sub><span style="font-style:italic">k</span></sub> peuvent ne pas être constants, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">N</span>′=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">N</span><sub><span style="font-style:italic">k</span></sub>′+<span style="font-style:italic">kN</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">z</span>′) <span style="font-style:italic">Z</span><sup><span style="font-style:italic">k</span></sup></td></tr>
</table><p>
Comme on l’a déjà observé, <span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub>′+<span style="font-style:italic">n</span> <span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">z</span>′≠ 0, donc le
degré de <span style="font-style:italic">N</span>′ est égal au degré de <span style="font-style:italic">N</span>. On a donc trois cas :
</p><ul class="itemize"><li class="li-itemize"> 
si <span style="font-style:italic">r</span>≠ <span style="font-style:italic">s</span>, alors <span style="font-style:italic">n</span>=<span style="font-style:italic">t</span>−max(<span style="font-style:italic">r</span>,<span style="font-style:italic">s</span>)
</li><li class="li-itemize">si <span style="font-style:italic">r</span>=<span style="font-style:italic">s</span> et les termes de plus haut degré du membre de gauche ne
se simplifient pas, alors, <span style="font-style:italic">n</span>=<span style="font-style:italic">t</span>−<span style="font-style:italic">r</span>=<span style="font-style:italic">t</span>−<span style="font-style:italic">s</span>.
</li><li class="li-itemize">si <span style="font-style:italic">r</span>=<span style="font-style:italic">s</span> et s’il y a simplification, alors :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub>(<span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub>′+<span style="font-style:italic">nN</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">z</span>′)+<span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub><span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub>=0 </td></tr>
</table>
donc :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub>′ + (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub></td></tr>
</table></td><td class="dcell">+<span style="font-style:italic">nz</span>′)<span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub> = 0</td></tr>
</table>
et :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub> = <span style="font-style:italic">C</span> exp(−<span style="font-style:italic">nz</span>−</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub></td></tr>
</table></td><td class="dcell">) </td></tr>
</table>
On appelle alors l’algorithme de Risch avec une variable de moins (<span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub>
et <span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub> ne dépendent plus de <span style="font-style:italic">Z</span>) pour calculer <span style="font-style:italic">I</span>=∫<span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub>/<span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub>. 
Il s’agit alors de trouver <span style="font-style:italic">n</span> tel que l’exponentielle précédente
soit élémentaire et indépendante de la variable <span style="font-style:italic">Z</span>. Le théorème
de structure de Risch implique que −<span style="font-style:italic">nz</span>−∫<span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub>/<span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub> est combinaison 
linéaire à coefficients rationnels des logarithmes et des arguments 
des exponentielles de autres variables de la tour (jusqu’à <span style="font-style:italic">z</span> non compris).
Ceci permet de déterminer <span style="font-style:italic">n</span> de manière unique (c’est le coefficient
rationnel de ∫<span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub>/<span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub> en <span style="font-style:italic">z</span>).
</li></ul><p><span style="font-weight:bold">Si </span><span style="font-style:italic">Z</span>=ln(<span style="font-style:italic">z</span>)<span style="font-weight:bold">: exponentielle de logarithme</span><br>
Ici aussi, les <span style="font-style:italic">N</span><sub><span style="font-style:italic">k</span></sub> peuvent ne pas être constants, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">N</span>′=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">N</span><sub><span style="font-style:italic">k</span></sub>′<span style="font-style:italic">Z</span><sup><span style="font-style:italic">k</span></sup>+<span style="font-style:italic">kN</span><sub><span style="font-style:italic">k</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">z</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">Z</span><sup><span style="font-style:italic">k</span>−1</sup>)</td></tr>
</table><p>
Si <span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub> n’est pas constant, le terme de plus haut degré de 
<span style="font-style:italic">RN</span>′ est <span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub>′ <span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub> <span style="font-style:italic">Z</span><sup><span style="font-style:italic">n</span>+<span style="font-style:italic">r</span></sup>, si <span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub> est constant, 
le terme de plus haut degré de <span style="font-style:italic">RN</span>′ est <span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub>(<span style="font-style:italic">nN</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">z</span>′/<span style="font-style:italic">z</span>+<span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span>−1</sub>′) <span style="font-style:italic">Z</span><sup><span style="font-style:italic">r</span>−1</sup> 
qui est non nul (sinon <span style="font-style:italic">z</span>′/<span style="font-style:italic">z</span>=<span style="font-style:italic">CN</span><sub><span style="font-style:italic">n</span>−1</sub>′ et <span style="font-style:italic">z</span>=exp(<span style="font-style:italic">CN</span><sub><span style="font-style:italic">n</span>−1</sub>) serait 
une exponentielle).
Le terme de plus haut degré de <span style="font-style:italic">SN</span> est <span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub> <span style="font-style:italic">Z</span><sup><span style="font-style:italic">n</span>+<span style="font-style:italic">s</span></sup>.
</p><ul class="itemize"><li class="li-itemize">
Si <span style="font-style:italic">r</span>&lt;<span style="font-style:italic">s</span> ou si <span style="font-style:italic">r</span>=<span style="font-style:italic">s</span> sans simplifications,
alors <span style="font-style:italic">n</span>=<span style="font-style:italic">t</span>−<span style="font-style:italic">s</span>.
</li><li class="li-itemize">Si <span style="font-style:italic">r</span>&gt;<span style="font-style:italic">s</span>+1 ou si <span style="font-style:italic">r</span>=<span style="font-style:italic">s</span>+1 sans simplifications,
alors deg(<span style="font-style:italic">N</span>′)=<span style="font-style:italic">t</span>−<span style="font-style:italic">r</span> donc <span style="font-style:italic">n</span>=<span style="font-style:italic">t</span>−<span style="font-style:italic">r</span> ou <span style="font-style:italic">n</span>=<span style="font-style:italic">t</span>−<span style="font-style:italic">r</span>+1.
</li><li class="li-itemize">Si <span style="font-style:italic">r</span>=<span style="font-style:italic">s</span>+1, et s’il y a simplifications, alors <span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub> est constant et :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub>(<span style="font-style:italic">nN</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">z</span>′/<span style="font-style:italic">z</span>+<span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span>−1</sub>′)+ <span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub> <span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub> = 0 </td></tr>
</table>
alors <span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span>−1</sub>=<span style="font-style:italic">C</span> (−∫<span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub>/<span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub> −<span style="font-style:italic">n</span> <span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub> ln(<span style="font-style:italic">z</span>))
doit être élémentaire et indépendante de <span style="font-style:italic">Z</span> donc ∫<span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub>/<span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub>
est élémentaire, on détermine <span style="font-style:italic">n</span> en éliminant le coefficient de 
<span style="font-style:italic">Z</span>=ln(<span style="font-style:italic">z</span>) provenant de ∫<span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub>/<span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub>.
</li><li class="li-itemize">Si <span style="font-style:italic">r</span>=<span style="font-style:italic">s</span>, et s’il y a simplification des termes 
de plus haut degré du membre de gauche, 
alors <span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub>′ <span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub>+<span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub>=0 donc <span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub>=exp(−∫<span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub>/<span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub>)
est élémentaire et indépendante de <span style="font-style:italic">Z</span>. On peut donc changer
d’inconnue <span style="font-style:italic">N</span>=<span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">M</span> sans changer le fait que <span style="font-style:italic">M</span> est un polynôme de
même degré que <span style="font-style:italic">N</span>. On se ramène alors à une équation du même type
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">RM</span>′+(<span style="font-style:italic">S</span>−<span style="font-style:italic">R</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">S</span><sub><span style="font-style:italic">s</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">R</span><sub><span style="font-style:italic">r</span></sub></td></tr>
</table></td><td class="dcell">)<span style="font-style:italic">M</span>= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td></tr>
</table>
mais avec <span style="font-style:italic">s</span> diminué de 1 au moins.
</li></ul><p><span style="font-weight:bold">Réduction (algorithme SPDE de Rothstein)</span><a id="hevea_default210"></a><br>
On observe d’abord que si <span style="font-style:italic">R</span> et <span style="font-style:italic">S</span> ont un facteur
en commun, alors ce facteur divise <span style="font-style:italic">T</span> car <span style="font-style:italic">N</span>′ et <span style="font-style:italic">N</span> sont des polynômes
en <span style="font-style:italic">Z</span>. On peut donc quitte à simplifier par gcd(<span style="font-style:italic">R</span>,<span style="font-style:italic">S</span>) se ramener
au cas où <span style="font-style:italic">R</span> et <span style="font-style:italic">S</span> sont premiers entre eux, il existe donc deux
polynômes <span style="font-style:italic">U</span> et <span style="font-style:italic">V</span> tels que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:rischdebezout"></a>
<span style="font-style:italic">RU</span>+<span style="font-style:italic">SV</span>=<span style="font-style:italic">T</span>,    deg(<span style="font-style:italic">V</span>)&lt; deg(<span style="font-style:italic">R</span>)
    (31)</td></tr>
</table><p>
En soustrayant (<a href="#eq%3Arischdebezout">31</a>) de (<a href="#eq%3Arischdepol">30</a>), 
on montre que <span style="font-style:italic">R</span> divise <span style="font-style:italic">N</span>−<span style="font-style:italic">V</span>. Soit <span style="font-style:italic">H</span>=(<span style="font-style:italic">N</span>−<span style="font-style:italic">V</span>)/<span style="font-style:italic">R</span>. Alors <span style="font-style:italic">N</span>=<span style="font-style:italic">RH</span>+<span style="font-style:italic">V</span> donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">R</span> (<span style="font-style:italic">RH</span>′+<span style="font-style:italic">R</span>′<span style="font-style:italic">H</span>+<span style="font-style:italic">V</span>′)+<span style="font-style:italic">SRH</span>+<span style="font-style:italic">SV</span>= <span style="font-style:italic">T</span>=<span style="font-style:italic">RU</span>+<span style="font-style:italic">SV</span></td></tr>
</table><p>
donc après simplification par <span style="font-style:italic">SV</span> et division par <span style="font-style:italic">R</span>, 
<span style="font-style:italic">H</span> vérifie l’équation :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">R</span> <span style="font-style:italic">H</span>′ + (<span style="font-style:italic">S</span>+<span style="font-style:italic">R</span>′) <span style="font-style:italic">H</span> = <span style="font-style:italic">U</span> − <span style="font-style:italic">V</span>′</td></tr>
</table><p>
C’est une équation du même type mais avec deg(<span style="font-style:italic">H</span>)=deg(<span style="font-style:italic">N</span>)-deg(<span style="font-style:italic">R</span>)
ou <span style="font-style:italic">H</span>=0 (si <span style="font-style:italic">N</span>=<span style="font-style:italic">V</span>).
Donc si deg(<span style="font-style:italic">R</span>)&gt;0, au bout d’un nombre fini d’étapes on doit 
tomber sur un second membre nul ou des simplifications de <span style="font-style:italic">R</span> avec <span style="font-style:italic">S</span>+<span style="font-style:italic">R</span>′
telles que <span style="font-style:italic">R</span> simplifié soit constant en <span style="font-style:italic">Z</span>.</p><p><span style="font-weight:bold">Résolution</span><br>
Si <span style="font-style:italic">R</span> est constant par rapport à <span style="font-style:italic">Z</span>, 
on simplifie par <span style="font-style:italic">R</span> et on doit résoudre 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">N</span>′+<span style="font-style:italic">SN</span>=<span style="font-style:italic">T</span> </td></tr>
</table><p>
Si <span style="font-style:italic">S</span>=0, c’est un problème d’intégration. Supposons donc que
<span style="font-style:italic">S</span>≠ 0. Si <span style="font-style:italic">S</span> est non constant par rapport à <span style="font-style:italic">Z</span> ou si
<span style="font-style:italic">Z</span>=<span style="font-style:italic">x</span>, le degré de <span style="font-style:italic">N</span>′ est strictement inférieur 
au degré de <span style="font-style:italic">SN</span>, on peut donc facilement résoudre.
Reste le cas où <span style="font-style:italic">S</span>=<span style="font-style:italic">b</span> est constant non nul par rapport à <span style="font-style:italic">Z</span> et <span style="font-style:italic">Z</span> est
une exponentielle ou un logarithme.</p><p><span style="font-weight:bold">Si </span><span style="font-style:italic">Z</span>=exp(<span style="font-style:italic">z</span>)<br>
On a alors doit alors résoudre 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">N</span><sub><span style="font-style:italic">k</span></sub>′+ <span style="font-style:italic">k</span> <span style="font-style:italic">N</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">z</span>′ + <span style="font-style:italic">b</span> <span style="font-style:italic">N</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">T</span><sub><span style="font-style:italic">k</span></sub> </td></tr>
</table><p>
c’est une équation différentielle de Risch mais avec une variable de 
moins.</p><p><span style="font-weight:bold">Si </span><span style="font-style:italic">Z</span>=ln(<span style="font-style:italic">z</span>)<br>
On doit alors résoudre 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">N</span><sub><span style="font-style:italic">k</span></sub>′+ (<span style="font-style:italic">k</span>+1) <span style="font-style:italic">N</span><sub><span style="font-style:italic">k</span>+1</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">z</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">z</span></td></tr>
</table></td><td class="dcell"> + <span style="font-style:italic">b</span> <span style="font-style:italic">N</span><sub><span style="font-style:italic">k</span></sub> =<span style="font-style:italic">T</span><sub><span style="font-style:italic">k</span></sub> </td></tr>
</table><p>
c’est aussi une équation différentielle de Risch avec une
variable de moins.</p><p><span style="font-weight:bold">Exemple</span><br>
Voyons comment on intègre <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup> avec <span style="font-style:italic">n</span> un paramètre par l’algorithme
de Risch (cela illustre les possibilités couvertes par l’algorithme
mais aussi l’efficacité des méthodes traditionnelles d’intégration
lorsqu’elles s’appliquent).
On écrit d’abord <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup>=<span style="font-style:italic">e</span><sup><span style="font-style:italic">n</span> ln(<span style="font-style:italic">x</span>)</sup>, donc la tour de variables
est { <span style="font-style:italic">x</span>, <span style="font-style:italic">Z</span>=ln(<span style="font-style:italic">x</span>), <span style="font-style:italic">X</span>=<span style="font-style:italic">e</span><sup><span style="font-style:italic">n</span> ln(<span style="font-style:italic">x</span>)</sup>}, il s’agit donc d’intégrer
<span style="font-style:italic">X</span> qui est un polynôme généralisé. On cherche donc <span style="font-style:italic">A</span><sub>1</sub> solution
de l’équation différentielle de Risch 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span><sub>1</sub>′+ <span style="font-style:italic">n</span> /<span style="font-style:italic">x</span> <span style="font-style:italic">A</span><sub>1</sub>=1 </td></tr>
</table><p>
Par rapport à <span style="font-style:italic">Z</span>=ln(<span style="font-style:italic">x</span>) la fonction <span style="font-style:italic">f</span>=<span style="font-style:italic">n</span>/<span style="font-style:italic">x</span> est un polynôme, donc on
applique le dernier cas ci-dessus, <span style="font-style:italic">A</span><sub>1</sub> est aussi indépendant de ln(<span style="font-style:italic">x</span>)
et on se ramène à résoudre la même équation mais avec comme variable
principale <span style="font-style:italic">x</span> et non <span style="font-style:italic">Z</span>. Cette fois, il y a un dénominateur <span style="font-style:italic">x</span> en <span style="font-style:italic">f</span>.
Si <span style="font-style:italic">A</span><sub>1</sub> possède un dénominateur, il faut qu’il y ait annulation
du terme de plus bas degré en <span style="font-style:italic">x</span> car le second membre n’a pas de
dénominateur, on obtient <span style="font-style:italic">n</span>+α=0 qui n’a pas de solution, donc
<span style="font-style:italic">A</span><sub>1</sub> est un polynôme en <span style="font-style:italic">x</span> et l’équation se réécrit en :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">xA</span><sub>1</sub>′+<span style="font-style:italic">nA</span><sub>1</sub>=<span style="font-style:italic">x</span></td></tr>
</table><p>
On majore alors le degré en <span style="font-style:italic">x</span> de <span style="font-style:italic">A</span><sub>1</sub> par 1, car il ne peut pas y avoir
d’annulation de terme de plus grand degré. Ensuite, on peut appliquer
l’algorithme SPDE de Rothstein pour réduire le degré, ou ici conclure
à la main, <span style="font-style:italic">x</span> divise <span style="font-style:italic">nA</span><sub>1</sub> donc <span style="font-style:italic">A</span><sub>1</sub>=<span style="font-style:italic">Cx</span> qu’on remplace et <span style="font-style:italic">C</span>=1/(<span style="font-style:italic">n</span>+1).
Finalement, <span style="font-style:italic">A</span><sub>1</sub>=<span style="font-style:italic">x</span>/(<span style="font-style:italic">n</span>+1) et ∫<span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup>=<span style="font-style:italic">x</span>/(<span style="font-style:italic">n</span>+1)  <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup>.</p>
<!--TOC subsection id="sec189" Quelques références-->
<h3 id="sec189" class="subsection">19.4  Quelques références</h3><!--SEC END --><p> <a id="sec:rischref"></a>
</p><ul class="itemize"><li class="li-itemize">
M. Bronstein:<br>
Symbolic Integration I, Transcendental functions, Springer</li><li class="li-itemize">M. Bronstein:<br>
Integration tutorial, <br>
<code>http://www-sop.inria.fr/cafe/Manuel.Bronstein/publications/mb_papers.html</code></li><li class="li-itemize">J.H. Davenport, Y. Siret, E. Tournier:<br>
Calcul formel: Systèmes et algorithmes 
de manipulations algébriques</li><li class="li-itemize">R. Risch: <br>
les références des articles originaux de Risch sont dans
le “Integration tutorial” de Bronstein.</li><li class="li-itemize">B. Trager:<br>
PHD thesis MIT, 1984</li><li class="li-itemize">On peut lire en clair le code source de l’implémentation en MuPAD
(sous Unix, désarchiver le fichier <span style="font-family:monospace">lib.tar</span> du répertoire
<span style="font-family:monospace">/usr/local/MuPAD/share/lib</span> et regarder dans le sous-répertoire
<span style="font-family:monospace">lib/INTLIB</span>)</li></ul>
<!--TOC section id="sec190" Intégration numérique-->
<h2 id="sec190" class="section">20  Intégration numérique</h2><!--SEC END --><p> <a id="sec:intnum"></a><a id="hevea_default211"></a> <a id="hevea_default212"></a>
Les fractions rationnelles admettent une primitive que l’on calcule
en décomposant la fraction avec Bézout comme expliqué précédemment.
Mais elles font figure d’exceptions,
la plupart des fonctions n’admettent pas de primitives qui s’expriment
à l’aide des fonctions usuelles. Pour calculer une intégrale, on
revient donc à la définition d’aire sous la courbe, aire que
l’on approche, en utilisant par exemple un polynome de Lagrange.</p><p>Le principe est donc le suivant : on découpe l’intervalle d’intégration
en subdivisions [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>]=[<span style="font-style:italic">a</span>,<span style="font-style:italic">a</span>+<span style="font-style:italic">h</span>] + [<span style="font-style:italic">a</span>+<span style="font-style:italic">h</span>,<span style="font-style:italic">a</span>+2<span style="font-style:italic">h</span>]+...[<span style="font-style:italic">a</span>+(<span style="font-style:italic">n</span>−1)<span style="font-style:italic">h</span>,<span style="font-style:italic">a</span>+<span style="font-style:italic">nh</span>=<span style="font-style:italic">b</span>, où
<span style="font-style:italic">h</span>=(<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>)/<span style="font-style:italic">n</span> est le pas de la subdivision, et
sur chaque subdivision, on approche l’aire sous la courbe.</p>
<!--TOC subsection id="sec191" Les rectangles et les trapèzes-->
<h3 id="sec191" class="subsection">20.1  Les rectangles et les trapèzes</h3><!--SEC END --><p>
Sur une subdivision [α,β], on approche la fonction par un segment.
Pour les rectangles, il s’agit d’une horizontale : on peut prendre 
<span style="font-style:italic">f</span>(α), <span style="font-style:italic">f</span>(β) (rectangle à droite et gauche)
ou <span style="font-style:italic">f</span>((α+β)/2) (point milieu), pour les trapèzes on utilise
le segment reliant [α,<span style="font-style:italic">f</span>(α)] à [β,<span style="font-style:italic">f</span>(β)].</p><p>Exemple : calcul de la valeur approchée de ∫<sub>0</sub><sup>1</sup> <span style="font-style:italic">t</span><sup>3</sup> <span style="font-style:italic">dt</span>
(on en connait la valeur exacte 1/4=0.25) par ces méthodes en subdivisant
[0,1] en 10 subdivisions (pas <span style="font-style:italic">h</span>=1/10), donc α=<span style="font-style:italic">j</span>/10 et β=(<span style="font-style:italic">j</span>+1)/10
pour <span style="font-style:italic">j</span> variant de 0 à 9.
Pour les rectangles à gauche, on obtient sur une subdivision
<span style="font-style:italic">f</span>(α)=(<span style="font-style:italic">j</span>/10)<sup>3</sup>  que l’on multiplie par la longueur de la subdivision 
soit <span style="font-style:italic">h</span>=1/10 :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">10</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">9</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">10</td></tr>
</table></td><td class="dcell">)<sup>3</sup>  = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">81</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">400</td></tr>
</table></td><td class="dcell"> = 0.2025</td></tr>
</table><p>
Pour les rectangles à droite, on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">10</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">10</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">10</td></tr>
</table></td><td class="dcell">)<sup>3</sup>  = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">121</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">400</td></tr>
</table></td><td class="dcell"> = 0.3025</td></tr>
</table><p>
Pour le point milieu <span style="font-style:italic">f</span>((α+β)/2)=<span style="font-style:italic">f</span>((<span style="font-style:italic">j</span>/10+(<span style="font-style:italic">j</span>+1)/10)/2)=<span style="font-style:italic">f</span>(<span style="font-style:italic">j</span>/10+1/20)
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">10</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">9</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">10</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">20</td></tr>
</table></td><td class="dcell">)<sup>3</sup>  = 199/800 = 0.24875</td></tr>
</table><p>
Enfin pour les trapèzes, l’aire du trapèze délimité par l’axe des <span style="font-style:italic">x</span>,
les verticales <span style="font-style:italic">y</span>=α, <span style="font-style:italic">y</span>=β et les points sur ces verticales
d’ordonnées respectives <span style="font-style:italic">f</span>(α) et <span style="font-style:italic">f</span>(β) vaut
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">h</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(α)+<span style="font-style:italic">f</span>(β)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">10</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">9</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">10</td></tr>
</table></td><td class="dcell">)<sup>3</sup> +(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>+1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">10</td></tr>
</table></td><td class="dcell">)<sup>3</sup>
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">= 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">101</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">400</td></tr>
</table></td><td class="dcell"> = 0.2525 </td></tr>
</table><p>
Dans la somme des trapèzes, on voit que chaque terme apparait deux fois
sauf le premier et le dernier.</p><p>Plus généralement, les formules sont donc les suivantes :
<a id="hevea_default213"></a> <a id="hevea_default214"></a> <a id="hevea_default215"></a>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">


     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >rectangle gauche</td><td style="text-align:center;white-space:nowrap" > =</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> <span style="font-style:italic">h</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">a</span>+<span style="font-style:italic">jh</span>) <a id="eq:rectangle_gauche"> </a></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >    (32)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >rectangle droit</td><td style="text-align:center;white-space:nowrap" > =</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> <span style="font-style:italic">h</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">a</span>+<span style="font-style:italic">jh</span>) <a id="eq:rectangle_droit"> </a></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >    (33)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >point milieu</td><td style="text-align:center;white-space:nowrap" > =</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> <span style="font-style:italic">h</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">a</span>+<span style="font-style:italic">jh</span>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">) 
<a id="eq:point_milieu"> </a></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >    (34)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" > trapezes </td><td style="text-align:center;white-space:nowrap" > =</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> 
<span style="font-style:italic">h</span> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(<span style="font-style:italic">a</span>)+<span style="font-style:italic">f</span>(<span style="font-style:italic">b</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">a</span>+<span style="font-style:italic">jh</span>) </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
<a id="eq:trapezes"> </a>
</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >    (35)</td></tr>
</table></td></tr>
</table><p>
où <span style="font-style:italic">h</span>=(<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>)/<span style="font-style:italic">n</span> est le pas de la subdivision, <span style="font-style:italic">n</span> le nombre de subdivisions.<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">f(x):=ln(1+x^2); a:=0; b:=1.0; n:=100.0; h:=(b-a)/n;int(f(x),x,a,b) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">h*sum(f(a+j*h),j,0,n-1); h*sum(f(a+j*h),j,1,n); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">h*sum(f(a+h/2+j*h),j,0,n-1); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">h*(f(a)/2+f(b)/2+sum(f(a+j*h),j,1,n-1)); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>

On observe sur l’exemple que le point milieu et les trapèzes donnent
une bien meilleure précision que les rectangles. Plus généralement,
la précision de l’approximation n’est pas la même selon le choix
de méthode.
Ainsi pour les rectangles à gauche (le résultat est le même
à droite), si <span style="font-style:italic">f</span> est continument dérivable, de dérivée majorée
par une constante <span style="font-style:italic">M</span><sub>1</sub> sur [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>], en faisant un
développement de Taylor de <span style="font-style:italic">f</span> en α, on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>) <span style="font-style:italic">dt</span> − </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(α) <span style="font-style:italic">dt</span> |
= | </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>′(θ<sub><span style="font-style:italic">t</span></sub>)(<span style="font-style:italic">t</span>−α) <span style="font-style:italic">dt</span> |
≤ <span style="font-style:italic">M</span><sub>1</sub> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">t</span>−α) <span style="font-style:italic">dt</span> = <span style="font-style:italic">M</span><sub>1</sub></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(β−α)<sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
</table><p>
Ainsi dans l’exemple, on a <span style="font-style:italic">M</span><sub>1</sub>=3, l’erreur est donc majorée par 0.015
sur une subdivision, donc par 0.15 sur les 10 subdivisions.</p><p>Pour le point milieu, on fait le développement en (α+β)/2 à l’ordre
2, en supposant que <span style="font-style:italic">f</span> est deux fois continument dérivable :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> |</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>)  − </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">α+β</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)  |</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">| </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>′(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">α+β</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)(<span style="font-style:italic">t</span>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">α+β</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">) <span style="font-style:italic">dt</span>
</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">+  </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′′(θ<sub><span style="font-style:italic">t</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">t</span>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">α+β</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)<sup>2</sup> |
</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span><sub>2</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> 2 </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">α+β</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
</table></td><td class="dcell">
(<span style="font-style:italic">t</span>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">α+β</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)<sup>2</sup> <span style="font-style:italic">dt</span>  </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">M</span><sub>2</sub></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(β−α)<sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">24</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Dans l’exemple, on a <span style="font-style:italic">M</span><sub>2</sub>=6, donc l’erreur sur une subdivision est
majorée par 0.25<span style="font-style:italic">e</span>−3, donc sur 10 subdivisions par 0.25<span style="font-style:italic">e</span>−2=0.0025.</p><p>Pour les trapèzes, la fonction <span style="font-style:italic">g</span> dont le graphe est le segment reliant
[α,<span style="font-style:italic">f</span>(α)] à [β,<span style="font-style:italic">f</span>(β)] est <span style="font-style:italic">f</span>(α)+(<span style="font-style:italic">t</span>−α)/(β−α)<span style="font-style:italic">f</span>(β),
c’est en fait un polynome de Lagrange, si <span style="font-style:italic">f</span> est deux fois continument
dérivable, on peut donc majorer la différence
entre <span style="font-style:italic">f</span> et <span style="font-style:italic">g</span> en utilisant (<a href="#eq%3Alagrange">56</a>), on intègre la valeur
absolue ce qui donne
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>) <span style="font-style:italic">dt</span> − </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">g</span>(<span style="font-style:italic">t</span>) <span style="font-style:italic">dt</span> |
≤ </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> |</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′′(ξ<sub><span style="font-style:italic">x</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">x</span>−α)(<span style="font-style:italic">x</span>−β)|
≤ <span style="font-style:italic">M</span><sub>2</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(β−α)<sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">12</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
où <span style="font-style:italic">M</span><sub>2</sub> est un majorant de |<span style="font-style:italic">f</span>′′| sur [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>].</p><p>Lorsqu’on calcule l’intégrale sur [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>] par une de ces méthodes,
on fait la somme sur <span style="font-style:italic">n</span>=(<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>)/<span style="font-style:italic">h</span> subdivisions de longueur 
β−α=<span style="font-style:italic">h</span>, on obtient
donc une majoration de l’erreur commise sur l’intégrale :
</p><ul class="itemize"><li class="li-itemize">
pour les rectangles à droite ou gauche <span style="font-style:italic">nM</span><sub>1</sub><span style="font-style:italic">h</span><sup>2</sup>/2=<span style="font-style:italic">M</span><sub>1</sub> <span style="font-style:italic">h</span> (<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>)/2
</li><li class="li-itemize">pour le point milieu <span style="font-style:italic">M</span><sub>2</sub> <span style="font-style:italic">h</span><sup>2</sup> (<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>)/24
</li><li class="li-itemize">pour les trapèzes <span style="font-style:italic">M</span><sub>2</sub><span style="font-style:italic">h</span><sup>2</sup> (<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>)/12.
</li></ul><p>
Lorsque <span style="font-style:italic">h</span> tend vers 0, l’erreur tend vers 0, mais pas à la même vitesse,
plus rapidement pour les trapèzes et le point milieu
que pour les rectangles. Plus on
approche précisément la fonction sur une subdivision, plus la
puissance de <span style="font-style:italic">h</span> va être grande, plus la convergence sera rapide
lorsque <span style="font-style:italic">h</span> sera petit, avec toutefois une contrainte fixée par la
valeur de <span style="font-style:italic">M</span><sub><span style="font-style:italic">k</span></sub>, borne sur la dérivée <span style="font-style:italic">k</span>-ième de <span style="font-style:italic">f</span> (plus
<span style="font-style:italic">k</span> est grand, plus <span style="font-style:italic">M</span><sub><span style="font-style:italic">k</span></sub> est grand en général). Nous allons voir dans la suite
comment se comporte cette puissance de <span style="font-style:italic">h</span> en fonction de la facon
dont on approche <span style="font-style:italic">f</span>.</p>
<!--TOC subsection id="sec192" Ordre d’une méthode-->
<h3 id="sec192" class="subsection">20.2  Ordre d’une méthode</h3><!--SEC END --><p> <a id="hevea_default216"></a>
On appelle méthode d’intégration l’écriture d’une approximation
de l’intégrale sur une subdivision sous la forme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>) <span style="font-style:italic">dt</span> ≈ <span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">w</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>) </td></tr>
</table><p>
où les <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> sont dans l’intervalle [α,β], par exemple équirépartis
sur [α,β]. On utilise aussi la définition :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>) <span style="font-style:italic">dt</span> ≈ <span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>)=
(β−α)</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> w<sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>) </td></tr>
</table><p>
On prend toujours ∑<sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">w</span><sub><span style="font-style:italic">j</span></sub>=β−α (ou ∑<sub><span style="font-style:italic">j</span></sub> w<sub><span style="font-style:italic">j</span></sub>=1) pour
que la méthode donne le résultat exact si la fonction est constante.</p><p>On dit qu’une méthode d’intégration est d’ordre <span style="font-style:italic">n</span> si il y a égalité
ci-dessus pour tous les polynômes de degré inférieur ou égal à <span style="font-style:italic">n</span>
et non égalité pour un polynôme de degré <span style="font-style:italic">n</span>+1.
Par exemple, les rectangles à droite et gauche sont d’ordre 0, 
le point milieu et les trapèzes sont d’ordre 1. Plus
généralement, si on approche <span style="font-style:italic">f</span> par son polynôme
d’interpolation de Lagrange en <span style="font-style:italic">n</span>+1 points (donc par un polynôme
de degré inférieur ou égal à <span style="font-style:italic">n</span>), on obtient une méthode
d’intégration d’ordre au moins <span style="font-style:italic">n</span>.</p><p>Si une méthode est d’ordre <span style="font-style:italic">n</span> avec des <span style="font-style:italic">w</span><sub><span style="font-style:italic">j</span></sub>≥ 0 et 
si <span style="font-style:italic">f</span> est <span style="font-style:italic">n</span>+1 fois continument dérivable,
alors sur une subdivision, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:majoration_err"></a>
|</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>−<span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>)| ≤ <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span>+1</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(β−α)<sup><span style="font-style:italic">n</span>+2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td><td class="dcell">
(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>+2</td></tr>
</table></td><td class="dcell">+1)
    (36)</td></tr>
</table><p>En effet, on fait le développement de Taylor de <span style="font-style:italic">f</span> par exemple
en α à l’ordre <span style="font-style:italic">n</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>)+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">t</span>−α)<sup><span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(θ<sub><span style="font-style:italic">t</span></sub>),</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(α)+(<span style="font-style:italic">t</span>−α)<span style="font-style:italic">f</span>′(α)+...+ 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">t</span>−α)<sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>]</sup>(α)
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Donc 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>− </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>)|
≤ </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">t</span>−α)<sup><span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td><td class="dcell"> |<span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(θ<sub><span style="font-style:italic">t</span></sub>)| 
≤ </td><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell"><span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span>+1</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">t</span>−α)<sup><span style="font-style:italic">n</span>+2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+2)!</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td></tr>
</table><p>
De plus, 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> |<span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>) −<span style="font-style:italic">I</span>(<span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>))| =|<span style="font-style:italic">I</span></td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(θ<sub><span style="font-style:italic">t</span></sub>)
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">t</span>−α)<sup><span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">|</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> |<span style="font-style:italic">w</span><sub><span style="font-style:italic">j</span></sub>| <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span>+1</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>−α)<sup><span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td><td class="dcell"> 
</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> |<span style="font-style:italic">w</span><sub><span style="font-style:italic">j</span></sub>| <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span>+1</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(β−α)<sup><span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Donc comme la méthode est exacte pour <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>), on en déduit que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>−<span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>)|</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>−</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>)+<span style="font-style:italic">I</span>(<span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>))− <span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>)| </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>−</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>)|+|<span style="font-style:italic">I</span>(<span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>))− <span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>)|</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span>+1</sub>  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(β−α)<sup><span style="font-style:italic">n</span>+2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+2)!</td></tr>
</table></td><td class="dcell"> +  
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> |<span style="font-style:italic">w</span><sub><span style="font-style:italic">j</span></sub>| <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span>+1</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(β−α)<sup><span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td><td class="dcell"> 
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Si les <span style="font-style:italic">w</span><sub><span style="font-style:italic">j</span></sub>≥ 0, alors ∑<sub><span style="font-style:italic">j</span>=1</sub><sup><span style="font-style:italic">k</span></sup> |<span style="font-style:italic">w</span><sub><span style="font-style:italic">j</span></sub>|=∑<sub><span style="font-style:italic">j</span>=1</sub><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">w</span><sub><span style="font-style:italic">j</span></sub>=β−α
et on obtient finalement (<a href="#eq%3Amajoration_err">36</a>)</p><p>On remarque qu’on peut améliorer la valeur de la constante 
en faisant tous les développement de Taylor
en (α+β)/2 au lieu de α, 
Après sommation sur les <span style="font-style:italic">n</span> subdivisions, on obtient que :
</p><div class="theorem"><span style="font-weight:bold">Théorème 36</span>  <em>
Pour une méthode d’ordre </em><span style="font-style:italic">n</span><em> à coefficients positifs et une fonction </em><span style="font-style:italic">f</span><em>
</em><span style="font-style:italic">n</span>+1<em> fois continument dérivable 
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">b</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>−<span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>)| ≤ <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span>+1</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span><sup><span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup><span style="font-style:italic">n</span>+1</sup>(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td><td class="dcell">  (<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>) 
(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+2)</td></tr>
</table></td><td class="dcell">+1)</td></tr>
</table><em>
</em></div><p>On observe que cette majoration a la bonne puissance de <span style="font-style:italic">h</span> sur
les exemples déja traités, mais pas forcément le meilleur coefficient
possible, parce que nous avons traité le cas général d’une
méthode d’ordre <span style="font-style:italic">n</span>, et utilisé une majoration pas toujours
optimale du reste. Pour obtenir la meilleure valeur possible de la
constante, il faut exprimer le reste de la formule de Taylor sous
forme intégrale et utiliser la forme précise de la méthode :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>)(<span style="font-style:italic">t</span>)+</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">t</span>−<span style="font-style:italic">x</span>)<sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(<span style="font-style:italic">x</span>) 
<span style="font-style:italic">dx</span> </td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>− </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>)
= </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">t</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">t</span>−<span style="font-style:italic">x</span>)<sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell"> 
<span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">dx</span>  <span style="font-style:italic">dt</span>
= </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">t</span>−<span style="font-style:italic">x</span>)<sub>+</sub><sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell"> 
<span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">dx</span>  <span style="font-style:italic">dt</span>
</td></tr>
</table><p>
où (<span style="font-style:italic">t</span>−<span style="font-style:italic">x</span>)<sub>+</sub>=max(0,<span style="font-style:italic">t</span>−<span style="font-style:italic">x</span>). En intervertissant les deux intégrales
(Fubini), on obtient :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>− </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>)</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">t</span>−<span style="font-style:italic">x</span>)<sub>+</sub><sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell"> 
 <span style="font-style:italic">dt</span> <span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">dx</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">t</span>−<span style="font-style:italic">x</span>)<sub>+</sub><sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> 
<span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">dx</span></td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(β−<span style="font-style:italic">x</span>)<sup><span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">dx</span>
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
D’autre part :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>)−<span style="font-style:italic">I</span>(<span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>))</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span></td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">x</span>−<span style="font-style:italic">t</span>)<sub>+</sub><sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> 
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">w</span><sub><span style="font-style:italic">j</span></sub> 
</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>−<span style="font-style:italic">t</span>)<sub>+</sub><sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> 
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>−<span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>)
= </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> 
( </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(β−<span style="font-style:italic">x</span>)<sup><span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td><td class="dcell"> −  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">w</span><sub><span style="font-style:italic">j</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>−<span style="font-style:italic">x</span>)<sub>+</sub><sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell">)
<span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">dx</span>
</td></tr>
</table><p>
On appelle noyau de <span style="font-weight:bold">Péano</span><a id="hevea_default217"></a> l’expression
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">N</span>(<span style="font-style:italic">x</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(β−<span style="font-style:italic">x</span>)<sup><span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td><td class="dcell"> −  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">w</span><sub><span style="font-style:italic">j</span></sub>
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>−<span style="font-style:italic">x</span>)<sub>+</sub><sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td></tr>
</table><p>
On a alors :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>−<span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>)|
≤ </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> |<span style="font-style:italic">N</span>(<span style="font-style:italic">x</span>)| |<span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(<span style="font-style:italic">x</span>)|  <span style="font-style:italic">dx</span>
≤ <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span>+1</sub> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"> |<span style="font-style:italic">N</span>(<span style="font-style:italic">x</span>)|  <span style="font-style:italic">dx</span></td></tr>
</table>
<!--TOC subsection id="sec193" Simpson-->
<h3 id="sec193" class="subsection">20.3  Simpson</h3><!--SEC END --><p> <a id="hevea_default218"></a>
Il s’agit de la méthode obtenue en approchant la fonction
sur la subdivision [α,β] par son polynome de Lagrange
aux points α,(α+β)/2,β. On calcule l’intégrale
par exemple avec un logiciel de calcul formel, avec Xcas :
</p><div class="center">
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">factor(int(lagrange([a,(a+b)/2,b],[fa,fm,fb]),x=a..b)) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</div><p>
qui donne la formule sur une subdivision
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>) = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">f</span>(α)+4<span style="font-style:italic">f</span>(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">α+β</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">) + <span style="font-style:italic">f</span>(β)) </td></tr>
</table><p>
et sur [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>] :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:simpson"></a>
<span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>) = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">a</span>)+<span style="font-style:italic">f</span>(<span style="font-style:italic">b</span>)+ 4 </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">a</span>+<span style="font-style:italic">jh</span>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)
+ 2  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">a</span>+<span style="font-style:italic">jh</span>) </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
    (37)</td></tr>
</table><p>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">f(x):=ln(1+x^2); a:=0; b:=1.0; n:=100.0; h:=(b-a)/n; int(f(x),x,a,b) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">h/6*(f(a)+f(b)+4*sum(f(a+j*h+h/2),j,0,n-1)+2*sum(f(a+j*h),j,1,n-1)) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
Si on intègre <span style="font-style:italic">t</span><sup>3</sup> sur [0,1] en 1 subdivision par cette méthode,
on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> (0+ 4 </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup>3</sup></td></tr>
</table></td><td class="dcell"> + 1)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
c’est-à-dire le résultat exact, ceci est aussi vérifié pour <span style="font-style:italic">f</span> polynome
de degré inférieur ou égal à 2 puisque l’approximation de Lagrange
de <span style="font-style:italic">f</span> est alors égale à <span style="font-style:italic">f</span>. On en déduit que la méthode de Simpson
est d’ordre 3 (pas plus car la méthode
de Simpson appliquée à l’intégrale de
<span style="font-style:italic">t</span><sup>4</sup> sur [0,1] n’est pas exacte). On peut améliorer
la constante générale de la section précédente pour la majoration
de l’erreur en :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">b</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span> − <span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>)| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span><sup>4</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2880</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>) <span style="font-style:italic">M</span><sub>4</sub> </td></tr>
</table><p>
En effet sur une subdivision élémentaire [α,β], 
le noyau de Péano vaut :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">N</span>(<span style="font-style:italic">x</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(β−<span style="font-style:italic">x</span>)<sup>4</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4!</td></tr>
</table></td><td class="dcell"> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(β−<span style="font-style:italic">x</span>)<sub>+</sub><sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3!</td></tr>
</table></td><td class="dcell">
−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">α+β</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">−<span style="font-style:italic">x</span>)<sub>+</sub><sup>3</sup></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3!</td></tr>
</table></td><td class="dcell"> − 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(α−<span style="font-style:italic">x</span>)<sub>+</sub><sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3!</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(β−<span style="font-style:italic">x</span>)<sup>4</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4!</td></tr>
</table></td><td class="dcell"> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(β−<span style="font-style:italic">x</span>)<sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3!</td></tr>
</table></td><td class="dcell">
−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">α+β</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">−<span style="font-style:italic">x</span>)<sub>+</sub><sup>3</sup></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3!</td></tr>
</table></td><td class="dcell"> 
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
on observe que <span style="font-style:italic">N</span>(<span style="font-style:italic">x</span>)≤ 0 sur [α,β] <br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">N(x):=(1-x)^4/4!-1/6*(1-x)^3/3!-2/3/3!*max(0,1/2-x)^3 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p><p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plot(1000*N(x),x=0..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

et son intégrale vaut −1/2880(β−α)<sup>4</sup> :<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">int(N(x),x=0..1/2)+int(N(x),x=1/2..1) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p><p>La méthode de Simpson nécessite 2<span style="font-style:italic">n</span>+1 évaluations de <span style="font-style:italic">f</span> (le calcul
de <span style="font-style:italic">f</span> est un point étant presque toujours 
l’opération la plus couteuse en temps d’une
méthode de quadrature), au lieu de <span style="font-style:italic">n</span> pour les rectangles
et le point milieu et <span style="font-style:italic">n</span>+1 pour les trapèzes. Mais on a une majoration
en <span style="font-style:italic">h</span><sup>4</sup> au lieu de <span style="font-style:italic">h</span><sup>2</sup> donc le “rapport qualité-prix” de la méthode
de Simpson est meilleur, on l’utilise donc plutot que les
méthodes précédentes sauf si <span style="font-style:italic">f</span> n’a pas la régularité
suffisante (ou si <span style="font-style:italic">M</span><sub>4</sub> est trop grand).</p>
<!--TOC subsection id="sec194" Newton-Cotes-->
<h3 id="sec194" class="subsection">20.4  Newton-Cotes</h3><!--SEC END --><p> <a id="hevea_default219"></a>
On peut généraliser l’idée précédente, découper la subdivision 
[α,β] en <span style="font-style:italic">n</span> parts égales et utiliser le polynôme d’interpolation
en ces <span style="font-style:italic">n</span>+1 points <span style="font-style:italic">x</span><sub>0</sub>=α, <span style="font-style:italic">x</span><sub>1</sub>, ..., <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>=β. 
Ce sont les méthodes de Newton-Cotes,
qui sont d’ordre <span style="font-style:italic">n</span> au moins. Comme le polynôme d’interpolation
dépend linéairement des ordonnées, cette méthode est bien
de la forme :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>)=(β−α)</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> w<sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>)</td></tr>
</table><p>
De plus les w<sub><span style="font-style:italic">j</span></sub> sont universels (ils ne dépendent pas de 
la subdivision), parce qu’on peut faire 
le changement de variables <span style="font-style:italic">x</span>=α+<span style="font-style:italic">t</span>(β−α) dans l’intégrale
et le polynôme d’interpolation et donc se ramener à [0,1].</p><p>Exemple : on prend le polynôme d’interpolation en 5 points 
équidistribués sur une subdivision [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>] (méthode de Boole). 
Pour calculer les
w<sub><span style="font-style:italic">j</span></sub>, on se ramène à [0,1], puis on tape
</p><div class="center">
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">int(lagrange(seq(j/4,j,0,4),[f0,f1,f2,f3,f4]),x=0..1) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</div><p>
et on lit les coefficients de <code>f0</code> à <code>f4</code>
qui sont les w<sub>0</sub> à w<sub>4</sub>: 7/90, 32/90, 12/90,
32/90, 7/90. Voir aussi la section <a href="#sec%3Apoids">20.5</a>
La méthode est d’ordre au moins 4 par construction, mais on vérifie
qu’elle est en fait d’ordre 5 (exercice), la majoration de l’erreur
d’une méthode d’ordre 5 est 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">b</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span> −<span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>)| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span><sub>6</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup>6</sup> 6!</td></tr>
</table></td><td class="dcell">(1+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">7</td></tr>
</table></td><td class="dcell">) <span style="font-style:italic">h</span><sup>6</sup> (<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>) </td></tr>
</table><p>
elle peut être améliorée pour cette méthode précise en
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">b</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span> −<span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>)| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span><sub>6</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1935360</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">h</span><sup>6</sup> (<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>) </td></tr>
</table><p>En pratique, on ne les utilise pas très souvent, car d’une part
pour <span style="font-style:italic">n</span>≥ 8, les <span style="font-style:italic">w</span><sub><span style="font-style:italic">j</span></sub> ne sont pas tous positifs, et
d’autre part, parce que la constante <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span></sub> devient trop
grande. On préfère utiliser la méthode de Simpson en utilisant
un pas plus petit.</p><p>Il existe aussi d’autres méthodes, par exemple les quadratures de Gauss
(on choisit d’interpoler en utilisant des points non équirépartis 
tels que l’ordre de la méthode soit le plus grand possible, cf. infra)
ou la méthode de Romberg qui est une méthode d’accélération
de convergence basée sur la méthode des trapèzes (on prend
la méthode des trapèzes en 1 subdivision de [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>], puis
2, puis 2<sup>2</sup>, ..., et on élimine les puissances de <span style="font-style:italic">h</span>
du reste ∫<span style="font-style:italic">f</span>−<span style="font-style:italic">I</span>(<span style="font-style:italic">f</span>) en utilisant un théorème d’Euler-Mac Laurin
qui montre que le développement asymptotique de
l’erreur en fonction de <span style="font-style:italic">h</span> ne contient que des puissances paires
de <span style="font-style:italic">h</span>). De plus, on peut être amené à faire varier le pas <span style="font-style:italic">h</span>
en fonction de la plus ou moins grande régularité de la fonction.</p>
<!--TOC subsection id="sec195" Calcul des poids <span style="font-style:italic">w</span><sub><span style="font-style:italic">i</span></sub>-->
<h3 id="sec195" class="subsection">20.5  Calcul des poids <span style="font-style:italic">w</span><sub><span style="font-style:italic">i</span></sub></h3><!--SEC END --><p> <a id="sec:poids"></a>
Si la méthode d’intégration consiste à interpoler 
<span style="font-style:italic">f</span> en <span style="font-style:italic">n</span> points <span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>, alors la méthode est exacte pour
tout polynôme de degré <span style="font-style:italic">n</span>. Si on prend 
<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>(<span style="font-style:italic">x</span>)=∏<sub><span style="font-style:italic">k</span> ≠ <span style="font-style:italic">j</span></sub>(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>), on en déduit :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">dx</span> = <span style="font-style:italic">w</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>) </td></tr>
</table><p> 
Par exemple en interpolant en 0,1/2,1 sur [0,1], on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">w</span><sub>0</sub> <span style="font-style:italic">P</span><sub>0</sub>(0)=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">P</span><sub>0</sub>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">dx</span>,    <span style="font-style:italic">P</span><sub>0</sub>(<span style="font-style:italic">x</span>)=(<span style="font-style:italic">x</span>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)(<span style="font-style:italic">x</span>−1)</td></tr>
</table><p>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">P0:=(x-1)*(x-1/2); int(P0,x,0,1)/P0(x=0); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
On peut aussi résoudre un système linéaire en prenant pour <span style="font-style:italic">f</span>
les polynômes de la base canonique, la matrice du système est
la transposée de la matrice de Vandermonde en les <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> et le second
membre a pour <span style="font-style:italic">j</span>-ième composante ∫<sub>α</sub><sup>β</sup><span style="font-style:italic">x</span><sup><span style="font-style:italic">j</span></sup>  <span style="font-style:italic">dx</span>.
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">inv(tran(vandermonde(0,1/2,1)))*[1,1/2,1/3] 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p>
<!--TOC subsection id="sec196" En résumé-->
<h3 id="sec196" class="subsection">20.6  En résumé</h3><!--SEC END --><p>
Intégration sur [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>], <span style="font-style:italic">h</span> pas d’une subdivision, <span style="font-style:italic">M</span><sub><span style="font-style:italic">k</span></sub> majorant
de la dérivée <span style="font-style:italic">k</span>-ième de la fonction sur [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>]<br>
</p><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >formule</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >Lagrange degré</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >ordre</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >erreur </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >rectangles</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(<a href="#eq%3Arectangle_gauche">32</a>), (<a href="#eq%3Arectangle_droit">33</a>)</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0</td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-style:italic">M</span><sub>1</sub> <span style="font-style:italic">h</span> (<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>)/2 </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >point milieu</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(<a href="#eq%3Apoint_milieu">34</a>)</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-style:italic">M</span><sub>2</sub> <span style="font-style:italic">h</span><sup>2</sup> (<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>)/24 </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >trapèzes</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(<a href="#eq%3Atrapezes">35</a>)</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-style:italic">M</span><sub>2</sub> <span style="font-style:italic">h</span><sup>2</sup> (<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>)/12 </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >Simpson</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(<a href="#eq%3Asimpson">37</a>)</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >3</td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-style:italic">M</span><sub>4</sub> <span style="font-style:italic">h</span><sup>4</sup> (<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>)/2880 </td></tr>
</table>
<!--TOC subsection id="sec197" Accélération de Richardson-Romberg-->
<h3 id="sec197" class="subsection">20.7  Accélération de Richardson-Romberg</h3><!--SEC END --><p>
<a id="hevea_default220"></a><a id="hevea_default221"></a>
</p><div class="theorem"><span style="font-weight:bold">Proposition 37</span>  <em>
Soit </em><span style="font-style:italic">g</span><em> une fonction de classe </em><span style="font-style:italic">C</span><sup>2<span style="font-style:italic">k</span></sup><em> sur </em>[<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>]<em>, 
</em><span style="font-style:italic">T</span><sub><span style="font-style:italic">h</span></sub>(<span style="font-style:italic">g</span>)<em> la valeur de la méthode des trapèzes sur </em>[<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>]<em> de pas 
</em><span style="font-style:italic">h</span>=(<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>)/<span style="font-style:italic">N</span><em> (</em><span style="font-style:italic">N</span><em> entier).
Alors </em><span style="font-style:italic">T</span><sub><span style="font-style:italic">h</span></sub>(<span style="font-style:italic">g</span>)<em> admet un développement en puissances paires de </em><span style="font-style:italic">h</span><em>
à l’ordre </em>2<span style="font-style:italic">k</span><em>.
</em></div><p>Pour montrer ce résultat, il faut établir la formule d’Euler-Mac
Laurin. On commence par se placer sur une subdivision de l’intervalle
[0,1], on intègre par parties ∫<sub>0</sub><sup>1</sup> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>) <span style="font-style:italic">dt</span> en faisant apparaitre
la formule des trapèzes, on intègre donc 1 en <span style="font-style:italic">t</span>−1/2
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> = 
[(<span style="font-style:italic">t</span>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)<span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>)]<sub>0</sub><sup>1</sup> − </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">t</span>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)<span style="font-style:italic">f</span>′(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> =
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(0)+<span style="font-style:italic">f</span>(1)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> − </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">t</span>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)<span style="font-style:italic">f</span>′(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span>
</td></tr>
</table><p>
où encore
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">T</span><sub>1</sub>(<span style="font-style:italic">f</span>)=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> 
+  </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">t</span>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)<span style="font-style:italic">f</span>′(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> </td></tr>
</table><p>
Pour poursuivre, on pose <span style="font-style:italic">B</span><sub>1</sub>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">t</span>−1/2, qu’on va intégrer
en 1/2((<span style="font-style:italic">t</span>−1/2)<sup>2</sup>+<span style="font-style:italic">c</span>), où on choisit <span style="font-style:italic">c</span> pour que l’intégrale
soit nulle, donc <span style="font-style:italic">c</span>=−1/6. On pose <span style="font-style:italic">B</span><sub>2</sub>=(<span style="font-style:italic">t</span>−1/2)<sup>2</sup>−1/6, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">T</span><sub>1</sub>(<span style="font-style:italic">f</span>)=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> 
+ [</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub>2</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>′]<sub>0</sub><sup>1</sup> − </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub>2</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">f</span>′′(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> 
</td></tr>
</table><p>
Plus
généralement, on pose
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">B</span><sub><span style="font-style:italic">p</span>+1</sub>′=<span style="font-style:italic">pB</span><sub><span style="font-style:italic">p</span></sub>,    </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">B</span><sub><span style="font-style:italic">p</span>+1</sub>(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span>=0 </td></tr>
</table><p>
ce qui définit de manière unique les <span style="font-style:italic">B</span><sub><span style="font-style:italic">p</span></sub>. La nullité de l’intégrale
montre que <span style="font-style:italic">B</span><sub><span style="font-style:italic">p</span>+1</sub>(1)=<span style="font-style:italic">B</span><sub><span style="font-style:italic">p</span>+1</sub>(0) ce qui simplifiera l’expression des
termes tout intégrés. De plus, on montre par récurrence
que les <span style="font-style:italic">B</span><sub><span style="font-style:italic">p</span></sub> ont une symétrie paire
ou impaire selon la parité de <span style="font-style:italic">p</span> par rapport à <span style="font-style:italic">t</span>=1/2.
Après <span style="font-style:italic">p</span> intégrations par parties, on obtient :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >  <span style="font-style:italic">T</span><sub>1</sub>(<span style="font-style:italic">f</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> 
+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub>2</sub>(0)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">f</span>′(1)−<span style="font-style:italic">f</span>′(0)) 
+ ... </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub>2<span style="font-style:italic">k</span></sub>(0)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">k</span>)!</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">f</span><sup>[2<span style="font-style:italic">k</span>−1]</sup>(1)−<span style="font-style:italic">f</span><sup>[2<span style="font-style:italic">k</span>−1]</sup>(0)) 
− </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub>2<span style="font-style:italic">k</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">k</span>)!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span><sup>[2<span style="font-style:italic">k</span>]</sup>(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> 
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
En faisant le même raisonnement sur [<span style="font-style:italic">k</span>,<span style="font-style:italic">k</span>+1] pour <span style="font-style:italic">k</span>=1,...,<span style="font-style:italic">N</span>−1
et en sommant, on obtient la formule 
d’<span style="font-weight:bold">Euler-Mac Laurin</span><a id="hevea_default222"></a><a id="hevea_default223"></a> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >  <span style="font-style:italic">T</span><sub>1</sub><sup>[0,<span style="font-style:italic">N</span>]</sup>(<span style="font-style:italic">f</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">N</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> 
+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub>2</sub>(0)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">f</span>′(<span style="font-style:italic">N</span>)−<span style="font-style:italic">f</span>′(0)) 
+ ... </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub>2<span style="font-style:italic">k</span></sub>(0)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">k</span>)!</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">f</span><sup>[2<span style="font-style:italic">k</span>−1]</sup>(<span style="font-style:italic">N</span>)−<span style="font-style:italic">f</span><sup>[2<span style="font-style:italic">k</span>−1]</sup>(0)) 
− </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">N</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub>2<span style="font-style:italic">k</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">k</span>)!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span><sup>[2<span style="font-style:italic">k</span>]</sup>(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> 
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
On pose alors <span style="font-style:italic">x</span>=<span style="font-style:italic">a</span>+<span style="font-style:italic">ht</span> (donc <span style="font-style:italic">dt</span>=<span style="font-style:italic">dx</span>/<span style="font-style:italic">h</span>) et <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>)
(donc <span style="font-style:italic">f</span>′(<span style="font-style:italic">t</span>)=<span style="font-style:italic">df</span>/<span style="font-style:italic">dt</span>=<span style="font-style:italic">h</span> <span style="font-style:italic">dg</span>/<span style="font-style:italic">dx</span>), on obtient 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">T</span><sub><span style="font-style:italic">h</span></sub><sup>[<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>]</sup>(<span style="font-style:italic">g</span>)</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">N</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">dx</span> 
+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub>2</sub>(0)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">h</span>(<span style="font-style:italic">g</span>′(<span style="font-style:italic">b</span>)−<span style="font-style:italic">g</span>′(<span style="font-style:italic">a</span>)) 
+ ... </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub>2<span style="font-style:italic">k</span></sub>(0)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">k</span>)!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">h</span><sup>2<span style="font-style:italic">k</span>−1</sup> (<span style="font-style:italic">g</span><sup>[2<span style="font-style:italic">k</span>−1]</sup>(<span style="font-style:italic">N</span>)−<span style="font-style:italic">g</span><sup>[2<span style="font-style:italic">k</span>−1]</sup>(0)) 
− </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">N</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub>2<span style="font-style:italic">k</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">k</span>)!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">h</span><sup>2<span style="font-style:italic">k</span></sup> <span style="font-style:italic">g</span><sup>[2<span style="font-style:italic">k</span>]</sup>(<span style="font-style:italic">x</span>)  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">h</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">dx</span> 
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">T</span><sub><span style="font-style:italic">h</span></sub><sup>[<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>]</sup>(<span style="font-style:italic">g</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">N</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">dx</span> 
+ <span style="font-style:italic">h</span><sup>2</sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub>2</sub>(0)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">g</span>′(<span style="font-style:italic">b</span>)−<span style="font-style:italic">g</span>′(<span style="font-style:italic">a</span>)) 
+ ... </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">+ <span style="font-style:italic">h</span><sup>2<span style="font-style:italic">k</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub>2<span style="font-style:italic">k</span></sub>(0)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">k</span>)!</td></tr>
</table></td><td class="dcell">  (<span style="font-style:italic">g</span><sup>[2<span style="font-style:italic">k</span>−1]</sup>(<span style="font-style:italic">N</span>)−<span style="font-style:italic">g</span><sup>[2<span style="font-style:italic">k</span>−1]</sup>(0)) 
− <span style="font-style:italic">h</span><sup>2<span style="font-style:italic">k</span></sup> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">N</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sub>2<span style="font-style:italic">k</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">k</span>)!</td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">g</span><sup>[2<span style="font-style:italic">k</span>]</sup>(<span style="font-style:italic">x</span>)   <span style="font-style:italic">dx</span> 
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>L’accélération consiste à éliminer les puissances de <span style="font-style:italic">h</span><sup>2</sup> en
commençant par <span style="font-style:italic">h</span><sup>2</sup> avec des subdivisions deux fois plus fines
à chaque itération.
Ainsi <span style="font-style:italic">T</span><sub><span style="font-style:italic">h</span></sub><sup>1</sup>(<span style="font-style:italic">f</span>) = (4<span style="font-style:italic">T</span><sub><span style="font-style:italic">h</span>/2</sub>(<span style="font-style:italic">f</span>)−<span style="font-style:italic">T</span><sub><span style="font-style:italic">h</span></sub>(<span style="font-style:italic">f</span>))/(4−1) n’a plus de termes en <span style="font-style:italic">h</span><sup>2</sup>
et tend vers l’intégrale à approcher lorsque <span style="font-style:italic">h</span> tend vers 0. 
On peut d’ailleurs vérifier qu’il s’agit de la méthode de Simpson.
On élimine ensuite le terme en <span style="font-style:italic">h</span><sup>4</sup> en posant
<span style="font-style:italic">T</span><sub><span style="font-style:italic">h</span></sub><sup>2</sup>(<span style="font-style:italic">f</span>)=(4<sup>2</sup> <span style="font-style:italic">T</span><sub><span style="font-style:italic">h</span>/2</sub><sup>1</sup>(<span style="font-style:italic">f</span>)−<span style="font-style:italic">T</span><sub><span style="font-style:italic">h</span></sub><sup>1</sup>(<span style="font-style:italic">f</span>))/(4<sup>2</sup>−1) et ainsi
de suite. On construit un tableau triangulaire <code>T</code>
dont chaque
ligne <span style="font-style:italic">l</span> contient <span style="font-style:italic">T</span><sub><span style="font-style:italic">h</span>/2<sup><span style="font-style:italic">l</span></sup></sub>(<span style="font-style:italic">f</span>), <span style="font-style:italic">T</span><sub><span style="font-style:italic">h</span>/2<sup><span style="font-style:italic">l</span></sup></sub><sup>1</sup>(<span style="font-style:italic">f</span>), ... 
(avec des indices qui commencent à 0). Pour
calculer le terme d’indice 0 de la ligne courante
on fait une méthode des trapèzes sur 2 fois plus
de subdivisions que la précédente, puis pour le <span style="font-style:italic">j</span>-ième terme
<code>T[l,j]</code>
on effectue <code>(4^j*T[l-1,j-1]-T[l,j-1])/(4^j-1)</code>
(on n’a donc besoin que de la ligne précédente pour calculer
la ligne courante).
On s’arrête par exemple lorsque la valeur absolue de la différence
entre les derniers termes de deux lignes consécutives est inférieur
à la précision souhaitée (erreur empirique).</p>
<!--TOC subsection id="sec198" Cas des fonctions périodiques.-->
<h3 id="sec198" class="subsection">20.8  Cas des fonctions périodiques.</h3><!--SEC END --><p>
Si <span style="font-style:italic">f</span> est une fonction périodique régulière (<span style="font-style:italic">C</span><sup>∞</sup>),
alors la méthode des trapèzes sur une période est d’ordre 
arbitrairement grand. En effet, pour une série de Fourier tronquée
à l’ordre <span style="font-style:italic">m</span>, la formule des trapèzes avec <span style="font-style:italic">N</span> subdivisions donne
le résultat exact de ∫<sub>0</sub><sup><span style="font-style:italic">T</span></sup> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>) <span style="font-style:italic">dt</span> dès que <span style="font-style:italic">N</span>&gt;<span style="font-style:italic">m</span>. Il suffit
ensuite d’utiliser que le reste de
la série de Fourier (<span style="font-style:italic">m</span>&gt;<span style="font-style:italic">N</span>) 
a des coefficients à décroissance rapide.</p><p>La méthode des trapèzes donne donc de bons résultats pour une 
fonction périodique, on peut d’ailleurs aussi 
l’appliquer pour calculer une valeur
approchée des coefficients de Fourier de la fonction. La liste des valeurs
approchées obtenue est alors la transformée de Fourier discrète
des valeurs de la fonction <span style="font-style:italic">f</span> aux <span style="font-style:italic">N</span> points de la subdivision, elle
se calcule donc rapidement avec la transformée de Fourier rapide.
Par exemple, pour approcher <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">e</span><sup>sin(<span style="font-style:italic">x</span>)</sup>, on peut utiliser les
commandes suivantes en Xcas :

</p><pre class="verbatim">f(x):=exp(sin(x));
N:=16; F:=seq(f(k/N*2.*pi),k,0,N-1); G:=fft(F);
k:=4;
g:=G[0]+sum(G[j]*exp(i*j*x),j,1,k)+sum(G[N-j]*exp(-i*j*x),j,1,k);
h:=normal(re(exp2trig(g))/N);
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;t.value=tmp;tmp=UI.caseval(tmp);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML);field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>


<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">plot(h,x=-pi..pi,color=red); //plot(f(x),x=-pi..pi)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>Ou directement <code>2*re(G[j]/N)</code> est une valeur approchée du
<span style="font-style:italic">j</span>-ième coefficient de Fourier <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> de <span style="font-style:italic">f</span>, et <code>-2*im(G[j]/N)</code>
de <span style="font-style:italic">b</span><sub><span style="font-style:italic">j</span></sub>, par exemple :<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">1/pi*int(f(x)*cos(4x),x,0,2.*pi); 2*re(G[4]/N);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>


<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">1/pi*int(f(x)*sin(5x),x,0,2.*pi); -2*im(G[5]/N);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

On observe en effet une très bonne concordance.</p><p>Bien entendu, cela n’est pas très utile pour approcher <span style="font-style:italic">e</span><sup>sin(<span style="font-style:italic">x</span>)</sup>
(il vaut mieux composer exponentielle et sinus), 
mais cela pourrait le devenir pour une
fonction périodique plus compliquée ou pour une fonction
périodique dont on ne connait qu’un échantillonage régulier
(par exemple un fichier numérique audio).</p>
<!--TOC subsection id="sec199" Quadratures gaussiennes.-->
<h3 id="sec199" class="subsection">20.9  Quadratures gaussiennes.</h3><!--SEC END --><p>
<a id="hevea_default224"></a><a id="hevea_default225"></a>
</p>
<!--TOC subsubsection id="sec200" Description-->
<h4 id="sec200" class="subsubsection">20.9.1  Description</h4><!--SEC END --><p>
On a vu que l’interpolation polynomiale était de meilleure
qualité en prenant les points de Tchebyshev plutot que
des points équidistants, il est donc naturel de calculer
des approximations d’intégrale de cette manière
ou encore d’optimiser le choix des abscisses pour avoir
une méthode d’intégration d’ordre maximal.</p><p>Si on se fixe <span style="font-style:italic">n</span> abscisses <span style="font-style:italic">x</span><sub>1</sub> à <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>, on peut obtenir l’ordre
2<span style="font-style:italic">n</span>−1. En effet, considérons le polynôme <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>=∏<sub><span style="font-style:italic">i</span>=1</sub><sup><span style="font-style:italic">n</span></sup> (<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>),
qui est de degré <span style="font-style:italic">n</span>, si la méthode est d’ordre 2<span style="font-style:italic">n</span>−1 alors
il sera orthogonal à tous les polynômes de degré inférieur
strict à <span style="font-style:italic">n</span> pour le produit scalaire 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;<span style="font-style:italic">f</span>|<span style="font-style:italic">g</span>&gt;=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">b</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">dx</span></td></tr>
</table><p>
puisque &lt;<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>|<span style="font-style:italic">x</span><sup><span style="font-style:italic">j</span></sup>&gt;=∫<sub><span style="font-style:italic">a</span></sub><sup><span style="font-style:italic">b</span></sup> <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">j</span></sup>  sera combinaison linéaire des
<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">j</span></sup> en <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>, <span style="font-style:italic">k</span>=1..<span style="font-style:italic">n</span> (car la formule d’intégration est exacte puisque le degré
du polynôme <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">x</span><sup><span style="font-style:italic">j</span></sup> est au plus 2<span style="font-style:italic">n</span>−1). Donc <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> est à une constante
multiplicative près le <span style="font-style:italic">n</span>-ième polynôme orthogonal pour
l’integrale sur [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>], si [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>]=[−1,1] c’est <code>legendre(n)</code>.
Réciproquement, si les <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub> sont les racines de ce polynôme,
alors la formule d’intégration est exacte, on effectue la division
euclidienne du polynôme <span style="font-style:italic">P</span> de degré au plus 2<span style="font-style:italic">n</span>−1 à
intégrer par <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>= <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">Q</span> + <span style="font-style:italic">R</span> ,    deg(<span style="font-style:italic">Q</span>) ≤ <span style="font-style:italic">n</span>−1 </td></tr>
</table><p>
On a ∫<sub><span style="font-style:italic">a</span></sub><sup><span style="font-style:italic">b</span></sup> <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">Q</span>=0 par orthogonalité et la combinaison
linéaire correspondante en les <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub> est nulle, et on a exactiture
pour <span style="font-style:italic">R</span>, car de degré au plus <span style="font-style:italic">n</span>−1.</p><p>Exemple :
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">l:=proot(legendre(10)); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">f(x):=ln(1+x^2); int(f(x),x,-1.0,1.0); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">p:=interp(l,f); int(p,x,-1.0,1.0) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p>
<!--TOC subsubsection id="sec201" Calcul des poids-->
<h4 id="sec201" class="subsubsection">20.9.2  Calcul des poids</h4><!--SEC END --><p>
On peut calculer les poids en appliquant
la section <a href="#sec%3Apoids">20.5</a>. On peut ainsi montrer
que les poids sont positifs en appliquant la formule
d’intégration au polynôme
∏<sub><span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span></sub>(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>)
(la formule est exacte à cause du degré du polynome).
On peut d’ailleurs montrer que le poids <span style="font-style:italic">w</span><sub><span style="font-style:italic">i</span></sub> 
en une racine du polynôme de Legendre
sur [−1,1] est donné par :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">w</span><sub><span style="font-style:italic">i</span></sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(1−<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub><sup>2</sup>)<span style="font-style:italic">P</span>′<sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)<sup>2</sup></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2(1−<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub><sup>2</sup>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span><sup>2</sup><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)<sup>2</sup></td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">nP</span><sub><span style="font-style:italic">n</span>−1</sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>′(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)</td></tr>
</table></td></tr>
</table><p>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">n:=10; P:=legendre(n); Q:=legendre(n-1); l:=proot(P); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">a:=inv(trn(vandermonde(l))):; a*seq((1+(-1)^j)/(j+1),j,0,n-1); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">seq(2/(1-l[j]^2)/P'(x=l[j])^2,j,0,n-1) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">seq(2*(1-l[j]^2)/n^2/Q(x=l[j])^2,j,0,n-1) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">seq(2/n/Q(x=l[j])/P'(x=l[j]),j,0,n-1) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
Preuve de la dernière formule :<br>
On a <span style="font-style:italic">I</span>(<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>/(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>))=<span style="font-style:italic">w</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">P</span>′<sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>) la valeur de (<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>/(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>))
en <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> est par définition de <span style="font-style:italic">P</span>′<sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>) la limite (<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>)−<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>))/(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)
lorsque <span style="font-style:italic">x</span> tend vers <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> (rappelons que <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)=0).
Par exactitude de la formule d’intégration
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">w</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">P</span>′<sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">−1</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell"> =
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)</td></tr>
</table></td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">−1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell"> 
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)</td></tr>
</table></td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">−1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>(<span style="font-style:italic">x</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
la dernière égalité résulte du fait que
(<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>(<span style="font-style:italic">x</span>)−<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>))/(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)
est un polynôme de degré au plus <span style="font-style:italic">n</span>−2 donc orthogonal à <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>.
Donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">w</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">P</span>′<sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)=
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)</td></tr>
</table></td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">−1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Or <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>)/(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>) est un polynôme de degré <span style="font-style:italic">n</span>−1, si on fait son
quotient par <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub> on obtient une constante qui vaut <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub> en
utilisant la relation de récurrence à 2 crans
<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>=(<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub><span style="font-style:italic">x</span>−<span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span>−1</sub>)<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>−<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span>−1</sub><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−2</sub>. Le reste est de
degré <span style="font-style:italic">n</span>−2 donc orthogonal à <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>, d’où
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">w</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">P</span>′<sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)=
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)</td></tr>
</table></td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">−1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub><sup>2</sup> <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub> </td></tr>
</table><p>
On conclut en utilisant la valeur de <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub>=(2<span style="font-style:italic">n</span>−1)/<span style="font-style:italic">n</span> et de
|| <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>||<sup>2</sup>=2/(2(<span style="font-style:italic">n</span>−1)+1).</p>
<!--TOC subsubsection id="sec202" Erreur d’une quadrature gaussienne-->
<h4 id="sec202" class="subsubsection">20.9.3  Erreur d’une quadrature gaussienne</h4><!--SEC END --><p>
On considère une quadrature gaussienne d’ordre 2<span style="font-style:italic">n</span>+1 obtenue
par interpolation aux <span style="font-style:italic">n</span>+1 racines du <span style="font-style:italic">n</span>+1-ième polynome de
Legendre sur [−1,1].</p><p>Rappelons que le polynôme d’interpolation de <span style="font-style:italic">f</span> aux points
<span style="font-style:italic">x</span><sub>0</sub>,<span style="font-style:italic">x</span><sub>1</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> s’écrit
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>]+<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,<span style="font-style:italic">x</span><sub>1</sub>](<span style="font-style:italic">t</span>−<span style="font-style:italic">x</span><sub>0</sub>)+...+<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>](<span style="font-style:italic">t</span>−<span style="font-style:italic">x</span><sub>0</sub>)...(<span style="font-style:italic">t</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>)</td></tr>
</table><p>
Si on ajoute <span style="font-style:italic">x</span> on obtient un polynôme d’interpolation de degré <span style="font-style:italic">n</span>+1
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>+1</sub>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>]+<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,<span style="font-style:italic">x</span><sub>1</sub>](<span style="font-style:italic">t</span>−<span style="font-style:italic">x</span><sub>0</sub>)+...+<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">x</span>](<span style="font-style:italic">t</span>−<span style="font-style:italic">x</span><sub>0</sub>)...(<span style="font-style:italic">t</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>)(<span style="font-style:italic">t</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
</table><p>
qui coincide avec <span style="font-style:italic">f</span> en <span style="font-style:italic">t</span>=<span style="font-style:italic">x</span> donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>]+<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,<span style="font-style:italic">x</span><sub>1</sub>](<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)+...+<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">x</span>](<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)...(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>)(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
</table><p>
Le même calcul fait avec un point <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub> en plus donne
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>]+<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,<span style="font-style:italic">x</span><sub>1</sub>](<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)+...+<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>](<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)...(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>)(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>)
+ <span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>,<span style="font-style:italic">x</span>](<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)...(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>)(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>)(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>)</td></tr>
</table><p>
On a donc montré la formule :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:diffdivtranslate"></a>
<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">x</span>]=<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>]+<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>,<span style="font-style:italic">x</span>](<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>)
    (38)</td></tr>
</table><p>
mais en fait on va ajouter plus qu’un point, on va en ajouter <span style="font-style:italic">n</span>+1
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)−(<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>]+<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,<span style="font-style:italic">x</span><sub>1</sub>](<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)+...+<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>](<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)...(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>)
)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>](<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)...(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>)(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>) +...+<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub>2<span style="font-style:italic">n</span>+1</sub>](<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)...(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>2<span style="font-style:italic">n</span></sub>)
+ <span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub>2<span style="font-style:italic">n</span>+1</sub>,<span style="font-style:italic">x</span>](<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)...(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>2<span style="font-style:italic">n</span>+1</sub>)
</td></tr>
</table></td></tr>
</table><p>
puis on intègre sur [−1,1], on obtient à gauche l’erreur et à
droite, seul le dernier terme est non nul, car le polynôme de Legendre
proportionnel à (<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)...(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>)(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>) , de degré <span style="font-style:italic">n</span>+1,
est orthogonal à tous les polynôme de degré ≤ <span style="font-style:italic">n</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">−1</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) −<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>))  <span style="font-style:italic">dx</span> = </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">−1</td></tr>
</table></td><td class="dcell">
<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub>2<span style="font-style:italic">n</span>+1</sub>,<span style="font-style:italic">x</span>](<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)...(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>2<span style="font-style:italic">n</span>+1</sub>)  <span style="font-style:italic">dx</span> </td></tr>
</table><p>
D’autre part, le résultat sur l’erreur d’interpolation <a href="#eq%3Alagrange">56</a> donne
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">x</span>]=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(ξ<sub><span style="font-style:italic">x</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td></tr>
</table><p>
en particulier |<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">x</span>]| ≤ <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span>+1</sub>/(<span style="font-style:italic">n</span>+1)!
D’où la majoration
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|  </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">−1</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) −<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>))  <span style="font-style:italic">dx</span> | ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span><sub>2<span style="font-style:italic">n</span>+2</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">n</span>+2)!</td></tr>
</table></td><td class="dcell">
</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">−1</td></tr>
</table></td><td class="dcell">|(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)...(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>2<span style="font-style:italic">n</span>+1</sub>)|  <span style="font-style:italic">dx</span> </td></tr>
</table><p>
Il suffit ensuite de faire tendre les <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>,...,<span style="font-style:italic">x</span><sub>2<span style="font-style:italic">n</span>+1</sub> vers
<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> pour enlever la valeur absolue et obtenir
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|  </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">−1</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) −<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>))  <span style="font-style:italic">dx</span> | ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span><sub>2<span style="font-style:italic">n</span>+2</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">n</span>+2)!</td></tr>
</table></td><td class="dcell">
</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">−1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">L</span><sub><span style="font-style:italic">n</span>+1</sub><sup>2</sup>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">dx</span> </td></tr>
</table><p> 
où <span style="font-style:italic">L</span><sub><span style="font-style:italic">n</span>+1</sub> est proportionnel au <span style="font-style:italic">n</span>+1-ième polynôme de
Legendre de coefficient dominant 1.</p><p>Par exemple, pour <span style="font-style:italic">n</span>=1, on a 2 points d’interpolation en les racines
de <span style="font-style:italic">L</span><sub>2</sub>=<span style="font-style:italic">x</span><sup>2</sup>−1/3 et l’erreur d’interpolation
est majorée par <span style="font-style:italic">M</span><sub>4</sub>/24∫<sub>−1</sub><sup>1</sup>(<span style="font-style:italic">x</span><sup>2</sup>−1/3)  <span style="font-style:italic">dx</span>=<span style="font-style:italic">M</span><sub>4</sub>/24 × 8/45=<span style="font-style:italic">M</span><sub>4</sub>/135.</p>
<!--TOC subsection id="sec203" Méthode adaptative.-->
<h3 id="sec203" class="subsection">20.10  Méthode adaptative.</h3><!--SEC END --><p>
On calcule une valeur approchée de l’intégrale sur [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>] par
deux quadratures gaussiennes emboitées, on estime l’erreur,
si elle est supérieure à la tolérance on divise en 2. On
recommence en subdivisant en 2 l’intervalle où l’erreur est
maximale. On s’arrête lorsque l’erreur estimée est inférieure
à la tolérance.</p><p>L’estimation de l’erreur se fait par exemple avec deux quadratures
gaussiennes emboitées (c’est-à-dire que les points d’interpolation
de la moins fine sont contenues dans les points d’interpolation de la
plus fine, pour éviter de devoir calculer la fonction en de nouveaux
points, on considére alors l’erreur sur la quadrature la moins fine
comme la valeur absolue de la différence des deux valeurs). Ou avec
trois quadratures emboitées,
Hairer propose de prendre comme quadrature la plus fine en <span style="font-style:italic">h</span><sup>30</sup>
(15 points), intermédiaire en <span style="font-style:italic">h</span><sup>14</sup> (avec les mêmes points
sauf le point central), moins fine en <span style="font-style:italic">h</span><sup>6</sup> (avec les points 1, 3, 5,
9, 11, 13), et d’estimer l’erreur par 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">є<sub>1</sub>=| <span style="font-style:italic">I</span><sub>30</sub>−<span style="font-style:italic">I</span><sub>14</sub>|,  є<sub>2</sub>=| <span style="font-style:italic">I</span><sub>30</sub>−<span style="font-style:italic">I</span><sub>6</sub>|; 
є = є<sub>1</sub> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">є<sub>1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">є<sub>2</sub></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">2</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
On observe en effet que є est en <span style="font-style:italic">h</span><sup>30</sup>, comme
l’ordre de la méthode.</p>
<!--TOC subsection id="sec204" Méthodes probabilistes.-->
<h3 id="sec204" class="subsection">20.11  Méthodes probabilistes.</h3><!--SEC END --><p> <a id="hevea_default226"></a>
Pour déterminer ∫<sub><span style="font-style:italic">a</span></sub><sup><span style="font-style:italic">b</span></sup> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> , on l’interprète comme
une espérance, plus précisément comme (<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>)<span style="font-style:italic">E</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">X</span>)) 
où <span style="font-style:italic">X</span> est une variable aléatoire
qui suit la loi uniforme sur [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>], et on approche cette valeur
par 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span>−<span style="font-style:italic">a</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>) </td></tr>
</table><p>
où <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub> est obtenu par un générateur pseudo-aléatoire
(selon la loi uniforme).
Par exemple<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">f(t):=exp(-t^2); n:=1000; a:=0; b:=2.0;l:=ranv(n,uniform,a,b):; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">(b-a)*sum(apply(f,l))/n; int(f(t),t,a,b); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
La convergence en fonction de <span style="font-style:italic">n</span> est assez lente, on peut l’observer
en faisant plusieurs estimations :<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">m:=ranm(500,n,uniform,a,b):;I:=seq(2*sum(apply(f,m[k]))/n,k,0,size(m)-1); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">histogram(I,0,0.01)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>En effet, les tirages sont équidistribués selon la même loi,
la loi des grands nombres s’applique donc : on fait <span style="font-style:italic">b</span>−<span style="font-style:italic">a</span> fois
une moyenne de
<span style="font-style:italic">n</span> tirages, si <span style="font-style:italic">n</span> est grand, on converge vers une loi normale
dont l’écart-type est en (<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>)σ/√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>.
La valeur de la constante σ
peut se calculer à partir de <span style="font-style:italic">f</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">σ<sup>2</sup> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span>−<span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">b</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span><sup>2</sup>(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> −
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span>−<span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">b</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span>  </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">2</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
par exemple ici<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">2*sqrt(int(f(t)^2,t,0,2.)/2-(1/2*int(f(t),t,0,2.))^2)/sqrt(n); stddevp(I); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
mais on ne fait pas ce calcul en pratique
(puisqu’il faudrait calculer une intégrale), on estime
l’écart-type σ/√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span> de la loi normale par
l’écart-type de l’échantillon des estimations <code>stddevp(I)</code>.<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">histogram(I,0,0.01); plot(normald(mean(I),stddevp(I),x),x=0.8..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>On peut donc obtenir rapidement une estimation de σ en prenant
l’écart-type d’une séquence de valeurs de <span style="font-style:italic">f</span><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">f(t):=exp(-t^2); n:=1000; a:=0; b:=2.0;l:=ranv(n,uniform,a,b):; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">fl:=apply(f,l):;m:=(b-a)*mean(fl);s:=(b-a)*stddevp(fl)/sqrt(n);[m-2s,m+2s] 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p><p>Cette méthode converge donc beaucoup moins vite que les quadratures,
en dimension 1. Mais elle se généralise très facilement en
dimension plus grande en conservant la même vitesse de convergence
alors que le travail nécessaire pour une méthode de quadrature
croit comme une puissance de la dimension, et ne nécessite pas
de paramétrer des domaines d’intégration compliqués (il suffit
par exemple d’utiliser la méthode du rejet pour avoir un
générateur uniforme
dans un domaine inclus dans un cube).</p>
<!--TOC section id="sec205" Suites récurrentes et applications-->
<h2 id="sec205" class="section">21  Suites récurrentes et applications</h2><!--SEC END --><p> <a id="sec:rec"></a>
<a id="hevea_default227"></a><a id="hevea_default228"></a>
Cette section comporte une première petite partie sur le calcul
de l’expression exacte de suites récurrences (linéaires), puis
une deuxième partie sur l’intérêt du calcul approché de limites
de suites récurrentes (dont on ne sait en général pas déterminer l’expression
générale).</p>
<!--TOC subsection id="sec206" Calcul de l’expression des suites récurrentes.-->
<h3 id="sec206" class="subsection">21.1  Calcul de l’expression des suites récurrentes.</h3><!--SEC END --><p>
Le problème général est l’analogue discret de la recherche de solutions
d’équations différentielles. On ne sait en général pas le résoudre, sauf
pour certaines classes de suites, en particulier celles qui suivent
une récurrence affine.</p>
<!--TOC subsubsection id="sec207" Récurrence affine-->
<h4 id="sec207" class="subsubsection">21.1.1  Récurrence affine</h4><!--SEC END --><p><a id="hevea_default229"></a>
<a id="hevea_default230"></a>
On peut toujours se ramener au cas d’une suite vectorielle dans ℝ<sup><span style="font-style:italic">d</span></sup>
vérifiant un récurrence à un cran :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub> = <span style="font-style:italic">A</span> <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> + <span style="font-style:italic">B</span> <a id="eq:recaffine"></a>
    (39)</td></tr>
</table><p>
où <span style="font-style:italic">A</span> est une matrice indépendante de <span style="font-style:italic">n</span>, et <span style="font-style:italic">B</span> un vecteur qui peut
dépendre de <span style="font-style:italic">n</span>.
Par exemple pour une suite <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> récurrente à deux crans
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+2</sub>=<span style="font-style:italic">au</span><sub><span style="font-style:italic">n</span>+1</sub>+<span style="font-style:italic">bu</span><sub><span style="font-style:italic">n</span></sub>+<span style="font-style:italic">c</span></td></tr>
</table><p>
on pose <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>=(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>) qui vérifie alors :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub>= </td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">b</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span> </td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> + 
</td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">c</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td></tr>
</table><p> 
La solution générale de (<a href="#eq%3Arecaffine">39</a>) est la somme de la solution
de l’équation homogène <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">Av</span><sub><span style="font-style:italic">n</span></sub> et d’une solution particulière,
solution que l’on sait calculer lorsque <span style="font-style:italic">B</span> est combinaison linéaire
d’un produit d’exponentielle par un polynôme en <span style="font-style:italic">n</span>.
L’équation homogène a pour solution <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">A</span><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">v</span><sub>0</sub>, où l’expression de <span style="font-style:italic">A</span><sup><span style="font-style:italic">n</span></sup>
se calcule sur un corps algébriquement clos par réduction de Jordan
(fonction <code>matpow</code> dans Xcas). On peut aussi utiliser un algorithme
de puissance rapide pour calculer le reste de la division euclidienne
de <span style="font-style:italic">A</span><sup><span style="font-style:italic">n</span></sup> par un polynôme annulateur de <span style="font-style:italic">A</span> (minimal ou caractéristique)
ce qui permet de rester dans le corps des coefficients.</p><p>Le calcul d’une solution particulière dans le cas où 
<span style="font-style:italic">B</span>=<span style="font-style:italic">c</span><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">P</span>(<span style="font-style:italic">n</span>) avec <span style="font-style:italic">P</span> un vecteur à coefficients polynomiaux
de degré au plus <span style="font-style:italic">p</span> se fait en posant <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">c</span><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">Q</span>(<span style="font-style:italic">n</span>)
où <span style="font-style:italic">Q</span> est un vecteur de polynôme de degré <span style="font-style:italic">p</span> plus la multiplicité
de <span style="font-style:italic">c</span> comme valeur propre de <span style="font-style:italic">A</span>. En effet, on doit alors résoudre :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">Av</span><sub><span style="font-style:italic">n</span></sub> = <span style="font-style:italic">c</span><sup><span style="font-style:italic">n</span></sup> (<span style="font-style:italic">c</span> <span style="font-style:italic">Q</span>(<span style="font-style:italic">n</span>+1)− <span style="font-style:italic">AQ</span>(<span style="font-style:italic">n</span>)) = <span style="font-style:italic">c</span><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">P</span>(<span style="font-style:italic">n</span>)  </td></tr>
</table><p>
soit
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:recpart"></a>
<span style="font-style:italic">c</span> <span style="font-style:italic">Q</span>(<span style="font-style:italic">n</span>+1)− <span style="font-style:italic">AQ</span>(<span style="font-style:italic">n</span>) = <span style="font-style:italic">P</span>(<span style="font-style:italic">n</span>)
    (40)</td></tr>
</table><p>
Si <span style="font-style:italic">Q</span>(<span style="font-style:italic">n</span>)=∑<sub><span style="font-style:italic">j</span>=0</sub><sup><span style="font-style:italic">q</span></sup> <span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">n</span><sup><span style="font-style:italic">j</span></sup>, alors le coefficient de <span style="font-style:italic">n</span><sup><span style="font-style:italic">q</span></sup> de cette équation
est (<span style="font-style:italic">c</span> <span style="font-style:italic">I</span><sub><span style="font-style:italic">d</span></sub> −<span style="font-style:italic">A</span>)<span style="font-style:italic">Q</span><sub><span style="font-style:italic">q</span></sub>=<span style="font-style:italic">P</span><sub><span style="font-style:italic">q</span></sub>. Si <span style="font-style:italic">c</span> n’est pas valeur propre de <span style="font-style:italic">A</span>, alors
on peut calculer <span style="font-style:italic">Q</span><sub><span style="font-style:italic">q</span></sub> en fonction de <span style="font-style:italic">P</span><sub><span style="font-style:italic">q</span></sub> et en descendant de degré en degré
on peut trouver <span style="font-style:italic">Q</span> solution de même degré que <span style="font-style:italic">P</span>. Si <span style="font-style:italic">c</span> est valeur
propre de <span style="font-style:italic">A</span>, la résolution de cette façon
est plus compliquée, il faut séparer les
<span style="font-style:italic">Q</span><sub><span style="font-style:italic">j</span></sub> en deux composantes, l’une sur l’espace caractéristique associé
à <span style="font-style:italic">c</span> et l’autre sur la somme des autres sous-espaces caractéristiques,
ce qui peut se faire avec l’identité de Bézout, si <span style="font-style:italic">M</span> un polynôme annulateur
de <span style="font-style:italic">A</span> est <span style="font-style:italic">M</span>(<span style="font-style:italic">x</span>)=(<span style="font-style:italic">x</span>−<span style="font-style:italic">c</span>)<sup><span style="font-style:italic">m</span></sup> <span style="font-style:italic">N</span>(<span style="font-style:italic">x</span>) où <span style="font-style:italic">m</span> est la multiplicité de <span style="font-style:italic">c</span> dans <span style="font-style:italic">M</span>,
alors il existe <span style="font-style:italic">U</span> et <span style="font-style:italic">V</span> tels que (<span style="font-style:italic">x</span>−<span style="font-style:italic">c</span>)<sup><span style="font-style:italic">m</span></sup><span style="font-style:italic">U</span>(<span style="font-style:italic">x</span>)+<span style="font-style:italic">N</span>(<span style="font-style:italic">x</span>)<span style="font-style:italic">V</span>(<span style="font-style:italic">x</span>)=1, donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">A</span>−<span style="font-style:italic">cI</span>)<sup><span style="font-style:italic">m</span></sup> <span style="font-style:italic">U</span>(<span style="font-style:italic">A</span>)<span style="font-style:italic">y</span>+<span style="font-style:italic">N</span>(<span style="font-style:italic">A</span>)<span style="font-style:italic">V</span>(<span style="font-style:italic">A</span>)<span style="font-style:italic">y</span>= <span style="font-style:italic">y</span></td></tr>
</table><p>
on a écrit <span style="font-style:italic">y</span> comme somme de deux vecteurs, le premier dans le noyau de
<span style="font-style:italic">N</span>(<span style="font-style:italic">A</span>) et le second dans le noyau de (<span style="font-style:italic">A</span>−<span style="font-style:italic">cI</span>)<sup><span style="font-style:italic">m</span></sup>. Pour la première
composante on est ramené au cas où <span style="font-style:italic">c</span> n’est pas valeur propre de <span style="font-style:italic">A</span>,
pour la seconde composante, on jordanise puis on travaille composante
par composante, pour chaque composante on aura une équation du type
<span style="font-style:italic">c</span>(<span style="font-style:italic">Q</span>(<span style="font-style:italic">n</span>+1)−<span style="font-style:italic">Q</span>(<span style="font-style:italic">n</span>))=polynôme connu, équation 
que l’on peut résoudre efficacement avec
la base de Newton (voir section ci-dessous).</p>
<!--TOC subsubsection id="sec208" Utilisation de la base de Newton si <span style="font-style:italic">A</span>=<span style="font-style:italic">I</span><sub><span style="font-style:italic">d</span></sub> et <span style="font-style:italic">c</span>=1-->
<h4 id="sec208" class="subsubsection">21.1.2  Utilisation de la base de Newton si <span style="font-style:italic">A</span>=<span style="font-style:italic">I</span><sub><span style="font-style:italic">d</span></sub> et <span style="font-style:italic">c</span>=1</h4><!--SEC END --><p>
<a id="hevea_default231"></a>
Plutôt que d’exprimer les polynômes dans la base canonique, il est
intéressant d’utiliser la base 1,<span style="font-style:italic">n</span>,<span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>−1),<span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>−1)(<span style="font-style:italic">n</span>−2),...,<span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>−1)...(<span style="font-style:italic">n</span>−<span style="font-style:italic">p</span>+1).
En effet (<a href="#eq%3Arecpart">40</a>) appliqué à <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span>+1</sub> <span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>−1)..(<span style="font-style:italic">n</span>−<span style="font-style:italic">k</span>) s’écrit
<span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span>+1</sub>((<span style="font-style:italic">n</span>+1)−(<span style="font-style:italic">n</span>−<span style="font-style:italic">k</span>))<span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>−1)...(<span style="font-style:italic">n</span>−<span style="font-style:italic">k</span>+1)=<span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span>+1</sub>(<span style="font-style:italic">k</span>+1)<span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>−1)...(<span style="font-style:italic">n</span>−<span style="font-style:italic">k</span>+1), on obtient
donc <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>/(<span style="font-style:italic">k</span>+1). Le calcul des coefficients <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> s’effectue
efficacement par l’algorithme des différences divisées à partir
du polynôme <span style="font-style:italic">P</span> et de sa valeur en 0,1,2,...,degré(<span style="font-style:italic">P</span>).</p>
<!--TOC subsection id="sec209" Le point fixe dans ℝ-->
<h3 id="sec209" class="subsection">21.2  Le point fixe dans ℝ</h3><!--SEC END --><p><a id="hevea_default232"></a> 
Soit <span style="font-style:italic">f</span> une fonction continue sur un intervalle <span style="font-style:italic">I</span>=[<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>] de ℝ, et 
à valeurs dans <span style="font-style:italic">I</span> (attention à bien choisir <span style="font-style:italic">I</span> pour que l’image
de <span style="font-style:italic">I</span> par <span style="font-style:italic">f</span> reste dans <span style="font-style:italic">I</span>).
On s’intéresse à la suite 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:u_n_fixe"></a>
<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>),    <span style="font-style:italic">u</span><sub>0</sub> ∈ <span style="font-style:italic">I</span> 
    (41)</td></tr>
</table><p>
Supposons que <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> converge vers une limite <span style="font-style:italic">l</span> ∈ <span style="font-style:italic">I</span> lorsque
<span style="font-style:italic">n</span> → +∞, alors la limite doit vérifier
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">l</span>)=<span style="font-style:italic">l</span> </td></tr>
</table><p>
puisque <span style="font-style:italic">f</span> est continue. On dit que <span style="font-style:italic">l</span> est un point fixe de <span style="font-style:italic">f</span>.
Ceci amène à l’idée d’utiliser ces suites pour résoudre numériquement
l’équation <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">x</span>. Nous allons donner un théorème permettant
d’assurer que la suite (<a href="#eq%3Au_n_fixe">41</a>) converge, et que la limite
est l’unique solution de <span style="font-style:italic">f</span>(<span style="font-style:italic">l</span>)=<span style="font-style:italic">l</span> sur <span style="font-style:italic">I</span>.</p><div class="theorem"><span style="font-weight:bold">Définition 38</span>  <em>
On dit que </em><span style="font-style:italic">f</span><em> est </em><em><span style="font-weight:bold">contractante</span></em><a id="hevea_default233"></a><em> de rapport </em><span style="font-style:italic">k</span>&lt;1<em> sur </em><span style="font-style:italic">I</span><em> si
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">∀ <span style="font-style:italic">x</span>,<span style="font-style:italic">y</span> ∈ <span style="font-style:italic">I</span>,    |<span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)| ≤ <span style="font-style:italic">k</span> |<span style="font-style:italic">y</span>−<span style="font-style:italic">x</span>| </td></tr>
</table><em>
</em></div><p>En pratique, les fonctions <span style="font-style:italic">f</span> que l’on considèrera seront continument
dérivables, donc d’après le théorème des accroissements finis
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">f</span>′(θ) (<span style="font-style:italic">y</span>−<span style="font-style:italic">x</span>),    θ ∈ [<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>] </td></tr>
</table><p>
ainsi pour vérifier que <span style="font-style:italic">f</span> est contractante, on étudie la valeur absolue
de <span style="font-style:italic">f</span>′ sur <span style="font-style:italic">I</span>, il suffit de montrer que cette valeur absolue
est strictement inférieure à un réel <span style="font-style:italic">k</span>&lt;1 pour conclure (il faut
donc chercher le maximum de |<span style="font-style:italic">f</span>′| sur <span style="font-style:italic">I</span>. Attention, il s’agit du
maximum de |<span style="font-style:italic">f</span>′| et pas du maximum de <span style="font-style:italic">f</span>′, ce qui revient à chercher
le maximum de <span style="font-style:italic">f</span>′ et de −<span style="font-style:italic">f</span>′).</p><p>On a alors le 
</p><div class="theorem"><span style="font-weight:bold">Théorème 39</span>  <em> (du </em><em><span style="font-weight:bold">point fixe</span></em><em>)</em><a id="hevea_default234"></a><em><br>
si </em><span style="font-style:italic">f</span><em> est contractante de </em><span style="font-style:italic">I</span>=[<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>]<em>
dans </em><span style="font-style:italic">I</span><em> de rapport </em><span style="font-style:italic">k</span><em> 
alors la suite (</em><a href="#eq%3Au_n_fixe"><em>41</em></a><em>) converge vers l’unique
solution de </em><span style="font-style:italic">f</span>(<span style="font-style:italic">l</span>)=<span style="font-style:italic">l</span><em> dans </em><span style="font-style:italic">I</span><em>. On a de plus les encadrements :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">  <a id="eq:u_n_l"></a>
|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">l</span>| ≤ <span style="font-style:italic">k</span><sup><span style="font-style:italic">n</span></sup> |<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span>|,   
|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> −<span style="font-style:italic">l</span> | ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>|</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"><em> 
    (42)</em></td></tr>
</table><em>
</em></div><p>Démonstration : Tout d’abord si <span style="font-style:italic">f</span> est contractante, on montre à partir
de la définition de la continuité que <span style="font-style:italic">f</span> est continue. 
Soit <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)−<span style="font-style:italic">x</span>, alors <span style="font-style:italic">g</span> est continue, positive en <span style="font-style:italic">a</span> et négative
en <span style="font-style:italic">b</span>, il existe donc <span style="font-style:italic">l</span>∈[<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>] tel que <span style="font-style:italic">g</span>(<span style="font-style:italic">l</span>)=0 (théorème des
valeurs intermédiaires). 
Soit <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> une suite définie par
(<a href="#eq%3Au_n_fixe">41</a>). On a alors pour tout <span style="font-style:italic">n</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">l</span>|=|<span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">l</span>)| ≤ <span style="font-style:italic">k</span> |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">l</span>| </td></tr>
</table><p>
Donc par une récurrence évidente :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">l</span>| ≤ <span style="font-style:italic">k</span><sup><span style="font-style:italic">n</span></sup> |<span style="font-style:italic">u</span><sub>0</sub>−<span style="font-style:italic">l</span>| </td></tr>
</table><p>
ce qui entraine d’ailleurs que |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">l</span>| ≤ <span style="font-style:italic">k</span><sup><span style="font-style:italic">n</span></sup> |<span style="font-style:italic">a</span>−<span style="font-style:italic">b</span>|.
Comme <span style="font-style:italic">k</span> ∈ [0,1[ , la suite géométrique <span style="font-style:italic">k</span><sup><span style="font-style:italic">n</span></sup> converge vers 0
lorsque <span style="font-style:italic">n</span> tend vers l’infini, donc <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> tend vers <span style="font-style:italic">l</span>.
Notons que <span style="font-style:italic">l</span> est unique car si <span style="font-style:italic">l</span>′ est une autre solution
alors |<span style="font-style:italic">l</span>−<span style="font-style:italic">l</span>′|=|<span style="font-style:italic">f</span>(<span style="font-style:italic">l</span>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">l</span>′)| ≤ <span style="font-style:italic">k</span>|<span style="font-style:italic">l</span>−<span style="font-style:italic">l</span>′| donc (1−<span style="font-style:italic">k</span>)|<span style="font-style:italic">l</span>−<span style="font-style:italic">l</span>′| ≤ 0,
or 1−<span style="font-style:italic">k</span>&gt;0 et |<span style="font-style:italic">l</span>−<span style="font-style:italic">l</span>′| ≥ 0 donc |<span style="font-style:italic">l</span>−<span style="font-style:italic">l</span>′| doit être nul.
Passons à la preuve de la majoration (<a href="#eq%3Au_n_l">42</a>) qui est importante
en pratique car elle donne un test d’arrêt de calcul des
termes de la suite récurrente, on écrit pour <span style="font-style:italic">m</span>&gt;0 :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">l</span>= <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> − <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub> + <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub> − <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+2</sub> + ... + <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+<span style="font-style:italic">m</span>−1</sub>− <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+<span style="font-style:italic">m</span></sub>
+ <span style="font-style:italic">u</span><sub><span style="font-style:italic">m</span></sub>−<span style="font-style:italic">l</span> </td></tr>
</table><p>
puis on majore avec l’inégalité triangulaire
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">l</span>| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+<span style="font-style:italic">j</span></sub>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+<span style="font-style:italic">j</span>+1</sub>| + |<span style="font-style:italic">u</span><sub><span style="font-style:italic">m</span></sub>−<span style="font-style:italic">l</span>| </td></tr>
</table><p>
puis on applique le fait que <span style="font-style:italic">f</span> est contractante de rapport <span style="font-style:italic">k</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">l</span>| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">k</span><sup><span style="font-style:italic">j</span></sup> |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>| + |<span style="font-style:italic">u</span><sub><span style="font-style:italic">m</span></sub>−<span style="font-style:italic">l</span>| </td></tr>
</table><p>
soit
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">l</span>| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">k</span><sup><span style="font-style:italic">m</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>| + |<span style="font-style:italic">u</span><sub><span style="font-style:italic">m</span></sub>−<span style="font-style:italic">l</span>| </td></tr>
</table><p>
On fait alors tendre <span style="font-style:italic">m</span> vers l’infini d’où le résultat.</p><p>Remarque : on peut aussi (voir plus bas le point fixe en dimension
<span style="font-style:italic">n</span>) montrer l’existence de la limite en montrant que (<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>) est
une suite de Cauchy. On peut alors faire <span style="font-style:italic">a</span>=−∞ ou <span style="font-style:italic">b</span>=+∞
dans l’énoncé du théorème. On remarque aussi 
que l’existence d’un point fixe
dans [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>] pour <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> finis ne nécessite pas la contractance
de rapport <span style="font-style:italic">k</span>&lt;1, il suffit de préserver [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>].</p><p>Exemples : 
Cherchons une valeur approchée de √<span style="text-decoration:overline">2</span> par cette méthode.
Il faut d’abord trouver une fonction <span style="font-style:italic">f</span> dont √<span style="text-decoration:overline">2</span> est un point
fixe, par exemple
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>+2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>+1</td></tr>
</table></td></tr>
</table><p>
On vérifie que <span style="font-style:italic">f</span>(√<span style="text-decoration:overline">2</span>)=√<span style="text-decoration:overline">2</span>), puis que <span style="font-style:italic">f</span>′=−1/(<span style="font-style:italic">x</span>+1)<sup>2</sup>
donc <span style="font-style:italic">f</span> décroit. On va voir si les hypothèses du théorème du point
fixe s’appliquent sur par exemple [1,2]. Comme <span style="font-style:italic">f</span> est décroissante
<span style="font-style:italic">f</span>([1,2])=[<span style="font-style:italic">f</span>(2),<span style="font-style:italic">f</span>(1)]=[4/3,3/2] qui est bien inclus dans [1,2] .
De plus <span style="font-style:italic">f</span>′ est comprise entre −1/(1+1)<sup>2</sup>=−1/4 et −1/(2+1)<sup>2</sup>=−1/9 donc
|<span style="font-style:italic">f</span>′|&lt;1/4, <span style="font-style:italic">f</span> est contractante de rapport 1/4. On peut donc
itérer la suite à partir par exemple de <span style="font-style:italic">u</span><sub>0</sub>=1 et on va converger
vers √<span style="text-decoration:overline">2</span> (en s’en rapprochant à chaque cran d’un rapport
inférieur à 1/4).</p><p>Considérons l’équation en <span style="font-style:italic">x</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>− <span style="font-style:italic">e</span> sin(<span style="font-style:italic">x</span>) =<span style="font-style:italic">t</span>,    <span style="font-style:italic">e</span> ∈ [0,1[ </td></tr>
</table><p>
c’est l’équation du temps utilisée en astronomie pour trouver la
position d’une planète sur son orbite elliptique (<span style="font-style:italic">e</span> étant l’excentricité
de l’ellipse).
Il n’y a pas de formule exacte permettant de calculer <span style="font-style:italic">x</span> en fonction de <span style="font-style:italic">t</span>.
Si on a une valeur numérique pour <span style="font-style:italic">t</span>, on peut trouver une valeur
numérique approchée de <span style="font-style:italic">x</span> par la méthode du point fixe, en réécrivant
l’équation sous la forme 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">t</span>+<span style="font-style:italic">e</span>sin(<span style="font-style:italic">x</span>) = <span style="font-style:italic">x</span> </td></tr>
</table><p>
On observe que <span style="font-style:italic">f</span> envoie ℝ dans [<span style="font-style:italic">t</span>−<span style="font-style:italic">e</span>,<span style="font-style:italic">t</span>+<span style="font-style:italic">e</span>] donc on peut prendre
<span style="font-style:italic">I</span>=[<span style="font-style:italic">t</span>−<span style="font-style:italic">e</span>,<span style="font-style:italic">t</span>+<span style="font-style:italic">e</span>], de plus |<span style="font-style:italic">f</span>′|≤ <span style="font-style:italic">e</span> &lt;1, <span style="font-style:italic">f</span> est contractante
de rapport <span style="font-style:italic">e</span> ∈ [0,1[, le théorème s’applique, il suffit de
prendre une valeur initiale dans [<span style="font-style:italic">t</span>−<span style="font-style:italic">e</span>,<span style="font-style:italic">t</span>+<span style="font-style:italic">e</span>] et d’itérer la suite
jusqu’à obtenir la précision désirée. Par exemple si on veut une
valeur approchée de <span style="font-style:italic">x</span> à 10<sup>−6</sup> près, il suffira que la différence
entre deux termes successifs de la suite <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> vérifie
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>| ≤  10<sup>−6</sup> (1−<span style="font-style:italic">e</span>) </td></tr>
</table><p>
on aura alors bien :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">x</span>| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>|</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">e</span></td></tr>
</table></td><td class="dcell"> ≤ 10<sup>−6</sup> </td></tr>
</table><p>Cette méthode n’est pas toujours optimale, car la vitesse de convergence
vers la limite <span style="font-style:italic">l</span> est dite “linéaire”, c’est-à-dire 
que le temps de calcul pour
avoir <span style="font-style:italic">n</span> décimales est proportionnel à <span style="font-style:italic">n</span> (ou
encore il faut effectuer un nombre d’itérations
proportionnel à <span style="font-style:italic">n</span>, chaque itération faisant
gagner en précision de l’ordre du rapport <span style="font-style:italic">k</span> de contractance). 
En effet, supposons que <span style="font-style:italic">f</span>′ est continue en <span style="font-style:italic">l</span> et que 0&lt;<span style="font-style:italic">L</span>=|<span style="font-style:italic">f</span>′(<span style="font-style:italic">l</span>)|&lt;1 .
Il existe alors un intervalle <span style="font-style:italic">I</span>=[<span style="font-style:italic">l</span>−η,<span style="font-style:italic">l</span>+η] tel que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span> ∈ <span style="font-style:italic">I</span> ⇒ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> ≤ |<span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span>)| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Le théorème des accroissements finis donne alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub> − <span style="font-style:italic">l</span> | = |<span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">l</span>)| = |<span style="font-style:italic">f</span>′(θ)| |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">l</span>|,
   θ ∈ [<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">l</span>] </td></tr>
</table><p>
Si <span style="font-style:italic">u</span><sub>0</sub> ∈ <span style="font-style:italic">I</span>, alors θ ∈ <span style="font-style:italic">I</span> donc |<span style="font-style:italic">u</span><sub>1</sub>−<span style="font-style:italic">l</span>| ≤ |<span style="font-style:italic">u</span><sub>0</sub>−<span style="font-style:italic">l</span>| et
<span style="font-style:italic">u</span><sub>1</sub> ∈ <span style="font-style:italic">I</span>, par récurrence on a pour tout <span style="font-style:italic">n</span>, <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> ∈ <span style="font-style:italic">I</span> 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">l</span>| ≤ |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub> − <span style="font-style:italic">l</span>| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">l</span>| </td></tr>
</table><p>
on a donc par récurrence 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell">|<span style="font-style:italic">u</span><sub>0</sub>−<span style="font-style:italic">l</span>| ≤ |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">l</span>| ≤  
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell">|<span style="font-style:italic">u</span><sub>0</sub>−<span style="font-style:italic">l</span>|
</td></tr>
</table><p>
Donc pour avoir |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">l</span>| ≤ є il suffit que 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell">|<span style="font-style:italic">u</span><sub>0</sub>−<span style="font-style:italic">l</span>| ≤ є ⇒
<span style="font-style:italic">n</span> ≥ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">ln(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">є</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">u</span><sub>0</sub>−<span style="font-style:italic">l</span>|</td></tr>
</table></td><td class="dcell">)</td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">ln( </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">) </td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
et il faut que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell"> |<span style="font-style:italic">u</span><sub>0</sub>−<span style="font-style:italic">l</span>| ≤ є
⇒
<span style="font-style:italic">n</span> ≥ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">ln(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">є</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">u</span><sub>0</sub>−<span style="font-style:italic">l</span>|</td></tr>
</table></td><td class="dcell">)</td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">ln( </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">) </td></tr>
</table></td></tr>
</table></td></tr>
</table><p>On peut accélerer la convergence par la méthode dite de
relaxation<a id="hevea_default235"></a>, au lieu de résoudre <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">x</span>, on résoud
<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)+α <span style="font-style:italic">x</span>=(1+α)<span style="font-style:italic">x</span> soit <span style="font-style:italic">x</span>=(<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)+α <span style="font-style:italic">x</span>)/(1+α),
on choisira alors α proche de −<span style="font-style:italic">f</span>′(<span style="font-style:italic">l</span>).</p><p>Si <span style="font-style:italic">f</span> est suffisamment régulière,
il existe une méthode plus rapide lorsqu’on est proche de la racine ou lorsque
la fonction a des propriétés de convexité, c’est la méthode de Newton
(voir aussi la méthode de la sécante).
Et même si Newton n’est pas applicable, une simple dichotomie
peut être plus efficace si la constante de contractance est 
supérieure à 1/2 (y compris prés de la solution de <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">x</span>).
Toutefois la méthode du point fixe reste intéressante si la
constante de contractance est suffisamment petite (par exemple <span style="font-style:italic">k</span>=0.1
garantit 15 décimales en 15 itérations) et présente l’avantage
de se généraliser en dimension plus grande, cf. la section suivante.</p>
<!--TOC subsection id="sec210" Le point fixe dans ℝ<sup><span style="font-style:italic">n</span></sup>-->
<h3 id="sec210" class="subsection">21.3  Le point fixe dans ℝ<sup><span style="font-style:italic">n</span></sup></h3><!--SEC END --><p>
Le théorème précédent se généralise. 
</p><div class="theorem"><span style="font-weight:bold">Théorème 40</span>  <em>
Soit </em><span style="font-style:italic">I</span><em> un ensemble
fermé de </em>ℝ<sup><span style="font-style:italic">n</span></sup><em> (ou d’un espace métrique complet) tel que </em><span style="font-style:italic">f</span><em> 
envoie </em><span style="font-style:italic">I</span><em> dans </em><span style="font-style:italic">I</span><em> et tel que </em><span style="font-style:italic">f</span><em> soit contractante sur </em><span style="font-style:italic">I</span><em>
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">∃ <span style="font-style:italic">k</span>&lt;1, ∀ <span style="font-style:italic">x</span>,<span style="font-style:italic">y</span> ∈ <span style="font-style:italic">I</span>,    |<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>)| ≤ <span style="font-style:italic">k</span> |<span style="font-style:italic">x</span>−<span style="font-style:italic">y</span>|</td></tr>
</table><em>
Alors pour tout </em><span style="font-style:italic">u</span><sub>0</sub> ∈ <span style="font-style:italic">I</span><em>, la suite </em>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)<em> définie par
</em><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)<em> converge vers l’unique solution dans </em><span style="font-style:italic">I</span><em> de </em><span style="font-style:italic">f</span>(<span style="font-style:italic">l</span>)=<span style="font-style:italic">l</span><em>.
</em></div><p>
La démonstration de la convergence est un peu différente de celle 
donnée en
dimension 1, on montre que (<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>) est une suite de Cauchy, car pour <span style="font-style:italic">n</span>&gt;<span style="font-style:italic">m</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">m</span></sub>| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=<span style="font-style:italic">m</span></td></tr>
</table></td><td class="dcell">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">j</span>+1</sub>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">j</span></sub> | 
≤ <span style="font-style:italic">k</span><sup><span style="font-style:italic">m</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> |<span style="font-style:italic">u</span><sub>1</sub>−<span style="font-style:italic">u</span><sub>0</sub>| </td></tr>
</table><p>
donc (<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>) est convergente puisque nous sommes dans un fermé 
d’un espace complet. (Cela permet d’ailleurs de généraliser 
l’énoncé donné en dimension 1 au cas où <span style="font-style:italic">a</span> ou <span style="font-style:italic">b</span> est infini).</p><p>La vitesse de convergence est linéaire, la démonstration est
identique à celle de la dimension 1.</p><p>Remarque : 
</p><ul class="itemize"><li class="li-itemize">
L’existence d’un point fixe sans hypothèse de contractance
se généralise si <span style="font-style:italic">I</span> est un convexe compact préservé
par <span style="font-style:italic">f</span> (théorème
de Brouwer ou de Schauder).
</li><li class="li-itemize">Pour vérifier les hypothèses du théorème dans
ℝ<sup><span style="font-style:italic">n</span></sup>, il suffit de montrer que dans <span style="font-style:italic">I</span> la norme triple de <span style="font-style:italic">f</span>′
subordonnée à la norme choisie dans ℝ<sup><span style="font-style:italic">n</span></sup> est inférieure
à <span style="font-style:italic">k</span>&lt;1. Pour <span style="font-style:italic">f</span> linéaire,
cela revient à calculer une norme subordonnée de matrice
et donne lieu à des méthodes itératives alternatives à
l’inversion de matrice, cf. la section <a href="#sec%3Ajacobi">22.9.2</a>.
</li><li class="li-itemize">l’algorithme de recherche
PageRank de google utilise le point fixe, en très grande dimension :
<span style="font-style:italic">n</span> est le nombre de pages Web, <span style="font-style:italic">I</span> est l’ensemble des vecteurs
de ℝ<sup><span style="font-style:italic">n</span></sup> dont toutes les coordonnées sont positives ou nulles et
dont la somme des coordonnées vaut 1, <span style="font-style:italic">f</span> est la somme d’un vecteur
constant et du produit du vecteur <span style="font-style:italic">x</span> par une matrice <span style="font-style:italic">A</span> transposée
d’une matrice stochastique.
</li></ul>
<!--TOC subsection id="sec211" La méthode de Newton dans ℝ.-->
<h3 id="sec211" class="subsection">21.4  La méthode de Newton dans ℝ.</h3><!--SEC END --><p>
La méthode de Newton est une méthode de résolution de l’équation
<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=0, attention à la différence avec le théorème du point fixe
qui permet de résoudre numériquement <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">x</span>.
Si <span style="font-style:italic">x</span><sub>0</sub> est proche de la racine <span style="font-style:italic">r</span>
on peut faire un développement de Taylor à l’ordre 1 de la
fonction <span style="font-style:italic">f</span> en <span style="font-style:italic">x</span><sub>0</sub> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>0</sub>)+(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)<span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span><sub>0</sub>)+<span style="font-style:italic">O</span>((<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)<sup>2</sup>) </td></tr>
</table><p>
Pour trouver une valeur approchée de <span style="font-style:italic">r</span>, on ne garde que la partie
linéaire du développement, on résout :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">r</span>)=0 ≈ <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>0</sub>) + (<span style="font-style:italic">r</span>−<span style="font-style:italic">x</span><sub>0</sub>) <span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span><sub>0</sub>) </td></tr>
</table><p>
donc (si <span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span><sub>0</sub>)≠ 0) :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">r</span> ≈ <span style="font-style:italic">x</span><sub>0</sub> −</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>0</sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span><sub>0</sub>)</td></tr>
</table></td></tr>
</table><p>
Graphiquement, cela revient à tracer la tangente à la courbe représentative
de <span style="font-style:italic">f</span> et à chercher où elle coupe l’axe des <span style="font-style:italic">x</span>.
On considère donc la suite récurrente définie par une valeur <span style="font-style:italic">u</span><sub>0</sub>
proche de la racine et par la relation :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub> = <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> −</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
</table></td></tr>
</table><p>Il y a deux théorèmes importants, l’un d’eux prouve que
si <span style="font-style:italic">u</span><sub>0</sub> est “assez proche” de <span style="font-style:italic">r</span> alors la suite <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> converge vers <span style="font-style:italic">r</span>,
malheureusement il est difficile de savoir en pratique si on est 
“assez proche” de <span style="font-style:italic">u</span><sub>0</sub> pour que ce théorème s’applique. Le second
théorème donne un critère pratique facile à vérifier qui assure
la convergence, il utilise les propriétés de convexité de la fonction.</p><div class="theorem"><span style="font-weight:bold">Théorème 41</span>  <em> </em><a id="hevea_default236"></a><em>
Soit </em><span style="font-style:italic">f</span><em> une fonction de classe </em><span style="font-style:italic">C</span><sup>2</sup><em> (2 fois continument dérivable)
sur un intervalle fermé </em><span style="font-style:italic">I</span><em>. Soit </em><span style="font-style:italic">r</span><em> une racine simple de </em><span style="font-style:italic">f</span><em>
située à l’intérieur de </em><span style="font-style:italic">I</span><em>
(telle que </em><span style="font-style:italic">f</span>(<span style="font-style:italic">r</span>)=0<em> et </em><span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span>)≠ 0<em>). Alors il existe </em>ε&gt;0<em>
tel que la suite définie par
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub> = <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> −</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
</table></td><td class="dcell"><em>,    |</em><em><span style="font-style:italic">u</span></em><sub><em>0</em></sub><em>−</em><em><span style="font-style:italic">r</span></em><em>| ≤ ε </em></td></tr>
</table><em>
converge vers </em><span style="font-style:italic">r</span><em>.</em><p><em>Si on a </em>|<span style="font-style:italic">f</span>′′| ≤ <span style="font-style:italic">M</span><em> et </em>|1/<span style="font-style:italic">f</span>′| ≤ <span style="font-style:italic">m</span><em> sur un intervalle 
</em>[<span style="font-style:italic">r</span>−η,<span style="font-style:italic">r</span>+η]<em> contenu dans </em><span style="font-style:italic">I</span><em>, alors on peut prendre tout réel
</em>ε&gt;0<em> tel que </em>ε &lt; 2/(<span style="font-style:italic">mM</span>)<em> et </em>ε ≤ η<em>.
</em></p></div><p><span style="font-weight:bold">Démonstration</span> : on a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">r</span> = <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> − <span style="font-style:italic">r</span> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
</table></td><td class="dcell"> = 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span>)<span style="font-style:italic">f</span>′(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
En appliquant un développement de Taylor de <span style="font-style:italic">f</span> en <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> à l’ordre 2,
on obtient pour un réel θ
situé entre <span style="font-style:italic">r</span> et <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">0 = <span style="font-style:italic">f</span>(<span style="font-style:italic">r</span>)=<span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)+(<span style="font-style:italic">r</span>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>) <span style="font-style:italic">f</span>′(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>) + (<span style="font-style:italic">r</span>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)<sup>2</sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′′(θ)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span>)<span style="font-style:italic">f</span>′(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)= (<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span>)<sup>2</sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′′(θ)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
d’où :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">r</span>| ≤ |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span>|<sup>2</sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">f</span>′(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)|</td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">f</span>′′(θ)|</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
On commence par choisir un intervalle [<span style="font-style:italic">r</span>−ε,<span style="font-style:italic">r</span>+ε]
contenant strictement <span style="font-style:italic">r</span> et tel que |<span style="font-style:italic">f</span>′′|&lt;<span style="font-style:italic">M</span> et |1/<span style="font-style:italic">f</span>′|&lt;<span style="font-style:italic">m</span>
sur [<span style="font-style:italic">r</span>−ε,<span style="font-style:italic">r</span>+ε] (c’est toujours possible car
<span style="font-style:italic">f</span>′′ et 1/<span style="font-style:italic">f</span>′ sont continues au voisinage de <span style="font-style:italic">r</span> puisque <span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span>)≠ 0).
Si <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> est dans cet intervalle, alors θ aussi donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><a id="eq:newton"></a>
|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">r</span>| ≤ |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span>|<sup>2</sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Mm</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> ≤  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span>|<span style="font-style:italic">Mm</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">
|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span>|,  
    (43)</td></tr>
</table><p>
On a |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span>| ≤ ε, on diminue si nécessaire
ε pour avoir ε &lt; 2/(<span style="font-style:italic">Mm</span>), on a alors :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">r</span>| ≤ <span style="font-style:italic">k</span> |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span>|,    <span style="font-style:italic">k</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ε <span style="font-style:italic">Mm</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">&lt;1  </td></tr>
</table><p>
donc d’une part <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub> est encore dans l’intervalle 
[<span style="font-style:italic">r</span>−ε,<span style="font-style:italic">r</span>+ε] 
ce qui permettra de refaire le même raisonnement au rang
suivant, et d’autre part
on a une convergence au moins géométrique vers <span style="font-style:italic">r</span>.
En fait la convergence est bien meilleure
lorsqu’on est proche de <span style="font-style:italic">r</span> grace au carré dans |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span>|<sup>2</sup>,
plus précisément, on montre par récurrence que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span>| ≤ |<span style="font-style:italic">u</span><sub>0</sub> − <span style="font-style:italic">r</span>|<sup>2<sup><span style="font-style:italic">n</span></sup></sup> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Mm</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">2<sup><span style="font-style:italic">n</span></sup>−1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td></tr>
</table><p>
il faut donc un nombre d’itérations proportionnel à ln(<span style="font-style:italic">n</span>)
pour atteindre une précision donnée.</p><p><span style="font-weight:bold">Remarque :</span> ce théorème se généralise sur ℂ et même sur ℝ<sup><span style="font-style:italic">n</span></sup>
(cf. la section suivante).</p><p><span style="font-weight:bold">Exemple :</span> pour calculer √<span style="text-decoration:overline">2</span>, on écrit l’équation <span style="font-style:italic">x</span><sup>2</sup>−2=0
qui a √<span style="text-decoration:overline">2</span> comme racine simple sur <span style="font-style:italic">I</span>=[1/2,2], 
on obtient la suite récurrente
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub> = <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub><sup>2</sup>−2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Si on prend η=1/2, on a <span style="font-style:italic">f</span>′=2<span style="font-style:italic">x</span> et <span style="font-style:italic">f</span>′′=2
donc on peut prendre <span style="font-style:italic">M</span>=2 et <span style="font-style:italic">m</span>=1 car |1/<span style="font-style:italic">f</span>′|≤ 1 sur 
[√<span style="text-decoration:overline">2</span>−1/2,√<span style="text-decoration:overline">2</span>+1/2]. On a 2/(<span style="font-style:italic">mM</span>)=1, on peut donc 
prendre ε=1/2, la suite convergera pour tout 
 <span style="font-style:italic">u</span><sub>0</sub> ∈ [√<span style="text-decoration:overline">2</span>−1/2,√<span style="text-decoration:overline">2</span>+1/2].</p><p>Plus généralement, on peut calculer une racine <span style="font-style:italic">k</span>-ième d’un réel <span style="font-style:italic">a</span>
en résolvant <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup>−<span style="font-style:italic">a</span> par la méthode de Newton.</p><p>L’inconvénient de ce théorème
est qu’il est difficile de savoir si la valeur de départ qu’on
a choisie se trouve suffisamment près d’une racine pour que
la suite converge. Pour illustrer le phénomène, 
on peut par exemple colorer les points du plan
complexe en <span style="font-style:italic">n</span>+1 couleurs selon que la suite définie par la méthode
de Newton converge vers l’une des <span style="font-style:italic">n</span> racines d’un polynôme de degré
<span style="font-style:italic">n</span> fixé au bout de par exemple 50 itérations (la <span style="font-style:italic">n</span>+1-ième couleur
servant aux origines de suite qui ne semblent pas converger).</p><p>Passons maintenant à un critère très utile en pratique :
</p><div class="theorem"><span style="font-weight:bold">Définition 42</span>  <em> (</em><em><span style="font-weight:bold">convexité</span></em><em>)</em><a id="hevea_default237"></a><em><br>
Une fonction </em><span style="font-style:italic">f</span><em> continument dérivable sur un intervalle </em><span style="font-style:italic">I</span><em> de </em>ℝ<em>
est dite convexe si son graphe est au-dessus de la tangente en tout point
de </em><span style="font-style:italic">I</span><em>.
</em></div><p>
Il existe un critère simple permettant de savoir si
une fonction de classe <span style="font-style:italic">C</span><sup>2</sup> est convexe :
</p><div class="theorem"><span style="font-weight:bold">Théorème 43</span>  <em>
Si </em><span style="font-style:italic">f</span><em> est </em><span style="font-style:italic">C</span><sup>2</sup><em> et </em><span style="font-style:italic">f</span>′′ ≥ 0<em> sur </em><span style="font-style:italic">I</span><em> alors </em><span style="font-style:italic">f</span><em> est convexe.
</em></div><p>
<span style="font-weight:bold">Démonstration</span> :<br>
L’équation de la tangente au graphe en <span style="font-style:italic">x</span><sub>0</sub> est 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>0</sub>)+<span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span><sub>0</sub>)(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>) </td></tr>
</table><p>
Soit
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)−(<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>0</sub>)+<span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span><sub>0</sub>)(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)) </td></tr>
</table><p>
on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">g</span>(<span style="font-style:italic">x</span><sub>0</sub>)=0,    <span style="font-style:italic">g</span>′(<span style="font-style:italic">x</span>)=<span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span>)−<span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span><sub>0</sub>),    <span style="font-style:italic">g</span>′(<span style="font-style:italic">x</span><sub>0</sub>)=0, 
   <span style="font-style:italic">g</span>′′=<span style="font-style:italic">f</span>′′ ≥ 0 </td></tr>
</table><p>
donc <span style="font-style:italic">g</span>′ est croissante, comme <span style="font-style:italic">g</span>′(<span style="font-style:italic">x</span><sub>0</sub>)=0, <span style="font-style:italic">g</span>′ est négative
pour <span style="font-style:italic">x</span>&lt;<span style="font-style:italic">x</span><sub>0</sub> et positive pour <span style="font-style:italic">x</span>&gt;<span style="font-style:italic">x</span><sub>0</sub>, donc <span style="font-style:italic">g</span> est décroissante
pour <span style="font-style:italic">x</span>&lt;<span style="font-style:italic">x</span><sub>0</sub> et croissante pour <span style="font-style:italic">x</span>&gt;<span style="font-style:italic">x</span><sub>0</sub>. On conclut alors que
<span style="font-style:italic">g</span> ≥ 0 puisque <span style="font-style:italic">g</span>(<span style="font-style:italic">x</span><sub>0</sub>)=0. Donc <span style="font-style:italic">f</span> est bien au-dessus
de sa tangente.</p><p>On arrive au deuxième théorème sur la méthode de Newton
</p><div class="theorem"><span style="font-weight:bold">Théorème 44</span>  <em> </em><a id="hevea_default238"></a><em>
Si </em><span style="font-style:italic">f</span>(<span style="font-style:italic">r</span>)=0, <span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span>)&gt;0<em> et si </em><span style="font-style:italic">f</span>′′ ≥ 0<em> sur </em>[<span style="font-style:italic">r</span>,<span style="font-style:italic">b</span>]<em> alors
pour tout </em><span style="font-style:italic">u</span><sub>0</sub> ∈ [<span style="font-style:italic">r</span>,<span style="font-style:italic">b</span>]<em> la suite de la méthode de Newton
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub> = <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> −</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
</table></td><td class="dcell"><em>,  </em></td></tr>
</table><em>
est définie, décroissante, minorée par </em><span style="font-style:italic">r</span><em> et converge vers 
</em><span style="font-style:italic">r</span><em>. De plus
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">0 ≤ <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> −<span style="font-style:italic">r</span> ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span>)</td></tr>
</table></td><td class="dcell"><em> </em></td></tr>
</table><em>
(On prendra garde dans cette estimation aux erreurs en calcul
approché, le calcul de la valeur de </em><span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)<em>, proche de 0, va typiquement
faire intervenir la différence de deux termes très proches,
d’où perte de précision sur la mantisse)
</em></div><p><span style="font-weight:bold">Démonstration</span> :<br>
On a <span style="font-style:italic">f</span>′′ ≥ 0 donc si <span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span>)&gt;0 alors <span style="font-style:italic">f</span>′&gt;0
sur [<span style="font-style:italic">r</span>,<span style="font-style:italic">b</span>], <span style="font-style:italic">f</span> est donc strictement croissante sur [<span style="font-style:italic">r</span>,<span style="font-style:italic">b</span>]
on en déduit que <span style="font-style:italic">f</span>&gt;0 sur ]<span style="font-style:italic">r</span>,<span style="font-style:italic">b</span>] donc <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub> ≤ <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>.
Comme la courbe représentative de <span style="font-style:italic">f</span> est au-dessus de la tangente,
on a <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub> ≥ <span style="font-style:italic">r</span> (car <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub> est l’abscisse du point
d’intersection de la tangente avec l’axe des <span style="font-style:italic">x</span>). 
La suite <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> est donc décroissante minorée par <span style="font-style:italic">r</span>, donc convergente
vers une limite <span style="font-style:italic">l</span>≥ <span style="font-style:italic">r</span>. À la limite, on a 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">l</span>=<span style="font-style:italic">l</span>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(<span style="font-style:italic">l</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′(<span style="font-style:italic">l</span>)</td></tr>
</table></td><td class="dcell"> ⇒ <span style="font-style:italic">f</span>(<span style="font-style:italic">l</span>)=0 </td></tr>
</table><p>
donc <span style="font-style:italic">l</span>=<span style="font-style:italic">r</span> car <span style="font-style:italic">f</span>&gt;0 sur ]<span style="font-style:italic">r</span>,<span style="font-style:italic">b</span>].</p><p>Comme (<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>) est décroissante, on a bien 0 ≤ <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> −<span style="font-style:italic">r</span>,
pour montrer l’autre inégalité, on applique le théorème
des accroissements finis, il existe θ ∈ [<span style="font-style:italic">r</span>,<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>] tel que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">r</span>)=(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span>)<span style="font-style:italic">f</span>′(θ) </td></tr>
</table><p>
comme <span style="font-style:italic">f</span>(<span style="font-style:italic">r</span>)=0, on a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>′(θ)</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
et la deuxième inégalité du théorème
en découle parce que <span style="font-style:italic">f</span>′ est croissante.</p><p><span style="font-weight:bold">Variantes</span> :<br>
Il existe des variantes, par exemple si <span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span>)&lt;0 et <span style="font-style:italic">f</span>′′ ≥ 0
sur [<span style="font-style:italic">a</span>,<span style="font-style:italic">r</span>]. Si <span style="font-style:italic">f</span>′′ ≤ 0, on considère <span style="font-style:italic">g</span>=−<span style="font-style:italic">f</span>.</p><p><span style="font-weight:bold">Application</span> :<br>
On peut calculer la valeur approchée de la 
racine <span style="font-style:italic">k</span>-ième d’un réel <span style="font-style:italic">a</span>&gt;0 en appliquant ce deuxième
théorème. En effet si
<span style="font-style:italic">a</span>&gt;0, alors <span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup>−<span style="font-style:italic">a</span> est 2 fois continument dérivable et 
de dérivée première <span style="font-style:italic">kx</span><sup><span style="font-style:italic">k</span>−1</sup>  et
seconde <span style="font-style:italic">k</span>(<span style="font-style:italic">k</span>−1)<span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span>−2</sup> strictement positives sur ℝ<sup>+∗</sup> (car <span style="font-style:italic">k</span> ≥ 2).
Il suffit donc de prendre une valeur de départ <span style="font-style:italic">u</span><sub>0</sub> plus grande que
la racine <span style="font-style:italic">k</span>-ième, par exemple 1+<span style="font-style:italic">a</span>/<span style="font-style:italic">k</span> (en effet
(1+<span style="font-style:italic">a</span>/<span style="font-style:italic">k</span>)<sup><span style="font-style:italic">k</span></sup> ≥ 1+<span style="font-style:italic">k</span> <span style="font-style:italic">a</span>/<span style="font-style:italic">k</span>=1+<span style="font-style:italic">a</span>).
En appliquant l’inégalité du théorème, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">0 ≤ <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> − </td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎝</td><td class="dcell"><span style="font-style:italic">a</span></td><td class="dcell">⎞<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td></tr>
<tr><td class="dcell">&nbsp;</td></tr>
</table></td></tr>
</table></td><td class="dcell"> ≤  
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub><sup><span style="font-style:italic">k</span></sup> − <span style="font-style:italic">a</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">k</span></td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎝</td><td class="dcell"><span style="font-style:italic">a</span></td><td class="dcell">⎞<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td></tr>
<tr><td class="dcell">&nbsp;</td></tr>
</table></td></tr>
</table></td><td class="dcell"><sup><span style="font-style:italic">k</span>−1</sup> </td></tr>
</table></td></tr>
</table></td><td class="dcell">
≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub><sup><span style="font-style:italic">k</span></sup>−<span style="font-style:italic">a</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ka</span></td></tr>
</table></td><td class="dcell">  </td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎝</td><td class="dcell"><span style="font-style:italic">a</span></td><td class="dcell">⎞<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td></tr>
<tr><td class="dcell">&nbsp;</td></tr>
</table></td></tr>
</table></td><td class="dcell">
≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub><sup><span style="font-style:italic">k</span></sup>−<span style="font-style:italic">a</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ka</span></td></tr>
</table></td><td class="dcell"> (1+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">)
</td></tr>
</table><p>
Pour avoir une valeur approchée de (<span style="font-style:italic">a</span>)<sup>1/<span style="font-style:italic">k</span></sup> à ε près,
on peut donc choisir comme test d’arrêt 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub><sup><span style="font-style:italic">k</span></sup> −<span style="font-style:italic">a</span> ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ka</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> ε </td></tr>
</table><p>
Par exemple pour √<span style="text-decoration:overline">2</span>, le test d’arrêt serait 
<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub><sup>2</sup>−2 ≤ 2 ε.</p>
<!--TOC subsection id="sec212" La méthode de Newton dans ℝ<sup><span style="font-style:italic">n</span></sup>.-->
<h3 id="sec212" class="subsection">21.5  La méthode de Newton dans ℝ<sup><span style="font-style:italic">n</span></sup>.</h3><!--SEC END --><p>
Le premier énoncé du cas de la dimension 1 se généralise en :
</p><div class="theorem"><span style="font-weight:bold">Théorème 45</span>  <em> </em><a id="hevea_default239"></a><em>
Soit </em><span style="font-style:italic">f</span><em> une fonction de classe </em><span style="font-style:italic">C</span><sup>2</sup><em> (2 fois continument dérivable)
sur un fermé </em><span style="font-style:italic">I</span><em> de </em>ℝ<sup><span style="font-style:italic">n</span></sup><em>. Soit </em><span style="font-style:italic">r</span><em> une racine simple de </em><span style="font-style:italic">f</span><em>
située à l’intérieur de </em><span style="font-style:italic">I</span><em>
(telle que </em><span style="font-style:italic">f</span>(<span style="font-style:italic">r</span>)=0<em> et </em><span style="font-style:italic">f</span>′(<span style="font-style:italic">r</span>)=(∂<sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>)(<span style="font-style:italic">r</span>)<em> inversible). 
Alors il existe </em>ε&gt;0<em>
tel que la suite définie par
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub> = <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> −(<span style="font-style:italic">f</span>′(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>) )<sup>−1</sup><span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>),    |<span style="font-style:italic">u</span><sub>0</sub>−<span style="font-style:italic">r</span>| ≤ ε </td></tr>
</table><em>
converge vers </em><span style="font-style:italic">r</span><em>.</em><p><em>Si on a </em>|<span style="font-style:italic">f</span>′′| ≤ <span style="font-style:italic">M</span><em> et </em>|(<span style="font-style:italic">f</span>′)<sup>−1</sup>| ≤ <span style="font-style:italic">m</span><em> sur une boule
centré en </em><span style="font-style:italic">r</span><em> de rayon </em>η&gt;0<em> contenue dans </em><span style="font-style:italic">I</span><em>, alors on peut prendre tout réel
</em>ε&gt;0<em> tel que </em>ε &lt; 2/(<span style="font-style:italic">mM</span>)<em> et </em>ε ≤ η<em>.
</em></p></div><p>
La démonstration est calquée sur la dimension 1, mais il faut
prendre le reste intégral dans la formule de Taylor
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">r</span> = <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> − <span style="font-style:italic">r</span> − <span style="font-style:italic">f</span>′(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)<sup>−1</sup> <span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>) = 
<span style="font-style:italic">f</span>′(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)<sup>−1</sup> (<span style="font-style:italic">f</span>′(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>) ) </td></tr>
</table><p>
puis on applique Taylor le long du segment [<span style="font-style:italic">r</span>,<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>] :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">0 = <span style="font-style:italic">f</span>(<span style="font-style:italic">r</span>)=<span style="font-style:italic">f</span>(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)+ <span style="font-style:italic">f</span>′(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>) (<span style="font-style:italic">r</span>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)+  </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> (1−θ)(<span style="font-style:italic">r</span>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)
<span style="font-style:italic">f</span>′′(<span style="font-style:italic">r</span>+θ (<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span>)) (<span style="font-style:italic">r</span>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)   <span style="font-style:italic">d</span>θ </td></tr>
</table><p>
donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">r</span> =−<span style="font-style:italic">f</span>′(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)<sup>−1</sup>  (<span style="font-style:italic">r</span>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>) 
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> (1−θ)<span style="font-style:italic">f</span>′′(<span style="font-style:italic">r</span>+θ (<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">r</span>))   <span style="font-style:italic">d</span>θ </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">(<span style="font-style:italic">r</span>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)  </td></tr>
</table><p>
et on en déduit (<a href="#eq%3Anewton">43</a>) et on conclut de même en
remplaçant intervalle centré en <span style="font-style:italic">r</span> de rayon ε
par boule de rayon ε.</p><p>Remarque : la convergence “numérique” (au sens du calcul en
flottant) de la suite <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> ne suffit pas à montrer l’existence
d’une racine proche de <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>. Une méthode de preuve alternative
au calcul des constantes <span style="font-style:italic">m</span> et <span style="font-style:italic">M</span> consiste
à trouver un rectangle ou une boule autour de <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> préservée
par l’application <span style="font-style:italic">x</span>→ <span style="font-style:italic">x</span>−<span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span>)<sup>−1</sup> <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>).</p>
<!--TOC subsection id="sec213" Calcul approché des racines complexes simples-->
<h3 id="sec213" class="subsection">21.6  Calcul approché des racines complexes simples</h3><!--SEC END --><p> 
<a id="hevea_default240"></a> <a id="hevea_default241"></a> <a id="sec:proot"></a>
La section précédente nous a montré qu’on pouvait
se ramener à la recherche de racines simples, ce qui 
donne envie d’essayer la méthode de Newton. On a malheureusement
rarement la possibilité de pouvoir démontrer qu’à partir d’une valeur
initiale donnée, la méthode de Newton converge, 
parce que les racines peuvent être complexes, et même si elles
sont réelles, on n’a pas forcément de résultat sur la convexité
du polynôme (cf. cependant une application des suites de
Sturm qui permet de connaitre le signe
de <span style="font-style:italic">P</span>′′ sur un intervalle sans le factoriser).</p><p>Par contre, on peut montrer à postériori des estimations sur la
distance entre une racine approchée et la racine la plus proche
d’un polynôme, plus précisément cette distance est inférieure
ou égale au degré du polynôme multiplié par le module
de <span style="font-style:italic">P</span>/<span style="font-style:italic">P</span>′ en la racine approchée (<a href="#sec%3Aautres_algorithmes">7.3</a>).</p><p>On effectue donc souvent des itérations de Newton, en partant de
0.0, en espérant s’approcher suffisamment d’une racine pour que
le théorème de convergence théorique s’applique. On se fixe
un nombre maximal d’itérations, si on le dépasse on prend alors
une valeur initiale aléatoire complexe et on recommence.</p><p>Une fois une racine déterminée, on l’élimine en calculant
le quotient euclidien <span style="font-style:italic">Q</span> de <span style="font-style:italic">P</span> par <span style="font-style:italic">X</span>−<span style="font-style:italic">r</span> (par l’algorithme de Horner),
puis on calcule les racines du quotient <span style="font-style:italic">Q</span> (qui sont des racines de <span style="font-style:italic">P</span>).</p><p>Un problème pratique apparait alors, c’est que <span style="font-style:italic">r</span> n’est pas exact
donc le quotient <span style="font-style:italic">Q</span> non plus, au fur et à mesure du calcul des
racines de <span style="font-style:italic">P</span>, on perd de plus en plus de précision.
Il existe une amélioration simple, si <span style="font-style:italic">r</span>′ est une racine
approchée de <span style="font-style:italic">Q</span>, alors elle est racine approchée de <span style="font-style:italic">P</span>
et on a toutes les chances qu’elle soit suffisamment proche
d’une racine de <span style="font-style:italic">P</span> pour que le théorème s’applique, on
effectue alors 1 ou 2 itérations de Newton avec <span style="font-style:italic">r</span>′ mais pour <span style="font-style:italic">P</span>
(et non <span style="font-style:italic">Q</span>) afin d’améliorer sa précision comme racine de <span style="font-style:italic">P</span>.</p><p>Une méthode de calcul plus stable utilise la recherche des valeurs
propres de la matrice companion en double précision, 
puis affine par la méthode de
Newton pour obtenir des valeurs approchées multi-précision,
c’est ce que fait <code>proot</code>, par exemple <code>proot(x^3+x+1,50)</code>.
Il existe aussi un algorithme de recherche de racines
dû à Schönhage dont la convergence
est garantie, cet algorithme est implémenté dans PARI (voir
la thèse de Xavier Gourdon et l’article Splitting circle method de Wikipedia)
et est appelé par Xcas pour des polynômes mals conditionnés.</p><p>Enfin, on peut appliquer directement la méthode de Newton pour
trouver dans ℂ<sup><span style="font-style:italic">n</span></sup> toutes les racines simultanément, c’est la
méthode de <span style="font-weight:bold">Durand-Kerner, Weierstrass</span><a id="hevea_default242"></a>.
On pose <span style="font-style:italic">g</span><sub><span style="font-style:italic">x</span></sub>(<span style="font-style:italic">z</span>)=∏<sub><span style="font-style:italic">i</span>=1</sub><sup><span style="font-style:italic">n</span></sup> (<span style="font-style:italic">x</span>−<span style="font-style:italic">z</span><sub><span style="font-style:italic">i</span></sub>), il s’agit de résoudre en <span style="font-style:italic">z</span>
<span style="font-style:italic">g</span><sub><span style="font-style:italic">x</span></sub>(<span style="font-style:italic">z</span>)=<span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>). On a a l’ordre 1 en <span style="font-style:italic">z</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">g</span><sub><span style="font-style:italic">x</span></sub>(<span style="font-style:italic">z</span>+<span style="font-style:italic">w</span>)=<span style="font-style:italic">g</span><sub><span style="font-style:italic">x</span></sub>(<span style="font-style:italic">z</span>) − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">w</span><sub><span style="font-style:italic">i</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span> ≠ <span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">x</span>−<span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub>) +<span style="font-style:italic">O</span>(<span style="font-style:italic">w</span><sup>2</sup>)
=<span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)</td></tr>
</table><p>
pour trouver <span style="font-style:italic">w</span><sub><span style="font-style:italic">i</span></sub>, on pose <span style="font-style:italic">x</span>=<span style="font-style:italic">z</span><sub><span style="font-style:italic">i</span></sub>, on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span> ≠ <span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">z</span><sub><span style="font-style:italic">i</span></sub>−<span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub>) <span style="font-style:italic">w</span><sub><span style="font-style:italic">i</span></sub> = <span style="font-style:italic">P</span>(<span style="font-style:italic">z</span><sub><span style="font-style:italic">i</span></sub>)</td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">w</span><sub><span style="font-style:italic">i</span></sub>=−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span>(<span style="font-style:italic">z</span><sub><span style="font-style:italic">i</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span> ≠ <span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">z</span><sub><span style="font-style:italic">i</span></sub>−<span style="font-style:italic">z</span><sub><span style="font-style:italic">j</span></sub>)</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
On peut aussi calculer le produit du dénominateur en effectuant
<span style="font-style:italic">g</span><sub><span style="font-style:italic">x</span></sub>′(<span style="font-style:italic">z</span><sub><span style="font-style:italic">i</span></sub>) (la dérivée porte sur <span style="font-style:italic">x</span>). 
On retrouve la méthode de Newton à une variable
où la dérivée du polynôme au dénominateur est remplacée 
par la valeur approchée du polynôme.
D’où le programme
</p><pre class="verbatim">dw(P,N,eps):={ // Weierstrass, Durand-Kerner polynomial rooter
  local l,v,w,n,j,k,q,q1;
  P:=P/lcoeff(P);
  n:=degree(P);
  assume(l,symbol);
  v:=seq(exp(i*l/n*2.0*pi),l,0,n-1); w:=v;
  for k from 1 to N do
    q:=pcoeff(v);
    q1:=q';
    for j from 0 to n-1 do
      w[j]:=v[j]-horner(P,v[j])/horner(q1,v[j]);
    od;
    if (l2norm(w-v)&lt;eps*l2norm(v))
      return w;
    v:=w;
  od;
  retourne "max iter reached";
}:;
</pre><p>Par exemple <code>dw(x^3+x+1,100,1e-10)</code> renvoie des valeurs
approchées des racines de <span style="font-style:italic">x</span><sup>3</sup>+<span style="font-style:italic">x</span>+1.</p><p>Si on s’intéresse seulement à la racine de module maximal d’un
polynôme, on peut
en trouver une estimation assez simplement en appliquant la méthode
de la puissance à la matrice companion du polynôme.
On peut améliorer la précision d’une racine
par des itérations inverses ou par la méthode de Newton en une
variable.</p>
<!--TOC subsection id="sec214" Méthodes de gradient (sans contrainte)-->
<h3 id="sec214" class="subsection">21.7  Méthodes de gradient (sans contrainte)</h3><!--SEC END --><p>
Il s’agit ici de minimiser une fonction <span style="font-style:italic">f</span> d’un ouvert <span style="font-style:italic">U</span> de ℝ<sup><span style="font-style:italic">n</span></sup> 
à valeurs dans ℝ. Lorsque la fonction <span style="font-style:italic">f</span> est
suffisamment régulière sur <span style="font-style:italic">U</span>, une condition nécessaire
en un extremum local de l’ouvert est que la différentielle <span style="font-style:italic">df</span>
s’annulle. Réciproquement, la recherche d’une solution de <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=0
peut se ramener à minimiser ||<span style="font-style:italic">f</span>||<sup>2</sup>.
Les méthodes de gradient en dimension 2 peuvent se comprendre 
à partir de la représentation des lignes
de niveau de la fonction. Le long de la tangente à une ligne
de niveau <span style="font-style:italic">f</span> reste constant (la tangente est dans le noyau de <span style="font-style:italic">df</span>),
si on est en un point <span style="font-style:italic">v</span> de la ligne de niveau,
intuitivement suivre la direction perpendiculaire à la ligne de niveau
devrait permettre de faire diminuer <span style="font-style:italic">f</span> efficacement, c’est la ligne de
plus grande pente choisie par l’eau pour s’écouler vers le bas le
plus rapidement possible. Ceci n’est toutefois pas intrinsèque mais
dépendant du produit scalaire choisi, toutefois si on ne choisit pas la
direction du gradient, on choisira une direction de descente <span style="font-style:italic">w</span> telle
que <span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span></sub><span style="font-style:italic">f</span>(<span style="font-style:italic">w</span>)&lt;0. Pour le gradient on a bien
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span></sub><span style="font-style:italic">f</span>(−∇ <span style="font-style:italic">f</span>)=−&lt;∇ <span style="font-style:italic">f</span>|∇ <span style="font-style:italic">f</span>&gt;&lt;0</td></tr>
</table><p>
Une fois la direction de descente choisie, il faut déterminer quelle
distance parcourir dans cette direction, c’est le pas ρ et le
nouveau <span style="font-style:italic">v</span> s’obtient par la formule
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ṽ=<span style="font-style:italic">v</span> + ρ <span style="font-style:italic">w</span> = <span style="font-style:italic">v</span>−ρ ∇<sub><span style="font-style:italic">v</span></sub> <span style="font-style:italic">f</span></td></tr>
</table><p>
pour la méthode de gradient. Plusieurs choix sont possibles pour
ρ
</p><ul class="itemize"><li class="li-itemize">
ρ est fixé une fois pour toutes, c’est le gradient à
pas constant, le cout d’une itération est minimal.
</li><li class="li-itemize">on détermine ρ pour minimiser <span style="font-style:italic">f</span> le long de la
direction, c’est le gradient à pas optimial, le cout d’une
iteration peut être important car il faut minimiser une fonction
d’une variable
</li><li class="li-itemize">on détermine ρ pour faire diminuer <span style="font-style:italic">f</span> un peu et ||
∇ <span style="font-style:italic">f</span>|| suffisamment pour assurer la convergence. Les conditions
de Wolfe permettent de préciser ces objectifs. 
Pour 0&lt;ε<sub>1</sub>&lt;ε<sub>2</sub>&lt;1 fixés (par exemple
ε<sub>1</sub>=1<span style="font-style:italic">e</span>−4, ε<sub>2</sub>=0.99)
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">f</span>(<span style="font-style:italic">v</span>+ρ <span style="font-style:italic">w</span>)</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">f</span>(<span style="font-style:italic">v</span>) +ε<sub>1</sub> ρ <span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span></sub><span style="font-style:italic">f</span>(<span style="font-style:italic">w</span>) ,</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >0 ≤ −<span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span>+ρ <span style="font-style:italic">w</span></sub><span style="font-style:italic">f</span>(<span style="font-style:italic">w</span>)</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" >−ε<sub>2</sub> <span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span></sub><span style="font-style:italic">f</span>(<span style="font-style:italic">w</span>)
</td></tr>
</table></td></tr>
</table>
</li></ul><div class="theorem"><span style="font-weight:bold">Proposition 46</span>  <em>
Les conditions de Wolfe permettent d’assurer la convergence d’une
suite itérative </em><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>+ρ<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub><em> si la direction de descente
est “suffisante”, plus précisément si </em><span style="font-style:italic">f</span><em> est </em><span style="font-style:italic">C</span><sup>1</sup><em> de dérivée
lipschitizienne et bornée inférieurement, si on pose
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">cos(θ<sub><span style="font-style:italic">k</span></sub>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&lt;∇ <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>)|<span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>&gt;</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">|| ∇ <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>)|| ||<span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>||</td></tr>
</table></td></tr>
</table><em>
alors la série
</em> ∑cos(θ<sub><span style="font-style:italic">k</span></sub>)<sup>2</sup> || ∇ <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>)||<sup>2</sup> <em> converge.
Ainsi si la direction de descente forme un angle minimal avec la
tangente à la courbe de niveau (en dimension 2), </em>cos(θ<sub><span style="font-style:italic">k</span></sub>)<sup>2</sup><em>
est borné indépendamment de </em><span style="font-style:italic">k</span><em> et </em>∑|| ∇ <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>)||<sup>2</sup><em>
est convergente donc le gradient de </em><span style="font-style:italic">f</span><em> tend vers 0.
</em></div><p>
Preuve : on a avec la deuxième condition de Wolfe
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;∇ <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub>)|<span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>&gt;=<span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub></sub><span style="font-style:italic">f</span>(<span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>) 
≥ ε<sub>2</sub> <span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub></sub><span style="font-style:italic">f</span>(<span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>)= ε<sub>2</sub>&lt;∇ <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>)|<span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>&gt;</td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;∇ <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub>)−∇ <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>)|<span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>&gt;  ≥ (ε<sub>2</sub>−1) &lt;∇ <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>)|<span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>&gt;</td></tr>
</table><p>
Par Cauchy-Schwartz et en notant <span style="font-style:italic">M</span><sub>2</sub> la constante de Lipschitz de ∇ <span style="font-style:italic">f</span>
le membre de gauche est plus petit que 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|| ∇ <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub>)−∇ <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>) || || <span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub> || ≤ 
<span style="font-style:italic">M</span><sub>2</sub>||<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub>−<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>|| || <span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>|| = <span style="font-style:italic">M</span><sub>2</sub> ρ<sub><span style="font-style:italic">k</span></sub> || <span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub> ||<sup>2</sup></td></tr>
</table><p>
Donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:minor_rho"></a>
(ε<sub>2</sub>−1)&lt;∇ <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>)|<span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>&gt; ≤ <span style="font-style:italic">M</span><sub>2</sub> ρ<sub><span style="font-style:italic">k</span></sub> || <span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub> ||<sup>2</sup>
    (44)</td></tr>
</table><p>
On considère ensuite la série de terme général
<span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub>) qui est à terme positif, donc convergente
(elle ne peut tendre vers l’infini car <span style="font-style:italic">f</span> est bornée
inférieurement).
La première condition de Wolfe donne
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub>)   ≥   ε<sub>1</sub> ρ<sub><span style="font-style:italic">k</span></sub> &lt;−∇
<span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>)|<span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>&gt; </td></tr>
</table><p>
puis (<a href="#eq%3Aminor_rho">44</a>) :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub>)  ≥  
ε<sub>1</sub>  (1−ε<sub>2</sub>)&lt;∇ <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>)|<span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>&gt;<sup>2</sup></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span><sub>2</sub>  ||  <span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub> ||<sup>2</sup></td></tr>
</table></td><td class="dcell"> 
≥ 0 </td></tr>
</table><p>
d’où le résultat.</p><p>L’existence de pas de Wolfe se montre en considérant le max <span style="font-style:italic">r</span> des
pas vérifiant la première condition de Wolfe
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">v</span>+ρ <span style="font-style:italic">w</span>) ≤ <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span>) +ε<sub>1</sub> ρ <span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span></sub><span style="font-style:italic">f</span>(<span style="font-style:italic">w</span>) </td></tr>
</table><p>
C’est bien un max si la fonction
<span style="font-style:italic">f</span> est bornée inférieurement. On a alors l’égalité pour le pas
<span style="font-style:italic">r</span> (par passage à la limite des deux cotés de <span style="font-style:italic">r</span>)
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">v</span>+<span style="font-style:italic">r</span> <span style="font-style:italic">w</span>) = <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span>) +ε<sub>1</sub> <span style="font-style:italic">r</span> <span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span></sub><span style="font-style:italic">f</span>(<span style="font-style:italic">w</span>) </td></tr>
</table><p>
et l’inégalité dans l’autre sens pour un pas ρ&gt;<span style="font-style:italic">r</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">v</span>+ρ <span style="font-style:italic">w</span>) &gt; <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span>) +ε<sub>1</sub> ρ <span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span></sub><span style="font-style:italic">f</span>(<span style="font-style:italic">w</span>) </td></tr>
</table><p>
Donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">v</span>+ρ <span style="font-style:italic">w</span>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">v</span>+<span style="font-style:italic">r</span> <span style="font-style:italic">w</span>) &gt; ε<sub>1</sub> <span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span></sub><span style="font-style:italic">f</span>(<span style="font-style:italic">w</span>) (ρ −<span style="font-style:italic">r</span>)</td></tr>
</table><p>
A la limite lorsque ρ tend vers <span style="font-style:italic">r</span>, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span>+<span style="font-style:italic">rw</span></sub><span style="font-style:italic">f</span>(<span style="font-style:italic">w</span>) ≥ ε<sub>1</sub> <span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span></sub><span style="font-style:italic">f</span>(<span style="font-style:italic">w</span>) ⇒ −<span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span>+<span style="font-style:italic">rw</span></sub><span style="font-style:italic">f</span>(<span style="font-style:italic">w</span>) ≤ ε<sub>1</sub> (−<span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span></sub><span style="font-style:italic">f</span>(<span style="font-style:italic">w</span>))</td></tr>
</table><p>
et comme ε<sub>1</sub>&lt;ε<sub>2</sub> on vérifie la deuxième
condition de Wolfe.</p><p>La recherche d’un pas de Wolfe peut se faire par dichotomie. On
initialise <span style="font-style:italic">s</span><sub>−</sub>,<span style="font-style:italic">s</span><sub>+</sub>,<span style="font-style:italic">s</span>=0,+∞,estimation initiale. Puis on fait une boucle
</p><ol class="enumerate" type=1><li class="li-enumerate">
On teste si <span style="font-style:italic">s</span> vérifie la première condition de Wolfe:
</li><li class="li-enumerate">Si c’est le cas, on teste la deuxième condition de Wolfe
<ol class="enumerate" type=a><li class="li-enumerate">
si la deuxième condition est
vérifiée, on renvoie <span style="font-style:italic">s</span> qui est un pas de Wolfe. 
</li><li class="li-enumerate">Sinon
on pose <span style="font-style:italic">s</span><sub>−</sub>=<span style="font-style:italic">s</span>
et (<span style="font-style:italic">s</span>=2<span style="font-style:italic">s</span> si <span style="font-style:italic">s</span>=+∞ ou <span style="font-style:italic">s</span>=(<span style="font-style:italic">s</span><sub>−</sub>+<span style="font-style:italic">s</span><sub>+</sub>)/2 si <span style="font-style:italic">s</span><sub>+</sub>≠ +∞).
</li></ol>
</li><li class="li-enumerate">Si ce n’est pas le cas, <span style="font-style:italic">s</span> est trop
grand, on pose donc <span style="font-style:italic">s</span><sub>+</sub>=<span style="font-style:italic">s</span>, et <span style="font-style:italic">s</span>=(<span style="font-style:italic">s</span><sub>−</sub>+<span style="font-style:italic">s</span><sub>+</sub>)/2 et on reéssaie.
</li></ol><p>
Cette dichotomie est couteuse car exécutée à chaque itération
de la descente, on peut l’accélérer en interpolant <span style="font-style:italic">f</span>(<span style="font-style:italic">v</span>+<span style="font-style:italic">sw</span>) (par
exemple par un polynôme de Lagrange/Hermite de degré 3 en 0,0,<span style="font-style:italic">s</span>, <span style="font-style:italic">s</span>).</p>
<!--TOC section id="sec215" Algèbre linéaire-->
<h2 id="sec215" class="section">22  Algèbre linéaire</h2><!--SEC END --><p> <a id="sec:linalg"></a>
On présente ici des algorithmes autour de la résolution exacte
et approchée de systèmes (réduction des matrices sous forme échelonnée) 
et la recherche de valeurs propres et de vecteurs propres 
(diagonalisation et jordanisation des matrices).</p>
<!--TOC subsection id="sec216" Résolution de systèmes, calcul de déterminant.-->
<h3 id="sec216" class="subsection">22.1  Résolution de systèmes, calcul de déterminant.</h3><!--SEC END -->
<!--TOC subsubsection id="sec217" La méthode du pivot de Gauß.-->
<h4 id="sec217" class="subsubsection">22.1.1  La méthode du pivot de Gauß.</h4><!--SEC END --><p><a id="hevea_default243"></a> <a id="hevea_default244"></a>
</p><ul class="itemize"><li class="li-itemize">
Le pivot : on détermine à partir d’une ligne <span style="font-style:italic">i</span> 
la ligne <span style="font-style:italic">j</span> où apparait le premier coefficient non nul <span style="font-style:italic">p</span> dans
la colonne à réduire. On échange les lignes
<span style="font-style:italic">i</span> et <span style="font-style:italic">j</span>. Puis pour <span style="font-style:italic">j</span>&gt;<span style="font-style:italic">i</span> (réduction sous-diagonale)
ou <span style="font-style:italic">j</span>≠ <span style="font-style:italic">i</span> (réduction complète), on effectue l’opération
<span style="font-style:italic">L</span><sub><span style="font-style:italic">j</span></sub> ← <span style="font-style:italic">L</span><sub><span style="font-style:italic">j</span></sub> − <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>/<span style="font-style:italic">p</span><span style="font-style:italic">L</span><sub><span style="font-style:italic">i</span></sub>.<br>
Inconvénient : avec des données exactes de taille non bornée, 
la complexité des coefficients augmente plus vite qu’en choisissant 
le pivot le plus simple possible, (remarque, lorsque les données 
sont approchées, on n’utilise pas non plus cette méthode
pour des raisons de stabilité numérique).
Le domaine d’utilisation naturel concerne donc les coefficients
dans un corps fini (par exemple ℤ/<span style="font-style:italic">n</span>ℤ).
</li><li class="li-itemize">Le pivot partiel. On choisit le meilleur coefficient non nul de la
colonne, où meilleur dépend du type de coefficient : avec des données
exactes, on choisirait le coefficient de taille la plus petite possible,
avec des données approximatives, on choisit
le coefficient de plus grande norme dans la colonne.
Le domaine d’utilisation naturel concerne les coefficients
approchés. Pour les coefficients exacts, on remplacerait la
réduction par <span style="font-style:italic">L</span><sub><span style="font-style:italic">j</span></sub> ← <span style="font-style:italic">pL</span><sub><span style="font-style:italic">j</span></sub> −<span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">L</span><sub><span style="font-style:italic">i</span></sub> pour ne pas effectuer
de division. Mais avec cette méthode, la taille des coefficients
augmente de manière exponentielle. On peut améliorer
la taille des coefficients intermédiaires en divisant chaque
ligne par le PGCD de ses coefficients, mais comme pour le
calcul du PGCD par l’algorithme du sous-résultant, il existe
une méthode plus efficace présentée ci-dessous.
</li><li class="li-itemize">La méthode de <span style="font-weight:bold">Bareiss</span> :<a id="hevea_default245"></a> on initialise un coefficient <span style="font-style:italic">b</span> à 1.
On remplace l’étape de réduction ci-dessus
par <span style="font-style:italic">L</span><sub><span style="font-style:italic">j</span></sub> ← (<span style="font-style:italic">pL</span><sub><span style="font-style:italic">j</span></sub> −<span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">L</span><sub><span style="font-style:italic">i</span></sub>)/<span style="font-style:italic">b</span>.
À la fin de l’étape de réduction, on met le coefficient <span style="font-style:italic">b</span>
à la valeur du pivot <span style="font-style:italic">p</span>. L’intérêt de la méthode est que la division
se fait sans introduire de fraction (la preuve pour les deux premières
étapes se fait facilement à la main ou avec
un système de calcul formel (cf. infra), pour le cas général, on vérifie
que le déterminant de la matrice de départ
est égal au dernier coefficient sur la diagonale obtenu par
cette méthode de réduction, ce dernier est donc entier, le
même raisonnement fait sur des sous-matrices dont on prend les
<span style="font-style:italic">k</span> premières lignes et colonnes et une autre ligne et une autre
colonne montre que tous les coefficients des matrices intermédiaires
sont entiers).
On peut utiliser cette méthode aussi bien pour la réduction
sous-diagonale que pour la réduction complète (les lignes
intervenant dans la combinaison linéaire subissent des 
modifications identiques dans les deux cas).
</li></ul><p>
Vérifions
qu’on n’introduit pas de dénominateur dans la méthode
de Bareiss. Sans
restreindre la généralité, il suffit de le montrer avec une
matrice 3x3 à coefficients symboliques génériques. 
</p><pre class="verbatim">Pivot(M,n,m,r):={ 
 // n ligne du pivot, m colonne, r ligne a modifier
 local COL,j,a,b; 
 COL:=ncols(M);
 a:=M[n,m];
 b:=M[r,m];
 for j from 0 to COL-1 do
   // afficher(j,a,b,n,m,r);
   M[r,j]:=a*M[r,j]-b*M[n,j];
 end_for;
 return(M);
}:; 
M:=matrix(3,3,[[A,B,C],[D,E,F],[G,H,J]]);
M:=Pivot(M,0,0,1); M:=Pivot(M,0,0,2); /* 1ere colonne */
M:=Pivot(M,1,1,2); M:=Pivot(M,1,1,0); /* 2eme colonne */
factor(M[2,2]);
</pre><p>Ce qui met bien en évidence le facteur <span style="font-style:italic">A</span> dans <span style="font-style:italic">M</span><sub>3,3</sub>.</p>
<!--TOC subsubsection id="sec218" Le déterminant.-->
<h4 id="sec218" class="subsubsection">22.1.2  Le déterminant.</h4><!--SEC END --><p><a id="hevea_default246"></a>
On peut bien sûr appliquer les méthodes ci-dessus en tenant compte
des pivots utilisés et du produit des coefficients diagonaux. Dans le cas de 
la méthode de Bareiss, si on effectue la réduction sous-diagonale
uniquement, il n’est pas nécessaire de garder une trace des pivots
et de calculer le produit des coefficients diagonaux,
montrons que la valeur du déterminant est égal au 
dernier coefficient diagonal : en effet si <span style="font-style:italic">R</span> désigne la matrice réduite et
que l’on pose <span style="font-style:italic">R</span><sub>0,0</sub>=1, alors la réduction par la méthode de
Bareiss de la colonne <span style="font-style:italic">i</span> a pour effet de multiplier le déterminant 
de la matrice initiale <span style="font-style:italic">M</span> par (<span style="font-style:italic">R</span><sub><span style="font-style:italic">i</span>,<span style="font-style:italic">i</span></sub>/(<span style="font-style:italic">R</span><sub><span style="font-style:italic">i</span>−1,<span style="font-style:italic">i</span>−1</sub>)<sup><span style="font-style:italic">n</span>−<span style="font-style:italic">i</span></sup>. Donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > det(<span style="font-style:italic">R</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">det(<span style="font-style:italic">M</span>)  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=1</td></tr>
</table></td><td class="dcell">
(<span style="font-style:italic">R</span><sub><span style="font-style:italic">i</span>,<span style="font-style:italic">i</span></sub>/(<span style="font-style:italic">R</span><sub><span style="font-style:italic">i</span>−1,<span style="font-style:italic">i</span>−1</sub>)<sup><span style="font-style:italic">n</span>−<span style="font-style:italic">i</span></sup> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">R</span><sub><span style="font-style:italic">i</span>,<span style="font-style:italic">i</span></sub></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">det(<span style="font-style:italic">M</span>)  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">R</span><sub><span style="font-style:italic">i</span>,<span style="font-style:italic">i</span></sub>  </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span>,<span style="font-style:italic">n</span></sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >det(<span style="font-style:italic">M</span>)
</td></tr>
</table></td></tr>
</table><p>Pour les matrices à coefficients entiers, on peut aussi utiliser une
méthode 
<span style="font-weight:bold">modulaire</span><a id="hevea_default247"></a><a id="hevea_default248"></a> :
on calcule une borne à priori sur le déterminant
et on calcule le déterminant modulo suffisamment de petits nombres
premiers pour le reconstruire par les restes chinois. En effet
si le produit des nombres premiers utilisés
est supérieur au double d’un majorant de la valeur absolue du
déterminant, alors le déterminant est le résultat des restes chinois
écrit en représentation symétrique.
L’avantage de cet algorithme est qu’il est simple et facile à paralléliser.</p><p>On utilise souvent la <span style="font-weight:bold">borne d’Hadamard</span><a id="hevea_default249"></a> 
sur le déterminant :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|det(<span style="font-style:italic">M</span>)| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center">1≤ <span style="font-style:italic">i</span> ≤ <span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center">1≤ <span style="font-style:italic">j</span> ≤ <span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell"> |<span style="font-style:italic">m</span><sub><span style="font-style:italic">i</span>,<span style="font-style:italic">j</span></sub>|<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Preuve de la borne : on majore le déterminant par le produit des
normes des vecteurs colonnes de <span style="font-style:italic">M</span>.</p><p>L’algorithme de calcul modulaire du déterminant d’une matrice bornée
de taille <span style="font-style:italic">n</span> est en <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>4</sup> ln(<span style="font-style:italic">n</span>)) opérations, en effet 
chaque calcul modulaire
nécessite <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>3</sup>) opérations, et il faut <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span>ln(<span style="font-style:italic">n</span>)) nombres premiers
d’une taille donnée (par exemple 31 bits)
pour dépasser le double de la borne de Hadamard 
(on montre facilement que la norme
euclidienne d’une colonne de <span style="font-style:italic">A</span> est ≤ √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>||<span style="font-style:italic">A</span>||<sub>∞</sub>,
on en prend la puissance <span style="font-style:italic">n</span>-ième).
C’est meilleur que la méthode de Bareiss, qui est en 
<span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>5</sup> ln(<span style="font-style:italic">n</span>)<sup>2</sup> (avec multiplication naïve des entiers). En effet
lors de la réduction de la <span style="font-style:italic">k</span>-ième colonne, on manipule des entiers
qui sont des mineurs de taille <span style="font-style:italic">k</span> donc de taille <span style="font-style:italic">O</span>(<span style="font-style:italic">k</span>ln(<span style="font-style:italic">k</span>)), d’où
une complexité en <span style="font-style:italic">O</span>(∑<sub><span style="font-style:italic">k</span>=1</sub><sup><span style="font-style:italic">n</span>−1</sup> (<span style="font-style:italic">n</span>−<span style="font-style:italic">k</span>)<sup>2</sup> (<span style="font-style:italic">k</span>ln(<span style="font-style:italic">k</span>))<sup>2</sup> ). Mais
la méthode de Bareiss fonctionne dans bien d’autres situations, par
exemple si les coefficients sont des polynômes.</p><p><span style="font-weight:bold">Remarque</span> :<br>
Si on veut juste prouver l’inversibilité d’une matrice à coefficients
entiers, il suffit
de trouver un nombre premier <span style="font-style:italic">p</span> tel que le déterminant de cette matrice modulo
<span style="font-style:italic">p</span> soit non nul.</p><p><span style="font-weight:bold">Développement par rapport à une ligne ou une colonne</span><br>
On a tendance à oublier ce type de méthode car le développement
complet du déterminant (faisant intervenir une somme sur toutes les
permutations du groupe symétrique)
nécessite d’effectuer <span style="font-style:italic">n</span>! produits
de <span style="font-style:italic">n</span> coefficients et <span style="font-style:italic">n</span>! additions ce qui est gigantesque. Or on peut
"factoriser" une partie des calculs et se ramener à <span style="font-style:italic">n</span>.2<sup><span style="font-style:italic">n</span></sup> opérations
élémentaires au lieu de <span style="font-style:italic">n</span>.<span style="font-style:italic">n</span>!. Remarquons aussi que le nombre
d’opérations élémentaires n’a guère de sens si on ne tient pas
compte de la complexité des expressions, l’avantage principal
de la méthode de développement étant d’éviter d’effectuer
des divisions.</p><p><span style="font-weight:bold">Calcul du déterminant par développement de Laplace</span><a id="hevea_default250"></a><br>
On calcule d’abord tous les mineurs 2x2 des colonnes 1 et 2
que l’on place dans une table de mineurs,
puis on calcule les mineurs 3x3 des colonnes 1 à 3 en développant
par rapport à la colonne 3 et en utilisant les mineurs précédents,
puis les mineurs 4x4 avec les mineurs 3x3, etc.. 
On évite ainsi de recalculer plusieurs fois les mêmes mineurs.
Cf. par exemple l’implémentation en C++ dans giac/xcas
(<code>www-fourier.ujf-grenoble.fr/~parisse/giac.html</code>)
qui utilise le type générique <code>map&lt;&gt;</code> de la librairie standard C++ (STL)
pour stocker les tables de mineurs (fonction 
<code>det_minor</code> du fichier <span style="font-family:monospace">vecteur.cc</span>).<br>
Nombre d’opérations élémentaires : il y a (<sub>2</sub><sup><span style="font-style:italic">n</span></sup>) mineurs d’ordre 2
à calculer nécessitant chacun 2 multiplications (et 1 addition),
puis (<sub>3</sub><sup><span style="font-style:italic">n</span></sup>) mineurs d’ordre 3 nécessitant 3 multiplications et
2 additions, etc. donc le nombre de multiplications est de
2(<sub>2</sub><sup><span style="font-style:italic">n</span></sup>)+3(<sub>3</sub><sup><span style="font-style:italic">n</span></sup>)+...+<span style="font-style:italic">n</span>(<sub><span style="font-style:italic">n</span></sub><sup><span style="font-style:italic">n</span></sup>), celui d’additions est
(<sub>2</sub><sup><span style="font-style:italic">n</span></sup>)+2(<sub>3</sub><sup><span style="font-style:italic">n</span></sup>)+...+(<span style="font-style:italic">n</span>−1)(<sub><span style="font-style:italic">n</span></sub><sup><span style="font-style:italic">n</span></sup>) soit un nombre d’opérations
élémentaires majoré par <span style="font-style:italic">n</span>.2<sup><span style="font-style:italic">n</span></sup>.</p><p>On observe "expérimentalement" que cet algorithme est intéressant
lorsque le nombre de
paramètres dans le déterminant est grand et que la matrice est
plutôt creuse (majorité de coefficients nuls). Il existe des
heuristiques de permutation des lignes ou des colonnes visant
à optimiser la position des zéros (par exemple, les auteurs de GiNaC
(<code>www.ginac.de</code>) suite à des expérimentations
privilégient la simplification des petits mineurs en mettant les colonnes 
contenant le maximum de zéros à gauche selon la description faite
ici). </p><p>Pour se convaincre de l’intérêt de cet algorithme, on peut effectuer
le test O1 de Lewis-Wester<br>
<code>http://www.bway.net/~lewis/calatex.html</code><br>
il s’agit de calculer un déterminant de taille 15 avec 18 paramètres.</p>
<!--TOC subsubsection id="sec219" Systèmes linéaires-->
<h4 id="sec219" class="subsubsection">22.1.3  Systèmes linéaires</h4><!--SEC END --><p><a id="hevea_default251"></a>
On peut appliquer la méthode du pivot de Gauß ou les règles
de Cramer (matrices creuses avec beaucoup de paramètres par exemple). </p><p>Pour les systèmes à coefficients entiers non singuliers, 
on peut aussi utiliser une méthode <span style="font-style:italic">p</span>-adique asymptotiquement
plus efficace. On calcule d’abord une borne sur les
coefficients des fractions solutions de l’équation <span style="font-style:italic">Ax</span>=<span style="font-style:italic">b</span>
en utilisant les règles de Cramer et la borne d’Hadamard.
On calcule ensuite <span style="font-style:italic">C</span>, l’inverse de <span style="font-style:italic">A</span> modulo <span style="font-style:italic">p</span> (en changeant de <span style="font-style:italic">p</span> si
<span style="font-style:italic">A</span> n’est pas inversible modulo <span style="font-style:italic">p</span>), puis, si
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">p</span><sup><span style="font-style:italic">i</span></sup>,    <span style="font-style:italic">A</span>(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>&lt;<span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">p</span><sup><span style="font-style:italic">i</span></sup>)=<span style="font-style:italic">b</span> (mod <span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup> ) </td></tr>
</table><p>
on ajoute <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup>  et on obtient l’équation :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Ax</span><sub><span style="font-style:italic">k</span></sub> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">b</span>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span> &lt;<span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">p</span><sup><span style="font-style:italic">i</span></sup></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup></td></tr>
</table></td><td class="dcell"> (mod <span style="font-style:italic">p</span> ) </td></tr>
</table><p>
qui détermine <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>.
On s’arrête lorsque <span style="font-style:italic">k</span> est suffisamment grand pour pouvoir reconstruire
les fractions à l’aide de l’identité de Bézout (cf. infra),
ce qui est le cas si <span style="font-style:italic">p</span><sup><span style="font-style:italic">k</span></sup> est
supérieur à 4 fois la borne de Hadamard de <span style="font-style:italic">A</span> au carré.
Pour éviter de recalculer plusieurs fois <span style="font-style:italic">b</span>−∑<sub><span style="font-style:italic">i</span> &lt;<span style="font-style:italic">k</span></sub> <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">p</span><sup><span style="font-style:italic">i</span></sup>,
on utilise la récurrence suivante
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span><sub>0</sub>=<span style="font-style:italic">b</span>,    <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">Cy</span><sub><span style="font-style:italic">k</span></sub> (mod <span style="font-style:italic">p</span> ),    <span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span>+1</sub> =
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>−<span style="font-style:italic">Ax</span><sub><span style="font-style:italic">k</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span></td></tr>
</table></td></tr>
</table><p>
Pour une matrice de taille <span style="font-style:italic">n</span>, il faut <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>3</sup>) opérations
pour calculer <span style="font-style:italic">C</span>, puis <span style="font-style:italic">kn</span><sup>2</sup> ln(<span style="font-style:italic">n</span>) opérations 
pour calculer <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub> (le terme ln(<span style="font-style:italic">n</span>) 
vient de la taille des coefficients
de <span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub> dans le produit <span style="font-style:italic">Cy</span><sub><span style="font-style:italic">k</span></sub>),
donc pour pouvoir reconstruire <span style="font-style:italic">x</span>, il faut prendre <span style="font-style:italic">k</span> de l’ordre
de <span style="font-style:italic">n</span>ln(<span style="font-style:italic">n</span>), ce qui nécessite finalement <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>3</sup>ln(<span style="font-style:italic">n</span>)<sup>2</sup>) opérations.</p>
<!--TOC subsubsection id="sec220" Bézout et les <span style="font-style:italic">p</span>-adiques.-->
<h4 id="sec220" class="subsubsection">22.1.4  Bézout et les <span style="font-style:italic">p</span>-adiques.</h4><!--SEC END --><p>
Soit <span style="font-style:italic">n</span> et <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span> une fraction irréductible d’entiers tels que 
<span style="font-style:italic">b</span> est premier avec <span style="font-style:italic">n</span> et |<span style="font-style:italic">a</span>| &lt; √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>/2 et  0 ≤ <span style="font-style:italic">b</span> ≤ √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>/2.
Il s’agit de reconstruire <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> connaissant 
<span style="font-style:italic">x</span>=<span style="font-style:italic">a</span> × (<span style="font-style:italic">b</span><sup>−1</sup>) (mod <span style="font-style:italic">n</span> ) avec <span style="font-style:italic">x</span>∈ [0,<span style="font-style:italic">n</span>[.</p><p><span style="font-weight:bold">Unicité</span><br>
S’il existe une solution (<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>) vérifiant |<span style="font-style:italic">a</span>| &lt; √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>/2 et 
 0 ≤ <span style="font-style:italic">b</span> ≤ √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>/2, soit (<span style="font-style:italic">a</span>′,<span style="font-style:italic">b</span>′) une solution
de <span style="font-style:italic">x</span>=<span style="font-style:italic">a</span> × (<span style="font-style:italic">b</span><sup>−1</sup>) (mod <span style="font-style:italic">n</span> ) et 
vérifiant |<span style="font-style:italic">a</span>′| &lt; √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span> et  0 ≤ <span style="font-style:italic">b</span>′ ≤ √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>, alors :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span> <span style="font-style:italic">b</span>′=<span style="font-style:italic">a</span>′ <span style="font-style:italic">b</span> (mod <span style="font-style:italic">n</span> ) </td></tr>
</table><p>
Comme |<span style="font-style:italic">ab</span>′| &lt; <span style="font-style:italic">n</span>/2, |<span style="font-style:italic">a</span>′<span style="font-style:italic">b</span>| &lt;<span style="font-style:italic">n</span>/2, 
on en déduit que <span style="font-style:italic">ab</span>′=<span style="font-style:italic">a</span>′<span style="font-style:italic">b</span>. Donc <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>=<span style="font-style:italic">a</span>′/<span style="font-style:italic">b</span>′
donc <span style="font-style:italic">a</span>=<span style="font-style:italic">a</span>′ et <span style="font-style:italic">b</span>=<span style="font-style:italic">b</span>′ car <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span> et <span style="font-style:italic">a</span>′/<span style="font-style:italic">b</span>′ sont supposées irréductibles.</p><p><span style="font-weight:bold">Reconstruction lorsqu’on sait qu’il y a une solution</span><br>
On suit l’algorithme de calcul des coefficients de Bézout
pour les entiers <span style="font-style:italic">n</span> et <span style="font-style:italic">x</span>. On pose :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">α<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">n</span> + β<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">x</span>= <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub> </td></tr>
</table><p>
où les <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub> sont les restes successifs de l’algorithme d’Euclide,
avec la condition initiale :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">α<sub>0</sub>=1, β<sub>0</sub>=0, α<sub>1</sub>=0, β<sub>1</sub>=1, <span style="font-style:italic">r</span><sub>0</sub>=<span style="font-style:italic">n</span>, <span style="font-style:italic">r</span><sub>1</sub>=<span style="font-style:italic">x</span> </td></tr>
</table><p>
et la relation de récurrence :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">β<sub><span style="font-style:italic">k</span>+2</sub>=β<sub><span style="font-style:italic">k</span></sub> − <span style="font-style:italic">q</span><sub><span style="font-style:italic">k</span>+2</sub> β<sub><span style="font-style:italic">k</span>+1</sub>,   
<span style="font-style:italic">q</span><sub><span style="font-style:italic">k</span>+2</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub>−<span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+2</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+1</sub></td></tr>
</table></td></tr>
</table><p>On a  β<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">x</span>= <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub> (mod <span style="font-style:italic">n</span> ) pour tout rang mais il faut vérifier
les conditions de taille sur β<sub><span style="font-style:italic">k</span></sub> et <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub> pour trouver le couple
(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>).
Montrons par récurrence que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:rec"></a>
β<sub><span style="font-style:italic">k</span>+1</sub> <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub> − <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+1</sub> β<sub><span style="font-style:italic">k</span></sub> = (−1)<sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">n</span> 
    (45)</td></tr>
</table><p>
Au rang <span style="font-style:italic">k</span>=0, on vérifie l’égalité, on l’admet au rang <span style="font-style:italic">k</span>, 
alors au rang <span style="font-style:italic">k</span>+1, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > β<sub><span style="font-style:italic">k</span>+2</sub> <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+1</sub> − <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+2</sub> β<sub><span style="font-style:italic">k</span>+1</sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >β<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+1</sub> − <span style="font-style:italic">q</span><sub><span style="font-style:italic">k</span>+2</sub> <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+1</sub> β<sub><span style="font-style:italic">k</span>+1</sub>  − <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+2</sub> β<sub><span style="font-style:italic">k</span>+1</sub> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >β<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+1</sub> − (<span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub>−<span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+2</sub>) β<sub><span style="font-style:italic">k</span>+1</sub>  − <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+2</sub> β<sub><span style="font-style:italic">k</span>+1</sub> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >β<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+1</sub> − <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub> β<sub><span style="font-style:italic">k</span>+1</sub> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >− (−1)<sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">n</span>
</td></tr>
</table></td></tr>
</table><p>
On vérifie aussi que le signe de β<sub><span style="font-style:italic">k</span></sub> est positif si <span style="font-style:italic">k</span> est impair
et négatif si <span style="font-style:italic">k</span> est pair, on déduit donc de (<a href="#eq%3Arec">45</a>) :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|β<sub><span style="font-style:italic">k</span>+1</sub>| <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub> &lt; <span style="font-style:italic">n</span> </td></tr>
</table><p>
(avec égalité si <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+1</sub>=0)</p><p>Considérons la taille des restes successifs, il existe un rang <span style="font-style:italic">k</span>
tel que <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub> ≥ √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span> et <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+1</sub>&lt;√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>. On a alors
|β<sub><span style="font-style:italic">k</span>+1</sub>| &lt; <span style="font-style:italic">n</span>/<span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub> ≤ √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>.</p><p>Donc l’algorithme de Bézout permet de reconstruire l’unique couple
solution s’il existe.</p><p><span style="font-weight:bold">Exemple</span><br>
On prend <span style="font-style:italic">n</span>=101, <span style="font-style:italic">a</span>=2, <span style="font-style:italic">b</span>=3, <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>=68 (mod 101 ).
Puis on effectue Bézout pour 68 et 101 en affichant les étapes 
intermédiaires (par exemple avec <code>IEGCD</code> sur une HP49 ou exercice
avec votre système de calcul formel) :
</p><pre class="verbatim">   = alpha*101+beta*68
101    1        0
 68    0        1  L1 - 1*L2
 33    1       -1  L2 - 2*L3
  2   -2        3  ...
</pre><p>On s’arrête à la première ligne telle que le coefficient de la 1ère colonne
est inférieur à √<span style="text-decoration:overline">101</span>, on retrouve bien 2 et 3.
Quand on programme l’algorithme de
reconstruction, on ne calcule bien sûr pas la colonne des α,
ce qui donne par exemple le programme xcas ou mupad suivant :
</p><pre class="verbatim">// Renvoie a/b tel que a/b=x mod n et |a|,|b|&lt;sqrt(n)
padictofrac:=proc (n,x)
  local r0,beta0,r1,beta1,r2,q2,beta2;
begin
  r0:=n;
  beta0:=0;
  r1:=x;
  beta1:=1;
  sqrtn:=float(sqrt(n));
  while r1&gt;sqrtn do
    r2:= irem(r0,r1); 
    q2:=(r0-r2)/r1;
    beta2:=beta0-q2*beta1;
    beta0:=beta1; r0:=r1; beta1:=beta2; r1:=r2;
  end_while;
  return(r1/beta1);
end_proc;
</pre>
<!--TOC subsubsection id="sec221" Base du noyau-->
<h4 id="sec221" class="subsubsection">22.1.5  Base du noyau</h4><!--SEC END --><p><a id="hevea_default252"></a>
On présente ici deux méthodes, la première se généralise
au cas des systèmes à coefficients entiers, la deuxième
utilise un peu moins de mémoire (elle travaille sur une matrice 2 fois
plus petite).</p><p><span style="font-weight:bold">Première méthode</span>
Soir <span style="font-style:italic">M</span> la matrice dont on cherche le noyau. On ajoute à droite
de la matrice transposée de <span style="font-style:italic">M</span> une matrice identité ayant
le même nombre de lignes que <span style="font-style:italic">M</span><sup><span style="font-style:italic">t</span></sup>. On effectue une réduction
sous-diagonale qui nous amène à une matrice composée de deux
blocs
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">( <span style="font-style:italic">M</span><sup><span style="font-style:italic">t</span></sup> <span style="font-style:italic">I</span><sub><span style="font-style:italic">n</span></sub> )  →  ( <span style="font-style:italic">U</span> L ) </td></tr>
</table><p>
Attention, L n’est pas la matrice <span style="font-style:italic">L</span> de la décomposition <span style="font-style:italic">LU</span>
de <span style="font-style:italic">M</span><sup><span style="font-style:italic">t</span></sup>, on a en fait
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">L <span style="font-style:italic">M</span><sup><span style="font-style:italic">t</span></sup> = <span style="font-style:italic">U</span></td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">M</span> L<sup><span style="font-style:italic">t</span></sup> = <span style="font-style:italic">U</span><sup><span style="font-style:italic">t</span></sup> </td></tr>
</table><p>
Les colonnes de L<sup><span style="font-style:italic">t</span></sup> correspondant aux colonnes nulles de <span style="font-style:italic">U</span><sup><span style="font-style:italic">t</span></sup> 
(ou si on préfère les lignes de L correspondant
aux lignes nulles de <span style="font-style:italic">U</span>) sont donc dans le noyau de <span style="font-style:italic">M</span> et réciproquement
si <span style="font-style:italic">Mv</span>=0 alors 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">U</span><sup><span style="font-style:italic">t</span></sup> (L<sup><span style="font-style:italic">t</span></sup>)<sup>−1</sup> <span style="font-style:italic">v</span> =0 </td></tr>
</table><p>
donc, comme <span style="font-style:italic">U</span> est réduite, (L<sup><span style="font-style:italic">t</span></sup>)<sup>−1</sup> <span style="font-style:italic">v</span> est une combinaison
linéaire des vecteurs de base d’indice les lignes nulles de <span style="font-style:italic">U</span>.
Finalement, les lignes de L correspondant
aux lignes nulles de <span style="font-style:italic">U</span> forment une base du noyau de <span style="font-style:italic">M</span>.</p><p><span style="font-weight:bold">Deuxième méthode</span>
On commence bien sûr par réduire la matrice (réduction complète
en-dehors de la diagonale), et on divise chaque ligne par son
premier coefficient non nul (appelé pivot). On insère alors
des lignes de 0 pour que les pivots (non nuls) se trouvent
sur la diagonale. Puis en fin de matrice, on ajoute ou on supprime des 
lignes de 0 pour avoir une matrice carrée de dimension le nombre de colonnes
de la matrice de départ.
On parcourt alors la matrice en diagonale. Si
le <span style="font-style:italic">i</span>-ième coefficient est non nul, on passe au suivant. 
S’il est nul, alors tous
les coefficients d’indice supérieur ou égal à <span style="font-style:italic">i</span> du <span style="font-style:italic">i</span>-ième
vecteur colonne <span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub> sont nuls (mais pas forcément pour les indices
inférieurs à <span style="font-style:italic">i</span>). Si on remplace le <span style="font-style:italic">i</span>-ième coefficient de <span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub>
par -1, il est facile de se convaincre que c’est un vecteur du noyau,
on le rajoute donc à la base du noyau. On voit facilement
que tous les vecteurs de ce type forment une famille libre de
la bonne taille, c’est donc bien une base du noyau.</p>
<!--TOC subsection id="sec222" Algèbre linéaire sur ℤ-->
<h3 id="sec222" class="subsection">22.2  Algèbre linéaire sur ℤ</h3><!--SEC END -->
<!--TOC subsubsection id="sec223" Calcul du déterminant d’une matrice à coefficient entiers-->
<h4 id="sec223" class="subsubsection">22.2.1  Calcul du déterminant d’une matrice à coefficient entiers</h4><!--SEC END --><p>
L’algorithme <span style="font-style:italic">p</span>-adique de résolution de systèmes
linéaires peut servir à accélérer le calcul du
déterminant d’une matrice à coefficients entiers de grande taille.
En effet, le PPCM <span style="font-style:italic">f</span> des dénominateurs des composantes de <span style="font-style:italic">x</span> est
un diviseur du déterminant, et si <span style="font-style:italic">b</span> est choisi avec des
coefficients aléatoires, on a une forte probabilité d’obtenir
le dernier facteur invariant de la matrice <span style="font-style:italic">A</span>. Comme le déterminant
de <span style="font-style:italic">A</span> a une très faible probabilité de contenir un gros facteur
carré, ce dernier facteur invariant est très proche du
déterminant. Ce dernier est pour une matrice <span style="font-style:italic">A</span> aléatoire
lui-même à un facteur de l’ordre de (2/π)<sup><span style="font-style:italic">n</span></sup> proche
de la borne de Hadamard. Il suffit donc de très peu de nombres
premiers pour déterminer det(<span style="font-style:italic">A</span>)/<span style="font-style:italic">f</span> par le théorème
des restes chinois. En pratique pour des <span style="font-style:italic">n</span> de l’ordre de 100
à 1000, cet algorithme est plus rapide que le calcul uniquement
par les restes chinois. Pour des <span style="font-style:italic">n</span> plus grands, il faut se
rabattre sur des algorithmes probabilistes avec arrêt prématuré
pour être plus rapide (on s’arrête lorsque le déterminant
n’évolue plus par reconstruction par les restes chinois 
pour plusieurs nombres premiers successifs, le résultat n’est
alors pas certifié, c’est ce qui se passe dans Xcas si
<code>proba_epsilon</code> n’est pas nul), 
ou utiliser des méthodes
d’inversion ou de réduction de type Strassen.</p>
<!--TOC subsubsection id="sec224" Réduction de Hermite et Smith-->
<h4 id="sec224" class="subsubsection">22.2.2  Réduction de Hermite et Smith</h4><!--SEC END --><p><a id="hevea_default253"></a> <a id="hevea_default254"></a>
Lorsque <span style="font-style:italic">M</span> est une matrice à coefficients entiers, 
on ne peut plus faire l’algorithme du pivot de Gauss ou de
Gauss-Bareiss en restant dans ℤ et en étant réversible.
On peut toutefois effectuer des manipulations élémentaires
réversibles dans ℤ, grâce à l’idendité de Bézout. Si <span style="font-style:italic">a</span>
est le pivot en ligne <span style="font-style:italic">i</span>, <span style="font-style:italic">b</span> le coefficient en ligne <span style="font-style:italic">j</span> à
annuler, et <span style="font-style:italic">u</span>, <span style="font-style:italic">v</span>, <span style="font-style:italic">d</span> les coefficients de l’identité de Bézout
<span style="font-style:italic">a</span> <span style="font-style:italic">u</span> + <span style="font-style:italic">b</span> <span style="font-style:italic">v</span> =<span style="font-style:italic">d</span> on fait les changements :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">L</span><sub><span style="font-style:italic">i</span></sub> ← <span style="font-style:italic">uL</span><sub><span style="font-style:italic">i</span></sub> +<span style="font-style:italic">v</span> <span style="font-style:italic">L</span><sub><span style="font-style:italic">j</span></sub>,    
<span style="font-style:italic">L</span><sub><span style="font-style:italic">j</span></sub> ← −</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">L</span><sub><span style="font-style:italic">i</span></sub> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">L</span><sub><span style="font-style:italic">j</span></sub> </td></tr>
</table><p>
qui est réversible dans ℤ
car le déterminant de la sous-matrice élémentaire
correspondante est
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">u</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">v</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪</td><td class="dcell">= 1
</td></tr>
</table><p>
On peut donc créer des zéros en-dessous de la diagonale, il existe
une matrice inversible <span style="font-style:italic">L</span> telle que <span style="font-style:italic">LM</span>=<span style="font-style:italic">U</span> où <span style="font-style:italic">U</span> est triangulaire
supérieure. On peut même rendre les coefficients hors diagonale
de <span style="font-style:italic">U</span> inférieur aux pivots de leurs colonnes respectives en faisant
une combinaison linéaire de lignes <span style="font-style:italic">L</span><sub><span style="font-style:italic">j</span></sub> = <span style="font-style:italic">L</span><sub><span style="font-style:italic">j</span></sub>−<span style="font-style:italic">qL</span><sub><span style="font-style:italic">p</span></sub>, <span style="font-style:italic">j</span>&lt;<span style="font-style:italic">p</span> où <span style="font-style:italic">q</span>
est le quotient de la division euclidienne de <span style="font-style:italic">M</span><sub><span style="font-style:italic">jc</span></sub> par <span style="font-style:italic">M</span><sub><span style="font-style:italic">pc</span></sub>
(<span style="font-style:italic">p</span> la ligne du pivot, en principe <span style="font-style:italic">p</span>=<span style="font-style:italic">c</span>).
On observe aussi que les pivots sont les pgcd des éléments de la colonne
du pivot à partir de la ligne du pivot.</p><p>Applications : 
Cette réduction (dite forme normale de Hermite 
lorsqu’on réduit les lignes
au-dessus de la diagonale par division euclidienne par
le pivot) permet de trouver une base du noyau
à coefficients entiers et telle que tout élément du noyau à 
coefficient entier s’écrit comme combinaison linéaire à coefficients
entiers des éléments de la base. Il suffit d’appliquer la
réduction de Hermite à (<span style="font-style:italic">M</span><sup><span style="font-style:italic">t</span></sup>|<span style="font-style:italic">I</span>), on obtient une matrice (<span style="font-style:italic">U</span>|<span style="font-style:italic">L</span>)
telle que <span style="font-style:italic">U</span>=<span style="font-style:italic">LM</span><sup><span style="font-style:italic">t</span></sup>.
Dans Xcas, on peut utiliser l’instruction <code>ihermite</code> (ou
<code>mathnf</code> de PARI). L’aide
détaillée de Xcas donne un exemple de calcul de ℤ-base
d’un noyau. </p><p>Exemple : soit à résoudre en entiers 2<span style="font-style:italic">x</span>+3<span style="font-style:italic">y</span>+5<span style="font-style:italic">z</span>=0.
On pose <code>M:=[[2,3,5]]</code> puis 
<code>L,U:=ihermite(tran(M))</code>, les lignes nulles de <span style="font-style:italic">U</span> correspondent
à des lignes de <span style="font-style:italic">L</span> qui forment une base du noyau de <span style="font-style:italic">M</span>, soit
(6,1,−3) et (−5,0,2).
En effet <span style="font-style:italic">U</span>=<span style="font-style:italic">L</span> <span style="font-style:italic">M</span><sup><span style="font-style:italic">t</span></sup> donc <span style="font-style:italic">U</span><sup><span style="font-style:italic">t</span></sup>=<span style="font-style:italic">M</span> <span style="font-style:italic">L</span><sup><span style="font-style:italic">t</span></sup>, les colonnes nulle 
de <span style="font-style:italic">U</span><sup><span style="font-style:italic">t</span></sup> sont donc images par <span style="font-style:italic">M</span> des colonnes
correspondantes de <span style="font-style:italic">L</span><sup><span style="font-style:italic">t</span></sup>, ainsi les lignes de <span style="font-style:italic">L</span> correspondant
à des lignes nulles de <span style="font-style:italic">U</span> sont dans le noyau. Et si un vecteur
à coefficient entiers est dans le noyau, alors il se décompose
sur les vecteurs colonnes de <span style="font-style:italic">L</span><sup><span style="font-style:italic">t</span></sup> avec des coefficients entiers
(puisque <span style="font-style:italic">L</span>∈GL<sub><span style="font-style:italic">n</span></sub>(ℤ)), on applique <span style="font-style:italic">M</span> et on conclut
que ses composantes sur les colonnes non nulles de <span style="font-style:italic">U</span><sup><span style="font-style:italic">t</span></sup> sont nulles.</p><p>Remarque : l’algorithme du pivot de Gauss permet de trouver plus
rapidement une base sur ℚ du noyau de <span style="font-style:italic">M</span> à coefficients entiers,
par exemple ici { <span style="font-style:italic">v</span><sub>1</sub>=(−3,2,0), <span style="font-style:italic">v</span><sub>2</sub>=(−5,0,2)} mais ce n’est pas une base
sur ℤ, par exemple 1/2<span style="font-style:italic">v</span><sub>1</sub>+1/2<span style="font-style:italic">v</span><sub>2</sub> ∈ ℤ<sup>3</sup>.</p><p>Plus généralement, chercher une solution particulière
du système <span style="font-style:italic">MX</span>=<span style="font-style:italic">B</span> revient à résoudre
<span style="font-style:italic">U</span><sup><span style="font-style:italic">t</span></sup> <span style="font-style:italic">Y</span>=<span style="font-style:italic">B</span> avec <span style="font-style:italic">Y</span>=(<span style="font-style:italic">L</span><sup><span style="font-style:italic">t</span></sup>)<sup>−1</sup> <span style="font-style:italic">X</span>, la recherche de <span style="font-style:italic">Y</span> est
alors très simple puisque <span style="font-style:italic">U</span> est échelonnée. 
Par exemple, <code>M:=[[2,3,5],[7,5,3]]</code>
puis <code>B:=[3,-2]</code>, puis
<code>L,U:=ihermite(tran(M))</code>, donne pour <code>tran(U)</code>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td></tr>
</table><p>
on a donc <span style="font-style:italic">y</span><sub>1</sub>=3, <span style="font-style:italic">y</span><sub>2</sub>=−2, <span style="font-style:italic">y</span><sub>3</sub> quelconque puis on calcule 
<code>X:=tran(L)*[3,-2,y3]</code>, on peut vérifier 
avec <code>normal(M*X)</code>.</p><p>On peut aussi se servir de la forme normale de Hermite pour
compléter un vecteur <span style="font-style:italic">v</span>=(<span style="font-style:italic">a</span><sub>1</sub>,...,<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>) de contenu 1 en une base
de ℤ<sup><span style="font-style:italic">n</span></sup> (si le contenu n’est pas 1, c’est bien sur impossible
puisque le déterminant est un multiple du contenu), il suffit
de prendre les colonnes de <span style="font-style:italic">L</span><sup>−1</sup> 
(où <code>L,U:=ihermite(tran(v))</code>).
En effet on a <span style="font-style:italic">U</span>=<span style="font-style:italic">L</span> <span style="font-style:italic">v</span><sup><span style="font-style:italic">t</span></sup> et <span style="font-style:italic">U</span> est égal à (1,0,...,0) car le
contenu de <span style="font-style:italic">v</span> vaut 1.</p><p>La réduction échelonnée sous la diagonale correspond à
<code>ihermite</code>, la réduction complète correspond à
<code>ismith</code>
(ou <code>matsnf</code> de PARI) qui 
calcule la décomposition de Smith d’une matrice <span style="font-style:italic">A</span> à coefficients
entiers et en donne les coefficients invariants.
Il faut pour cela alterner plusieurs décomposition de Hermite en
ligne et en colonne. En effet un élément hors diagonale <span style="font-style:italic">a</span><sub><span style="font-style:italic">ij</span></sub>
non nul d’une
réduction de Hermite est un reste de division euclidienne par
le pivot <span style="font-style:italic">a</span><sub><span style="font-style:italic">jj</span></sub> (respectivement <span style="font-style:italic">a</span><sub><span style="font-style:italic">ii</span></sub> selon qu’on réduit en lignes ou en
colonnes) sur la diagonale, il est donc 
strictement plus petit et donnera lieu à
l’étape de réduction suivante à un pgcd
soit égal en <span style="font-style:italic">a</span><sub><span style="font-style:italic">ii</span></sub> [resp. <span style="font-style:italic">a</span><sub><span style="font-style:italic">jj</span></sub>] 
(dans ce cas <span style="font-style:italic">a</span><sub><span style="font-style:italic">ij</span></sub> deviendra nul et on effectue une seule
manipulation de lignes de type Gauss et non deux, ce qui ne changera
pas les 0 dans la ligne du pivot), soit strictement plus
petit, donc soit l’un des pivots décroit, soit l’un des <span style="font-style:italic">a</span><sub><span style="font-style:italic">ij</span></sub>
hors diagonale s’annule. On obtient en un nombre fini d’étapes
une matrice diagonale.
La forme normale de Smith d’une matrice <span style="font-style:italic">A</span> impose également 
que les coefficients
diagonaux non nuls <span style="font-style:italic">d</span><sub>1</sub>|<span style="font-style:italic">d</span><sub>2</sub>|...|<span style="font-style:italic">d</span><sub><span style="font-style:italic">r</span></sub> se divisent. Pour réaliser
cela, si par exemple <span style="font-style:italic">d</span><sub>1</sub> ne divise pas <span style="font-style:italic">d</span><sub>2</sub>, on remplace <span style="font-style:italic">C</span><sub>1</sub> par
<span style="font-style:italic">C</span><sub>1</sub>+<span style="font-style:italic">C</span><sub>2</sub>, puis on fait apparaitre le pgcd de <span style="font-style:italic">d</span><sub>1</sub> et <span style="font-style:italic">d</span><sub>2</sub> en ligne
1 colonne 1 en créant un 0 en ligne 2 colonne 1. </p><p>La réduction de Smith sert par exemple à montrer
qu’un sous-module de ℤ<sup><span style="font-style:italic">n</span></sup> obtenu par quotient par l’image 
d’une application linéaire de matrice <span style="font-style:italic">A</span> est isomorphe 
à ℤ/<span style="font-style:italic">d</span><sub><span style="font-style:italic">i</span></sub> × ... × ℤ/<span style="font-style:italic">d</span><sub><span style="font-style:italic">r</span></sub> × ℤ<sup><span style="font-style:italic">n</span>−<span style="font-style:italic">r</span></sup>. C’est ce
qu’on obtient pour un module présenté par des générateurs
et relations entre générateurs.
Les coefficients <span style="font-style:italic">d</span><sub><span style="font-style:italic">i</span></sub> sont appelés <span style="font-weight:bold">facteurs
invariants</span><a id="hevea_default255"></a> de la
matrice <span style="font-style:italic">A</span>, leur factorisation en produit de nombres 
premiers à une certaine puissance donne les <span style="font-weight:bold">diviseurs 
élémentaires</span><a id="hevea_default256"></a>.</p><p>Exemple 1 : on se donne le groupe abélien engendré par <span style="font-style:italic">x</span><sub>1</sub> et
<span style="font-style:italic">x</span><sub>2</sub> vérifiant les relations 2<span style="font-style:italic">x</span><sub>1</sub>+4<span style="font-style:italic">x</span><sub>2</sub>=0, −2<span style="font-style:italic">x</span><sub>1</sub>+6<span style="font-style:italic">x</span><sub>2</sub>=0. On fait
<span style="font-style:italic">L</span><sub>2</sub>=<span style="font-style:italic">L</span><sub>2</sub>+<span style="font-style:italic">L</span><sub>1</sub> et <span style="font-style:italic">C</span><sub>2</sub>=<span style="font-style:italic">C</span><sub>2</sub>−<span style="font-style:italic">C</span><sub>1</sub> ce qui donne la matrice réduite
de diagonale 2 et 10, qui en sont les facteurs invariants, le groupe
est isomorphe à ℤ/2 × ℤ/10 (parfois noté 
⊕ au lieu de ×).</p><p>Exemple 2 : on se donne un module sur ℤ engendré par <span style="font-style:italic">m</span><sub>1</sub>,<span style="font-style:italic">m</span><sub>2</sub>,<span style="font-style:italic">m</span><sub>3</sub>
et les relations 2<span style="font-style:italic">m</span><sub>1</sub>+3<span style="font-style:italic">m</span><sub>2</sub>+5<span style="font-style:italic">m</span><sub>3</sub>=0, 7<span style="font-style:italic">m</span><sub>1</sub>+3<span style="font-style:italic">m</span><sub>2</sub>−5<span style="font-style:italic">m</span><sub>3</sub>=0.
On pose <code>A:=[[2,3,5],[7,3,-5]]</code>, puis
<code>U,B,V:=ismith(A)</code>, on a donc <span style="font-style:italic">B</span>=<span style="font-style:italic">UAV</span>.
Si <span style="font-style:italic">M</span>=(<span style="font-style:italic">m</span><sub>1</sub>,<span style="font-style:italic">m</span><sub>2</sub>,<span style="font-style:italic">m</span><sub>3</sub>), on a <span style="font-style:italic">AM</span>=0 donc <span style="font-style:italic">B</span> <span style="font-style:italic">V</span><sup>−1</sup><span style="font-style:italic">M</span>=<span style="font-style:italic">UAM</span>=0.
On pose (<span style="font-style:italic">n</span><sub>1</sub>,<span style="font-style:italic">n</span><sub>2</sub>,<span style="font-style:italic">n</span><sub>3</sub>)=<span style="font-style:italic">N</span>=<span style="font-style:italic">V</span><sup>−1</sup><span style="font-style:italic">M</span>, 
les générateurs <span style="font-style:italic">n</span><sub>1</sub>=<span style="font-style:italic">m</span><sub>1</sub>−6<span style="font-style:italic">m</span><sub>2</sub>−20<span style="font-style:italic">m</span><sub>3</sub>, <span style="font-style:italic">n</span><sub>2</sub>=<span style="font-style:italic">m</span><sub>2</sub>+3<span style="font-style:italic">m</span><sub>3</sub>,<span style="font-style:italic">n</span><sub>3</sub>=<span style="font-style:italic">m</span><sub>3</sub>
vérifient donc <span style="font-style:italic">b</span><sub>1</sub> <span style="font-style:italic">n</span><sub>1</sub>=0, <span style="font-style:italic">b</span><sub>2</sub><span style="font-style:italic">n</span><sub>2</sub>=0, <span style="font-style:italic">b</span><sub>1</sub>=1, <span style="font-style:italic">b</span><sub>2</sub>=15, le module est donc
isomorphe à ℤ/1 × ℤ/15 × ℤ soit encore ℤ/15ℤ
× ℤ.</p>
<!--TOC subsubsection id="sec225" L’algorithme LLL.-->
<h4 id="sec225" class="subsubsection">22.2.3  L’algorithme LLL.</h4><!--SEC END --><p> <a id="hevea_default257"></a>
Il s’agit d’une méthode permettant d’obtenir rapidement
une base courte d’un réseau. Ce n’est pas la base la plus courte
possible mais un compromis temps d’exécution rapide/base
pas trop grande. Voir par exemple Cohen pour la définition
et les propriétés. L’instruction Xcas correspondante est
<code>lll</code> (ou <code>qflll</code> de PARI).</p><p>Cet algorithme est très utile en calcul formel, pour éviter
une explosion combinatoire dans certaines
opérations de recombinaison. Par exemple, supposons que
nous souhaitions factoriser un polynôme <span style="font-style:italic">P</span> à coefficients
entiers sur ℤ[<span style="font-style:italic">X</span>] en utilisant ses racines approchées. Si
plusieurs racines <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub> correspondent à un facteur entier,
alors <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> ∑<span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub>  doit être un entier aux erreurs
d’arrondi près. Tester toutes les combinaisons possibles
serait beaucoup trop long, en particulier si <span style="font-style:italic">P</span> est irréductible
(en gros 2<sup><span style="font-style:italic">n</span>−1</sup> tests de recombinaison). Pour éviter ce
problème, on construit un réseau engendré par degré <span style="font-style:italic">P</span> 
lignes dont les premières coordonnées sont celles de la
matrice identité, complétées par la partie réelle et
imaginaire des racines de <span style="font-style:italic">P</span> multipliée par le coefficient dominant
de <span style="font-style:italic">P</span> et par une puissance de 10 assez grande. On ajoute
deux lignes qui“annulent” les parties entières des combinaisons
linéaires des parties réelles et imaginaires.
L’existence
d’un facteur irréductible se lira sur un vecteur court du réseau
avec des 1 et des 0 comme combinaison linéaire des vecteurs
initiaux.
</p><pre class="verbatim">f(P):={
  local l,n,prec,M,S,A,L,O;
  n:=degree(P);
  prec:=2*n;
  l:=proot(P,prec+n);
  M:=round(tran([op(idn(n)),
     lcoeff(P)*10^prec*re(l),lcoeff(P)*10^prec*im(l)]));
  M:=[op(M),[0$n,10^prec,0],[0$(n+1),10^prec]];
  S,A,L,O:=lll(M);
  retourne l,A;
}:;
</pre><p>Par exemple, <code>P:=(x^3+x+1)*(x^4+x+1)</code> suivi de <code>l,A:=f(P)</code>
fait apparaitre en première ligne de <span style="font-style:italic">A</span> le vecteur
(1,1,1,0,0,0,0,0,0). On essaie donc de recombiner les trois
premières racines de <code>l</code><br>
<code>pcoeff(l[0],l[1],l[2])</code><br>
renvoie bien un facteur presqu’entier de <span style="font-style:italic">P</span>. Il faut bien entendu des
encadrements rigoureux pour déterminer la précision à utiliser
pour les racines pour prouver l’irréductibilité de <span style="font-style:italic">P</span> si <span style="font-style:italic">A</span> ne
contient pas de vecteur court contenant uniquement des 1 et 0.</p>
<!--TOC subsection id="sec226" Le pivot de Gauss numérique.-->
<h3 id="sec226" class="subsection">22.3  Le pivot de Gauss numérique.</h3><!--SEC END -->
<!--TOC subsubsection id="sec227" Efficacité de l’algorithme-->
<h4 id="sec227" class="subsubsection">22.3.1  Efficacité de l’algorithme</h4><!--SEC END --><p>
Si la matrice possède <span style="font-style:italic">L</span> lignes et <span style="font-style:italic">C</span> colonnes,
le nombre maximal d’opérations pour réduire une ligne est 
<span style="font-style:italic">C</span> opérations (une opération=1 multiplication + 1 soustraction, 
en calculant une seule fois le quotient). 
Il y a <span style="font-style:italic">L</span>−1 lignes à réduire à chaque
étape et min(<span style="font-style:italic">L</span>,<span style="font-style:italic">C</span>) étapes à effectuer, on en déduit que le
nombre maximal d’opérations pour réduire une matrice est
<span style="font-style:italic">LC</span>min(<span style="font-style:italic">L</span>,<span style="font-style:italic">C</span>). Pour une matrice carrée de taille <span style="font-style:italic">n</span>, cela fait 
<span style="font-style:italic">n</span><sup>3</sup> opérations. Si on effectue une réduction en-dessous de la diagonale, 
toujours pour une matrice carrée, le nombre d’opérations est
divisé par 3 (∑<sub><span style="font-style:italic">k</span>=2</sub><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">k</span><sup>2</sup>).</p>
<!--TOC subsubsection id="sec228" Erreurs d’arrondis du pivot de Gauss-->
<h4 id="sec228" class="subsubsection">22.3.2  Erreurs d’arrondis du pivot de Gauss</h4><!--SEC END --><p> <a id="hevea_default258"></a>
<a id="hevea_default259"></a>
Comme |<span style="font-style:italic">a</span><sub><span style="font-style:italic">jc</span></sub>| ≤ |<span style="font-style:italic">a</span><sub><span style="font-style:italic">lc</span></sub>|, une étape de réduction multiplie
au plus l’erreur absolue des coefficients par 2. Donc la
réduction complète d’une matrice peut multiplier au pire l’erreur
absolue sur les coefficients par 2<sup><span style="font-style:italic">n</span></sup> (où <span style="font-style:italic">n</span> est le nombre
d’étapes de réduction, inférieur au plus petit du nombre de lignes
et de colonnes). Ceci signifie qu’avec la précision d’un double,
on peut au pire perdre toute précision pour des matrices pas
si grandes que ça (<span style="font-style:italic">n</span>=52). Heureusement, il semble qu’en pratique, 
l’erreur absolue
ne soit que très rarement multipliée par un facteur supérieur à 10.</p><p>Par contre, si on ne prend pas la précaution de choisir le pivot
de norme maximale dans la colonne, les erreurs d’arrondis se
comportent de manière bien moins bonnes, cf. l’exemple suivant.</p><p><span style="font-weight:bold">Exemple</span><br>
Soit à résoudre le système linéaire
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">є <span style="font-style:italic">x</span> + 1.0 <span style="font-style:italic">y</span> = 1.0 ,    <span style="font-style:italic">x</span> + 2.0 <span style="font-style:italic">y</span> = 3.0 </td></tr>
</table><p>
avec є =2<sup>−54</sup> (pour une machine utilisant des doubles pour
les calculs en flottant,
plus généralement on choisira є tel que (1.0+3є)−1.0
soit indistinguable de 0.0).<br>
Si on résoud le système exactement,
on obtient <span style="font-style:italic">x</span>=1/(1−2є) (environ 1)
et <span style="font-style:italic">y</span>=(1−3є)/(1−2є) (environ 1).
Supposons que l’on n’utilise pas la stratégie du pivot partiel,
on prend alors comme pivot є, donc on effectue la
manipulation de ligne <span style="font-style:italic">L</span><sub>2</sub> ← <span style="font-style:italic">L</span><sub>2</sub> − 1/є <span style="font-style:italic">L</span><sub>1</sub> ce qui
donne comme 2ème équation (2.0−1.0/є)<span style="font-style:italic">y</span>=3.0−1.0/є.
Comme les calculs sont numériques, et à cause des erreurs
d’arrondis, cette 2ème équation sera remplacée par
(−1.0/є)<span style="font-style:italic">y</span>=−1.0/є d’où <span style="font-style:italic">y</span>=1.0, qui sera remplacé
dans la 1ère équation, donnant є <span style="font-style:italic">x</span> = 1.0−1.0<span style="font-style:italic">y</span>=0.0 donc
<span style="font-style:italic">x</span>=0.0.<br>
Inversement, si on utilise la stratégie du pivot partiel, alors
on doit échanger les 2 équations <span style="font-style:italic">L</span><sub>2</sub>′=<span style="font-style:italic">L</span><sub>1</sub> et <span style="font-style:italic">L</span><sub>1</sub>′=<span style="font-style:italic">L</span><sub>2</sub> puis on effectue
<span style="font-style:italic">L</span><sub>2</sub> ← <span style="font-style:italic">L</span><sub>2</sub>′ − є <span style="font-style:italic">L</span><sub>1</sub>′, ce qui donne
(1.0−2.0є) <span style="font-style:italic">y</span> = 1.0 − 3.0 є , remplacée en raison
des erreurs d’arrondi par 1.0*<span style="font-style:italic">y</span>=1.0 donc <span style="font-style:italic">y</span>=1.0, puis on remplace
<span style="font-style:italic">y</span> dans <span style="font-style:italic">L</span><sub>1</sub>′ ce qui donne <span style="font-style:italic">x</span>=3.0−2.0<span style="font-style:italic">y</span>=1.0.<br>
On observe dans les deux cas que la valeur de <span style="font-style:italic">y</span> est proche de la
valeur exacte, mais la valeur de <span style="font-style:italic">x</span> dans le premier cas est
grossièrement eloignée de la valeur correcte.</p><p>On peut aussi s’intéresser à la sensibilité de la solution d’un
système linéaire à des variations de son second membre. Cela fait intervenir
le nombre de conditionnement de la matrice <span style="font-style:italic">A</span> (voir plus bas) du système (qui
est essentiellement la valeur absolue du rapport de la valeur propre
la plus grande sur la valeur propre la plus petite), plus
ce nombre est grand, plus la solution variera (donc plus on
perd en précision).</p>
<!--TOC subsection id="sec229" La méthode de factorisation <span style="font-style:italic">LU</span>-->
<h3 id="sec229" class="subsection">22.4  La méthode de factorisation <span style="font-style:italic">LU</span></h3><!--SEC END --><p> <a id="hevea_default260"></a>
<a id="hevea_default261"></a>
Dans sa forme la plus simple, elle permet d’écrire
une matrice <span style="font-style:italic">A</span> comme produit de deux matrices triangulaire
inférieures et supérieures, ce qui ramène la résolution
de système à la résolution de deux systèmes triangulaires.
Pour tenir compte d’éléments diagonaux nuls et pour optimiser 
les erreurs d’arrondi, il est nécessaire d’effectuer des
permutations sur les lignes de la matrice.</p>
<!--TOC subsubsection id="sec230" Interprétation matricielle du pivot de Gauss-->
<h4 id="sec230" class="subsubsection">22.4.1  Interprétation matricielle du pivot de Gauss</h4><!--SEC END --><p>
On notera <span style="font-style:italic">l</span> et <span style="font-style:italic">c</span> le nombre de lignes et colonnes de <span style="font-style:italic">A</span> (pour
éviter la confusion avec le facteur <span style="font-style:italic">L</span>) et on
supposera <span style="font-style:italic">A</span> non singulière pour simplifier l’exposition.</p><p>Lorsqu’on réduit la colonne <span style="font-style:italic">j</span> d’une matrice Ã
(partiellement réduite) à partir
de la ligne <span style="font-style:italic">j</span>+1 (en supposant Ã<sub><span style="font-style:italic">j</span>,<span style="font-style:italic">j</span></sub> ≠ 0), cela revient à
multiplier Ã à gauche par une matrice L<sub><span style="font-style:italic">j</span></sub> créée en
partant de la matrice
identité de taille <span style="font-style:italic">l</span> où on remplace les 0 
colonne <span style="font-style:italic">j</span>, lignes <span style="font-style:italic">j</span>+1 à <span style="font-style:italic">l</span> par 
le coefficient de la combinaison de ligne effectuée :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">l</span><sub><span style="font-style:italic">i</span></sub> → <span style="font-style:italic">l</span><sub><span style="font-style:italic">i</span></sub> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Ã<sub><span style="font-style:italic">i</span>,<span style="font-style:italic">j</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">Ã<sub><span style="font-style:italic">j</span>,<span style="font-style:italic">j</span></sub></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">l</span><sub><span style="font-style:italic">j</span></sub> </td></tr>
</table><p>
donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">L<sub><span style="font-style:italic">j</span></sub> = </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">− </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Ã<sub><span style="font-style:italic">j</span>+1,<span style="font-style:italic">j</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">Ã<sub><span style="font-style:italic">j</span>,<span style="font-style:italic">j</span></sub></td></tr>
</table></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > 0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >....</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">− </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Ã<sub><span style="font-style:italic">l</span>,<span style="font-style:italic">j</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">Ã<sub><span style="font-style:italic">j</span>,<span style="font-style:italic">j</span></sub></td></tr>
</table></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >1</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
On vérifie facilement que l’inverse de cette matrice est
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">L</span><sub><span style="font-style:italic">j</span></sub> = L<sub><span style="font-style:italic">j</span></sub><sup>−1</sup> = </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">Ã<sub><span style="font-style:italic">j</span>+1,<span style="font-style:italic">j</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">Ã<sub><span style="font-style:italic">j</span>,<span style="font-style:italic">j</span></sub></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > 0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >....</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">Ã<sub><span style="font-style:italic">l</span>,<span style="font-style:italic">j</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">Ã<sub><span style="font-style:italic">j</span>,<span style="font-style:italic">j</span></sub></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >1</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
Donc <span style="font-style:italic">A</span> est le produit des matrices <span style="font-style:italic">L</span><sub><span style="font-style:italic">j</span></sub> par une matrice réduite
<span style="font-style:italic">U</span> qui est triangulaire supérieure
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>= <span style="font-style:italic">L</span><sub>1</sub>...<span style="font-style:italic">L</span><sub><span style="font-style:italic">l</span>−1</sub> <span style="font-style:italic">U</span> </td></tr>
</table><p>
On vérifie ensuite que le produit des matrices <span style="font-style:italic">L</span><sub>1</sub>...<span style="font-style:italic">L</span><sub><span style="font-style:italic">l</span>−1</sub> revient à
remplacer les coefficients de la colonne <span style="font-style:italic">j</span> sous la diagonale 
par ceux de <span style="font-style:italic">L</span><sub><span style="font-style:italic">j</span></sub>, ce qui donne une matrice <span style="font-style:italic">L</span> triangulaire
inférieure (avec des 1 sur la diagonale). Pour l’obtenir il suffit
au cours de l’algorithme de réduction sous-diagonale du 
pivot de Gauss de stocker le coefficient
de la combinaison linéaire dans une matrice initialisée
à la matrice identité (on peut aussi le faire
en place dans la matrice á réduire).</p><p>Attention, le produit L<sub><span style="font-style:italic">l</span>−1</sub>...L<sub>1</sub> ne s’obtient pas en
copiant la colonne <span style="font-style:italic">j</span> de L<sub><span style="font-style:italic">j</span></sub> pour <span style="font-style:italic">j</span> variant de 1 à
<span style="font-style:italic">l</span>−1! On peut l’obtenir en faisant
une réduction sous-diagonale de la matrice bloc obtenue en collant
<span style="font-style:italic">A</span> avec la matrice identité ayant <span style="font-style:italic">l</span> lignes.</p>
<!--TOC subsubsection id="sec231" Factorisation <span style="font-style:italic">PA</span>=<span style="font-style:italic">LU</span>-->
<h4 id="sec231" class="subsubsection">22.4.2  Factorisation <span style="font-style:italic">PA</span>=<span style="font-style:italic">LU</span></h4><!--SEC END --><p>
Si on veut mettre en oeuvre la stratégie du pivot partiel (ou en
calcul exact si un coefficient diagonal est nul), il est nécessaire
d’intervertir une ligne de la matrice partiellement réduite
avec une ligne en-dessous. Cela revient à réduire la matrice
<span style="font-style:italic">A</span> de départ après échange de ces mêmes lignes. En
conséquence ce n’est pas <span style="font-style:italic">A</span> qui est le produit <span style="font-style:italic">LU</span> mais
une matrice obtenue par permutations de lignes de <span style="font-style:italic">A</span>, que
l’on peut écrire comme produit à gauche de <span style="font-style:italic">A</span> par une matrice
de permutation <span style="font-style:italic">P</span>.</p><p>Remarque : si à une étape de réduction, tous les coefficients
de la colonne <span style="font-style:italic">j</span> à partir de la ligne <span style="font-style:italic">j</span> sont nuls, on peut
simplement ignorer cette colonne et incrémenter <span style="font-style:italic">j</span> de 1 (<span style="font-style:italic">L</span><sub><span style="font-style:italic">j</span></sub>
sera l’identité).
Mais ceci différe de la réduction sous forme échelonnée
où on incrémente <span style="font-style:italic">j</span> de 1, mais pas <span style="font-style:italic">i</span> (on ne peut plus
alors déduire le rang de <span style="font-style:italic">U</span> du nombre de lignes non nulles).
On peut aussi effectuer un échange de colonnes (ce qui revient
à multiplier à droite par une matrice de permutation).</p>
<!--TOC subsubsection id="sec232" Applications de la décomposition <span style="font-style:italic">LU</span>-->
<h4 id="sec232" class="subsubsection">22.4.3  Applications de la décomposition <span style="font-style:italic">LU</span></h4><!--SEC END --><p>
On peut résoudre des systèmes linéaires par la factorisation
<span style="font-style:italic">LU</span>. En effet soit à résoudre <span style="font-style:italic">Ax</span>=<span style="font-style:italic">b</span>. On effectue la permutation
de lignes sur <span style="font-style:italic">A</span> et <span style="font-style:italic">b</span> (correspondant à la matrice de permutation
<span style="font-style:italic">P</span>), ce qui donne <span style="font-style:italic">PAx</span>=<span style="font-style:italic">Pb</span>=<span style="font-style:italic">LUx</span>, puis on résoud <span style="font-style:italic">Ly</span>=<span style="font-style:italic">Pb</span>
(système triangulaire inférieur), puis on résoud <span style="font-style:italic">Ux</span>=<span style="font-style:italic">y</span>
(système triangulaire supérieur).</p><p>Comparaison avec la réduction complète sous forme échelonnée de
(<span style="font-style:italic">A</span>|<span style="font-style:italic">b</span>) :
</p><ul class="itemize"><li class="li-itemize">
La factorisation <span style="font-style:italic">LU</span> peut reservir plus tard pour résoudre le même
système linéaire avec un autre second membre.
Avec <code>rref</code> il faut dès le départ mettre tous les
vecteurs colonnes second membre à <span style="font-style:italic">A</span>.
</li><li class="li-itemize">Le nombre d’opérations pour résoudre un système <span style="font-style:italic">n</span>,<span style="font-style:italic">n</span>
est moindre. La réduction sous-diagonale nécessite de réduire
les colonnes <span style="font-style:italic">j</span> de 1 à <span style="font-style:italic">n</span>−1, avec pour réduire la colonne <span style="font-style:italic">j</span>
<span style="font-style:italic">n</span>−<span style="font-style:italic">j</span> combinaisons linéaire de lignes ayant <span style="font-style:italic">n</span>+1−<span style="font-style:italic">j</span> coefficients non
nuls, soit ∑<sub><span style="font-style:italic">j</span>=1</sub><sup>(</sup><span style="font-style:italic">n</span>−1) (<span style="font-style:italic">n</span>−<span style="font-style:italic">j</span>)(<span style="font-style:italic">n</span>+1−<span style="font-style:italic">j</span>)=1/3<span style="font-style:italic">n</span><sup>3</sup>+<span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>2</sup>) opérations
(1 opération = 1 multiplication et 1 soustraction).
La résolution des systèmes triangulaires est en <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>2</sup>).
</li><li class="li-itemize">Le calcul est plus favorable au cache mémoire, puisqu’on
travaille sur une portion de plus en plus petite de la matrice.
</li></ul><p>On peut inverser une matrice en utilisant la décomposition
<span style="font-style:italic">LU</span>. Supposons pour simplifier que la permutation est l’identité.
On calcule d’abord <span style="font-style:italic">L</span><sup>−1</sup> en utilisant le fait que <span style="font-style:italic">L</span> est
triangulaire inférieure, voici comment cela est implémenté dans
Xcas (<span style="font-style:italic">L</span> est noté <span style="font-family:monospace">l</span>) :
</p><pre class="verbatim">first step compute l^-1, 
solve l*a=y for y a canonical basis vector
  a0=y0, a1=y1-l_{1,0}*a0, ..., ak=yk-sum_{j=0..k-1}(l_kj*aj)
if y=(0,..,0,1,0,...0) (1 at position i), 
  a0=..=a_{i-1}=0, a_i=1 and we start at equation k=i+1 and sum_{j=i...}
-&gt; n^3/6 operations
To store the result in place of l
we first compute all the a2 (there is only 1), then all the a3 (2), etc.
a0=y0, a1=y1-l_{1,0}*a0, ..., ak=yk-sum_{j=0..k-1}(l_kj*aj)
</pre><p>Puis on résoud <span style="font-style:italic">U</span> <span style="font-style:italic">A</span><sup>−1</sup>=<span style="font-style:italic">L</span><sup>−1</sup> colonne par colonne
</p><pre class="verbatim">second step, solve u*inverse=l^-1 (now under the diagonal)
we compute a column of inverse by solving the system: 
u*col(inverse)=corresponding row of l^-1, 
and overwrite the row of l^-1 by solution
u*[x0,..,xn-1]=[a0,...,an]
x_{n-1}=a_{n-1}/u_{n-1,n-1}
x_{n-2}=(a_{n-2}-u_{n-2,n-1}*x_{n-1})/u_{n-2,n-2}
...
x_k=(a_{k}-sum_{j=k+1..n-1} u_{k,j}x_j)/u_{k,k}
-&gt; n^3/2 operations
To store the solution in place, we first compute all the x_{n-1}
put them in the last line of m, then all the x_{n-2}, etc.
</pre>
<!--TOC subsection id="sec233" La factorisation de Cholesky-->
<h3 id="sec233" class="subsection">22.5  La factorisation de Cholesky</h3><!--SEC END --><p> <a id="hevea_default262"></a>
<a id="hevea_default263"></a>
Dans le cas où la matrice est réelle symétrique définie
positive (ou plus généralement hermitienne), 
on peut obtenir une écriture analogue
mais où <span style="font-style:italic">U</span> est la transconjuguée de <span style="font-style:italic">L</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>=<span style="font-style:italic">U</span><sup>*</sup> <span style="font-style:italic">U</span> = <span style="font-style:italic">L</span> <span style="font-style:italic">L</span><sup>*</sup> </td></tr>
</table><p>
<span style="font-style:italic">L</span> reste triangulaire
inférieure, mais n’a plus des 1 sur sa diagonale en général. Si
<span style="font-style:italic">A</span> est définie positive, on peut rendre l’écriture unique en
imposant aux coefficients diagonaux de <span style="font-style:italic">L</span> d’être réels positifs.</p><p>L’algorithme de calcul de <span style="font-style:italic">U</span> est la traduction matricielle de l’algorithme
de Gauss de réduction des formes quadratiques. On a en effet
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span><sup>*</sup> <span style="font-style:italic">A</span> <span style="font-style:italic">x</span>=<span style="font-style:italic">x</span><sup>*</sup> <span style="font-style:italic">U</span><sup>*</sup> <span style="font-style:italic">U</span> <span style="font-style:italic">x</span> = ||<span style="font-style:italic">Ux</span>||<sup>2</sup> </td></tr>
</table><p>
les lignes de <span style="font-style:italic">U</span> (ou les colonnes de <span style="font-style:italic">L</span>) sont donc les coefficients
des formes linéaires indépendantes qui interviennent dans l’écriture
de la forme quadratique comme somme/différence de carrés de formes
linéaires. Si <span style="font-style:italic">A</span>
est définie positive, seules des sommes interviennent, et les
variables s’éliminent l’une après l’autre (le coefficient de <span style="font-style:italic">x</span><sub>2</sub> est forcément
non nul lorsqu’on a éliminé <span style="font-style:italic">x</span><sub>1</sub> et ainsi de suite), ceci explique
la forme triangulaire de <span style="font-style:italic">U</span> et <span style="font-style:italic">L</span>.</p><p>Le calcul de <span style="font-style:italic">L</span> se fait donc colonne par colonne, en calculant d’abord le
coefficient diagonal comme racine carrée du coefficient diagonal 
α<sub><span style="font-style:italic">j</span></sub>=√<span style="text-decoration:overline"><span style="font-style:italic">A</span></span><sub><span style="text-decoration:overline"><span style="font-style:italic">j</span></span><span style="text-decoration:overline">,</span><span style="text-decoration:overline"><span style="font-style:italic">j</span></span></sub>.
Ensuite on effectue les combinaisons de ligne sous la forme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">l</span><sub><span style="font-style:italic">j</span></sub> → </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">α<sub><span style="font-style:italic">j</span></sub></td></tr>
</table></td><td class="dcell"><span style="font-style:italic">l</span><sub><span style="font-style:italic">j</span></sub>,     <span style="font-style:italic">l</span><sub><span style="font-style:italic">i</span></sub> → α<sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">l</span><sub><span style="font-style:italic">i</span></sub> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span>,<span style="font-style:italic">j</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">α<sub><span style="font-style:italic">j</span></sub></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">l</span><sub><span style="font-style:italic">j</span></sub> </td></tr>
</table><p>On peut aussi tout simplement effectuer le produit de <span style="font-style:italic">L</span> <span style="font-style:italic">L</span><sup>*</sup> et
chercher les inconnues en commencant par <span style="font-style:italic">l</span><sub>1,1</sub> puis on calcule
les <span style="font-style:italic">l</span><sub><span style="font-style:italic">i</span>,1</sub> pour <span style="font-style:italic">i</span>&gt;1, etc. En suivant wikipedia, pour une matrice réelle :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">L</span>=</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">l</span><sub>11</sub></td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >⋯</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">l</span><sub>21</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">l</span><sub>22</sub></td><td style="text-align:center;white-space:nowrap" >⋯</td><td style="text-align:center;white-space:nowrap" >0</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >⋱</td><td style="text-align:center;white-space:nowrap" >⋮</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">l</span><sub><span style="font-style:italic">n</span>1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">l</span><sub><span style="font-style:italic">n</span>2</sub></td><td style="text-align:center;white-space:nowrap" >⋯</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">l</span><sub><span style="font-style:italic">nn</span></sub>
</td></tr>
</table></td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎥<br>
⎦</td></tr>
</table></td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">ij</span></sub>=</td><td class="dcell">⎛<br>
⎝</td><td class="dcell"><span style="font-style:italic">LL</span><sup><span style="font-style:italic">T</span></sup></td><td class="dcell">⎞<br>
⎠</td><td class="dcell"><sub><span style="font-style:italic">ij</span></sub>=</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">l</span><sub><span style="font-style:italic">ik</span></sub><span style="font-style:italic">l</span><sub><span style="font-style:italic">jk</span></sub></td></tr>
</table></td><td class="dcell">=
</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">min</td><td class="dcell">⎧<br>
⎨<br>
⎩</td><td class="dcell"><span style="font-style:italic">i</span>,<span style="font-style:italic">j</span></td><td class="dcell">⎫<br>
⎬<br>
⎭</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">l</span><sub><span style="font-style:italic">ik</span></sub><span style="font-style:italic">l</span><sub><span style="font-style:italic">jk</span></sub></td></tr>
</table></td><td class="dcell">, 1≤ <span style="font-style:italic">i</span>,<span style="font-style:italic">j</span>≤ <span style="font-style:italic">n</span> </td></tr>
</table><p>
La matrice <span style="font-style:italic">A</span> étant symétrique, il suffit que les relations ci-dessus
soient vérifiées pour <span style="font-style:italic">i</span> ≤ <span style="font-style:italic">j</span>, 
c’est-à-dire que les éléments <span style="font-style:italic">l</span><sub><span style="font-style:italic">i</span>,<span style="font-style:italic">j</span></sub> de la matrice <span style="font-style:italic">L</span> doivent
satisfaire
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">ij</span></sub>=</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">l</span><sub><span style="font-style:italic">ik</span></sub><span style="font-style:italic">l</span><sub><span style="font-style:italic">jk</span></sub></td></tr>
</table></td><td class="dcell">, 1≤ <span style="font-style:italic">i</span>≤ <span style="font-style:italic">j</span>≤ <span style="font-style:italic">n</span> </td></tr>
</table><p>
Pour <span style="font-style:italic">i</span>=1, on détermine la première colonne de <span style="font-style:italic">L</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub>11</sub>=<span style="font-style:italic">l</span><sub>11</sub><span style="font-style:italic">l</span><sub>11</sub>,    <span style="font-style:italic">a</span><sub>1<span style="font-style:italic">j</span></sub>=<span style="font-style:italic">l</span><sub>11</sub><span style="font-style:italic">l</span><sub><span style="font-style:italic">j</span>1</sub></td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">l</span><sub>11</sub>=</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span><sub>11</sub></td></tr>
</table></td><td class="dcell">,    <span style="font-style:italic">l</span><sub><span style="font-style:italic">j</span>1</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub>1<span style="font-style:italic">j</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span><sub>11</sub></td></tr>
</table></td><td class="dcell">
 (pour  <span style="font-style:italic">j</span>&gt;1) </td></tr>
</table><p>
On détermine la <span style="font-style:italic">i</span>-ième colonne de <span style="font-style:italic">L</span> (2≤ <span style="font-style:italic">i</span>≤ <span style="font-style:italic">n</span>) après avoir
calculé les <span style="font-style:italic">i</span>−1 premières colonnes
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">ii</span></sub>=<span style="font-style:italic">l</span><sub><span style="font-style:italic">i</span>1</sub><span style="font-style:italic">l</span><sub><span style="font-style:italic">i</span>1</sub>+…+<span style="font-style:italic">l</span><sub><span style="font-style:italic">ii</span></sub><span style="font-style:italic">l</span><sub><span style="font-style:italic">ii</span></sub>,   
<span style="font-style:italic">a</span><sub><span style="font-style:italic">ij</span></sub>=<span style="font-style:italic">l</span><sub><span style="font-style:italic">i</span>1</sub><span style="font-style:italic">l</span><sub><span style="font-style:italic">j</span>1</sub>+…+<span style="font-style:italic">l</span><sub><span style="font-style:italic">ii</span></sub><span style="font-style:italic">l</span><sub><span style="font-style:italic">ji</span></sub> </td></tr>
</table><p>
d’où 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">l</span><sub><span style="font-style:italic">ii</span></sub>= </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">ii</span></sub>−</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">l</span><sub><span style="font-style:italic">ik</span></sub><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">,   
<span style="font-style:italic">l</span><sub><span style="font-style:italic">ji</span></sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">ij</span></sub>−</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">l</span><sub><span style="font-style:italic">ik</span></sub><span style="font-style:italic">l</span><sub><span style="font-style:italic">jk</span></sub></td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span><sub><span style="font-style:italic">ii</span></sub></td></tr>
</table></td><td class="dcell"> 
(pour  <span style="font-style:italic">j</span> &gt; <span style="font-style:italic">i</span>)</td></tr>
</table><p>
Pour une matrice hermitienne complexe, il suffit de remplacer
<span style="font-style:italic">l</span><sub><span style="font-style:italic">ik</span></sub><span style="font-style:italic">l</span><sub><span style="font-style:italic">jk</span></sub> par <span style="font-style:italic">l</span><sub><span style="font-style:italic">ik</span></sub><span style="text-decoration:overline"><span style="font-style:italic">l</span></span><sub><span style="text-decoration:overline"><span style="font-style:italic">jk</span></span></sub> et <span style="font-style:italic">l</span><sub><span style="font-style:italic">ik</span></sub><sup>2</sup> par
|<span style="font-style:italic">l</span><sub><span style="font-style:italic">ik</span></sub>|<sup>2</sup>.</p><p>Le nombre d’opérations à effectuer est asymptotiquement
2 fois plus faible que celui pour <span style="font-style:italic">LU</span>. En effet,
pour la première ligne, il faut 1 racine et <span style="font-style:italic">n</span>−1 divisions,
pour la deuxième ligne, 1 racine, <span style="font-style:italic">n</span>−1 additions, multiplications
et <span style="font-style:italic">n</span>−2 divisions, ..., pour la <span style="font-style:italic">i</span>-ième ligne 1 racine,
(<span style="font-style:italic">i</span>−1)(<span style="font-style:italic">n</span>−<span style="font-style:italic">i</span>) additions, multiplications et <span style="font-style:italic">n</span>−2 divisions, au final
le cout est dominé par les additions et multiplications en 1/6<span style="font-style:italic">n</span><sup>3</sup>
pour chaque, contre 1/3<span style="font-style:italic">n</span><sup>3</sup> pour la
factorisation <span style="font-style:italic">LU</span>.</p><p>La commande Xcas correspondante est <code>cholesky</code> et renvoie
la matrice <span style="font-style:italic">L</span>.</p>
<!--TOC subsection id="sec234" Conditionnement-->
<h3 id="sec234" class="subsection">22.6  Conditionnement</h3><!--SEC END --><p> <a id="hevea_default264"></a> <a id="hevea_default265"></a>
Le conditionnement mesure la sensibilité de la solution renvoyée d’un
système linéaire aux données du problème.</p><p>Soit le système linéaire <span style="font-style:italic">Ax</span>=<span style="font-style:italic">b</span> de solution <span style="font-style:italic">x</span>=<span style="font-style:italic">A</span><sup>−1</sup><span style="font-style:italic">b</span>, 
supposons <span style="font-style:italic">b</span> connu avec une erreur <span style="font-style:italic">e</span>, alors la solution renvoyée
sera <span style="font-style:italic">x</span>+<span style="font-style:italic">A</span><sup>−1</sup><span style="font-style:italic">e</span>, on a donc une erreur relative sur la solution de 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">||<span style="font-style:italic">A</span><sup>−1</sup><span style="font-style:italic">e</span>||</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">||<span style="font-style:italic">A</span><sup>−1</sup><span style="font-style:italic">b</span>||</td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">||<span style="font-style:italic">A</span><sup>−1</sup><span style="font-style:italic">e</span>||</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">||<span style="font-style:italic">e</span>||</td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">||<span style="font-style:italic">e</span>||</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">||<span style="font-style:italic">b</span>||</td></tr>
</table></td><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">||<span style="font-style:italic">b</span>||</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">||<span style="font-style:italic">A</span><sup>−1</sup><span style="font-style:italic">b</span>||</td></tr>
</table></td><td class="dcell">  ≤ |||<span style="font-style:italic">A</span><sup>−1</sup>|||  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">e</span>|</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">b</span>|</td></tr>
</table></td><td class="dcell"> |||<span style="font-style:italic">A</span>|||  </td></tr>
</table><p>
(la dernière inégalité s’obtient en écrivant <span style="font-style:italic">b</span>=<span style="font-style:italic">A</span>(<span style="font-style:italic">A</span><sup>−1</sup><span style="font-style:italic">b</span>)).
On en déduit que le rapport de l’erreur relative sur la solution par l’erreur
relative du second membre est majorée par
le produit de la norme de <span style="font-style:italic">A</span> (en tant qu’application linéaire)
par la norme de <span style="font-style:italic">A</span><sup>−1</sup>, ce produit est appelé conditionnement
de la matrice <span style="font-style:italic">A</span> (ou parfois nombre de condition de <span style="font-style:italic">A</span> en adoptant
la terminologie anglo-saxonne).</p><p>On remarquera que le conditionnement dépend du choix de la norme sur
l’espace vectoriel.
Si on prend comme norme la norme <span style="font-style:italic">L</span><sup>2</sup>, le calcul de |||<span style="font-style:italic">A</span>|||
nécessite de maximiser √<span style="text-decoration:overline">&lt;</span><span style="text-decoration:overline"><span style="font-style:italic">Ab</span></span><span style="text-decoration:overline">|</span><span style="text-decoration:overline"><span style="font-style:italic">Ab</span></span><span style="text-decoration:overline">&gt;</span> pour <span style="font-style:italic">b</span> de norme 1, ce qui revient
à maximiser √<span style="text-decoration:overline">&lt;</span><span style="text-decoration:overline"><span style="font-style:italic">b</span></span><span style="text-decoration:overline">|</span><span style="text-decoration:overline"><span style="font-style:italic">A</span></span><sup><span style="text-decoration:overline">*</span></sup><span style="text-decoration:overline"> </span><span style="text-decoration:overline"><span style="font-style:italic">A</span></span><span style="text-decoration:overline"> </span><span style="text-decoration:overline"><span style="font-style:italic">b</span></span><span style="text-decoration:overline">&gt;</span>. En diagonalisant la matrice hermitienne
<span style="font-style:italic">A</span><sup>*</sup> <span style="font-style:italic">A</span>, on voit qu’il suffit d’en trouver la plus grande valeur
propre et d’en prendre la racine carrée. Les valeurs propres de
<span style="font-style:italic">A</span><sup>*</sup><span style="font-style:italic">A</span> sont appelées valeurs singulières de <span style="font-style:italic">A</span> (ce sont des
réels positifs). Le même raisonnement pour <span style="font-style:italic">A</span><sup>−1</sup> (dont les
valeurs singulières sont les inverses des valeurs singulières de <span style="font-style:italic">A</span>) nous
donne alors le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 47</span>  <em>
Lorsqu’on résoud un système linéaire </em><span style="font-style:italic">Ax</span>=<span style="font-style:italic">b</span><em>, </em><span style="font-style:italic">A</span><em> matrice connue
précisément et inversible, </em><span style="font-style:italic">b</span><em> connu avec une erreur relative en
norme </em><span style="font-style:italic">L</span><sup>2</sup><em>, l’erreur relative en norme </em><span style="font-style:italic">L</span><sup>2</sup><em> sur </em><span style="font-style:italic">x</span><em> est au plus
multipliée par
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">K</span><sub>2</sub>(<span style="font-style:italic">A</span>)= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">λ<sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">λ<sub>1</sub></td></tr>
</table></td><td class="dcell"><em> </em></td></tr>
</table><em>
oú </em>λ<sub><span style="font-style:italic">n</span></sub><em> [resp. </em>λ<sub>1</sub><em>] est la plus grande [resp. plus
petite] valeur singulière de </em><span style="font-style:italic">A</span><em> (racines carrées des
valeurs propres de </em><span style="font-style:italic">A</span><sup>*</sup><span style="font-style:italic">A</span><em>).<br>
Ce facteur d’amplification des erreurs relatives est évidemment
supérieur ou égal à 1. Il est égal à 1 si la matrice est
unitaire (puisque </em><span style="font-style:italic">A</span><em> est une matrice
d’isométrie ou car </em><span style="font-style:italic">AA</span><sup>*</sup>=<span style="font-style:italic">I</span><em>). 
S’il est de l’ordre de </em>2<sup><span style="font-style:italic">c</span></sup><em> on perdra (au plus) </em><span style="font-style:italic">c</span><em> bits de
précision sur la mantisse de </em><span style="font-style:italic">x</span><em>.
</em></div><p>
Avec Xcas, les <span style="font-weight:bold">valeurs singulières</span><a id="hevea_default266"></a> 
<a id="hevea_default267"></a>
s’obtiennent par l’instruction
<code>SVL(A)</code>, le conditionnement <span style="font-style:italic">L</span><sup>2</sup> par <code>COND(A,2)</code>.
Attention, les valeurs singulières de <span style="font-style:italic">A</span> ne sont pas les valeurs
absolues des valeurs propres de <span style="font-style:italic">A</span> (c’est le cas si <span style="font-style:italic">A</span> 
commute avec sa transconjuguée mais ce n’est pas général).
On peut utiliser la méthode de la puissance (cf. infra) pour estimer la plus
grande valeur singulière de <span style="font-style:italic">A</span> (donc sans diagonaliser complètement
la matrice <span style="font-style:italic">A</span><sup>*</sup><span style="font-style:italic">A</span>), et de même sur <span style="font-style:italic">A</span><sup>−1</sup> (en utilisant <span style="font-style:italic">LU</span>
ou Cholesky pour trouver les itérées sans calculer <span style="font-style:italic">A</span><sup>−1</sup>).</p><p>On peut aussi prendre la norme <span style="font-style:italic">L</span><sup>1</sup> sur l’espace vectoriel, dans ce
cas la norme de matrice correspondante est la norme de colonne (exercice!),
le maximum des sommes valeurs absolues des éléments
des colonnes (<code>colNorm(A)</code> en Xcas) et le conditonnement
est le produit de <code>colNorm(A)</code> par <code>colNorm(inv(A))</code>
qui est renvoyé par <code>COND(A)</code> en Xcas.</p><p>Si la matrice du système <span style="font-style:italic">A</span> (de nombre de condition noté
κ(<span style="font-style:italic">A</span>)) est elle-même connue avec une
certaine incertitude, alors pour ||Δ <span style="font-style:italic">A</span>|| suffisamment petit,
la solution de
(<span style="font-style:italic">A</span>+Δ <span style="font-style:italic">A</span>)(<span style="font-style:italic">x</span>+Δ <span style="font-style:italic">x</span>)=<span style="font-style:italic">b</span>+Δ <span style="font-style:italic">b</span> vérifie
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">|Δ <span style="font-style:italic">x</span> |</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">x</span>|</td></tr>
</table></td><td class="dcell">≤
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">κ(<span style="font-style:italic">A</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−κ(<span style="font-style:italic">A</span>)</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">||Δ <span style="font-style:italic">A</span>||</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">||<span style="font-style:italic">A</span>||</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">|Δ <span style="font-style:italic">b</span>|</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">b</span>|</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">||Δ <span style="font-style:italic">A</span>||</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">||<span style="font-style:italic">A</span>||</td></tr>
</table></td><td class="dcell">
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
En effet, on a 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span> Δ <span style="font-style:italic">x</span> =Δ <span style="font-style:italic">b</span> − Δ <span style="font-style:italic">A</span>(<span style="font-style:italic">x</span>+Δ <span style="font-style:italic">x</span>)
⇒ Δ <span style="font-style:italic">x</span> = <span style="font-style:italic">A</span><sup>−1</sup>(Δ <span style="font-style:italic">b</span> − Δ <span style="font-style:italic">A</span>(<span style="font-style:italic">x</span>+Δ <span style="font-style:italic">x</span>))  </td></tr>
</table><p>
donc en norme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|| Δ <span style="font-style:italic">x</span> || ≤ |||<span style="font-style:italic">A</span><sup>−1</sup>||| (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">||Δ <span style="font-style:italic">b</span>||</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">||<span style="font-style:italic">b</span>||</td></tr>
</table></td><td class="dcell">||<span style="font-style:italic">Ax</span>||
+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">||| Δ <span style="font-style:italic">A</span> |||</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">|||<span style="font-style:italic">A</span>|||</td></tr>
</table></td><td class="dcell"> |||<span style="font-style:italic">A</span>||| (||<span style="font-style:italic">x</span>||+||Δ <span style="font-style:italic">x</span>||))</td></tr>
</table><p>
puis :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">|| Δ <span style="font-style:italic">x</span> ||</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">||<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> ≤ κ(<span style="font-style:italic">A</span>)
(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">||Δ <span style="font-style:italic">b</span>||</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">||<span style="font-style:italic">b</span>||</td></tr>
</table></td><td class="dcell">
+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">||| Δ <span style="font-style:italic">A</span> |||</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">|||<span style="font-style:italic">A</span>|||</td></tr>
</table></td><td class="dcell"> (1+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">|| Δ <span style="font-style:italic">x</span> ||</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">||<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell">) </td></tr>
</table>
<!--TOC subsection id="sec235" Réduction des endomorphismes-->
<h3 id="sec235" class="subsection">22.7  Réduction des endomorphismes</h3><!--SEC END -->
<!--TOC subsubsection id="sec236" Le polynôme minimal (Krylov)-->
<h4 id="sec236" class="subsubsection">22.7.1  Le polynôme minimal (Krylov)</h4><!--SEC END --><p><a id="hevea_default268"></a>
<a id="hevea_default269"></a>
On prend un vecteur <span style="font-style:italic">v</span> au hasard et on calcule la relation linéaire
de degré minimal entre <span style="font-style:italic">v</span>, <span style="font-style:italic">Av</span>, ..., <span style="font-style:italic">A</span><sup><span style="font-style:italic">n</span></sup><span style="font-style:italic">v</span> en cherchant
le premier vecteur <span style="font-style:italic">w</span> du noyau de la matrice obtenue en écrivant
les vecteurs <span style="font-style:italic">v</span>, <span style="font-style:italic">Av</span>, etc. en colonne dans cet ordre. Les
coordonnées de <span style="font-style:italic">w</span> donnent alors par ordre de degré croissant
un polynôme <span style="font-style:italic">P</span> de degré minimal tel que <span style="font-style:italic">P</span>(<span style="font-style:italic">A</span>)<span style="font-style:italic">v</span>=0 donc
<span style="font-style:italic">P</span> divise le polynôme minimal <span style="font-style:italic">M</span>. Donc si <span style="font-style:italic">P</span> est de
degré <span style="font-style:italic">n</span>, <span style="font-style:italic">P</span>=<span style="font-style:italic">M</span>. Sinon, il faut vérifier que le polynôme obtenu 
annule la matrice <span style="font-style:italic">A</span>. On peut aussi calculer en parallèle le polynôme <span style="font-style:italic">P</span>
précédent pour quelques vecteurs aléatoires et prendre le PPCM des
polynômes obtenus.</p><p><span style="font-weight:bold">Exemple 1</span><br>
Polynôme minimal de (</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >4
</td></tr>
</table><p>) . On prend <span style="font-style:italic">v</span>=(1,0), la matrice à réduire est
alors :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >−11 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >10</td><td style="text-align:center;white-space:nowrap" >38
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell">→ 
</td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >−6 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >5
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td></tr>
</table><p>
Le noyau est engendré par (−6,5,−1) donc <span style="font-style:italic">P</span>=−<span style="font-style:italic">x</span><sup>2</sup>+5<span style="font-style:italic">x</span>−6.</p><p><span style="font-weight:bold">Exemple 2</span><br>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>=</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > 3</td><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >−2 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
en prenant <span style="font-style:italic">v</span>=(1,0,0) on obtient la matrice :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>=</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >3</td><td style="text-align:center;white-space:nowrap" >5</td><td style="text-align:center;white-space:nowrap" >7 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >−2</td><td style="text-align:center;white-space:nowrap" >−3 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >3
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">→
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >−2 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >3 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
le permier vecteur du noyau est (−1,2,−1) d’où un polynôme divisant
le polynôme minimal −<span style="font-style:italic">x</span><sup>2</sup>+2<span style="font-style:italic">x</span>−1.</p>
<!--TOC subsubsection id="sec237" Le polynôme caractéristique-->
<h4 id="sec237" class="subsubsection">22.7.2  Le polynôme caractéristique</h4><!--SEC END --><p>
<a id="hevea_default270"></a>
Pour une matrice générique, le polynôme caractéristique est égal
au polynôme minimal, il est donc intéressant de chercher si le polynôme
annulateur de <span style="font-style:italic">A</span> sur un vecteur aléatoire est de degré <span style="font-style:italic">n</span>, 
car le temps de calcul du polynôme caractéristique est alors en <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>3</sup>). 
Si cette méthode probabiliste échoue, on se
rabat sur une des méthode déterministe ci-dessous:
</p><ul class="itemize"><li class="li-itemize">
on utilise la formule det(λ <span style="font-style:italic">I</span> −<span style="font-style:italic">A</span>) déterminé par
une des méthodes de calcul de déterminant ci-dessus. Cela
nécessite <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>3</sup>) opérations mais avec des coefficients 
polynômes en λ.
</li><li class="li-itemize">on fait une interpolation de Lagrange en donnant <span style="font-style:italic">n</span>+1 valeurs
distinctes à λ. Ce qui nécessite <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>4</sup>) opérations mais avec
des coefficients indépendants de λ, de plus cette méthode 
est facile à programmer de manière parallèle.
</li><li class="li-itemize">si la matrice est à coefficients entiers
on peut utiliser la méthode de Hessenberg (voir ci-dessous), on calcule
une borne à priori sur les coefficients du polynôme caractéristique
(cf. Cohen p.58-59) :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>| ≤ </td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span>−<span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell">
(<span style="font-style:italic">n</span>−<span style="font-style:italic">k</span>)<sup>(<span style="font-style:italic">n</span>−<span style="font-style:italic">k</span>)/2</sup> |<span style="font-style:italic">M</span>|<sup><span style="font-style:italic">n</span>−<span style="font-style:italic">k</span></sup>  ,</td></tr>
</table>
on calcule le polynôme caractéristique modulo suffisamment
de petits entiers puis on remonte par les restes chinois.
</li></ul>
<!--TOC subsubsection id="sec238" La méthode de Hessenberg-->
<h4 id="sec238" class="subsubsection">22.7.3  La méthode de Hessenberg</h4><!--SEC END --><p><a id="hevea_default271"></a>
Pour les matrices à coefficients de taille bornée (modulaires par exemple)
on préfère la méthode de Hessenberg qui est plus
efficace, car elle nécessite de l’ordre de <span style="font-style:italic">n</span><sup>3</sup> opérations sur
les coefficients.</p><p>On se raméne d’abord à une matrice triangulaire supérieure à
une diagonale près qui est semblable à la
matrice de départ puis on
applique une formule de récurrence pour calculer les coefficients
du polynôme caractéristique.</p><p><span style="font-weight:bold">Algorithme de réduction de Hessenberg:</span><br>
Dans une colonne <span style="font-style:italic">m</span> donnée de la matrice <span style="font-style:italic">H</span>, 
on cherche à partir de la ligne
<span style="font-style:italic">m</span>+1 un coefficient non nul. S’il n’y en a pas on passe à la colonne
suivante. S’il y en a un en ligne <span style="font-style:italic">i</span>, on échange les lignes <span style="font-style:italic">m</span>+1
et <span style="font-style:italic">i</span> et les colonnes <span style="font-style:italic">m</span>+1 et <span style="font-style:italic">i</span>. Ensuite pour tout <span style="font-style:italic">i</span>≥ <span style="font-style:italic">m</span>+2,
soit <span style="font-style:italic">u</span>=<span style="font-style:italic">H</span><sub><span style="font-style:italic">i</span>,<span style="font-style:italic">m</span></sub>/<span style="font-style:italic">H</span><sub><span style="font-style:italic">m</span>+1,<span style="font-style:italic">m</span></sub>, on remplace alors la ligne <span style="font-style:italic">L</span><sub><span style="font-style:italic">i</span></sub> de <span style="font-style:italic">H</span>
par <span style="font-style:italic">L</span><sub><span style="font-style:italic">i</span></sub>−<span style="font-style:italic">uL</span><sub><span style="font-style:italic">m</span>+1</sub> et la colonne <span style="font-style:italic">C</span><sub><span style="font-style:italic">m</span>+1</sub> par <span style="font-style:italic">C</span><sub><span style="font-style:italic">m</span>+1</sub>+<span style="font-style:italic">uC</span><sub><span style="font-style:italic">i</span></sub>
ce qui revient “à remplacer le vecteur <span style="font-style:italic">e</span><sub><span style="font-style:italic">m</span>+1</sub> de la base
par le vecteur <span style="font-style:italic">e</span><sub><span style="font-style:italic">m</span>+1</sub>+<span style="font-style:italic">ue</span><sub><span style="font-style:italic">i</span></sub>” ou plus précisément
à multiplier à gauche par 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−<span style="font-style:italic">u</span></td><td style="text-align:center;white-space:nowrap" >1</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td></tr>
</table><p> 
et à droite par la matrice inverse
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">u</span></td><td style="text-align:center;white-space:nowrap" >1</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td></tr>
</table><p> 
(en utilisant les lignes et colonnes
<span style="font-style:italic">m</span>+1 et <span style="font-style:italic">i</span> au lieu de 1 et 2 pour ces matrices). 
Ceci a pour effet d’annuler le coefficient <span style="font-style:italic">H</span><sub><span style="font-style:italic">i</span>,<span style="font-style:italic">m</span></sub>
dans la nouvelle matrice.</p><p>On obtient ainsi en <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>3</sup>) opérations
une matrice <span style="font-style:italic">H</span>′ semblable à <span style="font-style:italic">H</span> de la forme :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>1,1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>1,2</sub></td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>1,<span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>1,<span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>1,<span style="font-style:italic">n</span></sub></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>2,1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>2,2</sub></td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>2,<span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>2,<span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>2,<span style="font-style:italic">n</span></sub> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>3,2</sub></td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>3,<span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>3,<span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>3,<span style="font-style:italic">n</span></sub> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>4,<span style="font-style:italic">n</span>−2</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>4,<span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub>4,<span style="font-style:italic">n</span></sub> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >⋮ </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub><span style="font-style:italic">n</span>,<span style="font-style:italic">n</span>−1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>′<sub><span style="font-style:italic">n</span>,<span style="font-style:italic">n</span></sub>
</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
On calcule alors le polynôme caractéristique de <span style="font-style:italic">H</span>′ par une récurrence
qui s’obtient en développant le déterminant par rapport à la dernière
colonne :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">h</span><sub><span style="font-style:italic">n</span></sub>(λ) = det(λ <span style="font-style:italic">I</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">H</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >(λ−<span style="font-style:italic">H</span>′<sub><span style="font-style:italic">n</span>,<span style="font-style:italic">n</span></sub>) <span style="font-style:italic">h</span><sub><span style="font-style:italic">n</span>−1</sub>(λ) −(−<span style="font-style:italic">H</span>′<sub><span style="font-style:italic">n</span>−1,<span style="font-style:italic">n</span></sub>) (−<span style="font-style:italic">H</span>′<sub><span style="font-style:italic">n</span>,<span style="font-style:italic">n</span>−1</sub>) 
<span style="font-style:italic">h</span><sub><span style="font-style:italic">n</span>−2</sub>(λ) + </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >    + (−<span style="font-style:italic">H</span>′<sub><span style="font-style:italic">n</span>−2,<span style="font-style:italic">n</span></sub>) (−<span style="font-style:italic">H</span>′<sub><span style="font-style:italic">n</span>,<span style="font-style:italic">n</span>−1</sub>) (−<span style="font-style:italic">H</span>′<sub><span style="font-style:italic">n</span>−1,<span style="font-style:italic">n</span>−2</sub>) <span style="font-style:italic">h</span><sub><span style="font-style:italic">n</span>−3</sub>(λ) − ...
</td></tr>
</table></td></tr>
</table><p>
où les <span style="font-style:italic">h</span><sub><span style="font-style:italic">i</span></sub> s’entendent en gardant les <span style="font-style:italic">i</span> premières lignes/colonnes de <span style="font-style:italic">H</span>′.
On peut écrire cette formule pour <span style="font-style:italic">m</span>≤ <span style="font-style:italic">n</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">h</span><sub><span style="font-style:italic">m</span></sub>(λ)= (λ − <span style="font-style:italic">H</span>′<sub><span style="font-style:italic">m</span>,<span style="font-style:italic">m</span></sub>) <span style="font-style:italic">h</span><sub><span style="font-style:italic">m</span>−1</sub>(λ)
−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">H</span>′<sub><span style="font-style:italic">m</span>−<span style="font-style:italic">i</span>,<span style="font-style:italic">m</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">H</span>′<sub><span style="font-style:italic">m</span>−<span style="font-style:italic">j</span>+1,<span style="font-style:italic">m</span>−<span style="font-style:italic">j</span></sub> <span style="font-style:italic">h</span><sub><span style="font-style:italic">i</span>−1</sub>(λ)</td></tr>
</table><p>
Pour effectuer cette récurrence de manière efficace, on conserve
les <span style="font-style:italic">h</span><sub><span style="font-style:italic">m</span></sub>(λ) dans un tableau de polynômes et on utilise une 
variable produit contenant successivement les ∏<span style="font-style:italic">H</span>′<sub><span style="font-style:italic">m</span>−<span style="font-style:italic">j</span>+1,<span style="font-style:italic">m</span>−<span style="font-style:italic">j</span></sub>.</p><p><span style="font-weight:bold">Remarques</span>
Une variante de la réduction ci-dessus utilise des matrices de
<span style="font-weight:bold">rotation de Givens</span><a id="hevea_default272"></a> : il s’agit d’une rotation
dans le plan engendré par deux vecteurs de base <span style="font-style:italic">e</span><sub><span style="font-style:italic">i</span></sub>,<span style="font-style:italic">e</span><sub><span style="font-style:italic">j</span></sub> 
prolongée par l’identité. On doit alors effectuer 
deux combinaisons linéaires de ligne
et deux combinaisons linéaires de colonnes par transformation
donc deux fois plus de calculs, mais l’avantage est que la matrice
de transformation est unitaire (donc facile à inverser, et bien
conditionnée).</p><p>On peut aussi utiliser des <span style="font-weight:bold">matrices de
Householder</span><a id="hevea_default273"></a> 
pour se ramener à une forme de Hessenberg.
La matrice de Householder associée à <span style="font-style:italic">v</span> est définie par ;
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">H</span>=<span style="font-style:italic">I</span>−2</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span> <span style="font-style:italic">v</span><sup><span style="font-style:italic">t</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">||<span style="font-style:italic">v</span>||<sup>2</sup></td></tr>
</table></td></tr>
</table><p>
c’est la matrice de la symétrie par rapport à l’hyperplan 
perpendiculaire à <span style="font-style:italic">v</span>, <span style="font-style:italic">Hv</span>=−<span style="font-style:italic">v</span> et pour tout vecteur
perpendiculaire à <span style="font-style:italic">v</span> on a <span style="font-style:italic">Hw</span>=<span style="font-style:italic">w</span>, donc <span style="font-style:italic">H</span> est orthogonale.
On l’utilise en général pour <span style="font-style:italic">v</span>=<span style="font-style:italic">a</span>−<span style="font-style:italic">b</span> avec ||<span style="font-style:italic">a</span>||=||<span style="font-style:italic">b</span>||,
on a alors <span style="font-style:italic">Ha</span>=<span style="font-style:italic">b</span> puisque <span style="font-style:italic">H</span>(<span style="font-style:italic">a</span>−<span style="font-style:italic">b</span>)=<span style="font-style:italic">b</span>−<span style="font-style:italic">a</span> car <span style="font-style:italic">v</span>=<span style="font-style:italic">a</span>−<span style="font-style:italic">b</span> et <span style="font-style:italic">H</span>(<span style="font-style:italic">a</span>+<span style="font-style:italic">b</span>)=<span style="font-style:italic">a</span>+<span style="font-style:italic">b</span>
car <span style="font-style:italic">v</span> est orthogonal à <span style="font-style:italic">a</span>+<span style="font-style:italic">b</span> (puisque ||<span style="font-style:italic">a</span>||=||<span style="font-style:italic">b</span>||).</p><p>On peut enfin utiliser l’algorithme de <span style="font-weight:bold">Danilevsky</span><a id="hevea_default274"></a>. 
Il s’agit un peu
d’un analogue de la méthode du pivot de Gauss pour se ramener
à une matrice companion semblable (avec des 1 sur
la diagonale au-dessus de la diagonale
principale et le polynôme caractéristique en dernière
ligne). Cela se fait ligne par ligne en commençant par
la ligne <span style="font-style:italic">k</span>=0. On multiplie à gauche par <span style="font-style:italic">P</span> une matrice identité
dont la ligne <span style="font-style:italic">k</span>+1 est remplacée par la ligne <span style="font-style:italic">k</span> de la matrice
et à droite par son inverse <span style="font-style:italic">P</span><sup>−1</sup>, qui est une matrice identité sauf
en ligne <span style="font-style:italic">k</span>+1. Comme la <span style="font-style:italic">k</span>+1-ième ligne de <span style="font-style:italic">P</span> est la <span style="font-style:italic">k</span>-ième
ligne de la matrice <span style="font-style:italic">A</span>, le produit à droite par <span style="font-style:italic">P</span><sup>−1</sup> va remplacer
la <span style="font-style:italic">k</span>-ième ligne de la matrice <span style="font-style:italic">A</span> par la <span style="font-style:italic">k</span>+1-ième ligne de <span style="font-style:italic">I</span>=<span style="font-style:italic">PP</span><sup>−1</sup>.
Le produit à gauche par <span style="font-style:italic">P</span> préserve les <span style="font-style:italic">k</span> premières lignes.
Quand on programme cet algorithme, on traduit le produit à droite
par une opération sur les colonnes, et le produit à gauche par
une opération sur les lignes, on ne doit faire ces opérations qu’à 
partir de la ligne <span style="font-style:italic">k</span>.</p><p>Exemple sur une matrice 3,3 :
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">a:=[[1,2,3],[1,-1,1],[2,-3,3]] 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
Réduction de la 1ère ligne :
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">p:=idn(3):; p[1]:=a[0]; inv(p); a*inv(p); b:=p*a*inv(p); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
Deuxième ligne :
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">p:=idn(3):; p[2]:=b[1]; inv(p); b*inv(p); c:=p*b*inv(p) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
on lit le polynôme caractéristique en dernière ligne
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">[1,op(revlist(-c[2]))];charpoly(a) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
Notons (<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span>,0</sub>,...,<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span>,<span style="font-style:italic">n</span>−1</sub>) la <span style="font-style:italic">k</span>-ième ligne de <span style="font-style:italic">A</span>,
donc la <span style="font-style:italic">k</span>+1-i‘eme ligne de <span style="font-style:italic">P</span>, alors la <span style="font-style:italic">k</span>+1-ième ligne de 
<span style="font-style:italic">P</span><sup>−1</sup> a comme coefficients −<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span>,<span style="font-style:italic">j</span></sub>/<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span>,<span style="font-style:italic">k</span>+1</sub> si <span style="font-style:italic">j</span>≠ <span style="font-style:italic">k</span> et 
1/<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span>,<span style="font-style:italic">k</span>+1</sub> pour <span style="font-style:italic">j</span>=<span style="font-style:italic">k</span>. 
Les opérations de colonnes correspondant à <span style="font-style:italic">AP</span><sup>−1</sup> sont donc
<span style="font-style:italic">C</span><sub><span style="font-style:italic">j</span></sub> ← <span style="font-style:italic">C</span><sub><span style="font-style:italic">j</span></sub>−<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span>,<span style="font-style:italic">j</span></sub>/<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span>,<span style="font-style:italic">k</span>+1</sub><span style="font-style:italic">C</span><sub><span style="font-style:italic">k</span>+1</sub> si <span style="font-style:italic">j</span> ≠ <span style="font-style:italic">k</span> et 
<span style="font-style:italic">C</span><sub><span style="font-style:italic">k</span>+1</sub> ← <span style="font-style:italic">C</span><sub><span style="font-style:italic">k</span>+1</sub>/<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span>,<span style="font-style:italic">k</span>+1</sub>. Puis l’opération de ligne
correspondant à <span style="font-style:italic">PA</span> est <span style="font-style:italic">L</span><sub><span style="font-style:italic">k</span>+1</sub> ← ∑<sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span>,<span style="font-style:italic">j</span></sub> <span style="font-style:italic">L</span><sub><span style="font-style:italic">j</span></sub> (on peut
commencer la somme à <span style="font-style:italic">k</span>+1 si on initialise la ligne à
(0,<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span>,0</sub>,..,<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span>,<span style="font-style:italic">k</span></sub>,0,...0)).
Dans l’exemple, pour <span style="font-style:italic">k</span>=0 on a <span style="font-style:italic">a</span><sub>0,1</sub>=2 donc on fait
<span style="font-style:italic">C</span><sub>1</sub>=<span style="font-style:italic">C</span><sub>1</sub>−1/2<span style="font-style:italic">C</span><sub>2</sub>, <span style="font-style:italic">C</span><sub>2</sub>=<span style="font-style:italic">C</span><sub>2</sub>/2, <span style="font-style:italic">C</span><sub>3</sub>=<span style="font-style:italic">C</span><sub>3</sub>−3<span style="font-style:italic">C</span><sub>2</sub>/2 puis <span style="font-style:italic">L</span><sub>2</sub>=<span style="font-style:italic">L</span><sub>1</sub>+2<span style="font-style:italic">L</span><sub>2</sub>+3<span style="font-style:italic">L</span><sub>3</sub>.
Pour <span style="font-style:italic">k</span>=1, on a <span style="font-style:italic">b</span><sub>1,2</sub>=55/2 donc on fait 
<span style="font-style:italic">C</span><sub>1</sub>=<span style="font-style:italic">C</span><sub>1</sub>−27/55<span style="font-style:italic">C</span><sub>3</sub>, <span style="font-style:italic">C</span><sub>2</sub>=<span style="font-style:italic">C</span><sub>2</sub>+9/55<span style="font-style:italic">C</span><sub>3</sub>, <span style="font-style:italic">C</span><sub>3</sub>=2/55<span style="font-style:italic">C</span><sub>3</sub> puis
<span style="font-style:italic">L</span><sub>3</sub>=27/2<span style="font-style:italic">L</span><sub>1</sub>−9/2<span style="font-style:italic">L</span><sub>2</sub>+55/2<span style="font-style:italic">L</span><sub>3</sub>.</p><p>Si au cours du calcul <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span>,<span style="font-style:italic">k</span>+1</sub>=0, il faut chercher un “pivot” non nul
sur la ligne <span style="font-style:italic">k</span> à partir de la colonne <span style="font-style:italic">k</span>+1, on échange ensuite les
colonnes et les lignes <span style="font-style:italic">k</span>+1 et <span style="font-style:italic">k</span>′ correspondantes. Si tout le reste
de la ligne est nul, alors le polynomôme caractéristique est le
produit du polynôme de la matrice companion lignes et colonnes 
0 à <span style="font-style:italic">k</span> incluses et de la matrice lignes et colonnes <span style="font-style:italic">k</span>+1 à <span style="font-style:italic">n</span>−1.</p>
<!--TOC subsubsection id="sec239" La méthode de
Leverrier-Faddeev-Souriau-->
<h4 id="sec239" class="subsubsection">22.7.4  La méthode de
Leverrier-Faddeev-Souriau</h4><!--SEC END --><p><a id="hevea_default275"></a> <a id="hevea_default276"></a><a id="hevea_default277"></a>
Cette méthode permet le calcul simultané des coefficients 
<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub>  (<span style="font-style:italic">i</span>=0..<span style="font-style:italic">n</span>) du polynôme caractéristique 
<span style="font-style:italic">P</span>(λ)=det(λ <span style="font-style:italic">I</span>−<span style="font-style:italic">A</span>) et des coefficients matriciels
<span style="font-style:italic">B</span><sub><span style="font-style:italic">i</span></sub>  (<span style="font-style:italic">i</span>=0..<span style="font-style:italic">n</span>−1) du polynôme en λ donnant la matrice adjointe
(ou transposée de la comatrice) <span style="font-style:italic">B</span>(λ) de λ <span style="font-style:italic">I</span> −<span style="font-style:italic">A</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:Bp"></a>
(λ <span style="font-style:italic">I</span> −<span style="font-style:italic">A</span>)<span style="font-style:italic">B</span>(λ)=(λ <span style="font-style:italic">I</span> −<span style="font-style:italic">A</span>) </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>≤ <span style="font-style:italic">n</span>−1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub> λ<sup><span style="font-style:italic">k</span></sup>
= (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>≤ <span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> λ<sup><span style="font-style:italic">k</span></sup>)<span style="font-style:italic">I</span> =<span style="font-style:italic">P</span>(λ)<span style="font-style:italic">I</span>
    (46)</td></tr>
</table><p>
Remarquons que cette équation donne une démonstration assez simple
de Cayley-Hamilton puisque le reste de la division euclidienne
du polynôme <span style="font-style:italic">P</span>(λ)<span style="font-style:italic">I</span> par λ <span style="font-style:italic">I</span> −<span style="font-style:italic">A</span>  est <span style="font-style:italic">P</span>(<span style="font-style:italic">A</span>).</p><p>Pour déterminer simultanément les <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> et <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub>,
on a les relations de récurrence :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
<a id="eq:Bp1"></a> <span style="font-style:italic">B</span><sub><span style="font-style:italic">n</span>−1</sub>=<span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">I</span>=<span style="font-style:italic">I</span>,    <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub>−<span style="font-style:italic">AB</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span>+1</sub> <span style="font-style:italic">I</span>
    (47)</td></tr>
</table><p>
Il nous manque une relation entre les <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> et <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub> pour pouvoir
faire le calcul par valeurs décroissantes de <span style="font-style:italic">k</span>, on va montrer le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 48</span>  <em>
La dérivée du polynôme caractéristique </em><span style="font-style:italic">P</span>′(λ)<em>,
est égale à la trace de la matrice adjointe 
de </em>λ <span style="font-style:italic">I</span>−<span style="font-style:italic">A</span><em>
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">tr(<span style="font-style:italic">B</span>)=<span style="font-style:italic">P</span>′(λ) </td></tr>
</table><em>
</em></div><p>
Le théorème nous donne tr(<span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub>) = (<span style="font-style:italic">k</span>+1)<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span>+1</sub> .
Si on prend la trace de (<a href="#eq%3ABp1">47</a>), on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">tr(<span style="font-style:italic">B</span><sub><span style="font-style:italic">n</span>−1</sub>)=<span style="font-style:italic">n</span> <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub>,    (<span style="font-style:italic">k</span>+1)<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span>+1</sub> −tr(<span style="font-style:italic">AB</span><sub><span style="font-style:italic">k</span>+1</sub>)
=<span style="font-style:italic">np</span><sub><span style="font-style:italic">k</span>+1</sub> </td></tr>
</table><p>
donc on calcule <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span>+1</sub> en fonction de <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>+1</sub> puis <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span>+1</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">tr(<span style="font-style:italic">AB</span><sub><span style="font-style:italic">k</span>+1</sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>+1−<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">, 
   <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">AB</span><sub><span style="font-style:italic">k</span>+1</sub>+<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span>+1</sub> <span style="font-style:italic">I</span> </td></tr>
</table><p>
<span style="font-weight:bold">Démonstration du théorème:</span><br>
Soient <span style="font-style:italic">V</span><sub>1</sub>(λ),...<span style="font-style:italic">V</span><sub><span style="font-style:italic">n</span></sub>(λ) les vecteurs colonnes 
de λ <span style="font-style:italic">I</span>−<span style="font-style:italic">A</span> et <span style="font-style:italic">b</span><sub><span style="font-style:italic">i</span>,<span style="font-style:italic">j</span></sub>(λ) les coefficients de <span style="font-style:italic">B</span>, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">P</span>′(λ<sub>0</sub>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >det(<span style="font-style:italic">V</span><sub>1</sub>(λ),<span style="font-style:italic">V</span><sub>2</sub>(λ),...,<span style="font-style:italic">V</span><sub><span style="font-style:italic">n</span></sub>(λ) )′
<sub>|λ=λ<sub>0</sub></sub></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >det(<span style="font-style:italic">V</span>′<sub>1</sub>(λ<sub>0</sub>),<span style="font-style:italic">V</span><sub>2</sub>(λ<sub>0</sub>),...,<span style="font-style:italic">V</span><sub><span style="font-style:italic">n</span></sub>(λ<sub>0</sub>) )+
det(<span style="font-style:italic">V</span><sub>1</sub>(λ<sub>0</sub>),<span style="font-style:italic">V</span>′<sub>2</sub>(λ<sub>0</sub>),...,<span style="font-style:italic">V</span><sub><span style="font-style:italic">n</span></sub>(λ<sub>0</sub>) )+ </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >+...+det(<span style="font-style:italic">V</span><sub>1</sub>(λ<sub>0</sub>),<span style="font-style:italic">V</span><sub>2</sub>(λ<sub>0</sub>),...,<span style="font-style:italic">V</span>′<sub><span style="font-style:italic">n</span></sub>(λ<sub>0</sub>) )
</td></tr>
</table></td></tr>
</table><p>
Il suffit alors de remarquer que
<span style="font-style:italic">V</span>′<sub><span style="font-style:italic">i</span></sub>(λ<sub>0</sub>) est le <span style="font-style:italic">i</span>-ième vecteur de la base canonique donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">det(<span style="font-style:italic">V</span><sub>1</sub>(λ<sub>0</sub>),<span style="font-style:italic">V</span><sub>2</sub>(λ<sub>0</sub>),...,<span style="font-style:italic">V</span>′<sub><span style="font-style:italic">i</span></sub>(λ<sub>0</sub>),...,<span style="font-style:italic">V</span><sub><span style="font-style:italic">n</span></sub>(λ<sub>0</sub>) )
=<span style="font-style:italic">b</span><sub><span style="font-style:italic">i</span>,<span style="font-style:italic">i</span></sub>(λ<sub>0</sub>) </td></tr>
</table><p>
Finalement :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>′(λ<sub>0</sub>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">b</span><sub><span style="font-style:italic">i</span>,<span style="font-style:italic">i</span></sub>(λ<sub>0</sub>)=tr (<span style="font-style:italic">B</span>(λ<sub>0</sub>)) </td></tr>
</table><p><span style="font-weight:bold">Remarque</span> :<br>
En réindexant les coefficients de <span style="font-style:italic">P</span> et <span style="font-style:italic">B</span> de la manière suivante :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">P</span>(λ)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >λ<sup><span style="font-style:italic">n</span></sup>+<span style="font-style:italic">p</span><sub>1</sub>λ<sup><span style="font-style:italic">n</span>−1</sup>+<span style="font-style:italic">p</span><sub>2</sub>λ<sup><span style="font-style:italic">n</span>−2</sup>...+<span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">B</span>(λ)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >λ<sup><span style="font-style:italic">n</span>−1</sup><span style="font-style:italic">I</span>+λ<sup><span style="font-style:italic">n</span>−2</sup><span style="font-style:italic">B</span><sub>1</sub>+...+<span style="font-style:italic">B</span><sub><span style="font-style:italic">n</span>−1</sub>
</td></tr>
</table></td></tr>
</table><p>
on a montré que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎧<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎨<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎩</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span><sub>1</sub>=<span style="font-style:italic">A</span>,</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">p</span><sub>1</sub>=−tr(<span style="font-style:italic">A</span>),</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span><sub>1</sub>=<span style="font-style:italic">A</span><sub>1</sub>+<span style="font-style:italic">p</span><sub>1</sub><span style="font-style:italic">I</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span><sub>2</sub>=<span style="font-style:italic">AB</span><sub>1</sub>,</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">p</span><sub>2</sub>=−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">tr(<span style="font-style:italic">A</span><sub>2</sub>),</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span><sub>2</sub>=<span style="font-style:italic">A</span><sub>2</sub>+<span style="font-style:italic">p</span><sub>2</sub><span style="font-style:italic">I</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >⋮ </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">AB</span><sub><span style="font-style:italic">k</span>−1</sub>,</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>=−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">tr(<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>),</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>+<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">I</span>
</td></tr>
</table></td><td class="dcell">
</td></tr>
</table><p>
On peut alors vérifier que <span style="font-style:italic">B</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>+<span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">I</span>=0.
D’où ce petit programme :
</p><pre class="verbatim">Faddeev(A):={ // renvoie la liste des matrices B et le polynome P
  local Aj,AAj,Id,coef,n,pcara,lmat,j;
  n:=ncols(A);
  Id:=idn(n);     // matrice identite
  Aj:=Id;
  lmat:=[];      // B initialise a liste vide
  pcara:=[1];    // coefficient de plus grand degre de P
  for j from 1 to n do
    lmat:=append(lmat,Aj);  // rajoute Aj a la liste de matrices
    AAj:=Aj*A;
    coef:=-trace(AAj)/j;    
    pcara:=append(pcara,coef);  // rajoute coef au pol. caract.
    Aj:=AAj+coef*Id;
   end_for;
  return lmat,pcara;        // resultat
}:;
</pre>
<!--TOC subsubsection id="sec240" Les vecteurs propres simples.-->
<h4 id="sec240" class="subsubsection">22.7.5  Les vecteurs propres simples.</h4><!--SEC END --><p>
On suppose ici qu’on peut factoriser le polynôme caractéristique
(ou calculer dans une extension algébrique d’un corps).
Lorsqu’on a une valeur propre simple λ<sub>0</sub>, en écrivant
la relation (<span style="font-style:italic">A</span>−λ<sub>0</sub> <span style="font-style:italic">I</span>)<span style="font-style:italic">B</span>(λ<sub>0</sub>)=<span style="font-style:italic">P</span>(λ<sub>0</sub>)<span style="font-style:italic">I</span>=0,
on voit que les vecteurs colonnes de la matrice <span style="font-style:italic">B</span>(λ<sub>0</sub>)
sont vecteurs propres.
Remarquer que <span style="font-style:italic">B</span>(λ<sub>0</sub>) ≠ 0 sinon on pourrait factoriser
λ−λ<sub>0</sub> dans <span style="font-style:italic">B</span>(λ) et apres simplifications on aurait :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">A</span>−λ<sub>0</sub> <span style="font-style:italic">I</span>)</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">λ−λ<sub>0</sub></td></tr>
</table></td><td class="dcell">(λ<sub>0</sub>)=
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">λ−λ<sub>0</sub></td></tr>
</table></td><td class="dcell">(λ<sub>0</sub>)<span style="font-style:italic">I</span> </td></tr>
</table><p>
or le 2ème membre est inversible en λ<sub>0</sub> ce qui n’est pas le
cas du premier.
Pour avoir une base des vecteurs propres associés à λ<sub>0</sub>, on
calcule <span style="font-style:italic">B</span>(λ<sub>0</sub>)  par la méthode de Horner appliquée au
polynôme <span style="font-style:italic">B</span>(λ) en λ=λ<sub>0</sub>, et on réduit en
colonnes la matrice obtenue.</p>
<!--TOC subsubsection id="sec241" La forme normale de Jordan-->
<h4 id="sec241" class="subsubsection">22.7.6  La forme normale de Jordan</h4><!--SEC END --><p> <a id="sec:jordan"></a><a id="hevea_default278"></a>
Pour les valeurs propres de multiplicité plus grande que 1, on souhaiterait 
généraliser la méthode ci-dessus pour obtenir une base
de l’espace caractéristique, sous forme de cycles de Jordan.
Soit λ <sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub> les valeurs propres comptées avec leur 
multiplicité. On fait un développement de Taylor en
λ <sub><span style="font-style:italic">i</span></sub>:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >−<span style="font-style:italic">P</span>(λ )<span style="font-style:italic">I</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">A</span>−λ <span style="font-style:italic">I</span>)</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">
<span style="font-style:italic">B</span>(λ<sub><span style="font-style:italic">i</span></sub> )+ <span style="font-style:italic">B</span>′(λ <sub><span style="font-style:italic">i</span></sub>)(λ −λ <sub><span style="font-style:italic">i</span></sub>)
+ ... +  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sup>(<span style="font-style:italic">n</span>−1)</sup>(λ<sub><span style="font-style:italic">i</span></sub> )</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>−1)!</td></tr>
</table></td><td class="dcell"> 
(λ −λ <sub><span style="font-style:italic">i</span></sub>)<sup><span style="font-style:italic">n</span>−1</sup> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">−(λ −λ <sub><span style="font-style:italic">i</span></sub>)<sup><span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub></sup>
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>≠ <span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> (λ −λ <sub><span style="font-style:italic">j</span></sub>)<sup><span style="font-style:italic">n</span><sub><span style="font-style:italic">j</span></sub></sup> <span style="font-style:italic">I</span> 
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Comme <span style="font-style:italic">A</span>−λ <span style="font-style:italic">I</span>=<span style="font-style:italic">A</span>−λ <sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">I</span> − (λ −λ <sub><span style="font-style:italic">i</span></sub>)<span style="font-style:italic">I</span>, on obtient
pour les <span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub> premières puissances de λ −λ <sub><span style="font-style:italic">i</span></sub>:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">


     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><a id="eq:jordan1"> </a>
(<span style="font-style:italic">A</span>−λ <sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">I</span>) <span style="font-style:italic">B</span>(λ <sub><span style="font-style:italic">i</span></sub>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >0</td><td style="text-align:right;white-space:nowrap" >    (48)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >(<span style="font-style:italic">A</span>−λ <sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">I</span>) <span style="font-style:italic">B</span>′(λ <sub><span style="font-style:italic">i</span></sub>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">B</span>(λ<sub><span style="font-style:italic">i</span></sub> )</td><td style="text-align:right;white-space:nowrap" >    (49)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" > ...</td><td style="text-align:left;white-space:nowrap" > </td><td style="text-align:right;white-space:nowrap" >    (50)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">A</span>−λ <sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">I</span>) </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sup>(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−1)</sup>(λ <sub><span style="font-style:italic">i</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−1)!</td></tr>
</table></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sup>(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−2)</sup>(λ <sub><span style="font-style:italic">i</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−2)!</td></tr>
</table></td><td class="dcell"> <a id="eq:jordan3"> </a> </td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >    (51)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">A</span>−λ <sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">I</span>)</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sup>(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>)</sup>(λ<sub><span style="font-style:italic">i</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>!</td></tr>
</table></td><td class="dcell"> −  
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sup>(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−1)</sup>(λ<sub><span style="font-style:italic">i</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−1)!</td></tr>
</table></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>≠ <span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell">(λ <sub><span style="font-style:italic">i</span></sub>−λ <sub><span style="font-style:italic">j</span></sub>)<sup><span style="font-style:italic">n</span><sub><span style="font-style:italic">j</span></sub></sup> <span style="font-style:italic">I</span> <a id="eq:jordan4"> </a>
</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >    (52)</td></tr>
</table></td></tr>
</table><p>
Le calcul des matrices <span style="font-style:italic">B</span><sup>(<span style="font-style:italic">n</span>)</sup>(λ <sub><span style="font-style:italic">i</span></sub>)/<span style="font-style:italic">n</span>! pour <span style="font-style:italic">n</span>&lt;<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub> se fait en
appliquant <span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub> fois l’algorithme de Horner (avec reste).</p><div class="theorem"><span style="font-weight:bold">Théorème 49</span>  <em> </em><a id="th:jordan"></a><em>
L’espace caractéristique de </em>λ <sub><span style="font-style:italic">i</span></sub><em> est égal à
l’image de </em><span style="font-style:italic">B</span><sup>(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−1)</sup>(λ <sub><span style="font-style:italic">i</span></sub>)/(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−1)!<em>.
</em></div><p>
<span style="font-weight:bold">Preuve :</span><br>
On montre d’abord que Im<span style="font-style:italic">B</span><sup>(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−1)</sup>(λ <sub><span style="font-style:italic">i</span></sub>)/(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−1)! est inclus
dans l’espace caractéristique correspondant à λ<sub><span style="font-style:italic">i</span></sub> en
appliquant l’équation (<a href="#eq%3Ajordan3">51</a>) et les équations précédentes.
Réciproquement on veut prouver que tout vecteur caractéristique <span style="font-style:italic">v</span> est dans 
l’image de <span style="font-style:italic">B</span><sup>(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−1)</sup>(λ <sub><span style="font-style:italic">i</span></sub>)/(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−1)!. Prouvons le par récurrence
sur le plus petit entier <span style="font-style:italic">m</span> tel que
(<span style="font-style:italic">A</span>−λ <sub><span style="font-style:italic">i</span></sub>)<sup><span style="font-style:italic">m</span></sup><span style="font-style:italic">v</span>=0. Le cas <span style="font-style:italic">m</span>=0 est clair puisque <span style="font-style:italic">v</span>=0.
Supposons le cas <span style="font-style:italic">m</span> vrai, prouvons le cas <span style="font-style:italic">m</span>+1. On applique l’équation
(<a href="#eq%3Ajordan4">52</a>) à <span style="font-style:italic">v</span>, il suffit alors de prouver que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">w</span>=(<span style="font-style:italic">A</span>−λ <sub><span style="font-style:italic">i</span></sub>)</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sup>(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>)</sup>(λ<sub><span style="font-style:italic">i</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">v</span></td></tr>
</table><p>
appartient à l’image de
<span style="font-style:italic">B</span><sup>(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−1)</sup>(λ <sub><span style="font-style:italic">i</span></sub>)/(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−1)!.
Comme <span style="font-style:italic">B</span><sup>(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>)</sup>(λ<sub><span style="font-style:italic">i</span></sub>)
commute avec <span style="font-style:italic">A</span> (car c’est un polynôme en <span style="font-style:italic">A</span> ou en appliquant
le fait que <span style="font-style:italic">B</span>(λ) inverse de <span style="font-style:italic">A</span>−λ <span style="font-style:italic">I</span>):
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">A</span>−λ <sub><span style="font-style:italic">i</span></sub>)<sup><span style="font-style:italic">m</span></sup> <span style="font-style:italic">w</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span><sup>(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>)</sup>(λ<sub><span style="font-style:italic">i</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>!</td></tr>
</table></td><td class="dcell"> 
(<span style="font-style:italic">A</span>−λ <sub><span style="font-style:italic">i</span></sub>)<sup><span style="font-style:italic">m</span>+1</sup><span style="font-style:italic">v</span>=0 </td></tr>
</table><p>
et on applique l’hypothèse de récurrence à <span style="font-style:italic">w</span>.</p><p>Pour calculer les cycles de Jordan, nous allons effectuer une
réduction par le pivot de Gauß simultanément sur les colonnes
des matrices <span style="font-style:italic">B</span><sup>(<span style="font-style:italic">k</span>)</sup>(λ <sub><span style="font-style:italic">i</span></sub>)/<span style="font-style:italic">k</span>! où <span style="font-style:italic">k</span>&lt;<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>. 
La simultanéité a pour but de conserver les
relations (<a href="#eq%3Ajordan1">48</a>) à (<a href="#eq%3Ajordan3">51</a>) pour les matrices
réduites. Pour visualiser l’algorithme, on se représente les
matrices les unes au-dessus des autres, colonnes alignées.
On commence par réduire la matrice <span style="font-style:italic">B</span>(λ <sub><span style="font-style:italic">i</span></sub>) jusqu’à ce
que l’on obtienne une matrice réduite <span style="font-weight:bold">en recopiant</span> les opérations
élémentaires de colonnes faites sur <span style="font-style:italic">B</span>(λ <sub><span style="font-style:italic">i</span></sub>) sur toutes les matrices
<span style="font-style:italic">B</span><sup>(<span style="font-style:italic">k</span>)</sup>(λ <sub><span style="font-style:italic">i</span></sub>)/<span style="font-style:italic">k</span>!. On va continuer avec la liste des matrices
réduites issues de <span style="font-style:italic">B</span>′(λ <sub><span style="font-style:italic">i</span></sub>), ..., 
<span style="font-style:italic">B</span><sup>(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−1)</sup>(λ <sub><span style="font-style:italic">i</span></sub>)/(<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−1)!, 
mais en déplacant les colonnes non nulles de <span style="font-style:italic">B</span>(λ <sub><span style="font-style:italic">i</span></sub>) 
d’une matrice vers le bas
(pour une colonne non nulle de la matrice réduite <span style="font-style:italic">B</span>(λ )
les colonnes correspondantes de <span style="font-style:italic">B</span><sup>(<span style="font-style:italic">k</span>)</sup>(λ <sub><span style="font-style:italic">i</span></sub>) réduite 
sont remplacées par les colonnes correspondantes de <span style="font-style:italic">B</span><sup>(<span style="font-style:italic">k</span>−1)</sup>(λ <sub><span style="font-style:italic">i</span></sub>)
réduite pour <span style="font-style:italic">k</span> décroissant de <span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−1 vers 1).
À chaque étape, on obtient une famille (éventuellement vide)
de cycles de Jordan, ce sont les vecteurs colonnes correspondants 
aux colonnes non nulles de la matrice réduite du haut de la colonne.
On élimine bien sûr les colonnes correspondant aux fins de cycles
déjà trouvés.</p><p>Par exemple, si <span style="font-style:italic">B</span>(λ <sub><span style="font-style:italic">i</span></sub>)≠ 0, son rang est 1 et on a
une colonne non nulle, et un cycle de Jordan de longueur
<span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub> fait des <span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub> vecteurs colonnes des matrices
<span style="font-style:italic">B</span><sup>(<span style="font-style:italic">k</span>)</sup>(λ <sub><span style="font-style:italic">i</span></sub>)/<span style="font-style:italic">k</span>! réduites. 
Plus généralement, on obtiendra plus qu’un cycle de Jordan
(et dans ce cas <span style="font-style:italic">B</span>(λ <sub><span style="font-style:italic">i</span></sub>)= 0).</p>
<!--TOC subsubsection id="sec242" Exemple 1-->
<h4 id="sec242" class="subsubsection">22.7.7  Exemple 1</h4><!--SEC END --><p> <a id="sec:ex1"></a></p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>=</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > 3</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >2 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
λ =2 est valeur propre de multiplicité 2, on obtient :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">B</span>(λ )= λ <sup>2</sup> <span style="font-style:italic">I</span> + λ </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > −2</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >−5</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >−3 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
+ </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > 1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−3</td><td style="text-align:center;white-space:nowrap" >5</td><td style="text-align:center;white-space:nowrap" >−1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−2</td><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >2 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
on applique l’algorithme de Horner :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">B</span>(2)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > 1</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">,</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">B</span>′(2)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > 2</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >1 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Comme <span style="font-style:italic">B</span>(2)≠ 0, on pourrait arrêter les calculs en utilisant
une colonne non nulle et le cycle de Jordan associé
(2,2,1)→ (1,1,0) → (0,0,0) . Expliquons tout
de même l’algorithme général sur cet exemple. La réduction
de <span style="font-style:italic">B</span>(2) s’obtient en effectuant les manipulations de colonnes
<span style="font-style:italic">C</span><sub>2</sub>+<span style="font-style:italic">C</span><sub>1</sub> → <span style="font-style:italic">C</span><sub>2</sub> et <span style="font-style:italic">C</span><sub>3</sub>−<span style="font-style:italic">C</span><sub>1</sub> → <span style="font-style:italic">C</span><sub>3</sub>. 
On effectue les mêmes opérations sur <span style="font-style:italic">B</span>′(2) 
et on obtient :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > 1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">, </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > 2</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−1</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
L’étape suivante consiste à déplacer vers le bas d’une matrice les
colonnes non nulles de la matrice du haut, on obtient :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > 1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−1</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
qui se réduit en :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > 1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
on chercherait alors dans les colonnes 2 et 3 de nouveaux cycles (puisque
la colonne 1 a déja été utilisée pour fournir un cycle).</p>
<!--TOC subsubsection id="sec243" Exemple 2-->
<h4 id="sec243" class="subsubsection">22.7.8  Exemple 2</h4><!--SEC END --><p> <a id="sec:ex2"></a>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>=</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > 3</td><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >−2 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
λ =1 est valeur propre de multiplicité 3.
On trouve :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">B</span>(1)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">, </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">B</span>′(1)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >−2 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−1 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">, </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center"> <span style="font-style:italic">B</span>′′(1)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Le processus de réduction commence avec <span style="font-style:italic">B</span>′(1) en haut de la liste
de matrices, on effectue les opérations élémentaires de
colonne <span style="font-style:italic">C</span><sub>2</sub>−<span style="font-style:italic">C</span><sub>1</sub>→ <span style="font-style:italic">C</span><sub>2</sub>
et <span style="font-style:italic">C</span><sub>3</sub>+<span style="font-style:italic">C</span><sub>1</sub> → <span style="font-style:italic">C</span><sub>3</sub> et on obtient:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">, </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
La première colonne donne le premier cycle de Jordan
(1,0,0) → (2,−1,1).
On déplace les premières colonnes d’une matrice vers le bas :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
qu’on réduit par les opérations 2<span style="font-style:italic">C</span><sub>2</sub> +<span style="font-style:italic">C</span><sub>1</sub> → <span style="font-style:italic">C</span><sub>2</sub> et
2<span style="font-style:italic">C</span><sub>3</sub>−<span style="font-style:italic">C</span><sub>1</sub>→ <span style="font-style:italic">C</span><sub>3</sub> en :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
Puis on effectue <span style="font-style:italic">C</span><sub>3</sub>−<span style="font-style:italic">C</span><sub>2</sub> → <span style="font-style:italic">C</span><sub>3</sub> et la deuxième colonne
nous donne le deuxième cycle de Jordan, réduit ici à un
seul vecteur propre (0,1,1).</p>
<!--TOC subsubsection id="sec244" Le polynôme minimal par Faddeev-->
<h4 id="sec244" class="subsubsection">22.7.9  Le polynôme minimal par Faddeev</h4><!--SEC END --><p>
On vérifie aisément que le degré du facteur 
(λ−λ<sub><span style="font-style:italic">i</span></sub>) dans le polynôme minimal de <span style="font-style:italic">A</span> est égal
à <span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>−<span style="font-style:italic">k</span> où <span style="font-style:italic">k</span> est le plus grand entier tel que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">∀ <span style="font-style:italic">j</span>&lt;<span style="font-style:italic">k</span>,    <span style="font-style:italic">B</span><sup>(<span style="font-style:italic">j</span>)</sup>(λ<sub><span style="font-style:italic">i</span></sub>)=0 </td></tr>
</table>
<!--TOC subsubsection id="sec245" Formes normales rationnelles-->
<h4 id="sec245" class="subsubsection">22.7.10  Formes normales rationnelles</h4><!--SEC END --><p><a id="hevea_default279"></a>
On se place ici dans une problématique différente : trouver une matrice
semblable la plus simple possible sans avoir à introduire d’extension
algébrique pour factoriser le polynôme caractéristique.
Quitte à “compléter” plus tard la factorisation et la jordanisation à
partir de la forme simplifiée. Il existe diverses formes associées
à une matrice et plusieurs algorithmes permettant de les relier entre elles,
forme de Smith, de Frobenius, forme normale de Jordan rationnelle.</p><p>On commence par un algorithme très simple qui donne la décomposition
dite de Dunford<a id="hevea_default280"></a> (somme d’une matrice diagonalisable et d’une matrice
nilpotente) sans calculer les valeurs propres (donc en faisant
tous les calculs dans le corps des coefficients de la matrice).
Il utilise la méthode de Newton, la forme diagonale
annulant le polynôme caractéristique où on met à 1 toutes
les multiplicités, la partie nilpotente étant vue comme le
terme d’erreur (la taille de l’erreur est en raison inverse
de l’exposant nécessaire pour annuler le nilpotent).

</p><pre class="verbatim">dunford(A):={
  local D,p,q,q1,j,d,n;
  D:=A;
  n:=nrows(D);
  p:=charpoly(D);
  q:=p/gcd(p,p'); // partie sans multiplicite
  q1:=q';
  for (j:=1;j&lt;=n;j:=2*j){
    d:=inv(horner(q1,D))*horner(q,D); // pas de Newton
    if (d==0*d) return D,A-D;
    D:=D-d;
  }
  return D,A-D;
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;t.value=tmp;tmp=UI.caseval(tmp);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML);field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>

<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">J:=[[2,1,0],[0,1,1],[0,0,1]]; P:=trn([[1,2,3],[0,-1,4],[0,0,1]]); A:=P*J*inv(P) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">D,N:=dunford(A); N^2; N^3 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
Mais cet algorithme est trop simple pour être efficace pour de
grandes matrices, pour le rendre plus efficace, il faut travailler un
peu en utilisant la factorisation la plus poussée possible sur le
polynôme caractéristique (en tout cas au moins la décomposition
<code>sqrfree</code>) et Bézout pour calculer les projecteurs spectraux,
on diminue ainsi la dimension pour accélérer les évaluations du
polynôme d’endomorphisme (en <span style="font-style:italic">O</span>(dimesion)<sup>4</sup>). Et au demeurant
la forme de Dunford n’a pas beaucoup d’applications.</p><p>On va maintenant présenter une méthode directe de calcul d’une forme normale
contenant le maximum de zéros (dont la forme dite normale de Jordan
rationnelle peut se déduire) en utilisant le même algorithme que pour 
la forme
normale de Jordan. Soit <span style="font-style:italic">Q</span>(λ)=<span style="font-style:italic">q</span><sub>0</sub>+...+<span style="font-style:italic">q</span><sub><span style="font-style:italic">d</span></sub> λ<sup><span style="font-style:italic">d</span></sup> 
un facteur irréductible
de degré <span style="font-style:italic">d</span> et de multiplicité <span style="font-style:italic">q</span> 
du polynôme caractéristique <span style="font-style:italic">P</span>. Il
s’agit de construire un sous-espace de dimension <span style="font-style:italic">dq</span> formé de “cycles
de Jordan rationnels”.
On part toujours de la relation 
(λ <span style="font-style:italic">I</span> −<span style="font-style:italic">A</span>) ∑<sub><span style="font-style:italic">k</span>≤ <span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub> λ<sup><span style="font-style:italic">k</span></sup>=<span style="font-style:italic">P</span>(λ)<span style="font-style:italic">I</span>.
On observe que <span style="font-style:italic">Q</span>(λ)<span style="font-style:italic">I</span>−<span style="font-style:italic">Q</span>(<span style="font-style:italic">A</span>) est divisible par (λ <span style="font-style:italic">I</span> −<span style="font-style:italic">A</span>) 
donc il existe une matrice <span style="font-style:italic">M</span>(λ) telle que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">Q</span>(λ) <span style="font-style:italic">I</span> −<span style="font-style:italic">Q</span>(<span style="font-style:italic">A</span>)) (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>≤ <span style="font-style:italic">n</span>−1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub> λ<sup><span style="font-style:italic">k</span></sup>)
=<span style="font-style:italic">Q</span>(λ)<sup><span style="font-style:italic">q</span></sup> <span style="font-style:italic">M</span>(λ) </td></tr>
</table><p>
On observe aussi que <span style="font-style:italic">Q</span> a pour coefficient dominant 1 puisqu’il divise
<span style="font-style:italic">P</span>, on peut donc effectuer des divisions euclidiennes de polynômes
donc de polynômes à coefficients matriciels par <span style="font-style:italic">Q</span> sans avoir
à diviser des coefficients. Ce qui nous
permet de décomposer <span style="font-style:italic">B</span>(λ)=∑<sub><span style="font-style:italic">k</span>≤ <span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub> λ<sup><span style="font-style:italic">k</span></sup> en 
puissances croissantes de <span style="font-style:italic">Q</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">B</span>(λ)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">C</span><sub><span style="font-style:italic">k</span></sub>(λ) <span style="font-style:italic">Q</span>(λ)<sup><span style="font-style:italic">k</span></sup>,    deg(<span style="font-style:italic">C</span><sub><span style="font-style:italic">k</span></sub>)&lt;<span style="font-style:italic">q</span> </td></tr>
</table><p>
On remplace et on écrit que les coefficients des puissances inférieures
à <span style="font-style:italic">q</span> de <span style="font-style:italic">Q</span> sont nulles (la <span style="font-style:italic">k</span>-ième étant non nulle
car <span style="font-style:italic">M</span>(λ) n’est pas divisible par <span style="font-style:italic">Q</span> pour les mêmes raisons
que pour la forme normale de Jordan). On a donc les relations :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Q</span>(<span style="font-style:italic">A</span>)<span style="font-style:italic">C</span><sub>0</sub> = 0,    <span style="font-style:italic">C</span><sub><span style="font-style:italic">k</span></sub> = <span style="font-style:italic">Q</span>(<span style="font-style:italic">A</span>) <span style="font-style:italic">C</span><sub><span style="font-style:italic">k</span>+1</sub> </td></tr>
</table><p>
ce qui donne une colonne de matrice 
<span style="font-style:italic">C</span><sub><span style="font-style:italic">q</span>−1</sub> → <span style="font-style:italic">C</span><sub><span style="font-style:italic">q</span>−2</sub> ... → <span style="font-style:italic">C</span><sub>0</sub> → 0
qui sont images l’une de l’autre en appliquant <span style="font-style:italic">Q</span>(<span style="font-style:italic">A</span>). On peut alors
faire l’algorithme de réduction simultanée sur les colonnes des <span style="font-style:italic">C</span><sub><span style="font-style:italic">j</span></sub>. 
On observe
ensuite que le nombre de cycles de Jordan de <span style="font-style:italic">Q</span>(<span style="font-style:italic">A</span>) de longueur donnée 
est un multiple de <span style="font-style:italic">d</span>, en effet il suffit de multiplier
un cycle par <span style="font-style:italic">A</span>, ..., <span style="font-style:italic">A</span><sup><span style="font-style:italic">d</span>−1</sup> pour créer un autre cycle, de plus ces
cycles forment des familles libres car on a supposé <span style="font-style:italic">Q</span> irréductible.
On peut donc choisir pour un cycle de longueur <span style="font-style:italic">k</span> des bases de la forme
(<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>−1</sub>,<span style="font-style:italic">Av</span><sub><span style="font-style:italic">k</span>−1</sub>...,<span style="font-style:italic">A</span><sup><span style="font-style:italic">d</span>−1</sup><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>−1</sub>) → ... 
→ (<span style="font-style:italic">v</span><sub>0</sub>,<span style="font-style:italic">Av</span><sub>0</sub>...,<span style="font-style:italic">A</span><sup><span style="font-style:italic">d</span>−1</sup><span style="font-style:italic">v</span><sub>0</sub>) → (0,...,0) 
où la flèche → désigne l’image par <span style="font-style:italic">Q</span>(<span style="font-style:italic">A</span>).
Si on écrit la matrice de <span style="font-style:italic">A</span> dans la base 
<span style="font-style:italic">v</span><sub>0</sub>,<span style="font-style:italic">Av</span><sub>0</sub>...,<span style="font-style:italic">A</span><sup><span style="font-style:italic">d</span>−1</sup><span style="font-style:italic">v</span><sub>0</sub>,...,<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>−1</sub>,<span style="font-style:italic">Av</span><sub><span style="font-style:italic">k</span>−1</sub>...,<span style="font-style:italic">A</span><sup><span style="font-style:italic">d</span>−1</sup><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>−1</sub>
on obtient un “quasi-bloc de Jordan rationnel” de taille <span style="font-style:italic">kd</span> 
multiple de <span style="font-style:italic">d</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >−<span style="font-style:italic">q</span><sub>0</sub></td><td style="text-align:center;white-space:nowrap" > </td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >−<span style="font-style:italic">q</span><sub>1</sub></td><td style="text-align:center;white-space:nowrap" > </td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >−<span style="font-style:italic">q</span><sub>2</sub></td><td style="text-align:center;white-space:nowrap" > </td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" > </td><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >...</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >−<span style="font-style:italic">q</span><sub><span style="font-style:italic">d</span>−1</sub></td><td style="text-align:center;white-space:nowrap" > </td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" > </td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >−<span style="font-style:italic">q</span><sub>0</sub></td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" > </td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >−<span style="font-style:italic">q</span><sub>1</sub></td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" > </td><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >⋮</td><td style="text-align:center;white-space:nowrap" >...
</td></tr>
</table></td><td class="dcell">
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p><span style="font-weight:bold">Exemple</span><br>
Soit la matrice
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>=</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−2</td><td style="text-align:center;white-space:nowrap" >4</td><td style="text-align:center;white-space:nowrap" >−2</td><td style="text-align:center;white-space:nowrap" >5</td><td style="text-align:center;white-space:nowrap" >−4 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">5</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">−7</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−5</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">−5</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">5</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >−3 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">9</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">−7</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >3</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−7</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >−2</td><td style="text-align:center;white-space:nowrap" >3</td><td style="text-align:center;white-space:nowrap" >−1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">−3</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">3</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
Son polynôme caractéristique est (<span style="font-style:italic">x</span>−2)<sup>2</sup>(<span style="font-style:italic">x</span><sup>2</sup>−2)<sup>2</sup> et on va déterminer
la partie bloc de Jordan rationnel correspondant au facteur irréductible
sur les entiers <span style="font-style:italic">Q</span>(<span style="font-style:italic">x</span>)=(<span style="font-style:italic">x</span><sup>2</sup>−2) de multiplicité <span style="font-style:italic">q</span>=2. 
On calcule <span style="font-style:italic">B</span>(<span style="font-style:italic">x</span>) et l’écriture de <span style="font-style:italic">B</span> comme
somme de puissances de <span style="font-style:italic">Q</span> (ici avec <code>xcas</code> en mode <code>xcas</code>) :
</p><pre class="verbatim">A:=[[1,-2,4,-2,5,-4],[0,1,5/2,(-7)/2,2,(-5)/2],[1,(-5)/2,2,1/(-2),5/2,-3],
    [0,-1,9/2,(-7)/2,3,(-7)/2],[0,0,2,-2,3,-1],[1,(-3)/2,1/(-2),1,3/2,1/2]];
P:=det(A-x*idn(6));
B:=normal(P*inv(A-x*idn(6))); // preferer un appel a faddeev bien sur!
ecriture(B,Q,q):={
  local j,k,l,n,C,D,E;
  C:=B;
  D:=B;
  E:=NULL;
  n:=coldim(B);
  for (j:=0;j&lt;q;j++){ 
    for (k:=0;k&lt;n;k++){
      for (l:=0;l&lt;n;l++){
        D[k,l]:=rem(C[k,l],Q,x);
        C[k,l]:=quo(C[k,l],Q,x);
      }
    }
    E:=E,D;
  }
  return E;
};
E:=ecriture(B,x^2-2,2);
QA:=A*A-2*idn(6);
</pre><p>On vérifie bien que <code>normal(QA*E(0))</code> et
<code>normal(QA*E(1))-E(0))</code> sont nuls. On sait qu’on a un bloc de
taille 2 de cycles de Jordan de longueur 2, donc il n’est pas nécessaire
de faire des réductions ici, il suffit de prendre une colonne non nulle
de <span style="font-style:italic">E</span>(0), par exemple la première colonne en <span style="font-style:italic">x</span>=0
et la colonne correspondante de <span style="font-style:italic">E</span>(1) et leurs images par <span style="font-style:italic">A</span>, ici
cela donne (4,24,12,32,8,−4) correspondant à (0,4,−4,8,4,−4),
on calcule les images par <span style="font-style:italic">A</span>, la matrice de l’endomorphisme
restreint à ce sous-espace est alors le bloc de taille 4 :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >2 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0
</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>Cette forme normale minimise le nombre de coefficients non nuls,
mais présente un inconvénient, la partie nilpotente ne commute pas
avec la partie bloc-diagonale, contrairement à la forme normale
rationnelle de Jordan qui contient des blocs identités au-dessus
de la diagonale de blocs.
Pour créer la forme normale rationnelle de Jordan, on doit donc remplacer
les blocs ( </p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >0 
</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >... </td></tr>
</table><p> )
par des matrices identités. Supposons constitués les <span style="font-style:italic">j</span> premiers blocs de
taille <span style="font-style:italic">d</span> numérotés de 0 à <span style="font-style:italic">j</span>−1 avec comme base de vecteurs
(<span style="font-style:italic">v</span><sub>0,0</sub>,...,<span style="font-style:italic">v</span><sub>0,<span style="font-style:italic">d</span>−1</sub>,...,<span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>−1,<span style="font-style:italic">d</span>−1</sub>). 
Il s’agit de trouver un vecteur <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>,0</sub> pour commencer le bloc
suivant. On définit alors <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">l</span></sub> en fonction de <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">l</span>−1</sub>
en appliquant la relation <span style="font-style:italic">Av</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">l</span>−1</sub>=<span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">l</span></sub>+<span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>−1,<span style="font-style:italic">l</span>−1</sub>.
Il faut donc chercher <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>,0</sub> tel que 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:jordanrat1"></a>
<span style="font-style:italic">Av</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">d</span>−1</sub>=−<span style="font-style:italic">q</span><sub>0</sub> <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>,0</sub>−...−<span style="font-style:italic">q</span><sub><span style="font-style:italic">d</span>−1</sub> <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">d</span>−1</sub>+<span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>−1,<span style="font-style:italic">d</span>−1</sub> 
    (53)</td></tr>
</table><p>
En utilisant les relations de récurrence précédentes, on voit que
cela revient à fixer <span style="font-style:italic">Q</span>(<span style="font-style:italic">A</span>)<span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>,0</sub> en fonction des <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>′,<span style="font-style:italic">l</span></sub> avec
<span style="font-style:italic">j</span>′&lt;<span style="font-style:italic">j</span> (<span style="font-style:italic">l</span> quelconque). Ce qui est toujours possible en utilisant
la colonne de matrices <span style="font-style:italic">C</span><sub><span style="font-style:italic">j</span>′</sub> qui s’obtiennent en
fonction des <span style="font-style:italic">C</span><sub><span style="font-style:italic">j</span>′+1</sub> en appliquant <span style="font-style:italic">Q</span>(<span style="font-style:italic">A</span>).</p><p>Plus précisément, calculons les <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">l</span></sub> en fonction de <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>,0</sub>
et des <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>′,<span style="font-style:italic">l</span>′</sub> (<span style="font-style:italic">j</span>′&lt;<span style="font-style:italic">j</span>). On utilise les coefficients binomiaux 
( <sub><span style="font-style:italic">m</span></sub><sup><span style="font-style:italic">l</span></sup>) calculés par la règle du triangle de Pascal et
on montre par récurrence que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:jordanrat3"></a>
<span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>,<span style="font-style:italic">l</span></sub> = <span style="font-style:italic">A</span><sup><span style="font-style:italic">l</span></sup> <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>,0</sub> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-size:small">inf</span>(<span style="font-style:italic">l</span>,<span style="font-style:italic">j</span>)</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span>=1</td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell">⎛<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">l</span></td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">m</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎠</td><td class="dcell"><span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>−<span style="font-style:italic">m</span>,<span style="font-style:italic">l</span>−<span style="font-style:italic">m</span></sub>
    (54)</td></tr>
</table><p>
On remplace dans (<a href="#eq%3Ajordanrat1">53</a>) d’où :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span><sup><span style="font-style:italic">d</span></sup> <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>,0</sub> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-size:small">inf</span>(<span style="font-style:italic">d</span>,<span style="font-style:italic">j</span>)</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span>=1</td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell">⎛<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">d</span></td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">m</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎠</td><td class="dcell"><span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>−<span style="font-style:italic">m</span>,<span style="font-style:italic">l</span>−<span style="font-style:italic">m</span></sub>
+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span>=0</td></tr>
</table></td><td class="dcell"> 
<span style="font-style:italic">q</span><sub><span style="font-style:italic">l</span></sub> (<span style="font-style:italic">A</span><sup><span style="font-style:italic">l</span></sup> <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>,0</sub> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-size:small">inf</span>(<span style="font-style:italic">l</span>,<span style="font-style:italic">j</span>)</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span>=1</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">l</span></td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">m</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎠</td><td class="dcell">
<span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>−<span style="font-style:italic">m</span>,<span style="font-style:italic">l</span>−<span style="font-style:italic">m</span></sub> )=0
</td></tr>
</table><p>
finalement :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:jordanrat"></a>
<span style="font-style:italic">Q</span>(<span style="font-style:italic">A</span>) <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>,0</sub>= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span>=1</td></tr>
</table></td><td class="dcell"> 
<span style="font-style:italic">q</span><sub><span style="font-style:italic">l</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-size:small">inf</span>(<span style="font-style:italic">l</span>,<span style="font-style:italic">j</span>)</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span>=1</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">l</span></td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">m</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎠</td><td class="dcell"><span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span>−<span style="font-style:italic">m</span>,<span style="font-style:italic">l</span>−<span style="font-style:italic">m</span></sub> 
    (55)</td></tr>
</table><p><span style="font-weight:bold">Application à l’exemple :</span><br>
Ici <span style="font-style:italic">v</span><sub>0,0</sub>=(4,24,12,32,8,−4) et <span style="font-style:italic">v</span><sub>0,1</sub>=<span style="font-style:italic">Av</span><sub><span style="font-style:italic">j</span>,0</sub> dont une préimage
par <span style="font-style:italic">Q</span>(<span style="font-style:italic">A</span>) est <span style="font-style:italic">w</span><sub>1,0</sub>=(0,4,−4,8,4,−4) et <span style="font-style:italic">w</span><sub>1,1</sub>=<span style="font-style:italic">Aw</span><sub>1,0</sub>.
On applique (<a href="#eq%3Ajordanrat">55</a>), comme <span style="font-style:italic">q</span><sub>1</sub>=0 et <span style="font-style:italic">q</span><sub>2</sub>=1
on doit avoir :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Q</span>(<span style="font-style:italic">A</span>) <span style="font-style:italic">v</span><sub>1,0</sub> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span>=1</td></tr>
</table></td><td class="dcell">
<span style="font-style:italic">q</span><sub><span style="font-style:italic">l</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-size:small">inf</span>(<span style="font-style:italic">l</span>,1)</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span>=1</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">l</span></td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">m</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎠</td><td class="dcell"><span style="font-style:italic">v</span><sub>1−<span style="font-style:italic">m</span>,<span style="font-style:italic">l</span>−<span style="font-style:italic">m</span></sub> 
=2<span style="font-style:italic">v</span><sub>0,1</sub> </td></tr>
</table><p>
donc  :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > <span style="font-style:italic">v</span><sub>1,0</sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:center;white-space:nowrap" >2<span style="font-style:italic">A</span>(0,4,−4,8,4,−4)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:center;white-space:nowrap" >(−8,−32,0,−48,−16,16) </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <span style="font-style:italic">v</span><sub>1,1</sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">Av</span><sub>1,0</sub>−<span style="font-style:italic">v</span><sub>0,0</sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:center;white-space:nowrap" >(4,40,−4,64,24,−20) 
</td></tr>
</table></td></tr>
</table><p>
On vérifie bien que <span style="font-style:italic">Av</span><sub>1,1</sub>=2<span style="font-style:italic">v</span><sub>1,0</sub>+<span style="font-style:italic">v</span><sub>0,1</sub>.</p>
<!--TOC subsubsection id="sec246" Fonctions analytiques-->
<h4 id="sec246" class="subsubsection">22.7.11  Fonctions analytiques</h4><!--SEC END --><p>
Soit <span style="font-style:italic">f</span> une fonction analytique et <span style="font-style:italic">M</span> une matrice. Pour calculer
<span style="font-style:italic">f</span>(<span style="font-style:italic">M</span>), on calcule la forme normale de Jordan de 
<span style="font-style:italic">M</span>=<span style="font-style:italic">P</span>(<span style="font-style:italic">D</span>+<span style="font-style:italic">N</span>)<span style="font-style:italic">P</span><sup>−1</sup> où <span style="font-style:italic">D</span>=diag(<span style="font-style:italic">d</span><sub>1</sub>,...,<span style="font-style:italic">d</span><sub><span style="font-style:italic">m</span></sub>) est diagonale et <span style="font-style:italic">N</span> nilpotente
d’ordre <span style="font-style:italic">n</span>. On calcule
aussi le développement de Taylor formel de <span style="font-style:italic">f</span> en <span style="font-style:italic">x</span> à l’ordre
<span style="font-style:italic">n</span>−1, on a alors :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">N</span>)=<span style="font-style:italic">P</span> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">diag(<span style="font-style:italic">f</span><sup>(<span style="font-style:italic">j</span>)</sup>(<span style="font-style:italic">d</span><sub>1</sub>),...,
<span style="font-style:italic">f</span><sup>(<span style="font-style:italic">j</span>)</sup>(<span style="font-style:italic">d</span><sub><span style="font-style:italic">m</span></sub>))</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">N</span><sup><span style="font-style:italic">j</span></sup> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><span style="font-style:italic">P</span><sup>−1</sup></td></tr>
</table>
<!--TOC subsection id="sec247" Quelques autres algorithmes utiles-->
<h3 id="sec247" class="subsection">22.8  Quelques autres algorithmes utiles</h3><!--SEC END -->
<!--TOC subsubsection id="sec248" Complexité asymptotique-->
<h4 id="sec248" class="subsubsection">22.8.1  Complexité asymptotique</h4><!--SEC END --><p>
Pour calculer le produit de matrices, on peut utiliser
l’algorithme de <span style="font-weight:bold">Strassen</span>, on présente ici la variante
de <span style="font-weight:bold">Winograd</span><a id="hevea_default281"></a><a id="hevea_default282"></a>. Soit à calculer :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span><sub>1,1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span><sub>1,2</sub> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span><sub>2,1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">a</span><sub>2,2</sub> </td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell">
</td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">b</span><sub>1,1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">b</span><sub>1,2</sub> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">b</span><sub>2,1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">b</span><sub>2,2</sub> </td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell">
=</td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">c</span><sub>1,1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">c</span><sub>1,2</sub> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">c</span><sub>2,1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">c</span><sub>2,2</sub> </td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td></tr>
</table><p>
On calcule :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">s</span><sub>1</sub>=<span style="font-style:italic">a</span><sub>2,1</sub>+<span style="font-style:italic">a</span><sub>2,2</sub>,    <span style="font-style:italic">s</span><sub>2</sub>=<span style="font-style:italic">s</span><sub>1</sub>−<span style="font-style:italic">a</span><sub>1,1</sub>,    
<span style="font-style:italic">s</span><sub>3</sub>=<span style="font-style:italic">a</span><sub>1,1</sub>− <span style="font-style:italic">a</span><sub>2,1</sub>,    <span style="font-style:italic">s</span><sub>4</sub>=<span style="font-style:italic">a</span><sub>1,2</sub>−<span style="font-style:italic">s</span><sub>2</sub>
</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">t</span><sub>1</sub>=<span style="font-style:italic">b</span><sub>1,2</sub>−<span style="font-style:italic">b</span><sub>1,1</sub>,    <span style="font-style:italic">t</span><sub>2</sub>=<span style="font-style:italic">b</span><sub>2,2</sub>−<span style="font-style:italic">t</span><sub>1</sub>,
   <span style="font-style:italic">t</span><sub>3</sub>=<span style="font-style:italic">b</span><sub>2,2</sub>−<span style="font-style:italic">b</span><sub>1,2</sub>,    <span style="font-style:italic">t</span><sub>4</sub>=<span style="font-style:italic">b</span><sub>2,1</sub>−<span style="font-style:italic">t</span><sub>2</sub>
</td></tr>
</table></td></tr>
</table><p>
puis :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">p</span><sub>1</sub>=<span style="font-style:italic">a</span><sub>1,1</sub> <span style="font-style:italic">b</span><sub>1,1</sub>,   
<span style="font-style:italic">p</span><sub>2</sub>=<span style="font-style:italic">a</span><sub>1,2</sub><span style="font-style:italic">b</span><sub>2,1</sub>,   
<span style="font-style:italic">p</span><sub>3</sub>=<span style="font-style:italic">s</span><sub>1</sub> <span style="font-style:italic">t</span><sub>1</sub>,    <span style="font-style:italic">p</span><sub>4</sub>=<span style="font-style:italic">s</span><sub>2</sub> <span style="font-style:italic">t</span><sub>2</sub> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">p</span><sub>5</sub>=<span style="font-style:italic">s</span><sub>3</sub> <span style="font-style:italic">t</span><sub>3</sub>,    <span style="font-style:italic">p</span><sub>6</sub>=<span style="font-style:italic">s</span><sub>4</sub> <span style="font-style:italic">b</span><sub>2,2</sub>,
   <span style="font-style:italic">p</span><sub>7</sub>=<span style="font-style:italic">a</span><sub>2,2</sub> <span style="font-style:italic">t</span><sub>4</sub> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">u</span><sub>1</sub>= <span style="font-style:italic">p</span><sub>1</sub>+<span style="font-style:italic">p</span><sub>2</sub>    <span style="font-style:italic">u</span><sub>2</sub>=<span style="font-style:italic">p</span><sub>1</sub>+<span style="font-style:italic">p</span><sub>4</sub>,
   <span style="font-style:italic">u</span><sub>3</sub>=<span style="font-style:italic">u</span><sub>2</sub>+<span style="font-style:italic">p</span><sub>5</sub>,    <span style="font-style:italic">u</span><sub>4</sub>=<span style="font-style:italic">u</span><sub>3</sub>+<span style="font-style:italic">p</span><sub>7</sub></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">u</span><sub>5</sub>=<span style="font-style:italic">u</span><sub>3</sub>+<span style="font-style:italic">p</span><sub>3</sub>,   
<span style="font-style:italic">u</span><sub>6</sub>=<span style="font-style:italic">u</span><sub>2</sub>+<span style="font-style:italic">p</span><sub>3</sub>,    <span style="font-style:italic">u</span><sub>7</sub>=<span style="font-style:italic">u</span><sub>6</sub>+<span style="font-style:italic">p</span><sub>6</sub>
</td></tr>
</table></td></tr>
</table><p>
Alors <span style="font-style:italic">c</span><sub>1,1</sub>=<span style="font-style:italic">u</span><sub>1</sub>, <span style="font-style:italic">c</span><sub>1,2</sub>=<span style="font-style:italic">u</span><sub>7</sub>, <span style="font-style:italic">c</span><sub>2,1</sub>=<span style="font-style:italic">u</span><sub>4</sub>, <span style="font-style:italic">c</span><sub>2,2</sub>=<span style="font-style:italic">u</span><sub>5</sub>.<br>
Cet algorithme utilise 7 multiplications et 15 additions
ce qui économise 1 multiplication et permet en appliquant
récursivement cet algorithme pour des matrices blocs
de réduire la complexité d’un produit de grandes matrices
normalement en <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>3</sup>=<span style="font-style:italic">n</span><sup>ln(8)/ln(2)</sup>) à <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>ln(7)/ln(2)</sup>) (la preuve
est analogue à celle de la multiplication des polynômes
par l’algorithme de Karatsuba).</p><p>En utilisant une factorisation <span style="font-style:italic">LU</span> par blocs, on peut montrer
que cette complexité asymptotique se généralise au
calcul de l’inverse. On peut d’ailleurs améliorer l’exposant,
mais la constante non explicitée dans le <span style="font-style:italic">O</span> augmente aussi.
En pratique, Strassen n’est pas utilisée pour des matrices
de taille plus petites que plusieurs centaines de lignes et colonnes.</p><p>De même on peut gagner sur le calcul du polynôme minimal en
faisant des opérations de multiplication par bloc.</p>
<!--TOC subsection id="sec249" Quelques méthodes alternatives au pivot-->
<h3 id="sec249" class="subsection">22.9  Quelques méthodes alternatives au pivot</h3><!--SEC END -->
<!--TOC subsubsection id="sec250" Factorisation <span style="font-style:italic">QR</span>-->
<h4 id="sec250" class="subsubsection">22.9.1  Factorisation <span style="font-style:italic">QR</span></h4><!--SEC END --><p><a id="hevea_default283"></a>
La factorisation <span style="font-style:italic">QR</span> 
consiste à écrire une matrice <span style="font-style:italic">A</span> comme produit d’une matrice
orthogonale (ou unitaire dans ℂ) et d’une matrice triangulaire
supérieure. Les matrices orthogonales ayant un conditionnement
de 1 (en norme <span style="font-style:italic">L</span><sup>2</sup>) cette factorisation peut s’obtenir de manière 
numériquement stable.</p><p>Il existe plusieurs algorithmes pour effectuer cette factorisation.
On peut voir cette factorisation comme l’orthonormalisation de
Gram-Schmidt appliqué aux vecteurs colonnes de <span style="font-style:italic">A</span> si <span style="font-style:italic">A</span> est non 
singulière. Mais la procédure de Gram-Schmidt n’est pas
numériquement stable (car on retranche d’un vecteur
une combinaison linéaire des vecteurs précdents pour rendre
le nouveau vecteur orthogonal et les erreurs d’arrondi s’accumulent
rendant l’orthogonalité plus aléatoire).
La méthode de Householder utilise des matrices de symétrie
par rapport à un hyperplan et ne souffre pas de ce problème d’instabilité.
Pour annuler les coefficients de la première colonne <span style="font-style:italic">c</span><sub>1</sub> de <span style="font-style:italic">A</span>,
on construit le vecteur <span style="font-style:italic">u</span>=<span style="font-style:italic">c</span><sub>1</sub> ± ||<span style="font-style:italic">c</span><sub>1</sub>|| <span style="font-style:italic">e</span><sub>1</sub> où <span style="font-style:italic">e</span><sub>1</sub>
est le premier vecteur de base et le signe ± est
le signe de la première composante de <span style="font-style:italic">c</span><sub>1</sub> (pour assurer
la stabilité numérique). On fait alors la symétrie <span style="font-style:italic">Q</span><sub>1</sub> par rapport
à l’hyperplan <span style="font-style:italic">H</span> orthogonal à <span style="font-style:italic">u</span>, qui laisse <span style="font-style:italic">H</span> invariant
et transforme <span style="font-style:italic">u</span> en −<span style="font-style:italic">u</span>. Comme <span style="font-style:italic">u</span> est vecteur directeur
de la bissectrice intérieure ou extérieure de <span style="font-style:italic">c</span><sub>1</sub> et <span style="font-style:italic">e</span><sub>1</sub>, la symétrie
échange ces deux vecteurs, éventuellement au signe près.
La matrice <span style="font-style:italic">A</span><sub>1</sub>=<span style="font-style:italic">Q</span><sub>1</sub><span style="font-style:italic">A</span> a donc comme première colonne un multiple de
<span style="font-style:italic">e</span><sub>1</sub>, on continue ensuite en faisant le même raisonnement
sur la matrice <span style="font-style:italic">A</span><sub>1</sub> en se limitant et lignes et colonnes d’indice
≥ 2. Après <span style="font-style:italic">n</span>−1 itérations, on a <span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span>−1</sub>=<span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span>−1</sub>...<span style="font-style:italic">Q</span><sub>1</sub><span style="font-style:italic">A</span>
qui est triangulaire supérieure d’où la factorisation annoncée.</p><p>Matriciellement, <span style="font-style:italic">Q</span><sub>1</sub>=<span style="font-style:italic">I</span>−2<span style="font-style:italic">vv</span><sup>*</sup> où <span style="font-style:italic">v</span>=<span style="font-style:italic">u</span>/||<span style="font-style:italic">u</span>||, pour calculer <span style="font-style:italic">Q</span><sub>1</sub><span style="font-style:italic">A</span>
il faut effectuer <span style="font-style:italic">A</span>−2<span style="font-style:italic">vv</span><sup>*</sup><span style="font-style:italic">A</span>, on calcule donc <span style="font-style:italic">w</span>=<span style="font-style:italic">v</span><sup>*</sup><span style="font-style:italic">A</span> en <span style="font-style:italic">n</span><sup>2</sup>
opérations (ou une opération est une addition et une
multiplication) puis on soustrait (2<span style="font-style:italic">v</span>)<sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">w</span><sub><span style="font-style:italic">j</span></sub> de <span style="font-style:italic">a</span><sub><span style="font-style:italic">ij</span></sub> en <span style="font-style:italic">n</span><sup>2</sup>
opérations. En faisant de même aux étapes qui suivent, sans
tenir compte de la simplification progressive du vecteur <span style="font-style:italic">v</span>, on 
effectue 2<span style="font-style:italic">n</span><sup>3</sup> opérations. La constante 2 peut être 
un peu améliorée en tenant compte des 0 initiaux de <span style="font-style:italic">v</span> aux
étapes 2 et ultérieures, elle est toutefois supérieure à LU
(et Cholesky), mais en contrepartie
la méthode est très stable numériquement.</p><p>On peut aussi utiliser des rotations (méthode de Givens) pour
annuler les coefficients de <span style="font-style:italic">A</span> sous la diagonale. C’est par exemple
très efficace pour des matrices tridiagonales.</p><p>Lorsque la matrice <span style="font-style:italic">A</span> n’est pas carrée, mais possède <span style="font-style:italic">n</span> lignes
et <span style="font-style:italic">c</span> colonnes, la factorisation <span style="font-style:italic">QR</span> est encore possible, la matrice
<span style="font-style:italic">Q</span> est alors une matrice carrée d’ordre <span style="font-style:italic">n</span>, et <span style="font-style:italic">R</span> a les mêmes
dimensions que <span style="font-style:italic">A</span>. En particulier si <span style="font-style:italic">A</span> a plus de lignes que de
colonnes (matrice verticale), <span style="font-style:italic">R</span> aussi. Par exemple si <span style="font-style:italic">A</span> est de 
rang maximal <span style="font-style:italic">c</span>, alors <span style="font-style:italic">R</span> se décompose en un premier bloc
<span style="font-style:italic">c</span>,<span style="font-style:italic">c</span> inversible <span style="font-style:italic">R</span><sub>1</sub> et un deuxième bloc <span style="font-style:italic">n</span>−<span style="font-style:italic">c</span>,<span style="font-style:italic">c</span> entièrement nul.</p><p><span style="font-weight:bold">Applications :</span><br>
On peut alors écrire <span style="font-style:italic">Ax</span>=<span style="font-style:italic">b</span> sous la forme <span style="font-style:italic">QRx</span>=<span style="font-style:italic">b</span>
donc <span style="font-style:italic">Rx</span>=<span style="font-style:italic">Q</span><sup>*</sup><span style="font-style:italic">b</span> qui est un système triangulaire supérieur,
donc résoudre <span style="font-style:italic">Ax</span>=<span style="font-style:italic">b</span> en <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>2</sup>) opérations une fois 
la factorisation <span style="font-style:italic">QR</span> effectuée.<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">a:=[[1.,2.,3.],[4.,5.,6.],[7.,8.,0.]]; q,r:=qr(a); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p><p>Mais c’est surtout pour résoudre <span style="font-weight:bold">au sens des moindres carrés</span>
un système sur-déterminé que la factorisation <span style="font-style:italic">QR</span> trouve tout
son intérêt. Soit <span style="font-style:italic">A</span> la matrice d’un système sur-déterminé
avec <span style="font-style:italic">n</span> lignes et <span style="font-style:italic">c</span> colonnes, <span style="font-style:italic">n</span>&gt;<span style="font-style:italic">c</span> (matrice “verticale” ou mince).
Le système n’a en général pas de solution, on cherche alors
à minimiser || <span style="font-style:italic">Ax</span>−<span style="font-style:italic">b</span> ||<sub>2</sub><sup>2</sup>. Ceci revient à
chercher la projection orthogonale de <span style="font-style:italic">b</span> sur Im(<span style="font-style:italic">A</span>).
Soit <span style="font-style:italic">Ax</span> cette projection, on a <span style="font-style:italic">b</span>=<span style="font-style:italic">Ax</span>+<span style="font-style:italic">p</span> avec <span style="font-style:italic">p</span> orthogonal
à Im(<span style="font-style:italic">A</span>) donc dans Ker(<span style="font-style:italic">A</span><sup>*</sup>), donc <span style="font-style:italic">A</span><sup>*</sup><span style="font-style:italic">b</span>=<span style="font-style:italic">A</span><sup>*</sup>(<span style="font-style:italic">Ax</span>+<span style="font-style:italic">p</span>)=<span style="font-style:italic">A</span><sup>*</sup><span style="font-style:italic">Ax</span>.
</p><div class="theorem"><span style="font-weight:bold">Proposition 50</span>  <em>
La solution </em><span style="font-style:italic">x</span><em> du problème de minimisation de </em>|| <span style="font-style:italic">Ax</span>−<span style="font-style:italic">b</span> ||<sub>2</sub><em>
est donnée par </em><span style="font-style:italic">A</span><sup>*</sup><span style="font-style:italic">Ax</span>=<span style="font-style:italic">A</span><sup>*</sup><span style="font-style:italic">b</span><em>
</em></div><p>
Si <span style="font-style:italic">A</span>=<span style="font-style:italic">QR</span> on a alors <span style="font-style:italic">R</span><sup>*</sup> <span style="font-style:italic">R</span> <span style="font-style:italic">x</span>=<span style="font-style:italic">R</span><sup>*</sup> <span style="font-style:italic">Q</span><sup>*</sup><span style="font-style:italic">b</span>. Si <span style="font-style:italic">A</span> est de rang maximal
<span style="font-style:italic">c</span>, on décompose <span style="font-style:italic">R</span> en (<sub><span style="font-style:italic">R</span><sub>2</sub></sub><sup><span style="font-style:italic">R</span><sub>1</sub></sup>) avec <span style="font-style:italic">R</span><sub>1</sub> inversible de
taille <span style="font-style:italic">c</span> et
<span style="font-style:italic">R</span><sub>2</sub>=0, donc <span style="font-style:italic">R</span><sup>*</sup>=(<span style="font-style:italic">R</span><sub>1</sub><sup>*</sup>, 0) et le système devient <span style="font-style:italic">R</span><sub>1</sub><sup>*</sup><span style="font-style:italic">R</span><sub>1</sub><span style="font-style:italic">x</span> =(<span style="font-style:italic">R</span><sub>1</sub><sup>*</sup>,0) <span style="font-style:italic">Q</span><sup>*</sup><span style="font-style:italic">b</span> 
et comme <span style="font-style:italic">R</span><sub>1</sub> est inversible, on a <span style="font-style:italic">R</span><sub>1</sub><span style="font-style:italic">x</span>= les <span style="font-style:italic">c</span> premières lignes
de <span style="font-style:italic">Q</span><sup>*</sup><span style="font-style:italic">b</span>.
Il vaut mieux résoudre ce système que <span style="font-style:italic">A</span><sup>*</sup> <span style="font-style:italic">Ax</span>=<span style="font-style:italic">A</span><sup>*</sup><span style="font-style:italic">b</span> car
le conditionnement de <span style="font-style:italic">A</span><sup>*</sup> <span style="font-style:italic">A</span> est le carré du conditionnement
de <span style="font-style:italic">A</span> (le nombre d’opérations est un peu supérieur :
<span style="font-style:italic">QR</span> a une constante nettement plus grande que Cholesky mais
il n’y a pas de multiplication de matrice à faire, et le résultat
est plus précis).</p><p>Notons qu’on peut résoudre de manière assez analogue
un système sous-déterminé au sens des moindres carrés.
On considère toujours le système <span style="font-style:italic">Ax</span>=<span style="font-style:italic">b</span> mais cette fois-ci
<span style="font-style:italic">A</span> est une matrice “horizontale” (nombre de lignes <span style="font-style:italic">n</span>&lt;<span style="font-style:italic">c</span> le nombre
de colonnes). Si <span style="font-style:italic">b</span> ∈ Im(<span style="font-style:italic">A</span>) (on peut génériquement supposer
que <span style="font-style:italic">A</span> est de rang <span style="font-style:italic">n</span>), 
il y a une infinité de solutions, on
cherche alors la solution de norme minimale. On cherche donc le
projeté orthogonal de l’espace affine des solutions (dirigé selon Ker(<span style="font-style:italic">A</span>))
sur l’orthogonal de Ker(<span style="font-style:italic">A</span>) qui est Im<span style="font-style:italic">A</span><sup>*</sup>. Ainsi <span style="font-style:italic">x</span>=<span style="font-style:italic">A</span><sup>*</sup><span style="font-style:italic">y</span>
vérifie <span style="font-style:italic">Ax</span>=<span style="font-style:italic">b</span>, donc <span style="font-style:italic">AA</span><sup>*</sup><span style="font-style:italic">y</span>=<span style="font-style:italic">b</span>. Si <span style="font-style:italic">A</span> est de rang <span style="font-style:italic">n</span> alors
<span style="font-style:italic">AA</span><sup>*</sup>  est inversible et <span style="font-style:italic">y</span>=(<span style="font-style:italic">AA</span><sup>*</sup>)<sup>−1</sup><span style="font-style:italic">b</span> donc <span style="font-style:italic">x</span>=<span style="font-style:italic">A</span> (<span style="font-style:italic">AA</span><sup>*</sup>)<sup>−1</sup><span style="font-style:italic">b</span>.
En utilisant la factorisation <span style="font-style:italic">QR</span> de <span style="font-style:italic">A</span><sup>*</sup> (attention pas celle de
<span style="font-style:italic">A</span>), on a <span style="font-style:italic">AA</span><sup>*</sup>=<span style="font-style:italic">R</span><sup>*</sup><span style="font-style:italic">R</span>, donc <span style="font-style:italic">x</span>=<span style="font-style:italic">QR</span>(<span style="font-style:italic">R</span><sup>*</sup><span style="font-style:italic">R</span>)<sup>−1</sup><span style="font-style:italic">b</span>. Si <span style="font-style:italic">A</span> est de rang <span style="font-style:italic">n</span>,
on a alors en posant <span style="font-style:italic">R</span>=(<sub>0</sub><sup><span style="font-style:italic">R</span><sub>1</sub></sup>) avec <span style="font-style:italic">R</span><sub>1</sub> matrice <span style="font-style:italic">n</span>,<span style="font-style:italic">n</span> inversible :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>=<span style="font-style:italic">Q</span></td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">R</span><sub>1</sub></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell"><span style="font-style:italic">R</span><sub>1</sub><sup>−1</sup> <span style="font-style:italic">R</span><sub>1</sub><sup>*<sup>−1</sup></sup><span style="font-style:italic">b</span>=<span style="font-style:italic">Q</span></td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">R</span><sub>1</sub><sup>*<sup>−1</sup></sup> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell"><span style="font-style:italic">b</span>=<span style="font-style:italic">Q</span><sub>1</sub> <span style="font-style:italic">R</span><sub>1</sub><sup>*<sup>−1</sup></sup> <span style="font-style:italic">b</span></td></tr>
</table><p>
où <span style="font-style:italic">Q</span><sub>1</sub> désigne les <span style="font-style:italic">n</span> premières colonnes de <span style="font-style:italic">Q</span>.
</p><div class="theorem"><span style="font-weight:bold">Proposition 51</span>  <em>
Soit </em><span style="font-style:italic">A</span><em> une matrice ayant </em><span style="font-style:italic">n</span><em> lignes et </em><span style="font-style:italic">c</span>&gt;<span style="font-style:italic">n</span><em> colonnes.
Si </em><span style="font-style:italic">A</span><em> est de rang maximal </em><span style="font-style:italic">n</span><em>, posons </em><span style="font-style:italic">A</span><sup>*</sup>=<span style="font-style:italic">QR</span><em>, </em><span style="font-style:italic">R</span><sub>1</sub><em> les </em><span style="font-style:italic">n</span><em>
premières lignes de </em><span style="font-style:italic">R</span><sub>1</sub><em>, </em><span style="font-style:italic">Q</span><sub>1</sub><em> les </em><span style="font-style:italic">n</span><em> premières colonnes
de </em><span style="font-style:italic">Q</span><em>. La solution de </em><span style="font-style:italic">Ax</span>=<span style="font-style:italic">b</span><em> de norme
minimale est donnée par </em><span style="font-style:italic">Q</span><sub>1</sub><span style="font-style:italic">c</span><em> où </em><span style="font-style:italic">c</span><em> est la solution de </em><span style="font-style:italic">R</span><sub>1</sub><sup>*</sup><span style="font-style:italic">c</span>=<span style="font-style:italic">b</span><em>
(système triangulaire).
</em></div><p><span style="font-weight:bold">Exemple 1 : la régression linéaire</span> :<br>
On se donne <span style="font-style:italic">n</span> points de coordonnées (<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>,<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub>) où les <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>
sont distincts 2 à 2 et on cherche
la droite qui approche le mieux ces points au sens de l’écart en <span style="font-style:italic">y</span>
au carré. Il s’agit donc de trouver α et β qui minimisent :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> (α+β <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>−<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub>)<sup>2</sup> </td></tr>
</table><p>
Ici on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>=</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">x</span><sub>1</sub> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >...</td><td style="text-align:center;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>  </td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">,    
<span style="font-style:italic">x</span>=</td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >α </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >β </td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell">,
  
<span style="font-style:italic">b</span>=</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">y</span><sub>1</sub>  </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >...  </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">y</span><sub><span style="font-style:italic">n</span></sub>  </td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
Pour trouver α, β de manière précise, on préferera
donc calculer la factorisation <span style="font-style:italic">QR</span> de <span style="font-style:italic">A</span> plutôt que calculer <span style="font-style:italic">A</span><sup>*</sup><span style="font-style:italic">A</span>, <span style="font-style:italic">R</span><sub>1</sub> est
une matrice carrée d’ordre 2, <span style="font-style:italic">Q</span> une matrice carrée d’ordre <span style="font-style:italic">n</span>, 
la première colonne de <span style="font-style:italic">Q</span> est le vecteur de coordonnées
± (1,...,1)/√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span>.</p><p>Exemple : on se donne les points (1,2), (2,1), (3,5), (4,4). La
matrice <span style="font-style:italic">A</span> et <span style="font-style:italic">b</span> sont donc<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">A:=evalf(tran([seq(1,4),seq(j,j,1,4)])); b:=[2,1,5,4]; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">q,r:=qr(A); y0,m:=normal(r[0..1,0..1]^-1*trn(q)[0..1]*b); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:40px;font-style:large">purge(x);droite(y=m*x+y0); scatterplot(seq(j,j,1,4),b);linear_regression_plot(seq(j,j,1,4),b)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p><span style="font-weight:bold">Exemple 2: régression polynomiale</span> :<br>
C’est une généralisation de l’exemple précédent, on cherche un polynôme <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)
de degré fixé tel que ∑<sub><span style="font-style:italic">i</span></sub> (<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub>−<span style="font-style:italic">P</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>))<sup>2</sup> soit minimal. Si on
choisit la base canonique des polynômes, la
matrice <span style="font-style:italic">A</span> est alors une matrice de Vandermonde 
et son conditionnement est en général très mauvais. 
De plus, plus le degré augmente, plus l’extrapolation 
est hasardeuse :<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">a:=[[0,-3],[1,-1],[2,0],[3,1],[4,3],[5,4],[6,5],[10,9]]:; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:40px;font-style:large">scatterplot(a); linear_regression_plot(a[0..6]); polynomial_regression_plot(a[0..6],4);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>On préfèrera utiliser une base de polynômes orthogonaux pour
le produit scalaire ∑<sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)<span style="font-style:italic">Q</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)
ou minimiser une autre fonctionnelle quadratique, par
exemple une intégrale du carré de la différence entre une
fonction à approcher et un polynôme ou un
polynôme trigonométrique.</p><p><span style="font-weight:bold">Remarque</span> : La factorisation <span style="font-style:italic">QR</span> peut s’obtenir
en calculant la factorisation de Cholesky de <span style="font-style:italic">A</span><sup>*</sup> <span style="font-style:italic">A</span> qui donne <span style="font-style:italic">R</span>,
mais on lui préfère une méthode de calcul direct pour des
raisons de stabilité, en tout cas pour des matrices denses (pour des
matrices creuses des considérations d’efficacité peuvent faire
préférer la factorisation de Cholesky).</p>
<!--TOC subsubsection id="sec251" Méthodes itératives de
Jacobi, Gauss-Seidel, relaxation-->
<h4 id="sec251" class="subsubsection">22.9.2  Méthodes itératives de
Jacobi, Gauss-Seidel, relaxation</h4><!--SEC END --><p><a id="hevea_default284"></a> <a id="hevea_default285"></a>
<a id="sec:jacobi"></a>
Lorsqu’on a une matrice creuse (peu d’éléments non nuls),
l’algorithme du pivot de Gauss a tendance à densifier rapidement
la matrice réduite (surtout avec le pivot partiel où on ne
controle pas le nombre de zéros de la ligne contenant le pivot). Il
peut alors être intéressant d’utiliser des méthodes alternatives
ne faisant intervenir que des produits de matrice, donnant éventuellement
un résultat seulement approché. </p><p>Par exemple pour calculer
l’inverse d’une matrice <span style="font-style:italic">A</span>=<span style="font-style:italic">M</span>−<span style="font-style:italic">N</span>, avec <span style="font-style:italic">M</span> facile à inverser (par
exemple diagonale) et 
<span style="font-style:italic">N</span> petit en norme et creuse, on peut écrire :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span><sup>−1</sup>=(<span style="font-style:italic">M</span>−<span style="font-style:italic">N</span>)<sup>−1</sup> =
(<span style="font-style:italic">M</span>(<span style="font-style:italic">I</span>−<span style="font-style:italic">M</span><sup>−1</sup><span style="font-style:italic">N</span>))<sup>−1</sup>=(<span style="font-style:italic">I</span>+<span style="font-style:italic">M</span><sup>−1</sup><span style="font-style:italic">N</span>+(<span style="font-style:italic">M</span><sup>−1</sup><span style="font-style:italic">N</span>)<sup>2</sup>+...)<span style="font-style:italic">M</span><sup>−1</sup></td></tr>
</table><p>De même pour résoudre un système linéaire <span style="font-style:italic">Ax</span>=<span style="font-style:italic">b</span>
avec <span style="font-style:italic">A</span>=<span style="font-style:italic">M</span>−<span style="font-style:italic">N</span>,
on considère la suite <span style="font-style:italic">Mx</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">Nx</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">b</span>, donc <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub> est obtenu
en résolvant le système :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Mx</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">b</span>+<span style="font-style:italic">N</span> <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>,    <span style="font-style:italic">x</span><sub>0</sub>=0</td></tr>
</table><p>
pour laquelle on vérifiera les hypothèses du théorème du point
fixe, il suffit par exemple de vérifier que la plus
grande valeur singulière de <span style="font-style:italic">M</span><sup>−1</sup><span style="font-style:italic">N</span> est strictement plus petite que 1.
Lorsque la matrice <span style="font-style:italic">N</span> n’est pas creuse, le procédé est intéressant
pour résoudre approximativement un système si <span style="font-style:italic">n</span> est grand
et si chaque itération est en <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>2</sup>) (ceci veut
dire qu’on ne calcule pas <span style="font-style:italic">M</span><sup>−1</sup> sauf si c’est
évident, par exemple si <span style="font-style:italic">M</span> est diagonale), 
mais le procédé n’est pas intéressant pour le calcul de
l’inverse de <span style="font-style:italic">A</span>.</p><p>Notons <span style="font-style:italic">D</span> la partie diagonale de <span style="font-style:italic">A</span>,
<span style="font-style:italic">L</span> sa partie triangulaire inférieure stricte, <span style="font-style:italic">U</span> sa partie
triangulaire supérieure stricte,
La méthode de Jacobi utilise pour <span style="font-style:italic">M</span> la
diagonale <span style="font-style:italic">D</span> de <span style="font-style:italic">A</span>, alors
que la méthode de Gauss-Seidel prend pour <span style="font-style:italic">M</span> la partie triangulaire
inférieure <span style="font-style:italic">D</span>+<span style="font-style:italic">L</span> de <span style="font-style:italic">A</span> (diagonale comprise). 
Pour Jacobi, on a donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">D</span><sup>−1</sup>(<span style="font-style:italic">b</span>+(<span style="font-style:italic">D</span>−<span style="font-style:italic">A</span>)<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>)=<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>+<span style="font-style:italic">D</span><sup>−1</sup>(<span style="font-style:italic">b</span>−<span style="font-style:italic">Ax</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
</table><p>
En Xcas, l’instruction préprogrammée est <code>jacobi_linsolve</code>, 
on peut aussi programmer la méthode par

</p><pre class="verbatim">jacobi(A,b,eps,N):={
  local D,x0,x1,n,j;
  n:=size(A);
  D:=diag(A).^-1;
  x0:=seq(0,n);
  pour j de 1 jusque N faire
    x1:=b-A*x0;
    si l2norm(x1)&lt;eps alors return x0; fsi;
    x0:=x0+D .*x1;
  fpour;
  return "non convergent";
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;t.value=tmp;tmp=UI.caseval(tmp);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML);field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>

Un cas simple où on a convergence :
</p><div class="theorem"><span style="font-weight:bold">Proposition 52</span>  <em> 
Lorsque la matrice </em><span style="font-style:italic">A</span><em> est
à diagonale strictement dominante, c’est-à-dire que
l’élément diagonal est en valeur absolue strictement supérieur
à la somme des éléments non diagonaux de la même ligne :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">a</span><sub><span style="font-style:italic">ii</span></sub>| &gt; </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>≠ <span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> |<span style="font-style:italic">a</span><sub><span style="font-style:italic">ij</span></sub>| </td></tr>
</table><em>
la méthode de Jacobi converge.
</em></div><p>
En effet,
||<span style="font-style:italic">M</span><sup>−1</sup><span style="font-style:italic">Nx</span>||<sub>∞</sub>&lt; || <span style="font-style:italic">x</span>||<sub>∞</sub> car :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|(<span style="font-style:italic">Nx</span>)<sub><span style="font-style:italic">i</span></sub>| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span> ≠ <span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell"> |<span style="font-style:italic">a</span><sub><span style="font-style:italic">ij</span></sub>| |<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span> ≠ <span style="font-style:italic">i</span></td></tr>
</table></td><td class="dcell">
|<span style="font-style:italic">a</span><sub><span style="font-style:italic">ij</span></sub>| ||<span style="font-style:italic">x</span>||<sub>∞</sub>&lt; |<span style="font-style:italic">a</span><sub><span style="font-style:italic">ii</span></sub>| || <span style="font-style:italic">x</span>||<sub>∞</sub>    ⇒    |<span style="font-style:italic">M</span><sup>−1</sup>(<span style="font-style:italic">Nx</span>)<sub><span style="font-style:italic">i</span></sub>| &lt;  || <span style="font-style:italic">x</span>||<sub>∞</sub></td></tr>
</table><p>
On retrouve ce cas pour une petite perturbation d’une matrice
diagonale, par exemple <br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">n:=500;A:=2*idn(n)+1e-4*ranm(n,n,uniform,-1,1):;b:=seq(1,n):; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">time(c:=linsolve(A,b));
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">time(d:=jacobi(A,b,1e-12,50));
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">maxnorm(d-c)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
Pour <span style="font-style:italic">n</span> assez grand, la méthode de Jacobi devient plus rapide. Cela
se vérifie encore plus vite si <span style="font-style:italic">A</span> est une matrice creuse.</p><p>Pour Gauss-Seidel,
le calcul de <span style="font-style:italic">M</span><sup>−1</sup> n’est pas effectué, on résoud
directement le système triangulaire <span style="font-style:italic">Mx</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">b</span>+<span style="font-style:italic">Nx</span><sub><span style="font-style:italic">n</span></sub> soit
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">D</span>+<span style="font-style:italic">L</span>)<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">b</span>−<span style="font-style:italic">Ux</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table><p> 
Gauss-Seidel
est moins adapté à la parallélisation que Jacobi.
On adapte le programme précédent

</p><pre class="verbatim">seidel(A,b,N,eps):={
  local L,U,x0,x1,n,j;
  n:=size(A);
  L:=diag(A,left);
  U:=A-L;
  x0:=seq(0.0,n);
  pour j de 1 jusque N faire
    x1:=b-U*x0;
    x1:=linsolve(L,x1);
    si l2norm(x1-x0)&lt;eps*l2norm(x0) alors return x0; fsi;
    x0:=x1;
  fpour;
  return "non convergent";
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;t.value=tmp;tmp=UI.caseval(tmp);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML);field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>

</p><p>Dans la méthode de relaxation, on pose pour <span style="font-style:italic">M</span> la matrice triangulaire
inférieure <span style="font-style:italic">M</span>=1/ω<span style="font-style:italic">D</span>+<span style="font-style:italic">L</span> où ω &gt;0, donc
<span style="font-style:italic">N</span>=(1/ω−1) <span style="font-style:italic">D</span>−<span style="font-style:italic">U</span>
et on utilise la récurrence <span style="font-style:italic">Mx</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">b</span>+<span style="font-style:italic">Nx</span><sub><span style="font-style:italic">n</span></sub> donc
<span style="font-style:italic">Mx</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">b</span>+(<span style="font-style:italic">M</span>−<span style="font-style:italic">A</span>)<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> puis
<span style="font-style:italic">M</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>)=<span style="font-style:italic">b</span>−<span style="font-style:italic">Ax</span><sub><span style="font-style:italic">n</span></sub> puis
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">D</span>+ω <span style="font-style:italic">L</span>) (<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>) = ω(<span style="font-style:italic">b</span>−<span style="font-style:italic">Ax</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
</table><p>
On remarque que Gauss-Seidel correspond à ω=1.
L’instruction correspondante de Xcas est <code>gauss_seidel_linsolve</code> et
peut prendre en paramètre le coefficient de relaxation, 
dont la valeur par défaut est 1.</p><div class="theorem"><span style="font-weight:bold">Proposition 53</span>  <em> (Convergence ): 
si </em><span style="font-style:italic">A</span>=<span style="font-style:italic">M</span>−<span style="font-style:italic">N</span><em> est une matrice symétrique définie positive
et si </em><span style="font-style:italic">M</span><sup>*</sup>+<span style="font-style:italic">N</span><em> est définie positive, alors la méthode converge. 
</em></div><p>
On utilise la norme correspondant à
la forme quadratique de matrice <span style="font-style:italic">A</span> et on calcule la norme subordonnée
de <span style="font-style:italic">M</span><sup>−1</sup><span style="font-style:italic">N</span>, on a  <span style="font-style:italic">M</span><sup>−1</sup><span style="font-style:italic">Nx</span>=<span style="font-style:italic">x</span>−<span style="font-style:italic">y</span> avec <span style="font-style:italic">y</span>=<span style="font-style:italic">M</span><sup>−1</sup><span style="font-style:italic">Ax</span> donc 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >|| <span style="font-style:italic">M</span><sup>−1</sup><span style="font-style:italic">Nx</span> ||<sub><span style="font-style:italic">A</span></sub><sup>2</sup></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >&lt;<span style="font-style:italic">x</span>−<span style="font-style:italic">y</span>|<span style="font-style:italic">A</span> (<span style="font-style:italic">x</span>−<span style="font-style:italic">y</span>))&gt; </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >&lt;<span style="font-style:italic">x</span>|<span style="font-style:italic">Ax</span>&gt;+&lt;<span style="font-style:italic">y</span>|<span style="font-style:italic">Ay</span>&gt;−&lt;<span style="font-style:italic">y</span>|<span style="font-style:italic">Ax</span>&gt;−&lt;<span style="font-style:italic">x</span>|<span style="font-style:italic">Ay</span>&gt; </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >&lt;<span style="font-style:italic">x</span>|<span style="font-style:italic">Ax</span>&gt;+&lt;<span style="font-style:italic">y</span>|<span style="font-style:italic">Ay</span>&gt;−&lt;<span style="font-style:italic">y</span>|<span style="font-style:italic">My</span>&gt; −&lt;<span style="font-style:italic">My</span>|<span style="font-style:italic">y</span>&gt;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >&lt;<span style="font-style:italic">x</span>|<span style="font-style:italic">Ax</span>&gt;−&lt;<span style="font-style:italic">y</span>|(<span style="font-style:italic">M</span><sup>*</sup>+<span style="font-style:italic">N</span>)<span style="font-style:italic">y</span>&gt;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&lt;</td><td style="text-align:left;white-space:nowrap" >&lt;<span style="font-style:italic">x</span>|<span style="font-style:italic">Ax</span>&gt;=||<span style="font-style:italic">x</span>||<sub><span style="font-style:italic">A</span></sub><sup>2</sup>
</td></tr>
</table></td></tr>
</table><p>
Conséquence : si <span style="font-style:italic">A</span> symétrique définie positive, alors 
Gauss-Seidel converge, car <span style="font-style:italic">M</span><sup>*</sup>+<span style="font-style:italic">N</span>=<span style="font-style:italic">D</span>. Pour la relaxation,
on a <span style="font-style:italic">M</span><sup>*</sup>+<span style="font-style:italic">N</span>=(2/ω −1)<span style="font-style:italic">D</span> qui est définie positive si ω&lt;2.</p><p><span style="font-weight:bold">Remarque </span>: Jacobi et Gauss-Seidel sont implémentées dans les commandes
Xcas <span style="font-family:monospace">jacobi_linsolve</span> et <span style="font-family:monospace">gauss_seidel_linsolve</span>.</p>
<!--TOC subsubsection id="sec252" Méthode du gradient à pas constant-->
<h4 id="sec252" class="subsubsection">22.9.3  Méthode du gradient à pas constant</h4><!--SEC END --><p><a id="hevea_default286"></a>
<a id="hevea_default287"></a>
Soit <span style="font-style:italic">A</span> est une matrice symétrique définie positive (relativement
à un produit scalaire noté &lt;|&gt;), on
considère la fonctionnelle :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">J</span>(<span style="font-style:italic">v</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> &lt;<span style="font-style:italic">Av</span>|<span style="font-style:italic">v</span>&gt;−&lt;<span style="font-style:italic">b</span>|<span style="font-style:italic">v</span>&gt;</td></tr>
</table><p>
<span style="font-style:italic">J</span>(<span style="font-style:italic">v</span>) tend vers +∞ lorsque ||<span style="font-style:italic">v</span>|| tend vers l’infini, 
car si λ<sub>1</sub>&gt;0 est la plus petite valeur propre de <span style="font-style:italic">A</span>,
on a <span style="font-style:italic">J</span>(<span style="font-style:italic">v</span>)≥ 1/2 λ<sub>1</sub> ||<span style="font-style:italic">v</span>||<sup>2</sup>−||<span style="font-style:italic">b</span>||||<span style="font-style:italic">v</span>||.
Elle admet donc un minimum global, qui vérifie <span style="font-style:italic">J</span>′(<span style="font-style:italic">v</span>)=∇ <span style="font-style:italic">J</span>(<span style="font-style:italic">v</span>)=0
Or <span style="font-style:italic">d</span><sub><span style="font-style:italic">v</span></sub><span style="font-style:italic">J</span>(<span style="font-style:italic">w</span>)=&lt;<span style="font-style:italic">Av</span>−<span style="font-style:italic">b</span>|<span style="font-style:italic">w</span>&gt;, en effet
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;<span style="font-style:italic">A</span>(<span style="font-style:italic">v</span>+<span style="font-style:italic">hw</span>)|(<span style="font-style:italic">v</span>+<span style="font-style:italic">hw</span>)&gt;−&lt;<span style="font-style:italic">Av</span>|<span style="font-style:italic">v</span>&gt;=<span style="font-style:italic">h</span>&lt;<span style="font-style:italic">Aw</span>|<span style="font-style:italic">v</span>&gt;+<span style="font-style:italic">h</span>&lt;<span style="font-style:italic">Av</span>|<span style="font-style:italic">w</span>&gt;+<span style="font-style:italic">O</span>(<span style="font-style:italic">h</span><sup>2</sup>)=2<span style="font-style:italic">h</span>&lt;<span style="font-style:italic">Av</span>|<span style="font-style:italic">w</span>&gt;+<span style="font-style:italic">O</span>(<span style="font-style:italic">h</span><sup>2</sup>)</td></tr>
</table><p>
donc ∇ <span style="font-style:italic">J</span> (<span style="font-style:italic">v</span>)=<span style="font-style:italic">Av</span>−<span style="font-style:italic">b</span>
Donc le minimum global est l’unique solution de <span style="font-style:italic">Av</span>=<span style="font-style:italic">b</span>.</p><p>La méthode du gradient à pas constant consiste à résoudre le
système <span style="font-style:italic">Av</span>=<span style="font-style:italic">b</span> en minimisant <span style="font-style:italic">J</span>. Pour cela on calcule une suite récurrente
de premier terme par exemple <span style="font-style:italic">v</span><sub>0</sub>=0, et au rang <span style="font-style:italic">k</span>+1 on suit la
direction opposée au gradient de <span style="font-style:italic">J</span> en <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> selon un pas constant :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>−ρ (<span style="font-style:italic">Av</span><sub><span style="font-style:italic">k</span></sub>−<span style="font-style:italic">b</span>)</td></tr>
</table><p>
La plus grande et plus petite valeur propre de <span style="font-style:italic">I</span>−ρ <span style="font-style:italic">A</span> sont 
1−ρ λ<sub>1</sub> et 1−ρ λ<sub><span style="font-style:italic">n</span></sub>, si ces deux valeurs propres
sont en module strictement inférieure à 1, alors <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> va
converger à vitesse géométrique (de raison max(|1−ρ
λ<sub>1</sub>|,|1−ρ λ<sub><span style="font-style:italic">n</span></sub>|) vers l’unique point fixe de
<span style="font-style:italic">f</span>(<span style="font-style:italic">v</span>)=(<span style="font-style:italic">I</span>−ρ <span style="font-style:italic">A</span>)<span style="font-style:italic">v</span>+ρ <span style="font-style:italic">b</span>, qui est la solution du système <span style="font-style:italic">Av</span>=<span style="font-style:italic">b</span>.
Il suffit de choisir ρ (si on a une estimation sur λ<sub>1</sub> et
λ<sub><span style="font-style:italic">n</span></sub>).</p><p>Par exemple, pour la matrice du laplacien discret (2 sur la diagonale,
et -1 sur les 2 diagonales de part et d’autre), les valeurs propres
sont les 2(1−cos(<span style="font-style:italic">k</span>π/(<span style="font-style:italic">n</span>+1))), il faut donc que 
 −1 &lt; 1−2ρ (1+cos(π/(<span style="font-style:italic">n</span>+1)))
soit 0&lt;ρ&lt;1/1+cos(π/(<span style="font-style:italic">n</span>+1)).
La valeur optimale est obtenue lorsque les 2 valeurs extrêmales ont
même valeur absolue
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">2ρ (1+cos(π/(<span style="font-style:italic">n</span>+1))−1=1−2ρ (1−cos(π/(<span style="font-style:italic">n</span>+1)) 
 ⇒ 
ρ = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
</table><p>
La vitesse de convergence est assez lente, car |<span style="font-style:italic">I</span>−ρ <span style="font-style:italic">A</span>| a pour
valeur propre maximale cos(π/(<span style="font-style:italic">n</span>+1)), par exemple pour <span style="font-style:italic">n</span>=20,
cos(<span style="font-style:italic">pi</span>/21.) ≡ 0.988 est très proche de 1.</p>
<!--TOC subsubsection id="sec253" Méthode itérative du gradient conjugué-->
<h4 id="sec253" class="subsubsection">22.9.4  Méthode itérative du gradient conjugué</h4><!--SEC END --><p><a id="hevea_default288"></a>
Il s’agit de résoudre <span style="font-style:italic">Ax</span>=<span style="font-style:italic">b</span>, où <span style="font-style:italic">A</span> est définie positive. 
Si on a une base orthogonale pour le produit scalaire induit par <span style="font-style:italic">A</span>, 
on peut calculer la <span style="font-style:italic">j</span>-ième coordonnée de <span style="font-style:italic">x</span> 
dans cette base en faisant le produit scalaire de 
<span style="font-style:italic">Ax</span>=<span style="font-style:italic">b</span> par le <span style="font-style:italic">j</span>-ième vecteur de la base. 
On construit donc petit à petit une base orthogonale 
{ <span style="font-style:italic">p</span><sub>1</sub>,...,<span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> } pour <span style="font-style:italic">A</span> par un procédé à la Gram-Schmidt, 
mais on ne part pas de la base canonique : 
on construit cette famille orthogonale pour <span style="font-style:italic">A</span> 
en meme temps qu’on calcule les composantes de <span style="font-style:italic">x</span>.
Si <span style="font-style:italic">x</span>=∑<sub><span style="font-style:italic">j</span>≥ 1</sub> α<sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>, alors 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;<span style="font-style:italic">b</span>|<span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>&gt;=&lt;<span style="font-style:italic">Ax</span>|<span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>&gt;=α<sub><span style="font-style:italic">j</span></sub> &lt;<span style="font-style:italic">Ap</span><sub><span style="font-style:italic">j</span></sub>|<span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>&gt;</td></tr>
</table><p>
Posons <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>=∑<sub><span style="font-style:italic">j</span>≤ <span style="font-style:italic">i</span></sub> α<sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>, on a donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;<span style="font-style:italic">b</span>−<span style="font-style:italic">Ax</span><sub><span style="font-style:italic">i</span></sub>|<span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>&gt;=0  si  <span style="font-style:italic">j</span>≤ <span style="font-style:italic">i</span>,    
&lt;<span style="font-style:italic">b</span>−<span style="font-style:italic">Ax</span><sub><span style="font-style:italic">i</span></sub>|<span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>&gt;=α<sub><span style="font-style:italic">j</span></sub> &lt;<span style="font-style:italic">Ap</span><sub><span style="font-style:italic">j</span></sub>|<span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>&gt;  sinon.</td></tr>
</table><p>
On peut donc construire <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> comme une suite récurrente de 
la manière suivante : 
</p><ol class="enumerate" type=1><li class="li-enumerate">
on initialise par <span style="font-style:italic">x</span><sub>0</sub>=0, 
</li><li class="li-enumerate">à la <span style="font-style:italic">i</span>-ième itération, on pose <span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>=<span style="font-style:italic">b</span>−<span style="font-style:italic">Ax</span><sub><span style="font-style:italic">i</span></sub>, on a donc
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>|<span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>&gt;=0  si  <span style="font-style:italic">j</span>≤ <span style="font-style:italic">i</span> </td></tr>
</table>
</li><li class="li-enumerate">On en déduit que si <span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub> est combinaison linéaire des <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>, <span style="font-style:italic">j</span>
≤ <span style="font-style:italic">i</span>, alors <span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>=0 donc on a terminé : <span style="font-style:italic">x</span>=<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>.
</li><li class="li-enumerate">Sinon, on complète la famille <span style="font-style:italic">A</span>-orthogonale par un nouveau vecteur
<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub> tel que <span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>−<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub> soit dans Vect({
<span style="font-style:italic">p</span><sub>1</sub>,...,<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub>}) et <span style="font-style:italic">A</span>-orthogonal. On observe que <span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub> est combinaison
linéaire des <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub> pour <span style="font-style:italic">j</span> ≤ <span style="font-style:italic">i</span>+1, donc &lt;<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span></sub>|<span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub>&gt;=0 si <span style="font-style:italic">i</span>&lt;<span style="font-style:italic">k</span>
puisque <span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub> est orthogonal aux <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub> pour <span style="font-style:italic">j</span> ≤ <span style="font-style:italic">i</span> &lt;<span style="font-style:italic">k</span>.
</li><li class="li-enumerate">On calcule la <span style="font-style:italic">i</span>+1-ième composante de <span style="font-style:italic">x</span> 
sur la famille orthogonale augmentée :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">α<sub><span style="font-style:italic">i</span>+1</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&lt;<span style="font-style:italic">b</span>|<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>&gt;</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&lt;<span style="font-style:italic">Ap</span><sub><span style="font-style:italic">i</span>+1</sub>|<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>&gt;</td></tr>
</table></td></tr>
</table>
On peut maintenant ajouter la <span style="font-style:italic">i</span>+1-ième composante de <span style="font-style:italic">x</span> à <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> 
pour obtenir <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span>+1</sub>=<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>+α<sub><span style="font-style:italic">i</span>+1</sub><span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>. 
</li><li class="li-enumerate">Pour calculer efficacement <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>, on observe que
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+1</sub>−<span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">A</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>−1</sub>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>)=−α<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">A</span> <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table>
Donc <span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>−<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub> est orthogonal à <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> pour <span style="font-style:italic">k</span>&lt;<span style="font-style:italic">i</span> :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>−<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>|<span style="font-style:italic">Ap</span><sub><span style="font-style:italic">k</span></sub>&gt;=−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">α</td></tr>
</table></td><td class="dcell"><sub><span style="font-style:italic">k</span></sub>&lt;<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>|<span style="font-style:italic">Ap</span><sub><span style="font-style:italic">k</span></sub>&gt;=−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">α</td></tr>
</table></td><td class="dcell"><sub><span style="font-style:italic">k</span></sub>&lt;<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>|<span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span>+1</sub>−<span style="font-style:italic">r</span><sub><span style="font-style:italic">k</span></sub>&gt;=0</td></tr>
</table>
Ainsi <span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>−<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>=β<sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub>  et :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>−<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>|<span style="font-style:italic">Ap</span><sub><span style="font-style:italic">i</span></sub>&gt;=−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">α</td></tr>
</table></td><td class="dcell"><sub><span style="font-style:italic">i</span></sub>&lt;<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>|<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>&gt;=
β<sub><span style="font-style:italic">i</span></sub>&lt;<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub>|<span style="font-style:italic">Ap</span><sub><span style="font-style:italic">i</span></sub>&gt;</td></tr>
</table>
</li><li class="li-enumerate">De plus :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">α<sub><span style="font-style:italic">i</span>+1</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&lt;<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>|<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>&gt;</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&lt;<span style="font-style:italic">Ap</span><sub><span style="font-style:italic">i</span>+1</sub>|<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>&gt;</td></tr>
</table></td></tr>
</table>
En effet, comme
<span style="font-style:italic">b</span>=<span style="font-style:italic">Ax</span><sub><span style="font-style:italic">i</span></sub>+<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub> et comme <span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub> est orthogonal aux <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>, <span style="font-style:italic">j</span> ≤ <span style="font-style:italic">i</span> :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;<span style="font-style:italic">b</span>|<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>&gt;=&lt;<span style="font-style:italic">Ax</span><sub><span style="font-style:italic">i</span></sub>+<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>|<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>&gt;=&lt;<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>|<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>&gt;=&lt;<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>|<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>&gt;</td></tr>
</table>
</li><li class="li-enumerate">Donc 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">β<sub><span style="font-style:italic">i</span></sub>=−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&lt;<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>|<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>&gt;</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">&lt;<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span></sub>|<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span></sub>&gt;</td></tr>
</table></td><td class="dcell">,
   <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>=<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>−β<sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table>
</li></ol><p>
On s’arrête en au plus la dimension itérations 
lorsque la famille orthogonale est devenue une base. En grande
dimension, on peut décider de s’arrêter prématurément
sur une solution approchée en testant
si la norme de la valeur du résidu vérifie
||<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span>+1</sub>||=||<span style="font-style:italic">b</span>−<span style="font-style:italic">Ax</span><sub><span style="font-style:italic">i</span></sub>||&lt;ε.</p><p>La commande <code>conjugate_gradient(A,b)</code> de Xcas permet de faire ce
calcul, on peut préciser une valeur initiale de recherche <code>x0</code>
et une précision <code>eps</code> en tapant 
<code>conjugate_gradient(A,b,x0,eps)</code>.
Voir aussi le programme en langage Xcas depuis le 
menu <span style="font-family:monospace">Exemple, analyse, gradconj</span></p>
<!--TOC subsection id="sec254" Réduction approchée des endomorphismes-->
<h3 id="sec254" class="subsection">22.10  Réduction approchée des endomorphismes</h3><!--SEC END --><p>
On pourrait trouver des valeurs propres approchées d’une matrice
en calculant le polynome caractéristique ou minimal puis en le
factorisant numériquement. Mais cette méthode n’est pas idéale
relativement aux erreurs d’arrondis (calcul du polynome caractéristiaue,
de ses racines, et nouvelle approximation en calculant le noyau
de <span style="font-style:italic">A</span>−λ <span style="font-style:italic">I</span>), lorsqu’on veut calculer quelques valeurs propres
on préfère utiliser des méthodes itératives directement sur <span style="font-style:italic">A</span>
ce qui évite la propagation des erreurs d’arrondi.</p>
<!--TOC subsubsection id="sec255" Méthode de la puissance-->
<h4 id="sec255" class="subsubsection">22.10.1  Méthode de la puissance</h4><!--SEC END --><p> <a id="hevea_default289"></a>
Elle permet de déterminer la plus grande valeur propre en valeur absolue
d’une matrice diagonalisable lorsque celle-ci est unique.
Supposons en effet que les valeurs propres de <span style="font-style:italic">A</span> soient
<span style="font-style:italic">x</span><sub>1</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> avec |<span style="font-style:italic">x</span><sub>1</sub>| ≤ |<span style="font-style:italic">x</span><sub>2</sub>| ≤ ... ≤ |<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>| &lt; |<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>|
et soient <span style="font-style:italic">e</span><sub>1</sub>,...,<span style="font-style:italic">e</span><sub><span style="font-style:italic">n</span></sub> une base de vecteurs propres correspondants.
On choisit un vecteur aléatoire <span style="font-style:italic">v</span> et on calcule la suite
<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">Av</span><sub><span style="font-style:italic">k</span>−1</sub>=<span style="font-style:italic">A</span><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">v</span> . Si <span style="font-style:italic">v</span> a pour coordonnées <span style="font-style:italic">V</span><sub>1</sub>,...,<span style="font-style:italic">V</span><sub><span style="font-style:italic">n</span></sub>) 
dans la base propre, alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">V</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">e</span><sub><span style="font-style:italic">j</span></sub> 
= <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>,    <span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">V</span><sub><span style="font-style:italic">j</span></sub> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sub><span style="font-style:italic">j</span></sub>
</td></tr>
</table><p>
L’hypothèse que <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> est l’unique valeur propre
de module maximal entraine alors 
que lim<sub><span style="font-style:italic">k</span> → +∞</sub> <span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub> = <span style="font-style:italic">V</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">e</span><sub><span style="font-style:italic">n</span></sub> puisque la suite
géométrique de raison <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>/<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> converge vers 0.
Autrement dit, si <span style="font-style:italic">V</span><sub><span style="font-style:italic">n</span></sub>≠ 0 (ce qui a une probabilité 1 d’être
vrai pour un vecteur aléatoire), 
<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> est équivalent à <span style="font-style:italic">V</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">e</span><sub><span style="font-style:italic">n</span></sub>. Lorsque <span style="font-style:italic">n</span>
est grand, <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> est presque colinéaire au vecteur propre
<span style="font-style:italic">e</span><sub><span style="font-style:italic">n</span></sub> (que l’on peut estimer par <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> divisé par sa norme), 
ce que l’on détecte en testant si <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub> et <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>
sont presques colinéaires. De plus le facteur de colinéarité
entre <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub> et <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> est presque <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>, la valeur propre
de module maximal.</p><p>En pratique, pour éviter des débordements d’exposant des
coordonnées des <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> on normalise <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> à chaque
étape, on pose donc <span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">Av</span><sub><span style="font-style:italic">k</span></sub>, <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span>+1</sub>/||<span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span>+1</sub>|| 
et on estime <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> en calculant λ<sub><span style="font-style:italic">k</span></sub>=(<span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>|<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>).</p><p>Lorsque la matrice <span style="font-style:italic">A</span> est symétrique réelle ou hermitienne
complexe, on peut utiliser comme
test d’arrêt || <span style="font-style:italic">w</span><sub><span style="font-style:italic">k</span></sub>−λ<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>|| ≤ ε . En effet,
<span style="font-style:italic">A</span> est alors diagonalisable dans une base orthonormale,
on écrit la relation || (<span style="font-style:italic">A</span>−λ<sub><span style="font-style:italic">k</span></sub>)<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> || ≤ ε
dans cette base et on obtient qu’il existe une valeur propre de <span style="font-style:italic">A</span>
à distance inférieure ou égale à ε de
la valeur propre estimée λ<sub><span style="font-style:italic">k</span></sub>. Ce résultat n’est
malheureusement plus vrai si <span style="font-style:italic">A</span> est quelconque, car deux
vecteurs propres peuvent faire un angle très petit. Par
exemple la matrice 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>=</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >0</td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">є</td></tr>
</table></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >1
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
a pour valeurs propres −1 et 1 mais
<span style="font-style:italic">A</span>(<sub>1</sub><sup>є</sup>)=(<sub>0</sub><sup>−є</sup>) donc 0 semble
être une valeur propre approchée. Il vaut alors mieux tester
l’écart entre deux estimations consécutives de la valeur
propre, en effet au premier ordre
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">λ<sub><span style="font-style:italic">k</span></sub>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> ≈ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> β<sub><span style="font-style:italic">j</span></sub> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td></tr>
</table><p>
où la somme porte sur les indices <span style="font-style:italic">j</span> des valeurs propres
de module sous-dominant. En général cette somme se
réduit au seul indice <span style="font-style:italic">j</span>=<span style="font-style:italic">n</span>−1, et λ<sub><span style="font-style:italic">k</span>+1</sub>−λ<sub><span style="font-style:italic">k</span></sub> se
comporte comme une suite géométrique (de raison <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>/<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>),
on peut alors estimer l’erreur par 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|λ<sub><span style="font-style:italic">k</span></sub>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>| ≤ є,   
є ≈<sub><span style="font-style:italic">k</span> → +∞</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">|λ<sub><span style="font-style:italic">k</span>+1</sub>−λ<sub><span style="font-style:italic">k</span></sub>|</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−|</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">λ<sub><span style="font-style:italic">k</span>+2</sub>−λ<sub><span style="font-style:italic">k</span>+1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">λ<sub><span style="font-style:italic">k</span>+1</sub>−λ<sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td><td class="dcell">|</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Mais cette estimation n’est plus correcte s’il y a plusieurs indices
<span style="font-style:italic">j</span> sous-dominants (cas par exemple d’une paire 
de valeurs propres conjuguées
pour une matrice réelle).</p><p>Exercice : tester la convergence de <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">A</span><sup><span style="font-style:italic">k</span></sup><span style="font-style:italic">v</span> vers l’espace propre
associé à λ=3 pour la matrice <code>[[1,-1],[2,4]]</code>
et le vecteur <span style="font-style:italic">v</span>=(1,0). Attention à ne pas calculer <span style="font-style:italic">A</span><sup><span style="font-style:italic">k</span></sup> pour
déterminer <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>, utiliser la relation de récurrence!</p><p>Si on n’observe pas de convergence ou si elle est trop lente, alors
|<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>| est proche de |<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>| ou égal, il est judicieux
de faire subir à la matrice un shift, on remplace <span style="font-style:italic">A</span> par
<span style="font-style:italic">A</span>−λ <span style="font-style:italic">I</span>. On peut prendre λ aléatoirement, ou bien
mieux faire des itérations inverses sur <span style="font-style:italic">A</span>−λ <span style="font-style:italic">I</span> si λ
est une estimation d’une valeur propre (voir les itérations inverses
ci-dessous).</p><p>Lorsqu’on applique cette méthode a une matrice réelle, il peut arriver
quíl y ait deux valeurs propres conjuguées de module maximal. On
peut appliquer la méthode ci-dessus avec un shift complexe non réel,
mais on doit alors travailler en arithmétique complexe 
ce qui est plus couteux. Le même
type de raisonnement que ci-dessus montre que pour <span style="font-style:italic">k</span> grand,
<span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+2</sub> est presque colinéaire à l’espace engendré par <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> et <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub>, 
la recherche d’une relation  <span style="font-style:italic">av</span><sub><span style="font-style:italic">k</span>+2</sub>+ <span style="font-style:italic">b</span> <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span>+1</sub> + <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>=0 
permet alors de calculer les valeurs propres qui sont les deux racines
de <span style="font-style:italic">ax</span><sup>2</sup>+<span style="font-style:italic">bx</span>+1=0.</p><p>La convergence est de type série géométrique, on gagne le même nombre
de décimales à chaque itération. </p><p>Applications : 
</p><ul class="itemize"><li class="li-itemize">
la méthode de la puissance peut donner
une estimation du nombre de condition <span style="font-style:italic">L</span><sup>2</sup> d’une
matrice <span style="font-style:italic">A</span>. On calcule <span style="font-style:italic">B</span>=<span style="font-style:italic">A</span><sup>*</sup> <span style="font-style:italic">A</span> puis on effectue
cette méthode sur <span style="font-style:italic">B</span> pour avoir une estimation
de la plus grande valeur propre, puis “sur <span style="font-style:italic">B</span><sup>−1</sup>”
par itérations inverses et on fait le rapport des racines carrées.
C’est une méthode intéressante si la matrice
est creuse et symétrique (pour pouvoir faire Cholesky creux
pour les itérations inverses).
</li><li class="li-itemize">la méthode de la puissance peut donner une estimation
rapide de la taille de la plus grande racine d’un polynôme (en
module), en itérant sur la matrice companion du polynôme,
matrice qui contient beaucoup de 0, donc le produit avec un vecteur
se fait en temps <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span>), où <span style="font-style:italic">n</span> est le degré du polynôme.
<pre class="verbatim">f(P,eps,N):={
  local k,l,n,v,old,new,oldratio,tmp;
  l:=coeffs(P);
  n:=degree(P);
  l:=revlist(l[1..n]/l[0]);
  v:=randvector(n,uniform,-1,1);
  oldratio:=inf;
  for k from 1 to N do
    old:=maxnorm(v);
    tmp := -l[0]*v[n-1];
    for j from 1 to n-1 do
      v[j] =&lt; v[j-1]-l[j]*v[n-1];
    od;
    v[0] =&lt; tmp;
    new:=maxnorm(v);
    if (abs(new/old-oldratio)&lt;eps) return new/old;
    oldratio:=new/old;
  od;
  retourne undef;
}:;
</pre></li></ul><p>Ceci peut par exemple servir à déterminer pour un polynôme <span style="font-style:italic">P</span> donné
squarefree (de degré <span style="font-style:italic">n</span> et coefficient dominant <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub>)
l’écart minimal entre 2 racines, on calcule<br>
<code>R:=normal(resultant(P,subst(P,x=x+y),x)/x^degree(P))</code><br>
c’est un polynôme bicarré dont on cherche la plus petite racine
en calculant le carré de la plus grande racine en module
de <code>numer(subst(R,y=1/sqrt(x)))</code>.</p><p>On peut obtenir un minorant à priori de cette plus petit racine en calculant 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">resultant(<span style="font-style:italic">P</span>,<span style="font-style:italic">P</span>′)= 
± <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub><sup>2<span style="font-style:italic">n</span>−1</sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center">1 ≤ <span style="font-style:italic">i</span> &lt; <span style="font-style:italic">j</span> ≤ <span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">r</span><sub><span style="font-style:italic">i</span></sub>−<span style="font-style:italic">r</span><sub><span style="font-style:italic">j</span></sub>)<sup>2</sup> 
</td></tr>
</table><p>
on isole l’écart minimal au carré, on majore les autres carrés en
majorant les racines, et
on peut minorer le résultant à priori par 1 si <span style="font-style:italic">P</span> est à coefficients
entiers.</p>
<!--TOC subsubsection id="sec256" Itérations inverses-->
<h4 id="sec256" class="subsubsection">22.10.2  Itérations inverses</h4><!--SEC END --><p> <a id="hevea_default290"></a>
La méthode précédente permet de calculer la valeur propre
de module maximal d’une matrice. Pour trouver une valeur
propre proche d’une quantité donnée <span style="font-style:italic">x</span>, on peut appliquer
la méthode précédente à la matrice (<span style="font-style:italic">A</span>−<span style="font-style:italic">xI</span>)<sup>−1</sup> (en pratique
on effectue <span style="font-style:italic">LU</span> sur <span style="font-style:italic">A</span>−<span style="font-style:italic">xI</span> et on résoud (<span style="font-style:italic">A</span>−<span style="font-style:italic">xI</span>)<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>). En effet,
les valeurs propres de cette matrice sont les (<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>−<span style="font-style:italic">x</span>)<sup>−1</sup> dont
la norme est maximale lorsqu’on se rapproche de <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>. Attention
à ne pas prendre <span style="font-style:italic">x</span> trop proche d’une valeur propre, car le calcul
de (<span style="font-style:italic">A</span>−<span style="font-style:italic">xI</span>)<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> est alors peu précis (la matrice étant
mal conditionnée).</p>
<!--TOC subsubsection id="sec257" Elimination des valeurs propres trouvées-->
<h4 id="sec257" class="subsubsection">22.10.3  Elimination des valeurs propres trouvées</h4><!--SEC END --><p>
Si la matrice <span style="font-style:italic">A</span> est symétrique, et
si <span style="font-style:italic">e</span><sub><span style="font-style:italic">n</span></sub> est un vecteur propre normé écrit en colonne, on peut considérer
la matrice <span style="font-style:italic">B</span>=<span style="font-style:italic">A</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">e</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">e</span><sub><span style="font-style:italic">n</span></sub><sup><span style="font-style:italic">t</span></sup> qui possède les mêmes valeurs
propres et mêmes vecteurs propres que <span style="font-style:italic">A</span> avec même multiplicité, 
sauf <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> qui est remplacé par 0. 
En effet les espaces propres de <span style="font-style:italic">A</span> sont orthogonaux
entre eux, donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Be</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">e</span><sub><span style="font-style:italic">n</span></sub> −<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">e</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">e</span><sub><span style="font-style:italic">n</span></sub><sup><span style="font-style:italic">t</span></sup> <span style="font-style:italic">e</span><sub><span style="font-style:italic">n</span></sub> = 0,
<span style="font-style:italic">Be</span><sub><span style="font-style:italic">k</span></sub> = <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">e</span><sub><span style="font-style:italic">k</span></sub> − <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">e</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">e</span><sub><span style="font-style:italic">n</span></sub><sup><span style="font-style:italic">t</span></sup> <span style="font-style:italic">e</span><sub><span style="font-style:italic">k</span></sub> = <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">e</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table><p>
On peut donc calculer
la 2ème valeur propre (en valeur absolue), l’éliminer
et ainsi de suite.</p><p>Si la matrice <span style="font-style:italic">A</span> n’est pas symétrique, il faut considérer
<span style="font-style:italic">B</span>=<span style="font-style:italic">A</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">e</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub><sup><span style="font-style:italic">t</span></sup> /<span style="font-style:italic">e</span><sub><span style="font-style:italic">n</span></sub>.<span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub> où <span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub> est vecteur propre
de <span style="font-style:italic">A</span><sup><span style="font-style:italic">t</span></sup> associé à <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>. En effet <span style="font-style:italic">f</span><sub><span style="font-style:italic">k</span></sub>.<span style="font-style:italic">e</span><sub><span style="font-style:italic">j</span></sub>=0 si <span style="font-style:italic">i</span> ≠ <span style="font-style:italic">j</span>
car <span style="font-style:italic">Ae</span><sub><span style="font-style:italic">k</span></sub>.<span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub>=<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">e</span><sub><span style="font-style:italic">k</span></sub>.<span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub>=<span style="font-style:italic">e</span><sub><span style="font-style:italic">k</span></sub>.<span style="font-style:italic">A</span><sup><span style="font-style:italic">t</span></sup><span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub>=<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub><span style="font-style:italic">e</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub> et donc <span style="font-style:italic">f</span><sub><span style="font-style:italic">k</span></sub>.<span style="font-style:italic">e</span><sub><span style="font-style:italic">k</span></sub> ≠ 0
(sinon <span style="font-style:italic">e</span><sub><span style="font-style:italic">k</span></sub> est dans l’orthogonal de ℝ<sup><span style="font-style:italic">n</span></sup>=Vect(<span style="font-style:italic">f</span><sub>1</sub>,...,<span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub>).</p>
<!--TOC subsubsection id="sec258" Décomposition de Schur-->
<h4 id="sec258" class="subsubsection">22.10.4  Décomposition de Schur</h4><!--SEC END --><p><a id="hevea_default291"></a>
<a id="hevea_default292"></a>
Il s’agit d’une factorisation de matrice sous la forme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span> = <span style="font-style:italic">P</span> <span style="font-style:italic">S</span> <span style="font-style:italic">P</span><sup>−1</sup></td></tr>
</table><p>
où <span style="font-style:italic">P</span> est unitaire et <span style="font-style:italic">S</span> diagonale supérieure.
Existence (théorique) : 
on prend une valeur propre et un vecteur propre correspondant,
puis on projette sur l’orthogonal de ce vecteur propre et on s’y
restreint, on prend à nouveau une valeur propre et un vecteur propre
correspondant, etc.</p><p>On peut approcher cette factorisation par un algorithme itératif
qui utilise la <span style="font-weight:bold">factorisation </span><span style="font-style:italic">QR</span><a id="hevea_default293"></a> 
d’une matrice quelconque comme
produit d’une matrice unitaire par une matrice triangulaire supérieure
à coefficients positifs sur la diagonale. On fait l’hypothèse que les
valeurs propres de <span style="font-style:italic">S</span> sur la diagonale sont classées par ordre de module 
strictement décroissant |λ<sub>1</sub>|&gt;|λ<sub>2</sub>|&gt;...&gt;|λ<sub><span style="font-style:italic">n</span></sub>| 
(développement inspiré par Peter J. Olver dans le cas symétrique
<code>http://www.math.umn.edu/~olver/aims_/qr.pdf</code>). On peut toujours
s’y ramener quitte à remplacer <span style="font-style:italic">A</span> par <span style="font-style:italic">A</span>− α <span style="font-style:italic">I</span>.
Posons <span style="font-style:italic">A</span><sub>1</sub>=<span style="font-style:italic">A</span>, et par récurrence <span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub> (avec <span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span></sub> unitaire et <span style="font-style:italic">R</span>
triangulaire supérieure à coefficients diagonaux positifs), 
<span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">Q</span><sub><span style="font-style:italic">n</span></sub>. On a alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">A</span><sup><span style="font-style:italic">k</span></sup></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">Q</span><sub>1</sub> <span style="font-style:italic">R</span><sub>1</sub>) (<span style="font-style:italic">Q</span><sub>1</sub> <span style="font-style:italic">R</span><sub>1</sub>) (<span style="font-style:italic">Q</span><sub>1</sub> <span style="font-style:italic">R</span><sub>1</sub>) ... (<span style="font-style:italic">Q</span><sub>1</sub> <span style="font-style:italic">R</span><sub>1</sub>) (<span style="font-style:italic">Q</span><sub>1</sub> <span style="font-style:italic">R</span><sub>1</sub>) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Q</span><sub>1</sub> (<span style="font-style:italic">R</span><sub>1</sub> <span style="font-style:italic">Q</span><sub>1</sub>) (<span style="font-style:italic">R</span><sub>1</sub> <span style="font-style:italic">Q</span><sub>1</sub>) (<span style="font-style:italic">R</span><sub>1</sub> ... <span style="font-style:italic">Q</span><sub>1</sub>) (<span style="font-style:italic">R</span><sub>1</sub> <span style="font-style:italic">Q</span><sub>1</sub>) <span style="font-style:italic">R</span><sub>1</sub> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Q</span><sub>1</sub> (<span style="font-style:italic">Q</span><sub>2</sub> <span style="font-style:italic">R</span><sub>2</sub>) (<span style="font-style:italic">Q</span><sub>2</sub> <span style="font-style:italic">R</span><sub>2</sub>) .. (<span style="font-style:italic">Q</span><sub>2</sub> <span style="font-style:italic">R</span><sub>2</sub>) <span style="font-style:italic">R</span><sub>1</sub> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Q</span><sub>1</sub> <span style="font-style:italic">Q</span><sub>2</sub> (<span style="font-style:italic">R</span><sub>2</sub> <span style="font-style:italic">Q</span><sub>2</sub>) <span style="font-style:italic">R</span><sub>2</sub> .. <span style="font-style:italic">Q</span><sub>2</sub> <span style="font-style:italic">R</span><sub>2</sub> <span style="font-style:italic">R</span><sub>1</sub> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Q</span><sub>1</sub> <span style="font-style:italic">Q</span><sub>2</sub> (<span style="font-style:italic">Q</span><sub>3</sub> <span style="font-style:italic">R</span><sub>3</sub>) ... <span style="font-style:italic">Q</span><sub>3</sub> <span style="font-style:italic">R</span><sub>3</sub> <span style="font-style:italic">R</span><sub>2</sub> <span style="font-style:italic">R</span><sub>1</sub> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Q</span><sub>1</sub> ... <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span></sub> ...<span style="font-style:italic">R</span><sub>1</sub>
</td></tr>
</table></td></tr>
</table><p>
D’autre part <span style="font-style:italic">A</span>=<span style="font-style:italic">PSP</span><sup>−1</sup> donc <span style="font-style:italic">A</span><sup><span style="font-style:italic">k</span></sup> = <span style="font-style:italic">P</span> <span style="font-style:italic">S</span><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">P</span><sup>−1</sup>. Soit <span style="font-style:italic">D</span> la forme diagonale
de <span style="font-style:italic">S</span> et <span style="font-style:italic">U</span> la matrice de passage <span style="font-style:italic">S</span>=<span style="font-style:italic">UDU</span><sup>−1</sup>, où <span style="font-style:italic">U</span> est triangulaire supérieure
et où on choisit la normalisation des coefficients sur la diagonale de <span style="font-style:italic">U</span> valant 1.
On a donc 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span><sup><span style="font-style:italic">k</span></sup> = <span style="font-style:italic">P</span> <span style="font-style:italic">U</span> <span style="font-style:italic">D</span><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">U</span><sup>−1</sup> <span style="font-style:italic">P</span><sup>−1</sup> </td></tr>
</table><p>
Ensuite, on suppose
qu’on peut factoriser <span style="font-style:italic">U</span><sup>−1</sup><span style="font-style:italic">P</span><sup>−1</sup>=<span style="font-style:italic">L</span>Ũ sans permutations, donc
qu’on ne rencontre pas de pivot nul, et quitte à multiplier 
les vecteurs unitaires de <span style="font-style:italic">P</span><sup>−1</sup> par une constante complexe de module 1
on peut supposer que les pivots sont positifs donc que Ũ a
des coefficients positifs sur la diagonale, on a alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span><sup><span style="font-style:italic">k</span></sup> = <span style="font-style:italic">P</span> <span style="font-style:italic">U</span> <span style="font-style:italic">D</span><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">L</span> Ũ = <span style="font-style:italic">Q</span><sub>1</sub> ... <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span></sub> ...<span style="font-style:italic">R</span><sub>1</sub> </td></tr>
</table><p>
puis en multipliant par Ũ<sup>−1</sup> |<span style="font-style:italic">D</span>|<sup>−<span style="font-style:italic">k</span></sup>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span> <span style="font-style:italic">U</span> <span style="font-style:italic">D</span><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">L</span> |<span style="font-style:italic">D</span>|<sup>−<span style="font-style:italic">k</span></sup> =  <span style="font-style:italic">Q</span><sub>1</sub> ... <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span></sub> ...<span style="font-style:italic">R</span><sub>1</sub> Ũ<sup>−1</sup> |<span style="font-style:italic">D</span>|<sup>−<span style="font-style:italic">k</span></sup> </td></tr>
</table><p>
où <span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span></sub> ...<span style="font-style:italic">R</span><sub>1</sub> Ũ<sup>−1</sup> |<span style="font-style:italic">D</span>|<sup>−<span style="font-style:italic">k</span></sup> est triangulaire supérieure à coefficients positifs
sur la diagonale et <span style="font-style:italic">Q</span><sub>1</sub> ... <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> est unitaire. On regarde ensuite les entrées 
de la matrice <span style="font-style:italic">D</span><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">L</span> |<span style="font-style:italic">D</span>|<sup>−<span style="font-style:italic">k</span></sup>, sous la diagonale elles convergent (géométriquement) vers 0,
donc <span style="font-style:italic">UD</span><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">L</span> |<span style="font-style:italic">D</span>|<sup>−<span style="font-style:italic">k</span></sup> tend vers une matrice triangulaire supérieure
dont les coefficients diagonaux valent <span style="font-style:italic">e</span><sup><span style="font-style:italic">i</span> <span style="font-style:italic">k</span>arg(λ<sub><span style="font-style:italic">j</span></sub>)</sup>. On montre que cela
entraine que <span style="font-style:italic">Q</span><sub>1</sub> ... <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub>  est équivalent à <span style="font-style:italic">P</span>(<span style="font-style:italic">D</span>/|<span style="font-style:italic">D</span>|)<sup><span style="font-style:italic">k</span></sup>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Q</span><sub>1</sub> ... <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> ≈ <span style="font-style:italic">P</span> (<span style="font-style:italic">D</span>/|<span style="font-style:italic">D</span>|)<sup><span style="font-style:italic">k</span></sup>,     
<span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span></sub> ...<span style="font-style:italic">R</span><sub>1</sub> Ũ<sup>−1</sup> |<span style="font-style:italic">D</span>|<sup>−<span style="font-style:italic">k</span></sup> ≈ (<span style="font-style:italic">D</span>/|<span style="font-style:italic">D</span>|)<sup>−<span style="font-style:italic">k</span></sup> <span style="font-style:italic">UD</span><sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">L</span> |<span style="font-style:italic">D</span>|<sup>−<span style="font-style:italic">k</span></sup> </td></tr>
</table><p>
Donc, <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> tend à devenir diagonale, et <span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>+1</sub> triangulaire supérieure. De plus
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>=<span style="font-style:italic">Q</span><sub>1</sub> <span style="font-style:italic">A</span><sub>2</sub> <span style="font-style:italic">Q</span><sub>1</sub><sup>−1</sup> = ... = <span style="font-style:italic">Q</span><sub>1</sub> ... <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>+1</sub> (<span style="font-style:italic">Q</span><sub>1</sub> ... <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub>)<sup>−1</sup> </td></tr>
</table><p>
la matrice <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>+1</sub> est donc semblable à <span style="font-style:italic">A</span>.</p><p>En pratique, on n’impose pas la positivité des coefficients diagonaux de <span style="font-style:italic">R</span>
dans la factorisation <span style="font-style:italic">QR</span>, ce qui ne change
évidemment pas le fait que <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> s’approche d’une matrice diagonale et <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub> d’une matrice
triangulaire supérieure (avec convergence à vitesse géométrique).
On commence aussi par mettre la matrice <span style="font-style:italic">A</span> sous forme de Hessenberg
(par conjugaison par des matrices de Householder),
c’est-à-dire presque triangulaire supérieure (on autorise des
coefficients non nuls dans la partie inférieure seulement sur la sous-diagonale, 
<span style="font-style:italic">a</span><sub><span style="font-style:italic">ij</span></sub>=0 si <span style="font-style:italic">i</span>&gt;<span style="font-style:italic">j</span>+1). Cela réduit considérablement le temps de calcul de la
décomposition <span style="font-style:italic">QR</span>, le produit <span style="font-style:italic">RQ</span> ayant encore cette
propriété, une itération se fait en temps <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>2</sup>) au lieu de
<span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>3</sup>). Le calcul de <span style="font-style:italic">RQ</span> à partir de <span style="font-style:italic">A</span> est d’ailleurs fait directement,
on parle d’itération <span style="font-style:italic">QR</span> implicite.</p><p>On utilise aussi des “shifts” pour accélerer la convergence, c’est-à-dire qu’au lieu
de faire <span style="font-style:italic">QR</span> et <span style="font-style:italic">RQ</span> sur la matrice <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub> on le fait sur <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub> − α<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">I</span> où
λ<sub><span style="font-style:italic">k</span></sub> est choisi pour accélerer la convergence vers 0 du coefficient d’indice
ligne <span style="font-style:italic">n</span> colonne <span style="font-style:italic">n</span>−1 (idéalement il faut prendre α<sub><span style="font-style:italic">k</span></sub> proche de λ<sub><span style="font-style:italic">n</span></sub> la
valeur propre de module minimal, afin de minimiser 
|λ<sub><span style="font-style:italic">n</span></sub>−α<sub><span style="font-style:italic">k</span></sub>|/|λ<sub><span style="font-style:italic">n</span>−1</sub>−α<sub><span style="font-style:italic">k</span></sub>|). 
En effet, si <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub> − λ<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">I</span> = <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span></sub> et <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span>+1</sub>=<span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub>+λ<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">I</span> alors :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > (<span style="font-style:italic">A</span>−α<sub>1</sub> <span style="font-style:italic">I</span>) ... (<span style="font-style:italic">A</span>−α<sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">I</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Q</span><sub>1</sub><span style="font-style:italic">R</span><sub>1</sub>(<span style="font-style:italic">Q</span><sub>1</sub><span style="font-style:italic">R</span><sub>1</sub>−(α<sub>2</sub>−α<sub>1</sub>)<span style="font-style:italic">I</span>) ...(<span style="font-style:italic">Q</span><sub>1</sub><span style="font-style:italic">R</span><sub>1</sub>−(α<sub><span style="font-style:italic">k</span></sub>−α<sub>1</sub>)<span style="font-style:italic">I</span>)
</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Q</span><sub>1</sub> (<span style="font-style:italic">R</span><sub>1</sub><span style="font-style:italic">Q</span><sub>1</sub> − (α<sub>2</sub>−α<sub>1</sub>)<span style="font-style:italic">I</span>)<span style="font-style:italic">R</span><sub>1</sub> 
(<span style="font-style:italic">Q</span><sub>1</sub><span style="font-style:italic">R</span><sub>1</sub>−(α<sub>3</sub>−α<sub>1</sub>)<span style="font-style:italic">I</span>) ...(<span style="font-style:italic">Q</span><sub>1</sub><span style="font-style:italic">R</span><sub>1</sub>−(α<sub><span style="font-style:italic">k</span></sub>−α<sub>1</sub>)<span style="font-style:italic">I</span>)
</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Q</span><sub>1</sub> (<span style="font-style:italic">A</span><sub>2</sub> − α<sub>1</sub> <span style="font-style:italic">I</span> −(α<sub>2</sub>−α<sub>1</sub>)<span style="font-style:italic">I</span>) <span style="font-style:italic">R</span><sub>1</sub> 
<span style="font-style:italic">Q</span><sub>1</sub>(<span style="font-style:italic">R</span><sub>1</sub><span style="font-style:italic">Q</span><sub>1</sub>−(α<sub>3</sub>−α<sub>1</sub>)<span style="font-style:italic">I</span>) <span style="font-style:italic">R</span><sub>1</sub>...(<span style="font-style:italic">Q</span><sub>1</sub><span style="font-style:italic">R</span><sub>1</sub>−(α<sub><span style="font-style:italic">k</span></sub>−α<sub>1</sub>)<span style="font-style:italic">I</span>)
</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Q</span><sub>1</sub> (<span style="font-style:italic">A</span><sub>2</sub> − α<sub>2</sub> <span style="font-style:italic">I</span>) (<span style="font-style:italic">A</span><sub>2</sub> − α<sub>3</sub> <span style="font-style:italic">I</span>) ... (<span style="font-style:italic">A</span><sub>2</sub> − α<sub><span style="font-style:italic">k</span></sub><span style="font-style:italic">I</span>) <span style="font-style:italic">R</span><sub>1</sub>
</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >...
</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Q</span><sub>1</sub> ... <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span></sub> ...<span style="font-style:italic">R</span><sub>1</sub>
</td></tr>
</table></td></tr>
</table><p>
On peut aussi éliminer la dernière
ligne et la dernière colonne de la matrice pour accélerer les calculs dès que le coefficient
en ligne <span style="font-style:italic">n</span> colonne <span style="font-style:italic">n</span>−1 est suffisamment petit.</p><p>On remarque que pour une matrice réelle si on choisit des shifts conjugués,
alors <span style="font-style:italic">Q</span><sub>1</sub>...<span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span></sub>...<span style="font-style:italic">R</span><sub>1</sub> est réel. Or si <span style="font-style:italic">QR</span>=<span style="text-decoration:overline"><span style="font-style:italic">Q</span></span><span style="text-decoration:overline"><span style="font-style:italic">R</span></span>
et si <span style="font-style:italic">R</span> est inversible
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">Q</span></td></tr>
</table></td><td class="dcell"><sup>−1</sup> <span style="font-style:italic">Q</span> = </td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">R</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">R</span><sup>−1</sup> </td></tr>
</table><p>
On a donc une matrice symétrique (car <span style="text-decoration:overline"><span style="font-style:italic">Q</span></span><sup>−1</sup>=<span style="font-style:italic">Q</span><sup><span style="font-style:italic">t</span></sup>) 
et triangulaire supérieure. On en déduit que
<span style="text-decoration:overline"><span style="font-style:italic">Q</span></span><sup>−1</sup> <span style="font-style:italic">Q</span>=<span style="font-style:italic">D</span> est diagonale, donc <span style="font-style:italic">Q</span>=<span style="text-decoration:overline"><span style="font-style:italic">Q</span></span> <span style="font-style:italic">D</span>. On peut
donc rendre <span style="font-style:italic">Q</span> réelle en divisant chaque colonne par un <span style="font-style:italic">e</span><sup><span style="font-style:italic">i</span>θ</sup>, et
rendre <span style="font-style:italic">R</span> réelle en conjuguant par la matrice <span style="font-style:italic">D</span>.
Mais ce procédé de retour au réel après élimination de 2 valeurs propres
complexes conjuguées d’une matrice réelle
se heurte à un problème de conditionnement parce que le choix d’un shift
intéressant pour la convergence va rendre la matrice <span style="font-style:italic">R</span> proche d’une matrice non
inversible (les deux derniers coefficients diagonaux de <span style="font-style:italic">R</span> sont proches de 0).
On a alors seulement
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">Q</span></td></tr>
</table></td><td class="dcell"><sup>−1</sup> <span style="font-style:italic">Q</span> <span style="font-style:italic">R</span> = </td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">R</span></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Si on décompose <span style="text-decoration:overline"><span style="font-style:italic">Q</span></span><sup>−1</sup> <span style="font-style:italic">Q</span>, <span style="font-style:italic">R</span>, <span style="text-decoration:overline"><span style="font-style:italic">R</span></span> par blocs 
<span style="font-style:italic">n</span>−2,<span style="font-style:italic">n</span>−2, <span style="font-style:italic">n</span>−2,2, 2,<span style="font-style:italic">n</span>−2 et 2,2, on a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">QQ</span><sub>11</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">QQ</span><sub>12</sub> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">QQ</span><sub>21</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">QQ</span><sub>22</sub> 
</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell">
</td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">R</span><sub>11</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">R</span><sub>12</sub> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">R</span><sub>22</sub> 
</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎠</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">QQ</span><sub>11</sub> <span style="font-style:italic">R</span><sub>11</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">QQ</span><sub>21</sub><span style="font-style:italic">R</span><sub>11</sub> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">QQ</span><sub>11</sub> <span style="font-style:italic">R</span><sub>12</sub> + <span style="font-style:italic">QQ</span><sub>12</sub> <span style="font-style:italic">R</span><sub>22</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">QQ</span><sub>21</sub> <span style="font-style:italic">R</span><sub>12</sub> + <span style="font-style:italic">QQ</span><sub>22</sub> <span style="font-style:italic">R</span><sub>22</sub> 
</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">R</span></td></tr>
</table></td><td class="dcell"><sub>11</sub></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">R</span></td></tr>
</table></td><td class="dcell"><sub>12</sub> </td></tr>
</table></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">R</span></td></tr>
</table></td><td class="dcell"><sub>22</sub> 
</td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Donc on a <span style="font-style:italic">QQ</span><sub>11</sub> =<span style="text-decoration:overline"><span style="font-style:italic">R</span></span><sub>11</sub> <span style="font-style:italic">R</span><sub>11</sub><sup>−1</sup>.
Comme <span style="font-style:italic">Q</span> est unitaire, <span style="font-style:italic">QQ</span>=<span style="text-decoration:overline"><span style="font-style:italic">Q</span></span><sup>−1</sup> <span style="font-style:italic">Q</span>=<span style="font-style:italic">Q</span><sup><span style="font-style:italic">t</span></sup>   <span style="font-style:italic">Q</span> est symétrique, donc
<span style="font-style:italic">QQ</span><sub>11</sub> est diagonale puisque symétrique et triangulaire supérieure. On peut donc
ramener <span style="font-style:italic">Q</span><sub>11</sub> et <span style="font-style:italic">R</span><sub>11</sub> en des matrices réelles.
L’algorihtme des itérations <span style="font-style:italic">QR</span> implicites traite de manière
efficace le cas des
couples de valeurs propres complexes conjuguées ou plus
généralement de clusters de valeurs propres, c’est l’algorithme
de Francis (aussi appelé <em>bulge chasing</em> en anglais, qu’on
pourrait traduire par “à la poursuite du bourrelet”, cela vient
de la forme que prend la matrice après application d’un shift,
elle a des entrées non nulles en première colonne plus bas
que la sous-diagonale qui forment un bourrelet non nul, 
l’annulation de ces entrées par des transformations de Householder
déplace le bourrelet sur la colonne suivante).</p><p>Revenons à la localisation des valeurs propres 
On suppose qu’on a maintenant une matrice
unitaire <span style="font-style:italic">P</span> et une matrice triangulaire supérieure <span style="font-style:italic">S</span>
(aux erreurs d’arrondi près) telles que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sup>−1</sup> <span style="font-style:italic">A</span> <span style="font-style:italic">P</span> = <span style="font-style:italic">S</span> </td></tr>
</table><p>
Que peut-on en déduire ?
<sup><a id="text33" href="#note33">33</a></sup>
On va d’abord arrondir <span style="font-style:italic">P</span> en une matrice exacte à coefficients rationnels, dont les dénominateurs
sont une puissance de 2 (en fait c’est exactement ce que donne l’écriture d’un flottant
en base 2, une fois ramené tous les exposants à la même valeur). On a donc une matrice
<span style="font-style:italic">P</span><sub><span style="font-style:italic">e</span></sub> presque unitaire exacte et telle que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">S</span><sub><span style="font-style:italic">e</span></sub> = <span style="font-style:italic">P</span><sub><span style="font-style:italic">e</span></sub><sup>−1</sup> <span style="font-style:italic">A</span> <span style="font-style:italic">P</span><sub><span style="font-style:italic">e</span></sub>  </td></tr>
</table><p>
est semblable à <span style="font-style:italic">A</span>, et presque triangulaire supérieure.
(comme <span style="font-style:italic">P</span><sub><span style="font-style:italic">e</span></sub> est presque unitaire, sa norme et la norme de son inverse
sont proches de 1 donc <span style="font-style:italic">S</span><sub><span style="font-style:italic">e</span></sub> est proche de <span style="font-style:italic">S</span>, les coefficients de <span style="font-style:italic">S</span><sub><span style="font-style:italic">e</span></sub>
sont de la même taille que les coefficients de <span style="font-style:italic">A</span> : le changement de base est bien
conditionné et c’est la raison pour laquelle on a choisi d’effectuer des 
transformations unitaires). </p><p>Notons µ<sub>1</sub>, ..., µ<sub><span style="font-style:italic">n</span></sub> les coefficients
diagonaux de <span style="font-style:italic">S</span><sub><span style="font-style:italic">e</span></sub>, soit ε un majorant de la norme des coefficients
sous-diagonaux de <span style="font-style:italic">S</span><sub><span style="font-style:italic">e</span></sub>, et soit δ un minorant de l’écart entre 2 µ<sub><span style="font-style:italic">j</span></sub> distincts.
On a donc <span style="font-style:italic">S</span><sub><span style="font-style:italic">e</span></sub>=<span style="font-style:italic">U</span>+<span style="font-style:italic">E</span> où <span style="font-style:italic">U</span> est triangulaire supérieure, <span style="font-style:italic">E</span> est triangulaire inférieure
avec des 0 sous la diagonale et des coefficients de module majorés par ε.
Si ε est suffisamment petit devant δ, on va montrer qu’on peut
localiser les valeurs propres de <span style="font-style:italic">S</span><sub><span style="font-style:italic">e</span></sub> (qui sont celles de <span style="font-style:italic">A</span>) au moyen des µ<sub><span style="font-style:italic">j</span></sub>.</p><p>En effet, fixons <span style="font-style:italic">j</span> et soit <span style="font-style:italic">C</span> un cercle de centre µ=µ<sub><span style="font-style:italic">j</span></sub> et de rayon 
α ≤ δ/2. 
Si <span style="font-style:italic">A</span> est une matrice diagonalisable, on sait que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">nombre de valeurs propres ∈ <span style="font-style:italic">C</span> =  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">i</span>π</td></tr>
</table></td><td class="dcell">  trace </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">C</span></td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">A</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup> </td></tr>
</table><p>
En prenant <span style="font-style:italic">A</span>=<span style="font-style:italic">S</span><sub><span style="font-style:italic">e</span></sub>, et en écrivant
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">S</span><sub><span style="font-style:italic">e</span></sub>−<span style="font-style:italic">zI</span>)<sup>−1</sup> = (<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>+<span style="font-style:italic">E</span>)<sup>−1</sup> = ( <span style="font-style:italic">I</span> + (<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup><span style="font-style:italic">E</span>)<sup>−1</sup>(<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup>  </td></tr>
</table><p>
on développe le second terme si la norme de (<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup><span style="font-style:italic">E</span> est strictement inférieure à 1
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">S</span><sub><span style="font-style:italic">e</span></sub>−<span style="font-style:italic">zI</span>)<sup>−1</sup> = (<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup> −(<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup><span style="font-style:italic">E</span>(<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup> + (<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup><span style="font-style:italic">E</span>(<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup><span style="font-style:italic">E</span>(<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup> + ...</td></tr>
</table><p>
puis on calcule la trace
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">trace(<span style="font-style:italic">S</span><sub><span style="font-style:italic">e</span></sub>−<span style="font-style:italic">zI</span>)<sup>−1</sup> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> (µ<sub><span style="font-style:italic">j</span></sub>−<span style="font-style:italic">z</span>)<sup>−1</sup> + η </td></tr>
</table><p>
avec
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|η| ≤ 2π α || (<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup> || </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">|| (<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup><span style="font-style:italic">E</span> ||</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−|| (<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup><span style="font-style:italic">E</span> ||</td></tr>
</table></td></tr>
</table><p>
Au final, le nombre de valeurs propres dans <span style="font-style:italic">C</span> est donné par
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">1 + η,    |η| ≤ 
α max<sub><span style="font-style:italic">z</span> ∈ <span style="font-style:italic">C</span></sub> || (<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup> || </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">|| (<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup><span style="font-style:italic">E</span> ||</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−|| (<span style="font-style:italic">U</span>−<span style="font-style:italic">zI</span>)<sup>−1</sup><span style="font-style:italic">E</span> ||</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Il suffit donc que le max soit plus petit que 1 pour avoir l’existence d’une valeur
propre et une seule de <span style="font-style:italic">S</span><sub><span style="font-style:italic">e</span></sub> dans le cercle <span style="font-style:italic">C</span> (à distance au plus α de µ).
Ce sera le cas si
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ε ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">δ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2 ||<span style="font-style:italic">S</span><sub><span style="font-style:italic">e</span></sub>||</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">n</span>−1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">α</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span>−1</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
on choisit donc α pour réaliser l’égalité ci-dessus,
sous réserve que δ ne soit pas trop petit, rappelons que α doit être
plus petit ou égal à δ/2. Si δ est petit, il peut être nécessaire
d’utiliser une précision plus grande pour les calculs de la décomposition de Schur
en arithmétique flottante.</p><p>Typiquement, on peut espérer (pour un écart δ pas trop petit) pouvoir
localiser les racines d’un polynôme de degré <span style="font-style:italic">n</span> par cette méthode avec précision
<span style="font-style:italic">b</span> bits en <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>3</sup> <span style="font-style:italic">b</span><sup>2</sup> + <span style="font-style:italic">n</span><sup>2</sup> <span style="font-style:italic">b</span><sup>3</sup>) opérations pour le calcul de la décomposition
de Schur en flottant (<span style="font-style:italic">n</span><sup>3</sup><span style="font-style:italic">b</span><sup>2</sup> pour Hessenberg initial puis <span style="font-style:italic">n</span><sup>2</sup><span style="font-style:italic">b</span><sup>2</sup> par itération
et un nombre d’itérations proportionnel à <span style="font-style:italic">b</span>). 
Pour le calcul exact de <span style="font-style:italic">S</span><sub><span style="font-style:italic">e</span></sub>, il faut inverser une matrice
de taille <span style="font-style:italic">n</span> avec des coefficients de taille proportionnelle à <span style="font-style:italic">b</span> donc <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>4</sup><span style="font-style:italic">b</span>ln(<span style="font-style:italic">n</span>))
opérations (en modulaire, la taille des coefficients de l’inverse est <span style="font-style:italic">O</span>(<span style="font-style:italic">nb</span> ln(<span style="font-style:italic">n</span>)))
puis calculer un produit avec une matrice <span style="font-style:italic">n</span>,<span style="font-style:italic">n</span> de coefficients de taille
proportionnelle à <span style="font-style:italic">b</span>, soit <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span><sup>4</sup><span style="font-style:italic">b</span><sup>2</sup>ln(<span style="font-style:italic">nb</span>)) opérations. Asymptotiquement,
on peut faire mieux avec des méthodes de multiplication et d’opérations matricielles
par blocs. Pour éviter la perte d’un facteur <span style="font-style:italic">n</span>, 
on peut aussi ne pas faire de calculs en mode exact et controler
les erreurs sur la matrice <span style="font-style:italic">S</span>.
On peut regrouper les valeurs propres par “clusters” si elles sont trop
proches à la précision de <span style="font-style:italic">b</span> bits. Pour la recherche des racines
d’un polynôme <span style="font-style:italic">P</span>, on peut montrer, en calculant le résultant de <span style="font-style:italic">P</span>
et de <span style="font-style:italic">P</span>′ qui est en module plus grand ou égal à 1, et en l’écrivant
comme produit des carrés de différences des racines, et en majorant toutes
les différences de racine sauf une à l’aide de la norme infinie
de <span style="font-style:italic">P</span>, qu’il faut au pire <span style="font-style:italic">b</span>=<span style="font-style:italic">O</span>(<span style="font-style:italic">n</span>) bits pour séparer les racines).</p>
<!--TOC subsection id="sec259" Quelques références-->
<h3 id="sec259" class="subsection">22.11  Quelques références</h3><!--SEC END --><p> <a id="sec:ref"></a></p><ul class="itemize"><li class="li-itemize">
Comme toujours on renvoie à l’excellent livre de Henri Cohen:
A Course in Computational Algebraic Number Theory</li><li class="li-itemize">Gantmacher: Théorie des matrices</li><li class="li-itemize">Press et al.: Numerical recipies in Fortran/C/Pascal.<br>
Pour des algorithmes numériques (sur les matrices et autres).</li></ul>
<!--TOC subsection id="sec260" Exercices (algèbre linéaire)-->
<h3 id="sec260" class="subsection">22.12  Exercices (algèbre linéaire)</h3><!--SEC END -->
<!--TOC subsubsection id="sec261" Instructions-->
<h4 id="sec261" class="subsubsection">22.12.1  Instructions</h4><!--SEC END --><ul class="itemize"><li class="li-itemize">
Les commandes d’algèbre linéaire de Xcas sont
regroupées dans le menu <span style="font-family:monospace">Cmds-&gt;Alglin</span>.
En maple V, la commande <span style="font-family:monospace">?linalg</span> affiche
la liste des commandes d’algèbre linéaire. 
</li><li class="li-itemize">En maple V il est conseillé d’exécuter <span style="font-family:monospace">with(linalg);</span>,
sinon il faut précéder
chaque commande de <span style="font-family:monospace">linalg::</span>.
Attention
il faut utiliser le caractère <span style="font-family:monospace">&amp;</span> avant la multiplication
et il faut souvent utiliser <span style="font-family:monospace">evalm</span> dans les programmes
utilisant des matrices et vecteurs. Notez aussi que les
matrices sont toujours passées par référence en maple V,
en Xcas le choix revient à l’utilisateur (affectation par <code>:=</code>
par valeur ou par <code>=&lt;</code> par référence)
</li><li class="li-itemize">Pour travailler avec des
coefficients modulaires, en Xcas
on fait suivre les coefficients ou matrices de <span style="font-family:monospace">% n</span>
(utiliser <code>% 0</code> pour enlever les modulos),
en maple V, on utilise les noms de commandes
avec une majuscule (forme inerte) suivi de <span style="font-family:monospace">mod n</span>.
</li></ul>
<!--TOC subsubsection id="sec262" Exercices-->
<h4 id="sec262" class="subsubsection">22.12.2  Exercices</h4><!--SEC END --><ol class="enumerate" type=1><li class="li-enumerate">
En utilisant un logiciel de calcul formel,
comparez le temps de calcul d’un déterminant de matrice
aléatoire à coefficients entiers de tailles 50 et 100, 
d’une matrice de taille 6 et 12 avec comme coefficients symboliques
ligne <span style="font-style:italic">j</span> colonne <span style="font-style:italic">k</span>, <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span>+<span style="font-style:italic">k</span></sub> lorsque <span style="font-style:italic">j</span>+<span style="font-style:italic">k</span> est pair
et 0 sinon. Peut-on en déduire une indication sur l’algorithme
utilisé?
</li><li class="li-enumerate">Écrire un programme calculant la borne de Hadamard d’un
déterminant à coefficients réels (rappel : c’est la borne obtenue en faisant
le produit des normes euclidiennes des vecteurs colonnes).
</li><li class="li-enumerate">Créez une matrice 4x4 aléatoire avec des coefficients entiers
compris entre -100 et 100, calculer la borne de Hadamard de son déterminant
avec le programme précédent, calculer ce déterminant modulo
quelques nombres premiers choisis en fonction de la borne de Hadamard
et vérifiez le résultat de la reconstruction modulaire du déterminant.
</li><li class="li-enumerate">Créez une matrice 100x100 aléatoire à coefficients entiers
et calculez son déterminant
modulo quelques nombres premiers. Dans quels cas peut-on
conclure que la matrice est inversible dans ℝ? dans ℤ?
</li><li class="li-enumerate">Écrire un programme calculant par interpolation de Lagrange
le polynôme caractéristique d’une matrice (en donnant à λ
de det(λ <span style="font-style:italic">I</span> −<span style="font-style:italic">A</span>), <span style="font-style:italic">n</span>+1 valeurs distinctes).
</li><li class="li-enumerate">(Long) Écrire un programme qui calcule un déterminant de matrice
en calculant les mineurs 2x2 puis 3x3 etc. (méthode de Laplace)
</li><li class="li-enumerate">Recherche du polynôme minimal. On prend un vecteur aléatoire
à coefficients entiers et on calcule <span style="font-style:italic">v</span>, <span style="font-style:italic">Av</span>, ..., <span style="font-style:italic">A</span><sup><span style="font-style:italic">n</span></sup><span style="font-style:italic">v</span> puis
on cherche une relation linéaire minimale entre ces vecteurs, en
calculant le noyau de la matrice ayant ces vecteurs colonnes. Si le
noyau est de dimension 1, alors le polynôme minimal est égal au
polynome caractéristique et correspond à un vecteur de la base du noyau.
Sinon, il faut choisir un vecteur du noyau correspondant au degré
le plus petit possible puis faire le PPCM avec les polynomes obtenus
avec d’autres vecteurs pour obtenir le polynôme minimal avec une grande
probabilité.
Essayez avec la matrice <span style="font-style:italic">A</span> de taille 3 ayant des 0 sur la diagonale et 
des 1 ailleurs.
Écrire un programme mettant en oeuvre cette recherche, testez-le avec
une matrice aléatoire de taille 30.
</li><li class="li-enumerate">Testez l’algorithme méthode de Fadeev pour la matrice <span style="font-style:italic">A</span> ci-dessus.
Même question pour 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>=</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > 3</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >2 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">,    
<span style="font-style:italic">A</span>=</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > 3</td><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >−2 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >−1</td><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >1 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >0 
</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table>
</li><li class="li-enumerate">Écrire un programme calculant par une méthode itérative
la valeur propre de module maximal d’une matrice à coefficients
complexes. Dans le cas réel, modifier le programme pour pouvoir
traiter le cas d’un couple de complexes conjugués de module maximal.
Dans le cas hermitien ou réel symétrique, éliminer le couple valeur
propre/vecteur propre et continuer la diagonalisation numérique.
</li><li class="li-enumerate">Soient |<span style="font-style:italic">a</span>|,|<span style="font-style:italic">b</span>|&lt;√<span style="text-decoration:overline"><span style="font-style:italic">n</span></span><span style="text-decoration:overline">/2</span>
Écrire une fonction ayant comme arguments <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span> (mod <span style="font-style:italic">n</span> ) 
qui calcule <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span>.<br>
Utiliser ce programme pour résoudre un système 4,4 à coefficients entiers
par une méthode <span style="font-style:italic">p</span>-adique.
</li></ol>
<!--TOC section id="sec263" Approximation polynomiale-->
<h2 id="sec263" class="section">23  Approximation polynomiale</h2><!--SEC END --><p> <a id="sec:interp"></a>
On présente dans cette section quelques méthodes d’approximation
de fonctions par des polynômes sur un intervalle, la section suivante 
présente des méthodes d’approximation près d’un point ou de l’infini.</p>
<!--TOC subsection id="sec264" Polynôme de Lagrange-->
<h3 id="sec264" class="subsection">23.1  Polynôme de Lagrange</h3><!--SEC END --><p><a id="hevea_default294"></a> <a id="hevea_default295"></a>
Étant donné la facilité de manipulation qu’apportent les
polynomes, on peut chercher à approcher une fonction par un
polynôme. La méthode la plus naturelle consiste à chercher
un polynôme de degré le plus petit possible
égal à la fonction en certains points <span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>
et à trouver une majoration de la différence entre la fonction
et le polynôme.
Le polynome interpolateur de Lagrange répond à cette question.</p>
<!--TOC subsubsection id="sec265" Existence et unicité-->
<h4 id="sec265" class="subsubsection">23.1.1  Existence et unicité</h4><!--SEC END --><p>
Soit donc <span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> des réels distincts et <span style="font-style:italic">y</span><sub>0</sub>,...,<span style="font-style:italic">y</span><sub><span style="font-style:italic">n</span></sub>
les valeurs de la fonction à approcher en ces points (on posera
<span style="font-style:italic">y</span><sub><span style="font-style:italic">j</span></sub>=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>) pour approcher la fonction <span style="font-style:italic">f</span>). On cherche
donc <span style="font-style:italic">P</span> tel que <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>)=<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub> pour <span style="font-style:italic">j</span> ∈ [0,<span style="font-style:italic">n</span>].</p><p>Commencons par voir s’il y a beaucoup de solutions. Soit <span style="font-style:italic">P</span> et <span style="font-style:italic">Q</span>
deux solutions distinctes du problème, alors <span style="font-style:italic">P</span>−<span style="font-style:italic">Q</span> est non nul
et va s’annuler en <span style="font-style:italic">x</span><sub>0</sub>, ...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> donc possède <span style="font-style:italic">n</span>+1 racines donc
est de degré <span style="font-style:italic">n</span>+1 au moins. Réciproquement, si on ajoute
à <span style="font-style:italic">P</span> un multiple du polynome <span style="font-style:italic">A</span>=∏<sub><span style="font-style:italic">j</span>=0</sub><sup><span style="font-style:italic">n</span></sup> (<span style="font-style:italic">X</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>), on obtient
une autre solution. Toutes les solutions se déduisent donc
d’une solution particulière en y ajoutant un polynome de degré
au moins <span style="font-style:italic">n</span>+1 multiple de <span style="font-style:italic">A</span>. </p><p>Nous allons maintenant construire
une solution particulière de degré au plus <span style="font-style:italic">n</span>.
Si <span style="font-style:italic">n</span>=0, on prend <span style="font-style:italic">P</span>=<span style="font-style:italic">x</span><sub>0</sub> constant. On procède ensuite par
récurrence. Pour construire le polynôme correspondant
à <span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub> on part du polynoôme <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> correspondant à
<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> et on lui ajoute un multiple réel de <span style="font-style:italic">A</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>+ α<sub><span style="font-style:italic">n</span>+1</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">X</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>) </td></tr>
</table><p>
Ainsi on a toujours <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>+1</sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>)=<span style="font-style:italic">y</span><sub><span style="font-style:italic">j</span></sub> pour <span style="font-style:italic">j</span>=0,..<span style="font-style:italic">n</span>, on calcule
maintenant  α<sub><span style="font-style:italic">n</span>+1</sub> pour que <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>+1</sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>)=<span style="font-style:italic">y</span><sub><span style="font-style:italic">n</span>+1</sub>.
En remplacant avec l’expression de <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>+1</sub> ci-dessus, on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>)+  α<sub><span style="font-style:italic">n</span>+1</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>) = <span style="font-style:italic">y</span><sub><span style="font-style:italic">n</span>+1</sub> </td></tr>
</table><p>
Comme tous les <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> sont distincts, il existe une solution unique :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">α<sub><span style="font-style:italic">n</span>+1</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>)</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>On a donc prouvé le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 54</span>  <em> </em><a id="hevea_default296"></a><em> </em><a id="hevea_default297"></a><em>
Soit </em><span style="font-style:italic">n</span>+1<em> réels distincts </em><span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub><em> et </em><span style="font-style:italic">n</span>+1<em>
réels quelconques </em><span style="font-style:italic">y</span><sub>0</sub>,...,<span style="font-style:italic">y</span><sub><span style="font-style:italic">n</span></sub><em>.
Il existe un unique polynôme </em><span style="font-style:italic">P</span><em> de degré inférieur ou égal à
</em><span style="font-style:italic">n</span><em>, appelé polynome de Lagrange, tel que :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)=<span style="font-style:italic">y</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table><em>
</em></div><p>Exemple : déterminons le polynome de degré inférieur ou égal
à 2 tel que <span style="font-style:italic">P</span>(0)=1, <span style="font-style:italic">P</span>(1)=2, <span style="font-style:italic">P</span>(2)=1. On commence par <span style="font-style:italic">P</span><sub>0</sub>=1.
Puis on pose <span style="font-style:italic">P</span><sub>1</sub>=<span style="font-style:italic">P</span><sub>0</sub>+ α<sub>1</sub><span style="font-style:italic">X</span>=1+ α<sub>1</sub><span style="font-style:italic">X</span>. 
Comme <span style="font-style:italic">P</span>(1)=2=1+ α<sub>1</sub> on en tire  α<sub>1</sub>=1
donc <span style="font-style:italic">P</span><sub>1</sub>=1+<span style="font-style:italic">X</span>. Puis on pose <span style="font-style:italic">P</span><sub>2</sub>=<span style="font-style:italic">P</span><sub>1</sub>+ α<sub>2</sub><span style="font-style:italic">X</span>(<span style="font-style:italic">X</span>−1), on a 
<span style="font-style:italic">P</span><sub>2</sub>(2)=3+2 α<sub>2</sub>=1
donc  α<sub>2</sub>=−1, finalement <span style="font-style:italic">P</span><sub>2</sub>=1+<span style="font-style:italic">X</span>−<span style="font-style:italic">X</span>(<span style="font-style:italic">X</span>−1).<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">P:=interp([0,1,2],[1,2,1]); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p>
<!--TOC subsubsection id="sec266" Majoration de l’erreur d’interpolation.-->
<h4 id="sec266" class="subsubsection">23.1.2  Majoration de l’erreur d’interpolation.</h4><!--SEC END --><p>
Reste à estimer l’écart entre une fonction et son polynome
interpolateur, on a le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 55</span>  <em> </em><a id="hevea_default298"></a><em>
Soit </em><span style="font-style:italic">f</span><em> une fonction </em><span style="font-style:italic">n</span>+1<em> fois dérivable sur un intervalle </em><span style="font-style:italic">I</span>=[<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>]<em>
de </em>ℝ<em>, </em><span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub><em> des réels distincts de </em><span style="font-style:italic">I</span><em>. 
Soit </em><span style="font-style:italic">P</span><em> le polynome de Lagrange donné par les </em><span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub><em> et </em><span style="font-style:italic">y</span><sub><span style="font-style:italic">j</span></sub>=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>)<em>.
Pour tout réel </em><span style="font-style:italic">x</span> ∈ <span style="font-style:italic">I</span><em>,
il existe un réel </em>ξ<sub><span style="font-style:italic">x</span></sub> ∈ [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>]<em> (qui dépend de </em><span style="font-style:italic">x</span><em>) tel
que :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:lagrange"></a>
<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)−<span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>) = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(ξ<sub><span style="font-style:italic">x</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td><td class="dcell"><em> </em></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><em><em><span style="font-style:italic">n</span></em></em></td></tr>
<tr><td class="dcell" style="text-align:center"><em><span style="font-size:xx-large">∏</span></em></td></tr>
<tr><td class="dcell" style="text-align:center"><em><em><span style="font-style:italic">j</span></em><em>=0</em></em></td></tr>
</table></td><td class="dcell"><em>(</em><em><span style="font-style:italic">x</span></em><em>−</em><em><span style="font-style:italic">x</span></em><sub><em><span style="font-style:italic">j</span></em></sub><em>) 
    (56)</em></td></tr>
</table><em>
</em></div><p>
Ainsi l’erreur commise dépend d’une majoration de la taille
de la dérivée <span style="font-style:italic">n</span>+1-ième sur l’intervalle, mais aussi
de la disposition des points <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> par rapport à <span style="font-style:italic">x</span>. Par exemple
si les points <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> sont équidistribués, le terme
|∏<sub><span style="font-style:italic">j</span>=0</sub><sup><span style="font-style:italic">n</span></sup>(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>)| sera plus grand près du bord de <span style="font-style:italic">I</span> qu’au
centre de <span style="font-style:italic">I</span>.</p><p>Preuve du théorème : Si <span style="font-style:italic">x</span> est l’un des <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> l’égalité est vraie. Soit 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">C</span>=(<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)−<span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>))/</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>) </td></tr>
</table><p>
on considère maintenant la fonction :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">g</span>(<span style="font-style:italic">t</span>)=<span style="font-style:italic">f</span>(<span style="font-style:italic">t</span>)−<span style="font-style:italic">P</span>(<span style="font-style:italic">t</span>) − <span style="font-style:italic">C</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">t</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>) </td></tr>
</table><p>
elle s’annule en <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> pour <span style="font-style:italic">j</span> variant de 0 à <span style="font-style:italic">n</span> ainsi qu’en <span style="font-style:italic">x</span>
suite au choix de la constante <span style="font-style:italic">C</span>, donc <span style="font-style:italic">g</span> s’annule au moins <span style="font-style:italic">n</span>+2 fois
sur l’intervalle contenant les <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> et <span style="font-style:italic">x</span>, donc <span style="font-style:italic">g</span>′ s’annule au moins
<span style="font-style:italic">n</span>+1 fois sur ce même intervalle, donc <span style="font-style:italic">g</span>′′ s’annule au moins
<span style="font-style:italic">n</span> fois, etc. et finalement <span style="font-style:italic">g</span><sup>[<span style="font-style:italic">n</span>+1]</sup> s’annule une fois
au moins sur cet intervalle. Or 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">g</span><sup>[<span style="font-style:italic">n</span>+1]</sup> = <span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup> − <span style="font-style:italic">C</span> (<span style="font-style:italic">n</span>+1)!</td></tr>
</table><p>
car <span style="font-style:italic">P</span> est de degré inférieur ou égal à <span style="font-style:italic">n</span> 
et  ∏<sub><span style="font-style:italic">j</span>=0</sub><sup><span style="font-style:italic">n</span></sup>(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>) − <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup> est de degré
inférieur ou égal à <span style="font-style:italic">n</span>. Donc il existe bien un réel ξ<sub><span style="font-style:italic">x</span></sub> dans
l’intervalle contenant les <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> et <span style="font-style:italic">x</span> tel que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">C</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(ξ<sub><span style="font-style:italic">x</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">f(x):=ln(x^2+1); n:=10; X:=evalf(seq(j/n,j,0,n)); Y:=map(X,f); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">P:=interp(X,Y); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plot([f(x),P],x=-1..2,color=[red,blue])
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">plot(1e7*abs(f(x)-P),x=0..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>Attention, l’erreur d’interpolation peut devenir très grande
lorsqu’on utilise beaucoup de points d’interpolation.</p>
<!--TOC subsubsection id="sec267" Calcul efficace du polynôme de
Lagrange.-->
<h4 id="sec267" class="subsubsection">23.1.3  Calcul efficace du polynôme de
Lagrange.</h4><!--SEC END --><p><a id="hevea_default299"></a><a id="hevea_default300"></a>
Avec la méthode de calcul précédent, on remarque que le
polynôme de Lagrange peut s’écrire à la Horner sous la forme :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >α<sub>0</sub> + α<sub>1</sub> (<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>) + ... + α<sub><span style="font-style:italic">n</span></sub>
(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)...(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >α<sub>0</sub> + (<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)( α<sub>1</sub> + (<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>1</sub>)(α<sub>2</sub> +  ... +
(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−2</sub>)(α<sub><span style="font-style:italic">n</span>−1</sub>+(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>) α<sub><span style="font-style:italic">n</span></sub>)...))
</td></tr>
</table></td></tr>
</table><p>
ce qui permet de le calculer rapidement une fois les α<sub><span style="font-style:italic">i</span></sub>
connus.
On observe que 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">α<sub>0</sub>=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>0</sub>),    α<sub>1</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>1</sub>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>0</sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub>1</sub>−<span style="font-style:italic">x</span><sub>0</sub></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
On va voir que les α<sub><span style="font-style:italic">k</span></sub> peuvent aussi se mettre sous forme
d’une différence.
On définit les différences divisées d’ordre <span style="font-style:italic">n</span> par récurrence
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>]=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>),    <span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+<span style="font-style:italic">i</span>+1</sub>]=
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span>+1</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+<span style="font-style:italic">i</span>+1</sub>]−<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+<span style="font-style:italic">i</span></sub>]</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+<span style="font-style:italic">i</span>+1</sub>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
On va montrer que α<sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>].
C’est vrai au rang 0, il suffit donc de le montrer au rang <span style="font-style:italic">k</span>+1 en
l’admettant au rang <span style="font-style:italic">k</span>. Pour cela on observe qu’on peut construire 
le polynôme d’interpolation en <span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+1</sub> à partir des polynômes 
d’interpolation <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> en <span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub> et <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> en <span style="font-style:italic">x</span><sub>1</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+1</sub> 
par la formule :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span>+1</sub>(<span style="font-style:italic">x</span>)= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+1</sub>−<span style="font-style:italic">x</span>)<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> + (<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)<span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+1</sub>−<span style="font-style:italic">x</span><sub>0</sub></td></tr>
</table></td></tr>
</table><p>
en effet on vérifie que <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span>+1</sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>) pour <span style="font-style:italic">i</span>∈ [1,<span style="font-style:italic">k</span>] car
<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)=<span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>),
et pour <span style="font-style:italic">i</span>=0 et <span style="font-style:italic">i</span>=<span style="font-style:italic">k</span>+1, on a aussi <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span>+1</sub>(<span style="font-style:italic">x</span><sub>0</sub>)=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>0</sub>) et 
<span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span>+1</sub>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+1</sub>)=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+1</sub>).
Or α<sub><span style="font-style:italic">k</span>+1</sub> est le coefficient dominant de <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span>+1</sub> donc
c’est la différence du coefficient dominant de <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> et de <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub>
divisée par <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+1</sub>−<span style="font-style:italic">x</span><sub>0</sub>, c’est-à-dire la définition de 
<span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+1</sub>] en fonction de <span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>1</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span>+1</sub>] et <span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>].</p><p>Exemple : on reprend <span style="font-style:italic">P</span>(0)=1, <span style="font-style:italic">P</span>(1)=2, <span style="font-style:italic">P</span>(2)=1. On a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>]</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>,<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span>+1</sub>]</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,<span style="font-style:italic">x</span><sub>1</sub>,<span style="font-style:italic">x</span><sub>2</sub>] </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" ><table class="boxed"><tr><td>1</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">(2−1)/(1−0)=</td><td class="dcell"><table class="boxed"><tr><td>1</td></tr>
</table></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">(−1−1)/(2−0)=</td><td class="dcell"><table class="boxed"><tr><td>-1</td></tr>
</table></td><td class="dcell">   </td></tr>
</table></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >(1−2)/(2−1)=−1</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table><p>
donc <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)=<span class="textboxed">1</span>+(<span style="font-style:italic">x</span>−0)(<span class="textboxed">1</span>+(<span style="font-style:italic">x</span>−1)(<span class="textboxed">−1</span>))=1+<span style="font-style:italic">x</span>(2−<span style="font-style:italic">x</span>).</p><p>On peut naturellement utiliser l’ordre que l’on souhaite pour les
<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>, en observant que le coefficient dominant de <span style="font-style:italic">P</span> ne dépend pas de
cet ordre, on en déduit que <span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>] est indépendant de
l’ordre des <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>, on peut donc à partir du tableau ci-dessus
écrire <span style="font-style:italic">P</span> par exemple avec l’ordre 2,1,0, sous la forme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)=1+(<span style="font-style:italic">x</span>−2)(−1+(<span style="font-style:italic">x</span>−1)(−1))=1+(<span style="font-style:italic">x</span>−2)(−<span style="font-style:italic">x</span>)</td></tr>
</table><p>Le nombre d’opérations nécessaires pour faire ce calcul est
proportionnel à <span style="font-style:italic">n</span><sup>2</sup>.</p><p>La commande Xcas <code>interp</code> ou son synonyme <code>lagrange</code>
effectue ce calcul. Pour avoir les différences divisées, 
on peut créer le programme suivant :

</p><pre class="verbatim">dd(X,Y):={ // Algorithme des différences divisées
  local k,l,n,A,old,cur;
  si size(X)!=size(Y) alors return "erreur" fsi;
  n:=size(X)-1;
  A:=[Y[0]];
  old:=Y;
  pour k de 1 jusque n faire
    // calcul de cur en fonction de old
    cur:=[];
    pour l de 0 jusque n-k faire
      cur[l]:=(old[l+1]-old[l])/(X[l+k]-X[l])
    fpour;
    A[k]:=cur[0];
    old:=cur;
  fpour;
  retourne A;
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;t.value=tmp;tmp=UI.caseval(tmp);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML);field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>


<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">dd([0,1,2],[1,2,1])
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

(N.B. pour rendre ce programme optimal, il faudrait utiliser
l’affectation en place <code>=&lt;</code> au lieu de <code>:=</code>)</p>
<!--TOC subsubsection id="sec268" Sensibilité aux erreurs sur les données.-->
<h4 id="sec268" class="subsubsection">23.1.4  Sensibilité aux erreurs sur les données.</h4><!--SEC END --><p>
Si les <span style="font-style:italic">y</span><sub><span style="font-style:italic">j</span></sub> sont connus avec une certaine erreur, alors le polynôme 
d’interpolation est connu de manière approchée. Plus
précisément, si on note
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">π<sub><span style="font-style:italic">j</span></sub>(<span style="font-style:italic">x</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span> ≠ <span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table></td></tr>
</table><p>
le <span style="font-style:italic">j</span>-ième polynome de Lagrange valant 1 en <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> et 0 ailleurs,
l’erreur vaut :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> (ỹ<sub><span style="font-style:italic">j</span></sub>−<span style="font-style:italic">y</span><sub><span style="font-style:italic">j</span></sub>) π<sub><span style="font-style:italic">j</span></sub>(<span style="font-style:italic">x</span>) </td></tr>
</table><p>
Si l’erreur relative sur les <span style="font-style:italic">y</span><sub><span style="font-style:italic">j</span></sub> est majorée par є,
l’erreur sur le polynôme d’interpolation est majorée par :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">є   max<sub><span style="font-style:italic">j</span></sub>|<span style="font-style:italic">y</span><sub><span style="font-style:italic">j</span></sub>| </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span></td></tr>
</table></td><td class="dcell"> |π<sub><span style="font-style:italic">j</span></sub>(<span style="font-style:italic">x</span>)| </td></tr>
</table><p>
il y a amplification de l’erreur par un facteur majoré par 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">max<sub><span style="font-style:italic">x</span> ∈ [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>]</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> |π<sub><span style="font-style:italic">j</span></sub>(<span style="font-style:italic">x</span>)| </td></tr>
</table><p>
Ce facteur s’appelle <span style="font-weight:bold">constante de Lebesgue</span><a id="hevea_default301"></a><a id="hevea_default302"></a> relative à la
subdivision <span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> de [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>]. On peut le calculer
numériquement pour une subdivision équidistribuée,
et montrer qu’il croit comme 2<sup><span style="font-style:italic">n</span>+1</sup>/<span style="font-style:italic">e</span> <span style="font-style:italic">n</span> ln(<span style="font-style:italic">n</span>),
par exemple pour <span style="font-style:italic">n</span>=40, il vaut environ <span style="font-family:monospace">5e9</span>.
Illustration avec Xcas :<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">restart;l(k,n):=product((x-j)/(k-j),j,0,k-1)*product((x-j)/(k-j),j,k+1,n); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p><p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:40px;font-style:large">n:=10; f:=add(abs(l(k,n)),k,0,n); plot(f,x=0..n)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>puis essayer avec <span style="font-style:italic">n</span>=20. Pour <span style="font-style:italic">n</span>=40, en observant que le max
est atteint dans [0,1], on peut remplacer les valeurs absolues
par la bonne puissance de -1<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">n:=40; g:=l(0,n)+add((-1)^(k+n-1)*l(k,n),k,1,n) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p><p>on a alors un polynôme, dont on calcule l’abscisse du maximum par<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">g1:=normal(g'); l:=realroot(g1,1e-12,evalf) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p><p>puis 
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">subst(g,x=l[0])
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
 qui donne environ <span style="font-family:monospace">4.7e9</span>.</p>
<!--TOC subsection id="sec269" Interpolation aux points de Tchebyshev-->
<h3 id="sec269" class="subsection">23.2  Interpolation aux points de Tchebyshev</h3><!--SEC END --><p><a id="hevea_default303"></a>
L’idée la plus naturelle pour interpoler un polynôme en <span style="font-style:italic">n</span>+1
points d’un intervalle [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>] consiste à couper en <span style="font-style:italic">n</span> morceaux
de même longueur. Mais ce n’est pas le plus efficace car le
terme |∏<sub><span style="font-style:italic">j</span>=0</sub><sup><span style="font-style:italic">n</span></sup>(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>)| est plus grand près des bords. Il est
donc plus judicieux d’avoir plus de points près des bords et moins
à l’intérieur. C’est là qu’interviennent les polynômes de
Tchebyshev, ils sont définis par développement de cos(<span style="font-style:italic">nx</span>)
en puissances de cos(<span style="font-style:italic">x</span>) :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(cos(<span style="font-style:italic">x</span>))=cos(<span style="font-style:italic">nx</span>) </td></tr>
</table><p>
Sur [−1,1], le polynôme <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub> vaut en valeur absolue au plus 1, et
atteint cette valeur exactement <span style="font-style:italic">n</span>+1 fois lorsque <span style="font-style:italic">x</span>=<span style="font-style:italic">k</span>π/<span style="font-style:italic">n</span> donc 
<span style="font-style:italic">X</span>=cos(<span style="font-style:italic">x</span>)=cos(<span style="font-style:italic">k</span>π/<span style="font-style:italic">n</span>).<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">n:=7; plot(tchebyshev1(n),x=-1..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>De plus cette majoration est optimale. En effet
soit <span style="font-style:italic">U</span> un polynôme de degré au plus <span style="font-style:italic">n</span> 
qui vérifie |<span style="font-style:italic">U</span>|<sub>∞</sub>&lt;1 sur [−1,1]
et tel que <span style="font-style:italic">U</span> ait le même coefficient dominant que
<span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>. Alors la différence <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">U</span> est du signe de <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub> en
<span style="font-style:italic">X</span>=cos(<span style="font-style:italic">k</span>π/<span style="font-style:italic">n</span>), <span style="font-style:italic">k</span> ∈ [0,<span style="font-style:italic">n</span>] puisqu’en ces points <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub> est
extrêmal de valeur absolue 1. Donc <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">U</span> s’annule <span style="font-style:italic">n</span> fois sur
[−1,1], mais son degré est au plus <span style="font-style:italic">n</span>−1 donc <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">U</span> absurde.</p><p>On a donc intérêt à prendre les abscisses des points
d’interpolation en les racines <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub> de <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>+<span style="font-style:italic">b</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>−<span style="font-style:italic">b</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>,    <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>=cos((<span style="font-style:italic">k</span>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">), 
   <span style="font-style:italic">k</span>=0..<span style="font-style:italic">n</span>−1</td></tr>
</table><p>
On pourra observer que le phénomène de 
Runge<a id="hevea_default304"></a> qui apparait par
exemple pour <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=1/(25<span style="font-style:italic">x</span><sup>2</sup>+1) sur [−1,1] avec des points d’interpolation
équidistants n’apparait plus si on prend des points de Tchebyshev.<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">f(x):=1/(1+25x^2); n:=20; X:=seq(2*j/n-1.0,j,0,n);  
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">l:=lagrange(X,map(X,f)):; plot(l-f(x),x=-1..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p><div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">T:=seq(cos((j+0.5)*pi/(n+1)),j,0,n); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-style:large">l:=lagrange(T,map(T,f)):; plot(100*(l-f(x)),x=-1..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>Ceci est relié à la constante de Lebesgue 
qui pour des points de Tchebyshev vaut un peu moins de 4 pour <span style="font-style:italic">n</span>&lt;100
(se comporte comme 2/πln(<span style="font-style:italic">n</span>) pour <span style="font-style:italic">n</span> grand), on peut montrer
que les polynômes de Lagrange aux points de Tchebyshev convergent
uniformément vers 1/(25<span style="font-style:italic">x</span><sup>2</sup>+1) (c’est plus généralement
vrai pour toute fonction <span style="font-style:italic">C</span><sup>1</sup> sur l’intervalle).</p><p>Remarque : ce n’est pas le polynôme de meilleure approximation,
de <span style="font-style:italic">f</span> (celui qui minimise la norme <span style="font-style:italic">L</span><sup>∞</sup> de la différence)
car la dérivée <span style="font-style:italic">n</span>+1-ième varie en général sur [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>]. Mais
il est trop difficile de le calculer en général.</p><p>Exemple de calcul explicite de constante de Lebesgue pour <span style="font-style:italic">n</span>=40 avec
Xcas

</p><pre class="verbatim">purge(x);
t(k,n):={ 
 local T; 
 T:=seq(cos(pi*(k+.5)/(n+1)),k,0,n);
 return product((x-T[j])/(T[k]-T[j]),j,0,k-1)*
  product((x-T[j])/(T[k]-T[j]),j,k+1,n);
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;t.value=tmp;tmp=UI.caseval(tmp);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML);field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>


<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-style:large">n:=40; f:=add(abs(t(k,n)),k,0,n):;plot(f,x=-1..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p>
<!--TOC subsection id="sec270" Interpolation de Hermite-->
<h3 id="sec270" class="subsection">23.3  Interpolation de Hermite</h3><!--SEC END --><p><a id="hevea_default305"></a>
Si on fait tendre un des points d’interpolation vers un autre, la
donnée de la valeur en ces 2 points serait redondante, elle 
est remplacée par la valeur de la dérivée. Dans le calcul
des différences divisées ci-dessus on fera comme si les
2 points étaient distincts et successifs, disons <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> et <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span>+1</sub>,
on remplace le rapport indéterminé 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span>+1</sub>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span>+1</sub>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">0</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">0</td></tr>
</table></td></tr>
</table><p>
par <span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>).
On montre qu’une fois ce changement réalisé
tout le reste est identique (y compris la majoration d’erreur).
On peut bien sur généraliser au cas de plusieurs paires de points 
identiques ou des multiplicités plus grandes faisant intervenir
des dérivées d’ordre supérieures, dans ce cas la différence
divisée <span style="font-style:italic">f</span>[<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span>+<span style="font-style:italic">m</span></sub>] sera remplacée par <span style="font-style:italic">f</span><sup>[<span style="font-style:italic">m</span>]</sup>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)/<span style="font-style:italic">m</span>!.</p>
<!--TOC subsection id="sec271" Polynômes de Bernstein et courbes de
Bézier-->
<h3 id="sec271" class="subsection">23.4  Polynômes de Bernstein et courbes de
Bézier</h3><!--SEC END --><p><a id="hevea_default306"></a> <a id="hevea_default307"></a>
Les polynômes de Bernstein de degré <span style="font-style:italic">m</span> sont les
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">n</span></sup> (<span style="font-style:italic">x</span>) = 
</td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">k</span> </td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell"><span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup> (1−<span style="font-style:italic">x</span>)<sup><span style="font-style:italic">n</span>−<span style="font-style:italic">k</span></sup></td></tr>
</table><p>
On reconnait la probabilité d’avoir <span style="font-style:italic">k</span> succès si on effectue <span style="font-style:italic">n</span>
tirages indépendants (avec remise) 
avec probabilité <span style="font-style:italic">x</span> ∈ [0,1] de succès par tirage. Ceci donne
une relation de récurrence
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>+1</sub><sup><span style="font-style:italic">n</span>+1</sup>=(1−<span style="font-style:italic">x</span>)<span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span>+1</sub><sup><span style="font-style:italic">n</span></sup>+<span style="font-style:italic">x</span> <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">n</span></sup> </td></tr>
</table><p>
qui peut servir à calculer les <span style="font-style:italic">B</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">m</span></sup>. On en déduit aussi que l’espérance
de <span style="font-style:italic">k</span> selon cette loi vaut <span style="font-style:italic">nx</span> (somme de <span style="font-style:italic">n</span> variables d’espérance
<span style="font-style:italic">x</span>) et l’espérance de (<span style="font-style:italic">k</span>−<span style="font-style:italic">nx</span>)<sup>2</sup> vaut
<span style="font-style:italic">nx</span>(1−<span style="font-style:italic">x</span>) (variance de la somme de <span style="font-style:italic">n</span> variables indépendantes
de variance <span style="font-style:italic">x</span>).
On en déduit qu’on peut approcher uniformément une
fonction continue sur un intervalle [<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>] par des polynômes, en
se ramenant à <span style="font-style:italic">a</span>=0, <span style="font-style:italic">b</span>=1, on pose :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>) = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">f</span>(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">) <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">n</span></sup>(<span style="font-style:italic">x</span>) </td></tr>
</table><p>
En effet, par continuité uniforme de <span style="font-style:italic">f</span> sur [0,1], pour
є&gt;0,
il existe δ&gt;0 tel que |<span style="font-style:italic">x</span>−<span style="font-style:italic">y</span>|&lt;δ ⇒
|<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>)|&lt;є/2,
dans
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">f</span>(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">)−<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)) <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">n</span></sup>(<span style="font-style:italic">x</span>)</td></tr>
</table><p>
on décompose la somme sur <span style="font-style:italic">k</span> en deux parties, |<span style="font-style:italic">k</span>/<span style="font-style:italic">n</span>−<span style="font-style:italic">x</span>|&lt;δ
et |<span style="font-style:italic">k</span>/<span style="font-style:italic">n</span>−<span style="font-style:italic">x</span>| ≥ δ, pour la première somme, on majore
|<span style="font-style:italic">f</span>(<span style="font-style:italic">k</span>/<span style="font-style:italic">n</span>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)| par є/2 puis par ∑<sub><span style="font-style:italic">k</span>=0</sub><sup><span style="font-style:italic">n</span></sup>,
pour la deuxième somme, on majore par 2|<span style="font-style:italic">f</span>|<sub>∞</sub> et on utilise
1&lt;(<span style="font-style:italic">k</span>/<span style="font-style:italic">n</span>−<span style="font-style:italic">x</span>)<sup>2</sup>/δ<sup>2</sup>=1/<span style="font-style:italic">n</span><sup>2</sup>/δ<sup>2</sup> (<span style="font-style:italic">k</span>−<span style="font-style:italic">nx</span>)<sup>2</sup> pour se ramener au calcul
de la variance de <span style="font-style:italic">k</span>, au final
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>)−<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">є</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span><sup>2</sup> δ<sup>2</sup></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">nx</span>(1−<span style="font-style:italic">x</span>)|<span style="font-style:italic">f</span>|<sub>∞</sub></td></tr>
</table><p>
il suffit de choisir <span style="font-style:italic">n</span> assez grand pour rendre le membre de droite
plus petit que є.</p><p>Les polynômes de Bernstein ne sont pas des polynômes
interpolateurs aux points <span style="font-style:italic">k</span>/<span style="font-style:italic">n</span>,   0&lt;<span style="font-style:italic">k</span>&lt;<span style="font-style:italic">n</span>, et la convergence
n’est pas forcément très rapide.
On les utilise pour approcher rapidement des morceaux de
courbes, si on se donne des “points de controle” <span style="font-style:italic">A</span><sub>0</sub>, ..., <span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>
on construit la courbe paramétrée
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>(<span style="font-style:italic">t</span>) = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub> </td><td class="dcell">⎛<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">i</span> </td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎠</td><td class="dcell"><span style="font-style:italic">x</span><sup><span style="font-style:italic">i</span></sup>
(1−<span style="font-style:italic">x</span>)<sup><span style="font-style:italic">n</span>−<span style="font-style:italic">i</span></sup> </td></tr>
</table><p>
appelée courbe de Bézier. En pratique on les utilise pour <span style="font-style:italic">n</span>=3.</p>
<!--TOC subsection id="sec272" Polynômes orthogonaux.-->
<h3 id="sec272" class="subsection">23.5  Polynômes orthogonaux.</h3><!--SEC END --><p><a id="hevea_default308"></a>
<a id="hevea_default309"></a>
Il s’agit d’une autre méthode d’approximation, 
particulièrement important pour l’intégration : les polynômes
de meilleur approximation au sens de normes <span style="font-style:italic">L</span><sup>2</sup> ou <span style="font-style:italic">L</span><sup>2</sup>
à poids <span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>)&gt;0 sur l’intervalle de bornes α et β
(finis ou infinis). 
On considère le produit scalaire
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;<span style="font-style:italic">f</span>|<span style="font-style:italic">g</span>&gt;=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>) <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)<span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">dx</span></td></tr>
</table><p>
et on projette alors la fonction à approcher 
sur une base de polynômes orthogonaux
de degrés croissants construit par la procédure
de Gram-Schmidt à partir de la base canonique
pour le produit scalaire ci-dessus.</p><div class="theorem"><span style="font-weight:bold">Proposition 56</span>  <em>
Le polynôme </em><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub><em> de degré </em><span style="font-style:italic">n</span><em>
obtenu par orthogonalisation de Gram-Schmidt
pour le produit scalaire </em>∫<sub>α</sub><sup>β</sup><span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>) <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)<span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>)  <span style="font-style:italic">dx</span><em>
possède </em><span style="font-style:italic">n</span><em> racines réelles.
</em></div><p>
En effet, soit <span style="font-style:italic">r</span> le nombre de racines réelles de <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>, on pose <span style="font-style:italic">f</span>=<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> et 
<span style="font-style:italic">g</span>=∏<sub><span style="font-style:italic">i</span>=1</sub><sup><span style="font-style:italic">r</span></sup> (<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>), <span style="font-style:italic">wfg</span> est de signe constant
et non identiquement nul donc &lt;<span style="font-style:italic">f</span>|<span style="font-style:italic">g</span>&gt; ≠ 0 donc
<span style="font-style:italic">r</span>=<span style="font-style:italic">n</span> sinon <span style="font-style:italic">g</span> serait de degré strictement plus petit que <span style="font-style:italic">n</span>
donc orthogonal à <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>.</p><p>On peut aussi construire ces polynômes en cherchant les valeurs
propres de
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">T</span>(<span style="font-style:italic">f</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">w</span></td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">awf</span>′)′</td></tr>
</table><p>
où <span style="font-style:italic">a</span>&gt;0 est un polynôme de degré au plus 2
sur ]α,β[, tel que <span style="font-style:italic">aw</span> s’annule (ou tend vers 0) 
aux bornes de l’intervalle d’intégration : si α et β sont finis
<span style="font-style:italic">a</span>(<span style="font-style:italic">x</span>)=(<span style="font-style:italic">x</span>−α)(β−<span style="font-style:italic">x</span>).
On a alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;<span style="font-style:italic">T</span>(<span style="font-style:italic">f</span>)|<span style="font-style:italic">g</span>&gt;=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">awf</span>′)′<span style="font-style:italic">g</span> =
[<span style="font-style:italic">awf</span>′<span style="font-style:italic">g</span>]<sub>α</sub><sup>β</sup>−</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">awg</span>′<span style="font-style:italic">f</span>′
=−</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">β</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">α</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">awg</span>′<span style="font-style:italic">f</span>′</td></tr>
</table><p>
car le terme tout intégré s’annule 
(puisque <span style="font-style:italic">aw</span> s’annule en α et β). Donc &lt;<span style="font-style:italic">T</span>(<span style="font-style:italic">f</span>)|<span style="font-style:italic">g</span>&gt;=&lt;<span style="font-style:italic">f</span>|<span style="font-style:italic">T</span>(<span style="font-style:italic">g</span>)&gt;
est symétrique, les vecteurs propres de <span style="font-style:italic">T</span> correspondant à des
valeurs propres distinctes sont donc orthogonaux entre eux.
Pour trouver ces valeurs propres/polynômes vecteurs propres, on
écrit <span style="font-style:italic">T</span>(<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>)=λ<sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> pour un polynôme <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> de degré
<span style="font-style:italic">n</span>. Si <span style="font-style:italic">aw</span>′/<span style="font-style:italic">w</span> est un polynôme de degré au plus 1, 
le terme de degré dominant de cette équation
donne la valeur de λ<sub><span style="font-style:italic">n</span></sub> et les termes de degré plus petits
permettent en général de déterminer de manière unique les
coefficients de <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> en fonction du coefficient dominant.</p><p>Pour certains poids <span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>) standards,
les polynômes obtenus ont un nom :
</p><ul class="itemize"><li class="li-itemize">
Legendre<a id="hevea_default310"></a> pour <span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>)=1 sur [−1,1],
<span style="font-style:italic">a</span>(<span style="font-style:italic">x</span>)=1−<span style="font-style:italic">x</span><sup>2</sup>
</li><li class="li-itemize">Hermite pour <span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">x</span><sup>2</sup></sup> sur ℝ, <span style="font-style:italic">a</span>(<span style="font-style:italic">x</span>)=1
</li><li class="li-itemize">Laguerre pour <span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">x</span><sup><span style="font-style:italic">a</span></sup> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">x</span></sup> sur ℝ<sup>+</sup>, 
</li><li class="li-itemize">Tchebyshev de première espèce pour <span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>)=1/√<span style="text-decoration:overline">1−</span><span style="text-decoration:overline"><span style="font-style:italic">x</span></span><sup><span style="text-decoration:overline">2</span></sup> sur
[−1,1], <span style="font-style:italic">a</span>(<span style="font-style:italic">x</span>)=1−<span style="font-style:italic">x</span><sup>2</sup>
</li><li class="li-itemize">Tchebyshev de deuxième espèce pour <span style="font-style:italic">w</span>(<span style="font-style:italic">x</span>)=√<span style="text-decoration:overline">1−</span><span style="text-decoration:overline"><span style="font-style:italic">x</span></span><sup><span style="text-decoration:overline">2</span></sup> sur
[−1,1], <span style="font-style:italic">a</span>(<span style="font-style:italic">x</span>)=1−<span style="font-style:italic">x</span><sup>2</sup>
</li></ul><p>Ainsi, les polynômes de Legendre vérifient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">((1−<span style="font-style:italic">x</span><sup>2</sup>)<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>′)′=λ<sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table><p>
Le terme de degré <span style="font-style:italic">n</span> de cette équation donne λ<sub><span style="font-style:italic">n</span></sub>=−<span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>+1),
le terme sous-dominant est nul. Plus générallement, 
le terme de degré <span style="font-style:italic">k</span> vérifie
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">k</span>+2)(<span style="font-style:italic">k</span>+1)<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span>+2</sub>−<span style="font-style:italic">k</span>(<span style="font-style:italic">k</span>+1)<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>=−<span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>+1)<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> ⇒
<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span>+2</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>(<span style="font-style:italic">k</span>+1)−<span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>+1)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">k</span>+2)(<span style="font-style:italic">k</span>+1)</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub></td></tr>
</table><p>
Ceci permet de calculer le polynôme <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>, on normalise
<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> par <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(1)=1.<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">n:=10; p:=makelist(n+1); p[0]:=1;
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">for k from 0 to size(p)-3 step 2 do p[k+2]:=(k*(k+1)-n*(n+1))/(k+2)/(k+1)*p[k]; od;
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">q:=p*1/sum(p); normal(poly2symb(revlist(q))); legendre(n) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p><p>Le calcul de ces polynômes peut aussi se faire par une récurrence à 2
crans du type :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:rec_orthogonaux"></a>
<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>+1</sub>=(<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">x</span>−<span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span></sub>)<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>
    (57)</td></tr>
</table><p>
La valeur de <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> est définie par la normalisation de la famille de
polynômes, ensuite <span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span></sub> et <span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub> sont déterminés respectivement
par 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>+1</sub>|<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>&gt;=0 ⇒ <span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span></sub>&lt;<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>|<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>&gt;=<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>&lt;<span style="font-style:italic">xP</span><sub><span style="font-style:italic">n</span></sub>|<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>&gt;</td></tr>
</table><p> 
et
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>+1</sub>|<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>&gt;=0 ⇒
<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub>&lt;<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>|<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>&gt;=<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>&lt;<span style="font-style:italic">xP</span><sub><span style="font-style:italic">n</span></sub>|<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>&gt;=<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>&lt;<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>|<span style="font-style:italic">xP</span><sub><span style="font-style:italic">n</span>−1</sub>&gt;</td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub>&lt;<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>|<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>&gt;=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub></td></tr>
</table></td><td class="dcell">&lt;<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>|<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>+<span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span>−1</sub><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub>+<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span>−1</sub><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−2</sub>&gt;
=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub></td></tr>
</table></td><td class="dcell">&lt;<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>|<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>&gt;</td></tr>
</table><p>
Les autres relations
d’orthogonalité &lt;<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>+1</sub>|<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>&gt;=0, <span style="font-style:italic">j</span>&lt;<span style="font-style:italic">n</span>−1 sont automatiquement
vérifiées puisque &lt;<span style="font-style:italic">xP</span><sub><span style="font-style:italic">n</span></sub>|<span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub>&gt;=&lt;<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>|<span style="font-style:italic">xP</span><sub><span style="font-style:italic">j</span></sub>&gt;=0 et <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> est orthogonal
aux polynômes de degré ≤ <span style="font-style:italic">n</span>−1.</p><p>Dans l’exemple des polynômes de Legendre, les polynômes obtenus
sont pairs si <span style="font-style:italic">n</span> est pair et impairs sinon, la relation de 
récurrence a donc un coefficient <span style="font-style:italic">b</span><sub><span style="font-style:italic">n</span></sub> nul. La convention
de normalisation usuelle est <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>(1)=1, on peut montrer qu’on a
<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>=(2<span style="font-style:italic">n</span>+1)/(<span style="font-style:italic">n</span>+1) et &lt;<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>|<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub>&gt;=2/(2<span style="font-style:italic">n</span>+1) 
donc <span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">n</span>/(<span style="font-style:italic">n</span>+1).
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">n</span>+1)<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>+1</sub>=(2<span style="font-style:italic">n</span>+1)<span style="font-style:italic">xP</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">nP</span><sub><span style="font-style:italic">n</span>−1</sub></td></tr>
</table><p>
En effet la normalisation en 1 donne 1=<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub> donc <span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>−1,
les termes de degré <span style="font-style:italic">n</span>+1 et <span style="font-style:italic">n</span>−1 de <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">xP</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span>−1</sub> donnent
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>+1,<span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>,<span style="font-style:italic">n</span></sub>,    <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>+1,<span style="font-style:italic">n</span>−1</sub>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>
<span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>,<span style="font-style:italic">n</span>−2</sub>−(<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>−1)<span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>−1,<span style="font-style:italic">n</span>−1</sub></td></tr>
</table><p>
On applique alors (<a href="#eq%3Alegendre_rec">??</a>) et on déduit de la
deuxième équation ci-dessus :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>+1)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2(2<span style="font-style:italic">n</span>+1)</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>+1,<span style="font-style:italic">n</span>+1</sub>= −</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>−1)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2(2<span style="font-style:italic">n</span>+1)</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>
<span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>,<span style="font-style:italic">n</span></sub>−(<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>−1)<span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>−1,<span style="font-style:italic">n</span>−1</sub></td></tr>
</table><p>
puis on applique la première :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>+1)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2(2<span style="font-style:italic">n</span>+1)</td></tr>
</table></td><td class="dcell"> −
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>−1)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2(2<span style="font-style:italic">n</span>+1)</td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub></td></tr>
</table></td></tr>
</table><p>
d’où 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4<span style="font-style:italic">n</span><sup>2</sup>−1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub></td></tr>
</table></td></tr>
</table></td></tr>
</table><p><div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">S(f,g):=int(f*g,x,-1,1); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p><p><div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">gramschmidt([1,x,x^2,x^3,x^4],S); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">f:=ln(x+2);C:=seq(S(f,legendre(k))/S(legendre(k),legendre(k)),k,0,4); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">g:=sum(C[j]*legendre(j),j,0,4); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">plot([f,g],x,-1.4,1.4,color=[red,blue]);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p><span style="font-weight:bold">Remarques</span>
</p><ul class="itemize"><li class="li-itemize">
On peut utiliser la récurrence à deux crans pour évaluer
le polynôme en un réel, il n’est alors pas nécessaire
de calculer <span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> dans la base canonique.
</li><li class="li-itemize">La récurrence à deux crans se généralise pour les degrés
plus petits que <span style="font-style:italic">d</span> au produit scalaire
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;<span style="font-style:italic">P</span>|<span style="font-style:italic">Q</span>&gt;=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>) <span style="font-style:italic">Q</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>) </td></tr>
</table>
où les <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> sont des abscisses distinctes 2 à 2. Le calcul
d’une base orthogonale permet de
faire des calculs de régressions polynomiales mieux conditionnés
qu’en utilisant la base canonique (et la matrice de Vandermonde).
</li><li class="li-itemize">On peut voir l’interpolation trigonométrique (séries de Fourier,
transformée de Fourier discrète) comme une
généralisation en remplaçant une base orthonormalisée
de polynômes par une base orthogonale de sinus, cosinus
ou exponentielles.
</li></ul>
<!--TOC subsection id="sec273" Les splines-->
<h3 id="sec273" class="subsection">23.6  Les splines</h3><!--SEC END --><p><a id="hevea_default311"></a>
Il s’agit de fonctions définies par des polynomes de degré borné
sur des intervalles, dont on fixe la valeur
aux extrémités des intervalles (comme pour le polynome de Lagrange)
ce qui rend la fonction continue, de plus on exige un
degré de régularité plus grand, par exemple etre de classe <span style="font-style:italic">C</span><sup>2</sup>.
Enfin, on fixe des conditions aux bornes de la réunion des 
intervalles, par exemple avoir certaines dérivées nulles. </p><p>Par exemple supposons qu’on se donne <span style="font-style:italic">n</span> intervalles, donc <span style="font-style:italic">n</span>+1
points <span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>, on se fixe une régularité <span style="font-style:italic">C</span><sup><span style="font-style:italic">d</span>−1</sup>. Ceci
entraine (<span style="font-style:italic">n</span>−1)<span style="font-style:italic">d</span> conditions de recollement, on y ajoute <span style="font-style:italic">n</span>+1
conditions de valeur en <span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>, on a donc <span style="font-style:italic">nd</span>+1 conditions,
la borne sur le degré des polynomes doit donc etre <span style="font-style:italic">d</span> (ou plus,
mais <span style="font-style:italic">d</span> suffit) ce qui donne <span style="font-style:italic">n</span>(<span style="font-style:italic">d</span>+1) degrés de liberté, on
peut donc ajouter <span style="font-style:italic">d</span>−1 conditions, par exemple pour les splines
naturelles, on impose que les dérivées d’ordre <span style="font-style:italic">d</span>/2 à <span style="font-style:italic">d</span>−1
soient nulles en <span style="font-style:italic">x</span><sub>0</sub> et <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> (si <span style="font-style:italic">d</span> est pair, on commence à
la dérivée <span style="font-style:italic">d</span>/2+1-ième nulle en <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>).</p><p>Pour trouver les polynomes, on doit donc résoudre un grand système
linéaire. Une méthode permettant de diminuer la taille du système
linéaire à résoudre dans le cas des splines naturelles
consiste à se fixer <span style="font-style:italic">n</span> inconnues <span style="font-style:italic">z</span><sub>0</sub>,..,<span style="font-style:italic">z</span><sub><span style="font-style:italic">n</span>−1</sub>
représentant les dérivées <span style="font-style:italic">d</span>-ième de la spline <span style="font-style:italic">f</span> en
<span style="font-style:italic">x</span><sub>0</sub> sur [<span style="font-style:italic">x</span><sub>0</sub>,<span style="font-style:italic">x</span><sub>1</sub>] à <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub> sur [<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>], 
et (<span style="font-style:italic">d</span>−1)/2 inconnues <span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub>, représentant
la valeur de la dérivée de <span style="font-style:italic">f</span> en <span style="font-style:italic">x</span><sub>0</sub> pour <span style="font-style:italic">j</span> variant
de 1 à (<span style="font-style:italic">d</span>−1)/2. On peut alors écrire le polynome sur l’intervalle
[<span style="font-style:italic">x</span><sub>0</sub>,<span style="font-style:italic">x</span><sub>1</sub>] car on connait son développement de Taylor en <span style="font-style:italic">x</span><sub>0</sub>.
On effectue un changement d’origine (par application répétée
de Horner) en <span style="font-style:italic">x</span><sub>1</sub>. On obtient alors le polynome sur [<span style="font-style:italic">x</span><sub>1</sub>,<span style="font-style:italic">x</span><sub>2</sub>]
en remplaçant uniquement la dérivée <span style="font-style:italic">d</span>-ième par <span style="font-style:italic">z</span><sub>1</sub>.
On continue ainsi jusqu’en <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>−1</sub>. Le système s’obtient en
calculant la valeur du polynome en <span style="font-style:italic">x</span><sub>0</sub>,...,<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> et la nullité
des dérivées d’ordre (<span style="font-style:italic">d</span>−1)/2 à <span style="font-style:italic">d</span>/2 en <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>. On résoud
le système et on remplace pour avoir les valeurs numériques
des coefficients du polynome.</p>
<!--TOC section id="sec274" Développement de Taylor, asymptotiques, 
séries entières, fonctions usuelles-->
<h2 id="sec274" class="section">24  Développement de Taylor, asymptotiques, 
séries entières, fonctions usuelles</h2><!--SEC END --><p>
<a id="sec:series"></a>
<a id="hevea_default312"></a>
Pour approcher les fonctions classiques (exponentielle, sinus,
cosinus, log nepérien), on peut utiliser les développements en séries 
classiques, le polynôme de Taylor en un point donne
une bonne approximation près du point, l’équivalent
en l’infini appelé développement asymptotique donne
une bonne approximation loin de 0, et
les approximants de Padé 
où on approche par le quotient de 2 polynômes (ceci
donne parfois de très bons résultats comme pour la fonction
exponentielle près de 0 par exemple).</p><p>Soit <span style="font-style:italic">f</span> une fonction indéfiniment dérivable sur un intervalle <span style="font-style:italic">I</span> de ℝ
et <span style="font-style:italic">x</span><sub>0</sub> ∈ <span style="font-style:italic">I</span>. On peut alors effectuer le développement de Taylor de <span style="font-style:italic">f</span>
en <span style="font-style:italic">x</span><sub>0</sub> à l’ordre <span style="font-style:italic">n</span><a id="hevea_default313"></a>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>)(<span style="font-style:italic">x</span>)= <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>0</sub>) + (<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>) <span style="font-style:italic">f</span>′(<span style="font-style:italic">x</span><sub>0</sub>) + ... + 
(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)<sup><span style="font-style:italic">n</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>]</sup>(<span style="font-style:italic">x</span><sub>0</sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
et se demander si <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>) converge lorsque <span style="font-style:italic">n</span> tend vers
l’infini, si la limite est égale à <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) et si on peut facilement
majorer la différence entre <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) et <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>)(<span style="font-style:italic">x</span>). Si c’est le
cas, on pourra utiliser <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>)(<span style="font-style:italic">x</span>) comme valeur approchée de <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>).</p><p>On peut parfois répondre à ces questions simultanément en regardant le
développement de Taylor de <span style="font-style:italic">f</span> avec reste : il existe θ compris
entre <span style="font-style:italic">x</span><sub>0</sub> et <span style="font-style:italic">x</span> tel que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>) := <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)− <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>)(<span style="font-style:italic">x</span>) = (<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>0</sub>)<sup><span style="font-style:italic">n</span>+1</sup></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>+1]</sup>(θ)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
C’est le cas pour la fonction exponentielle que nous allons
détailler, ainsi que les fonctions sinus et cosinus.</p>
<!--TOC subsection id="sec275" La fonction exponentielle-->
<h3 id="sec275" class="subsection">24.1  La fonction exponentielle</h3><!--SEC END --><p><a id="hevea_default314"></a><a id="hevea_default315"></a>
Soit <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=exp(<span style="font-style:italic">x</span>) et <span style="font-style:italic">x</span><sub>0</sub>=0, la dérivée <span style="font-style:italic">n</span>-ième de <span style="font-style:italic">f</span> 
est exp(<span style="font-style:italic">x</span>), donc <span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>)=exp(θ)<span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup>/(<span style="font-style:italic">n</span>+1)! avec θ
compris entre 0 et <span style="font-style:italic">x</span>, ainsi si <span style="font-style:italic">x</span> est positif 
|<span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>)| ≤ <span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup> <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup>/(<span style="font-style:italic">n</span>+1)! et si <span style="font-style:italic">x</span> est négatif,
|<span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>)| ≤ <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup>/(<span style="font-style:italic">n</span>+1)!. Dans les deux cas, la limite de <span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub>
est 0 lorsque <span style="font-style:italic">n</span> tend vers l’infini, car pour <span style="font-style:italic">n</span> ≥ 2<span style="font-style:italic">x</span>, on a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>+1</td></tr>
</table></td><td class="dcell">≤ 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td></tr>
</table><p>
on a donc pour tout <span style="font-style:italic">x</span> réel
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center">lim</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span> → +∞</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>)(<span style="font-style:italic">x</span>)
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center">lim</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span> → +∞</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>!</td></tr>
</table></td><td class="dcell">
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>!</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>Comment en déduire une valeur approchée de <span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup>? Il suffira d’arrêter
la sommation lorsque <span style="font-style:italic">R</span>:=<span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup>/(<span style="font-style:italic">n</span>+1)! si <span style="font-style:italic">x</span>&lt;0 ou lorsque
<span style="font-style:italic">R</span>:=<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup> <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup>/(<span style="font-style:italic">n</span>+1)! si <span style="font-style:italic">x</span>&gt;0 est inférieur à 
l’erreur absolue souhaitée, le plus tôt étant le mieux pour des
raisons d’efficacité et pour éviter l’accumulation d’erreurs
d’arrondi. 
Si on veut connaitre <span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup> à une erreur relative ε donnée
(par exemple ε=2<sup>−53</sup> pour stocker le résultat dans un double)
il suffit que <span style="font-style:italic">R</span>/<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup> &lt; ε, donc si <span style="font-style:italic">x</span> est positif, il suffit
que <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup>/(<span style="font-style:italic">n</span>+1)!&lt;ε, on peut donc arrêter la sommation
lorsque le terme suivant est plus petit que ε.</p><p>On observe que plus <span style="font-style:italic">x</span> est grand, plus <span style="font-style:italic">n</span> devra
être grand pour réaliser le test d’arrêt, ce qui est facheux
pour le temps de calcul.
De plus, le résultat final peut être petit alors que les termes
intermédiaires calculés dans la somme peuvent être grands, ce qui
provoque une perte de précision relative, par exemple si on
veut calculer <span style="font-style:italic">e</span><sup>−10</sup> ou plus généralement l’exponentielle
d’un nombre négatif de grande valeur absolue.</p><p>Exercice : combien de termes faut-il calculer dans le développement
de l’exponentielle de -10 pour que le reste soit plus petit
que 2<sup>−53</sup> ? Quel est la valeur du plus grand terme rencontré dans
la suite ? Quelle est la perte de précision relative occasionné
par cette méthode de calcul ?</p><p>On peut utiliser les propriétés de la fonction exponentielle
pour éviter ce problème. Pour les nombres négatifs, on peut
utiliser l’équation <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">x</span></sup>=1/<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup> (ne change pas l’erreur relative). 
Pour les grands réels, on peut utiliser <span style="font-style:italic">e</span><sup>2<span style="font-style:italic">x</span></sup>=(<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup>)<sup>2</sup>
(multiplie par 2 l’erreur relative).
On peut aussi, si on connait une valeur approchée
de ln(2), effectuer la division euclidienne de <span style="font-style:italic">x</span> par ln(2) 
avec reste symétrique :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span> = <span style="font-style:italic">a</span> ln(2) + <span style="font-style:italic">r</span>,    <span style="font-style:italic">a</span> ∈ ℤ, |<span style="font-style:italic">r</span>| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ln</span>(2)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
puis si <span style="font-style:italic">r</span> est positif, on somme la série de <span style="font-style:italic">T</span>(<span style="font-style:italic">f</span>)(<span style="font-style:italic">r</span>), si <span style="font-style:italic">r</span>
est négatif, on calcule <span style="font-style:italic">T</span>(<span style="font-style:italic">f</span>)(−<span style="font-style:italic">r</span>) et on inverse, on applique alors :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup> = 2<sup><span style="font-style:italic">a</span></sup> <span style="font-style:italic">e</span><sup><span style="font-style:italic">r</span></sup> </td></tr>
</table><p>Il faut toutefois noter que ln(2) n’étant pas connu exactement,
on commet une erreur d’arrondi absolu sur <span style="font-style:italic">r</span> d’ordre <span style="font-style:italic">a</span> η,
où η est l’erreur relative sur ln(2),
il faut donc ajouter une erreur d’arrondi relative de <span style="font-style:italic">x</span>/ln(2) η
qui peut devenir grande si <span style="font-style:italic">x</span> est grand. Puis il faut ajouter
la somme des erreurs d’arrondi due au calcul de <span style="font-style:italic">e</span><sup><span style="font-style:italic">r</span></sup>, que l’on
peut minimiser en utilisant la méthode de Horner pour évaluer
<span style="font-style:italic">T</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">f</span>)(<span style="font-style:italic">r</span>) (car elle commence par sommer les termes de plus haut degré
qui sont justement les plus petits termes de la somme). 
Les coprocesseurs arithmétiques qui implémentent la fonction exponentielle
ont un format de représentation interne des double avec une mantisse
plus grande que celle des double (par exemple 64 bits au lieu de 53),
et une table contenant des constantes dont ln(2) avec cette précision,
le calcul de <span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup> par cette méthode entraine donc seulement une erreur
relative d’arrondi au plus proche sur le résultat converti en double 
(donc de 2<sup>−53</sup>).</p><p>Notons que en général <span style="font-style:italic">x</span> lui-même
a déjà été arrondi ou n’est connu qu’avec une précision relative.
Or si <span style="font-style:italic">x</span>&gt;0 est connu avec une erreur relative de ε
(donc une erreur absolue de ε |<span style="font-style:italic">x</span>|, alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span>+ε |<span style="font-style:italic">x</span>|</sup>= <span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup> <span style="font-style:italic">e</span><sup>ε |<span style="font-style:italic">x</span>|</sup> </td></tr>
</table><p>
donc on ne peut pas espérer mieux qu’une erreur relative de 
<span style="font-style:italic">e</span><sup>ε |<span style="font-style:italic">x</span>|</sup>−1 sur l’exponentielle de <span style="font-style:italic">x</span>. Si ε <span style="font-style:italic">x</span> est petit
cette erreur relative (impossible à éviter, quel que soit
l’algorithme utilisé pour calculer l’exponentielle) 
est d’ordre ε |<span style="font-style:italic">x</span>|. Si ε <span style="font-style:italic">x</span> est 
grand alors l’erreur relative devient de l’ordre de 1, et la valeur
de l’exponentielle calculée peut être très éloignée de la valeur
réelle! Notons que pour les double, il y aura dans ce cas débordement 
soit vers l’infini soit vers 0
(par exemple si <span style="font-style:italic">x</span> est supérieur à 709, l’exponentielle renvoie infini).</p><p>Exercice : refaire les mêmes calculs pour les fonction sinus ou cosinus.
On utilise par exemple sin(<span style="font-style:italic">x</span>+π)=−<span style="font-style:italic">sin</span>(<span style="font-style:italic">x</span>), sin(−<span style="font-style:italic">x</span>)=−sin(<span style="font-style:italic">x</span>),
sin(<span style="font-style:italic">x</span>)=cos(π/2−<span style="font-style:italic">x</span>) pour se ramener au calcul de sin(<span style="font-style:italic">x</span>) 
ou de cos(<span style="font-style:italic">x</span>) sur [0,π/4].<a id="hevea_default316"></a><a id="hevea_default317"></a>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">sin(<span style="font-style:italic">x</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=0</td></tr>
</table></td><td class="dcell">(−1)<sup><span style="font-style:italic">n</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2<span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td><td class="dcell">,
   cos(<span style="font-style:italic">x</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=0</td></tr>
</table></td><td class="dcell">(−1)<sup><span style="font-style:italic">n</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2<span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">n</span>)!</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>Cette méthode a toutefois ces limites, car il peut devenir impraticable
de calculer la dérivée <span style="font-style:italic">n</span>-ième d’une fonction (par exemple avec tan(<span style="font-style:italic">x</span>)),
et encore plus de la majorer. D’où l’intérêt de développer une théorie
des fonctions qui sont égales à leur développement de Taylor à l’infini
d’une part, et d’avoir d’autres méthodes pour majorer le reste, nous
présentons ici le cas des séries alternées.</p>
<!--TOC subsection id="sec276" Séries entières.-->
<h3 id="sec276" class="subsection">24.2  Séries entières.</h3><!--SEC END --><p><a id="hevea_default318"></a>
Les séries de type prendre la limite lorsque <span style="font-style:italic">n</span> tend vers
l’infini du développement de Taylor en x=0 sont de la forme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=0</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup> := </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center">lim</td></tr>
<tr><td class="dcell" style="text-align:center"> <span style="font-style:italic">k</span> → +∞</td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup>, <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">f</span><sup>[<span style="font-style:italic">n</span>]</sup>(0)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td></tr>
</table><p>
On peut s’intéresser plus généralement à ∑<sub><span style="font-style:italic">n</span>=0</sub><sup>∞</sup><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup>
lorsque <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> est un complexe quelconque, 
c’est ce qu’on appelle une série entière, on peut aussi les voir comme
des polynômes généralisés. </p><p>S’il existe un point <span style="font-style:italic">x</span><sub>0</sub> tel que 
|<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">x</span><sub>0</sub><sup><span style="font-style:italic">n</span></sup>| est borné (ce sera le cas en particulier 
si la série converge en <span style="font-style:italic">x</span><sub>0</sub>), alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup>| = |<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">x</span><sub>0</sub><sup><span style="font-style:italic">n</span></sup>| |</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub>0</sub></td></tr>
</table></td><td class="dcell">|<sup><span style="font-style:italic">n</span></sup> ≤ 
<span style="font-style:italic">M</span> |</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub>0</sub></td></tr>
</table></td><td class="dcell">|<sup><span style="font-style:italic">n</span></sup>
</td></tr>
</table><p>
la série converge donc en <span style="font-style:italic">x</span> si |<span style="font-style:italic">x</span>|&lt;|<span style="font-style:italic">x</span><sub>0</sub>| et on 
peut majorer le reste de la série au rang <span style="font-style:italic">n</span> par 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub>| ≤ <span style="font-style:italic">M</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"> |</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub>0</sub></td></tr>
</table></td><td class="dcell">|<sup><span style="font-style:italic">n</span>+1</sup></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−|</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub>0</sub></td></tr>
</table></td><td class="dcell">|</td></tr>
</table></td></tr>
</table></td><td class="dcell"> 
</td></tr>
</table><p>
la vitesse de convergence est donc du même type que pour le
théorème du point fixe (le nombre de termes à calculer
pour trouver une valeur approchée avec <span style="font-style:italic">k</span> décimales 
dépend linéairement <span style="font-style:italic">k</span>, les constantes sont d’autant
plus grandes que |<span style="font-style:italic">x</span>| est grand).</p><div class="theorem"><span style="font-weight:bold">Théorème 57</span>  <em>
S’il existe un rang </em><span style="font-style:italic">n</span><sub>0</sub><em>, un réel </em><span style="font-style:italic">M</span>&gt;0<em> et un complexe </em><span style="font-style:italic">x</span><sub>0</sub><em> tels que 
pour </em><span style="font-style:italic">n</span>&gt;<span style="font-style:italic">n</span><sub>0</sub><em>, on ait :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">x</span><sub>0</sub>|<sup><span style="font-style:italic">n</span></sup> ≤ <span style="font-style:italic">M</span></td></tr>
</table><em>
alors la série converge pour </em>|<span style="font-style:italic">x</span>|&lt;|<span style="font-style:italic">x</span><sub>0</sub>|<em>
et pour </em><span style="font-style:italic">n</span>≥ <span style="font-style:italic">n</span><sub>0</sub><em>, on a :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:maj_serie_entiere"></a>
|<span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub>| ≤ <span style="font-style:italic">M</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"> |</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub>0</sub></td></tr>
</table></td><td class="dcell">|<sup><span style="font-style:italic">n</span>+1</sup></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−|</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub>0</sub></td></tr>
</table></td><td class="dcell">|</td></tr>
</table></td></tr>
</table></td><td class="dcell"><em> 
    (58)</em></td></tr>
</table><em>
</em></div><p>On en déduit qu’il existe un réel
positif <span style="font-style:italic">R</span>≥ 0 éventuellement égal à +∞ tel que 
la série converge (la limite de la somme jusqu’à l’infini existe) 
lorsque |<span style="font-style:italic">x</span>|&lt;<span style="font-style:italic">R</span> et n’existe pas lorsque
|<span style="font-style:italic">x</span>|&gt;<span style="font-style:italic">R</span>, ce réel est appelé <span style="font-weight:bold">rayon de convergence</span> de la série.
Par exemple ce rayon vaut +∞ pour l’exponentielle, le sinus
ou le cosinus. Il
est égal à 1 pour la série géométrique ∑<span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup> (car elle diverge
si |<span style="font-style:italic">x</span>|&gt;1 et converge si |<span style="font-style:italic">x</span>|&lt;1). 
On ne peut pas dire ce qui se passe génériquement lorsqu’on
est à la limite, c’est-à-dire lorsque |<span style="font-style:italic">x</span>|=<span style="font-style:italic">R</span> (si <span style="font-style:italic">R</span>≠
+∞). Mais cela n’a en fait pas trop d’importance en pratique
car même si la série converge, elle converge souvent trop lentement
pour donner de bonnes approximations. En fait, la vitesse de
convergence d’une série entière de rayon <span style="font-style:italic">R</span>≠ +∞ est
en gros la même que celle d’une série géométrique de raison |<span style="font-style:italic">x</span>|/<span style="font-style:italic">R</span>.</p><p>Lorsque 2 séries ont un rayon de convergence non nul, alors on
peut effectuer leur somme, leur produit comme des polynômes et la
série somme/produit a un rayon de convergence au moins égal au plus
petit des 2 rayons de convergence des arguments. On peut inverser une série
entière non nulle en 0 en appliquant 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(1+<span style="font-style:italic">x</span>)<sup>−1</sup> = 1−<span style="font-style:italic">x</span>+<span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">x</span><sup>3</sup>+... </td></tr>
</table><p>
et on obtient une série entière de rayon de
convergence non nul. On peut aussi composer deux séries entières
<span style="font-style:italic">g</span> et <span style="font-style:italic">f</span> en <span style="font-style:italic">g</span>∘ <span style="font-style:italic">f</span> (avec les règles de calcul de composition
des polynômes) si <span style="font-style:italic">f</span>(0)=0. On peut enfin dériver
et intégrer une série entière terme à terme dans son rayon de convergence.</p><p>On dit qu’une fonction est développable en série entière en 0 si
elle est égale à son développement de Taylor en 0 sommé jusqu’en l’infini
dans un disque de centre 0 et de rayon non nul. Les fonctions
exponentielle, sinus, cosinus sont donc développables en série entière en 0.
La fonction tangente également car le dénominateur cosinus est non nul en 0,
mais son rayon de convergence n’est pas l’infini et le calcul des <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>
est assez complexe.
La fonction (1+<span style="font-style:italic">x</span>)<sup>α</sup> est développable en séries entières
pour tout α ∈ ℝ avec un rayon de convergence 1 (ou l’infini
pour α  entier positif). 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(1+<span style="font-style:italic">x</span>)<sup>α</sup>= 1 + α <span style="font-style:italic">x</span> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">α (α−1)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sup>2</sup> +
... + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">α (α−1) ... (α −<span style="font-style:italic">n</span> +1)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup> + ...</td></tr>
</table><p>
Pour α=−1, c’est la série 
géométrique de raison −<span style="font-style:italic">x</span>, en effet si |<span style="font-style:italic">x</span>|&lt;1 :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=0</td></tr>
</table></td><td class="dcell"> (−<span style="font-style:italic">x</span>)<sup><span style="font-style:italic">n</span></sup> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1−(−<span style="font-style:italic">x</span>)<sup><span style="font-style:italic">k</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> 
→<sub><span style="font-style:italic">k</span>→ ∞</sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">x</span></td></tr>
</table></td></tr>
</table><p>
En intégrant par rapport à <span style="font-style:italic">x</span>, on obtient que ln(1+<span style="font-style:italic">x</span>) est développable
en série entière en 0 de rayon de convergence 1 et
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ln(1+<span style="font-style:italic">x</span>) = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=0</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(−<span style="font-style:italic">x</span>)<sup><span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>+1</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
On peut calculer de manière analogue le développement en série entière
de arctan(<span style="font-style:italic">x</span>) en iintégrant celui de 1/(1+<span style="font-style:italic">x</span><sup>2</sup>), de même pour arccos(<span style="font-style:italic">x</span>)
et arcsin(<span style="font-style:italic">x</span>) en intégrant celui de (1−<span style="font-style:italic">x</span><sup>2</sup>)<sup>−1/2</sup>.<a id="hevea_default319"></a>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">arctan(<span style="font-style:italic">x</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=0</td></tr>
</table></td><td class="dcell">(−1)<sup><span style="font-style:italic">n</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2<span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">n</span>+1</td></tr>
</table></td><td class="dcell">,
</td></tr>
</table><p>
On peut donc calculer ln, arctan, ... par ces formules, 
mais il faut répondre
à la question où arrête-t-on la somme pour obtenir une précision donnée? 
Dans le cas de ln(1+<span style="font-style:italic">x</span>),
on pourrait répondre comme avec l’exponentielle en majorant la dérivée
<span style="font-style:italic">n</span>+1-ième, mais ce n’est plus faisable pour arctan, arcsin, arccos.
On va donner un autre critère qui ne nécessite pas
de calculer cette dérivée mais utilise l’alternance des signes
dans la somme.</p>
<!--TOC subsection id="sec277" Série alternée-->
<h3 id="sec277" class="subsection">24.3  Série alternée</h3><!--SEC END --><p><a id="hevea_default320"></a>
</p><div class="theorem"><span style="font-weight:bold">Théorème 58</span>  <em>
Soit </em><span style="font-style:italic">S</span><sub><span style="font-style:italic">n</span></sub>= ∑<sub><span style="font-style:italic">k</span>=0</sub><sup><span style="font-style:italic">n</span></sup> (−1)<sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">u</span><sub><span style="font-style:italic">k</span></sub><em> la somme jusqu’au rang </em><span style="font-style:italic">n</span><em> d’une
série de réels tels que la suite des </em><span style="font-style:italic">u</span><sub><span style="font-style:italic">k</span></sub><em> décroit à partir
d’un rang </em><span style="font-style:italic">n</span><sub>0</sub><em> et tend vers 0
lorsque </em><span style="font-style:italic">k</span>→ +∞<em>. Alors </em><span style="font-style:italic">S</span><sub><span style="font-style:italic">n</span></sub><em> converge vers une limite
</em><span style="font-style:italic">S</span><em>. Si </em><span style="font-style:italic">n</span>≥ <span style="font-style:italic">n</span><sub>0</sub><em>, la limite est comprise entre deux sommes
partielles succesives </em><span style="font-style:italic">S</span><sub><span style="font-style:italic">n</span></sub><em> et </em><span style="font-style:italic">S</span><sub><span style="font-style:italic">n</span>+1</sub><em> et le reste est majoré par
la valeur absolue du premier terme non sommé :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub>| ≤ |<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>|</td></tr>
</table><em>
</em></div><p>
Démonstration :<br>
on montre que les suites <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">S</span><sub>2<span style="font-style:italic">n</span></sub> et <span style="font-style:italic">w</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">S</span><sub>2<span style="font-style:italic">n</span>+1</sub> sont
adjacentes. On a 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>= <span style="font-style:italic">S</span><sub>2<span style="font-style:italic">n</span>+2</sub>−<span style="font-style:italic">S</span><sub>2<span style="font-style:italic">n</span></sub>= (−1)<sup>2<span style="font-style:italic">n</span>+2</sup> <span style="font-style:italic">u</span><sub>2<span style="font-style:italic">n</span>+2</sub> + (−1)<sup>2<span style="font-style:italic">n</span>+1</sup>
<span style="font-style:italic">u</span><sub>2<span style="font-style:italic">n</span>+1</sub> = <span style="font-style:italic">u</span><sub>2<span style="font-style:italic">n</span>+2</sub>−<span style="font-style:italic">u</span><sub>2<span style="font-style:italic">n</span>+1</sub> ≤ 0</td></tr>
</table><p>
donc <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> est décroissante, de même <span style="font-style:italic">w</span><sub><span style="font-style:italic">n</span></sub> est croissante,
et <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">w</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">u</span><sub>2<span style="font-style:italic">n</span>+1</sub> est positif et tend vers 0. On en déduit que
<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> et <span style="font-style:italic">w</span><sub><span style="font-style:italic">n</span></sub> convergent vers la même limite <span style="font-style:italic">S</span> telle que
<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>&gt;<span style="font-style:italic">S</span>&gt;<span style="font-style:italic">w</span><sub><span style="font-style:italic">n</span></sub> et les inégalités du théorème s’en déduisent.</p><p><span style="font-weight:bold">Remarque</span><br>
lorsqu’on utilise une suite alternée pour
trouver une valeur approchée, il faut que <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> tende assez
vite vers 0, sinon il y aura perte de précision sur la mantisse
lorsqu’on effectuera <span style="font-style:italic">u</span><sub>2<span style="font-style:italic">n</span></sub>−<span style="font-style:italic">u</span><sub>2<span style="font-style:italic">n</span>+1</sub>. On sommera aussi les termes
par ordre décroissant pour diminuer les erreurs d’arrondi.</p>
<!--TOC subsection id="sec278" La fonction logarithme-->
<h3 id="sec278" class="subsection">24.4  La fonction logarithme</h3><!--SEC END --><p><a id="hevea_default321"></a><a id="hevea_default322"></a>
Si nous voulons calculer ln(1+<span style="font-style:italic">x</span>) pour <span style="font-style:italic">x</span> ∈ [0,1[ avec une
précision ε, il suffit de calculer
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"> (−1)<sup><span style="font-style:italic">k</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>+1</td></tr>
</table></td></tr>
</table><p>
pour <span style="font-style:italic">n</span> tel que la valeur absolue du terme suivant soit plus petit 
que ε :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">n</span>  tel que  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>+1</td></tr>
</table></td><td class="dcell"> &lt; ε </td></tr>
</table><p>
en effet, les signes sont alternés et la suite <span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span>+1</sup>/<span style="font-style:italic">k</span>+1
décroit vers 0.</p><p>Si la suite décroit lentement vers 0, cette méthode est
mauvaise numériquement et en temps de calcul
car il y a presque compensation entre
termes successifs donc perte de précision sur la mantisse et il
y a beaucoup de termes à calculer. C’est le cas pour le logarithme,
si <span style="font-style:italic">x</span> est voisin de 1, il faut calculer <span style="font-style:italic">n</span> termes pour avoir une
précision en 1/<span style="font-style:italic">n</span>, par exemple 1 million de termes pour avoir
une précision de 1<span style="font-style:italic">e</span>−6 (sans tenir compte des erreurs d’arrondi). 
Si <span style="font-style:italic">x</span> est proche de 1/2 il faut de l’ordre
de −ln(ε)/ln(2) termes ce qui est mieux, mais encore
relativement grand (par exemple
50 termes environ pour une précision en 1<span style="font-style:italic">e</span>−16,
13 termes pour 1<span style="font-style:italic">e</span>−4).
On a donc intérêt à se
ramener si possible à calculer la fonction en un <span style="font-style:italic">x</span> où la
convergence est plus rapide (donc |<span style="font-style:italic">x</span>| le plus petit possible).
Par exemple pour le calcul de ln(1+<span style="font-style:italic">x</span>) on peut :
</p><ul class="itemize"><li class="li-itemize">
utiliser la racine carrée
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">ln</span>(1+<span style="font-style:italic">x</span>)= 2 <span style="font-style:italic">ln</span>(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell">)</td></tr>
</table>
on observe que :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">X</span>=</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell">−1 = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">x</span></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table>
il faut toutefois faire attention à la perte de précision sur
<span style="font-style:italic">X</span> par rapport à <span style="font-style:italic">x</span> lorsque <span style="font-style:italic">x</span> est petit.
</li><li class="li-itemize">utiliser l’inverse
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ln(1+<span style="font-style:italic">x</span>)=−ln(1/(1+<span style="font-style:italic">x</span>))=−ln(1 + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−<span style="font-style:italic">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell">) </td></tr>
</table>
lorsque <span style="font-style:italic">x</span> est proche de 1, −<span style="font-style:italic">x</span>/(1+<span style="font-style:italic">x</span>) est proche de −<span style="font-style:italic">x</span>/2, on
a presque divisé par 2. Attention toutefois, on se retrouve alors
avec une série non alternée, mais on peut utiliser 
(<a href="#eq%3Amaj_serie_entiere">58</a>) pour majorer le reste dans ce cas.
</li><li class="li-itemize">trouver une valeur approchée <span style="font-style:italic">y</span><sub>0</sub> de ln(1+<span style="font-style:italic">x</span>) à une précision
faible, par exemple 1<span style="font-style:italic">e</span>−4, et utiliser la méthode de Newton pour
améliorer la précision. Soit en effet <span style="font-style:italic">y</span>=ln(1+<span style="font-style:italic">x</span>), alors
<span style="font-style:italic">e</span><sup><span style="font-style:italic">y</span></sup>=1+<span style="font-style:italic">x</span>, on pose <span style="font-style:italic">f</span>(<span style="font-style:italic">y</span>)=<span style="font-style:italic">e</span><sup><span style="font-style:italic">y</span></sup>−(1+<span style="font-style:italic">x</span>), on utilise la suite itérative
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span><sub><span style="font-style:italic">n</span>+1</sub> = <span style="font-style:italic">y</span><sub><span style="font-style:italic">n</span></sub> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup><span style="font-style:italic">y</span><sub><span style="font-style:italic">n</span></sub></sup>−(1+<span style="font-style:italic">x</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup><span style="font-style:italic">y</span><sub><span style="font-style:italic">n</span></sub></sup></td></tr>
</table></td><td class="dcell">  </td></tr>
</table>
Comme <span style="font-style:italic">y</span><sub>0</sub> est proche à 1<span style="font-style:italic">e</span>−4 de <span style="font-style:italic">y</span>, on peut espérer avoir
une valeur approchée de <span style="font-style:italic">y</span> à 1<span style="font-style:italic">e</span>−16 en 2 itérations. Notez
que <span style="font-style:italic">y</span> est proche de 0, on est dans un domaine où le calcul
de <span style="font-style:italic">e</span><sup><span style="font-style:italic">y</span></sup> est rapide et précis et de plus la méthode de Newton
“corrige” les erreurs intermédiaires.
</li></ul><p>Nous sommes donc en mesure de calculer précisément le logarithme
ln(1+<span style="font-style:italic">x</span>) pour disons |<span style="font-style:italic">x</span>|&lt;1/2. Pour calculer <span style="font-style:italic">ln</span> sur ℝ<sup>+</sup>,
on se ramène à [1,2] en utilisant l’écriture
mantisse-exposant, puis si <span style="font-style:italic">x</span>∈[3/2,2] on peut en prendre la racine
carrée pour se retrouver dans l’intervalle souhaité.
On peut aussi effectuer une division par √<span style="text-decoration:overline">2</span>.</p><p>Remarquons que si <span style="font-style:italic">x</span> est connu à une erreur relative ε
près, comme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ln(<span style="font-style:italic">x</span>(1 ± ε))=ln(<span style="font-style:italic">x</span>) + ln(1 ± ε) </td></tr>
</table><p>
ln(<span style="font-style:italic">x</span>) est connu à une erreur absolue de 
|ln(1 ± ε)| ≈ ε. Si ln(<span style="font-style:italic">x</span>) est proche
de 0, on a une grande perte de précision relative.</p><p>Finalement, nous savons calculer ln et exp sous réserve
d’avoir dans une table la valeur de ln(2). Pour calculer
ln(2) précisément, on peut utiliser
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ln(2)=−<span style="font-style:italic">ln</span>(1/2)=−<span style="font-style:italic">ln</span>(1−1/2) </td></tr>
</table><p>
et le développement en série calculé en mode exact avec des
fractions à un ordre suffisant, on majore le reste en utilisant 
que le terme général de la série ln(1+<span style="font-style:italic">x</span>) est borné par
<span style="font-style:italic">M</span>=1 en <span style="font-style:italic">x</span>=1, donc d’après (<a href="#eq%3Amaj_serie_entiere">58</a>) :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">R</span><sub><span style="font-style:italic">n</span></sub>| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup><span style="font-style:italic">n</span></sup></td></tr>
</table></td></tr>
</table><p>
(on peut même obtenir 1/(<span style="font-style:italic">n</span>2<sup><span style="font-style:italic">n</span></sup>) car on a besoin de <span style="font-style:italic">M</span> uniquement
pour les termes d’ordre plus grand que <span style="font-style:italic">n</span>, on peut donc prendre <span style="font-style:italic">M</span>=1/<span style="font-style:italic">n</span>).
Par exemple, pour avoir ln(2) avec une mantisse de 80 bits,
on effectue une fois pour toutes avec un logiciel
de calcul formel :<br>
<code>a:=sum((1/2)^k/k,k=1..80)</code>|<br>
puis la division en base 2 avec 81 bits de précision
<code>iquo(numer(a)*2^81,denom(a))</code></p><p>Exercice : pour les fonctions trigonométriques, il faut une
méthode de calcul de π. On peut par exemple faire le calcul
de 16 arctan(1/5)−4arctan(1/239) en utilisant le développement
de la fonction arctan à un ordre suffisant.</p>
<!--TOC subsection id="sec279" Approximants de Padé.-->
<h3 id="sec279" class="subsection">24.5  Approximants de Padé.</h3><!--SEC END --><p><a id="hevea_default323"></a>
Soit une fonction <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) dont on connait le développement
de Taylor <span style="font-style:italic">B</span> en 0 à l’ordre <span style="font-style:italic">n</span>, on souhaiterait plutot
approcher <span style="font-style:italic">f</span> par une fraction <span style="font-style:italic">P</span>/<span style="font-style:italic">Q</span> avec degré(<span style="font-style:italic">P</span>) ≤ <span style="font-style:italic">d</span>
et degré(<span style="font-style:italic">Q</span>) ≤ <span style="font-style:italic">n</span>−<span style="font-style:italic">d</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>=<span style="font-style:italic">B</span>+<span style="font-style:italic">O</span>(<span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Q</span></td></tr>
</table></td><td class="dcell"> +<span style="font-style:italic">O</span>(<span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup>) </td></tr>
</table><p>
Si <span style="font-style:italic">Q</span>(0)=0, ceci équivaut à <span style="font-style:italic">P</span>=<span style="font-style:italic">BQ</span>+<span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup> <span style="font-style:italic">S</span> où <span style="font-style:italic">S</span>, <span style="font-style:italic">P</span>,<span style="font-style:italic">Q</span> sont
des polynômes inconnus. On reconnait une identité de type
Bézout pour les polynômes <span style="font-style:italic">A</span>=<span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup> et <span style="font-style:italic">B</span>.
On déroule l’algorithme d’Euclide itératif pour <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span>, on définit
donc 3 suites <span style="font-style:italic">U</span><sub><span style="font-style:italic">k</span></sub>, <span style="font-style:italic">V</span><sub><span style="font-style:italic">k</span></sub>, <span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span></sub> où <span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span></sub> est la suite des restes d’Euclide
de degrés strictement décroissants
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span>+2</sub>=<span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span></sub> − <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span>+1</sub>, <span style="font-style:italic">U</span><sub><span style="font-style:italic">k</span>+2</sub>=<span style="font-style:italic">U</span><sub><span style="font-style:italic">k</span></sub> − <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">U</span><sub><span style="font-style:italic">k</span>+1</sub>, <span style="font-style:italic">V</span><sub><span style="font-style:italic">k</span>+2</sub>=<span style="font-style:italic">V</span><sub><span style="font-style:italic">k</span></sub> − <span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">V</span><sub><span style="font-style:italic">k</span>+1</sub> </td></tr>
</table><p>
et les initialisations :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">U</span><sub>0</sub>=1, <span style="font-style:italic">U</span><sub>1</sub>=0, <span style="font-style:italic">V</span><sub>0</sub>=0, <span style="font-style:italic">V</span><sub>1</sub>=1, <span style="font-style:italic">R</span><sub>0</sub>=<span style="font-style:italic">A</span>, <span style="font-style:italic">R</span><sub>1</sub>=<span style="font-style:italic">B</span></td></tr>
</table><p>
On s’arrête au rang <span style="font-style:italic">N</span>+1 tel que degré(<span style="font-style:italic">R</span><sub><span style="font-style:italic">N</span></sub>)&gt;<span style="font-style:italic">d</span> et degré(<span style="font-style:italic">R</span><sub><span style="font-style:italic">N</span>+1</sub>) ≤ <span style="font-style:italic">d</span>.
Rappelons qu’on montre par récurrence que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">V</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span>+1</sub> − <span style="font-style:italic">V</span><sub><span style="font-style:italic">k</span>+1</sub> <span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span></sub> = (−1)<sup><span style="font-style:italic">k</span>+1</sup> <span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span>+1</sup> </td></tr>
</table><p>
D’autre part la suite des degrés des <span style="font-style:italic">V</span><sub><span style="font-style:italic">k</span></sub> est strictement croissante
à partir du rang 1 (car degré(<span style="font-style:italic">Q</span><sub><span style="font-style:italic">k</span></sub>)&gt;0), on en déduit que
degré(<span style="font-style:italic">V</span><sub><span style="font-style:italic">k</span>+1</sub>)+degré(<span style="font-style:italic">R</span><sub><span style="font-style:italic">k</span></sub>)=<span style="font-style:italic">n</span>+1 donc degré(<span style="font-style:italic">V</span><sub><span style="font-style:italic">N</span>+1</sub>) ≤ <span style="font-style:italic">n</span>−<span style="font-style:italic">d</span>.
On pose alors <span style="font-style:italic">P</span>=<span style="font-style:italic">R</span><sub><span style="font-style:italic">N</span>+1</sub> et <span style="font-style:italic">Q</span>=<span style="font-style:italic">V</span><sub><span style="font-style:italic">N</span>+1</sub>, qui vérifient
<span style="font-style:italic">P</span>=<span style="font-style:italic">BQ</span>+<span style="font-style:italic">AU</span><sub><span style="font-style:italic">N</span>+1</sub>.
Si <span style="font-style:italic">Q</span>(0) ≠ 0 on a existence d’une solution <span style="font-style:italic">P</span>/<span style="font-style:italic">Q</span>, 
et cette solution est alors
unique, car si on a 2 triplets solutions
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>=<span style="font-style:italic">BQ</span>+<span style="font-style:italic">AS</span>,  <span style="font-style:italic">P</span>′=<span style="font-style:italic">BQ</span>′+<span style="font-style:italic">AS</span>′,    <span style="font-style:italic">A</span>=<span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span>+1</sup></td></tr>
</table><p>
alors <span style="font-style:italic">PQ</span>′−<span style="font-style:italic">P</span>′<span style="font-style:italic">Q</span> est un multiple de <span style="font-style:italic">X</span><sup><span style="font-style:italic">n</span>+1</sup> donc nul pour des raisons
de degré, donc <span style="font-style:italic">P</span>/<span style="font-style:italic">Q</span>=<span style="font-style:italic">P</span>′/<span style="font-style:italic">Q</span>′.</p><p>Par exemple, pour <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup> et <span style="font-style:italic">n</span>=10, <span style="font-style:italic">d</span>=5, <code>pade(e^x,x,10,6)</code>
renvoie le quotient de deux polynômes de degré 5
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub>2</sub>+<span style="font-style:italic">P</span><sub>1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">P</span><sub>2</sub>−<span style="font-style:italic">P</span><sub>1</sub></td></tr>
</table></td><td class="dcell">,  <span style="font-style:italic">P</span><sub>2</sub>=30240+3360<span style="font-style:italic">x</span><sup>2</sup>+30<span style="font-style:italic">x</span><sup>4</sup>, <span style="font-style:italic">P</span><sub>1</sub>=<span style="font-style:italic">x</span>(15120+420<span style="font-style:italic">x</span><sup>2</sup>+<span style="font-style:italic">x</span><sup>4</sup>)</td></tr>
</table><p>
fraction que l’on peut évaluer en 12 opérations (5 additions, 1
soustraction, 5 multiplications et 1 division)
et qui donne une approximation de meilleure qualité que le
développement de Taylor à l’ordre 10.<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:40px;font-style:large">x:=0.5; X:=x*x; a:=(30X+3360)*X+30240;
b:=x*((X+420)*X+15120); (a+b)/(a-b); exp(0.5); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div><br>
Pour démontrer des estimations sur l’erreur <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)−<span style="font-style:italic">P</span>/<span style="font-style:italic">Q</span>, il n’existe
pas à ma connaissance de résultat explicite général. 
Pour la fonction exponentielle, on peut calculer l’erreur relative
<span style="font-style:italic">g</span>(<span style="font-style:italic">x</span>)=1−<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">x</span></sup><span style="font-style:italic">P</span>/<span style="font-style:italic">Q</span>
puis étudier la fonction.
</p><pre class="verbatim">P,Q:=fxnd(pade(exp(x),x,10,6));
g:=1-exp(-x)*P/Q; factor(g');
</pre><p>On en déduit que <span style="font-style:italic">g</span> est une fonction décroissante
(nulle en l’origine), son maximum en valeur absolue
est donc atteint aux bornes de l’intervalle d’étude, par
exemple sur [−1/4,1/4], l’erreur relative est majorée
par <code>3e-17</code>, il faudrait aller à l’ordre 12 pour
avoir la même précision avec Taylor donc faire 23 opérations,
quasiment le double. Visuellement, le graphe de l’exponentielle et de
l’approximation de Padé sont encore très proches pour <span style="font-style:italic">x</span>=5.
</p><pre class="verbatim">f(x):={
  local P1,P2,x2;
  x2:=x*x;
  P2:=30240+x2*(3360+30*x2);
  P1:=x*(15120+x2*(420+x2));
  retourne (P2+P1)/(P2-P1);
}:;
plot([f(x),exp(x)],x=-6..6,color=[blue,red]);
</pre>
<!--TOC subsection id="sec280" Autres applications-->
<h3 id="sec280" class="subsection">24.6  Autres applications</h3><!--SEC END --><p>
On peut calculer certaines intégrales de la même manière,
par exemple
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1/2</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">x</span><sup>3</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
mais aussi des fonctions définies par des intégrales (cas de nombreuses
fonctions spéciales).</p>
<!--TOC subsubsection id="sec281" Exemple : la fonction d’erreur (error fonction, <span style="font-family:monospace">erf</span>)-->
<h4 id="sec281" class="subsubsection">24.6.1  Exemple : la fonction d’erreur (error fonction, <span style="font-family:monospace">erf</span>)</h4><!--SEC END --><p><a id="hevea_default324"></a><a id="hevea_default325"></a>
Cette fonction est définie à une constante multiplicative près par :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span><sup>2</sup></sup>  <span style="font-style:italic">dt</span> </td></tr>
</table><p>
On peut développer en séries entières l’intégrand (rayon
de convergence +∞), puis intégrer terme
à terme, on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">+∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=0</td></tr>
</table></td><td class="dcell"> (−1)<sup><span style="font-style:italic">n</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2<span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>! (2<span style="font-style:italic">n</span>+1)</td></tr>
</table></td></tr>
</table><p>
Ce développement converge très rapidement pour |<span style="font-style:italic">x</span>|≤ 1.
Par contre, pour |<span style="font-style:italic">x</span>| grand, il faut calculer beaucoup de termes
avant que le reste soit suffisamment petit pour être négligeable,
et certains termes intermédiaires sont grands, ce qui provoque
une perte de précision qui peut rendre le résultat calculé
complètement faux. Contrairement à la fonction exponentielle,
il n’y a pas de possibilité de réduire l’argument à une plage
où la série converge vite. Il faut donc
</p><ul class="itemize"><li class="li-itemize">
soit utiliser des flottants multiprécision, avec une précision
augmentée de la quantité nécessaire pour avoir un résultat fiable
</li><li class="li-itemize">soit, pour les grandes valeurs de <span style="font-style:italic">x</span>, utiliser un développement
asymptotique (en puissances de 1/<span style="font-style:italic">x</span>) de
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span><sup>2</sup></sup>  <span style="font-style:italic">dt</span> </td></tr>
</table>
ainsi que 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span><sup>2</sup></sup>  <span style="font-style:italic">dt</span> =</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >π </td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table>
Le développement asymptotique
s’obtient par exemple en changeant de variable
<span style="font-style:italic">u</span>=<span style="font-style:italic">t</span><sup>2</sup> et en effectuant des intégrations par parties répétées
en intégrant <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">u</span></sup> et en dérivant <span style="font-style:italic">u</span><sup>−1/2</sup> et ses dérivées
successives. Ce type de développement asymptotique a la propriété
inverse du développement en 0: les termes successifs commencent
par décroitre avant de croitre et de tendre vers l’infini. Il faut
donc arrêter le développement à un rang donné (dépendant de <span style="font-style:italic">x</span>)
et il est impossible d’obtenir une précision meilleure pour cette
valeur de <span style="font-style:italic">x</span> par un développement asymptotique (on parle parfois de
développement des astronomes).
</li></ul><p><span style="font-weight:bold">Exercice </span>: donner une valeur approchée de <span style="font-style:italic">f</span>(1) à 1<span style="font-style:italic">e</span>−16 près.
Combien de termes faut-il calculer dans la somme pour trouver
une valeur approchée de <span style="font-style:italic">f</span>(7) à 1<span style="font-style:italic">e</span>−16 près ? Comparer la valeur
de <span style="font-style:italic">f</span>(7) et la valeur absolue du plus grand terme de la série,
quelle est la perte de précision relative si on effectue les
calculs en virgule flottante ? Combien de chiffres significatifs
faut-il utiliser pour assurer une précision finale de 16 chiffres
en base 10 ? Calculer le développement asymptotique en l’infini
et déterminer un encadrement de <span style="font-style:italic">f</span>(7) par ce développement. Combien
de termes faut-il calculer pour déterminer <span style="font-style:italic">f</span>(10) à 1<span style="font-style:italic">e</span>−16 près
par le développement asymptotique et par le développement en séries ?
Quelle est la meilleure méthode pour calculer <span style="font-style:italic">f</span>(10) ?</p>
<!--TOC subsubsection id="sec282" Recherche de solutions d’équations différentielles-->
<h4 id="sec282" class="subsubsection">24.6.2  Recherche de solutions d’équations différentielles</h4><!--SEC END --><p>
On peut aussi appliquer les techniques ci-dessus pour calculer
des solutions de certaines équations différentielles dont les
solutions ne s’expriment pas à l’aide des fonctions usuelles,
on remplace dans l’équation la fonction inconnue par son 
développement en séries et on cherche une relation de récurrence
entre <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>+1</sub> et <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>. Si on arrive à montrer par exemple
qu’il y a une solution ayant un développement alternée, 
ou plus généralement,
si on a une majoration |<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>+1</sub>/<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>|&lt;<span style="font-style:italic">C</span>, alors le reste de la
série entière est majoré par |<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup>|/(1−|<span style="font-style:italic">Cx</span>|) lorsque
|<span style="font-style:italic">x</span>|&lt;1/<span style="font-style:italic">C</span>, on peut alors calculer des valeurs approchées
de la fonction solution à la précision souhaitée en utilisant
le développement en séries entières.</p>
<!--TOC subsubsection id="sec283" Exemple : fonctions de Bessel d’ordre entier-->
<h4 id="sec283" class="subsubsection">24.6.3  Exemple : fonctions de Bessel d’ordre entier</h4><!--SEC END --><p><a id="hevea_default326"></a>
Soit <span style="font-style:italic">m</span> un entier positif fixé, on considère l’équation
différentielle
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span><sup>2</sup> <span style="font-style:italic">y</span>′′ + <span style="font-style:italic">x</span> <span style="font-style:italic">y</span>′ + (<span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">m</span><sup>2</sup>)<span style="font-style:italic">y</span>=0 </td></tr>
</table><p>
dont on cherche une solution série entière 
<span style="font-style:italic">y</span>=∑<sub><span style="font-style:italic">k</span>=0</sub><sup>∞</sup><span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup> . En remplacant dans l’équation, si
<span style="font-style:italic">x</span> est dans le rayon de convergence de la série (rayon supposé
non nul), on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">k</span>(<span style="font-style:italic">k</span>−1)<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">k</span> <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup> 
+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">x</span><sup>2</sup>−<span style="font-style:italic">m</span><sup>2</sup>) <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup> =0
</td></tr>
</table><p>
soit encore
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">k</span><sup>2</sup>−<span style="font-style:italic">m</span><sup>2</sup>+<span style="font-style:italic">x</span><sup>2</sup>) <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup>  </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">−<span style="font-style:italic">m</span><sup>2</sup> <span style="font-style:italic">a</span><sub>0</sub> + (1−<span style="font-style:italic">m</span><sup>2</sup>)<span style="font-style:italic">a</span><sub>1</sub> <span style="font-style:italic">x</span> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=2</td></tr>
</table></td><td class="dcell">[(<span style="font-style:italic">k</span><sup>2</sup>−<span style="font-style:italic">m</span><sup>2</sup>) <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub> +<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span>−2</sub>]<span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup> 
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Par exemple, prenons le cas <span style="font-style:italic">m</span>=0. On a alors <span style="font-style:italic">a</span><sub>0</sub> quelconque, <span style="font-style:italic">a</span><sub>1</sub>
nul et pour <span style="font-style:italic">k</span>≥ 2
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub> = − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span>−2</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
</table></td></tr>
</table><p>
Donc tous les <span style="font-style:italic">a</span> d’indice impair sont nuls. Les pairs sont non nuls
si <span style="font-style:italic">a</span><sub>0</sub>≠ 0, et ils sont de signe alterné.
Soit <span style="font-style:italic">x</span> fixé, on observe que pour 2<span style="font-style:italic">k</span> &gt; |<span style="font-style:italic">x</span>|,
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">a</span><sub>2<span style="font-style:italic">k</span></sub> <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">k</span></sup>| &lt; |<span style="font-style:italic">a</span><sub>2<span style="font-style:italic">k</span>−2</sub> <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">k</span>−2</sup>| </td></tr>
</table><p>
donc la série ∑<sub><span style="font-style:italic">k</span>=0</sub><sup>∞</sup><span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup> est alternée à partir
du rang partie entière de |<span style="font-style:italic">x</span>| plus un. Donc elle converge pour
tout <span style="font-style:italic">x</span> (le rayon de convergence de <span style="font-style:italic">y</span> est +∞) 
et le reste de la somme jusqu’à l’ordre 2<span style="font-style:italic">n</span> est
inférieur en valeur absolue à :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">R</span><sub>2<span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>)| ≤ |<span style="font-style:italic">a</span><sub>2<span style="font-style:italic">n</span>+2</sub> <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">n</span>+2</sup>| </td></tr>
</table><p>
Par exemple, pour avoir une valeur approchée à 1<span style="font-style:italic">e</span>−10 près de
<span style="font-style:italic">y</span>(<span style="font-style:italic">x</span>) pour <span style="font-style:italic">a</span><sub>0</sub>=1 et |<span style="font-style:italic">x</span>|≤ 1, on calcule <span style="font-style:italic">y</span>=∑<sub><span style="font-style:italic">k</span>=0</sub><sup>2<span style="font-style:italic">n</span></sup> <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup> ,
on s’arrête au rang <span style="font-style:italic">n</span> tel que 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">a</span><sub>2<span style="font-style:italic">n</span>+2</sub> <span style="font-style:italic">x</span><sup>2<span style="font-style:italic">n</span>+2</sup>| ≤ |<span style="font-style:italic">a</span><sub>2<span style="font-style:italic">n</span>+2</sub>| ≤ 10<sup>−10</sup> </td></tr>
</table><p>
On remarque que :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">a</span><sub>2<span style="font-style:italic">n</span></sub> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(−1)<sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup>2</sup> 4<sup>2</sup> ... (2<span style="font-style:italic">n</span>)<sup>2</sup></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(−1)<sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup>2<span style="font-style:italic">n</span></sup> <span style="font-style:italic">n</span>!<sup>2</sup></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
donc <span style="font-style:italic">n</span>=7 convient.</p><p>Pour <span style="font-style:italic">m</span> ≠ 0, on peut faire un raisonnement analogue (les
calculs sont un peu plus compliqués).</p><p>On a ainsi trouvé une solution <span style="font-style:italic">y</span><sub>0</sub> de l’équation
différentielle de départ dont on peut facilement calculer
une valeur approchée (aussi facilement que par exemple la fonction sinus
pour |<span style="font-style:italic">x</span>| ≤ 1), 
on peut alors trouver toutes les solutions de l’équation
différentielle (en posant <span style="font-style:italic">y</span>=<span style="font-style:italic">y</span><sub>0</sub> <span style="font-style:italic">z</span> et en cherchant <span style="font-style:italic">z</span>).</p><p><span style="font-weight:bold">Exercice :</span> faire de même pour les solutions de
<span style="font-style:italic">y</span>′′−<span style="font-style:italic">xy</span>=0 (fonctions de Airy).</p>
<!--TOC subsection id="sec284" Développements asymptotiques et séries
divergentes-->
<h3 id="sec284" class="subsection">24.7  Développements asymptotiques et séries
divergentes</h3><!--SEC END --><p><a id="hevea_default327"></a>
Un développement asymptotique est une généralisation d’un développement de Taylor, par exemple
lorsque le point de développement est en l’infini. De nombreuses fonctions ayant
une limite en l’infini admettent un développement asymptotique en l’infini, mais ces
développements sont souvent des séries qui semblent commencer par converger
mais sont divergentes. Ce type de développement s’avère néanmoins très utile lorsqu’on
n’a pas besoin d’une trop grande précision sur la valeur de la fonction.</p><p>Nous allons illustrer ce type de développement sur un exemple, la fonction 
<span style="font-weight:bold">exponentielle intégrale</span><a id="hevea_default328"></a><a id="hevea_default329"></a>, 
définie à une constante près par
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> </td></tr>
</table><p>
On peut montrer que l’intégrale existe bien, car l’intégrand est positif et inférieur à <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>
(qui admet −<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup> comme primitive, cette primitive ayant une limite en +∞).
Pour trouver le développement asymptotique de <span style="font-style:italic">f</span> en +∞, on effectue des intégrations
par parties répétées, en intégrant l’exponentielle et en dérivant la fraction rationnelle
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">[</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">]<sub><span style="font-style:italic">x</span></sub><sup>+∞</sup> − </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">−<span style="font-style:italic">t</span><sup>2</sup></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup>−<span style="font-style:italic">x</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> − </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup>−<span style="font-style:italic">x</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> − ([</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup></td></tr>
</table></td><td class="dcell">]<sub><span style="font-style:italic">x</span></sub><sup>+∞</sup> − </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−2<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">−<span style="font-style:italic">t</span><sup>3</sup></td></tr>
</table></td><td class="dcell">) </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup>−<span style="font-style:italic">x</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup>−<span style="font-style:italic">x</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>3</sup></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >... </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">e</span><sup>−<span style="font-style:italic">x</span></sup></td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>3</sup></td></tr>
</table></td><td class="dcell"> + ... + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(−1)<sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">n</span>!</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
− </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(−1)<sup><span style="font-style:italic">n</span></sup> (<span style="font-style:italic">n</span>+1)!<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup><span style="font-style:italic">n</span>+2</sup></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">S</span>(<span style="font-style:italic">x</span>) + <span style="font-style:italic">R</span>(<span style="font-style:italic">x</span>)
</td></tr>
</table></td></tr>
</table><p>
où
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:Eiinf"></a>
<span style="font-style:italic">S</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">x</span></sup>
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>3</sup></td></tr>
</table></td><td class="dcell"> + ... + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(−1)<sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">n</span>!</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">, 
   <span style="font-style:italic">R</span>(<span style="font-style:italic">x</span>)=− </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(−1)<sup><span style="font-style:italic">n</span></sup> (<span style="font-style:italic">n</span>+1)!<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup><span style="font-style:italic">n</span>+2</sup></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> 
    (59)</td></tr>
</table><p>
Le développement en séries est divergent puisque pour <span style="font-style:italic">x</span>&gt;0 fixé et <span style="font-style:italic">n</span> tendant vers l’infini
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center">lim</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>→ +∞</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup></td></tr>
</table></td><td class="dcell"> = +∞</td></tr>
</table><p>
mais si <span style="font-style:italic">x</span> est grand, au début la série semble converger, de manière très rapide :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> &gt;&gt; </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> &gt;&gt; </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>3</sup></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
On peut utiliser <span style="font-style:italic">S</span>(<span style="font-style:italic">x</span>) comme valeur approchée de <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) pour <span style="font-style:italic">x</span> grand si on sait majorer
<span style="font-style:italic">R</span>(<span style="font-style:italic">x</span>) par un nombre suffisamment petit. On a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| <span style="font-style:italic">R</span>(<span style="font-style:italic">x</span>) | ≤ </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+2</sup></td></tr>
</table></td><td class="dcell">
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1)!<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">x</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+2</sup></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
On retrouve une majoration du type de celle des séries alternées, 
l’erreur relative est inférieure
à la valeur absolue du dernier terme sommé divisé par <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">x</span></sup>/<span style="font-style:italic">x</span>. 
Pour <span style="font-style:italic">x</span> fixé assez grand, il 
faut donc trouver un rang <span style="font-style:italic">n</span>, s’il en existe un, 
tel que (<span style="font-style:italic">n</span>+1)!/<span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup>&lt;є où
є est la précision relative que l’on s’est fixée.
Par exemple, si <span style="font-style:italic">x</span>≥ 100, <span style="font-style:italic">n</span>=11 convient pour 
є=12!/100<sup>12</sup>=5<span style="font-style:italic">e</span>−16 (à peu près
la précision relative d’un “double”).
Ceci permet d’avoir une approximation de la fonction avec une bonne
précision et peu de calculs, mais contrairement aux séries entières,
il n’est pas possible d’améliorer cette précision de manière
arbitraire en poussant le développement plus loin, il y a une
précision maximale possible (qui dépend de <span style="font-style:italic">x</span>).</p><p>Ce type de développement asymptotique peut être effectué pour
d’autres fonctions du même type, par exemple
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span><sup>2</sup></sup>  <span style="font-style:italic">dt</span>,    </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">sin(<span style="font-style:italic">t</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span>,    ... </td></tr>
</table><p><span style="font-weight:bold">Digression: calcul approché de la constante d’Euler
</span>γ<a id="hevea_default330"></a><br>
On peut montrer que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:def_gamma"></a>
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center">lim</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>→ +∞</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>,    <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=1</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> − ln(<span style="font-style:italic">n</span>) 
    (60)</td></tr>
</table><p>
existe (par exemple en cherchant un équivalent de <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> qui vaut 
−1/2<span style="font-style:italic">n</span><sup>2</sup>)
et on définit γ comme sa limite. Malheureusement, la convergence
est très lente et cette définition n’est pas applicable pour obtenir la valeur
de γ avec une très grande précision.
Il y a un lien entre γ et la fonction exponentielle intégrale, plus précisément
lorsque <span style="font-style:italic">x</span>→ 0, <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) admet une singularité en −ln(<span style="font-style:italic">x</span>),
plus précisément <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)+ln(<span style="font-style:italic">x</span>)
admet un développement en séries (de rayon de convergence +∞), car :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)+ln(<span style="font-style:italic">x</span>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> + </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">1</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> + </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">1</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span>
− </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span>
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Que vaut la constante du membre de droite :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">C</span>=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>−1)</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> + </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> </td></tr>
</table><p>
Il se trouve que <span style="font-style:italic">C</span>=−γ (voir plus bas une démonstration condensée) et donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:gamma"></a>
γ= </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> −<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)−ln(<span style="font-style:italic">x</span>)
    (61)</td></tr>
</table><p>
Pour obtenir une valeur approchée de γ, il suffit donc de prendre un <span style="font-style:italic">x</span> assez grand
pour pouvoir calculer <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) par son développement asymptotique à la précision requise,
puis de calculer l’intégrale du membre de droite par le développement en séries en <span style="font-style:italic">x</span>=0
(en utilisant une précision intermédiaire plus grande puisque ce développement en séries
va sembler diverger au début avant de converger pour <span style="font-style:italic">n</span> suffisamment grand).
Par exemple, on pose <span style="font-style:italic">x</span>=13, on calcule <span style="font-style:italic">f</span>(13) par (<a href="#eq%3AEiinf">59</a>)
avec <span style="font-style:italic">n</span>=13 (qui correspond au moment où le terme général
de la série est minimum puisque le rapport de deux termes successifs
est en <span style="font-style:italic">n</span>/<span style="font-style:italic">x</span>)
et une erreur absolue inférieure à <span style="font-style:italic">e</span><sup>−13</sup> 13!/13<sup>14</sup>=4<span style="font-style:italic">e</span>−12
</p><div class="center">
<span style="font-style:italic">f</span>(13) ≈ <code>exp(-13)*sum((-1)^n*n!/13.^(n+1),n=0..13)</code>
</div><p>
puis on remplace dans (<a href="#eq%3Agamma">61</a>), avec 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">x</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> = 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=0</td></tr>
</table></td><td class="dcell"> (−1)<sup><span style="font-style:italic">n</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">n</span>+1) (<span style="font-style:italic">n</span>+1)!</td></tr>
</table></td></tr>
</table><p>
dont on obtient une valeur approchée, 
en faisant la somme jusqu’au rang 49 (pour lequel
le terme général est de l’ordre de <code>1e-12</code>),
le reste de cette somme <span style="font-style:italic">R</span><sub>50</sub> est positif et est inférieur à
<span style="font-family:monospace">(-1)</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">50*13.</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">51/51/51!)</span> qui est de l’ordre de 
<code>8e-12</code>
</p><div class="center">
<code>evalf(sum((-1)^n*13^(n+1)/(n+1)/(n+1)!,n=0..49))</code>
</div><p>
La somme argument de <code>evalf</code>
étant exacte, il n’y a pas de problèmes de perte de précision,
on peut aussi faire les calculs intermédiaires en arithmétique approchée,
on doit alors prendre 4 chiffres significatifs de plus
pour tenir compte de la valeur du plus grand terme
sommé dans la série, terme que l’on détermine par exemple par
</p><div class="center">
<span style="font-family:monospace">seq(13.</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">(n+1)/(n+1)/(n+1)!,n=0..20)</span>
</div><p> 
ce terme vaut <code>13^11/11/11!</code> soit 4000 environ)
</p><div class="center">
<code>Digits:=16; sum((-1)^n*13.^(n+1)/(n+1)/(n+1)!,n=0..49)</code>
</div><p>
On obtient finalement comme valeur approchée de γ
</p><div class="center">
<code>-exp(-13)*sum((-1)^n*n!/13.^(n+1),n=0..13)-ln(13)+</code><br>
<code>  sum((-1)^n*13^(n+1)/(n+1)/(n+1)!,n=0..49)</code>
</div><p>
soit <code>0.577215664897</code> avec une erreur inférieure à <code>1.2e-11</code>.
Bien entendu, cette méthode est surtout intéressante si on veut calculer
un grand nombre de décimales de la constante d’Euler, sinon
on peut par exemple appliquer la méthode d’accélération de Richardson à
la suite convergente (<a href="#eq%3Adef_gamma">60</a>) qui définit γ
ou d’autres méthodes d’accélération (en transformant par
exemple la série en série alternée). On calcule alors
de deux manières différentes <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) pour <span style="font-style:italic">x</span> plus grand (déterminé
par la précision qu’on peut obtenir par le développement
aymptotique de <span style="font-style:italic">f</span>).</p><p>On peut calculer π de la même manière avec le développement 
en séries et asymptotique
de la fonction <span style="font-weight:bold">sinus intégral</span><a id="hevea_default331"></a><a id="hevea_default332"></a> (on remplace exponentielle par sinus dans
la définition de <span style="font-style:italic">f</span>) et l’égalité (dont un schéma de preuve est aussi
donné plus bas)
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:Siinf"></a>
</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">sin(<span style="font-style:italic">t</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">
    (62)</td></tr>
</table><p><span style="font-weight:bold">Calcul de </span><span style="font-style:italic">C</span><span style="font-weight:bold"> (et preuve de (</span><a href="#eq%3ASiinf"><span style="font-weight:bold">62</span></a><span style="font-weight:bold">))</span>:<br>
Pour cela on effectue une intégration par parties, cette fois en intégrant 1/<span style="font-style:italic">t</span>
et en dérivant l’exponentielle (moins 1 dans la première intégrale).
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">C</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>−1)</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> + </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span></td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">[(<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>−1)ln(<span style="font-style:italic">t</span>)]<sub>0</sub><sup>1</sup> +</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> ln(<span style="font-style:italic">t</span>) <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>  <span style="font-style:italic">dt</span> + [<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup> ln(<span style="font-style:italic">t</span>)]<sub>1</sub><sup>+∞</sup>
+</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">1</td></tr>
</table></td><td class="dcell"> ln(<span style="font-style:italic">t</span>) <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>  <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> ln(<span style="font-style:italic">t</span>) <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>  <span style="font-style:italic">dt</span>
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Pour calculer cette intégrale, on utilise
l’égalité (qui se démontre par récurrence en faisant une 
intégration par parties) :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">n</span>!= </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">t</span><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>  <span style="font-style:italic">dt</span> </td></tr>
</table><p>
On va à nouveau intégrer par parties,
on intègre un facteur multiplicatif 1 
et on dérive l’intégrand, on simplifie, puis
on intègre <span style="font-style:italic">t</span> et on dérive l’autre terme, puis <span style="font-style:italic">t</span><sup>2</sup>/2, etc. 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">C</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">[<span style="font-style:italic">te</span><sup>−<span style="font-style:italic">t</span></sup> ln(<span style="font-style:italic">t</span>)]<sub>0</sub><sup>+∞</sup> − </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">t</span> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">−ln(<span style="font-style:italic">t</span>))  <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">0 − </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>  <span style="font-style:italic">dt</span> + </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">t</span> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup> ln(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">−1 + [</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup> ln(<span style="font-style:italic">t</span>)]<sub>0</sub><sup>+∞</sup> 
− </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">−ln(<span style="font-style:italic">t</span>))  <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">−1 − </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup> +  </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup> ln(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">−1 − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> +  </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup> ln(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" >...</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">−1 − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> − ... −  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup> ln(<span style="font-style:italic">t</span>)  <span style="font-style:italic">dt</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">−1 − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> − ... −  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell"> + ln(<span style="font-style:italic">n</span>) + <span style="font-style:italic">I</span><sub><span style="font-style:italic">n</span></sub>
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
où
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span><sub><span style="font-style:italic">n</span></sub>=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span><sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup> (ln(<span style="font-style:italic">t</span>)−ln(<span style="font-style:italic">n</span>))  <span style="font-style:italic">dt</span> </td></tr>
</table><p>
Pour déterminer <span style="font-style:italic">I</span><sub><span style="font-style:italic">n</span></sub> on fait le changement de variables <span style="font-style:italic">t</span>=<span style="font-style:italic">nu</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">I</span><sub><span style="font-style:italic">n</span></sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">nu</span>)<sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">nu</span></sup> ln(<span style="font-style:italic">u</span>) <span style="font-style:italic">n</span> <span style="font-style:italic">du</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span><sup><span style="font-style:italic">n</span>+1</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup><span style="font-style:italic">n</span>(<span style="font-style:italic">ln</span>(<span style="font-style:italic">u</span>)−<span style="font-style:italic">u</span>)</sup> ln(<span style="font-style:italic">u</span>)  <span style="font-style:italic">du</span> 
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Or en faisant le même changement de variables <span style="font-style:italic">t</span>=<span style="font-style:italic">nu</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">n</span>!= </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">t</span><sup><span style="font-style:italic">n</span></sup> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup>  <span style="font-style:italic">dt</span> = <span style="font-style:italic">n</span><sup><span style="font-style:italic">n</span>+1</sup> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup><span style="font-style:italic">n</span>(<span style="font-style:italic">ln</span>(<span style="font-style:italic">u</span>)−<span style="font-style:italic">u</span>)</sup>  <span style="font-style:italic">du</span>
</td></tr>
</table><p>
Donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span><sub><span style="font-style:italic">n</span></sub>= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup><span style="font-style:italic">n</span>(<span style="font-style:italic">ln</span>(<span style="font-style:italic">u</span>)−<span style="font-style:italic">u</span>)</sup> ln(<span style="font-style:italic">u</span>)  <span style="font-style:italic">du</span></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup><span style="font-style:italic">n</span>(<span style="font-style:italic">ln</span>(<span style="font-style:italic">u</span>)−<span style="font-style:italic">u</span>)</sup>  <span style="font-style:italic">du</span></td></tr>
</table></td></tr>
</table></td><td class="dcell">  </td></tr>
</table><p>
Lorsque <span style="font-style:italic">n</span> tend vers l’infini, on peut montrer que <span style="font-style:italic">I</span><sub><span style="font-style:italic">n</span></sub> → 0, en effet les intégrales
sont équivalentes à leur valeur sur un petit intervalle autour de <span style="font-style:italic">u</span>=1, point où l’argument
de l’exponentielle est maximal, 
et comme l’intégrand du numérateur a une amplitude ln(<span style="font-style:italic">u</span>) qui s’annule en <span style="font-style:italic">u</span>=1, 
il devient négligeable devant le dénominateur. Finalement on a bien <span style="font-style:italic">C</span>=−γ.</p><p>On peut remarquer qu’en faisant le même calcul que <span style="font-style:italic">C</span> 
mais en remplacant <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">t</span></sup> par <span style="font-style:italic">e</span><sup>−α <span style="font-style:italic">t</span></sup> pour ℜ(α)&gt;0, donne
lim<span style="font-style:italic">I</span><sub><span style="font-style:italic">n</span></sub>=−ln(α) (car le point critique où la dérivée
de la phase s’annule est alors 1/α). Ceci peut aussi se vérifier
pour α réel en faisant le changement de variables α <span style="font-style:italic">t</span>=<span style="font-style:italic">u</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">e</span><sup>−α <span style="font-style:italic">t</span></sup>−1)</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> + </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−α <span style="font-style:italic">t</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> 
= −γ −ln(α) </td></tr>
</table><p>
En faisant tendre α vers −<span style="font-style:italic">i</span>, −ln(α) 
tend vers ln(<span style="font-style:italic">i</span>)=<span style="font-style:italic">i</span>π/2 et on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">e</span><sup><span style="font-style:italic">it</span></sup>−1)</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> + </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup><span style="font-style:italic">i</span> <span style="font-style:italic">t</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dt</span> 
= −γ + <span style="font-style:italic">i</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
dont la partie imaginaire nous donne (<a href="#eq%3ASiinf">62</a>), et la
partie réelle une autre identité sur γ faisant intervenir
la fonction cosinus intégral.</p>
<!--TOC subsection id="sec285" Séries formelles.-->
<h3 id="sec285" class="subsection">24.8  Séries formelles.</h3><!--SEC END --><p><a id="hevea_default333"></a> <a id="hevea_default334"></a>
On peut aussi s’intéresser aux séries d’un point de vue purement
algébrique en mettant de coté tous
les aspects liés à la convergence. On parle alors de série
formelle. Si le corps de base est de caractéristique quelconque
on peut faire les opérations arithmétiques usuelles sur les
séries formelles ∑<sub><span style="font-style:italic">k</span>≥ 0</sub> <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup>. Si la caractéristique
est nulle, on peut également calculer les fonctions usuelles.
Dans Xcas, on déclare la variable de série formelle par la commande
<code>series</code> avec en argument le caractère désignant la variable, 
par exemple <code>series("h")</code> utilisera <code>h</code> comme variable,
<code>series("h",8)</code> utilisera <code>h</code> comme variable
et fixera l’ordre par défaut pour les développements à 8. Si la
variable <code>O</code> n’est pas affectée, elle sera définie pour donner
l’ordre de la série. Ainsi <code>1+h+O(h^7)</code> sera une série
dont on connait les termes jusqu’à l’ordre 6 inclus.
Les opérations usuelles sont implémentées dans Xcas
</p><ul class="itemize"><li class="li-itemize">
addition <code>+</code>, opposé <code>-</code>, multiplication <code>*</code>
</li><li class="li-itemize">inverse <code>inv</code> 
si le coefficient de puissance 0 n’est pas inversible, 
Xcas renvoie une série de Laurent
∑<sub><span style="font-style:italic">k</span>≥ −<span style="font-style:italic">N</span></sub> <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup>.
</li><li class="li-itemize">composition de deux séries <code>@</code>
</li><li class="li-itemize">inverse pour la composition <code>revert</code>
</li><li class="li-itemize">les conversions se font avec la commande <code>convert</code>, par
exemple <code>a:=convert(sin(x),series,x=0,8)</code>,
<code>b:=convert(a,polynom)</code>.
</li></ul><p>
On peut aussi appliquer les fonctions usuelles en caractéristique 0, par
exemple
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">restart;series("h"); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">a:=ln(1+h+O(h^8)); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">exp(a); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
Pour travailler avec un autre corps de base, il suffit de donner des
coefficients dans ce corps. Si la caractéristique du corps est assez
grande, les fonctions usuelles sont aussi applicables.
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">GF(11,3); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">a:=ln(1+g*h+O(h^6)); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">exp(a); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div></p><p>Les opérations sur les séries sont implémentées sans optimisation
particulière, leur utilisation principale dans Xcas étant le
calcul de développement de Taylor ou asymptotique sur ℚ.</p>
<!--TOC section id="sec286" La transformée de Fourier discrète.-->
<h2 id="sec286" class="section">25  La transformée de Fourier discrète.</h2><!--SEC END --><p>
<a id="sec:dft"></a>
<a id="hevea_default335"></a><a id="hevea_default336"></a><a id="hevea_default337"></a>
</p>
<!--TOC subsection id="sec287" Définition et propriétés-->
<h3 id="sec287" class="subsection">25.1  Définition et propriétés</h3><!--SEC END --><p>
Soit <span style="font-style:italic">N</span> un entier fixé. Une suite <span style="font-style:italic">x</span> périodique de période <span style="font-style:italic">N</span> est
déterminée par le vecteur <span style="font-style:italic">x</span>=[<span style="font-style:italic">x</span><sub>0</sub>,<span style="font-style:italic">x</span><sub>1</sub>,...<span style="font-style:italic">x</span><sub><span style="font-style:italic">N</span>−1</sub>].
La transformée de Fourier discréte (DFT) notée <span style="font-style:italic">F</span><sub><span style="font-style:italic">N</span></sub> fait correspondre 
à une suite <span style="font-style:italic">x</span> périodique de période <span style="font-style:italic">N</span> une autre suite <span style="font-style:italic">y</span>
périodique de période <span style="font-style:italic">N</span>, définie pour <span style="font-style:italic">k</span>=0..<span style="font-style:italic">N</span>−1 par :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">F</span><sub><span style="font-style:italic">N</span></sub>(<span style="font-style:italic">x</span>))<sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">k</span>· <span style="font-style:italic">j</span></sup>,
</td></tr>
</table><p>
où ω<sub><span style="font-style:italic">N</span></sub> est une racine <span style="font-style:italic">N</span>-ième primitive de l’unité,
on prend ω=<span style="font-style:italic">e</span><sup>2<span style="font-style:italic">i</span>π/<span style="font-style:italic">N</span></sup> si <span style="font-style:italic">x</span> est à coefficients réels
ou complexes.</p><p>On observe que si la suite <span style="font-style:italic">x</span> est la suite des valeurs d’une fonction
périodique <span style="font-style:italic">f</span> sur une discrétisation de la période, alors
la transformée de Fourier discrète est la suite des valeurs approchées
des coefficients de Fourier obtenus en appliquant la méthode des
trapèzes sur cette discrétisation.</p><p>Cette transformation est linéaire, la transformée de la somme de 2
suites est la somme des transformées, et la transformée du produit
par une constante d’une suite 
est le produit par cette constante de la transformée
de la suite.</p><p>La transformée de Fourier discréte <span style="font-style:italic">F</span><sub><span style="font-style:italic">N</span></sub> est une transformation 
bijective dont la réciproque est donnée par :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">F</span><sub><span style="font-style:italic">N</span></sub><sup>−1</sup>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">F</span><sub><span style="font-style:italic">N</span></sub></td></tr>
</table></td><td class="dcell">,   
(<span style="font-style:italic">F</span><sub><span style="font-style:italic">N</span></sub><sup>−1</sup>(<span style="font-style:italic">y</span>))<sub><span style="font-style:italic">k</span></sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">y</span><sub><span style="font-style:italic">j</span></sub>ω<sub><span style="font-style:italic">N</span></sub><sup><span style="font-style:italic">k</span>· <span style="font-style:italic">j</span></sup>
</td></tr>
</table><p>
On le prouve en remplaçant <span style="font-style:italic">y</span> par sa valeur :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >(<span style="font-style:italic">F</span><sub><span style="font-style:italic">N</span></sub><sup>−1</sup>(<span style="font-style:italic">y</span>))<sub><span style="font-style:italic">k</span></sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">l</span></sub> ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">j</span>· <span style="font-style:italic">l</span></sup>
ω<sub><span style="font-style:italic">N</span></sub><sup><span style="font-style:italic">k</span>· <span style="font-style:italic">j</span></sup> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">l</span></sub> ω<sub><span style="font-style:italic">N</span></sub><sup><span style="font-style:italic">j</span> (<span style="font-style:italic">k</span>−<span style="font-style:italic">l</span>)</sup> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">l</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> (ω<sub><span style="font-style:italic">N</span></sub><sup>(<span style="font-style:italic">k</span>−<span style="font-style:italic">l</span>)</sup>)<sup><span style="font-style:italic">j</span></sup> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">l</span></sub> 
</td><td class="dcell">⎧<br>
⎪<br>
⎪<br>
⎨<br>
⎪<br>
⎪<br>
⎩</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">1−(ω<sub><span style="font-style:italic">N</span></sub><sup>(<span style="font-style:italic">k</span>−<span style="font-style:italic">l</span>)</sup>)<sup><span style="font-style:italic">N</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−ω<sub><span style="font-style:italic">N</span></sub><sup>(<span style="font-style:italic">k</span>−<span style="font-style:italic">l</span>)</sup></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >si</td><td style="text-align:left;white-space:nowrap" >ω<sub><span style="font-style:italic">N</span></sub><sup>(<span style="font-style:italic">k</span>−<span style="font-style:italic">l</span>)</sup>≠ 1 </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">N</span></td><td style="text-align:center;white-space:nowrap" >si</td><td style="text-align:left;white-space:nowrap" >ω<sub><span style="font-style:italic">N</span></sub><sup>(<span style="font-style:italic">k</span>−<span style="font-style:italic">l</span>)</sup> = 1 
</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Or si ω<sub><span style="font-style:italic">N</span></sub><sup><span style="font-style:italic">k</span>−<span style="font-style:italic">l</span></sup>=<span style="font-style:italic">e</span><sup>2<span style="font-style:italic">i</span>π(<span style="font-style:italic">k</span>−<span style="font-style:italic">l</span>)/<span style="font-style:italic">N</span></sup>=1 si et seulement si <span style="font-style:italic">k</span>=<span style="font-style:italic">l</span>
d’où le résultat.</p><p><span style="font-weight:bold">Remarque</span> : dans le cas complexe ω=<span style="font-style:italic">e</span><sup>2<span style="font-style:italic">i</span>π/<span style="font-style:italic">N</span></sup>, 
on peut interpréter la DFT
en termes du produit scalaire hermitien
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;<span style="font-style:italic">x</span>|<span style="font-style:italic">y</span>&gt;=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">x</span></td></tr>
</table></td><td class="dcell"><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">y</span><sub><span style="font-style:italic">j</span></sub></td></tr>
</table><p>
sur l’espace ℂ<sup><span style="font-style:italic">N</span></sup>, on a une base orthogonale donnée par 
les { <span style="font-style:italic">W</span><sub><span style="font-style:italic">k</span></sub>=(ω<sup><span style="font-style:italic">jk</span></sup>)<sub><span style="font-style:italic">j</span>=0..<span style="font-style:italic">N</span>−1</sub>, <span style="font-style:italic">k</span>=0..<span style="font-style:italic">N</span>−1}, la DFT d’une suite <span style="font-style:italic">x</span> est le calcul
des produits scalaires &lt;<span style="font-style:italic">W</span><sub><span style="font-style:italic">k</span></sub>|<span style="font-style:italic">x</span>&gt;, et la récriproque est l’écriture
de <span style="font-style:italic">x</span> dans cette base orthogonale.</p><p><span style="font-weight:bold">Propriété</span><br>
La transformée de Fourier discrète d’une suite réelle vérifie
<span style="font-style:italic">y</span><sub><span style="font-style:italic">N</span>−<span style="font-style:italic">k</span></sub>=<span style="text-decoration:overline"><span style="font-style:italic">y</span></span><sub><span style="text-decoration:overline"><span style="font-style:italic">k</span></span></sub>.<br>
La preuve est immédiate en appliquant la définition.</p><p>Un des intérêts de la DFT est de mettre en évidence rapidement
d’éventuelles périodicités de <span style="font-style:italic">x</span> divisant <span style="font-style:italic">N</span>. Plus précisément
soit <span style="font-style:italic">j</span> est un entier divisant <span style="font-style:italic">N</span>. Considérons une suite réelle <span style="font-style:italic">x</span> dont
la DFT <span style="font-style:italic">y</span> est nulle sauf <span style="font-style:italic">y</span><sub><span style="font-style:italic">l</span></sub> et <span style="font-style:italic">y</span><sub><span style="font-style:italic">N</span>−<span style="font-style:italic">l</span></sub>. Par linéarité, on
peut se ramener à 2 cas <span style="font-style:italic">y</span><sub><span style="font-style:italic">l</span></sub>=<span style="font-style:italic">y</span><sub><span style="font-style:italic">N</span>−<span style="font-style:italic">l</span></sub>=1 et <span style="font-style:italic">y</span><sub><span style="font-style:italic">l</span></sub>=<span style="font-style:italic">i</span>, <span style="font-style:italic">y</span><sub><span style="font-style:italic">N</span>−<span style="font-style:italic">l</span></sub>=−<span style="font-style:italic">i</span>. Dans
le premier cas, on obtient <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>=ω<sub><span style="font-style:italic">N</span></sub><sup><span style="font-style:italic">lk</span></sup>+ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">lk</span></sup>=2cos(2π <span style="font-style:italic">kl</span>/<span style="font-style:italic">N</span>),
dans le deuxième cas, on obtient <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>=−2sin(2π <span style="font-style:italic">kl</span>/<span style="font-style:italic">N</span>), qui sont périodiques
de période <span style="font-style:italic">N</span>/<span style="font-style:italic">l</span>.</p><p>Réciproquement, si <span style="font-style:italic">x</span> a comme période <span style="font-style:italic">T</span>=<span style="font-style:italic">N</span>/<span style="font-style:italic">l</span>, alors en posant
<span style="font-style:italic">j</span>=<span style="font-style:italic">T</span> <span style="font-style:italic">m</span> + <span style="font-style:italic">r</span> avec <span style="font-style:italic">m</span>∈[0,<span style="font-style:italic">l</span>[ et <span style="font-style:italic">r</span>∈[0,<span style="font-style:italic">T</span>−1], on a
<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>=<span style="font-style:italic">x</span><sub><span style="font-style:italic">r</span></sub> donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > <span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">k</span>· <span style="font-style:italic">j</span></sup> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span>=0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">r</span></sub> ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">k</span> (<span style="font-style:italic">T</span> <span style="font-style:italic">m</span>+<span style="font-style:italic">r</span>)</sup> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">r</span></sub> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span>=0</td></tr>
</table></td><td class="dcell"> ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">k</span> (<span style="font-style:italic">T</span> <span style="font-style:italic">m</span>+<span style="font-style:italic">r</span>)</sup> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">r</span></sub> ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">kr</span></sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span>=0</td></tr>
</table></td><td class="dcell">
(ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">kT</span></sup>)<sup><span style="font-style:italic">m</span></sup> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">r</span></sub> ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">kr</span></sup> 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1−(ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">kT</span></sup>)<sup><span style="font-style:italic">l</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">kT</span></sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
si ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">kT</span></sup> ≠ 1. Comme (ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">kT</span></sup>)<sup><span style="font-style:italic">l</span></sup>=ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">klT</span></sup>=1,
<span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>=0 si <span style="font-style:italic">kT</span>=<span style="font-style:italic">kN</span>/<span style="font-style:italic">l</span> n’est pas un multiple de <span style="font-style:italic">N</span>. 
Finalement si <span style="font-style:italic">k</span> n’est pas un multiple de <span style="font-style:italic">l</span>, alors <span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>=0.</p><p>Voyons maintenant le cas de “pseudo-périodes”, supposons donc
que <span style="font-style:italic">x</span> est périodique de période <span style="font-style:italic">N</span> mais que de plus pour un <span style="font-style:italic">T</span>&gt;0 
quelconque (ne divisant pas forcément <span style="font-style:italic">N</span>), on ait
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span>+<span style="font-style:italic">T</span></sub>=<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>,    ∀ <span style="font-style:italic">j</span> ∈[0,<span style="font-style:italic">N</span>−<span style="font-style:italic">T</span>] </td></tr>
</table><p>
On peut refaire le raisonnement ci-dessus, modulo des erreurs.
plus précisément :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ceil(<span style="font-style:italic">N</span>/<span style="font-style:italic">T</span>)<span style="font-style:italic">T</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=<span style="font-style:italic">N</span></td></tr>
</table></td><td class="dcell"><span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">k</span>· <span style="font-style:italic">j</span></sup> 
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ceil(<span style="font-style:italic">N</span>/<span style="font-style:italic">T</span>)</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span>=0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">r</span></sub> ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">k</span> (<span style="font-style:italic">T</span> <span style="font-style:italic">m</span>+<span style="font-style:italic">r</span>)</sup> </td></tr>
</table><p>
On calcule donc <span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub> à une erreur de ceil(<span style="font-style:italic">N</span>/<span style="font-style:italic">T</span>)<span style="font-style:italic">T</span>−<span style="font-style:italic">N</span> termes majorés
par |<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>| près.
Et le membre de droite vaudra :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">r</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">r</span></sub> ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">kr</span></sup> 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1−ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">k</span>ceil(<span style="font-style:italic">N</span>/<span style="font-style:italic">T</span>) <span style="font-style:italic">T</span></sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−ω<sub><span style="font-style:italic">N</span></sub><sup>−<span style="font-style:italic">kT</span></sup></td></tr>
</table></td></tr>
</table><p>
Le module de la fraction est égal à
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">sin(π <span style="font-style:italic">k</span> ceil(<span style="font-style:italic">N</span>/<span style="font-style:italic">T</span>) <span style="font-style:italic">T</span>/<span style="font-style:italic">N</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">sin(π <span style="font-style:italic">k</span> <span style="font-style:italic">T</span>/<span style="font-style:italic">N</span>)</td></tr>
</table></td><td class="dcell"> |
= |</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">sin(π <span style="font-style:italic">k</span> (ceil(<span style="font-style:italic">N</span>/<span style="font-style:italic">T</span>) <span style="font-style:italic">T</span>/<span style="font-style:italic">N</span>−1))</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">sin(π <span style="font-style:italic">k</span> <span style="font-style:italic">T</span>/<span style="font-style:italic">N</span>)</td></tr>
</table></td><td class="dcell"> |
</td></tr>
</table><p>
il est petit si <span style="font-style:italic">k</span> n’est pas proche d’un multiple de ceil(<span style="font-style:italic">N</span>/<span style="font-style:italic">T</span>).
Par exemple, prenons <span style="font-style:italic">N</span>=2<sup>1</sup>6=65536 et <span style="font-style:italic">T</span> ≈ <span style="font-style:italic">N</span>/10 =6554. Dans
ce cas ceil(<span style="font-style:italic">N</span>/<span style="font-style:italic">T</span>)<span style="font-style:italic">T</span>=10 × 6554=65540, il y a donc une erreur
de 4 termes sur le calcul de <span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>. Si <span style="font-style:italic">k</span> n’est pas proche d’un multiple
de 10, on doit trouver <span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub> proche de 0 relativement à la valeur des |<span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub>|.</p><p>Les périodes et pseudo-périodes de <span style="font-style:italic">x</span> correspondent donc aux
valeurs de <span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub> grandes par la règle <span style="font-style:italic">k</span> * période =<span style="font-style:italic">N</span>.</p>
<!--TOC subsection id="sec288" La transformée de Fourier rapide-->
<h3 id="sec288" class="subsection">25.2  La transformée de Fourier rapide</h3><!--SEC END --><p><a id="hevea_default338"></a>
<a id="hevea_default339"></a><a id="hevea_default340"></a>
Le calcul de la DFT est relativement lent, il nécessite de l’ordre
de <span style="font-style:italic">N</span><sup>2</sup> opérations, car il revient à calculer la valeur du polynôme
de degré <span style="font-style:italic">N</span>−1:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span>−1</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">j</span>=0</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">x</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">X</span><sup><span style="font-style:italic">j</span></sup> </td></tr>
</table><p>
aux <span style="font-style:italic">N</span> points 1, ω<sub><span style="font-style:italic">N</span></sub>, ..., ω<sub><span style="font-style:italic">N</span></sub><sup><span style="font-style:italic">N</span>−1</sup> 
(on a <span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>=<span style="font-style:italic">P</span>(ω<sub><span style="font-style:italic">N</span></sub><sup><span style="font-style:italic">k</span></sup>)).
Mais si <span style="font-style:italic">N</span> est une puissance de 2, on peut calculer de manière plus
astucieuse et réduire le nombre d’opérations à un ordre <span style="font-style:italic">T</span>(<span style="font-style:italic">N</span>)=<span style="font-style:italic">O</span>(<span style="font-style:italic">N</span> ln(<span style="font-style:italic">N</span>)).
En effet <span style="font-style:italic">N</span>=2<span style="font-style:italic">M</span>,
on prend les
puissances paires et impaires de <span style="font-style:italic">P</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">Q</span>(<span style="font-style:italic">x</span><sup>2</sup>)+<span style="font-style:italic">xR</span>(<span style="font-style:italic">x</span><sup>2</sup>)</td></tr>
</table><p>
On a alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(ω<sup><span style="font-style:italic">k</span></sup>)=<span style="font-style:italic">Q</span>( (ω<sup>2</sup>)<sup><span style="font-style:italic">k</span></sup>)+ω<sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">R</span>((ω<sup>2</sup>)<sup><span style="font-style:italic">k</span></sup>)</td></tr>
</table><p>
On calcule les DFT de <span style="font-style:italic">Q</span> et <span style="font-style:italic">R</span>, puis pour chaque valeur de <span style="font-style:italic">k</span> on a
1 multiplication et 1 addition donc 4<span style="font-style:italic">M</span> opérations plus le calcul
de deux DFT d’ordre <span style="font-style:italic">M</span> (on peut économiser <span style="font-style:italic">M</span> multiplications
en utilisant ω<sup><span style="font-style:italic">k</span>+<span style="font-style:italic">M</span></sup> =−ω<sup><span style="font-style:italic">k</span></sup>). On a donc <span style="font-style:italic">T</span>(2<span style="font-style:italic">M</span>)=<span style="font-style:italic">cM</span>+2<span style="font-style:italic">T</span>(<span style="font-style:italic">M</span>)
avec <span style="font-style:italic">c</span>=4 ou <span style="font-style:italic">c</span>=3. Si <span style="font-style:italic">N</span>=2<sup><span style="font-style:italic">n</span></sup> on a 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">T</span>(2<sup><span style="font-style:italic">n</span></sup>)=<span style="font-style:italic">c</span>2<sup><span style="font-style:italic">n</span>−1</sup>+2<span style="font-style:italic">T</span>(2<sup><span style="font-style:italic">n</span>−1</sup>)
= <span style="font-style:italic">c</span>2<sup><span style="font-style:italic">n</span>−1</sup>+2(<span style="font-style:italic">c</span>2<sup><span style="font-style:italic">n</span>−2</sup>+2<span style="font-style:italic">T</span>(2<sup><span style="font-style:italic">n</span>−2</sup>)
=...=<span style="font-style:italic">nc</span>2<sup><span style="font-style:italic">n</span>−1</sup>+2<sup><span style="font-style:italic">n</span></sup><span style="font-style:italic">T</span>(0)</td></tr>
</table><p>
donc <span style="font-style:italic">T</span>(2<sup><span style="font-style:italic">n</span></sup>) ≈ <span style="font-style:italic">cn</span>2<sup><span style="font-style:italic">n</span>−1</sup> opérations, donc <span style="font-style:italic">O</span>(<span style="font-style:italic">N</span>ln(<span style="font-style:italic">N</span>))
opérations.</p><p>Une méthode alternative consiste à 
découper <span style="font-style:italic">P</span> en 2 parties de même longueur :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">x</span><sup><span style="font-style:italic">M</span></sup> <span style="font-style:italic">Q</span>(<span style="font-style:italic">X</span>) + <span style="font-style:italic">R</span>(<span style="font-style:italic">X</span>) </td></tr>
</table><p>
on a alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">P</span>(ω<sup>2<span style="font-style:italic">k</span></sup>)</td><td style="text-align:center;white-space:nowrap" >= (<span style="font-style:italic">Q</span>+<span style="font-style:italic">R</span>) ((ω<sup>2</sup>)<sup><span style="font-style:italic">k</span></sup>), </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">P</span>(ω<sup>2<span style="font-style:italic">k</span>+1</sup>)</td><td style="text-align:center;white-space:nowrap" >= (−<span style="font-style:italic">Q</span> +<span style="font-style:italic">R</span>)<sub>ω</sub>((ω<sup>2</sup>)<sup><span style="font-style:italic">k</span></sup>)   </td><td style="text-align:left;white-space:nowrap" > où   <span style="font-style:italic">S</span><sub>ω</sub>(<span style="font-style:italic">x</span>)=<span style="font-size:xx-large">∑</span><span style="font-style:italic">s</span><sub><span style="font-style:italic">k</span></sub> ω<sup><span style="font-style:italic">k</span></sup> <span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup>
</td></tr>
</table></td></tr>
</table><p>
On est donc ramené à deux additions de 2 polynômes de degré <span style="font-style:italic">M</span>,
une multiplication coefficient par puissances sur un polynôme de
degré <span style="font-style:italic">M</span> (soit 3<span style="font-style:italic">M</span> opérations),
et au calcul des deux DFT de <span style="font-style:italic">Q</span>+<span style="font-style:italic">R</span> et <span style="font-style:italic">R</span>−<span style="font-style:italic">Q</span>. 
Lorsqu’on implémente cette méthode de manière efficace, 
on calcule le résultat de la DFT en place (en écrasant <span style="font-style:italic">P</span> par sa DFT)
il faut utiliser un espace mémoire
de travail de même longueur que le polynme de départ, on en
utilise la première partie pour calculer <span style="font-style:italic">Q</span>+<span style="font-style:italic">R</span> et la seconde partie
pour (<span style="font-style:italic">R</span>−<span style="font-style:italic">Q</span>)<sub>ω</sub>. On calcule les deux DFT en utilisant comme
espaces mémoire de travail la zone qui contient <span style="font-style:italic">P</span> (qui sera donc
perdu), puis on effectue les permutations donnant la DFT de <span style="font-style:italic">P</span>
à partir de celles de <span style="font-style:italic">Q</span> et <span style="font-style:italic">R</span> en écrasant la zone qui contenait <span style="font-style:italic">P</span>.</p><p>On appelle alors FFT cette méthode de calcul (DFT=FFT si <span style="font-style:italic">N</span>=2<sup><span style="font-style:italic">n</span></sup>).</p><p>Cette méthode se généralise à des <span style="font-style:italic">N</span> qui ne sont pas des puissances
de 2.</p>
<!--TOC subsection id="sec289" Applications.-->
<h3 id="sec289" class="subsection">25.3  Applications.</h3><!--SEC END --><p>
La DFT peut servir à trouver des périodes dans des données
expérimentales datées. On peut par exemple le voir sur
des enregistrements de son (par exemple avec le logiciel
libre <code>audacity</code>), mais dans bien d’autres
domaines, par exemple si on l’applique aux données
issues des paléoclimats, on voit apparaitre les périodicités
des paramètres orbitaux de la Terre, en phase avec la théorie
de Milankovitch.</p><p>En calcul exact, la FFT permet d’obtenir une complexité optimale
pour calculer des produits de grands entiers ou de polynômes
en une variable. La session <code>multfft</code>du menu 
<code>Aide, Exemples, arit</code> de Xcas implémente le principe
du calcul du produit <span style="font-style:italic">P</span> de deux polynômes <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> à coefficients entiers
en utilisant un seul nombre premier <span style="font-style:italic">p</span> tel que 
</p><ul class="itemize"><li class="li-itemize">
1 admette
une racine primitive 2<sup><span style="font-style:italic">n</span></sup>-ième de l’unité modulo <span style="font-style:italic">p</span> 
pour un <span style="font-style:italic">n</span> assez grand (2<sup><span style="font-style:italic">n</span></sup> strictement plus grand que le degré
du produit <span style="font-style:italic">P</span>) 
</li><li class="li-itemize">tel que <span style="font-style:italic">p</span>&gt;2|<span style="font-style:italic">P</span>|<sub>∞</sub> pour déterminer <span style="font-style:italic">P</span> à partir de son
écriture en représentation symétrique.
</li></ul><p>
On écrit les coefficients de <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> dans un vecteur de longueur
2<sup><span style="font-style:italic">n</span></sup> en complétant par des 0, on calcule la DFT de <span style="font-style:italic">A</span> et de <span style="font-style:italic">B</span>,
puis on fait le produit élément par élément puis on calcule la
DFT inverse.</p><p>Exemple : on cherche des nombres premiers de la forme <span style="font-style:italic">p</span>=<span style="font-style:italic">k</span>2<sup><span style="font-style:italic">n</span></sup>+1
par exemple <span style="font-style:italic">p</span>=7× 2<sup>20</sup>+1 est premier, 

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">isprime(p:=7*2^20+1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

on cherche un générateur de ℤ/<span style="font-style:italic">p</span>ℤ

</p><pre class="verbatim">for(g:=2;g&lt;p;g++){ 
  if (powmod(g,(p-1)/2,p)!=1 and powmod(g,(p-1)/7,p)!=1) break;
}:; g;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;t.value=tmp;tmp=UI.caseval(tmp);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML);field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>

on en déduit une racine primitive 2<sup>20</sup>-ième de l’unité

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:20px;font-size:large">g;r:=powmod(g,7,p);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

puis en prenant la puissance 2<sup><span style="font-style:italic">n</span>−<span style="font-style:italic">k</span></sup>-ième de <span style="font-style:italic">r</span> on obtient une
racine 2<sup><span style="font-style:italic">k</span></sup>-ième de 1 qui permettra de multiplier deux
polynômes dont la somme des degrés est strictement 
inférieure à 2<sup><span style="font-style:italic">k</span></sup>, par exemple pour <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> de
degrés 5 et 7, on prendra <span style="font-style:italic">k</span>=4
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">a:=randpoly(5,[]); b:=randpoly(7,[]);w:=powmod(r,2^16,p); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
on allonge <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> avec des 0 pour les amener à la taille 16=2<sup><span style="font-style:italic">k</span></sup>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">ar:=[op(a),0$(16-size(a))];br:=[op(b),0$(16-size(b))]; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
on calcule les transformées de Fourier rapide de <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">A:=fft(ar,w,p); B:=fft(br,w,p); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
puis on fait le produit terme à terme et on applique la transformée
de Fourier inverse
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">C:=irem(A.*B,p); c:=ifft(C,w,p); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
On peut comparer avec le produit calculé par Xcas
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">a*b; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<div><textarea onkeypress="UI.ckenter(event,this,2)" style="width:800px;height:20px;font-size:large">smod(c,p); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
Bien entendu les tailles de <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> prises ici
en exemple sont trop petites
pour que l’algorithme soit efficace.</p><p>Pour une implémentation efficace, on utilise plusieurs nombres
premiers et les restes chinois (en fait à deux reprises). 
On calcule le produit des polynômes
modulo plusieurs nombres premiers <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub>, dont le produit ∏
<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> est supérieur à deux fois la norme infinie de <span style="font-style:italic">P</span> pour
pouvoir en déduire <span style="font-style:italic">P</span>.
Pour calculer un des produits <span style="font-style:italic">AB</span> (mod <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> ), on réduit <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> modulo <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub>,
on multiplie les polynômes réduits <span style="text-decoration:overline"><span style="font-style:italic">A</span></span> <span style="text-decoration:overline"><span style="font-style:italic">B</span></span> 
comme s’ils étaient à coefficients
entiers et on r’eduit le résultat modulo <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub>. 
Le calcul de chaque <span style="text-decoration:overline"><span style="font-style:italic">A</span></span><span style="text-decoration:overline"><span style="font-style:italic">B</span></span> (<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> fixé) se fait en utilisant 2 ou 3
premiers choisis une fois pour toutes qui sont proches de 2<sup>31</sup>
et ont des racines 2<sup><span style="font-style:italic">n</span></sup>-ième de l’unité pour <span style="font-style:italic">n</span> assez proche de 31.
Ainsi, Law et Monagan, proposent 
dans“A parallel implementation for polynomial multiplication
modulo a prime”, PASCO 2015,
</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">n</span><sub>1</sub> = 2013265921 =15 × 2<sup>27</sup>+1 
(<span style="font-style:italic">r</span>=1227303670 est racine d’ordre 2<sup>27</sup>, il suffit de prendre 
un générateur de (ℤ/<span style="font-style:italic">n</span><sub>1</sub>ℤ)<sup>*</sup> à la puissance 15, ce qui
se fait en testant 2, 3,...).
</li><li class="li-itemize"><span style="font-style:italic">n</span><sub>2</sub> = 1811939329 =27 × 2<sup>26</sup> (<span style="font-style:italic">r</span>=814458146 est racine d’ordre 2<sup>26</sup>) 
</li><li class="li-itemize"><span style="font-style:italic">n</span><sub>3</sub> = 469762049  (<span style="font-style:italic">r</span>=2187 est racine d’ordre 2<sup>26</sup>)
</li></ul><p>
On peut retrouver ces nombres premiers avec une boucle comme suit

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-size:large">p:=2^25; for k from 64 downto 1 do if isprime(k*p+1) then print(k,k*p+1); fi od
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

et la valeur d’une racine 2<sup><span style="font-style:italic">n</span></sup>-ième comme suit

</p><pre class="verbatim">n:=2013265921;
pour k de 2 jusque 100 faire
 a:=powmod(k,(n-1)/3,n); b:=powmod(k,(n-1)/5,n); c:=powmod(k,(n-1)/2,n);
 print(k,a,b,c);
 si a!=1 et b!=1 et c!=1 alors break; fsi;
fpour;
r:=powmod(k,15,n);
powmod(r,2^26,n); powmod(r,2^27,n);
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;t.value=tmp;tmp=UI.caseval(tmp);if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML);field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>

Ce choix de valeurs de <span style="font-style:italic">n</span><sub>1</sub>, <span style="font-style:italic">n</span><sub>2</sub>, <span style="font-style:italic">n</span><sub>3</sub> 
permet de multiplier des polynômes dont le degré du produit
est strictement inférieur à 2<sup>26</sup> (environ 67 millions). 
Si on utilise deux de ces 3
premiers, <span style="font-style:italic">n</span><sub>1</sub> et <span style="font-style:italic">n</span><sub>2</sub>, on peut prendre des <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> dont la taille en bits est
plus petite que (60 bits moins le nombre de bits du degré minimal de
<span style="font-style:italic">A</span> et <span style="font-style:italic">B</span>) divisé par 2. Avec les trois <span style="font-style:italic">n</span><sub>1</sub>, <span style="font-style:italic">n</span><sub>2</sub> et <span style="font-style:italic">n</span><sub>3</sub> on peut prendre
<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> ayant 31 bits, mais il faut travailler si on veut éviter
de faire des restes chinois avec des
entiers de plus de 64 bits (ce qui est possible avec des entiers 128
bits mais au prix de réductions modulo couteuses).</p>
<!--TOC section id="sec290" Le rayonnement solaire.-->
<h2 id="sec290" class="section">26  Le rayonnement solaire.</h2><!--SEC END --><p> <a id="sec:soleil"></a></p>
<!--TOC subsection id="sec291" L’insolation au cours de l’année.-->
<h3 id="sec291" class="subsection">26.1  L’insolation au cours de l’année.</h3><!--SEC END --><p> <a id="hevea_default341"></a>
Pour connaitre la quantité d’énergie recue à un moment
donné, il faut calculer l’angle entre la verticale du lieu
et la direction du Soleil. Plus généralement, on va calculer
les composantes du vecteur Terre-Soleil et les composantes
des vecteurs de la base locale (verticale locale, direction du Sud et
direction du parallèle). On choisit d’abord comme référence
le plan <span style="font-style:italic">Txy</span> de l’écliptique (plan de l’orbite de la Terre
autour du Soleil), avec <span style="font-style:italic">Ty</span> orthogonal à l’axe de rotation 
de la Terre (donc <span style="font-style:italic">Tx</span> la projection de l’axe de rotation
de la Terre sur ce plan). Soit θ l’angle que fait la Terre
avec la direction du passage au périhélie, et θ<sub>0</sub>
l’angle de la position de la Terre au solstice d’hiver avec la
direction du périhélie, l’angle entre la direction Terre-Soleil
et <span style="font-style:italic">Tx</span> est donc θ−θ<sub>0</sub><br>
Dans <span style="font-style:italic">Txyz</span> le vecteur unitaire <span style="font-style:italic">s</span>
de la direction Terre-Soleil a pour coordonnées :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">s</span>=−(cos(θ−θ<sub>0</sub>),sin(θ−θ<sub>0</sub>),0)</td></tr>
</table><p>
On effectue ensuite une rotation autour
de <span style="font-style:italic">Ty</span> d’angle <span style="font-style:italic">i</span> l’inclinaison de l’axe de rotation de la Terre.
On obtient ainsi un repère <span style="font-style:italic">TXyZ</span> (<span style="font-style:italic">TX</span> et <span style="font-style:italic">TZ</span> se déduisent de 
<span style="font-style:italic">Tx</span> et <span style="font-style:italic">Tz</span> par rotation d’angle <span style="font-style:italic">i</span>). Dans ce repère 
le vecteur untaire <span style="font-style:italic">s</span> a pour coordonnées :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">s</span>=−(cos(θ−θ<sub>0</sub>)cos(<span style="font-style:italic">i</span>),sin(θ−θ<sub>0</sub>),
cos(θ−θ<sub>0</sub>)sin(<span style="font-style:italic">i</span>)) </td></tr>
</table><p>
Calculons maintenant dans ce repère <span style="font-style:italic">TXyZ</span> les coordonnées
des vecteurs de la base locale. On se place en un point de latitude
<span style="font-style:italic">l</span> et de longitude φ, on note <span style="font-style:italic">J</span> la durée d’une période
de révolution de la Terre sur elle-même (23 heures 56 minutes,
c’est un peu moins d’un jour car il faut encore en moyenne 4 minutes
pour compenser le déplacement de la Terre sur son orbite autour
du Soleil). La verticale locale a pour coordonnées :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">v</span>=(cos(<span style="font-style:italic">l</span>)cos(φ+2π <span style="font-style:italic">t</span>/<span style="font-style:italic">J</span>),cos(<span style="font-style:italic">l</span>)sin(φ+2π <span style="font-style:italic">t</span>/<span style="font-style:italic">J</span>),sin(<span style="font-style:italic">l</span>))
</td></tr>
</table><p>
L’énergie solaire recue au lieu donné (sur une surface horizontale ;
pour un panneau solaire, il faudrait calculer les coordonnées d’un vecteur
perpendiculaire au panneau) est proportionnelle à
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">s</span>.<span style="font-style:italic">v</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ρ<sup>2</sup></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
où ρ(θ)=<span style="font-style:italic">a</span>(1−<span style="font-style:italic">e</span><sup>2</sup>)/(1+<span style="font-style:italic">e</span>cos(θ)) 
désigne la distance Terre-Soleil.
Le calcul de <span style="font-style:italic">s</span>.<span style="font-style:italic">v</span> donne, en notant ϕ=φ+2π <span style="font-style:italic">t</span>/<span style="font-style:italic">J</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">−<span style="font-style:italic">s</span>.<span style="font-style:italic">v</span>  =  cos(<span style="font-style:italic">l</span>) cos(ϕ) cos(θ−θ<sub>0</sub>)cos(<span style="font-style:italic">i</span>)
+ cos(<span style="font-style:italic">l</span>)sin(ϕ) sin(θ−θ<sub>0</sub>) 
+ sin(<span style="font-style:italic">l</span>) cos(θ−θ<sub>0</sub>)sin(<span style="font-style:italic">i</span>) </td></tr>
</table><p>
On rassemble les deux premiers termes qui dépendent rapidement
du temps par l’intermédiaire de ϕ
(le 3ème terme n’en dépend que par θ qui ne varie
que d’environ 1 degré pendant une journée)
et on applique la formule de trigonométrie:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span> cosα + <span style="font-style:italic">B</span> sinα = </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span><sup>2</sup>+<span style="font-style:italic">B</span><sup>2</sup></td></tr>
</table></td><td class="dcell">
cos(α−α<sub>0</sub>),    </td><td class="dcell">⎧<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎨<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎩</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >cos(α<sub>0</sub>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span><sup>2</sup>+<span style="font-style:italic">B</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >sin(α<sub>0</sub>)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span><sup>2</sup>+<span style="font-style:italic">B</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p> 
Ici, après avoir factorisé cos(<span style="font-style:italic">l</span>), on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span><sup>2</sup>+<span style="font-style:italic">B</span><sup>2</sup></td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >
cos(θ−θ<sub>0</sub>)<sup>2</sup>cos(<span style="font-style:italic">i</span>)<sup>2</sup>+sin(θ−θ<sub>0</sub>)<sup>2</sup> </td></tr>
</table></td><td class="dcell">
= </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1 − sin(<span style="font-style:italic">i</span>)<sup>2</sup> cos(θ−θ<sub>0</sub>)<sup>2</sup> </td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
On peut aussi calculer 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">tan(α<sub>0</sub>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell"> =  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">tan(θ−θ<sub>0</sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">cos(<span style="font-style:italic">i</span>)</td></tr>
</table></td></tr>
</table><p>
qui donne α<sub>0</sub> modulo π et compléter en regardant 
le quadrant où se trouve (<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>), ici α<sub>0</sub> et θ−θ<sub>0</sub> 
sont tous deux dans [0,π] ou tous deux dans [−π,0].
Finalement, on obtient le
</p><div class="theorem"><span style="font-weight:bold">Théorème 59</span>  <em> </em><a id="thm:soleil"></a><em>
L’énergie solaire recue au sol est proportionnelle à
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(1+<span style="font-style:italic">e</span>cos(θ))<sup>2</sup> <span style="font-style:italic">s</span>.<span style="font-style:italic">v</span> </td></tr>
</table><em>
où </em><span style="font-style:italic">s</span>.<span style="font-style:italic">v</span><em> est donné par :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">s</span>.<span style="font-style:italic">v</span> = − cos(<span style="font-style:italic">l</span>) </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1 − sin(<span style="font-style:italic">i</span>)<sup>2</sup> cos(θ−θ<sub>0</sub>)<sup>2</sup> </td></tr>
</table></td><td class="dcell">
cos(ϕ−ϕ<sub>0</sub>)
− sin(<span style="font-style:italic">l</span>) cos(θ−θ<sub>0</sub>)sin(<span style="font-style:italic">i</span>)
</td></tr>
</table><em>
et 
</em><ul class="itemize"><li class="li-itemize"><em>
</em><span style="font-style:italic">e</span><em> est l’excentricité de l’orbite elliptique (environ
0.0167 actuellement)
</em></li><li class="li-itemize"><span style="font-style:italic">i</span><em> est l’obliquité (inclinaison de l’axe de rotation de la Terre,
environ 23 degré 27 minutes actuellement)
</em></li><li class="li-itemize">θ<em> est l’angle fait par la direction Terre-Soleil avec la 
direction du demi grand axe (Soleil-périhélie), 
</em>θ<sub>0</sub><em> le même angle au solstice d’hiver
de l’hémisphère Nord (environ -13 degrés). En première 
approximation, on peut faire varier </em>θ<em> proportionnellement au temps,
voir la fin de la section </em><a href="#sec%3Adureesaison"><em>26.6</em></a><em> pour un calcul plus précis.
</em></li><li class="li-itemize"><span style="font-style:italic">l</span><em> est la latitude, </em>ϕ<em> la longitude tenant compte
de la rotation de la Terre (somme de la longitude géographique </em>φ<em> et 
du terme dépendant du temps </em>2π <span style="font-style:italic">t</span>/<span style="font-style:italic">J</span><em>)
</em></li><li class="li-itemize">ϕ<sub>0</sub> ∈ [−π,π]<em> est de même signe que </em>θ−θ<sub>0</sub><em>
et est défini par :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:culmination"></a>
tanϕ<sub>0</sub> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">tan(θ−θ<sub>0</sub>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">cos(<span style="font-style:italic">i</span>)</td></tr>
</table></td><td class="dcell"><em> 
    (63)</em></td></tr>
</table><em>
</em></li></ul><em>
</em></div><p>
<span style="font-weight:bold">Variations de </span><span style="font-style:italic">s</span>.<span style="font-style:italic">v</span><span style="font-weight:bold"> au cours d’une journée dans l’approximation où
</span>θ<span style="font-weight:bold"> ne varie pas</span> :<br>
On obtient une sinusoide entre les deux valeurs extrêmes :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">± cos(<span style="font-style:italic">l</span>) </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1 − sin(<span style="font-style:italic">i</span>)<sup>2</sup> cos(θ−θ<sub>0</sub>)<sup>2</sup> </td></tr>
</table></td><td class="dcell"> −
sin(<span style="font-style:italic">l</span>) cos(θ−θ<sub>0</sub>)sin(<span style="font-style:italic">i</span>) </td></tr>
</table><p>
Le maximum est atteint pour 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ϕ=ϕ<sub>0</sub>+ π  ⇒  
2 π <span style="font-style:italic">t</span>/<span style="font-style:italic">J</span> = ϕ<sub>0</sub> − φ + π,    <span style="font-style:italic">J</span>=23<span style="font-style:italic">h</span>56<span style="font-style:italic">m</span> </td></tr>
</table><p>
le moment correspondant est appelé culmination (c’est le midi
solaire si le maximum est positif) et ne dépend pas de la latitude
(bien entendu la valeur du maximum en dépend).
Si le maximum est négatif ou nul, la nuit dure 24h.
Si le minimum est positif ou nul, le jour dure 24h.
Par exemple au solstice d’hiver, θ=θ<sub>0</sub>, selon la latitude
on obtient un maximum négatif pour <span style="font-style:italic">l</span>=π/2 (pole Nord), positif 
pour <span style="font-style:italic">l</span>=−π/2 (pole Sud), le minimum et le maximum croissent 
entre ces 2 valeurs.
Si le maximum est positif et le minimum est négatif, il y a
2 instants ou <span style="font-style:italic">s</span>.<span style="font-style:italic">v</span>=0 (lever et coucher du soleil).</p><p>L’énergie solaire recue pendant une journée par une surface
horizontale est proportionnelle à l’intégrale entre le lever
et le coucher de <span style="font-style:italic">s</span>.<span style="font-style:italic">v</span>/ρ<sup>2</sup>. S’il n’y a pas de lever/coucher, 
soit on ne recoit rien (nuit polaire),
soit on recoit l’intégrale entre 0 et 24h de <span style="font-style:italic">s</span>.<span style="font-style:italic">v</span> (jour polaire).</p><p>L’intervalle entre 2 culminations n’est pas constant au cours de
l’année, car ϕ<sub>0</sub> n’est pas une fonction linéaire de
θ (qui lui même n’est pas linéaire en fonction du temps
sauf en première approximation avec une orbite terrestre
circulaire). On peut le calculer en dérivant (<a href="#eq%3Aculmination">63</a>).
Par exemple dans l’approximation d’une excentricité nulle,
au solstice d’hiver (θ=θ<sub>0</sub>), on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ϕ<sub>0</sub>= 0,    (1+0<sup>2</sup>) <span style="font-style:italic">d</span>ϕ<sub>0</sub> = (1+0<sup>2</sup>)</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>θ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">cos(<span style="font-style:italic">i</span>)</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
avec <span style="font-style:italic">d</span>θ qui correspond à 4 minutes, on trouve <span style="font-style:italic">d</span>ϕ<sub>0</sub>
correspondant à 4.36 minutes.
L’écart entre 2 culminations
est donc d’environ 24h 20secondes. 
Au moment du solstice, le Soleil se lève et se couche donc environ
20 secondes plus tard entre un jour et son lendemain, dans 
l’hypothèse d’un mouvement circulaire de la Terre autour du Soleil. 
En réalité, l’orbite terrestre étant faiblement elliptique,
l’écart est un peu moins de 30 secondes en hiver et de 15 secondes en été, 
le mouvement de la Terre autour du Soleil étant plus rapide d’environ
3% au solstice d’hiver et moins rapide d’environ 3% au
solstice d’été. Comme 3%
de l’écart moyen entre 2 culminations (4 minutes=240 secondes) 
correspond à 7 secondes cela explique la différence.</p>
<!--TOC subsection id="sec292" Les saisons-->
<h3 id="sec292" class="subsection">26.2  Les saisons</h3><!--SEC END --><p><a id="hevea_default342"></a>
Les solstices sont définis par les 2 points de l’orbite où la projection
de l’axe de rotation terrestre est parallèle à l’axe Terre-Soleil.
Les équinoxes sont définis par les 2 points où il y a perpendicularité.
Au solstice d’hiver, on voit que les parallèles situés aux hautes latitudes
Nord ne sortent jamais de l’obscurité. Aux latitudes intérmédiaires,
le morceau de parallèle situé au jour est nettement plus petit que
celui situé dans l’obscurité.
À l’équinoxe de printemps, chaque parallèle est à moitié au jour
et à moitié dans l’obscurité (derrière la grille). Au printemps,
la situtation est analogue.
Au solstice d’été, on est dans la situation inverse de l’hiver.</p>
<!--TOC subsection id="sec293" L’orbite de la Terre.-->
<h3 id="sec293" class="subsection">26.3  L’orbite de la Terre.</h3><!--SEC END --><p><a id="hevea_default343"></a>
En première approximation, l’orbite de la Terre est uniquement
influencée par la force de gravitation entre la Terre et le Soleil,
ce dernier pouvant être considéré comme fixe en raison de sa masse
(on peut éviter cette approximation en remplaçant le Soleil par
le centre de gravité du système Terre-Soleil).
La force de gravitation qui dérive d’un potentiel inversement
proportionnel à la distance Terre-Soleil est de la forme
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-weight:bold"><span style="font-style:italic">F</span></span><span style="font-weight:bold">′</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-weight:bold"><span style="font-style:italic">F</span></span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span><sub><span style="font-style:italic">T</span></sub></td></tr>
</table></td><td class="dcell">= <span style="font-style:italic">K</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-weight:bold"><span style="font-style:italic">r</span></span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-weight:bold"><span style="font-style:italic">r</span></span><sup><span style="font-weight:bold">3</span></sup></td></tr>
</table></td><td class="dcell">,    <span style="font-style:italic">K</span>=−µ&lt;0</td></tr>
</table><p>
où <span style="font-weight:bold"><span style="font-style:italic">r</span></span> désigne le vecteur Terre-Soleil, <span style="font-style:italic">m</span><sub><span style="font-style:italic">T</span></sub> est la masse
de la Terre, µ=<span style="font-style:italic">Gm</span><sub><span style="font-style:italic">S</span></sub> est le produit de la constante
de gravitation universelle par la masse du Soleil.
Le moment cinétique de la rotation de la Terre autour du Soleil
est défini par :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-weight:bold"><span style="font-style:italic">L</span></span> = <span style="font-weight:bold"><span style="font-style:italic">r</span></span> ∧ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span> <span style="font-weight:bold"><span style="font-style:italic">r</span></span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-weight:bold"><span style="font-style:italic">dt</span></span></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
On vérifie que sa dérivée est nulle, donc <span style="font-weight:bold"><span style="font-style:italic">L</span></span> garde
une direction fixe <span style="font-weight:bold">k</span>, orthogonale à <span style="font-weight:bold"><span style="font-style:italic">r</span></span>,
l’orbite de la Terre reste donc dans le plan défini à un instant
donné par l’axe Terre-Soleil et le vecteur vitesse de la Terre.
De plus la conservation de <span style="font-weight:bold">L</span> entraine 
la loi des aires, l’aire balayée par le rayon Soleil-Terre
est proportionnelle au temps.</p><p>On utilise un repère en coordonnées polaires centré au Soleil,
ρ désignant la distance Terre-Soleil et θ l’angle
fait par rapport à une direction fixe, on a alors
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-weight:bold"><span style="font-style:italic">L</span></span> = ρ<sup>2</sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>θ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> <span style="font-weight:bold"><span style="font-style:italic">k</span></span></td></tr>
</table><p>
car si on calcule en coordonnées polaires <span style="font-style:italic">d</span> <span style="font-weight:bold"><span style="font-style:italic">r</span></span>/<span style="font-style:italic">dt</span>,
la composante sur le vecteur radial <span style="font-weight:bold"><span style="font-style:italic">e</span></span><sub><span style="font-weight:bold"><span style="font-style:italic">r</span></span></sub> est <span style="font-style:italic">d</span>ρ/<span style="font-style:italic">dt</span>, et
la composante sur le vecteur perpendiculaire <span style="font-weight:bold"><span style="font-style:italic">e</span></span><sub><span style="font-weight:bold">θ</span></sub>
est ρ <span style="font-style:italic">d</span>θ/<span style="font-style:italic">dt</span>.</p>
<!--TOC subsubsection id="sec294" Calcul en utilisant le vecteur excentricité.-->
<h4 id="sec294" class="subsubsection">26.3.1  Calcul en utilisant le vecteur excentricité.</h4><!--SEC END --><p><a id="hevea_default344"></a>
Montrons que le vecteur
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-weight:bold"><span style="font-style:italic">E</span></span>= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">µ</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-weight:bold"><span style="font-style:italic">dr</span></span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-weight:bold"><span style="font-style:italic">dt</span></span></td></tr>
</table></td><td class="dcell"> ∧ <span style="font-weight:bold"><span style="font-style:italic">L</span></span> − 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-weight:bold"><span style="font-style:italic">r</span></span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-weight:bold">ρ</span></td></tr>
</table></td></tr>
</table><p>
est aussi conservé (où on rappelle que µ provient
de la force de gravitation <span style="font-weight:bold"><span style="font-style:italic">F</span></span><span style="font-weight:bold">′</span>=<span style="font-weight:bold"><span style="font-style:italic">F</span></span>/<span style="font-style:italic">m</span><sub><span style="font-style:italic">T</span></sub>=−µ <span style="font-weight:bold"><span style="font-style:italic">r</span></span>/<span style="font-style:italic">r</span><sup>3</sup>).
Le deuxième terme est proportionnel au vecteur
radial −<span style="font-weight:bold"><span style="font-style:italic">e</span></span><sub><span style="font-weight:bold"><span style="font-style:italic">r</span></span></sub>, dont la dérivée est le vecteur orthogonal
−<span style="font-style:italic">d</span>θ/<span style="font-style:italic">dt</span> <span style="font-weight:bold"><span style="font-style:italic">e</span></span><sub><span style="font-weight:bold">θ</span></sub>.
Comme <span style="font-weight:bold"><span style="font-style:italic">L</span></span> est constant, la dérivée du premier terme est
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">µ</td></tr>
</table></td><td class="dcell"> <span style="font-weight:bold"><span style="font-style:italic">F</span></span><span style="font-weight:bold">′</span> ∧ <span style="font-weight:bold"><span style="font-style:italic">L</span></span> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-weight:bold">−</span><span style="font-weight:bold"><span style="font-style:italic">e</span></span><sub><span style="font-weight:bold"><span style="font-style:italic">r</span></span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-weight:bold">ρ</span><sup><span style="font-weight:bold">2</span></sup></td></tr>
</table></td><td class="dcell"> ∧ <span style="font-style:italic">L</span> <span style="font-weight:bold"><span style="font-style:italic">k</span></span>
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ρ<sup>2</sup></td></tr>
</table></td><td class="dcell"> <span style="font-weight:bold"><span style="font-style:italic">e</span></span><sub><span style="font-weight:bold">θ</span></sub> = − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>θ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> ρ<sup>2</sup></td></tr>
</table><p>Notons que <span style="font-weight:bold"><span style="font-style:italic">E</span></span> est dans le plan de l’orbite, prenons comme origine
des angles pour repérer la Terre par rapport au Soleil la direction
de <span style="font-weight:bold"><span style="font-style:italic">E</span></span>. En faisant le produit scalaire de <span style="font-weight:bold"><span style="font-style:italic">E</span></span> avec <span style="font-weight:bold"><span style="font-style:italic">r</span></span>, 
on obtient en notant <span style="font-style:italic">e</span> la norme de <span style="font-style:italic">E</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">e</span> ρ cos(θ)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-weight:bold"><span style="font-style:italic">E</span></span>.<span style="font-weight:bold"><span style="font-style:italic">r</span></span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">µ</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-weight:bold"><span style="font-style:italic">dr</span></span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-weight:bold"><span style="font-style:italic">dt</span></span></td></tr>
</table></td><td class="dcell"> ∧ <span style="font-weight:bold"><span style="font-style:italic">L</span></span>− 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-weight:bold"><span style="font-style:italic">r</span></span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-weight:bold">ρ</span></td></tr>
</table></td><td class="dcell">) .<span style="font-weight:bold"><span style="font-style:italic">r</span></span> 
</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">µ</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-weight:bold"><span style="font-style:italic">dr</span></span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-weight:bold"><span style="font-style:italic">dt</span></span></td></tr>
</table></td><td class="dcell"> ∧ <span style="font-weight:bold"><span style="font-style:italic">L</span></span>).<span style="font-weight:bold"><span style="font-style:italic">r</span></span>
− ρ </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">µ</td></tr>
</table></td><td class="dcell"> (<span style="font-weight:bold"><span style="font-style:italic">r</span></span> ∧  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-weight:bold"><span style="font-style:italic">dr</span></span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-weight:bold"><span style="font-style:italic">dt</span></span></td></tr>
</table></td><td class="dcell"> ).<span style="font-weight:bold"><span style="font-style:italic">L</span></span> − ρ </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">µ</td></tr>
</table></td><td class="dcell"> <span style="font-weight:bold"><span style="font-style:italic">L</span></span>.<span style="font-weight:bold"><span style="font-style:italic">L</span></span>− ρ </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">L</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">µ</td></tr>
</table></td><td class="dcell"> − ρ
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
d’où :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ρ = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">L</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">µ(1+<span style="font-style:italic">e</span> cos(θ))</td></tr>
</table></td></tr>
</table>
<!--TOC subsubsection id="sec295" Calcul par l’équation différentielle.-->
<h4 id="sec295" class="subsubsection">26.3.2  Calcul par l’équation différentielle.</h4><!--SEC END --><p>
On a les équations de conservation de l’énergie et du moment cinétique :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">K</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ρ</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>ρ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">2</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell">
+ </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">ρ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>θ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">2</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
=<span style="font-style:italic">C</span><sub>1</sub>,    ρ<sup>2</sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>θ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
</table></td><td class="dcell"> = <span style="font-style:italic">L</span>,    <span style="font-style:italic">K</span>&lt;0, <span style="font-style:italic">m</span>&gt;0
</td></tr>
</table><p>
On change de variable dépendante pour ρ, 
en prenant θ au lieu de <span style="font-style:italic">t</span>,
comme <span style="font-style:italic">d</span>ρ/<span style="font-style:italic">dt</span>=ρ′ <span style="font-style:italic">d</span>θ/<span style="font-style:italic">dt</span> 
(où ρ′=<span style="font-style:italic">d</span>ρ/<span style="font-style:italic">d</span>θ), on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">K</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ρ</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">(ρ′<sup>2</sup>+ρ<sup>2</sup>) 
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">L</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ρ<sup>2</sup></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">2</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">= <span style="font-style:italic">C</span><sub>1</sub>
</td></tr>
</table><p>
On effectue ensuite le changement de variable ρ=1/<span style="font-style:italic">u</span>, ρ′=−<span style="font-style:italic">u</span>′/ <span style="font-style:italic">u</span><sup>2</sup>,
d’où :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">K</span> <span style="font-style:italic">u</span> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">m</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span>′<sup>2</sup> </td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sup>4</sup></td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sup>2</sup></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><span style="font-style:italic">L</span><sup>2</sup> <span style="font-style:italic">u</span><sup>4</sup> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
= <span style="font-style:italic">C</span><sub>1</sub>
</td></tr>
</table><p>
soit :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">K</span> <span style="font-style:italic">u</span> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">mL</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> ( <span style="font-style:italic">u</span>′<sup>2</sup>+<span style="font-style:italic">u</span><sup>2</sup>) = <span style="font-style:italic">C</span><sub>1</sub> </td></tr>
</table><p>
donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">K</span>′ <span style="font-style:italic">u</span> + <span style="font-style:italic">u</span><sup>2</sup> + <span style="font-style:italic">u</span>′<sup>2</sup> = <span style="font-style:italic">C</span><sub>3</sub>,    
<span style="font-style:italic">K</span>′=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">K</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">mL</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> &lt;0, <span style="font-style:italic">C</span><sub>3</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">C</span><sub>1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">mL</span><sup>2</sup></td></tr>
</table></td></tr>
</table><p>
On pose maintenant <span style="font-style:italic">v</span>=<span style="font-style:italic">u</span>+<span style="font-style:italic">K</span>′/2, d’où :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">v</span><sup>2</sup> + <span style="font-style:italic">v</span>′<sup>2</sup> = <span style="font-style:italic">C</span><sub>3</sub> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">K</span>′<sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell"> = <span style="font-style:italic">C</span><sub>4</sub> </td></tr>
</table><p>
On montre (en exprimant <span style="font-style:italic">v</span>′ en fonction de <span style="font-style:italic">v</span> puis en séparant les
variables), que cette équation différentielle a pour solution générale
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">v</span>= </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">C</span><sub>4</sub></td></tr>
</table></td><td class="dcell"> cos(θ−θ<sub>0</sub>) </td></tr>
</table><p>
D’où :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ρ = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span></td></tr>
</table></td><td class="dcell"> =
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">v</span>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">K</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> = 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">C</span><sub>4</sub></td></tr>
</table></td><td class="dcell"> cos(θ−θ<sub>0</sub>)−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">K</span>′</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Comme <span style="font-style:italic">K</span>′&lt;0 et comme la trajectoire de la Terre autour du Soleil
passe par tous les angles (donc ρ est défini pour tout θ,
le dénominateur ne peut pas s’annuler), on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ρ = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">−<span style="font-style:italic">K</span>′</td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">e</span> cos(θ−θ<sub>0</sub>)</td></tr>
</table></td><td class="dcell">,    <span style="font-style:italic">e</span> ∈ [0,1[ </td></tr>
</table><p>
On définit ensuite <span style="font-style:italic">a</span> par 2/−<span style="font-style:italic">K</span>′=<span style="font-style:italic">a</span>(1−<span style="font-style:italic">e</span><sup>2</sup>), et on obtient finalement
l’équation d’une ellipse dont l’origine (le Soleil) est un des
foyers :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ρ = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>(1−<span style="font-style:italic">e</span><sup>2</sup>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">e</span> cos(θ−θ<sub>0</sub>)</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
On suppose maintenant quitte à faire pivoter l’axe des <span style="font-style:italic">x</span> que
θ<sub>0</sub>=0.</p>
<!--TOC subsubsection id="sec296" Lois de Képler.-->
<h4 id="sec296" class="subsubsection">26.3.3  Lois de Képler.</h4><!--SEC END --><p><a id="hevea_default345"></a>
L’orbite de la Terre est donc une ellipse dont le Soleil occupe un des foyers
(1ère loi de Képler).
On a aussi vu que <span style="font-style:italic">L</span>=ρ<sup>2</sup> <span style="font-style:italic">d</span>θ/<span style="font-style:italic">dt</span> est constant, ceci entraine la loi
des aires, infinitésimalement on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">ρ<sup>2</sup> <span style="font-style:italic">d</span>θ = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">L</span> <span style="font-style:italic">dt</span> </td></tr>
</table><p>
ce qui se traduit par
l’aire balayée par le rayon vecteur Soleil-Terre est proportionnelle
au temps (2ème loi de Képler). 
Au cours d’une période <span style="font-style:italic">T</span>, l’aire parcourue est celle
de l’ellipse, donc 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">π <span style="font-style:italic">a</span><sup>2</sup> </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">e</span><sup>2</sup></td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"><span style="font-style:italic">LT</span> </td></tr>
</table><p>
En prenant le carré, et en appliquant
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">L</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">µ</td></tr>
</table></td><td class="dcell">= <span style="font-style:italic">a</span>(1−<span style="font-style:italic">e</span><sup>2</sup>)</td></tr>
</table><p>
on en déduit la troisième loi de Képler :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">4π<sup>2</sup> <span style="font-style:italic">a</span><sup>3</sup> = µ <span style="font-style:italic">T</span><sup>2</sup> ⇔ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">µ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4π<sup>2</sup></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
où on rappelle que µ est le produit de la constante de gravitation
universelle par la masse du Soleil. (On peut évidemment faire
le même calcul pour la Lune autour de la Terre).</p>
<!--TOC subsection id="sec297" Quelques propriétés de l’ellipse-->
<h3 id="sec297" class="subsection">26.4  Quelques propriétés de l’ellipse</h3><!--SEC END --><p><a id="hevea_default346"></a>
<span style="font-weight:bold">Définition</span><br>
L’ellipse <span style="font-style:italic">E</span> de foyers <span style="font-style:italic">F</span><sub>1</sub> et <span style="font-style:italic">F</span><sub>2</sub> de demi-grand axe
<span style="font-style:italic">a</span> est l’ensemble des points <span style="font-style:italic">M</span> du plan tels que 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">MF</span><sub>1</sub>+<span style="font-style:italic">MF</span><sub>2</sub>=2<span style="font-style:italic">a</span></td></tr>
</table><p>On note 2<span style="font-style:italic">c</span>=<span style="font-style:italic">F</span><sub>1</sub><span style="font-style:italic">F</span><sub>2</sub> la distance entre les deux foyers, qui doit être
plus petite que 2<span style="font-style:italic">a</span> pour que l’ellipse soit non vide.
L’excentricité de l’ellipse est définie par <span style="font-style:italic">e</span>=<span style="font-style:italic">c</span>/<span style="font-style:italic">a</span> &lt; 1. Si <span style="font-style:italic">e</span>=0,
on obtient un cercle de centre <span style="font-style:italic">F</span><sub>1</sub>=<span style="font-style:italic">F</span><sub>2</sub> et de rayon <span style="font-style:italic">a</span>. Si <span style="font-style:italic">e</span>≠ 0,
on va voir qu’il s’agit d’un cercle contracté
selon l’axe perpendiculaire à <span style="font-style:italic">F</span><sub>1</sub><span style="font-style:italic">F</span><sub>2</sub> dans un rapport de 
√<span style="text-decoration:overline">1−</span><span style="text-decoration:overline"><span style="font-style:italic">e</span></span><sup><span style="text-decoration:overline">2</span></sup>. On va également calculer l’équation en
coordonnées polaires de <span style="font-style:italic">E</span> pour montrer que l’équation obtenue
ci-dessus est bien celle d’une ellipse dont le Soleil occupe un foyer.</p><p>Soit <span style="font-style:italic">O</span> le milieu de <span style="font-style:italic">F</span><sub>1</sub> et <span style="font-style:italic">F</span><sub>2</sub>, on se place dans le repère orthonormé
dont le premier axe <span style="font-style:italic">Ox</span> contient <span style="font-style:italic">F</span><sub>1</sub> et <span style="font-style:italic">F</span><sub>2</sub> donc les
coordonnées de <span style="font-style:italic">F</span><sub>1</sub> sont (<span style="font-style:italic">c</span>,0) et celles de <span style="font-style:italic">F</span><sub>2</sub> sont (−<span style="font-style:italic">c</span>,0). 
Soit <span style="font-style:italic">M</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) un
point de l’ellipse, on a d’une part :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">MF</span><sub>1</sub><sup>2</sup> − <span style="font-style:italic">MF</span><sub>2</sub><sup>2</sup> = (<span style="font-style:italic">x</span>−<span style="font-style:italic">c</span>)<sup>2</sup>−(<span style="font-style:italic">x</span>+<span style="font-style:italic">c</span>)<sup>2</sup> = −4<span style="font-style:italic">cx</span> </td></tr>
</table><p>
et d’autre part :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">MF</span><sub>1</sub><sup>2</sup> − <span style="font-style:italic">MF</span><sub>2</sub><sup>2</sup> = (<span style="font-style:italic">MF</span><sub>1</sub> + <span style="font-style:italic">MF</span><sub>2</sub>)(<span style="font-style:italic">MF</span><sub>1</sub> − <span style="font-style:italic">MF</span><sub>2</sub> ) = 2<span style="font-style:italic">a</span> (<span style="font-style:italic">MF</span><sub>1</sub> − <span style="font-style:italic">MF</span><sub>2</sub> )</td></tr>
</table><p>
donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">MF</span><sub>1</sub> − <span style="font-style:italic">MF</span><sub>2</sub> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−2<span style="font-style:italic">cx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
en additionnant avec <span style="font-style:italic">MF</span><sub>1</sub>+<span style="font-style:italic">MF</span><sub>2</sub>=2<span style="font-style:italic">a</span> et en appliquant <span style="font-style:italic">c</span>=<span style="font-style:italic">ea</span>, on en déduit :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:MF1bis"></a>
<span style="font-style:italic">MF</span><sub>1</sub> = <span style="font-style:italic">a</span> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">cx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> = <span style="font-style:italic">a</span>−<span style="font-style:italic">ex</span> 
    (64)</td></tr>
</table><p>
En prenant le carré, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">x</span>−<span style="font-style:italic">ea</span>)<sup>2</sup> + <span style="font-style:italic">y</span><sup>2</sup> = (<span style="font-style:italic">a</span>−<span style="font-style:italic">ex</span>)<sup>2</sup></td></tr>
</table><p>
d’où :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span><sup>2</sup> + <span style="font-style:italic">x</span><sup>2</sup> (1−<span style="font-style:italic">e</span><sup>2</sup>) = <span style="font-style:italic">a</span><sup>2</sup>(1−<span style="font-style:italic">e</span><sup>2</sup>) </td></tr>
</table><p>
finalement :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span><sup>2</sup> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">e</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> = <span style="font-style:italic">a</span><sup>2</sup> </td></tr>
</table><p>
qui est bien la contraction selon <span style="font-style:italic">Oy</span> de rapport √<span style="text-decoration:overline">1−</span><span style="text-decoration:overline"><span style="font-style:italic">e</span></span><sup><span style="text-decoration:overline">2</span></sup> du
cercle de centre <span style="font-style:italic">O</span> et de rayon <span style="font-style:italic">a</span> (appelé grand cercle de
l’ellipse).</p><p>En coordonnées polaires, on note ρ la distance de <span style="font-style:italic">F</span><sub>1</sub> à
<span style="font-style:italic">M</span>, et θ l’angle entre l’axe <span style="font-style:italic">Ox</span> et <span style="font-style:italic">F</span><sub>1</sub><span style="font-style:italic">M</span>. L’abscisse de <span style="font-style:italic">M</span>
est donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">x</span>= <span style="font-style:italic">ea</span> + ρ cos(θ)</td></tr>
</table><p>
que l’on combine avec (<a href="#eq%3AMF1">15</a>) pour obtenir :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ρ = <span style="font-style:italic">a</span>−<span style="font-style:italic">ex</span> =<span style="font-style:italic">a</span>(1−<span style="font-style:italic">e</span><sup>2</sup>) − <span style="font-style:italic">e</span> ρ cos(θ) </td></tr>
</table><p>
donc :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ρ = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>(1−<span style="font-style:italic">e</span><sup>2</sup>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">e</span>cos(θ)</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
ce qui nous permet d’affirmer que l’orbite de la Terre dans
l’approximation du point matériel soumis uniquement au Soleil
supposé fixe est une ellipse dont le Soleil occupe un foyer.</p>
<!--TOC subsection id="sec298" Influence de l’ellipse sur les saisons-->
<h3 id="sec298" class="subsection">26.5  Influence de l’ellipse sur les saisons</h3><!--SEC END --><p>
Il faut prendre garde à ne pas confondre les solstices et
équinoxes avec le moment où la Terre coupe le grand axe
de son ellipse autour du Soleil. Il n’y a aucune raison que la
projection de l’axe de rotation de la Terre sur le plan de l’ellipse
soit parallèle ou perpendiculaire au grand axe de l’ellipse, et
actuellement ce n’est pas le cas, le solstice d’hiver a lieu le
21 décembre alors que le passage au plus proche du Soleil a lieu
vers le 3 janvier (donc pendant l’hiver de l’hémisphère Nord)
et le passage au plus loin du Soleil a lieu début juillet
(pendant l’été). C’est pour cette raison que les saisons
sont moins marquées dans l’hémisphère Nord que dans 
l’hémisphère Sud. De plus la loi des aires oblige la Terre
a se déplacer plus vite lorsqu’elle est proche du Soleil que
lorsqu’elle en est éloignée ce qui diminue la durée de l’hiver
boréal et augmente la durée de l’été boréal (c’est
peut-être pour cette raison que février n’a que 
28 jours alors que juillet et aout ont 31 jours).</p>
<!--TOC subsection id="sec299" L’équation du temps, la durée des
saisons.-->
<h3 id="sec299" class="subsection">26.6  L’équation du temps, la durée des
saisons.</h3><!--SEC END --><p> <a id="sec:dureesaison"></a>
<a id="hevea_default347"></a> <a id="hevea_default348"></a>
</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div> <a id="fig:ell"></a>
<img src="algo001.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 1: Ellipse et équation du temps</td></tr>
</table></div>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>
La trajectoire elliptique <span style="font-style:italic">E</span> de la Terre autour du Soleil est
représentée sur la figure <a href="#fig%3Aell">26.6</a>
en bleu, l’excentricité de l’orbite a été énormément exagérée, il
s’agit d’une ellipse de foyers <span style="font-style:italic">S</span> (le Soleil) et <span style="font-style:italic">S</span>′. Le point <span style="font-style:italic">A</span> désigne
le périhélie de l’orbite (passage de la Terre au plus proche du Soleil), 
qui a lieu
vers le 4 janvier. En noir, on a dessiné le grand cercle de l’ellipse
(l’ellipse s’obtient par contraction du grand cercle de rapport √<span style="text-decoration:overline">1−</span><span style="text-decoration:overline"><span style="font-style:italic">e</span></span><sup><span style="text-decoration:overline">2</span></sup>
où <span style="font-style:italic">e</span> est l’excentricité de l’orbite).
L’aire décrite par le rayon Soleil-Terre (<span style="font-style:italic">ST</span>)
est proportionnelle au temps (loi des aires qui découle de la conservation
du moment cinétique), 
il en est donc de même de l’aire (en vert) du
décrite par le rayon <span style="font-style:italic">SM</span>. Si on ajoute à cette aire verte l’aire en 
rouge du triangle <span style="font-style:italic">OSM</span>, on obtient l’aire de l’arc de cercle <span style="font-style:italic">OAM</span>.
Donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">V</span> × <span style="font-style:italic">OA</span><sup>2</sup> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">OS</span> × <span style="font-style:italic">HM</span> </td></tr>
</table><p>
est proportionnel au temps écoulé depuis le passage au périhélie.
Comme <span style="font-style:italic">HM</span>=<span style="font-style:italic">OM</span> sin(<span style="font-style:italic">V</span>) et <span style="font-style:italic">OS</span>= <span style="font-style:italic">e</span> × <span style="font-style:italic">OA</span>, on en déduit que 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:tempsV"></a>
<span style="font-style:italic">V</span> − <span style="font-style:italic">e</span> sin(<span style="font-style:italic">V</span>) = <span style="font-style:italic">C</span> <span style="font-style:italic">t</span> = 2π </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span></td></tr>
</table></td><td class="dcell">
    (65)</td></tr>
</table><p>
où la constante <span style="font-style:italic">C</span> s’obtient en faisant varier <span style="font-style:italic">V</span> de 0 à 2π
ce qui correspond à la durée <span style="font-style:italic">T</span> d’une révolution de la Terre 
autour du Soleil (1 an).</p><p>La relation entre θ (noté <span style="font-style:italic">t</span> sur la figure)
et <span style="font-style:italic">V</span> s’obtient par exemple en calculant 
l’abscisse de <span style="font-style:italic">M</span> 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">x</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">a</span> cos(<span style="font-style:italic">V</span>) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">ea</span> + ρ cos(θ) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">ea</span> + <span style="font-style:italic">a</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">e</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">e</span>cos(θ)</td></tr>
</table></td><td class="dcell"> cos(θ)
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Les angles <span style="font-style:italic">V</span> et θ sont de même signe et
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:Vt"></a>
cos(<span style="font-style:italic">V</span>) = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">cos(θ)+<span style="font-style:italic">e</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">e</span>cos(θ)</td></tr>
</table></td><td class="dcell">
    (66)</td></tr>
</table><p>
et réciproquement :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:tV"></a>
cos(θ)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">cos(<span style="font-style:italic">V</span>)−<span style="font-style:italic">e</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">e</span> cos(<span style="font-style:italic">V</span>)</td></tr>
</table></td><td class="dcell"> 
    (67)</td></tr>
</table><p><span style="font-weight:bold">Durée des saisons </span>:<br>
Il suffit de connaitre l’angle θ lors du solstice d’hiver et
de lui ajouter <span style="font-style:italic">k</span>π/2 pour <span style="font-style:italic">k</span>=1,2,3 pour connaitre l’angle θ
au printemps, en été et à l’automne, on en déduit <span style="font-style:italic">V</span> par (<a href="#eq%3AVt">66</a>) 
puis le temps écoulé depuis le périhélie avec (<a href="#eq%3AtempsV">65</a>).</p><p><span style="font-weight:bold">Calcul de </span>θ<span style="font-weight:bold"> en fonction du temps écoulé depuis le passage
au périhélie</span> :<br>
Il faut calculer <span style="font-style:italic">V</span> par des méthodes numériques (point fixe ou 
méthode de Newton) en appliquant (<a href="#eq%3AtempsV">65</a>), on en déduit
θ avec (<a href="#eq%3AtV">67</a>).
En résumé, on a le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 60</span>  <em>
Soit </em>θ<em> l’angle entre le demi grand axe de l’ellipse et 
la direction Soleil-Terre, </em><span style="font-style:italic">t</span>∈ [−<span style="font-style:italic">T</span>/2,<span style="font-style:italic">T</span>/2]<em> le temps écoulé depuis le passage
au périhélie (</em><span style="font-style:italic">t</span>=0<em> lorsque </em>θ=0<em>, </em><span style="font-style:italic">T</span>=1<em> an). Soit </em><span style="font-style:italic">V</span>∈ [−π,π]<em> 
la solution de 
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">V</span> − <span style="font-style:italic">e</span> sin(<span style="font-style:italic">V</span>) = 2π </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span></td></tr>
</table></td><td class="dcell"><em> </em></td></tr>
</table><em>
où </em><span style="font-style:italic">e</span><em> est l’excentricité de l’ellipse.
Alors </em>θ<em> est donné par
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">cos(θ)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">cos(<span style="font-style:italic">V</span>)−<span style="font-style:italic">e</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">e</span> cos(<span style="font-style:italic">V</span>)</td></tr>
</table></td><td class="dcell"><em>  </em></td></tr>
</table><em>
</em></div>
<!--TOC subsection id="sec300" Les variations des paramètres orbitaux-->
<h3 id="sec300" class="subsection">26.7  Les variations des paramètres orbitaux</h3><!--SEC END --><p>
La Terre n’est pas une sphère idéale, elle a un renflement au niveau
de l’équateur, due à rotation de la Terre sur elle-même (la force
centrifuge y est plus importante). Ce renflement est dans un plan
qui fait un angle avec le plan de l’écliptique, le Soleil exerce
donc un couple sur ce renflement. Ce phénomène est à l’origine
de la précession des équinoxes, le passage au périhélie de la Terre
se décale dans le temps.
De plus, la Terre n’est pas seulement soumise à l’influence du Soleil,
mais aussi des autres planètes, en particulier Jupiter. Cela
modifie sur de très longues périodes tous les paramètres
de l’orbite terrestre, en particulier l’excentricité, la précession
des équinoxes, mais aussi l’obliquité (inclinaison de l’axe de
rotation terrestre par rapport à la perpendiculaire au plan de
l’écliptique).
Le calcul de ces variations est bien au-delà des prétentions de ce texte,
le lecteur intéressé pourra se référer par exemple aux publications
de Laskar (chercher ce mot-clef ou des mots comme orbite,
perturbation, symplectique, hamiltonien, ...). On se bornera ici
à indiquer que le demi-grand axe ne varie pas, ce qui donne
une relation entre les variations de la constante des aires et 
de l’excentricité 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">L</span>  est proportionnel à  </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">e</span><sup>2</sup></td></tr>
</table></td></tr>
</table><p>Les variations des paramètre orbitaux
modifient à long terme l’ensolleillement de la Terre (la valeur
de l’énergie reçue en un lieu sur une surface horizontale <span style="font-style:italic">s</span>.<span style="font-style:italic">v</span>/ρ<sup>2</sup>
dépend de la latitude, de la position de la Terre sur son orbite
mais aussi de l’excentricité de l’orbite, de l’obliquité
et de la date du périhélie par rapport aux saisons) et
sa répartition sur le globe par latitude, il est naturel de supposer
qu’elles influent sur le climat de la Terre.
Par exemple, l’énergie moyenne recue par la Terre au cours d’une
période <span style="font-style:italic">T</span> de une année est donnée par
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span></td></tr>
</table></td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">T</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ρ<sup>2</sup></td></tr>
</table></td><td class="dcell"> = 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span></td></tr>
</table></td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">2π</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">d</span>θ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">L</span></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2 π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">T</span> <span style="font-style:italic">L</span></td></tr>
</table></td><td class="dcell">  </td></tr>
</table><p>
est proportionnelle à 1/(<span style="font-style:italic">T</span> <span style="font-style:italic">L</span>) donc à (1−<span style="font-style:italic">e</span><sup>2</sup>)<sup>−1/2</sup> (car
<span style="font-style:italic">T</span> est aussi constant d’après la 3ème loi de Képler).
Au premier ordre, la variation de <span style="font-style:italic">e</span> entraine donc une variation de 
l’ensolleillement global de
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>2</sup></td></tr>
</table><p>
Pour la Terre, cela représente au plus 2.5 pour mille (la période
la plus favorable aux glaciations étant celle où l’orbite est
circulaire), soit, sans rétroactions, une variation globale
de 0.2 degrés Kelvin.</p>
<!--TOC section id="sec301" La moyenne arithmético-géométrique.-->
<h2 id="sec301" class="section">27  La moyenne arithmético-géométrique.</h2><!--SEC END --><p>
<a id="sec:agm"></a>
<a id="hevea_default349"></a>
La moyenne arithmético-géométrique est un processus itératif
qui converge très rapidement et est très utile pour calculer
les fonctions transcendantes réciproques en multi-précision. 
On peut alors trouver les fonctions transcendantes directes
par application de la méthode de Newton.</p>
<!--TOC subsection id="sec302" Définition et convergence-->
<h3 id="sec302" class="subsection">27.1  Définition et convergence</h3><!--SEC END --><p>
Soient <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> deux réels positifs,
on définit les 2 suites 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:agm"></a>
<span style="font-style:italic">u</span><sub>0</sub>=<span style="font-style:italic">a</span>, <span style="font-style:italic">v</span><sub>0</sub>=<span style="font-style:italic">b</span>,    <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>+<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">, <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub>=</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell"> 
    (68)</td></tr>
</table><p>
On va montrer que ces 2 suites sont adjacentes et convergent donc vers
une limite commune notée <span style="font-style:italic">M</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>) et il se trouve que la convergence
est très rapide, en raison de l’identité :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:agm1"></a>
<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">−</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">)<sup>2</sup>
=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">2(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">)<sup>2</sup></td></tr>
</table></td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>)<sup>2</sup>
    (69)</td></tr>
</table><p>
la convergence est quadratique.</p><p>On suppose dans la suite que <span style="font-style:italic">a</span>≥ <span style="font-style:italic">b</span> sans changer la généralité puisque échanger <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span>
ne change pas la valeur de <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> et <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> pour <span style="font-style:italic">n</span>&gt;0. On a alors <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> ≥ <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> 
(d’après (<a href="#eq%3Aagm1">69</a>) pour <span style="font-style:italic">n</span>&gt;0) et <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub> ≤ <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> car
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>) ≤ 0</td></tr>
</table><p>
et <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub>=√<span style="text-decoration:overline"><span style="font-style:italic">u</span></span><sub><span style="text-decoration:overline"><span style="font-style:italic">n</span></span></sub><span style="text-decoration:overline"><span style="font-style:italic">v</span></span><sub><span style="text-decoration:overline"><span style="font-style:italic">n</span></span></sub> ≥ √<span style="text-decoration:overline"><span style="font-style:italic">v</span></span><sub><span style="text-decoration:overline"><span style="font-style:italic">n</span></span></sub><span style="text-decoration:overline"><span style="font-style:italic">v</span></span><sub><span style="text-decoration:overline"><span style="font-style:italic">n</span></span></sub>=<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>. Donc (<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>) est décroissante 
minorée (par <span style="font-style:italic">v</span><sub>0</sub>), (<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>) est croissante majorée (par <span style="font-style:italic">u</span><sub>0</sub>), ces 2 suites sont 
convergentes et comme <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>+<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>/2, elles convergent vers la même limite 
<span style="font-style:italic">l</span> qui dépend de <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> et que l’on note <span style="font-style:italic">M</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>).
On remarque aussi que <span style="font-style:italic">M</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>)=<span style="font-style:italic">bM</span>(<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>,1)=<span style="font-style:italic">aM</span>(1,<span style="font-style:italic">b</span>/<span style="font-style:italic">a</span>). </p><p>Précisons maintenant la vitesse de convergence lorsque <span style="font-style:italic">a</span> ≥ <span style="font-style:italic">b</span>&gt;0. 
On va commencer par estimer le nombre
d’itérations nécessaires pour que <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> et <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> soient du même ordre de grandeur.
Pour cela, on utilise la majoration
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ln(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>)−ln(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub>) ≤ ln(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)−ln(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub>) = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">
(ln(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)−ln(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>)) </td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ln</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell"> = ln(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)−ln(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>) ≤ 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup><span style="font-style:italic">n</span></sup></td></tr>
</table></td><td class="dcell"> (ln(<span style="font-style:italic">a</span>)−ln(<span style="font-style:italic">b</span>)) = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup><span style="font-style:italic">n</span></sup></td></tr>
</table></td><td class="dcell"> ln</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Donc si <span style="font-style:italic">n</span> ≥ ln( ln(<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>)/<span style="font-style:italic">m</span>)/ln(2) alors
ln<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>/<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> ≤ <span style="font-style:italic">m</span> (par exemple, on peut prendre <span style="font-style:italic">m</span>=0.1 pour 
avoir <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>/<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> ∈ [1,<span style="font-style:italic">e</span><sup>0.1</sup>]). Le nombre minimum d’itérations <span style="font-style:italic">n</span><sub>0</sub> est proportionnel
au log du log du rapport <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span>.
Ensuite on est ramené à étudier la convergence de la suite arithmético-géométrique
de premiers termes <span style="font-style:italic">a</span>=<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span><sub>0</sub></sub> et <span style="font-style:italic">b</span>=<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span><sub>0</sub></sub> et même en tenant compte
de <span style="font-style:italic">M</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>)=<span style="font-style:italic">aM</span>(1,<span style="font-style:italic">b</span>/<span style="font-style:italic">a</span>) à <span style="font-style:italic">a</span>=1 et <span style="font-style:italic">b</span>=<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>/<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> donc 0≤ <span style="font-style:italic">a</span>−<span style="font-style:italic">b</span> ≤ 1−<span style="font-style:italic">e</span><sup>−0.1</sup>.
Alors l’équation (<a href="#eq%3Aagm1">69</a>) entraine 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>−<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub> ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">8</td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>)<sup>2</sup> </td></tr>
</table><p>
puis (par récurrence)
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">0 ≤ <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>−<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">8<sup>2<sup><span style="font-style:italic">n</span></sup>−1</sup></td></tr>
</table></td><td class="dcell">(<span style="font-style:italic">a</span>−<span style="font-style:italic">b</span>)<sup>2<sup><span style="font-style:italic">n</span></sup></sup> </td></tr>
</table><p>
Donc comme <span style="font-style:italic">M</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>) est compris entre <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> et <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>, l’erreur relative sur la limite
commune est inférieure à une précision donnée є
au bout d’un nombre d’itérations proportionnel au ln(ln(1/є)).</p><p>Typiquement dans la suite, on souhaitera calculer <span style="font-style:italic">M</span>(1,<span style="font-style:italic">b</span>) avec <span style="font-style:italic">b</span> de l’ordre
de 2<sup>−<span style="font-style:italic">n</span></sup> en déterminant <span style="font-style:italic">n</span> chiffres significatifs,
il faudra alors <span style="font-style:italic">O</span>(ln(<span style="font-style:italic">n</span>)) itérations pour se ramener à <span style="font-style:italic">M</span>(1,<span style="font-style:italic">b</span>) avec <span style="font-style:italic">b</span>∈ [<span style="font-style:italic">e</span><sup>−0.1</sup>,1] 
puis <span style="font-style:italic">O</span>(ln(<span style="font-style:italic">n</span>)) itérations pour avoir la limite avec <span style="font-style:italic">n</span> chiffres significatifs.</p><p><span style="font-weight:bold">Le cas complexe</span><br>
On suppose maintenant que <span style="font-style:italic">a</span>, <span style="font-style:italic">b</span> ∈ ℂ avec ℜ(<span style="font-style:italic">a</span>)&gt;0, ℜ(<span style="font-style:italic">b</span>)&gt;0. On va voir que
la suite arithmético-géométrique converge encore. <br>
<span style="font-weight:bold">Étude de l’argument</span><br>
On voit aisément (par récurrence)
que ℜ(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)&gt;0 ; de plus ℜ(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>) &gt; 0 car par définition de la racine carrée
ℜ(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>)≥ 0 et est de plus non nul car le produit de deux complexes d’arguments dans 
]−π/2,π/2[ ne peut pas être un réel négatif.
On en déduit que
arg(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>)=arg(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>+<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>) se trouve dans l’intervalle de bornes
arg(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>) et arg(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>) et que arg(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub>)=1/2(arg(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)+arg(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>))
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| arg(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>−arg(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub>) | ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">|arg(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)−arg(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>)| </td></tr>
</table><p>
Après <span style="font-style:italic">n</span> itérations, on a 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|arg(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)−arg(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>)| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup><span style="font-style:italic">n</span></sup></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Après quelques itérations, <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> et <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> seront donc presque alignés. 
Faisons 4 itérations.
On peut factoriser par exemple <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> et on
est ramené à l’étude de la suite de termes initiaux <span style="font-style:italic">a</span>=<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>/<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> d’argument 
arg(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)−arg(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>) petit 
(inférieur en valeur absolue à π/16) et <span style="font-style:italic">b</span>=1. On suppose donc dans la suite que
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|arg(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">)| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π/16</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup><span style="font-style:italic">n</span></sup></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
<span style="font-weight:bold">Étude du module</span><br>
On a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub></td></tr>
</table></td><td class="dcell">= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
Posons  <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>/<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>=ρ<sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">e</span><sup><span style="font-style:italic">i</span>θ<sub><span style="font-style:italic">n</span></sub></sup>, on a :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub></td></tr>
</table></td><td class="dcell">|</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup><span style="font-style:italic">i</span>θ<sub><span style="font-style:italic">n</span></sub>/2</sup>
+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">e</span><sup>−<span style="font-style:italic">i</span>θ<sub><span style="font-style:italic">n</span></sub>/2</sup> </td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪</td><td class="dcell">(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">)cos</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">θ<sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">
+ <span style="font-style:italic">i</span> (</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">− </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">)sin</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">θ<sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:6em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> (</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">)<sup>2</sup>cos<sup>2</sup></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">θ<sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">
+ (</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">− </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">)<sup>2</sup>sin<sup>2</sup></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">θ<sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> ρ<sub><span style="font-style:italic">n</span></sub>+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell"> +2cosθ<sub><span style="font-style:italic">n</span></sub> </td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Si ρ désigne le max de ρ<sub><span style="font-style:italic">n</span></sub> et 1/ρ<sub><span style="font-style:italic">n</span></sub>, on a alors la majoration
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub></td></tr>
</table></td><td class="dcell">| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" > ρ + ρ + 2 ρ </td></tr>
</table></td><td class="dcell"> 
= </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >ρ</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
donc en prenant les logarithmes
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:lnrhon"></a>
lnρ<sub><span style="font-style:italic">n</span>+1</sub> ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">  lnρ=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">  |lnρ<sub><span style="font-style:italic">n</span></sub>| 
    (70)</td></tr>
</table><p>
On rappelle qu’on a la majoration 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|arg(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">)| = |θ<sub><span style="font-style:italic">n</span></sub>| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π/16</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup><span style="font-style:italic">n</span></sup></td></tr>
</table></td><td class="dcell"> ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup><span style="font-style:italic">n</span>+1</sup></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
qui va nous donner la minoration de ρ<sub><span style="font-style:italic">n</span>+1</sub> 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">ρ<sub><span style="font-style:italic">n</span>+1</sub>=|</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub></td></tr>
</table></td><td class="dcell">|</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">
</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> ρ<sub><span style="font-style:italic">n</span></sub>+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell"> +2 − 2 (1−cosθ<sub><span style="font-style:italic">n</span></sub>) </td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> ρ<sub><span style="font-style:italic">n</span></sub>+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell"> +2 − 4 sin<sup>2</sup> (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">θ<sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">) </td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≥</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> ρ<sub><span style="font-style:italic">n</span></sub>+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell"> +2 − θ<sub><span style="font-style:italic">n</span></sub><sup>2</sup></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≥</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> ρ<sub><span style="font-style:italic">n</span></sub>+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell"> +2</td></tr>
</table></td></tr>
</table></td><td class="dcell"> × 
</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:8em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1 − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">θ<sub><span style="font-style:italic">n</span></sub><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">ρ<sub><span style="font-style:italic">n</span></sub>+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ρ<sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell"> +2</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≥</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ρ</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ρ</td></tr>
</table></td><td class="dcell"> +2</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ρ</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> × 
</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1 − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">θ<sub><span style="font-style:italic">n</span></sub><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≥</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >ρ</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1 − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">θ<sub><span style="font-style:italic">n</span></sub><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≥</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >ρ</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1 − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4 × 2<sup>2<span style="font-style:italic">n</span>+2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
en prenant les log et en minorant ln(1−<span style="font-style:italic">x</span>) par −2<span style="font-style:italic">x</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">lnρ<sub><span style="font-style:italic">n</span>+1</sub> ≥ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> (−|lnρ<sub><span style="font-style:italic">n</span></sub>|+ln(1 −</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4 × 2<sup>2<span style="font-style:italic">n</span>+2</sup></td></tr>
</table></td><td class="dcell"> ))
≥ −</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> (|lnρ<sub><span style="font-style:italic">n</span></sub>|+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup>2<span style="font-style:italic">n</span>+3</sup></td></tr>
</table></td><td class="dcell"> )  </td></tr>
</table><p>
Finalement avec (<a href="#eq%3Alnrhon">70</a>)
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|lnρ<sub><span style="font-style:italic">n</span>+1</sub>|
≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> (|lnρ<sub><span style="font-style:italic">n</span></sub>|+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup>2<span style="font-style:italic">n</span>+3</sup></td></tr>
</table></td><td class="dcell"> ) </td></tr>
</table><p>
On en déduit
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|lnρ<sub><span style="font-style:italic">n</span></sub>| ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup><span style="font-style:italic">n</span></sup></td></tr>
</table></td><td class="dcell"> lnρ<sub>0</sub> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup><span style="font-style:italic">n</span>+3</sup></td></tr>
</table></td><td class="dcell"> + ... +
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup>2<span style="font-style:italic">n</span>+1</sup></td></tr>
</table></td><td class="dcell"> +  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup>2<span style="font-style:italic">n</span>+2</sup></td></tr>
</table></td><td class="dcell">
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup><span style="font-style:italic">n</span></sup></td></tr>
</table></td><td class="dcell"> lnρ<sub>0</sub> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup><span style="font-style:italic">n</span>+2</sup></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
La convergence du ln(<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>/<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>) vers 0 est donc géométrique, donc <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> et <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> convergent
quadratiquement.</p>
<!--TOC subsection id="sec303" Lien avec les intégrales elliptiques-->
<h3 id="sec303" class="subsection">27.2  Lien avec les intégrales elliptiques</h3><!--SEC END --><p><a id="hevea_default350"></a>
Le calcul de la limite commune des suites <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> et <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> en fonction
de <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> n’est pas trivial
au premier abord. Il est relié aux intégrales elliptiques, plus
précisément on peut construire une intégrale dépendant
de deux paramètres <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> et qui est invariante par
la transformation <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>,<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> → <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>+1</sub>,<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>+1</sub> (<a href="#eq%3Aagm">68</a>)
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>)=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">−∞</td></tr>
</table></td><td class="dcell">  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">a</span><sup>2</sup>+<span style="font-style:italic">t</span><sup>2</sup>)(<span style="font-style:italic">b</span><sup>2</sup>+<span style="font-style:italic">t</span><sup>2</sup>)</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
On a en effet
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span>(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>+<span style="font-style:italic">b</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">,</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">ab</span></td></tr>
</table></td><td class="dcell">)
= </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">−∞</td></tr>
</table></td><td class="dcell">  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">du</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">((</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>+<span style="font-style:italic">b</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)<sup>2</sup>+<span style="font-style:italic">u</span><sup>2</sup>)(<span style="font-style:italic">ab</span>+<span style="font-style:italic">u</span><sup>2</sup>)</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
On pose alors 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">u</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> (<span style="font-style:italic">t</span>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">ab</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">t</span></td></tr>
</table></td><td class="dcell">),    <span style="font-style:italic">t</span>&gt;0 </td></tr>
</table><p>
où <span style="font-style:italic">t</span> → <span style="font-style:italic">u</span> est une bijection croissante de <span style="font-style:italic">t</span>∈]0,+∞[ vers 
<span style="font-style:italic">u</span> ∈ ]−∞,+∞[, donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span>(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>+<span style="font-style:italic">b</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">,</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">ab</span></td></tr>
</table></td><td class="dcell">)</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell">  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span>/2(1+<span style="font-style:italic">ab</span>/<span style="font-style:italic">t</span><sup>2</sup>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">((</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span>+<span style="font-style:italic">b</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)<sup>2</sup>+1/4(<span style="font-style:italic">t</span>−<span style="font-style:italic">ab</span>/<span style="font-style:italic">t</span>)<sup>2</sup>)(<span style="font-style:italic">ab</span>+1/4(<span style="font-style:italic">t</span>−<span style="font-style:italic">ab</span>/<span style="font-style:italic">t</span>)<sup>2</sup>)</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">2 </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">a</span><sup>2</sup>+<span style="font-style:italic">t</span><sup>2</sup>)(<span style="font-style:italic">b</span><sup>2</sup>+<span style="font-style:italic">t</span><sup>2</sup>)</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">
= <span style="font-style:italic">I</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>)
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
On note au passage que <span style="font-style:italic">I</span> est définie si <span style="font-style:italic">a</span>,<span style="font-style:italic">b</span> ∈ ℂ vérifient ℜ(<span style="font-style:italic">a</span>)&gt;0, ℜ(<span style="font-style:italic">b</span>)&gt;0,
on peut montrer que la relation ci-dessus s’étend (par holomorphie).</p><p>Lorsque <span style="font-style:italic">a</span>=<span style="font-style:italic">b</span>=<span style="font-style:italic">l</span> (par exemple lorsqu’on est à la limite), 
le calcul de <span style="font-style:italic">I</span>(<span style="font-style:italic">l</span>,<span style="font-style:italic">l</span>) est explicite
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span>(<span style="font-style:italic">l</span>,<span style="font-style:italic">l</span>)=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">−∞</td></tr>
</table></td><td class="dcell">  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dt</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">l</span><sup>2</sup>+<span style="font-style:italic">t</span><sup>2</sup>)</td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span></td></tr>
</table></td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>)=<span style="font-style:italic">I</span>(<span style="font-style:italic">M</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>),<span style="font-style:italic">M</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>))=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>)</td></tr>
</table></td></tr>
</table><p>
On peut transformer <span style="font-style:italic">I</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>) en posant <span style="font-style:italic">t</span>=<span style="font-style:italic">bu</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>)=2</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell">  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">du</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">a</span><sup>2</sup>+<span style="font-style:italic">b</span><sup>2</sup><span style="font-style:italic">u</span><sup>2</sup>)(1+<span style="font-style:italic">u</span><sup>2</sup>)</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">+∞</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell">  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">du</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >(1+(<span style="font-style:italic">b</span>/<span style="font-style:italic">a</span>)<sup>2</sup><span style="font-style:italic">u</span><sup>2</sup>)(1+<span style="font-style:italic">u</span><sup>2</sup>)</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Puis en posant <span style="font-style:italic">u</span>=tan(<span style="font-style:italic">x</span>) (<span style="font-style:italic">du</span>=(1+<span style="font-style:italic">u</span><sup>2</sup>) <span style="font-style:italic">dx</span>)
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">1+tan(<span style="font-style:italic">x</span>)<sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">1+(<span style="font-style:italic">b</span>/<span style="font-style:italic">a</span>)<sup>2</sup>tan(<span style="font-style:italic">x</span>)<sup>2</sup></td></tr>
</table></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dx</span> </td></tr>
</table><p>
et enfin en posant tan<sup>2</sup>(<span style="font-style:italic">x</span>)=sin(<span style="font-style:italic">x</span>)<sup>2</sup>/1−sin(<span style="font-style:italic">x</span>)<sup>2</sup>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">I</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">b</span>)= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell">  
</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:8em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">b</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sup>2</sup></td></tr>
</table></td><td class="dcell">)sin(<span style="font-style:italic">x</span>)<sup>2</sup></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dx</span></td></tr>
</table><p>
Si on définit pour <span style="font-style:italic">m</span>&lt;1
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">K</span>(<span style="font-style:italic">m</span>)=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">m</span> sin(<span style="font-style:italic">x</span>)<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
alors on peut calculer <span style="font-style:italic">K</span> en fonction de <span style="font-style:italic">I</span>, en posant
<span style="font-style:italic">m</span>=1−<span style="font-style:italic">b</span><sup>2</sup>/<span style="font-style:italic">a</span><sup>2</sup> soit <span style="font-style:italic">b</span><sup>2</sup>/<span style="font-style:italic">a</span><sup>2</sup>=1−<span style="font-style:italic">m</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">K</span>(<span style="font-style:italic">m</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">I</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">a</span></td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">m</span></td></tr>
</table></td><td class="dcell">)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">M</span>(<span style="font-style:italic">a</span>,<span style="font-style:italic">a</span></td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">m</span></td></tr>
</table></td><td class="dcell">)</td></tr>
</table></td></tr>
</table></td><td class="dcell">
=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">2<span style="font-style:italic">M</span>(1,</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">m</span></td></tr>
</table></td><td class="dcell">)</td></tr>
</table></td></tr>
</table></td><td class="dcell"> 
</td></tr>
</table><p>
d’où l’on déduit la valeur de l’intégrale elliptique en fonction
de la moyenne arithmético-géométrique :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:K"></a>
<span style="font-style:italic">K</span>(<span style="font-style:italic">m</span>)=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">m</span> sin(<span style="font-style:italic">x</span>)<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">= 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">2<span style="font-style:italic">M</span>(1,</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">m</span></td></tr>
</table></td><td class="dcell">)</td></tr>
</table></td></tr>
</table></td><td class="dcell"> 
    (71)</td></tr>
</table><p>
Dans l’autre sens, pour <span style="font-style:italic">x</span> et <span style="font-style:italic">y</span> positifs
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">K</span>( (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>−<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>+<span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell">)<sup>2</sup> )=  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">2<span style="font-style:italic">M</span>(1,</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>−<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>+<span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell">)<sup>2</sup></td></tr>
</table></td></tr>
</table></td><td class="dcell">)</td></tr>
</table></td></tr>
</table></td><td class="dcell">
=  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">2<span style="font-style:italic">M</span>(1,</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>+<span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">xy</span></td></tr>
</table></td><td class="dcell">)</td></tr>
</table></td></tr>
</table></td><td class="dcell">
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">2 </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>+<span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">M</span>(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>+<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">,</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">xy</span></td></tr>
</table></td><td class="dcell">) </td></tr>
</table></td></tr>
</table></td><td class="dcell">
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>+<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)</td></tr>
</table></td></tr>
</table><p>
et finalement
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">M</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>)=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>+<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"> <span style="font-style:italic">K</span></td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>−<span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span>+<span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">2</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell"> )</td></tr>
</table></td></tr>
</table></td></tr>
</table>
<!--TOC subsection id="sec304" Application : calcul efficace du logarithme.-->
<h3 id="sec304" class="subsection">27.3  Application : calcul efficace du logarithme.</h3><!--SEC END --><p><a id="hevea_default351"></a>
On peut utiliser la moyenne arithmético-géométrique pour
calculer le logarithme efficacement, pour cela on cherche le développement
asymptotique de <span style="font-style:italic">K</span>(<span style="font-style:italic">m</span>) lorsque <span style="font-style:italic">m</span> tend vers 1. Plus précisément,
on va poser 1−<span style="font-style:italic">m</span>=<span style="font-style:italic">k</span><sup>2</sup> avec <span style="font-style:italic">k</span> ∈ ]0,1], donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">K</span>(<span style="font-style:italic">m</span>)= </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dx</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−(1−<span style="font-style:italic">k</span><sup>2</sup>) sin(<span style="font-style:italic">x</span>)<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">
=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−(1−<span style="font-style:italic">k</span><sup>2</sup>) cos(<span style="font-style:italic">y</span>)<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
en posant <span style="font-style:italic">y</span>=π/2−<span style="font-style:italic">x</span>, et
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">K</span>(<span style="font-style:italic">m</span>)=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >sin(<span style="font-style:italic">y</span>)<sup>2</sup>+<span style="font-style:italic">k</span><sup>2</sup> cos(<span style="font-style:italic">y</span>)<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
la singularité de l’intégrale pour <span style="font-style:italic">k</span> proche
de 0 apparait lorsque <span style="font-style:italic">y</span> est proche de 0.
Si on effectue un développement de Taylor en <span style="font-style:italic">y</span>=0, on trouve
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">sin(<span style="font-style:italic">y</span>)<sup>2</sup>+<span style="font-style:italic">k</span><sup>2</sup> cos(<span style="font-style:italic">y</span>)<sup>2</sup> = <span style="font-style:italic">k</span><sup>2</sup> + (1−<span style="font-style:italic">k</span><sup>2</sup>) <span style="font-style:italic">y</span><sup>2</sup> + <span style="font-style:italic">O</span>(<span style="font-style:italic">y</span><sup>4</sup>)</td></tr>
</table><p>
Il est donc naturel de comparer <span style="font-style:italic">K</span>(<span style="font-style:italic">m</span>) à l’intégrale
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">J</span>=</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">dy</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">k</span><sup>2</sup> + (1−<span style="font-style:italic">k</span><sup>2</sup>) <span style="font-style:italic">y</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
qui se calcule en faisant par exemple le changement de variables
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">y</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">k</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> sinh(<span style="font-style:italic">t</span>)</td></tr>
</table><p>
ou directement avec Xcas, 
</p><div class="center">
<code>supposons(k&gt;0 &amp;&amp; k&lt;1);</code><br>
<code>J:=int(1/sqrt(k^2+(1-k^2)*y^2),y,0,pi/2)</code>
</div><p>
qui donne après réécriture :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:J"></a>
<span style="font-style:italic">J</span>= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">k</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">ln</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">+
ln</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> 1−<span style="font-style:italic">k</span><sup>2</sup> +4 </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">π<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> 
+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">k</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
    (72)</td></tr>
</table><p>
et on peut calculer le développement asymptotique de <span style="font-style:italic">J</span> en 0
</p><div class="center">
<code>series(J,k=0,5,1)</code>
</div><p>
qui renvoie :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">J</span> =ln</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">+<span style="font-style:italic">O</span>( </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ln(<span style="font-style:italic">k</span>)</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">5</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell">)</td></tr>
</table><p>
on peut alors préciser ce développement par
</p><div class="center">
<code>series(J+ln(k)-ln(pi),k=0,5,1)</code>
</div><p>
qui renvoie (après simplifications et où la notation Õ peut contenir des logarithmes)
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">π<sup>2</sup></td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ln(π)−ln(<span style="font-style:italic">k</span>)−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><span style="font-style:italic">k</span><sup>2</sup> + 
Õ(<span style="font-style:italic">k</span><sup>4</sup>)</td></tr>
</table><p>
donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
<span style="font-style:italic">J</span>=−ln(<span style="font-style:italic">k</span>)+ln(π)+</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">π<sup>2</sup></td></tr>
</table></td><td class="dcell"> + 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ln(π)−ln(<span style="font-style:italic">k</span>)−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><span style="font-style:italic">k</span><sup>2</sup> + Õ(<span style="font-style:italic">k</span><sup>4</sup>)
    (73)</td></tr>
</table><p>
Examinons maintenant <span style="font-style:italic">K</span>−<span style="font-style:italic">J</span>, il n’a plus de singularité en <span style="font-style:italic">y</span>=0, et il admet une limite
lorsque <span style="font-style:italic">k</span> → 0, obtenue en remplacant <span style="font-style:italic">k</span> par 0
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">K</span>−<span style="font-style:italic">J</span>)<sub>|<span style="font-style:italic">k</span>=0</sub> = </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">sin(<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
 <span style="font-style:italic">dy</span> = </td><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell">ln</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">tan</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">− ln(<span style="font-style:italic">y</span>) </td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> =
ln(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">π</td></tr>
</table></td><td class="dcell">)</td></tr>
</table><p>
D’où pour <span style="font-style:italic">K</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">K</span><sub><span style="font-style:italic">k</span> → 0</sub> = ln</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">+ <span style="font-style:italic">O</span>( </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">ln(<span style="font-style:italic">k</span>)</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">5</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell">)</td></tr>
</table><p>
Pour préciser la partie du développement de <span style="font-style:italic">K</span> en puissances de <span style="font-style:italic">k</span>, nous allons
majorer <span style="font-style:italic">K</span>−<span style="font-style:italic">J</span>−ln(4/π), puis <span style="font-style:italic">J</span>−ln(π/<span style="font-style:italic">k</span>).
Posons
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>=sin(<span style="font-style:italic">y</span>)<sup>2</sup>+<span style="font-style:italic">k</span><sup>2</sup> cos(<span style="font-style:italic">y</span>)<sup>2</sup>,    <span style="font-style:italic">B</span>=<span style="font-style:italic">y</span><sup>2</sup>+(1−<span style="font-style:italic">y</span><sup>2</sup>)<span style="font-style:italic">k</span><sup>2</sup></td></tr>
</table><p>
<span style="font-weight:bold">Majoration de </span><span style="font-style:italic">K</span>−<span style="font-style:italic">J</span>−ln(4/π)<br>
L’intégrand de la différence <span style="font-style:italic">K</span>−<span style="font-style:italic">J</span>−ln(4/π) est
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">


     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> − 
</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">sin(<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell">−</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span></td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> −
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span>−sin(<span style="font-style:italic">y</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span>sin(<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell"> 
</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >    (74)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span>−<span style="font-style:italic">A</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell"> (</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell">)</td></tr>
</table></td></tr>
</table></td><td class="dcell"> −
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span>−sin(<span style="font-style:italic">y</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span>sin(<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell"> <a id="eq:maj0"> </a>
</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >    (75)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">y</span><sup>2</sup>−sin(<span style="font-style:italic">y</span>)<sup>2</sup>)(1−<span style="font-style:italic">k</span><sup>2</sup>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell"> (</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell">)</td></tr>
</table></td></tr>
</table></td><td class="dcell">
− </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span>−sin(<span style="font-style:italic">y</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span>sin(<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell"> <a id="eq:maj1"> </a>
</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >    (76)</td></tr>
</table></td></tr>
</table><p>
Soit
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:maj2"></a>
<span style="font-style:italic">K</span>−<span style="font-style:italic">J</span>−ln(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">π</td></tr>
</table></td><td class="dcell">)= </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">y</span>−sin(<span style="font-style:italic">y</span>))[(1−<span style="font-style:italic">k</span><sup>2</sup>)<span style="font-style:italic">y</span> sin(<span style="font-style:italic">y</span>)(<span style="font-style:italic">y</span>+sin(<span style="font-style:italic">y</span>))−</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">AB</span></td></tr>
</table></td><td class="dcell">(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell">)]</td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell"> (</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell">)<span style="font-style:italic">y</span>sin(<span style="font-style:italic">y</span>)</td></tr>
</table></td></tr>
</table></td><td class="dcell">
    (77)</td></tr>
</table><p>
On décompose l’intégrale en 2 parties [0,<span style="font-style:italic">k</span>] et [<span style="font-style:italic">k</span>,π/2].
Sur [0,<span style="font-style:italic">k</span>] on utilise (<a href="#eq%3Amaj0">75</a>), on majore chaque terme séparément
et on minore <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> par
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>=<span style="font-style:italic">k</span><sup>2</sup>+(1−<span style="font-style:italic">k</span><sup>2</sup>)sin(<span style="font-style:italic">y</span>)<sup>2</sup> ≥ <span style="font-style:italic">k</span><sup>2</sup>,    <span style="font-style:italic">B</span>=<span style="font-style:italic">k</span><sup>2</sup>+(1−<span style="font-style:italic">k</span><sup>2</sup>)<span style="font-style:italic">y</span><sup>2</sup> ≥ <span style="font-style:italic">k</span><sup>2</sup></td></tr>
</table><p>
Donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">| </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> |</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">|<span style="font-style:italic">B</span>−<span style="font-style:italic">A</span>|</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">k</span><sup>3</sup></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dy</span> + </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> ( </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">sin(<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell"> ) 
 <span style="font-style:italic">dy</span> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span><sup>2</sup>−sin(<span style="font-style:italic">y</span>)<sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">k</span><sup>3</sup></td></tr>
</table></td><td class="dcell">  <span style="font-style:italic">dy</span> + ln(tan(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)) −ln(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">) </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">k</span><sup>3</sup>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">k</span>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell"> sin(2 <span style="font-style:italic">k</span>)</td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2 <span style="font-style:italic">k</span><sup>3</sup></td></tr>
</table></td><td class="dcell"> 
+ ln(sin(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)) −ln(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">) − ln(cos(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">))
</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">k</span><sup>3</sup>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">−1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">k</span>+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell"> (2<span style="font-style:italic">k</span>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">8<span style="font-style:italic">k</span><sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">32<span style="font-style:italic">k</span><sup>5</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">5!</td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2 <span style="font-style:italic">k</span><sup>3</sup></td></tr>
</table></td><td class="dcell"> − ln(cos(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)) </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">30</td></tr>
</table></td><td class="dcell">−  ln(1− </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2!</td></tr>
</table></td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">2</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">&nbsp;</td></tr>
</table></td><td class="dcell">) </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">30</td></tr>
</table></td><td class="dcell"> +</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Sur [<span style="font-style:italic">k</span>,π/2], on utilise (<a href="#eq%3Amaj2">77</a>)
et on minore <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> par
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>=sin(<span style="font-style:italic">y</span>)<sup>2</sup>+<span style="font-style:italic">k</span><sup>2</sup> cos(<span style="font-style:italic">y</span>)<sup>2</sup> ≥ sin(<span style="font-style:italic">y</span>)<sup>2</sup>,    <span style="font-style:italic">B</span>=<span style="font-style:italic">y</span><sup>2</sup>+(1−<span style="font-style:italic">y</span><sup>2</sup>)<span style="font-style:italic">k</span><sup>2</sup> ≥ <span style="font-style:italic">y</span><sup>2</sup></td></tr>
</table><p>
on obtient
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> | ≤  </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">y</span>−sin(<span style="font-style:italic">y</span>))|<span style="font-style:italic">C</span>|</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span> sin(<span style="font-style:italic">y</span>) (<span style="font-style:italic">y</span>+sin(<span style="font-style:italic">y</span>))</td></tr>
</table></td><td class="dcell"> , 
</td></tr>
</table><p>
où :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">C</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">(1−<span style="font-style:italic">k</span><sup>2</sup>)<span style="font-style:italic">y</span> sin(<span style="font-style:italic">y</span>)(<span style="font-style:italic">y</span>+sin(<span style="font-style:italic">y</span>))−<span style="font-style:italic">A</span></td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell">+<span style="font-style:italic">B</span></td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">−<span style="font-style:italic">A</span>(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell">−<span style="font-style:italic">y</span>)−<span style="font-style:italic">B</span>(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell">−sin(<span style="font-style:italic">y</span>))
−<span style="font-style:italic">Ay</span>−<span style="font-style:italic">B</span>sin(<span style="font-style:italic">y</span>) + (1−<span style="font-style:italic">k</span><sup>2</sup>)<span style="font-style:italic">y</span> sin(<span style="font-style:italic">y</span>)(<span style="font-style:italic">y</span>+sin(<span style="font-style:italic">y</span>)) </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">−<span style="font-style:italic">A</span>(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell">−<span style="font-style:italic">y</span>)−<span style="font-style:italic">B</span>(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell">−sin(<span style="font-style:italic">y</span>)) − <span style="font-style:italic">k</span><sup>2</sup>(<span style="font-style:italic">y</span>+sin(<span style="font-style:italic">y</span>))
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" > |<span style="font-style:italic">C</span>|</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span>(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell">−<span style="font-style:italic">y</span>)+<span style="font-style:italic">B</span>(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell">−sin(<span style="font-style:italic">y</span>)) + <span style="font-style:italic">k</span><sup>2</sup>(<span style="font-style:italic">y</span>+sin(<span style="font-style:italic">y</span>)) </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span>−<span style="font-style:italic">y</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell">+<span style="font-style:italic">y</span></td></tr>
</table></td></tr>
</table></td><td class="dcell">
+ <span style="font-style:italic">B</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span>−sin(<span style="font-style:italic">y</span>)<sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell">+sin(<span style="font-style:italic">y</span>)</td></tr>
</table></td></tr>
</table></td><td class="dcell"> + <span style="font-style:italic">k</span><sup>2</sup>(<span style="font-style:italic">y</span>+sin(<span style="font-style:italic">y</span>)) </td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">A</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell"> + <span style="font-style:italic">B</span> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2sin(<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell"> + <span style="font-style:italic">k</span><sup>2</sup>(<span style="font-style:italic">y</span>+sin(<span style="font-style:italic">y</span>))
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
et
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> | ≤ 
</td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">y</span>−sin(<span style="font-style:italic">y</span>))<span style="font-style:italic">k</span><sup>2</sup>(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">y</span></td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2sin(<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell"> + (<span style="font-style:italic">y</span>+sin(<span style="font-style:italic">y</span>))) </td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span> sin(<span style="font-style:italic">y</span>) (<span style="font-style:italic">y</span>+sin(<span style="font-style:italic">y</span>))</td></tr>
</table></td></tr>
</table><p>
On peut majorer <span style="font-style:italic">y</span>−sin(<span style="font-style:italic">y</span>) ≤ <span style="font-style:italic">y</span><sup>3</sup>/6, donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> | ≤ 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">Ay</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2sin(<span style="font-style:italic">y</span>) (sin(<span style="font-style:italic">y</span>)+<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">By</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">sin(<span style="font-style:italic">y</span>)<sup>2</sup>(sin(<span style="font-style:italic">y</span>)+<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">sin(<span style="font-style:italic">y</span>)</td></tr>
</table></td></tr>
</table><p>
On majore enfin <span style="font-style:italic">A</span> et <span style="font-style:italic">B</span> par 1, 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">| </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> |
≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2sin(<span style="font-style:italic">y</span>)<sup>2</sup></td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">sin(<span style="font-style:italic">y</span>)</td></tr>
</table></td></tr>
</table><p>
Le premier morceau se calcule par intégration par parties
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2sin(<span style="font-style:italic">y</span>)<sup>2</sup></td></tr>
</table></td></tr>
</table></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">[−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">tan(<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell">]<sub><span style="font-style:italic">k</span></sub><sup>π/2</sup> 
+ </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">tan(<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell">
</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">tan(<span style="font-style:italic">k</span>)</td></tr>
</table></td><td class="dcell">+ [ln(sin(<span style="font-style:italic">y</span>))]</td><td class="dcell"><table class="display"><tr><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell">&nbsp;</td></tr>
<tr><td class="dcell"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">tan(<span style="font-style:italic">k</span>)</td></tr>
</table></td><td class="dcell">−ln(sin(<span style="font-style:italic">k</span>)) </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >≤</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell">(1−ln(<span style="font-style:italic">k</span>))
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Le deuxième morceau se majore en minorant sin(<span style="font-style:italic">y</span>)≥ (2<span style="font-style:italic">y</span>)/π
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">y</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">sin(<span style="font-style:italic">y</span>)</td></tr>
</table></td><td class="dcell">
≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">y</span>
= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup>π<sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">96</td></tr>
</table></td><td class="dcell"> 
</td></tr>
</table><p>
Finalement
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">K</span>−<span style="font-style:italic">J</span>−ln(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">π</td></tr>
</table></td><td class="dcell">)| 
≤ <span style="font-style:italic">k</span><sup>2</sup> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> ln(<span style="font-style:italic">k</span>) + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π<sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">96</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">30</td></tr>
</table></td><td class="dcell">+ 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td></tr>
</table><p>
où <span style="font-style:italic">J</span> est donné en (<a href="#eq%3AJ">72</a>).</p><p><span style="font-weight:bold">Majoration de </span><span style="font-style:italic">J</span>−<span style="font-style:italic">ln</span>(π/<span style="font-style:italic">k</span>)<br>
On a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">J</span> − ln</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">|
= </td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪</td><td class="dcell">(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">k</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">−1) ln</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">k</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">
ln</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vbar" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> 1−<span style="font-style:italic">k</span><sup>2</sup> +4 </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">π<sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> 
+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">k</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪<br>
⎪</td></tr>
</table><p>
et on va majorer la valeur absolue de chaque terme de la somme.
Pour <span style="font-style:italic">k</span>≤ 1/2, on a
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">k</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">−1=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1−<span style="font-style:italic">k</span><sup>2</sup></td></tr>
</table></td><td class="dcell">+1−<span style="font-style:italic">k</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td><td class="dcell"> ≤ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">3/4+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >3</td></tr>
</table></td><td class="dcell">/2</td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Pour le second terme, on majore le facteur 1/√<span style="text-decoration:overline">1−</span><span style="text-decoration:overline"><span style="font-style:italic">k</span></span><sup><span style="text-decoration:overline">2</span></sup> par 2/√<span style="text-decoration:overline">3</span>,
l’argument du logarithme est inférieur à 1 et supérieur à
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">(1 − </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> +1− </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">k</span><sup>2</sup>(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">π<sup>2</sup></td></tr>
</table></td><td class="dcell">)</td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">)
= 1 − <span style="font-style:italic">k</span><sup>2</sup> ( 1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">π<sup>2</sup></td></tr>
</table></td><td class="dcell">) &gt; 1−<span style="font-style:italic">k</span><sup>2</sup>
</td></tr>
</table><p>
donc le logarithme en valeur absolue est inférieur à
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">2 <span style="font-style:italic">k</span><sup>2</sup> </td></tr>
</table><p>
donc, pour <span style="font-style:italic">k</span>≤ 1/2,
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">|<span style="font-style:italic">J</span>−ln</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">| ≤ 
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span><sup>2</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">3/4+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >3</td></tr>
</table></td><td class="dcell">/2</td></tr>
</table></td></tr>
</table></td><td class="dcell"> ln</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
+ <span style="font-style:italic">k</span><sup>2</sup> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >3</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> 
</td></tr>
</table><p>
Finalement, pour <span style="font-style:italic">k</span>&lt;1/2
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:ln_agm0"></a>
|<span style="font-style:italic">K</span>−ln</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">| 
≤ <span style="font-style:italic">k</span><sup>2</sup> </td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">lnπ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">3/4+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >3</td></tr>
</table></td><td class="dcell">/2</td></tr>
</table></td></tr>
</table></td><td class="dcell">  + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >3</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td><td class="dcell">
+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π<sup>3</sup></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">96</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">9</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">20</td></tr>
</table></td><td class="dcell">
− (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">3/4+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >3</td></tr>
</table></td><td class="dcell">/2</td></tr>
</table></td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell">) ln(<span style="font-style:italic">k</span>) </td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">
    (78)</td></tr>
</table><p>
que l’on peut réécrire
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"> <a id="eq:ln_agm"></a>
|</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">M</span>(1,<span style="font-style:italic">k</span>)</td></tr>
</table></td><td class="dcell">−ln</td><td class="dcell">⎛<br>
⎜<br>
⎜<br>
⎝</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span></td></tr>
</table></td><td class="dcell">⎞<br>
⎟<br>
⎟<br>
⎠</td><td class="dcell">|
≤  <span style="font-style:italic">k</span><sup>2</sup>(3.8−0.8ln(<span style="font-style:italic">k</span>))
    (79)</td></tr>
</table><p>
La formule (<a href="#eq%3Aln_agm">79</a>) 
permet de calculer le logarithme d’un réel positif
avec (presque) <span style="font-style:italic">n</span> bits 
lorsque <span style="font-style:italic">k</span> ≤ 2<sup>−<span style="font-style:italic">n</span>/2</sup> (ce à quoi on peut toujours se ramener
en calculant le logarithme d’une puissance 2<sup><span style="font-style:italic">m</span></sup>-ième de <span style="font-style:italic">x</span> ou
le logarithme de 2<sup><span style="font-style:italic">m</span></sup><span style="font-style:italic">x</span>, en calculant au préalable ln(2)).
Par exemple, prenons <span style="font-style:italic">k</span>=2<sup>−27</sup>, on trouve (en 8 itérations)
<span style="font-style:italic">M</span>(1,2<sup>−</sup>27)=<span style="font-style:italic">M</span><sub>1</sub>=0.0781441403763. 
On a, avec une erreur inférieure à 19 × 2<sup>−54</sup>=1.1× 10<sup>−15</sup>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">M</span>(1,2<sup>−</sup>27)=<span style="font-style:italic">M</span><sub>1</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2ln(2<sup>29</sup>)</td></tr>
</table></td><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">58ln(2)</td></tr>
</table></td><td class="dcell">,
</td></tr>
</table><p> 
On peut donc déduire une valeur approchée de π  si on connait
la valeur approchée de ln(2) et réciproquement.
Si on veut calculer les deux simultanément, comme les relations entre ln
et π seront des équations homogènes, on est obligé
d’introduire une autre relation. Par exemple pour calculer une
valeur approchée de π on calcule la différence
ln(2<sup>29</sup>+1)−ln(2<sup>29</sup>) dont on connait le développement au premier
ordre, et on applique la formule de la moyenne arithmético-géométrique.
Il faut faire attention à la perte de précision lorsqu’on fait
la différence des deux logarithmes qui sont très proches, ainsi
on va perdre une trentaine de bits (de même pour les moyennes).
On peut aussi calculer π directement avec <span style="font-style:italic">M</span>(1,√<span style="text-decoration:overline">(</span>2)) en
utilisant des propriétés des intégrales elliptiques<a id="hevea_default352"></a>
</p><pre class="verbatim">f(n):={
  local x,y,z,p;
  x:=evalf(1/sqrt(2),2^n);
  y:=(1+x)/2/sqrt(x);
  z:=1/sqrt(x);
  p:=evalf(2+sqrt(2),2^n);
  for k from 1 to n do
    p,y,z:=p*(1+y)/(1+z),(1+y)/sqrt(y)/2,(1+y*z)/(1+z)/sqrt(y);
  od;
  retourne p;
}:;
</pre><p>L’intérêt de cet algorithme apparait lorsqu’on veut calculer
le logarithme avec beaucoup de précision, en raison de la
convergence quadratique de la moyenne arithmético-géométrique
(qui est nettement meilleure que la convergence linéaire
pour les développements en série, ou logarithmiquement
meilleure pour l’exponentielle), par contre elle n’est pas
performante si on ne veut qu’une dizaine de chiffres significatifs. 
On peut alors calculer les autres
fonctions transcendantes usuelles, telle l’exponentielle,
à partir du logarithme, ou les fonctions trigonométriques
inverses (en utilisant des complexes) et directes.</p><p>On trouvera dans Brent-Zimmermann quelques considérations permettant
d’améliorer les constantes dans les temps de calcul par rapport
à cette méthode (cela nécessite d’introduire des fonctions 
spéciales θ) et d’autres formules pour calculer π.</p><p>On peut ensuite à partir du logarithme, calculer l’exponentielle
en utilisant la méthode de Newton.</p>
<!--TOC section id="sec305" Bonus : le “making of” de Giac/Xcas-->
<h2 id="sec305" class="section">A  Bonus : le “making of” de Giac/Xcas</h2><!--SEC END -->
<!--TOC subsection id="sec306" Comment le projet Giac/Xcas est né.-->
<h3 id="sec306" class="subsection">A.1  Comment le projet Giac/Xcas est né.</h3><!--SEC END --><p>
Lorsque j’étais au lycée au début des années 80,
nous avions des calculatrices
scientifiques mais les calculatrices graphiques n’existaient pas
encore, et les
particuliers n’avaient pas d’ordinateurs ni de téléphone
portable (cela doit paraitre incroyable à un lycéen actuel,
pourtant cela fait à peine plus de 30 ans!). On pouvait
programmer le calcul d’une fonction pour faire un tableau
de valeurs, par une suite d’opérations ressemblant un peu
à de la programmation en langage assembleur,
avec quelques régistres pour stocker des résultats
intermédiaires et un nombre très
limité de mémoires et de pas de programmes (environ
50 instructions).
J’ai ensuite appris à programmer sur un Apple II en Basic puis en
assembleur, puis en Pascal sur un PC compatible IBM (avec 512K de RAM,
pour plus de 10kg),
mais sans jamais essayer de logiciels de maths, tout cela
en amateur, puisque je faisais mes études de maths, conclues
en 1992 par un doctorat en physique mathématique à Orsay :
je n’ai donc jamais suivi un seul cours d’informatique ni
même de cours où
on utilise l’outil informatique, j’ai sans doute perdu quelques
enseignements utiles, mais je n’ai pas été déformé par
l’enseignement de certains, je pense par exemple
à ceux qui n’ont jamais écrit de
gros programmes et préconisent de ne pas
utiliser <code>break</code> ou <code>return</code> dans une boucle
alors que cela rend le code beaucoup plus lisible que
d’ajouter un booléen artificiel, ou qui
sont incapables de mettre au point un programme.</p><p>Je n’avais donc jamais entendu parler de calcul formel
avant 1993, et c’est Gilles, un de mes étudiants de Deug (on
dirait licence 1ère année aujourd’hui) qui m’a montré
le calcul d’une dérivée symbolique et d’un inverse
de matrice sur une calculatrice HP (qui était le leader du marché
haut de gamme avant que TI ne sorte la TI92 puis la TI89).
L’idée de pouvoir faire ce type de calculs sur calculatrices
m’a séduit, j’étais assez insatisfait des exercices
que l’on donnait en examen aux étudiants où la
différence entre un 8 et un 12 se fait souvent sur une petite
étourderie dans une résolution de système linéaire
et pas du tout sur la compréhension des notions au programme.
J’ai donc décidé de rattraper mon retard dans le domaine,
d’acheter une calculatrice et de la documentation pour la
programmer l’été suivant. C’était indispensable, car le moteur
de calcul formel fourni sur les HP48 était très limité. D’un
certain point de vue, c’était une chance, puisqu’il y avait
tout à faire donc tout à apprendre.
Au cours des années qui ont suivi, j’ai amélioré ces programmes,
et je les ai mis à disposition de la communauté des utilisateurs
de calculatrices HP sous le nom d’Erable (clin d’oeil à Maple).
Erable fait partie de ce que l’on peut qualifier de système de
calcul formel “jouets”, j’entends par là capable de résoudre
les exercices calculatoires donnés du lycée à la licence de maths.
En même temps, j’enseignais
l’algorithmique en licence (avec toute
une équipe très sympathique : Renée, Roland,
Gérard, Frédéric). On programmait en Pascal au début, puis
rapidement on a basculé les enseignements en C/C++.
Renée s’intéressait
aussi aux calculatrices et pensait qu’il faut contacter HP (il
y a un centre HP en banlieue de Grenoble),
ce qui ne fut pas évident mais finit par déboucher sur
la création d’un module optionnel calculatrices en Deug
(avec des calculatrices prêtées par HP),
puis en 1997 des contacts avec la nouvelle équipe calculatrices
de HP en Australie. En 1998/99, j’ai effectué une délégation
pour mettre au point la HP49 avec l’équipe australienne,
afin d’y intégrer Erable.
Un an plus tard nous sortons
la HP40, version lycée simplifiée et moins chère de la HP49,
projet porté par Jean Tavenas chez HP Grenoble.
Mais HP décide alors que les calculatrices graphiques
ne sont pas assez rentables, les efforts de Jean pour
faire la publicité de la HP40 sont stoppés juste au
moment où ils commençaient à porter leurs fruits
(avec une calculatrice formelle au prix de la TI83,
la HP40 avait pourtant toutes ses chances, c’est
d’ailleurs encore vrai en 2014,
la HP40GS est la calculatrice formelle
la moins chère du marché, on la trouve cette rentrée 2014
à un prix équivalent aux graphiques d’entrée de gamme de TI et Casio).</p><p>C’est cette expérience avec HP
qui m’a fait prendre conscience qu’il était possible d’écrire un logiciel
de calcul formel compétitif. Ma décision
d’abandonner le développement sur HP49/40 fut alors
la conséquence d’une part de la mise en retrait de HP du marché,
d’autre part de la modification de l’épreuve d’option de l’agrégation
de maths, qui devenait un oral de modélisation avec utilisation
de logiciels. À l’époque seuls les logiciels propriétaires
“leaders du marché” étaient autorisés (Maple et Mathematica
pour ne pas les nommer), il n’y avait pas
un seul logiciel libre de calcul formel et
cela m’avait beaucoup choqué. Au début
j’argumentais pour l’ajout de Mupad qui était sinon libre au moins
gratuit (Mupad n’existe plus isolément aujourd’hui).
Quelques années plus tard, Maxima et d’autres logiciels libres
ont été rajoutés à la liste des logiciels, mais sans connaitre beaucoup
de succès parmi les candidats. Au lancement du projet Giac/Xcas en 2000,
j’avais comme objectif que Xcas soit un jour intégré dans la liste des
logiciels de l’oral de modélisation (ce fut le cas en 2005, mais
les premiers candidats à l’utiliser ne l’ont fait que vers 2007 ou
2008...).</p>
<!--TOC subsection id="sec307" L’enfance d’Xcas: 2000-2006-->
<h3 id="sec307" class="subsection">A.2  L’enfance d’Xcas: 2000-2006</h3><!--SEC END --><p>
L’année 2000 marque sans doute un tournant dans ma carrière,
je viens d’achever l’année de délégation pour mettre au point
la HP49, et le travail se poursuit pour sortir la HP40 à la
rentrée scolaire. Le tandem se met en place avec Renée qui
rédige le manuel de calcul formel de la HP40G.
C’est la dernière année où je travaille activement en recherche sur
des thèmes de physique mathématique.
Au moment où nous avions décider de basculer l’enseignement
d’algorithmique du Pascal au C (fin des années 90),
j’avais regardé les possibilités
de bibliothèque pour faire un peu de calcul en précision
arbitraire à défaut de faire du calcul formel
(on a essayé LiDiA, PARI, mais sans vraiment être satisfait).
En mai 2000, alors que le projet HP40 s’achève,
je me lance dans un projet d’extension de la librairie C++
de calcul symbolique GiNaC,
il s’agissait dans un premier temps d’améliorer les fonctions
polynômiales avec des représentations non symboliques,
pour avoir de la simplification et de la factorisation. Après
plusieurs mois, je me rends compte que la philosophie de GiNaC
ne me convient pas, je bascule vers un projet complètement
indépendant, que je nomme Giac, en référence à GiNaC
<sup><a id="text34" href="#note34">34</a></sup>. Au début il s’agissait juste
d’avoir une librairie C++ capable de faire des opérations
sur les polynômes de manière efficace. Pendant 2 ans,
j’implémente les algorithmes de base d’un CAS pour la
licence de maths (pgcd, factorisation, intégration, limites...),
puis je crée une petite interface pour pouvoir tester le tout
sans avoir à écrire un programme C++ à chaque fois.
La première version publique de Xcas est disponible en 2002,
elle est très influencée par les interfaces de calculatrices.
En 2003/2004, premier contact avec le milieu de la recherche
en calcul formel, dont certains membres veulent créer une
alternative aux grands logiciels propriétaires du domaine, soit
par conviction, soit tout simplement pour des raisons de budget.
Une conférence a lieu à Lyon puis une école d’été,
où sont présents
de mombreux développeurs de logiciels libres
(Axiom, Fricas, Maxima, texmacs, pari, gap,
MPFR... mais aussi des gens de Mupad même s’il n’est pas libre). Cette
conférence n’a de mon point de vue abouti à rien de concret,
chacun tirant pour sa chapelle. La présentation des objectifs du projet 
Giac/Xcas n’a pas du tout attiré les autres participants,
d’une part à cause de mes déficiences en anglais,
d’autre part parce que l’objectif prioritaire de Xcas (pour l’enseignement)
est souvent assez éloigné des objectifs d’un logiciel
pour la recherche en calcul formel, sans parler de l’orientation
calculatrice de l’interface de Xcas à l’époque.
C’est plutôt vers le projet Sage que la
communauté recherche de calcul formel “libre” se tournera un peu
plus tard. Les deux projets Giac/Xcas et Sage sont
aujourd’hui concurrents (même si on peut appeler Giac
depuis Sage), voir plus bas section <a href="#sec%3Aconcurrents">A.5</a>.</p><p>Parallèlement, Renée a lancé à l’IREM de Grenoble
un groupe de travail sur l’utilisation des calculatrices
formelles au lycée, à l’automne 2000 :
HP mettait à disposition
des profs de lycée participants des valises de HP40G
prêtées aux élèves. Peu après, HP se désintéresse
des calculatrices, l’idée de tester le Xcas (d’alors) en classe
est venue tout naturellement. Ce sont Michèle Gandit et
Christianne Serret qui se lancent dans l’aventure, c’est bien
le mot, parce qu’il fallait y croire avec les très nombreux
bugs et manques de l’interface de l’époque. C’est
l’observation des problèmes rencontrés par les élèves
qui m’a fait prendre conscience qu’une révision complète
de l’interface s’imposait, et j’y ai consacré une bonne année
de travail, aboutissant à une interface proche de l’actuelle.
C’est cette nouvelle interface qui a permis le
décollage de Xcas, que l’on peut juger
au nombre de téléchargements, ainsi que par
les interactions avec des utilisateurs inconnus.</p>
<!--TOC subsection id="sec308" La montée en puissance: 2007-2013-->
<h3 id="sec308" class="subsection">A.3  La montée en puissance: 2007-2013</h3><!--SEC END --><p>
En 2007, Xcas participe aux Trophées du Libre, (concours
de logiciels libres qui n’existe plus aujourd’hui), et obtient
la 3ième place dans la catégorie logiciels scientifiques.
J’espérais que cela marquerait une étape
décisive dans la montée en puissance,
par exemple en faisant entrer Xcas dans
des distributions Linux, mais cela n’a pas servi (et encore
aujourd’hui Giac n’a pas réussi à entrer dans les distributions
Linux majeures, même si l’entrée dans Fedora semble
imminente). En fait la montée en puissance s’est faite
progressivement, avec environ une dizaine de % d’utilisateurs
en plus chaque année, grâce aux améliorations
implémentées par l’interaction avec les profs
de maths sur le forum de Xcas ou par email. C’est aussi
vers 2008 que l’interface est devenue suffisamment
intuitive pour que les étudiants de la préparation
à l’agrégation de Grenoble option calcul formel
basculent de Maple vers Xcas
(avec une période de transition où certains travaillaient
avec Maple en même temps que d’autres avec Xcas). Suivis
peu de temps après par Jussieu (F. Han). Puis progressivement
dans certains enseignements de licence à Grenoble et
sans doute ailleurs.</p><p>Le projet Giac va aussi prendre en 2011 une direction un peu
imprévue, c’est la valorisation. Le noyau de Giac va
en effet pour la première fois être intégré
à une application commerciale, PocketCAS. Ce qui nécessitera
de contacter les services de valorisation de l’université, début d’un épisode
difficile que je ne peux pas commenter plus pour des
raisons de confidentialité.</p>
<!--TOC subsection id="sec309" Le présent et le futur proche-->
<h3 id="sec309" class="subsection">A.4  Le présent et le futur proche</h3><!--SEC END --><p>
Le nombre de téléchargements de Xcas dépasse maintenant
les 50 000 par an avec des pointes mensuelles en septembre et octobre
à plus de 12 000 (principalement sous Windows). Xcas est
présent dans la grande majorité des livres de maths de Terminale
S, on en parle aussi en ES (une copie d’écran de Xcas se trouve
d’ailleurs dans le sujet du bac ES 2014).
La couverture en France est donc plutôt bonne, c’est
vers l’étranger qu’il faut maintenant gagner des parts de marché
(ce qui nécessitera une amélioration de la documentation
en anglais).</p><p>Au concours de l’agrégation externe,
Xcas est choisi par une fraction
significative des candidats en modélisation option C
(un tiers environ en 2012).
Parallèlement à la montée en
puissance de Xcas, l’arrivée de Sage, la fin de Maple (et
Mathematica) en classes préparatoires
et le succès de Scilab en calcul numérique et probabilités, ont
fait que la situation s’est renversée, en 2015,
seuls les logiciels libres sont autorisés
à cette épreuve de modélisation, on peut
dire que c’est un beau succès pour les logiciels libres,
auquel Xcas a contribué.
En 2013/14, j’ai retravaillé pour les candidats
aux options A et surtout B : refonte de
la page agrégation externe, ajout de fonctionnalités,
testées dans un cours de méthodes numériques
niveau licence 3ième année. Il y a en effet une part de marché
à conquérir parmi tous les candidats qui utilisaient auparavant
Maple, en particulier pour tous les certifiés qui
ne sont pas inscrits à une préparation, Xcas est un choix
qui semble rationnel : ceux qui ont appris Maple peuvent
utiliser leurs connaissances, Xcas est aussi proposé
à l’agrégation interne et les professeurs peuvent utiliser Xcas avec
leurs élèves ce qui est certainement un excellent entrainement
pour la mise au point d’un petit programme le jour du concours.
Xcas est aussi présent pour les oraux du Capes, mais je n’ai
pas de retour sur son utilisation réelle par les candidats,
même si plusieurs préparations semblent utiliser Xcas.</p><p>La collaboration entamée avec Geogebra en 2013
se concrétise avec la version 4.4 sortie en décembre 2013
qui interface Giac (module natif java et version
web) avec l’écran CAS de Geogebra.
Les interfaces vers d’autres langages s’améliorent,
module Python, interface avec Sage (F. Han),
utilisation depuis javascript. Plusieurs projets
libres utilisent Giac comme moteur de calcul : Qcas (interface
alternative, qui pourrait remplacer Xcas un jour),
Smartcas (calculatrice CAS dans votre navigateur),
Xcas Pad (sur tablettes)...</p><p>Coté valorisation, Giac fait aujourd’hui l’objet de
plusieurs contrats de
commercialisation (en dual-licensing), dont un avec HP
pour le CAS des calculatrices HP-Prime.</p>
<!--TOC subsection id="sec310" Les concurrents open-source.-->
<h3 id="sec310" class="subsection">A.5  Les concurrents open-source.</h3><!--SEC END --><p> <a id="sec:concurrents"></a>
Les principaux concurrents open-source de Giac/Xcas sont Maxima et
Sage. Il existe d’autres logiciels libres de calcul formel généralistes, mais ils
ne semblent pas avoir beaucoup d’utilisateurs.</p><p>L’utilisation de Giac et de Maxima est assez proche, ce sont
tous deux des logiciels qui fonctionnent localement (sans
avoir besoin de connexion Internet),
installables facilement sous Windows, Linux
et Mac OS, avec une prise en main rapide
aidée par un typage faible et par l’interface
(Xcas ou Wxmaxima). Maxima est plus connu dans le monde anglo-saxon
car il est plus ancien, alors que Xcas est maintenant bien
implanté en France (et sans doute dans d’autres pays francophones)
grace à la documentation en français. Xcas évolue plus vite.
Giac dispose d’algorithmes beaucoup plus
performants pour de (gros) calculs polynomiaux pour la recherche
(meilleur moteur open-source de calcul de bases de Groebner 
à l’heure actuelle par exemple)
et est bien adapté à un usage
en enseignement dès le lycée (en particulier 
par son intégration comme CAS de geogebra). Un challenge pour Xcas
pour les années à venir va être d’augmenter la part
de marché dans le monde anglo-saxon, il nous faudrait
un amateur motivé parlant nativement anglais prêt à consacrer
du temps pour améliorer la documentation en anglais.</p><p>Sage est très différent de Xcas et Maxima. On peut certes l’utiliser
comme un logiciel local en ligne de commande, mais
pour une interface plus conviviale il faut utiliser une 
client-serveur, l’interface étant alors dans le navigateur. Les
ressources nécessaires sont significativement plus importantes
si on l’installe localement, et l’accès Internet est indispensable
sinon<sup><a id="text35" href="#note35">35</a></sup>. Le langage de 
Sage est beaucoup plus typé que celui de Giac, il est
philosophiquement
plus proche de Magma que de Maple ou Mathematica,
donc plus difficile à apprendre pour qui n’est pas algébriste.
Sage se fonde sur un énorme corpus de logiciels et
bibliothèques (dont Maxima, appelé pour les calculs symboliques,
Giac peut d’ailleurs en être un composant
optionnel), qu’il fait communiquer entre eux, un peu à la
manière d’une distribution linux qui fait cohabiter des composants
logiciels, mais de manière plus intime, Python servant
de colle entre les briques logicielles écrits en différents
langages (c’est aussi là une différence importante avec Giac
qui utilise C/C++ pour dialoguer avec d’autres bibliothèques
ou logiciels, tout en restant utilisable comme module
Python). C’est la force et la
faiblesse de Sage, car on bénéficie de certains composants très
performants, mais le code propre de Sage est très dépendant
de l’évolution de ces composants :
</p><ul class="itemize"><li class="li-itemize">
son composant d’infrastructure le plus fondamental, 
la version de Python utilisée est
figée depuis plusieurs années en 2.7 (alors que le module
giacpy pour accéder à giac depuis Python fonctionne
en versions 2.7 et 3.x),
</li><li class="li-itemize">toutes les opérations de calcul formel non
spécialisé font très souvent appel à Maxima,
si une intégrale rend un résultat incorrect, il faut en informer
les développeurs de Maxima
</li><li class="li-itemize">les opérations polynomiales rapides font appel à des
bibliothèques C/C++ et dépendent donc des performances
de ces bibliothèques : par exemple le calcul de base
de Groebner sur les entiers utilise Singular, dont la version
actuelle est très inefficace sur ℤ
</li></ul><p> 
De ce fait, le portage est difficile : sans même parler des OS de tablettes
et smartphones, il n’y a pas de version native Windows,
on fait communiquer le navigateur sous Windows avec un serveur
sage dans une machine virtuelle sous linux, ce qui nécessite
significativement plus de ressources<sup><a id="text36" href="#note36">36</a></sup> que pour Giac, 
qui peut même tourner sur des calculatrices.</p><p>Les deux stratégies de développement de Giac et Sage
sont assez opposées<sup><a id="text37" href="#note37">37</a></sup> : Giac se contente de peu de ressources et cible le 
public enseignement dès le lycée (calculatrices, geogebra) alors
que W. Stein, le fondateur de Sage se tourne vers le cloud computing :
“Measured by the mission statement, Sage has overall failed. The core
goal is to provide similar functionality to Magma (and [Maple,
Mathematica Matlab]) across the board, and the Sage development model
and community has failed to do this across the board, since after 9
years, based on our current progress, we will never get there. There
are numerous core areas of research mathematics that I’m personally
familiar with (in arithmetic geometry), where Sage has barely moved in
years and Sage does only a few percent of what Magma does.”
“The longterm plan is to start a separate for-profit company if we
build a sufficient customer base. If this company is successful, it
would also support fulltime development of Sage (e.g., via teaching
buyouts for faculty, support of students, etc.), similar to how Magma
(and Mathematica, etc.) development is funded.” (<span style="font-family:monospace"><span style="font-size:xx-small">http://sagemath.blogspot.co.uk/2014/08/what-is-sagemathcloud-lets-clear-some.html</span></span>).</p>
<!--TOC section id="sec311" Quelques opinions.-->
<h2 id="sec311" class="section">B  Quelques opinions.</h2><!--SEC END -->
<!--TOC subsection id="sec312" Languages-->
<h3 id="sec312" class="subsection">B.1  Languages</h3><!--SEC END --><p>
La question du choix de langage en informatique est récurrente.
J’ai choisi C++ pour Giac/Xcas, en fait c’est plutôt du C– (au
sens où Giac définit très peu de classes lui-même, mais
utilise les facilités de la bibliothèque C++).</p><p>Lorsque j’ai développé pour la HP48 dans les années 90, le langage
était du RPL, un dérivé du Forth, sorte de Lisp restreint écrit
en polonaise inversé, spécialement conçu pour créer
des programmes compacts (le CAS de la HP49 occupe environ
200K, l’ensemble du système environ 1M).
C’était un langage où on pouvait
tout manipuler, y compris la pile des retours de fonction.
Mais c’était un langage difficile à maitriser et où le
moindre changement nécessitait de reconcevoir complètement
le programme. C’était aussi un langage interprété donc lent,
et comme pour tout langage interprété, optimiser nécessite
une longue pratique et rend le programme optimisé encore plus
incompréhensible que dans d’autres langages.
Et bien sur c’est un langage propriétaire, complètement
inutilisable en-dehors des HP48/49/50.</p><p>C’est donc avec ces défauts en tête que j’ai choisi le
langage de Giac : portabilité, facilités pour optimiser,
mettre au point et modifier, vitesse. Ce qui excluait
tout langage interprété. Le choix
de C/C++ c’était aussi la possibilité d’utiliser des opérateurs
sur le type générique de giac, pour pouvoir écrire
<code>b*b-4*a*c</code> et pas <code>sub(mult(b,b),mult(4,mult(a,c)))</code>
comme en Java.</p><p>Je ne regrette pas un instant ce choix. Si on regarde les logiciels
de calcul formel, on a essentiellement 3 langages :
</p><ul class="itemize"><li class="li-itemize">
Lisp utilisé par Maxima. Cela affecte
le nombre de développeurs potentiels du système,
et nécessite d’avoir un interpréteur Lisp sur
certaines plateformes (avec des problèmes de lenteur)
</li><li class="li-itemize">C/C++ utilisé par Xcas, Maple, Mathematica
mais aussi par de nombreux logiciels et librairies
mathématiques : GMP, MPFR, NTL,
Pari-GP, Singular...
</li><li class="li-itemize">Python utilisé par Sage et Sympy. Sage doit toutefois
être un peu mis à part, la plupart de ses fonctionnalités
sont en fait héritées de bibliothèques C ou logiciels
interfacés et les développeurs ont recours à une
sorte de traducteur C (cython) pour optimiser certaines portions de code
Python natif. Sympy se classe pour le moment encore dans les
systèmes de calcul formel jouets,
et est structurellement très lent comparé à giacpy.
</li></ul><p>
Je pense que le potentiel de portabilité
et réutilisation de code est maximal en C/C++,
on peut s’intégrer dans du Python (module giacpy
et interface giac/sage de F. Han, l’inverse est beaucoup plus difficile et
nécessite plus de ressources, essayez d’appeler
du code sage depuis un programme C/C++!),
du java (module natif javagiac utilisé par geogebra),
du Javascript (le langage de base du web! Giac se compile en
Javascript),
du code natif pour le navigateur google-chrome,
en embarqué (sur les HP Prime, mais aussi ailleurs,
la plus petite version de giac existante à ce jour
occupe moins de 5M et tourne sur calculatrices TI nspire) ou
enfoui dans un autre programme (C/C++ ou avec
un langage interfaçable, par exemple de la liste fournie par SWIG).
La durée de vie de code C/C++ est aussi excellente, le
langage C/C++ est au coeur de la très grande majorité
des applications utilisées aujourd’hui. L’avenir de Javascript
ou de Python parait aujourd’hui assuré, mais c’était
la situation de Java il y a une dizaine d’années, alors
qu’aujourd’hui on ne peut plus en dire autant.</p><p>Bien sur, écrire un programme en C/C++ nécessite
un peu plus d’apprentissage qu’écrire un programme
en Python ou en tout autre langage interprété,
mais c’est je pense aussi plus formateur, on
comprend mieux les avantages et inconvénients
d’utiliser un conteneur, un type de donnée précis
ou un algorithme avec un langage plus proche de la machine
réelle qu’avec une machine abstraite filtrée par les
possibilités mises à disposition par l’interpréteur
(avec souvent un biais lorsqu’on optimise, on favorise
l’instruction implémentée le plus efficacement par
l’interpréteur au détriment de l’algorithme le plus
efficace, ce qui conduit par exemple à choisir un style fonctionnel
plus difficile à concevoir, relire et modifier et moins
efficace dans un langage compilé).</p>
<!--TOC subsection id="sec313" Le libre, la recherche et l’éducation-->
<h3 id="sec313" class="subsection">B.2  Le libre, la recherche et l’éducation</h3><!--SEC END --><p>
Le logiciel libre a fini par se faire une place au soleil,
mais cela n’a pas été facile. Au sein de l’éducation
nationale, c’est probablement les restrictions budgétaires qui ont été
le meilleur allié du libre, et Open Office ou LIbre Office,
Geogebra, Xcas sont maintenant bien présents dans
les lycées et manuels, mais l’OS reste Windows et
l’évolution dans le monde des calculatrices va dans le mauvais sens.</p><p>L’idée de mettre en place un mode examen en 2018 va à l’encontre
de la possibilité pour l’acheteur de tirer parti de sa calculatrice
comme il l’entend, il suffit de voir la guerre entre les
développeurs de TI et la communauté Ndless, digne
de la lutte menée par Apple contre les“jailbreaks”
qui permettent d’utiliser l’Ipad avec des logiciels en-dehors
du marché controlé par Apple ou avec d’autres opérateurs
téléphoniques. L’institution devrait bien réfléchir avant de
se lancer dans l’aventure. Certes, le mode examen évitera le
recours parfois abusif aux anti-sèches, mais cela va décourager
le développement de programmes par les élèves sur leurs
calculatrices (car ces programmes seront effacés le jour de
l’examen) et renforcer les inégalités, en particulier pour
l’accès au calcul formel (qui est possible sur des modèles
d’entrée de gamme aujourd’hui).</p><p>Je pense que si on veut vraiment des calculatrices avec mode examen,
alors c’est à l’institution de les acheter, puis de les 
prêter aux élèves. L’éducation nationale devrait aussi
avoir plus de contrôle sur les logiciels
embarqués, qui ne devraient pas tant
dépendre des constructeurs
et donc des programmes de l’enseignement US. Cela permettrait
aussi de mettre fin à des rentes pour les constructeurs
en situation de position dominante, que l’on songe par
exemple au bénéfice sur les modèles de calculatrices les plus
conseillées et vendues, calculatrices qui ne se sont
guère améliorées depuis 20 ans.</p><p>Si ce sont les élèves qui sont propriétaires du matériel, alors
ils doivent pouvoir y installer les logiciels de leur choix.
En fait, avec la baisse du prix des tablettes et autres
netbooks où chacun peut installer le logiciel de son
choix, est-il raisonnable de continuer à utiliser
des calculatrices graphiques (à plus de disons 20 euros) ? Il vaudrait
peut-être mieux prévoir des dispositifs de brouillage
des communications de type wifi, ou/et des sujets avec
une partie sans outil informatique pour controler les questions
de cours.</p><p>Coté recherche, l’esprit “libre” progresse mais il y a encore
beaucoup de chemin à accomplir. L’édition scientifique
est encore essentiellement basée sur le paradigme du 20ième
siècle : revue papier vendue à prix d’or aux bibliothèques,
droits d’auteurs cédés par les auteurs des articles sans aucune
contrepartie, accès en ligne payant. Les éditeurs privés
s’approprient ainsi la connaissance financée par les fonds publics,
un comble!
Heureusement les archives en ligne permettent la plupart
du temps de contourner ces accès payants. Il reste
que les crédits utilisés pour payer les abonnements seraient
bien mieux utilisés à financer les journaux en ligne et en
les rendant publics.</p><p>Concernant le dèveloppement logiciel,
il y a beaucoup de logiciels scientifiques libres de qualité aujourd’hui, mais
il y a des freins :
</p><ul class="itemize"><li class="li-itemize">
la publication de code source de logiciel scientifique n’est pas
considéré comme équivalent à la publication d’un article :
certains qualifient d’ailleurs cette activité par “pisser du
code”. 
Conséquence, l’auteur d’un morceau de code n’a pas intérêt
à en diffuser le source car cela n’accélérera en rien
sa carrière, il est souvent plus rentable
de diffuser un article qui parle du code source,
sans rentrer trop dans les
détails qui rendent un algorithme efficace. Éventuellement
on diffuse un exécutable,
comme cela toute personne utilisant le code pour un autre
travail de recherche devra collaborer
ou remercier d’une autre manière. Dans certains
domaines, on me dit que la situation en arrive au point
où il faut communiquer
les données à l’auteur du code qui renvoie le résultat.
On est vraiment aux antipodes de la démarche scientifique,
encore plus en maths où on attend de pouvoir consulter
tous les détails d’une preuve.
</li><li class="li-itemize">On peut sans doute dire la même chose concernant
le développement de logiciels
éducatifs. Il n’y a pas de reconnaissance de l’institution et
les encouragements sont rares (en tout cas c’est le ressenti
de notre visite de présentation de Xcas
au ministère de l’Education Nationale
il y a quelques années, peut-être que ce serait différent
aujourd’hui).
</li><li class="li-itemize">Un autre frein au libre, c’est le droit qui est différent pour les logiciels
et pour les écrits scientifiques, la personne qui dispose des droits
patrimomiaux sur un logiciel c’est l’employeur de l’auteur et
pas l’auteur lui-même, or les responsables de projets,
universités et autres organismes
publics de recherche sont beaucoup plus réticentes au logiciel
libre que les auteurs eux-mêmes ... surtout s’ils ont des organismes
de valorisation. Ce n’est pas seulement une question financière
mais tout simplement de qui controle quoi, une fois un logiciel
libéré, le contrôle est dans les mains des personnes qui codent,
et échappe aux services de valorisation ou aux scientifiques
qui dirigent le projet<sup><a id="text38" href="#note38">38</a></sup>.
</li><li class="li-itemize">Plus généralement, le financement de la recherche
aujourd’hui n’est pas favorable aux projets de long terme.
Le manque de confiance des décideurs envers les chercheurs
est une cause majeure de perte d’efficacité des chercheurs,
en raison de l’inflation du temps passé à chercher des crédits,
à évaluer des projets, à évaluer les collègues
(pour les nominations et promotions aujourd’hui, bientot peut-être pour les services
d’enseignement!). Le système actuel favorise d’ailleurs la politique
d’édition dénoncée plus haut, avec une floraison d’indices utilisant
les publications dans les journaux prestigieux. Il serait bien plus
rentable de faire confiance aux chercheurs avec des financements
pérennes et la fin des contrôles systématiques, bien sur il y aura
toujours quelques abus, mais globalement on gagnerait en efficacité.
</li></ul>
<!--TOC subsection id="sec314" Les maths et les outils de calcul.-->
<h3 id="sec314" class="subsection">B.3  Les maths et les outils de calcul.</h3><!--SEC END --><p>
En un demi-siècle les outils de calcul informatiques ont
gagné en puissance de manière radicale. Aujourd’hui,
pour une centaine d’euros, on a la puissance de calcul
qui était réservée, il y a une vingtaine d’années, 
aux centres de calculs spécialisés. </p><p>Cela a des conséquences
visibles dans tous les domaines de la vie quotidienne, il
est impossible de les ignorer en maths sauf peut-être
dans certains domaines de recherche. En tout
cas pas dans le domaine de l’enseignement. Bien entendu,
les maths c’est pour partie du raisonnement, mais pour
l’écrasante majorité des gens, y compris scientifiques,
c’est surtout un outil et pas une fin en soi (sur une classe
d’age, deux à trois pour mille vont
être des professionnels des maths, en comptant tous les
enseignants de maths). Je pense que si les matheux veulent survivre
en tant que discipline, il faut qu’ils adaptent leur enseignement
pour un usage <em>intelligent</em> des outils de calcul, sinon ils finiront
comme les langues anciennes. On ne devrait par exemple 
plus étudier les courbes sans utiliser un logiciel ou une
calculatrice pour en avoir une représentation graphique : 
avant on faisait l’étude complète pour aboutir au tracé 
parce qu’on n’avait pas le choix de faire autrement, aujourd’hui il faut
faire le tracé et l’étude simultanément, létude analytique
servant à expliquer les particularités du tracé.</p><p>Utiliser des outils de calcul n’est pas contradictoire avec faire
du calcul, en particulier faire un peu de calcul mental pour avoir
une idée de la plausibilité d’un résultat obtenu par
un logiciel (ordre de grandeur). C’est
de l’hygiène intellectuelle, analogue à faire de l’exercice
physique. Faire quelques calculs à la main est aussi une
façon de s’approprier de nouveaux concepts. Mais une fois
cette étape franchie, je ne vois aucune raison de devoir
continuer à apprendre à faire des calculs fastidieux
ou techniques, alors que l’ordinateur fait cela beaucoup mieux
que nous. Il est beaucoup plus judicieux de savoir diriger
un logiciel pour cela, et donc de passer un peu de temps
(autrefois consacré à faire des calculs techniques)
à connaitre leurs possibilités
et limites (à la fois en termes de fonctionnalités et
de temps de calcul).</p><p>Prenons l’exemple de la résolution des équations du second
degré. Au moment où on enseigne cette technique, je pense
qu’il est important de faire faire quelques calculs de racines 
de trinômes (sans
calculatrices), et d’expliquer comment ce genre de calculs peut
se faire avec un logiciel de calcul formel (ce qui d’ailleurs
permettra aux élèves de vérifier les résultats
de leurs calculs faits à la main).
Un an ou deux ans après, je ne vois pas l’intérêt de forcer
des élèves à continuer à faire ces calculs à la main
s’ils savent les faire avec un logiciel ou une calculatrice. En les
bloquant sur un point technique, on ne fera
que les braquer et on les empêchera de comprendre à quoi
cela peut servir (par exemple ici faire un tableau de variations).
Il faut arrêter de croire que tous les
scientifiques fonctionnent comme les matheux qui veulent
comprendre de A à Z, c’est d’ailleurs souvent devenu
impossible en recherche en maths, les autres disciplines
ont leurs propres règles (je pense par exemple qu’un
bon physicien n’a pas forcément besoin de savoir
démontrer rigoureusement quelque chose, l’essentiel
est qu’il ait une bonne intuition des bonnes approximations
à faire pour calculer correctement, calcul qu’il n’hésitera
par à déléguer à la machine). Interdire les outils
de calculs (ou les réserver à ceux qui savent déjà
les faire à la main), c’est pour moi une pratique élitiste,
on donne l’accès à certaines connaissances non pas
à ceux qui sont capables de les comprendre, mais à
ceux qui sont suffisamment virtuoses du calcul à la main.</p><p>Certains enseignants mettent sur le dos de l’usage des outils de
calcul tous les maux du système actuel alors qu’à mon avis cela n’a rien
à voir. Je pense que le problème principal des maths au lycée, 
c’est que les maths de S sont à la fois dures pour des non matheux
et inintéressantes pour des matheux (au sens large), conséquence
de l’universalité des débouchés accessibles en sortant de S.
Dans le supérieur (hors prépas), le problème principal c’est
la multiplication des parcours, la semestrialisation 
et l’atomisation des enseignements
en unités beaucoup trop petites, qui augmentent les effets
frontières, sont contradictoires avec les échelles de temps
pour assimiler des notions, créent des casses-têtes pour faire
les emplois du temps, multiplient les sessions d’examens. 
A cela s’ajoute la perte d’attractivité des métiers de
l’enseignement et de la recherche en maths, que ce soit
dans le secondaire (conditions de travail, reconnaissance
par la société) ou dans le supérieur (dégradation
des conditions d’exercice de la recherche, mais aussi
de l’enseignement). Rien d’étonnant à ce que les jurys
du CAPES et de l’agrégation n’arrivent pas à
pourvoir tous les postes.</p><p>Les programmes des classes préparatoires aux grandes écoles
ont supprimé récemment l’apprentissage d’un logiciel de calcul
formel, peut-être une victoire des enseignants qui sont contre
l’usage des outils de calcul formel. Ce sont les mêmes qui conseillent
à leurs élèves l’achat de calculatrices graphiques non formelles
au lycée (ce qui arrange bien les constructeurs qui peuvent ainsi
faire payer au prix fort le modèle formel). 
Je pense que ce combat d’arrière-garde est voué à l’échec :
les calculatrices graphiques de milieu de gamme commencent
à avoir des logiciels de calcul formel jouets (comme
par exemple Eigenmath sur Casio Graph 35+USB et 75/85/95),
et à moyen terme (10 ans?), ces calculatrices 
auront suffisamment de capacité mémoire pour
permettre le portage de logiciels de calcul formel complets comme Giac.</p>
<!--TOC subsection id="sec315" Calculatrices, tablettes ou PC ?-->
<h3 id="sec315" class="subsection">B.4  Calculatrices, tablettes ou PC ?</h3><!--SEC END --><p>
Si on est convaincu de l’intérêt d’utiliser un outil de calcul,
se pose alors la question du choix de l’outil. Voici quelques
éléments de réflexion.
</p><ul class="itemize"><li class="li-itemize">
Les calculatrices ont pour avantages : la disponibilité
immédiate (on appuie sur ON, en 1 seconde on peut
travailler), l’encombrement faible, la robustesse,
le clavier scientifique
dédié (avec sur les calculatrices graphiques haut
de gamme une interface facilitant la saisie d’intégrales,
limites, etc.), la consommation faible (des piles qui durent
plusieurs mois ou des batteries dont la charge tient plusieurs
semaines), l’absence de connection Internet (pour les examens).<br>
Les inconvénients : prix élevé, taille d’écran trop petite
pour faire des gros calculs (et puissance parfois insuffisante), 
plus difficile de charger/sauvegarder
des données dans des fichiers, pas de souris, l’utilisation du clavier peut
être pénible pour programmer ou saisir une ligne de commandes
un peu longue (le clavier des TI92 et des TI Nspire CX est
un bon compromis, l’écran tactile des HP Prime permet
de se passer de souris, il faudrait un hybride des deux!) <br>
Bien adapté à l’enseignement (y compris dans le supérieur
même si elles y sont souvent dénigrées par les enseignants).
</li><li class="li-itemize">Les avantages des ordinateurs (portables) : clavier, écran,
puissance de calcul, convient pour d’autres usages que le calcul.<br>
Les inconvénients : poids/encombrement/fragilité, durée de charge
des batteries (souvent 3-4h), connectivité Internet pour les
examens.<br>
Idéal en usage stationnaire.
</li><li class="li-itemize">Les avantages des tablettes : disponibilité immédiate,
écran large, convient pour d’autres usages que le calcul.<br>
Les inconvénients : saisie de données fastidieuse, encombrement
et fragilité, usage sans recharge limité à une (petite) 
journée, connectivité Internet en examen.<br>
Peut être intéressant en mobilité
si on a beaucoup de documents à
consulter en ligne avec de temps en temps un petit calcul à
faire. Les tablettes avec possibilité de branchement
de clavier ont un potentiel intéressant pour un usage
en mobilité avec un peu plus de données à saisir.
</li></ul><p>

</div>
<div id="controldiv" style="max-height: 400px; overflow:auto">
<span id="controlindex"></span>
<button title="Efface la console" onclick="document.getElementById('output').innerHTML='';">Efface</button>
<button title="Augmente la taille de la console" onclick="var field=document.getElementById('output'); var s=field.style.maxHeight; s=s.substr(0,s.length-2);s=eval(s)+20 ;s=s+'px';field.style.maxHeight =s;">+</button>
<button title="Diminue la taille de la console" onclick="var field=document.getElementById('output'); var s=field.style.maxHeight; s=s.substr(0,s.length-2);s=eval(s)-20 ; if(s>100){s=s+'px';field.style.maxHeight =s;}">-</button>
<textarea title="Ligne de commande pour un calcul rapide" onkeypress="UI.ckenter(event,this,3)" style="width:400px;height:20px;font-size:large"></textarea><button  title="Evalue cellule precedente" onclick="UI.quick(this);">-></button><span></span>
&nbsp;&nbsp;<button onclick="var s=UI.caseval('restart;'); Module.print(s);" title="Reinitialise le moteur de calcul formel">Restart</button>
<button onclick="UI.exec(document.documentElement);" title='Cliquer ici pour executer toutes les commandes (attention cela peut etre long!)'>Exec. tout</button>
<canvas id='canvas' width=0 height=0   onmousedown="UI.canvas_pushed=true;UI.canvas_lastx=event.clientX; UI.canvas_lasty=event.clientY;"  onmouseup="UI.canvas_pushed=false;" onmousemove="UI.canvas_mousemove(event,'')"></canvas>
<div id="output" style="max-height: 100px; overflow:auto"></div>
</div>
</div>


<script language="javascript"> 
var Module = { 
        htmlcheck:true,
        htmlbuffer:'',
        preRun: [],
        postRun: [],
        print: (function() {
          var element = document.getElementById('output');
          element.innerHTML='';// element.value = ''; // clear browser cache
          return function(text) {
            //console.log(text.charCodeAt(0));
            if (text.length==1 && text.charCodeAt(0)==12){ element.innerHTML=''; return; }
            if (text.length>=1 && text.charCodeAt(0)==2) {console.log('STX');Module.htmlcheck=false; htmlbuffer='';return;}
            if (text.length>=1 && text.charCodeAt(0)==3) {console.log('ETX');Module.htmlcheck=true; element.style.display='inherit'; element.innerHTML += htmlbuffer;htmlbuffer='';element.scrollTop = 99999; return;}
            if (Module.htmlcheck){
            // These replacements are necessary if you render to raw HTML 
             text = text.replace(/&/g, "&amp;");
             text = text.replace(/</g, "&lt;");
             text = text.replace(/>/g, "&gt;");
             text = text.replace('\n', '<br>', 'g');
             text += '<br>'
             element.style.display='inherit';
             element.innerHTML += text; // element.value += text + "\n";
             element.scrollTop = 99999; // focus on bottom
            } else htmlbuffer += text;
          };
        })(),
     canvas: document.getElementById('canvas'),};
</script>


<script src="giac.js" async></script> 



<script language="javascript">
 var UI = {
  histcount:0,
  usemathjax:false,
  canvas_pushed:false,
  canvas_lastx:0,
  canvas_lasty:0,
  canvas_mousemove:function(event,no){
    if (UI.canvas_pushed){
      // Module.print(event.clientX);
      if (UI.canvas_lastx!=event.clientX){
        if (event.clientX>UI.canvas_lastx)
          giac3d('r'+no);
        else
          giac3d('l'+no);
        UI.canvas_lastx=event.clientX;
      }
      if (UI.canvas_lasty!=event.clientY){
        if (event.clientY>UI.canvas_lasty)
          giac3d('d'+no);
        else
          giac3d('u'+no);
        UI.canvas_lasty=event.clientY;
      }
    }
  },  
  quick:function(field){
    var tmp1=field.previousSibling.value;
    var tmp=UI.caseval(tmp1);
    if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); 
    tmp=UI.latexeval(tmp);
    Module.print(String.fromCharCode(2));
    Module.print("<tt>");
    Module.print(tmp1);
    Module.print("</tt><br>&nbsp;&nbsp;");
    Module.print(tmp);
    Module.print("<br>");
    Module.print(String.fromCharCode(3));
    field.nextSibling.innerHTML='&nbsp;'+tmp;
   //UI.render_canvas(nextSibling);  
  },
  caseval:function(text){
    var s="non evalu&eacute;",err;
    try {
       s= giaceval(text);
    } catch (err) { s=err.message;}
    var is_3d=s.length>5 && s.substr(0,5)=='gl3d ';
    if (is_3d){
	var n3d=s.substr(5,s.length-5);
	s = '<canvas id="gl3d_'+n3d+'" onmousedown="UI.canvas_pushed=true;UI.canvas_lastx=event.clientX; UI.canvas_lasty=event.clientY;" onmouseup="UI.canvas_pushed=false;" onmousemove="UI.canvas_mousemove(event,'+n3d+')" width=400 height=250></canvas>';
    }
    return s;
  },
  render_canvas:function(field){
   var n=field.id;
   if (n && n.length>5 && n.substr(0,5)=='gl3d_'){
    Module.print(n);
    var n3d=n.substr(5,n.length-5);
    giac3d(n3d);
    return;
   }
   var f=field.firstChild;
   for (;f;f=f.nextSibling){
     UI.render_canvas(f);
   }
  },
  eval_form: function(field){
    giaceval('assume('+field.name.value+'='+field.valname.value+')');
    var s=UI.caseval(field.prog.value);
    var is_svg=s.substr(1,4)=='<svg';
    if (is_svg) field.parentNode.lastChild.innerHTML=s.substr(1,s.length-2);
    else field.parentNode.lastChild.innerHTML=s;
    UI.render_canvas(field.parentNode.lastChild);
  },
  latexeval:function(text){
    var tmp=text;
    if (tmp.length>5 && tmp.substr(0,5)=='gl3d_') return tmp;
    if (tmp.length>5 && tmp.substr(1,4)=='<svg') return tmp.substr(1,tmp.length-2);
    if (tmp.length>5 && tmp.substr(0,4)=='<svg') return tmp;
     if (UI.usemathjax){
       tmp=giaceval('latex(quote('+tmp+'))');
       tmp='$$'+tmp.substr(1,tmp.length-2)+'$$';
       return tmp;
     }
     tmp=giaceval('mathml(quote('+tmp+',1))');
     tmp=tmp.substr(1,tmp.length-2);
    return tmp;   
  },
  ckenter:function(event,field,mode){
    var key = event.keyCode;
    if (key != 13 || event.shiftKey) return true;
   if (mode==3){ UI.quick(field.nextSibling); event.preventDefault(); return true; }
    var tmp=field.value;
   Module.print(tmp);
    tmp=UI.caseval(tmp);
    if (mode==1){
      if (tmp.charCodeAt(0)==34) tmp=tmp.substr(1,tmp.length-2); 
   }
   if (mode==2){
     tmp=UI.latexeval(tmp);
   }
   field.nextSibling.nextSibling.innerHTML=tmp;
   UI.render_canvas(field.nextSibling.nextSibling);
   if (UI.usemathjax) MathJax.Hub.Queue(["Typeset",MathJax.Hub,field.nextSibling.nextSibling]);
   if (event.preventDefault) event.preventDefault();
    return false;
  },
  exec: function(field){
     if (field.nodeName=="BUTTON"){
        field.click();
        return;
     }
     var f=field.firstChild;
     while (f){
       UI.exec(f);
       f=f.nextSibling;
     }
   }
 };
 window.onload = function(e){
   var isFirefox = typeof InstallTrigger !== 'undefined';   // Firefox 1.0+
   var isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
  var ua = window.navigator.userAgent;
  var old_ie = ua.indexOf('MSIE ');
  var new_ie = ua.indexOf('Trident/');
  if ((!isFirefox && !isSafari) || (old_ie > -1) || (new_ie > -1) || window.chrome){
     UI.usemathjax=true;
     alert("Votre navigateur ne supporte MathML, on utilise MathJax pour l'affichage 2d.  Les calculs seraient plus rapides et les resultats seraient mieux affiches avec Firefox.");
  }
  if (UI.usemathjax){
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  }
  var elem= document.getElementById('controlindex');
  elem.innerHTML='<hr><a href="'+String.fromCharCode(35)+'sec1">Table</a>, <a href="'+String.fromCharCode(35)+'sec2">Index</a>'+elem.innerHTML;
  elem=document.getElementById('maindiv');
  if (elem.style.maxHeight=='500px')
    elem.style.maxHeight=(window.innerHeight-120)+'px';
  giaceval=Module.cwrap('caseval',  'string', ['string']);
  giac3d = Module.cwrap('_ZN4giac13giac_rendererEPKc','number', ['string']);
  giaceval('set_language(1);');
  giaceval('factor(x^4-1)');
  giaceval('sin(x+y)+f(t)');
 // if (confirm('Executer les commandes?')) UI.exec(document.documentElement);
 };
</script>

</p><!--BEGIN NOTES document-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note1" href="#text1">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Certains
systèmes de calcul formel (calculatrices par exemple) utilisent d’ailleurs des
méthodes spécifiques pour gérer le problème de la fragmentation de
la mémoire, appelés “garbage collector”. Ce type de méthode
est intégré dans des langages comme Lisp ou Java, en C/C++ on trouve
des libraries pour cela, par exemple GC de Boehm, incluse dans la
distribution de GCC.</div></dd><dt class="dt-thefootnotes"><a id="note2" href="#text2">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Les HP Prime utilisent Giac comme
noyau de calcul formel, les TI Nspire CAS utilisent sans doute une
version actualisée du système utilisé sur les TI 89, 92,
Voayge 200.</div></dd><dt class="dt-thefootnotes"><a id="note3" href="#text3">3</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">un quartet=un demi octet</div></dd><dt class="dt-thefootnotes"><a id="note4" href="#text4">4</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Plus précisément deux
piles, la pile de donnée et la pile gérant le flux d’exécution. Cette
dernière n’est pas visible par l’utilisateur</div></dd><dt class="dt-thefootnotes"><a id="note5" href="#text5">5</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Sauf si
on utilise comme dernier argument le nombre d’arguments de la fonction ou 
si on utilise (cf. infra) un tag de début de liste d’arguments</div></dd><dt class="dt-thefootnotes"><a id="note6" href="#text6">6</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Toutefois une adaptation du logiciel utilisant comme
quantum de base par exemple 32 bits porterait cette limite
à 65536<sup>65535</sup>−1</div></dd><dt class="dt-thefootnotes"><a id="note7" href="#text7">7</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">cela se fait
par une méthode itérative appelée algorithme
de Francis. On pose <span style="font-style:italic">A</span><sub>0</sub>, la forme
de Hessenberg de <span style="font-style:italic">M</span>, puis on 
factorise <span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">QR</span> par des symétries de Householder ou
des rotations de Givens et on définit
<span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">RQ</span>, le calcul de <span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span>+1</sub> en fonction de <span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>
se fait sans expliciter la factorisation <span style="font-style:italic">QR</span></div></dd><dt class="dt-thefootnotes"><a id="note8" href="#text8">8</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Singular has also a modular implementation in
<span style="font-family:monospace">modstd.lib</span>, but it is not called by default.</div></dd><dt class="dt-thefootnotes"><a id="note9" href="#text9">9</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">on notant <span style="font-style:italic">X</span>(<span style="font-style:italic">t</span>) et
<span style="font-style:italic">Y</span>(<span style="font-style:italic">t</span>) les deux fonctions pour pouvoir utiliser <span style="font-style:italic">x</span> et <span style="font-style:italic">y</span> dans <span style="font-family:monospace">droite</span></div></dd><dt class="dt-thefootnotes"><a id="note10" href="#text10">10</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Si <span style="font-style:italic">r</span>′≠ 0,
cela se lit sur l’expression de la vitesse qui est non nulle, mais
c’est encore vrai si <span style="font-style:italic">r</span>(θ)=<span style="font-style:italic">r</span>′(θ)=0 et <span style="font-style:italic">r</span> non identiquement nul, 
pour le voir, on observe que <span style="font-style:italic">M</span>(θ)<span style="font-style:italic">M</span>(θ+<span style="font-style:italic">h</span>)=<span style="font-style:italic">OM</span>(θ+<span style="font-style:italic">h</span>) a pour
direction <span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub>(θ+<span style="font-style:italic">h</span>) qui tend vers <span style="font-style:italic">e</span><sub><span style="font-style:italic">r</span></sub>(θ) lorsque <span style="font-style:italic">h</span> tend
vers 0.</div></dd><dt class="dt-thefootnotes"><a id="note11" href="#text11">11</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">En toute rigueur il faut ajouter deux autres cas ;
l’ensemble vide et les paires éventuellement confondues de droites</div></dd><dt class="dt-thefootnotes"><a id="note12" href="#text12">12</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">en négligeant la masse
de la planète devant celle du Soleil</div></dd><dt class="dt-thefootnotes"><a id="note13" href="#text13">13</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Si <span style="font-style:italic">d</span>=<span style="font-style:italic">e</span>=0, le
polynôme est homogène et se factorise,
on obtient l’origine ou la réunion de deux droites</div></dd><dt class="dt-thefootnotes"><a id="note14" href="#text14">14</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Cette méthode
fonctionne pour les coniques, mais ne fonctionne malheureusement
pas pour n’importe quelle équation cartésienne</div></dd><dt class="dt-thefootnotes"><a id="note15" href="#text15">15</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">sinon, on 
aura deux droites parce que le
polynôme <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) se factorise en produit de deux facteurs
de degré 1 dont <span style="font-style:italic">dx</span>+<span style="font-style:italic">ey</span></div></dd><dt class="dt-thefootnotes"><a id="note16" href="#text16">16</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">On peut aussi voir ce discriminant comme le
déterminant de la matrice de la forme quadratique associée</div></dd><dt class="dt-thefootnotes"><a id="note17" href="#text17">17</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">qui tire
son nom de la trajectoire d’un point fixé à un cercle roulant
sans glisser sur une droite, par exemple l’extrémité d’un rayon 
sur une roue de vélo.</div></dd><dt class="dt-thefootnotes"><a id="note18" href="#text18">18</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">On peut montrer qu’une courbe
convexe admet au moins 4 sommets (théorème des quatre sommets), 
sa développée admet donc
au moins 4 points de rebroussements.</div></dd><dt class="dt-thefootnotes"><a id="note19" href="#text19">19</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">L’enveloppe d’une famille
de droites est une courbe dont l’ensemble des tangentes est la famille de droite</div></dd><dt class="dt-thefootnotes"><a id="note20" href="#text20">20</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Ce type de courbe, appelé
spirale d’Euler<a id="hevea_default113"></a> ou de Fresnel<a id="hevea_default114"></a> ou clothoïde<a id="hevea_default115"></a>, est utilisée pour
faire des raccordements de chemin de fer (ou de route) 
entre une portion rectiligne, où l’accélération normale est
nulle, et un arc de cercle, où l’accélération normale est
constante, en effet si <span style="font-style:italic">Rs</span>=<span style="font-style:italic">b</span><sup>2</sup> est constant alors l’accélération
normale varie linéairement en fonction de l’abscisse curviligne
donc du temps à vitesse constante. C’est plus agréable pour
les passagers qui passent d’une accélération nulle à une
accélération constante progressivement, mais aussi pour
créer une pente progressive latérale sur les rails pour compenser
la force centrifuge par la gravité et éviter une usure
prématurée du rail.</div></dd><dt class="dt-thefootnotes"><a id="note21" href="#text21">21</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Géométriquement,
<span style="font-style:italic">dx</span> [resp. <span style="font-style:italic">dy</span>] est la forme linéaire constante
(i.e. indépendante du point du plan choisi) qui a tout vecteur de
ℝ<sup>2</sup> associe sa première [resp. deuxième] coordonnée :
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">dx</span>(<span style="font-style:italic">v</span><sub>1</sub>,<span style="font-style:italic">v</span><sub>2</sub>)=<span style="font-style:italic">v</span><sub>1</sub>,    <span style="font-style:italic">dy</span>(<span style="font-style:italic">v</span><sub>1</sub>,<span style="font-style:italic">v</span><sub>2</sub>)=<span style="font-style:italic">v</span><sub>2</sub> </td></tr>
</table></div></dd><dt class="dt-thefootnotes"><a id="note22" href="#text22">22</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Pour être complet, on suppose de plus que cette application
linéaire qui dépend du point du plan en dépend de manière 
continue voire différentiable</div></dd><dt class="dt-thefootnotes"><a id="note23" href="#text23">23</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">En toute rigueur,
il faut prouver que la solution maximale est bien définie sur
ℝ tout entier. Soit ]<span style="font-style:italic">t</span><sub><span style="font-style:italic">m</span></sub>,<span style="font-style:italic">t</span><sub><span style="font-style:italic">M</span></sub>[ l’intervalle maximal de
définition de la solution. Si <span style="font-style:italic">t</span><sub><span style="font-style:italic">M</span></sub> ≠ +∞,
alors en intégrant <span style="font-style:italic">y</span>′ qui est borné sur [<span style="font-style:italic">t</span><sub>0</sub>,<span style="font-style:italic">t</span><sub><span style="font-style:italic">M</span></sub>[ 
on obtient une valeur finie pour la limite en <span style="font-style:italic">t</span><sub><span style="font-style:italic">M</span></sub> de <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>),
on peut alors prolonger <span style="font-style:italic">y</span>(<span style="font-style:italic">t</span>) autour de <span style="font-style:italic">t</span><sub><span style="font-style:italic">M</span></sub>
en appliquant le théorème de Cauchy-Lipschitz en <span style="font-style:italic">t</span>=<span style="font-style:italic">t</span><sub><span style="font-style:italic">M</span></sub>,
ce qui est contradictoire avec l’hypothèse de maximalité. 
Donc <span style="font-style:italic">t</span><sub><span style="font-style:italic">M</span></sub>=+∞ et de même <span style="font-style:italic">t</span><sub><span style="font-style:italic">m</span></sub>=−∞</div></dd><dt class="dt-thefootnotes"><a id="note24" href="#text24">24</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Cela vient du fait que
les puissances de <span style="font-style:italic">A</span> forment une famille d’un
espace vectoriel de dimension finie <span style="font-style:italic">n</span><sup>2</sup>, donc la famille est liée
à partir de <span style="font-style:italic">n</span><sup>2</sup>+1 éléments, en fait on peut montrer
que c’est le cas si on considère <span style="font-style:italic">I</span>,<span style="font-style:italic">A</span>,...,<span style="font-style:italic">A</span><sup><span style="font-style:italic">n</span></sup>.</div></dd><dt class="dt-thefootnotes"><a id="note25" href="#text25">25</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">On peut prouver l’existence globale de la solution
exactement comme pour l’exemple <span style="font-style:italic">y</span>′=<span style="font-style:italic">y</span>(1−<span style="font-style:italic">y</span>) de la section 
<a href="#sec%3Aexistence">14.2</a></div></dd><dt class="dt-thefootnotes"><a id="note26" href="#text26">26</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Pour une méthode à pas variable,
le pas <span style="font-style:italic">h</span> peut dépendre de <span style="font-style:italic">i</span></div></dd><dt class="dt-thefootnotes"><a id="note27" href="#text27">27</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Il n’existe à ma connaissance
pas de résultat sur pourquoi ces choix de <span style="font-style:italic">f</span> donnent 
des entiers bien répartis par rapport au hasard</div></dd><dt class="dt-thefootnotes"><a id="note28" href="#text28">28</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Rappelons qu’il s’agit d’une
majoration sur la valeur absolue des coefficients des facteurs de <span style="font-style:italic">P</span></div></dd><dt class="dt-thefootnotes"><a id="note29" href="#text29">29</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Plus exactement, on multiplie <span style="font-style:italic">P</span><sub><span style="font-style:italic">j</span></sub> par le
coefficient dominant de <span style="font-style:italic">P</span> modulo <span style="font-style:italic">p</span><sup><span style="font-style:italic">l</span></sup></div></dd><dt class="dt-thefootnotes"><a id="note30" href="#text30">30</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Ici |<span style="font-style:italic">P</span>| désigne le plus grand
coefficient de <span style="font-style:italic">P</span> en valeur absolue</div></dd><dt class="dt-thefootnotes"><a id="note31" href="#text31">31</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">cette preuve peut être sautée en première
lecture</div></dd><dt class="dt-thefootnotes"><a id="note32" href="#text32">32</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Peut être omise en première lecture</div></dd><dt class="dt-thefootnotes"><a id="note33" href="#text33">33</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Si <span style="font-style:italic">A</span> est la matrice companion
d’un polynôme, une autre approche 
consiste à rechercher un rectangle du plan complexe stable par itérée
de la méthode de Newton ou à calculer les disques
de centre les coefficients diagonaux et de rayon le
degré du polynôme divisé par un minorant de la
dérivée du polynôme par la valeur du polynôme</div></dd><dt class="dt-thefootnotes"><a id="note34" href="#text34">34</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">acronyme récursif de GiNac Is Not A Cas,
jeu de mot identique à Gnu is Not Unix, alors que Giac est
l’acronyme de Giac Is A Cas</div></dd><dt class="dt-thefootnotes"><a id="note35" href="#text35">35</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Il serait d’ailleurs intéressant de calculer le 
cout énergétique d’un même calcul fait par Sage, Maxima, 
Xcas et une calculatrice formelle! Pour avoir un ordre
de grandeur, une recherche sur google émettrait 7g de CO2, 
soit environ 16Wh, de quoi faire fonctionner un ordinateur 
portable un quart d’heure et une calculatrice haut de gamme
pendant une journée</div></dd><dt class="dt-thefootnotes"><a id="note36" href="#text36">36</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">512M de RAM pour la
machine virtuelle linux, à quoi il faut ajouter 
le logiciel VirtualBox et le navigateur. De plus la taille des
calculs possibles est limitée par la RAM allouée à
la machine virtuelle.</div></dd><dt class="dt-thefootnotes"><a id="note37" href="#text37">37</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Ce qui est peut-être une bonne chose,
on peut le voir comme deux stratégies complémentaires pour le
calcul formel libre</div></dd><dt class="dt-thefootnotes"><a id="note38" href="#text38">38</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">ainsi Allan Steel, le principal codeur du logiciel 
Magma, dont l’attractivité doit tout au génie algorithmique de cet
auteur, n’apparait même pas dans la citation recommendée
du logiciel.</div></dd></dl>
<!--END NOTES-->
<!--CUT END -->
<!--HTMLFOOT-->
Retour à la page principale de <a href="http://www-fourier.ujf-grenoble.fr/parisse/giac_fr.html">Giac/Xcas</a>.<!--ENDHTML-->
<!--FOOTER-->
<hr style="height:2"><blockquote class="quote"><em>Ce document a été traduit de L<sup>A</sup>T<sub>E</sub>X par </em><a href="http://hevea.inria.fr"><em>H</em><em><span style="font-size:small"><sup>E</sup></span></em><em>V</em><em><span style="font-size:small"><sup>E</sup></span></em><em>A</em></a></blockquote></body>
</html>
