<!DOCTYPE html>
<html >
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.29+5 of 2017-05-18">
<link rel="stylesheet" type="text/css" href="cascmd_en.css">
<title>Solving general linear programming problems: lpsolve
</title>
</head>
<body >
<a href="cascmd_en533.html"><img src="previous_motif.gif" alt="Previous"></a>
<a href="index.html"><img src="contents_motif.gif" alt="Up"></a>
<a href="cascmd_en535.html"><img src="next_motif.gif" alt="Next"></a>
<hr>
<h3 id="sec674" class="subsection">6.52.2  Solving general linear programming problems: <span style="font-family:monospace">lpsolve</span>
<a id="hevea_default930"></a></h3>
<p>The <span style="font-family:monospace">lpsolve</span> command can solve linear programming problems
(where a multivariate linear function needs to be maximized or
minimized subject to linear (in)equality constraints), as well as
(mixed) integer programming problems. You can enter a problem 
directly (in symbolic or matrix form) load it from a file in LP or
(gzipped) MPS format.</p>
<h4 id="sec675" class="subsubsection">Solving an LP problem in symbolic form</h4>
<p>To enter a problem symbolically:
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">lpsolve</span> takes one mandatory argument and three
optional arguments:
<ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">obj</span>, a symbolic expression representing the
objective function or a path to a file containing the LP problem.
</li><li class="li-itemize">Optionally, <span style="font-style:italic">constr</span>, list of linear constraints which
may be equalities or inequalities or bounded expressions entered as
<span style="font-style:italic">expr</span>=<span style="font-style:italic">a</span>..<span style="font-style:italic">b</span>. (If <span style="font-style:italic">obj</span> is a file name, this
option is omitted.)
</li><li class="li-itemize">Optionally, <span style="font-style:italic">bd</span>, a sequence of expressions of type
<span style="font-style:italic">x</span><span style="font-family:monospace">=</span><span style="font-style:italic">a</span><span style="font-family:monospace">..</span><span style="font-style:italic">b</span>, specifying that the variable <span style="font-style:italic">x</span> is bounded
below by <span style="font-style:italic">a</span> and above by <span style="font-style:italic">b</span>.
</li><li class="li-itemize">Optionally, <span style="font-style:italic">opts</span>, a sequence of solver settings in
form <span style="font-style:italic">option=value</span>, where <span style="font-family:monospace">option</span> may be one of:
<ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">assume</span>, which specifies a global constraint on
variables and whose value can be one of:
<ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">lp_nonnegative</span> (all variables are nonnegative)
</li><li class="li-itemize"><span style="font-family:monospace">lp_integer</span> or <span style="font-family:monospace">integer</span> (all variables are integers)
</li><li class="li-itemize"><span style="font-family:monospace">lp_binary</span> (all variables are binary, i.e. 0 or 1)
</li><li class="li-itemize"><span style="font-family:monospace">lp_nonnegint</span> or <span style="font-family:monospace">nonnegint</span> (all variables are nonnegative integers)
</li></ul>
(by default, <span style="font-style:italic">unset</span>.)
</li><li class="li-itemize"><span style="font-family:monospace">lp_integervariables</span>, whose value should be a list
of identifiers or indices (of integer variables) (by default,
<span style="font-family:monospace">lp_integervariables=[]</span>).
</li><li class="li-itemize"><span style="font-family:monospace">lp_binaryvariables</span>, whose value should be a list
of identifiers or indices (of binary variables) (by default,
<span style="font-family:monospace">lp_binaryvariables=[]</span>).
</li><li class="li-itemize"><span style="font-family:monospace">lp_maximize</span> (or <span style="font-family:monospace">maximize</span>), whose value can
be <span style="font-family:monospace">true</span> or <span style="font-family:monospace">false</span> setting the objective
direction (by default, <span style="font-family:monospace">lp_maximize=false</span>, meaning that the
objective is minimized).
</li><li class="li-itemize"><span style="font-family:monospace">lp_method</span>, setting the solver type, whose value can be one of:
<ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">exact</span>
</li><li class="li-itemize"><span style="font-family:monospace">float</span>
</li><li class="li-itemize"><span style="font-family:monospace">lp_simplex</span>
</li><li class="li-itemize"><span style="font-family:monospace">lp_interiorpoint</span>
</li></ul>
(by default, <span style="font-family:monospace">lp_method=lp_simplex</span>).
</li><li class="li-itemize"><span style="font-family:monospace">lp_depthlimit</span>, whose value can be a positive
integer, which sets the maximum depth of the branch and bound tree
(by default, <span style="font-style:italic">unlimited</span>).
</li><li class="li-itemize"><span style="font-family:monospace">lp_nodelimit</span>, whose value can be a positive integer,
which sets the maximum number of nodes in the branch and bound tree
(by default, <span style="font-style:italic">unlimited</span>).
</li><li class="li-itemize"><span style="font-family:monospace">lp_iterationlimit</span>, whose value can be positive integer
setting the maximum iterations of the simplex
algorithm (by default, <span style="font-style:italic">unlimited</span>).<br>
 If the maximum number of iterations is reached, the current
feasible solution (not necessarily an optimal one) is returned.
</li><li class="li-itemize"><span style="font-family:monospace">lp_timelimit</span>, whose value can be a positive number,
setting the maximum solving time in milliseconds (by default, <span style="font-style:italic">unlimited</span>).
</li><li class="li-itemize"><span style="font-family:monospace">lp_maxcuts</span>, whose value can be a nonnegative integer
setting the maximum GMI cuts per node, (by default,
<span style="font-family:monospace">lp_maxcuts=5</span>). 
</li><li class="li-itemize"><span style="font-family:monospace">lp_gaptolerance</span>, whose value can be a positive
number, setting the relative integrality gap threshold (by default,
<span style="font-family:monospace">lp_gaptolerance=0</span>).
</li><li class="li-itemize"><span style="font-family:monospace">lp_nodeselect</span>, which sets the branching node
selection strategy and whose value can be one of:
<ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">lp_depthfirst</span>
</li><li class="li-itemize"><span style="font-family:monospace">lp_breadthfirst</span>
</li><li class="li-itemize"><span style="font-family:monospace">lp_hybrid</span>
</li><li class="li-itemize"><span style="font-family:monospace">lp_bestprojection</span>
</li></ul>
(by default, <span style="font-family:monospace">lp_nodeselect=lp_hybrid</span>).
</li><li class="li-itemize"><span style="font-family:monospace">lp_varselect</span>, which sets the branching variable
selection strategy, whose value can be one of
<ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">lp_firstfractional</span>
</li><li class="li-itemize"><span style="font-family:monospace">lp_lastfractional</span>
</li><li class="li-itemize"><span style="font-family:monospace">lp_mostfractional</span>
</li><li class="li-itemize"><span style="font-family:monospace">lp_pseudocost</span>
</li></ul>
(by default, <span style="font-family:monospace">lp_varselect=lp_pseudocost</span>).
</li><li class="li-itemize"><span style="font-family:monospace">lp_verbose</span>, whose value can be <span style="font-family:monospace">true</span> or
<span style="font-family:monospace">false</span> (by default: <span style="font-family:monospace">lp_verbose=false</span>).
</li></ul>
</li></ul>
</li><li class="li-itemize"><span style="font-family:monospace">lpsolve(</span><span style="font-style:italic">obj,</span> ⟨<span style="font-style:italic">constr,bd,opts</span>⟩<span style="font-family:monospace">)</span>
returns a list <span style="font-family:monospace">[</span><span style="font-style:italic">optimum,soln</span><span style="font-family:monospace">]</span>, where
<span style="font-style:italic">optimum</span> is the minimum/maximum value of the objective
function and <span style="font-style:italic">soln</span> is the list of coordinates corresponding to
the point at which the optimal value is attained, i.e. the optimal
solution. If there is no feasible solution, an empty list is returned.
When the objective function is unbounded, <span style="font-style:italic">optimum</span> is returned
as <span style="font-family:monospace">+infinity</span> (for maximization problems) or
<span style="font-family:monospace">-infinity</span> (for minimization problems). If an error is
experienced while solving (terminating the process), <span style="font-family:monospace">undef</span> is
returned.
</li></ul><p>
The given objective function is minimized by default. To maximize it,
include the option <span style="font-family:monospace">lp_maximize=true</span> or <span style="font-family:monospace">lp_maximize</span>
or simply <span style="font-family:monospace">maximize</span>. Also note that all variables are, unless
specified otherwise, assumed to be continuous and unrestricted in
sign.</p><p><br>
</p><p><span style="font-weight:bold">Examples.</span>
</p><ul class="itemize"><li class="li-itemize">
Solve the problem specified in (<a href="cascmd_en533.html#eq%3Alpexample">11</a>):<br>
<span style="font-style:italic">Input</span>:
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">constr:=[x&lt;=1,y&gt;=2,x+3y-z=2,3x-y+z&lt;=8,-x+y&lt;=5];</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">lpsolve(2x+y-z+4,constr)</span>
</td></tr>
</table>
</div>
<span style="font-style:italic">Output:</span>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎣</td><td class="dcell">−4,</td><td class="dcell">⎡<br>
⎣</td><td class="dcell"><span style="font-style:italic">x</span>=0,<span style="font-style:italic">y</span>=5,<span style="font-style:italic">z</span>=13</td><td class="dcell">⎤<br>
⎦</td><td class="dcell">⎤<br>
⎦</td></tr>
</table>
Therefore, the minimum value of <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>,<span style="font-style:italic">z</span>)=2 <span style="font-style:italic">x</span>+<span style="font-style:italic">y</span>−<span style="font-style:italic">z</span>+4 is equal to −4
under the given constraints. The optimal value is attained at point
(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>,<span style="font-style:italic">z</span>)=(0,5,13). 
</li><li class="li-itemize">Constraints may also take the form <span style="font-family:monospace">expr=a..b</span> for bounded
linear expressions.<br>
<span style="font-style:italic">Input:</span>
<div class="center">
<span style="font-family:monospace">lpsolve(x+2y+3z,[x+y=1..5,y+z+1=2..4,x&gt;=0,y&gt;=0])</span>
</div>
<span style="font-style:italic">Output:</span>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎣</td><td class="dcell">−2,</td><td class="dcell">⎡<br>
⎣</td><td class="dcell"><span style="font-style:italic">x</span>=0,<span style="font-style:italic">y</span>=5,<span style="font-style:italic">z</span>=−4</td><td class="dcell">⎤<br>
⎦</td><td class="dcell">⎤<br>
⎦</td></tr>
</table>
</li><li class="li-itemize">Use the <span style="font-family:monospace">assume=lp_nonnegative</span> option to specify that all
variables are nonnegative. It is easier than entering the
nonnegativity constraints explicitly.<br>
<span style="font-style:italic">Input:</span>
<div class="center">
<span style="font-family:monospace">lpsolve(-x-y,[y&lt;=3x+1/2,y&lt;=-5x+2],assume=lp_nonnegative)</span>
</div>
<span style="font-style:italic">Output:</span>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">5</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell">,</td><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell"><span style="font-style:italic">x</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">3</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">16</td></tr>
</table></td><td class="dcell">,<span style="font-style:italic">y</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">17</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">16</td></tr>
</table></td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td></tr>
</table>
</li><li class="li-itemize">Bounds can be added separately for some variables. They should be
entered after constraints.<br>
<span style="font-style:italic">Input:</span>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">constr:=[5x-10y&lt;=20,2z-3y=6,-x+3y&lt;=3];</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">lpsolve(-6x+4y+z,constr,x=1..20,y=0..inf)</span>
</td></tr>
</table>
</div>
<span style="font-style:italic">Output:</span>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">133</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">,</td><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell"><span style="font-style:italic">x</span>=18,<span style="font-style:italic">y</span>=7,<span style="font-style:italic">z</span>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">27</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td></tr>
</table>
</li></ul>
<h4 id="sec676" class="subsubsection">Solving an LP problem in matrix form</h4>
<p>To enter a problem in matrix form:
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">lpsolve</span> takes 
<ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">obj</span>, a vector of coefficients representing the objective
function.
</li><li class="li-itemize"><span style="font-style:italic">constr</span>, a list [<span style="font-style:italic">A</span>,<span style="font-style:italic">b</span>,<span style="font-style:italic">A</span><sub>eq</sub>,<span style="font-style:italic">b</span><sub>eq</sub>]
such that objective function <span style="font-style:italic">obj</span><sup><span style="font-style:italic">T</span></sup>· <span style="font-style:italic">x</span> is to be
minimized/maximized subject to constraints <span style="font-style:italic">Ax</span> ≤ <span style="font-style:italic">b</span> and
<span style="font-style:italic">A</span><sub>eq</sub><span style="font-style:italic">x</span> = <span style="font-style:italic">b</span><sub>eq</sub>.<p>If the problem does not
contain equality constraints, <span style="font-style:italic">A</span><sub>eq</sub> and 
<span style="font-style:italic">b</span><sub>eq</sub> may be omitted. For a problem that does not contain
inequality constraints, empty lists must be entered in place of 
<span style="font-style:italic">A</span> and <span style="font-style:italic">b</span>.
</p></li><li class="li-itemize"><span style="font-style:italic">bd</span>, a list of two vectors [<span style="font-style:italic">b</span><sub><span style="font-style:italic">l</span></sub>,<span style="font-style:italic">b</span><sub><span style="font-style:italic">u</span></sub>] of the same
length as <span style="font-style:italic">c</span> such that <span style="font-style:italic">b</span><sub><span style="font-style:italic">l</span></sub>≤ <span style="font-style:italic">x</span> ≤ <span style="font-style:italic">b</span><sub><span style="font-style:italic">u</span></sub>.
These vectors may contain <span style="font-family:monospace">+infinity</span> or <span style="font-family:monospace">-infinity</span>.
</li><li class="li-itemize"><span style="font-style:italic">opts</span>, as before.
</li></ul>
</li><li class="li-itemize"><span style="font-family:monospace">lpsolve(</span><span style="font-style:italic">obj,</span> ⟨<span style="font-style:italic">constr,bd,opts</span>⟩<span style="font-family:monospace">)</span>
returns a list <span style="font-family:monospace">[</span><span style="font-style:italic">optimum,soln</span><span style="font-family:monospace">]</span> as before.
<span style="font-style:italic">optimum</span> is the minimum/maximum value of the objective
function and <span style="font-style:italic">soln</span> is the list of coordinates corresponding to
the point at which the optimal value is attained, i.e. the optimal
solution. If there is no feasible solution, an empty list is returned.
When the objective function is unbounded, <span style="font-style:italic">optimum</span> is returned
as <span style="font-family:monospace">+infinity</span> (for maximization problems) or
<span style="font-family:monospace">-infinity</span> (for minimization problems). If an error is
experienced while solving (terminating the process), <span style="font-family:monospace">undef</span> is
returned.

</li></ul><p><br>
</p><p><span style="font-weight:bold">Examples.</span>
</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">Input:</span>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">c:=[-2,1];A:=[[-1,1],[1,1],[-1,0],[0,-1]];b:=[3,5,0,0];</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">lpsolve(c,[A,b])</span>
</td></tr>
</table>
</div>
<span style="font-style:italic">Output:</span>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎣</td><td class="dcell">−10,</td><td class="dcell">⎡<br>
⎣</td><td class="dcell">5,0</td><td class="dcell">⎤<br>
⎦</td><td class="dcell">⎤<br>
⎦</td></tr>
</table>
</li><li class="li-itemize"><span style="font-style:italic">Input:</span>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">c:=[-2,5,-3];bl:=[2,3,1];bu:=[6,10,7/2];</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">lpsolve(c,[],[bl,bu])</span>
</td></tr>
</table>
</div>
<span style="font-style:italic">Output:</span>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">15</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">,</td><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell">6,3,</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">7</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td></tr>
</table>
<span style="font-style:italic">Input:</span>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">c:=[4,5];Aeq:=[[-1,3/2],[-3,2]];beq:=[2,3];</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">lpsolve(c,[[],[],Aeq,beq])</span>
</td></tr>
</table>
</div>
<span style="font-style:italic">Output:</span>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">26</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">,</td><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">,</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">6</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td></tr>
</table>
</li></ul>
<h4 id="sec677" class="subsubsection">Solving MIP (Mixed Integer Programming) problems</h4>
<p>The <span style="font-family:monospace">lpsolve</span> command allows restricting (some) variables to
integer values. Such problems, called (<em>mixed</em>) <em>integer
programming problems</em>, are solved by applying the branch and bound method.</p><p>To solve pure integer programming problems, in which all variables are
integers, use the option <span style="font-family:monospace">assume=integer</span> or
<span style="font-family:monospace">assume=lp_integer</span>.</p><p><br>
</p><p><span style="font-weight:bold">Example.</span><br>
<span style="font-style:italic">Input:</span>
</p><div class="center">
<span style="font-family:monospace">lpsolve(-5x-7y,[7x+y&lt;=35,-x+3y&lt;=6],assume=integer)</span>
</div><p>
<span style="font-style:italic">Output:</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎣</td><td class="dcell">−41,</td><td class="dcell">⎡<br>
⎣</td><td class="dcell"><span style="font-style:italic">x</span>=4,<span style="font-style:italic">y</span>=3</td><td class="dcell">⎤<br>
⎦</td><td class="dcell">⎤<br>
⎦</td></tr>
</table><p><br>
</p><p>Use the option <span style="font-family:monospace">assume=lp_binary</span> to specify that all variables
are binary, i.e. the only allowed values are 0 and 1. These usually 
represent <span style="font-family:monospace">false</span> and <span style="font-family:monospace">true</span>, respectively, giving the
variable a certain meaning in logical context.</p><p><br>
</p><p><span style="font-weight:bold">Example.</span><br>
<span style="font-style:italic">Input:</span>
</p><div class="center">
<span style="font-family:monospace">lpsolve(8x1+11x2+6x3+4x4,[5x1+7x2+4x3+3x4&lt;=14],assume=lp_binary,maximize)</span>
</div><p>
<span style="font-style:italic">Output:</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎣</td><td class="dcell">21,</td><td class="dcell">⎡<br>
⎣</td><td class="dcell"><span style="font-style:italic">x</span><sub>1</sub>=0,<span style="font-style:italic">x</span><sub>2</sub>=1,<span style="font-style:italic">x</span><sub>3</sub>=1,<span style="font-style:italic">x</span><sub>4</sub>=1</td><td class="dcell">⎤<br>
⎦</td><td class="dcell">⎤<br>
⎦</td></tr>
</table><p><br>
</p><p>To solve mixed integer problems, where some variables are integers and
some are continuous, use the option keywords <span style="font-family:monospace">lp_integervariables</span>
to specify integer variables and/or <span style="font-family:monospace">lp_binaryvariables</span> to
specify binary variables.</p><p>Input:
</p><div class="center">
<span style="font-family:monospace">lpsolve(x+3y+3z,[x+3y+2z&lt;=7,2x+2y+z&lt;=11],</span><br>
<span style="font-family:monospace">assume=lp_nonnegative,lp_maximize,</span>
<span style="font-family:monospace">lp_integervariables=[x,z])</span>
</div><p>
Output:
</p><div class="center">
	<span style="font-family:monospace">[10,[x=1,y=0,z=3]]</span>
</div><p><br>
</p><p>Use the <span style="font-family:monospace">assume=lp_nonnegint</span> or <span style="font-family:monospace">assume=nonnegint</span>
option to get nonnegative integer values.</p><p><br>
</p><p><span style="font-weight:bold">Example.</span><br>
<span style="font-style:italic">Input:</span>
</p><div class="center">
<span style="font-family:monospace">lpsolve(2x+5y,[3x-y=1,x-y&lt;=5],assume=nonnegint)</span>
</div><p>
<span style="font-style:italic">Output:</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎣</td><td class="dcell">12,</td><td class="dcell">⎡<br>
⎣</td><td class="dcell"><span style="font-style:italic">x</span>=1,<span style="font-style:italic">y</span>=2</td><td class="dcell">⎤<br>
⎦</td><td class="dcell">⎤<br>
⎦</td></tr>
</table><p><br>
</p><p>When specifying MIP problems in matrix form, lists corresponding to
the options <span style="font-family:monospace">lp_integervariables</span> and <span style="font-family:monospace">lp_binaryvariables</span>
are populated with variable indices, like in the following example.</p><p><br>
</p><p><span style="font-weight:bold">Example.</span><br>
<span style="font-style:italic">Input:</span>
</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">c:=[2,-3,-5];A:=[[-5,4,-5],[2,5,7],[2,-3,4]];b:=[3,1,-2];</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">lpsolve(c,[A,b],lp_integervariables=[0,2])</span>
</td></tr>
</table>
</div><p>
<span style="font-style:italic">Output:</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell">19,</td><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell">1,</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">3</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell">,−1</td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td></tr>
</table><p>
You can also specify a range of indices instead of a list when there is too much variables. Example: <span style="font-family:monospace">lp_binaryvariables=0..99</span> means that all variables  <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>  such that  0≤ <span style="font-style:italic">i</span>≤ 99  are binary.</p>
<h4 id="sec678" class="subsubsection">About <span style="font-family:monospace">lpsolve</span></h4>
<h5 id="sec679" class="paragraph">Implementation details.</h5>
<p>The branch and bound algorithm by
definition generates a binary tree of subproblems by branching on
integer variables with fractional values. The <span style="font-family:monospace">lpsolve</span> command features an
implementation which stores only active nodes of a branch and bound tree in
a list, thus saving a lot of space. Also, since variable bounds are
the only parameters that change during the branch and bound algorithm,
the number of constraints does not rise with depth, which is the
benefit of the upper-bounding technique built in the simplex
algorithm. Therefore a steady speed and minimal resource usage is
always maintained, no matter how long the execution time is. This
allows for solving problems that require tens or hundreds of thousands
of nodes to be generated before finding an optimal solution.</p>
<h5 id="sec680" class="paragraph">Stopping criteria.</h5>
<p>There are several ways to force the
branch and bound algorithm to stop prematurely when the execution takes
too much time. You can set <span style="font-family:monospace">lp_timelimit</span> to an integer
which defines the maximum number of milliseconds allowed to find an
optimal solution. Other ways are to set <span style="font-family:monospace">lp_nodelimit</span> or
<span style="font-family:monospace">lp_depthlimit</span> to limit the number of nodes generated in
the branch and bound tree or its depth, respectively. Finally, you can set
<span style="font-family:monospace">lp_gaptolerance</span> to some positive value, say <span style="font-style:italic">t</span>&gt;0, which
terminates the algorithm after finding an incumbent solution and
proving that the corresponding objective value differs from the optimum
value for less than <span style="font-style:italic">t</span>· 100 % . This is done by monitoring the
size of the integrality gap, i.e. the difference between the current incumbent
objective value and the best objective value bound among active nodes.</p><p>If the branch and bound algorithm terminates prematurely, a warning message
indicating the cause is displayed. The incumbent solution, if any, is
returned as the result, else the problem is declared to be infeasible.</p>
<h5 id="sec681" class="paragraph">Branching strategies.</h5>
<p>At every iteration of the branch and bound
algorithm, a node must be selected for branching on some variable that
has a fractional optimal value for the corresponding relaxed
subproblem. There exist different methods for making such decisions,
called <em>branching strategies</em>. Two types of branching strategies
exist: the <em>node selection</em> and <em>variable selection</em>
strategies.</p><p>The node selection strategy can be set by using the
<span style="font-family:monospace">lp_nodeselect</span> option. Possible values are:
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">lp_breadthfirst</span>, which chooses the active node which
provides the best bound for the objective value, 
</li><li class="li-itemize"><span style="font-family:monospace">lp_depthfirst</span>, which chooses the deepest active node
and break ties by selecting the node providing the best bound, 
</li><li class="li-itemize"><span style="font-family:monospace">lp_hybrid</span>, which combines the above two strategies,
</li><li class="li-itemize"><span style="font-family:monospace">lp_bestprojection</span>, which chooses the node with best simple projection.
</li></ul><p>
By default, the <span style="font-family:monospace">lp_bestprojection</span> strategy is used. Another
sophisticated strategy is <span style="font-family:monospace">lp_hybrid</span>: before an incumbent
solution is found, the solver uses the <span style="font-family:monospace">lp_depthfirst</span> strategy,
“diving” into the tree as an incumbent solution is more likely to be
located deeply. When an incumbent is found, the solver switches to the
<span style="font-family:monospace">lp_breadthfirst</span> strategy to try to close the integrality gap
as quickly as possible. </p><p>The Variable selection strategy can be set by using the
<span style="font-family:monospace">lp_varselect</span> option. Possible values are:
</p><ul class="itemize"><li class="li-itemize">
	<span style="font-family:monospace">lp_firstfractional</span>, which chooses the first fractional variable,
	</li><li class="li-itemize"><span style="font-family:monospace">lp_lastfractional</span>, which chooses the last fractional variable,
	</li><li class="li-itemize"><span style="font-family:monospace">lp_mostfractional</span>, which chooses the variable
with fractional part closest to 0.5, 
	</li><li class="li-itemize"><span style="font-family:monospace">lp_pseudocost</span>, which chooses the variable
which had the greatest impact on the objective value in
previous branchings. 
</li></ul><p>
By default, the <span style="font-family:monospace">lp_pseudocost</span> strategy is used. However,
since pseudocost-based choice cannot be made before all integer
variables have been branched upon at least one time in each direction,
the <span style="font-family:monospace">lp_mostfractional</span> strategy is used until that condition is
fulfilled. </p><p>Using the right combination of branching strategies may significantly
reduce the number of subproblems needed to be examined when solving a
particular MIP problem. However, what is “right” varies from problem
to problem. Default strategies are the most sophisticated (as they use
the available data most extensively) and usually the most effective
ones. But that is not always the case, as illustrated by the following
example.</p><p><br>
</p><p><span style="font-weight:bold">Example.</span><br>
:
Minimize <span style="font-weight:bold"><span style="font-style:italic">c</span></span>·<span style="font-weight:bold"><span style="font-style:italic">x</span></span> subject to 
<span style="font-weight:bold"><span style="font-style:italic">A</span></span> <span style="font-weight:bold"><span style="font-style:italic">x</span></span>=<span style="font-weight:bold"><span style="font-style:italic">b</span></span>, where 
<span style="font-weight:bold"><span style="font-style:italic">x</span></span>∈ℤ<sub>+</sub><sup>8</sup> and 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">  <span style="font-weight:bold"><span style="font-style:italic">A</span></span>=</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >  22</td><td style="text-align:center;white-space:nowrap" >13</td><td style="text-align:center;white-space:nowrap" >26</td><td style="text-align:center;white-space:nowrap" >33</td><td style="text-align:center;white-space:nowrap" >21</td><td style="text-align:center;white-space:nowrap" >3</td><td style="text-align:center;white-space:nowrap" >14</td><td style="text-align:center;white-space:nowrap" >26 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >  39</td><td style="text-align:center;white-space:nowrap" >16</td><td style="text-align:center;white-space:nowrap" >22</td><td style="text-align:center;white-space:nowrap" >28</td><td style="text-align:center;white-space:nowrap" >26</td><td style="text-align:center;white-space:nowrap" >30</td><td style="text-align:center;white-space:nowrap" >23</td><td style="text-align:center;white-space:nowrap" >24 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >  18</td><td style="text-align:center;white-space:nowrap" >14</td><td style="text-align:center;white-space:nowrap" >29</td><td style="text-align:center;white-space:nowrap" >27</td><td style="text-align:center;white-space:nowrap" >30</td><td style="text-align:center;white-space:nowrap" >38</td><td style="text-align:center;white-space:nowrap" >26</td><td style="text-align:center;white-space:nowrap" >26 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >  41</td><td style="text-align:center;white-space:nowrap" >26</td><td style="text-align:center;white-space:nowrap" >28</td><td style="text-align:center;white-space:nowrap" >36</td><td style="text-align:center;white-space:nowrap" >18</td><td style="text-align:center;white-space:nowrap" >38</td><td style="text-align:center;white-space:nowrap" >16</td><td style="text-align:center;white-space:nowrap" >26
</td></tr>
</table></td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎥<br>
⎦</td></tr>
</table></td><td class="dcell">,
  
<span style="font-weight:bold"><span style="font-style:italic">b</span></span>=</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >  7872 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >10466 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >11322 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >12058 
</td></tr>
</table></td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎥<br>
⎦</td></tr>
</table></td><td class="dcell">,
  
<span style="font-weight:bold"><span style="font-style:italic">c</span></span>=</td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎢<br>
⎢<br>
⎢<br>
⎢<br>
⎢<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >  2 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >10 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >13 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >17 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >7 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >5 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >7 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >3
</td></tr>
</table></td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎥<br>
⎥<br>
⎥<br>
⎥<br>
⎥<br>
⎥<br>
⎥<br>
⎦</td></tr>
</table></td><td class="dcell">. 
</td></tr>
</table><p>
When using the default settings, about 24000 subproblems need to be
examined before an optimal solution is found. When
<span style="font-family:monospace">lp_nodeselect</span> is set to <span style="font-family:monospace">lp_breadthfirst</span> the solver
needs to examine only about 20000 subproblems, but when set to
<span style="font-family:monospace">lp_hybrid</span> (a strategy which in general performs better) it
examines about 111000 nodes in total.</p>
<h5 id="sec682" class="paragraph">Cutting planes.</h5>
<p>Strong Gomory mixed integer cuts are generated at every node of the
branch and bound tree and used to improve the objective value bound. 
After solving the relaxed subproblem with the
simplex method, at most one strong cut is generated and added to the
subproblem which is subsequently reoptimized. Simplex reoptimizations
are fast because they start with the last feasible basis, but applying
cuts makes the simplex tableau larger, hence applying many of them may
actually slow the computation down. To limit the number of cuts that
can be applied to a subproblem, you can use <span style="font-family:monospace">lp_maxcuts</span>
option, setting it either to zero (which disables cut generation
altogether) or to some positive integer. Also, you may set it to
<span style="font-family:monospace">+infinity</span>, which means that any number of cuts may be applied
to any node. By default, <span style="font-family:monospace">lp_maxcuts</span> equals to 5.</p>
<h5 id="sec683" class="paragraph">Displaying detailed output.</h5>
<p>By typing <span style="font-family:monospace">lp_verbose=true</span> or simply <span style="font-family:monospace">lp_verbose</span> when
specifying options for <span style="font-family:monospace">lpsolve</span>, detailed messages are printed
during and after solving an MIP problem. During the branch and bound algorithm
a status report in form
</p><div class="center">
<span style="font-style:italic">n</span><span style="font-family:monospace">: </span><span style="font-style:italic">m</span><span style="font-family:monospace"> nodes active, lower bound: </span><span style="font-style:italic">lb</span> ⟨<span style="font-family:monospace"> integrality gap: </span><span style="font-style:italic">g</span>⟩
</div><p>
is displayed every 5 seconds, where <span style="font-style:italic">n</span> is the number of
already examined subproblems. Also, a report is printed every time
the incumbent solution is found or updated, as well as when the solver
switches to pseudocost-based branching. After the algorithm is
finished, i.e. when an optimal solution is found, a summary is displayed
containing the total number of examined subproblems, the number of
most nodes being active at the same time and the number of applied
Gomory mixed integer cuts. </p><p>In the following example, two nonnegative integers <span style="font-style:italic">x</span><sub>1</sub> and <span style="font-style:italic">x</span><sub>2</sub>
are found such that 1867 <span style="font-style:italic">x</span><sub>1</sub>+1913 <span style="font-style:italic">x</span><sub>2</sub>=3618894 and <span style="font-style:italic">x</span><sub>1</sub>+<span style="font-style:italic">x</span><sub>2</sub> is
minimal. The solver shows all progress and summary messages.</p><p><br>
</p><p><span style="font-weight:bold">Example.</span><br>
<span style="font-style:italic">Input:</span>
</p><div class="center">
<span style="font-family:monospace">lpsolve(x1+x2,[1867*x1+1913*x2=3618894],assume=nonnegint,lp_verbose=true)</span>
</div><p>
<span style="font-style:italic">Output:</span>
</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><code>Optimizing...</code></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code>Applying branch&amp;bound method to find integer feasible solutions...</code></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code>    3937: Incumbent solution found</code></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code>Summary:</code></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code> * 3938 subproblem(s) examined</code></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code> * max. tree size: 1 nodes</code></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code> * 0 Gomory cut(s) applied</code>
</td></tr>
</table>
</div><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎣</td><td class="dcell">1916,</td><td class="dcell">⎡<br>
⎣</td><td class="dcell"><span style="font-style:italic">x</span><sub>1</sub>=1009,<span style="font-style:italic">x</span><sub>2</sub>=907</td><td class="dcell">⎤<br>
⎦</td><td class="dcell">⎤<br>
⎦</td></tr>
</table>
<h4 id="sec684" class="subsubsection">Solving problems in floating-point arithmetic</h4>
<p>The <span style="font-family:monospace">lpsolve</span> command provides, in addition to its own exact solver
implementing the primal simplex method with upper-bounding technique, an
interface to the GLPK (GNU Linear Programming Kit) library which contains
sophisticated LP/MIP solvers in floating-point arithmetic, designed to
be very fast and to handle large problems. Choosing between the
available solvers is done by setting <span style="font-family:monospace">lp_method</span> option.</p><p>By default, <span style="font-family:monospace">lp_method</span> is set to <span style="font-family:monospace">lp_simplex</span>, which
solves the problem using primal simplex method, but performing exact
computation only when all problem coefficients are exact. If at least
one of them is approximative (a floating-point number), the GLPK solver is
used instead (see below).</p><p>Setting <span style="font-family:monospace">lp_method</span> to <span style="font-family:monospace">exact</span> forces the solver to
perform exact computation even when some coefficients are inexact
(they are converted to rational equivalents before applying the simplex
method).</p><p>Specifying <span style="font-family:monospace">lp_method=float</span> forces <span style="font-family:monospace">lpsolve</span> to use
the floating-point solver. If a MIP problem is given, it is combined with
the branch and cut algorithm. The GLPK simplex solver parameters can be
controlled by setting the <span style="font-family:monospace">lp_timelimit</span>,
<span style="font-family:monospace">lp_gaptolerance</span> and <span style="font-family:monospace">lp_varselect</span> options. If the
latter is not set, the Driebeek–Tomlin heuristic is used by default (see
the GLPK manual for details). If <span style="font-family:monospace">lp_maxcuts</span> is greater than
zero, GMI and MIR cut generation is enabled, else it is disabled. If
the problem contains binary variables, cover and clique cut generation
is enabled, else it is disabled. Finally, <span style="font-family:monospace">lp_verbose=true</span>
enables detailed messages.</p><p>Setting <span style="font-family:monospace">lp_method</span> to <span style="font-family:monospace">lp_interiorpoint</span> uses
the primal-dual interior-point algorithm which is part of GLPK. The only
parameter that can be controlled via options is the verbosity level.</p><p>For example, try to solve the following LP problem using the default
settings.
</p><div class="center">
	Minimize  1.06 <span style="font-style:italic">x</span><sub>1</sub>+0.56 <span style="font-style:italic">x</span><sub>2</sub>+3.0 <span style="font-style:italic">x</span><sub>3</sub>	
</div><p>
subject to
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >1.06 <span style="font-style:italic">x</span>1+0.015 <span style="font-style:italic">x</span>3</td><td style="text-align:left;white-space:nowrap" >≥ 729824.87</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
0.56 <span style="font-style:italic">x</span><sub>2</sub>+0.649 <span style="font-style:italic">x</span><sub>3</sub></td><td style="text-align:left;white-space:nowrap" >≥ 1522188.03</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:italic">x</span><sub>3</sub></td><td style="text-align:left;white-space:nowrap" >≥ 1680.05</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub></td><td style="text-align:left;white-space:nowrap" >≥ 0  for <span style="font-style:italic">k</span>=1,2,3
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table><p>
<span style="font-style:italic">Input:</span>
</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">lpsolve(1.06x1+0.56x2+3x3,</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">  [1.06x1+0.015x3&gt;=729824.87,0.56x2+0.649x3&gt;=1522188.03,x3&gt;=1680.05],</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">  assume=lp_nonnegative)</span>
</td></tr>
</table>
</div><p>
<span style="font-style:italic">Output:</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎣</td><td class="dcell">2255937.4968,</td><td class="dcell">⎡<br>
⎣</td><td class="dcell"><span style="font-style:italic">x</span><sub>1</sub>=688490.254009,<span style="font-style:italic">x</span><sub>2</sub>=2716245.85277,<span style="font-style:italic">x</span><sub>3</sub>=1680.05</td><td class="dcell">⎤<br>
⎦</td><td class="dcell">⎤<br>
⎦</td></tr>
</table><p>
If <span style="font-family:monospace">assume=nonnegint</span> is used for the same problem, 
i.e. when <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>∈ℤ<sub>+</sub> for <span style="font-style:italic">k</span>=1,2,3, the following result is
obtained by GLPK MIP solver: 
<span style="font-style:italic">Input:</span>
</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">lpsolve(1.06x1+0.56x2+3x3,</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">  [1.06x1+0.015x3&gt;=729824.87,0.56x2+0.649x3&gt;=1522188.03,x3&gt;=1680.05],</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">  assume=nonnegint)</span>
</td></tr>
</table>
</div><p>
<span style="font-style:italic">Output:</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎣</td><td class="dcell">2255940.66,</td><td class="dcell">⎡<br>
⎣</td><td class="dcell"><span style="font-style:italic">x</span><sub>1</sub>=688491.0,<span style="font-style:italic">x</span><sub>2</sub>=2716245.0,<span style="font-style:italic">x</span><sub>3</sub>=1681.0</td><td class="dcell">⎤<br>
⎦</td><td class="dcell">⎤<br>
⎦</td></tr>
</table><p>
The solution of the original problem can also be obtained with
the interior-point solver by including
<span style="font-family:monospace">lp_method=lp_interiorpoint</span> after
<span style="font-family:monospace">assume=lp_nonnegative</span>: 
<span style="font-style:italic">Input:</span>
</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">lpsolve(1.06x1+0.56x2+3x3,</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">  [1.06x1+0.015x3&gt;=729824.87,0.56x2+0.649x3&gt;=1522188.03,x3&gt;=1680.05],</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">  assume=lp_nonnegative,lp_method=lp_interiorpoint)</span>
</td></tr>
</table>
</div><p>
<span style="font-style:italic">Output:</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎣</td><td class="dcell">2255937.50731,</td><td class="dcell">⎡<br>
⎣</td><td class="dcell"><span style="font-style:italic">x</span><sub>1</sub>=688490.256652,<span style="font-style:italic">x</span><sub>2</sub>=2716245.85608,<span style="font-style:italic">x</span><sub>3</sub>=1680.05195065</td><td class="dcell">⎤<br>
⎦</td><td class="dcell">⎤<br>
⎦</td></tr>
</table>
<h4 id="sec685" class="subsubsection">Loading a problem from a file</h4>
<p>Linear (integer) programming problems can be loaded from MPS or CPLEX
LP format files (these formats are described in GLPK manual,
Appendices B and C). The file name should be a string passed as
the <span style="font-style:italic">obj</span> parameter. If the file name has extension “lp”, CPLEX
LP format is assumed, and if the extension is “mps” or “gz”, MPS
or gzipped MPS format is assumed.</p><p>For example, assume that <span style="font-family:monospace">somefile.lp</span> file is stored in
directory <span style="font-family:monospace">/path/to/file</span> and contains the following lines of text:
</p><pre class="verbatim">\* Problem: short *\

Maximize
 obj: + 0.6 x1 + 0.5 x2

Subject To
 c1: + x1 + 2 x2 &lt;= 1
 c2: + 3 x1 + x2 &lt;= 2

Bounds
 x1 free
 x2 free

End
</pre><p>
To find an optimal solution to the linear program specified in this file,
you just needs to enter:<br>
<span style="font-style:italic">Input:</span>
</p><div class="center">
	<span style="font-family:monospace">lpsolve("/path/to/file/somefile.lp")</span>
</div><p>
<span style="font-style:italic">Output:</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell">0, </td><td class="dcell">⎡<br>
⎢<br>
⎢<br>
⎣</td><td class="dcell"><span style="font-style:italic">x</span><sub>1</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">3</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">,<span style="font-style:italic">x</span><sub>2</sub>=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td><td class="dcell">⎤<br>
⎥<br>
⎥<br>
⎦</td></tr>
</table><p>
You can provide additional variable bounds and options alongside the
file name. Note that the original constraints (those which are read
from file) cannot be removed.<br>
<span style="font-style:italic">Input:</span>
</p><div class="center">
<span style="font-family:monospace">lpsolve("/path/to/file/somefile.lp",assume=integer)</span>
</div><p>
<span style="font-style:italic">Output:</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">⎡<br>
⎣</td><td class="dcell">0, </td><td class="dcell">⎡<br>
⎣</td><td class="dcell"><span style="font-style:italic">x</span><sub>1</sub>=1,<span style="font-style:italic">x</span><sub>2</sub>=−1</td><td class="dcell">⎤<br>
⎦</td><td class="dcell">⎤<br>
⎦</td></tr>
</table><p>It is advisable to use only (capital) letters, digits and underscores
when naming variables in an LP file, although the corresponding format
allows many more characters. That is because these names are converted
to Giac identifiers during the loading process.</p><p><br>
</p><p><span style="font-weight:bold">Warning!</span> Problems that are too large won’t be loaded. More precisely,
those with  <span style="font-style:italic">n</span><sub><span style="font-style:italic">v</span></sub>· <span style="font-style:italic">n</span><sub><span style="font-style:italic">c</span></sub>&gt;10<sup>5</sup>, where <span style="font-style:italic">n</span><sub><span style="font-style:italic">v</span></sub> is the number of variables and <span style="font-style:italic">n</span><sub><span style="font-style:italic">c</span></sub> is
the number of constraints, won’t be loaded. </p>
<hr>
<a href="cascmd_en533.html"><img src="previous_motif.gif" alt="Previous"></a>
<a href="index.html"><img src="contents_motif.gif" alt="Up"></a>
<a href="cascmd_en535.html"><img src="next_motif.gif" alt="Next"></a>
</body>
</html>
