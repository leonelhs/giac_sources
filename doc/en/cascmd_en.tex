\documentclass[a4paper,11pt]{book}
%\textwidth 11,8 cm
%\textheight 17 cm
\textheight 23 cm
%\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{makeidx}
\usepackage{times}
%\usepackage{mathptmx}
%Uncomment next line for pdflatex and use includegraphics with eps file
% for latex2html don't use the option [width=\textwidth]
% check that xfig files are exported magnif 100%
%\usepackage[francais]{babel}
\usepackage{ifpdf}
\ifpdf
 \usepackage[pdftex,colorlinks]{hyperref}
\else
 \usepackage[ps2pdf,breaklinks=true,colorlinks=true,linkcolor=red,citecolor=green]{hyperref}
 \usepackage{pst-plot}
\fi

%\def\@evenhead{\thepage\hfill{\footnotesize\textit{\leftmark}}}
%\def\@oddhead{\footnotesize{\textit{\rightmark}}\hfill\thepage}
%\usepackage{hp}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage[francais]{babel}
\usepackage{latexsym}

\newcommand{\R}{{\mathbb{R}}}
\newcommand{\C}{{\mathbb{C}}}
\newcommand{\Z}{{\mathbb{Z}}}
\newcommand{\N}{{\mathbb{N}}}

%\usepackage[pdftex]{hyperref}
\title {Symbolic algebra and Mathematics with {\tt Xcas}}
\author{Ren\'ee De Graeve, Bernard Parisse\\ 
University of Grenoble I}
\date{}
\makeindex
\usepackage{cutting}
\begin{document}
\newcommand{\asinh}{\,\,\mbox{asinh\,}}
\newcommand{\atanh}{\,\,\mbox{atanh\,}}
\maketitle
% {\bf \centerline{Remerciements}}

% \vspace{1cm}

% Je  remercie:
%  \begin{itemize}
% \item Bernard Parisse for ses pr\'ecieux conseils andses remarques sur ce texte,

%  \end{itemize}

\vfill


\copyright\ 2002, 2007 Ren\'ee De Graeve, Bernard Parisse\\
\verb|renee.degraeve@wanadoo.fr|\\
\verb|bernard.parisse@ujf-grenoble.fr|\\



\newpage
\tableofcontents

\chapter{Index}
\printindex

\chapter{The CAS functions}\label{sec:cas}

\section{Symbolic constants : {\tt e pi infinity i}}\index{e}\index{pi}
\index{i}\index{+infinity}\index{-infinity}\index{infinity}
\noindent {\tt e} is the number $\exp(1)$;\\ 
{\tt pi} is the number $\pi$.\\
{\tt infinity} is unsigned $\infty$.\\
{\tt +infinity} is $+\infty$.\\
{\tt -infinity} is $-\infty$.\\
{\tt i} is the complex number $i$.

\section{Booleans}
\subsection{The values of a boolean : {\tt true false}}\index{true}\index{false}\index{TRUE}\index{FALSE}
The value of a boolean is {\tt true} or {\tt false}.\\
The synonyms are :\\
{\tt true} or {\tt TRUE} or {\tt 1},\\
{\tt false} or {\tt FALSE} or {\tt 0}.\\
Tests or conditions are boolean functions.

\subsection{Tests : {\tt ==, !=, >, >=, <, =<}}\index{==}\index{>}\index{<}\index{>=}\index{<=}\index{\symbol{33}=}
{\tt ==, !=, >, >=, <, =<} are infixed operators.\\
{\tt a==b} tests the equality between {\tt a} and {\tt b} and returns {\tt 1} 
if {\tt a} is equal to {\tt b} and {\tt 0} otherwise.\\ 
{\tt a!=b} returns {\tt 1} if {\tt a} and {\tt b} are different and {\tt 0} 
otherwise.\\
 {\tt a>=b} returns {\tt 1} if {\tt a} is superior or equal to {\tt b} 
and {\tt 0} otherwise.\\ 
{\tt a>b} returns {\tt 1} if {\tt a} is strictly superior to {\tt b}
and {\tt 0} otherwise.\\ 
{\tt a<=b} returns {\tt 1} if {\tt a} is inferior or equal to {\tt b} and 
{\tt 0} otherwise.\\
{\tt a<b} returns {\tt 1} if {\tt a} is strictly inferior to {\tt b} 
and {\tt 0} otherwise.\\ 
To write an algebraic function having the same result as an 
{\tt if...then...else}, we use the boolean function {\tt ifte}.\\
For example :  
\begin{center}{\tt f(x):=ifte(x>0,true,false)}\end{center}
defines the boolean function $f$ such that {\tt f(x)= true} if 
$x \in ]0;+\infty[$ and {\tt f(x)=false} if $x \in ]-\infty;0]$.\\
Input :
\begin{center}{\tt f(0)==0}\end{center}
Output :
\begin{center}{\tt 1}\end{center}
{\bf Look out !}\\
{\tt a=b}  is not a boolean !!!!\\
{\tt a==b} is a boolean.\\

\subsection{Boolean operators  : {\tt or xor and not}}\index{or|textbf}\index{not|textbf}\index{and|textbf}\index{$\bigparallel$}\index{\&\&|textbf}\index{\symbol{33}=|textbf}\index{xor|textbf}
{\tt or} (or {\tt ||}), {\tt xor}, {\tt and} (or {\tt \&\&})  are infixed 
operators.\\
{\tt not} is a prefixed operators.\\ 
If {\tt a} and {\tt b} are two booleans :\\
{\tt (a or b)}  {\tt (a || b)} returns  {\tt 0} (or {\tt false}) if {\tt a} and
{\tt b} are equal to 0  and returns {\tt 1} (or {\tt true}) otherwise.\\ 
{\tt (a xor b)}   returns {\tt 1} if {\tt a} is equal to 1 and {\tt b} is
equal to 0 or if {\tt a} is equal to 0 and {\tt b} is equal to 1  and  returns 0
 if {\tt a} and {\tt b} are equal to 0
 or if  {\tt a} and {\tt b}  are equal to 1 (it is the "exclusive or").\\ 
{\tt (a and b)} or {\tt (a \&\& b)}  returns {\tt 1} (or {\tt true}) if {\tt a}
 and {\tt b}  are equal to 1 and {\tt 0} (or {\tt false})  otherwise.\\
{\tt not(a)} returns {\tt 1} (or {\tt true}) if {\tt a}  is equal to 0 (or 
{\tt false}), and {\tt 0} (or {\tt false})  if {\tt a}  is equal to 1 (or 
{\tt true}).\\ 
Input :
\begin{center}{\tt 1>=0 or 1<0}\end{center}
Output :
\begin{center}{\tt 1}\end{center}
Input :
\begin{center}{\tt 1>=0 xor 1>0}\end{center}
Output :
\begin{center}{\tt 0}\end{center}
Input :
\begin{center}{\tt 1>=0 and 1>0}\end{center}
Output :
\begin{center}{\tt 1}\end{center}
Input :
\begin{center}{\tt not(0==0)}\end{center}
Output :
\begin{center}{\tt 0}\end{center}

\subsection{Transform a boolean expression as a list : {\tt exp2list}}\index{exp2list}
\noindent{\tt exp2list} returns the list {\tt [expr0,expr1]} when the argument 
is {\tt (var=expr0) or (var=expr1)}.\\
{\tt exp2list} is used in TI mode for easier processing of the answer of a
{\tt solve} command.\\
Input :
\begin{center}{\tt exp2list((x=2) or (x=0))}\end{center}
Output :
\begin{center}{\tt [2,0]}\end{center}
Input :
\begin{center}{\tt exp2list((x>0) or (x<2))}\end{center}
Output :
\begin{center}{\tt [0,2]}\end{center}
In TI mode input :
\begin{center}{\tt exp2list(solve((x-1)*(x-2)))}\end{center}
Output :
\begin{center}{\tt [1,2]}\end{center}

\subsection{Evaluate booleans : {\tt evalb}}\index{evalb}
\noindent Inside Maple, {\tt evalb} evaluates an boolean expression.
Since {\tt Xcas} evaluates booleans automatically, {\tt evalb} is only
here for compatibility and is equivalent to {\tt eval}\\
Input :
\begin{center}{\tt evalb(sqrt(2)>1.41)}\end{center}
Or :
\begin{center}{\tt sqrt(2)>1.41}\end{center}
Output :
\begin{center}{\tt 1}\end{center}
Input :
\begin{center}{\tt evalb(sqrt(2)>1.42)}\end{center}
Or :
\begin{center}{\tt sqrt(2)>1.42}\end{center}
Output :
\begin{center}{\tt 0}\end{center}

\section{Operators bit to bit}
\subsection{Operators {\tt bitor, bitxor, bitand}}\index{bitor|textbf}\index{bitxor|textbf}\index{bitand|textbf}
The integers may be written using hexadecimal notation 0x...
for example 0x1f represents 16+15=31 in decimal writting. 
Integers may also be outputted in hexadecimal notation 
(click on the red CAS status button and select {\tt Base (Integers)}).\\
{\tt bitor} is the logical inclusive {\tt or} (bit to bit).\\
Input :
\begin{center}{\tt bitor(0x12,0x38)}\end{center}
or :
\begin{center}{\tt bitor(18,56)}\end{center}
Output :
\begin{center}{\tt 58}\end{center}
because :\\
{\tt 18} is written {\tt 0x12} in base 16 or {\tt 0b010010} in base 2,\\
{\tt 56} is written {\tt 0x38} in base 16 or {\tt 0b111000} in base 2,\\
hence {\tt bitor(18,56)} is {\tt 0b111010} in base 2 and so is equal to 
{\tt 58}.\\

{\tt bitxor} is the logical exclusive {\tt or} (bit to bit).\\
Input :
\begin{center}{\tt bitxor(0x12,0x38)}\end{center}
or input :
\begin{center}{\tt bitxor(18,56)}\end{center}
Output :
\begin{center}{\tt 42}\end{center}
because :\\
{\tt 18} is written {\tt 0x12} in base 16 and {\tt 0b010010} in base 2,\\
{\tt 56} is written {\tt 0x38} in base 16 and {\tt 0b111000} in base 2,\\
{\tt bitxor(18,56)} is written {\tt 0b101010} en base 2 and so, is equal to 
{\tt 42}.\\

{\tt bitand} is the logical {\tt and} (bit to bit).\\
Input :
\begin{center}{\tt bitand(0x12,0x38)}\end{center}
or input : 
\begin{center}{\tt bitand(18,56)}\end{center}
Output :
\begin{center}{\tt 16}\end{center}
because :\\
{\tt 18} is written {\tt 0x12} in base 16 and {\tt 0b010010} in base 2,\\
{\tt 56} is written {\tt 0x38} in base 16 and {\tt 0b111000} in base 2,\\
{\tt bitand(18,56)} is written {\tt 0b010000} in base 2 and so is equal to
{\tt 16}.

\subsection{Hamming distance bit to bit : {\tt hamdist}}\index{hamdist|textbf}
The Hamming distance is the number of differences
of the bits of the two arguments.\\
Input :
\begin{center}{\tt hamdist(0x12,0x38)}\end{center}
or input 
\begin{center}{\tt ha
  \item mdist(18,56)}\end{center}
Output :
\begin{center}{\tt 3}\end{center}
because :\\
{\tt 18}  is written {\tt 0x12} in base 16 and {\tt 0b010010} in base 2,\\
{\tt 56}  is written {\tt 0x38} in base 16 and {\tt 0b111000} in base 2,\\
{\tt hamdist(18,56)} is equal to {\tt 1+0+1+0+1+0} and so is equal to {\tt 3}.

\section{Strings}
\subsection{Character and string : {\tt "}}\index{\symbol{34}|textbf}
\noindent {\tt "} is used to delimit a string.
A character is a string of length one.\\
Do not confuse {\tt "} with
{\tt '} (or {\tt quote}) which is used to avoid evaluation
of an expression \index{quote}. For example,
{\tt "a"} returns a string of one character 
but {\tt 'a'} or {\tt quote(a)} returns
the variable {\tt a} unevaluated.\\

When a string is input in a command line, it is evaluated to itself
hence the output is the same string. Use {\tt +}
to concatenate two strings or a string and another object.\\
Example :\\
Input :
\begin{center}{\tt "Hello"}\end{center}
{\tt "Hello"} is the input and also the output.\\
Input :
\begin{center}{\tt "Hello"+", how are you?"}\end{center}
Output :
\begin{center}{\tt "Hello, how are you?"}\end{center}
The index notation is used to get the n-th character of a string, 
(as for lists). Indices begin at 0 in Xcas mode, 1 in other modes.\\
Example :\\
Input :
\begin{center}{\tt "Hello"[1]}\end{center}
Output :
\begin{center}{\tt "e"}\end{center}

\subsection{First character, middle and end of a string : {\tt head mid tail}}\index{head|textbf} \index{tail|textbf}\index{mid}
\begin{itemize}
\item  {\tt head(s)} returns the first character of the string {\tt s}.\\ 
 Input :
\begin{center}{\tt head("Hello")}\end{center}
Output :
\begin{center}{\tt "H"}\end{center}
\item {\tt mid(s,p,q)} returns the part of size {\tt q} of the string {\tt s} 
begining at the character of index {\tt p}.\\
Remember that the first index is 0 in Xcas mode.\\
Input :
\begin{center}{\tt mid("Hello",1,3)}\end{center}
Output :
\begin{center}{\tt "ell"}\end{center}
\item {\tt tail(s)} returns the string  {\tt s} without its first character.\\ 
Input :
\begin{center}{\tt tail("Hello")}\end{center}
Output :
\begin{center}{\tt "ello"}\end{center}
\end{itemize}

\subsection{Concatenation of a sequence of words : {\tt cumSum}}\index{cumSum}
\noindent{\tt cumSum} works on strings like on expressions by
doing partial concatenation.\\
{\tt cumSum} takes as argument a list of strings.\\
{\tt cumSum} returns a list of strings where the element of index $k$ is the
concatenation of the string  of index $k$, with the strings of indices 
0 to $k-1$ .\\
 Input :
\begin{center}{\tt cumSum("Hello, ","is ","that ","you?")}\end{center}
Output :
\begin{center}{\tt "Hello, ","Hello, is ","Hello, is that ","Hello, is that you?}\end{center}

\subsection{ASCII code of a character : {\tt ord}}\index{ord|textbf}
\noindent {\tt ord} takes as argument a string {\tt s} (resp. 
a list {\tt l} of 
strings).\\
{\tt ord} returns the ASCII code of the first character of {\tt s} (resp the 
list of the ASCII codes of the first character of the elements of {\tt l}).\\
Input :
\begin{center}{\tt ord("a")}\end{center}
Output :
\begin{center}{\tt 97}\end{center}
Input :
\begin{center}{\tt ord("abcd")}\end{center}
Output :
\begin{center}{\tt 97}\end{center} 
Input :
\begin{center}{\tt ord(["abcd","cde"])}\end{center}
Output :
\begin{center}{\tt [97,99]}\end{center} 
Input :
\begin{center}{\tt ord(["a","b","c","d"])}\end{center}
Output :
\begin{center}{\tt [97,98,99,100]}\end{center} 

\subsection{ASCII code of a string : {\tt asc}}\index{asc}
\noindent {\tt asc} takes as argument a string {\tt s}.
{\tt asc} returns the list of the ASCII codes of the characters of {\tt s}.\\
Input :
\begin{center}{\tt asc("abcd")}\end{center}
Output :
\begin{center}{\tt [97,98,99,100]}\end{center} 
Input :
\begin{center}{\tt asc("a")}\end{center}
Output :
\begin{center}{\tt [97]}\end{center}

\subsection{String defined by the ASCII codes of its characters : {\tt char}}\index{char}
\noindent {\tt char} takes as argument a list {\tt l} of ASCII codes.\\ 
{\tt char} returns the string whose characters have as ASCII codes the 
elements of the list {\tt l}.\\
Input :
\begin{center}{\tt char([97,98,99,100])}\end{center}
Output :
\begin{center}{\tt "abcd"}\end{center} 
Input :
\begin{center}{\tt char(97)}\end{center}
Output :
\begin{center}{\tt "a"}\end{center}
Input :
\begin{center}{\tt char(353)}\end{center}
Output :
\begin{center}{\tt "a"}\end{center}
En effet 353-256=97.

\subsection{Find a character in a string : {\tt inString}}\index{inString}
\noindent {\tt inString} takes two arguments : a string {\tt S} and a 
character {\tt c}.\\
{\tt inString} tests if the character {\tt c} is in the string {\tt S}.\\
 {\tt inString} returns {\tt "the index of its first occurence"}
or {\tt -1} if {\tt c} is not in {\tt S}.\\
Input :
\begin{center}{\tt inString("abcded","d")}\end{center}
Output :
\begin{center}{\tt  3}\end{center}
Input :
\begin{center}{\tt inString("abcd","e")}\end{center}
Output :
\begin{center}{\tt  -1}\end{center}

\subsection{Concat objects into a string : {\tt cat}}\index{cat|textbf}
\noindent {\tt cat} takes as argument a sequence of objects.\\ 
{\tt cat} concat these objects into a string.\\
Input :
\begin{center}{\tt cat("abcd",3,"d")}\end{center}
Output :
\begin{center}{\tt  "abcd3d"}\end{center}
Input :
\begin{center}{\tt c:=5}\end{center}
\begin{center}{\tt cat("abcd",c,"e")}\end{center}
Output :
\begin{center}{\tt  "abcd5e"}\end{center}
Input :
\begin{center}{\tt purge(c)}\end{center}
\begin{center}{\tt cat(15,c,3)}\end{center}
Output :
\begin{center}{\tt  "15c3"}\end{center}

\subsection{Add an object to a string : {\tt +}}\index{+}
\noindent {\tt +} is an infixed operator (resp {\tt '+'} is a prefixed 
operator.\\
If  {\tt +} (resp  {\tt '+'}) takes as argument a string (resp.
a sequence of objects with a string as first or second argument), 
the result is the concatenation of these objects into a string.\\
{\bf warning}\\
{\tt +} is infixed and {\tt '+'} is prefixed.\\ 
Input :
\begin{center}{\tt '+'("abcd",3,"d")}\end{center}
Ou on tape :
\begin{center}{\tt "abcd"+3+"d"}\end{center}
Output :
\begin{center}{\tt  "abcd3d"}\end{center}
Input :
\begin{center}{\tt c:=5}\end{center}
Then input:
\begin{center}{\tt "abcd"+c+"e"}\end{center}
Or input:
\begin{center}{\tt '+'("abcd",c,"d")}\end{center}
Output :
\begin{center}{\tt  "abcd5e"}\end{center}

\subsection{Transform an integer into a string : {\tt cat +}}\index{+}\index{cat}
\noindent Use {\tt cat} with the integer as argument, or add the integer
to an empty string\\
Input :
\begin{center}{\tt ""+123}\end{center}
Or :
\begin{center}{\tt cat(123)}\end{center}
Output :
\begin{center}{\tt  "123"}\end{center}

\subsection{Transform a string into a number : {\tt expr}}\index{expr|textbf}\label{sec:expr1}
Use {\tt expr}, the parser with a string representing a number.
\begin{itemize}
\item For integers, enter the string representing the integer without
leading 0 for basis 10, with prefix {\tt 0x} for basis 16,
{\tt 0} for basis 8 or {\tt 0b} for basis 2.
Input :
\begin{center}{\tt expr("123")}\end{center}
Output :
\begin{center}{\tt  123}\end{center}
Input :
\begin{center}{\tt expr("0123")}\end{center}
Output :
\begin{center}{\tt  83}\end{center}
Because : $1*8^2+2*8+3=83$
Input :
\begin{center}{\tt expr("0x12f")}\end{center}
Output :
\begin{center}{\tt 303}\end{center}
Because : $1*16^2+2*16+15=303$
\item For decimal numbers, use a string with a {\tt .} or {\tt e} inside.\\
Input :
\begin{center}{\tt expr("123.4567")}\end{center}
Output :
\begin{center}{\tt  123.4567}\end{center}
Input :
\begin{center}{\tt expr("123e-5")}\end{center}
Output :
\begin{center}{\tt 0.00123}\end{center}
\item Note that {\tt expr} more generally transforms a string 
into a command if the command exists.\\
Input :
\begin{center}{\tt expr("a:=1")}\end{center}
Output :
\begin{center}{\tt 1}\end{center}
Then, input :
\begin{center}{\tt a}\end{center}
Output :
\begin{center}{\tt 1}\end{center}
\end{itemize}

\section{Write an integer in a $b$ basis: {\tt convert}}
\label{sec:convertbase}
\index{convert}\index{base@{\sl base}|textbf}
\noindent{\tt convert} or {\tt convertir} can do different kind
of conversions depending on the option given as the second argument.

To convert an integer {\tt n} into the list of its coefficients in a 
basis {\tt b}, the option is {\tt base}. The arguments of {\tt convert} or 
{\tt convertir} are an integer {\tt n}, {\tt base} and {\tt b} the value of the
 basis.\\
{\tt convert} or {\tt convertir} returns the list of coefficients in a {\tt b} 
basis of the integer {\tt n}
Input :
\begin{center}{\tt convert(123,base,8)}\end{center}
Output :
\begin{center}{\tt [3,7,1]}\end{center}
To check the answer, 
input {\tt expr("0173")} or  {\tt horner(revlist([3,7,1]),8)}
or {\tt convert([3,7,1],base,8)} and output is {\tt 123}\\
Input :
\begin{center}{\tt convert(142,base,12)}\end{center}
Output :
\begin{center}{\tt [10,11]}\end{center}

To convert the list of coefficients in a basis {\tt b} of an integer {\tt n}, 
the option is also {\tt base}. 
{\tt convert} or {\tt convertir} returns the integer {\tt n}.\\ 
Input :
\begin{center}{\tt convert([3,7,1],base,8)}\end{center}
Or
\begin{center}{\tt horner(revlist([3,7,1]),8)}\end{center}
Output :
\begin{center}{\tt 123}\end{center}
Input :
\begin{center}{\tt convert([10,11],base,12)}\end{center}
Or
\begin{center}{\tt horner(revlist([10,11]),12)}\end{center}
Output :
\begin{center}{\tt 142}\end{center}

\section{Integers (and Gaussian Integers)}
 For all functions in this section, you can use Gaussian integers (numbers of 
the form  $a+ib$, where $a$ and $b$ in  $\mathbb Z$) in the place of integers.

\subsection{The factorial : {\tt factorial}}\index{factorial}
{\tt Xcas} can manage integers with unlimited precision, such as the 
following:\\ 
Input :
\begin{center}{\tt factorial(100)}\end{center}
Output :
\begin{verbatim}
   9332621544394415268169923885626670049071596826438162
   1468592963895217599993229915608941463976156518286253
   697920827223758251185210916864000000000000000000000000
\end{verbatim}
\subsection{GCD : {\tt gcd igcd}}\index{gcd|textbf}\index{igcd|textbf}\label{sec:igcd}
\noindent{\tt gcd} or {\tt igcd} denotes the gcd (greatest common divisor)
of several integers (for polynomials see also \ref{sec:gcd}).\\ 
{\tt gcd} or {\tt igcd} returns the {\tt GCD} of all integers.\\
Input :
\begin{center}{\tt gcd(18,15)}\end{center}
Output :
\begin{center}{\tt 3}\end{center} 
Input :
\begin{center}{\tt  gcd(18,15,21,36) }\end{center}
Output :
\begin{center}{\tt 3}\end{center}
Input :
\begin{center}{\tt  gcd([18,15,21,36])}\end{center}
Output :
\begin{center}{\tt 3}\end{center}
We can also put as parameters two lists of same size (or a matrix with 2 
lines), in this case {\tt  gcd} returns the greatest common divisor of
the elements with same index (or of the same column).
Input :
\begin{center}{\tt  gcd([6,10,12],[21,5,8])}\end{center}
or :
\begin{center}{\tt  gcd([[6,10,12],[21,5,8]])}\end{center}
Output :
\begin{center}{\tt [3,5,4]}\end{center}
{\bf An example}\\
Find the greatest common divisor of $4n+1$ and $5n+3$ when $n \in \mathbb N$.\\
Input :\\
\begin{center}{\tt  f(n):=gcd(4*n+1,5*n+3)}\end{center}
Then, input :\\
\begin{verbatim}
  essai(n):={
    local j,a,L; 
    L:=NULL;
    for (j:=-n;j<n;j++) {
      a:=f(j);
      if (a!=1) {
        L:=L,[j,a];
      } 
    }
    return L;
  }
\end{verbatim} 
Then, input :\\
\begin{center}{\tt essai(20)}\end{center}
Output :
\begin{center}{\tt [-16,7],[-9,7],[-2,7],[5,7],[12,7],[19,7]}\end{center}
So we have now to prove that :\\
if $n!=5+k*7$ (for $k \in \mathbb Z$), $4n+1$ and $5n+3$ are mutually prime,\\
and \\
if  $n=5+k*7$ (for $k \in \mathbb Z$), the greatest common divisor of  $4n+1$ 
and $5n+3$ is 7.
\subsection{GCD : {\tt Gcd}}\index{Gcd|textbf}
\noindent{\tt Gcd} is the inert form of {\tt gcd}. See the section
\ref{sec:Gcd} for polynomials with coefficients in $\Z/p\Z$ 
 for  using this instruction.\\
Input :
\begin{center}{\tt Gcd(18,15)}\end{center}
Output :
\begin{center}{\tt gcd(18,15)}\end{center}


\subsection{GCD of a list of integers : {\tt lgcd}}\index{lgcd}
\noindent{\tt lgcd} has  a list of integers (or of a list of polynomials)
as argument.\\ 
{\tt lgcd} returns the {\tt gcd} of all integers of the list (or
the {\tt gcd} of all polynomials of the list).\\
Input :
\begin{center}{\tt lgcd([18,15,21,36])}\end{center}
Output :
\begin{center}{\tt 3}\end{center} 
{\bf Remark}\\
{\tt lgcd} does not accept two lists (even if they have the same size)
as arguments.

\subsection{The least common multiple : {\tt lcm}}\index{lcm|textbf}\label{sec:ilcm}
\noindent {\tt lcm} returns the least common multiple of two integers (or of
two polynomials see also \ref{sec:lcm}).\\
Input :
\begin{center}{\tt lcm(18,15) }\end{center}
Output :
\begin{center}{\tt 90}\end{center}

\subsection{Decomposition into prime factors  : {\tt ifactor}}\index{ifactor}
\noindent{\tt ifactor} has an integer as  parameter.\\
{\tt ifactor} decomposes an integer into its prime factors.\\
Input :
\begin{center}{\tt ifactor(90) }\end{center}
Output :
\begin{center}{\tt 2*3\verb|^|2*5}\end{center}
Input :
\begin{center}{\tt ifactor(-90) }\end{center}
Output :
\begin{center}{\tt (-1)*2*3\verb|^|2*5}\end{center}

\subsection{List of prime factors : {\tt ifactors}}\index{ifactors}
\noindent{\tt ifactors} has an integer (or a list of integers) as  parameter.\\
{\tt ifactors} decomposes the integer (or the integers of the list) into prime 
factors, but the result
 is given as a list (or a list of lists) in which each prime factor is
followed by its multiplicity.\\
Input :
\begin{center}{\tt ifactors(90) }\end{center}
Output :
\begin{center}{\tt [2,1,3,2,5,1] }\end{center}
Input :
\begin{center}{\tt ifactors(-90) }\end{center}
Output :
\begin{center}{\tt [-1,1,2,1,3,2,5,1] }\end{center}
Input :
\begin{center}{\tt ifactor([36,52]) }\end{center}
Output :
\begin{center}{\tt [[2,2,3,2],[2,2,13,1]]}\end{center}
\subsection{Matrix of factors : {\tt maple\_ifactors}}\index{maple\_ifactors}
\noindent{\tt maple\_ifactors} has an integer $n$ (or a list of integers)
as parameter.\\
{\tt maple\_ifactors} decomposes the integer (or the integers of the list) into
prime factors, but the output follows the Maple syntax :\\
it is a list with +1 or -1 (for the sign) and a matrix with 2 columns and
 where the lines are the prime factors and their multiplicity (or a list of 
lists...).\\
Input :
\begin{center}{\tt maple\_ifactors(90) }\end{center}
Output :
\begin{center}{\tt [1,[[2,1],[3,2],[5,1]]]}\end{center}
Input :
\begin{center}{\tt maple\_ifactor([36,52]) }\end{center}
Output :
\begin{center}{\tt [[1,[[2,2],[3,2]]],[1,[[2,2],[13,1]]]]}\end{center}
\subsection{The divisors of a number : {\tt idivis divisors}} \index{idivis}\index{divisors}
\noindent{\tt idivis} or {\tt divisors} gives the list of the divisors of a 
number (or of a list of numbers).\\
Input :
\begin{center}{\tt idivis(36) }\end{center}
Output :
\begin{center}{\tt  [1,2,4,3,6,12,9,18,36] }\end{center}
Input :
\begin{center}{\tt idivis([36,22]) }\end{center}
Output :
\begin{center}{\tt [[1,2,4,3,6,12,9,18,36],[1,2,11,22]]}\end{center}

\subsection{The integer Euclidean quotient : {\tt iquo intDiv}}\index{iquo}\index{intDiv}
\noindent{\tt iquo} (or {\tt intDiv})  returns the integer quotient  $q$ of the
Euclidean division of two integers $a$ and $b$ given as arguments. 
($a=b*q+r$ with $0\leq r< b$).\\ 
For Gaussian integers, we choose $q$ so that $b*q$ is as near by $a$ as 
possible and it can be proved that $r$ may be choosen so that 
$|r|^2 \leq |b|^2/2$.\\
Input :
\begin{center}{\tt iquo(148,5) }\end{center}
Output :
\begin{center}{\tt 29}\end{center}
{\tt iquo} works with integers or with Gaussian integers.\\
Input :
\begin{center}{\tt iquo(factorial(148),factorial(145)+2 )}\end{center}
Output :
\begin{center}{\tt 3176375}\end{center}
Input :
\begin{center}{\tt iquo(25+12*i,5+7*i) }\end{center}
Output :
\begin{center}{\tt 3-2*i}\end{center}
Here $a-b*q=-4+i$ and $|-4+i|^2=17<|5+7*i|^2/2=74/2=37$

\subsection{The integer  Euclidean remainder : {\tt irem remain smod mods mod \%}}\index{irem}\index{remain}
\noindent{\tt irem} (or {\tt remain}) returns the integer remainder  $r$ from 
the Euclidean division of two integers $a$ and $b$ given as arguments 
($a=b*q+r$ avec $0\leq r< b$).\\
For Gaussian integers, we choose $q$ so that $b*q$ is as near by $a$ as 
possible and it can be proved that $r$ may be choosen so that 
$|r|^2 \leq |b|^2/2$.\\
Input :
\begin{center}{\tt irem(148,5) }\end{center}
Output :
\begin{center}{\tt 3}\end{center}
{\tt irem}  works with long integers or with Gaussian integers.\\
Example :
\begin{center}{\tt irem(factorial(148),factorial(45)+2 )}\end{center}
Output :
\begin{center}{\tt 111615339728229933018338917803008301992120942047239639312}\end{center}
Another example
\begin{center}{\tt irem(25+12*i,5+7*i) }\end{center}
Output :
\begin{center}{\tt -4+i}\end{center}
Here $a-b*q=-4+i$ and $|-4+i|^2=17<|5+7*i|^2/2=74/2=37$

{\tt smod} or {\tt mods}\index{smod|textbf}\index{mods|textbf} is a prefixed
function and has two integers $a$ and $b$ as arguments.\\ 
{\tt smod} or {\tt mods} returns the 
symetric remainder $s$ of the Euclidean division of the 
arguments $a$ and $b$ ($a=b*q+s$ with $-b/2<s \leq b/2$).\\
Input :
\begin{center}{\tt smod(148,5) }\end{center}
Output :
\begin{center}{\tt -2}\end{center}

{\tt mod} (or {\tt \%}) is an infixed function 
and has two integers  $a$ and $b$ 
as arguments.\\
{\tt mod} (or {\tt \%}) returns $r\% b$ of $Z/bZ$ where $r$ is the remainder of 
the Euclidean division of the arguments $a$ and $b$.\\
Input :\index{mod}\index{\%}
\begin{center}{\tt 148\ mod\ 5 }\end{center}
or
\begin{center}{\tt 148 \%  5 }\end{center}
Output :
\begin{center}{\tt 3 \% 5}\end{center}
Note that the answer {\tt 3 \% 5} is not an integer (3) but
an element of $Z/5Z$ (see \ref{sec:modulaire} to have
the possible operations in  $Z/5Z$).

\subsection{Euclidean quotient and euclidean remainder of two integers  : {\tt iquorem}}\index{iquorem}\label{sec:iquorem}
\noindent{\tt iquorem} returns the list of the quotient $q$ and the  
remainder $r$ of the Euclidean division between two integers $a$ and $b$ given
as arguments ($a=b*q+r$ with $0\leq r< b$).\\
Input :
\begin{center}{\tt iquorem(148,5) }\end{center}
Output :
\begin{center}{\tt [29,3] }\end{center}

\subsection{Test of evenness : {\tt even}}\index{even}
\noindent {\tt even} takes as argument an integer {\tt n}.\\
{\tt even} returns {\tt 1} if {\tt n} is even and  returns {\tt 0} if {\tt n} 
is odd.\\
Input :
\begin{center}{\tt even(148) }\end{center}
Output :
\begin{center}{\tt 1 }\end{center}
Input :
\begin{center}{\tt even(149) }\end{center}
Output :
\begin{center}{\tt 0}\end{center}


\subsection{Test of oddness : {\tt odd}}\index{odd}
\noindent {\tt odd} takes as argument an integer {\tt n}.\\
{\tt odd} returns {\tt 1} if {\tt n} is odd and returns {\tt 0} if {\tt n} is
even.\\
Input :
\begin{center}{\tt odd(148) }\end{center}
Output :
\begin{center}{\tt 0 }\end{center}
Input :
\begin{center}{\tt odd(149) }\end{center}
Output :
\begin{center}{\tt 1}\end{center}

\subsection{Test of pseudo-primality : {\tt is\_pseudoprime}}\index{is\_pseudoprime}
\noindent If {\tt is\_pseudoprime(n)} returns {\tt 2} (true), then
{\tt n} is prime.\\ 
If it returns 1, then {\tt n} is pseudo-prime (most
probably prime).\\
 If it returns 0, then {\tt n} is not prime. \\
{\sc Definition}: For numbers less than  $10^{14}$, pseudo-prime and prime
are equivalent. But for numbers greater than  $10^{14}$, a pseudo-prime
 is a number with a large probability of being prime (cf. Rabin's Algorithm and
Miller-Rabin's Algorithm in the Algorithmic part (menu 
{\tt Help->Manuals->Programming})).\\
Input :
\begin{center}{\tt is\_pseudoprime(100003) }\end{center}
Output :\begin{center}{\tt 2}\end{center}
Input :
\begin{center}{\tt is\_pseudoprime(9856989898997) }\end{center}
Output :
\begin{center}{\tt 2}\end{center} 
Input :
\begin{center}{\tt is\_pseudoprime(14) }\end{center}
Output :
\begin{center}{\tt 0}\end{center}
Input :
\begin{center}{\tt is\_pseudoprime(9856989898997789789) }\end{center}
Output :
\begin{center}{\tt 1}\end{center}

\subsection{Test of primality : {\tt is\_prime isprime isPrime}}\index{is\_prime}
\noindent {\tt is\_prime(n)} returns {\tt 1} (true) if {\tt n} is prime and 
{\tt 0} (false) if {\tt n} is not prime.\\
{\tt isprime} returns {\tt true} or {\tt false}.\\
Use the command {\tt pari("isprime",n,1)}
to have a primality certificat (see the documentation
 PARI/GP with the menu {\tt Aide->Manuels->PARI-GP}) and 
{\tt pari("isprime",n,2)} to use the APRCL test.

Input :
\begin{center}{\tt is\_prime(100003)}\end{center}
Output :
\begin{center}{\tt 1}\end{center}
Input :
\begin{center}{\tt isprime(100003)}\end{center}
Output :
\begin{center}{\tt true}\end{center}
Input :                    
\begin{center}{\tt is\_prime(98569898989987)}\end{center}
Output :
\begin{center}{\tt 1}\end{center} 
Input :
\begin{center}{\tt is\_prime(14)}\end{center}
Output :
\begin{center}{\tt 0}\end{center}
Input :
\begin{center}{\tt isprime(14)}\end{center}
Output :
\begin{center}{\tt false}\end{center}
Input :
\begin{center}{\tt pari("isprime",9856989898997789789,1)}\end{center}
This returns the coefficients giving the proof of primality by the 
$p-1$ Selfridge-Pocklington-Lehmer test~:
\begin{center}
{\tt [[2,2,1],[19,2,1],[941,2,1],[1873,2,1],[94907,2,1]]}
\end{center}
Input :
\begin{center}{\tt isprime(9856989898997789789)}\end{center}
Output :
\begin{center}{\tt true}\end{center}

\subsection{The smallest pseudo-prime greater than {\tt n} : {\tt nextprime}}\index{nextprime}
\noindent{\tt nextprime(n)} returns the smallest pseudo-prime (or prime)
greater than {\tt n}. \\
Input :
\begin{center}{\tt  nextprime(75) }\end{center}
Output :
\begin{center}{\tt 79}\end{center}

\subsection{The greatest pseudo-prime less than {\tt n} : {\tt prevprime}}\index{prevprime}
\noindent{\tt prevprime(n)} returns the greatest pseudo-prime (or prime) less 
than {\tt n}.\\
Input :
\begin{center}{\tt prevprime(75)}\end{center}
Output :
\begin{center}{\tt 73}\end{center}

\subsection{The {\tt n}-th prime number : {\tt ithprime}}\index{ithprime}
\noindent{\tt ithprime(n)} returns the {\tt n}-th  prime number 
less than 10000 (current limitation).\\
Input :
\begin{center}{\tt ithprime(75)}\end{center}
Output :
\begin{center}{\tt 379}\end{center}
Input :
\begin{center}{\tt ithprime(1229)}\end{center}
Output :
\begin{center}{\tt 9973}\end{center}
Input :
\begin{center}{\tt ithprime(1230)}\end{center}
Output :
\begin{center}{\tt ithprime(1230)}\end{center}
because {\tt ithprime(1230)} is greater than 10000.

\subsection{Bézout's Identity : {\tt iegcd igcdex}}\index{iegcd}\index{igcdex}
\noindent{\tt iegcd(a,b)} or  {\tt igcdex(a,b)} 
returns the coefficients of the Bézout's Identity for two integers given
as argument.\\
{\tt iegcd(a,b)}  or  {\tt igcdex(a,b)} returns {\tt [u,v,d]}  such that 
{\tt au+bv=d} and {\tt d=gcd(a,b)}.\\
Input :
\begin{center}{\tt iegcd(48,30) }\end{center}
Output :
\begin{center}{\tt [2,-3,6]}\end{center}
In other words :
$$2 \cdot 48+ (-3) \cdot 30 =6$$

\subsection{Solving au+bv=c in $\Z$: {\tt iabcuv}}\index{iabcuv}
\noindent{\tt iabcuv(a,b,c)} returns {\tt [u,v]} so that {\tt au+bv=c}.\\
{\tt c} must be a multiple of {\tt gcd(a,b)} for the existence of
a solution.\\
Input :
\begin{center}{\tt iabcuv(48,30,18) }\end{center}
Output :
\begin{center}{\tt [6,-9]}\end{center}

\subsection{Chinese remainders : {\tt ichinrem, ichrem}}\index{ichinrem}\index{ichrem}
\noindent{\tt ichinrem([a,p],[b,q])} or {\tt ichrem([a,p],[b,q])} returns a 
list {\tt [c,lcm(p,q)]} of 2 integers.\\
The first number {\tt c} is such that 
\[ \forall k \in \mathbb Z, \quad d=c+ k \times \mbox{lcm}(p,q) \]
has the properties
\[ d=a \pmod  p, \quad d=b \pmod q \]
If {\tt p} and {\tt q} are coprime, a solution {\tt d} always exists
and all the solutions are congruent modulo {\tt p*q}.\\
{\bf Examples} : \\
Solve :
$${\tt \left \{ \begin{array}{rcl} x&=&3\ (\bmod\ 5)\\ 
x&=&9\ (\bmod\ 13) \end{array}\right.}$$
Input :
\begin{center}{\tt ichinrem([3,5],[9,13])}\end{center}
or input :
\begin{center}{\tt ichrem([3,5],[9,13])}\end{center}
Output :
\begin{center}{\tt [-17,65] }\end{center}
so {\tt x=-17 (mod 65)}\\
we can also input :
\begin{center}{\tt ichrem(3\%5,9\%13)}\end{center}
Output :
\begin{center}{\tt -17\%65 }\end{center}
Solve :
$${\tt \left \{ \begin{array}{rcl} x&=&3\ (\bmod\ 5)\\ 
x&=&4\ (\bmod\ 7) \\ 
x&=&1\ (\bmod\ 9)\end{array}\right.}$$
First input :
\begin{center}{\tt tmp:=ichinrem([3,5],[4,7])}\end{center}
or input :
\begin{center}{\tt tmp:=ichrem([3,5],[4,7])}\end{center}
output :
\begin{center}{\tt [-17,35] }\end{center}
then input :
\begin{center}{\tt ichinrem([1,9],tmp)}\end{center}
or input :
\begin{center}{\tt ichrem([1,9],tmp)}\end{center}
Output :
\begin{center}{\tt [-17,315] }\end{center}
hence {\tt x=-17 (mod 315)}\\
Alternative :\\
\begin{center}{\tt ichinrem([3\%5,4\%7,1\%9])}\end{center}
Output :
\begin{center}{\tt -17\%315 }\end{center}

{\bf Remark}\\
{\tt ichrem} (or{\tt ichinrem})may be used to find coefficients of polynomial 
which class are known modulo several integers, for example find
$ax+b$ modulo $315=5 \times 7 \times 9$ under the assumptions:
$${\tt \left \{ \begin{array}{rl} a=&3\ (\bmod\ 5)\\ 
a=&4\ (\bmod\ 7) \\ 
a=&1\ (\bmod\ 9) \end{array}\right.},
\quad 
{\tt \left \{ \begin{array}{rl} b=&1\ (\bmod\ 5)\\ 
b=&2\ (\bmod\ 7) \\ 
b=&3\ (\bmod\ 9) \end{array}\right.}$$
Input :
\begin{center}{\tt ichrem((3x+1)\%5,(4x+2)\%7,(x+3)\%9)}\end{center}
Output :
\begin{center}{\tt (-17\%315$\times$ x+156\%315 }\end{center}
hence {\tt a=-17 (mod 315)} and  {\tt b=156 (mod 315)}.

\subsection{Chinese remainders for lists of integers  : {\tt chrem}}\index{chrem}
\noindent{\tt chrem} takes as argument 2 lists of integers of the same size.\\
{\tt chrem} returns a list of 2 integers.\\
For example, {\tt chrem([a,b,c],[p,q,r])} returns the list 
{\tt [x,lcm(p,q,r)]} where
{\tt x=a mod  p} and {\tt x=b mod q} and {\tt x=c mod r}.\\
A solution {\tt x} always exists if {\tt p, q, r} 
are mutually primes, and all the solutions are equal modulo {\tt p*q*r}. \\
{\sc Be carefull} with the order of the parameters, indeed :\\
{\tt chrem([a,b],[p,q])=ichrem([a,p],[b,q])=\\
ichinrem([a,p],[b,q])}\\
{\bf Examples} : \\
Solve :
$${\tt \left \{ \begin{array}{rl} x=&3\ (\bmod\ 5)\\ 
x=&9\ (\bmod\ 13) \end{array}\right.}$$
Input :
\begin{center}{\tt chrem([3,9],[5,13])}\end{center}
Output :
\begin{center}{\tt [-17,65] }\end{center}
so, {\tt x=-17 (mod 65)}\\
Solve :
$${\tt \left \{ \begin{array}{rl} x=&3\ (\bmod\ 5)\\ 
x=&4\ (\bmod\ 6) \\ 
x=&1\ (\bmod\ 9)\end{array}\right.}$$
Input :
\begin{center}{\tt chrem([3,4,1],[5,6,9])}\end{center}
Output :
\begin{center}{\tt [28,90] }\end{center}
so {\tt x=28 (mod 90)}\\
{\bf Remark}\\
{\tt chrem} may be used to find coefficients of polynomial which
class are known modulo several integers, for example find
$ax+b$ modulo $315=5 \times 7 \times 9$ under the assumptions:
$${\tt \left \{ \begin{array}{rl} a=&3\ (\bmod\ 5)\\ 
a=&4\ (\bmod\ 7) \\ 
a=&1\ (\bmod\ 9) \end{array}\right.}, \quad
{\tt \left \{ \begin{array}{rl} b=&1\ (\bmod\ 5)\\ 
b=&2\ (\bmod\ 7) \\ 
b=&3\ (\bmod\ 9) \end{array}\right.}$$
Input :
\begin{center}{\tt chrem([3x+1,4x+2,x+3],[5,7,9])}\end{center}
Output :
\begin{center}{\tt [-17x+156),315] }\end{center}
hence, {\tt a=-17 (mod 315)} et que {\tt b=156 (mod 315)}.

\subsection{Solving $a^2+b^2=p$ in $\Z$ : {\tt pa2b2}}\index{pa2b2}
\noindent{\tt pa2b2} decompose a prime integer $p$ congruent to 1 modulo 4, 
as a sum of squares : $p= a^2+b^2$.
The result is the list {\tt [a,b]}.\\
Input :
\begin{center}{\tt pa2b2(17)}\end{center}
Output :
\begin{center}{\tt [4,1] }\end{center}
indeed $17=4^2+1^2$

\subsection{The Euler indicatrix : {\tt euler phi}}\index{euler}\index{phi}
\noindent{\tt euler} (or {\tt phi}) returns the Euler indicatrix 
for a integer. \\
{\tt euler(n)} (or {\tt phi(n)}) is equal to the number of integers less 
than  {\tt n} and prime with {\tt n}. \\
Input :
\begin{center}{\tt euler(21)}\end{center}
Output :
\begin{center}{\tt 12}\end{center}
In other words
 E=\{2,4,5,7,8,10,11,13,15,16,17,19\} is the set of integers less than 21 
and coprime with 21. There are 12 members in this set, hence Cardinal(E)=12.

Euler has introduced this function to generalize the little Fermat theorem:\\
\centerline{If $a$ and $n$ are mutually prime then $a^{euler(n)}=1\ \bmod \ n$}

\subsection{Legendre symbol : {\tt legendre\_symbol}}\index{legendre\_symbol}
If $n$ is prime, we define the Legendre symbol of $a$ 
written $\left(\frac{a}{n}\right)$ by :\\
$$\left(\frac{a}{n}\right)=\left\{\begin{array}{rl}
0 & \mbox{if }a=0\ \bmod n \\
1 & \mbox{if } a \neq 0 \bmod n \mbox{ and if } a=b^2 \bmod n\\
-1 & \mbox{if } a \neq 0 \bmod n \mbox{ and if } a \neq b^2 \bmod n\\
\end{array}
\right.$$
Some properties
\begin{itemize}
\item
If $n$ is prime :
\[ a^{\frac{n-1}{2}}=\left(\frac{a}{n}\right) \bmod n \]
\item
\begin{eqnarray*}
\left(\frac{p}{q}\right).\left(\frac{q}{p}\right)
&=&(-1)^{\frac{p-1}{2}}.(-1)^{\frac{q-1}{2}}
\mbox{ if $p$ and $q$ are odd and positive} \\
\left(\frac{2}{p}\right)&=&(-1)^{\frac{p^2-1}{8}} \\
\left(\frac{-1}{p}\right)&=&(-1)^{\frac{p-1}{2}}
\end{eqnarray*}
\end{itemize}
{\tt legendre\_symbol} takes two arguments $a$ and $n$ and returns the Legendre
symbol $\left(\frac{a}{n}\right)$.\\
Input :
\begin{center}{\tt legendre\_symbol(26,17)}\end{center}
Output :
\begin{center}{\tt 1}\end{center}
Input :
\begin{center}{\tt legendre\_symbol(27,17)}\end{center}
Output :
\begin{center}{\tt -1}\end{center}
Input :
\begin{center}{\tt legendre\_symbol(34,17)}\end{center}
Output :
\begin{center}{\tt 0}\end{center}

\subsection{Jacobi symbol  : {\tt jacobi\_symbol}}\index{jacobi\_symbol}
If $n$ is not prime, the Jacobi symbol of $a$, 
denoted as $\left(\frac{a}{n}\right)$, is defined
from the Legendre symbol and from the
decomposition of $n$ into prime factors. 
Let 
\[ n=p_1^{\alpha _1}..p_k^{\alpha _k} \] 
where $p_j$ is prime and $\alpha _j$ is an integer for $j=1..k$.
The Jacobi symbol of $a$ is defined by :
\[ \left(\frac{a}{n}\right)=\left(\frac{a}{p_1}\right)^{\alpha _1}...\left(\frac{a}{p_k}\right)^{\alpha _k} \]
{\tt jacobi\_symbol} takes two arguments $a$ and $n$, and it returns the Jacobi
symbol $\left(\frac{a}{n}\right)$.\\
Input :
\begin{center}{\tt jacobi\_symbol(25,12)}\end{center}
Output :
\begin{center}{\tt 1}\end{center}
Input :
\begin{center}{\tt jacobi\_symbol(35,12)}\end{center}
Output :
\begin{center}{\tt -1}\end{center}
Input :
\begin{center}{\tt jacobi\_symbol(33,12)}\end{center}
Output :
\begin{center}{\tt 0}\end{center}

\section{Combinatory analysis}
\subsection{Factorial : {\tt factorial \ !}}\index{factorial|textbf}\index{\symbol{33}|textbf}
\noindent{\tt factorial} (prefix) or {\tt !} (postfix)
takes as argument an integer $n$.\\
{\tt factorial(n)} or {\tt n!} returns $n!$.\\
Input :
\begin{center}{\tt factorial(10)}\end{center}
or
\begin{center}{\tt 10!}\end{center}
Output :
\begin{center}{\tt 3628800}\end{center}

\subsection{Binomial coefficients : {\tt binomial comb nCr}}\index{binomial}\index{comb|textbf}\index{nCr|textbf}
\noindent{\tt comb} or {\tt nCr} or {\tt binomial} takes as argument two 
integers {\tt n} and {\tt p}.\\
{\tt comb(n,p)} or {\tt nCr(n,p)} or {\tt binomial(n,p)}  returns 
$\left(^n_p\right) =C_n^p$.\\
Input :
\begin{center}{\tt comb(5,2)}\end{center}
Output :
\begin{center}{\tt 10}\end{center}
{\bf Remark}\\
{\tt binomial} (unlike {\tt comb, nCr}) 
may have a third real argument,
in this case {\tt binomial(n,p,a)} returns 
$\left(^n_p\right) a^p(1-a)^{n-p}$.

\subsection{Arrangements : {\tt perm nPr}}\index{perm}\index{nPr}
\noindent{\tt perm} ou {\tt nPr} takes as argument two integers $n$ and $p$.\\
{\tt perm(n,p)} or {\tt nPr(n,p)} returns $A_n^p$.\\
Input :
\begin{center}{\tt perm(5,2)}\end{center}
Output :
\begin{center}{\tt 20}\end{center}

\subsection{Random integers : {\tt rand}}\index{rand}
\index{hasard}
\noindent{\tt rand} takes as argument an integer $n$ or no argument.
\begin{itemize}
\item {\tt rand(n)} returns a random integer $p$ such that $0 \leq p<n$.\\   
Input :
\begin{center}{\tt rand(10)}\end{center}
Output for example :
\begin{center}{\tt 8}\end{center}

\item {\tt rand()} returns a random integer $p$ such that $0 \leq p<2^{31}$ 
(or on 64 bits architecture $0 \leq p<2^{63}$).\\ 
Input :
\begin{center}{\tt rand()}\end{center}
Output for example :
\begin{center}{\tt 846930886}\end{center}
\end{itemize}

\section{Rationals}
\subsection{Transform a floating point number into a rational : {\tt exact \\
float2rational}}\index{float2rational|textbf}\index{exact|textbf}\index{evalf}
\noindent {\tt float2rational}  or {\tt exact} takes as argument a  
floating point number {\tt d} and returns 
a rational number {\tt q} approaching 
{\tt d} such that {\tt abs(d-q)<epsilon}. 
{\tt epsilon} is defined in the {\tt cas} configuration
({\tt Cfg} menu) or with the {\tt cas\_setup} command.\\
Input :
\begin{center}{\tt float2rational(0.3670520231)}\end{center}
Output when {\tt epsilon=1e-10}:
\begin{center}{\tt 127/346}\end{center}
% Input :
% \begin{center}{\tt 123/12+57/21}\end{center}
% Output :
% \begin{center}{\tt 363/28}\end{center}
% Then 
Input :
\begin{center}{\tt evalf(363/28)}\end{center}
Output :
\begin{center}{\tt 12.9642857143}\end{center}
Input :
\begin{center}{\tt float2rational(12.9642857143)}\end{center}
Output :
\begin{center}{\tt 363/28}\end{center}
If two representations are mixed, for example :
\begin{center}{\tt 1/2+0.7}\end{center}
the rational is converted to a float, output :
\begin{center}{\tt 1.2}\end{center} 
Input :
\begin{center}{\tt 1/2+float2rational(0.7)}\end{center}
Output :
\begin{center}{\tt 6/5}\end{center}

\subsection{Integer and fractional part : {\tt propfrac propFrac}}\index{propfrac}\index{propFrac}\label{sec:ipropfrac}
\noindent{\tt propfrac(A/B)} or {\tt propFrac(A/B)} returns 
$$q+\frac{r}{b}\ \mbox{ with } \ 0\leq r<b$$ 
if  $\displaystyle \frac{A}{B}=\frac{a}{b}$ with $\mbox{gcd}(a,b)=1$
and $a=bq+r$.\\
For rational fractions, cf. \ref{sec:propfrac}.\\
Input :
\begin{center}{\tt propfrac(42/15)}\end{center}
Output :
\begin{center}{\tt 2+4/5}\end{center}
Input :
\begin{center}{\tt  propfrac(43/12)}\end{center}
Output :
\begin{center}{\tt  3+7/12}\end{center}

\subsection{Numerator of a fraction after simplification : {\tt numer}\\
{\tt getNum}}\index{numer|textbf}\index{getNum|textbf}\label{sec:inumer}
\noindent{\tt numer} or {\tt getNum} takes as argument a fraction and returns 
the numerator of this fraction  after simplification (for rational fractions,
see \ref{sec:numer}).\\
Input :
\begin{center}{\tt  numer(42/12)}\end{center}
Or :
\begin{center}{\tt getNum(42/12)}\end{center}
Output :
\begin{center}{\tt 7}\end{center}
To avoid simplifications, the argument must
be quoted (for rational fractions see \ref{sec:getnum}).\\
Input :
\begin{center}{\tt  numer('42/12')}\end{center}
Or :
\begin{center}{\tt  getNum('42/12')}\end{center}
Output :
\begin{center}{\tt 42}\end{center}


\subsection{Denominator of a fraction after simplification : {\tt denom getDenom}}\index{denom|textbf}\index{getDenom|textbf}\label{sec:idenom}
\noindent{\tt denom} or {\tt getDenom} takes as argument a fraction and 
returns the denominator of this fraction  after simplification (for rational 
fractions see \ref{sec:denom}).\\
Input :
\begin{center}{\tt denom(42/12)}\end{center}
Or :
\begin{center}{\tt getDenom(42/12)}\end{center}
Output :
\begin{center}{\tt 2}\end{center}
To avoid simplifications, the argument must
be quoted (for rational fractions see \ref{sec:getdenom}).\\
Input :
\begin{center}{\tt denom('42/12')}\end{center}
Or :
\begin{center}{\tt getDenom('42/12')}\end{center}
Output :
\begin{center}{\tt 12}\end{center}

\subsection{Numerator and denominator of a fraction : {\tt f2nd fxnd}}\index{fxnd}\index{f2nd}\label{sec:ifxnd}
\noindent{\tt f2nd} (or {\tt fxnd}) takes as argument a fraction and returns, 
the list of the numerator and denominator of this fraction after simplification
(for rational fractions see \ref{sec:fxnd}).\\
Input :
\begin{center}{\tt  f2nd(42/12)}\end{center}
Output :
\begin{center}{\tt [7,2]}\end{center}

\subsection{Simplification of a pair of integers : {\tt simp2}}\index{simp2|textbf}\label{sec:isimp2}
\noindent{\tt simp2} takes as argument two integers or a list of two integers 
 which represent a fraction (for two polynomals see \ref{sec:simp2}).\\
{\tt simp2} returns the list of the numerator and the denominator of 
an irreducible representant of this fraction 
(i.e. after simplification).\\
Input :
\begin{center}{\tt simp2(18,15) }\end{center}
Output :
\begin{center}{\tt [6,5]}\end{center} 
Input :
\begin{center}{\tt  simp2([42,12])}\end{center}
Output :
\begin{center}{\tt [7,2]}\end{center}

\subsection{Continued fraction representation of a real : {\tt dfc}}\index{dfc}\label{sec:convertdfc}\index{confrac@{\sl confrac}|textbf}
\noindent {\tt dfc} takes as argument a real or a rational or a
floating point number {\tt a} and an integer {\tt n} 
(or a real {\tt epsilon}).\\
{\tt dfc} returns the list of the continued fraction representation 
of {\tt a} of order {\tt n} (or with precision {\tt epsilon} i.e. 
the continued fraction representation which 
approachs {\tt a} or {\tt evalf(a)} with precision 
{\tt epsilon}, by default {\tt epsilon} is the value of the {\tt epsilon} 
defined in the {\tt cas} configuration with the menu 
{\tt Cfg$\blacktriangleright$Cas Configuration}).\\ 
{\tt convert} with the option {\tt confrac} has a similar
functionnality: in that case
the value of {\tt epsilon} is the value of the {\tt epsilon} 
defined in the {\tt cas} configuration with the menu 
{\tt Cfg$\blacktriangleright$Cas Configuration} (see
\ref{sec:convert})
and the answer may be stored in an optionnal third argument.
 
{\bf Remarks} 
\begin{itemize}
\item If the last element of the result is a list, the representation is 
ultimaltely periodic, and the last element is the period. It means
that the real is a root of an equation of order 2 with integer
coefficients.
\item if the last element of the result is not an integer, it 
represents a remainder $r$ ($a=a0+1/....+1/an+1/r$). Be aware
that this remainder has lost most of it's accuracy.
\end{itemize}
If  {\tt dfc(a)=[a0,a1,a2,[b0,b1]} that means :
\[
a=a0+\frac{1}{a1+\frac{1}{a2+\frac{1}{b0+\frac{1}{b1+\frac{1}{b0+...}}}}} 
\]
If {\tt dfc(a)=[a0,a1,a2,r]} that means :
\[ a=a0+\frac{1}{a1+\frac{1}{a2+\frac{1}{r}}} \]
Input :
\begin{center}{\tt dfc(sqrt(2),5)}\end{center}
Output :
\begin{center}{\tt [1,2,[2]]}\end{center} 
Input :
\begin{center}{\tt dfc(evalf(sqrt(2)),1e-9)}\end{center}
Or : 
\begin{center}{\tt dfc(sqrt(2),1e-9)}\end{center}
Output :
\begin{center}{\tt [1,2,2,2,2,2,2,2,2,2,2,2,2]}\end{center} 
Input :
\begin{center}{\tt convert(sqrt(2),confrac,'dev'}\end{center}
Output (if in the {\tt cas} configuration {\tt epsilon=1e-9}) :
\begin{center}{\tt [1,2,2,2,2,2,2,2,2,2,2,2,2]}\end{center} 
and  {\tt [1,2,2,2,2,2,2,2,2,2,2,2,2]} is stored in {\tt dev}.\\
Input :
\begin{center}{\tt dfc(9976/6961,5)}\end{center}
Output :
\begin{center}{\tt [1,2,3,4,5,43/7]}\end{center} 
Input to verify:\\
{\tt 1+1/(2+1/(3+1/(4+1/(5+7/43))))} \\
Output :\\
{\tt 9976/6961}\\
Input :
\begin{center}{\tt convert(9976/6961,confrac,'l')}\end{center}
Output (if in the {\tt cas} configuration {\tt epsilon=1e-9}) :
\begin{center}{\tt [1,2,3,4,5,6,7]}\end{center} 
and {\tt [1,2,3,4,5,6,7]} is stored in {\tt l}\\
Input :
\begin{center}{\tt dfc(pi,5)}\end{center}
Output :
\begin{center}{\tt [3,7,15,1,292,(-113*pi+355)/(33102*pi-103993)]}\end{center} 
Input :
\begin{center}{\tt dfc(evalf(pi),5)}\end{center}
Output (if floats are hardware floats, e.g. for Digits=12) :
\begin{center}{\tt [3,7,15,1,292,1.57581843574]}\end{center} 
Input :
\begin{center}{\tt dfc(evalf(pi),1e-9)}\end{center}
Or :
\begin{center}{\tt dfc(pi,1e-9)}\end{center}
Or (if in the {\tt cas} configuration {\tt epsilon=1e-9}) :
\begin{center}{\tt convert(pi,confrac,'ll')}\end{center}
Output :
\begin{center}{\tt [3,7,15,1,292]}\end{center} 

\subsection{Transform a continued fraction representation into a real : {\tt dfc2f}}\index{dfc2f}
\noindent {\tt dfc2f} takes as argument a list, a continued 
fraction representation
\begin{itemize}
\item a list of integers for a rational number 
\item a list whose last element is a list for an
ultimately periodic representation, i.e.
a quadratic number, that is a root of a second order equation with
integer coefficients.
\item or a list with a remainder $r$ as last element
 ($a=a0+1/....+1/an+1/r$).
\end{itemize}
{\tt dfc2f} returns the rational number or the quadratic number with the 
argument as continued fraction representation.\\
Input :
\begin{center}{\tt dfc2f([1,2,[2]])}\end{center}
Output :
\begin{center}{\tt 1/(1/(1+sqrt(2))+2)+1}\end{center} 
After simplification with {\tt normal} :
\begin{center}{\tt sqrt(2)}\end{center} 
Input :
\begin{center}{\tt dfc2f([1,2,3])}\end{center}
Output :
\begin{center}{\tt 10/7}\end{center} 
Input :
\begin{center}{\tt normal(dfc2f([3,3,6,[3,6]]))}\end{center}
Output :
\begin{center}{\tt sqrt(11)}\end{center} 
Input :
\begin{center}{\tt dfc2f([1,2,3,4,5,6,7])}\end{center}
Output :
\begin{center}{\tt 9976/6961}\end{center} 
Input to verify :\\
{\tt 1+1/(2+1/(3+1/(4+1/(5+1/(6+1/7)))))} \\
Output :\\
{\tt 9976/6961}\\
Input :
\begin{center}{\tt dfc2f([1,2,3,4,5,43/7])}\end{center}
Output :
\begin{center}{\tt 9976/6961}\end{center} 
Input to verify :\\
{\tt 1+1/(2+1/(3+1/(4+1/(5+7/43))))} \\
Output :\\
{\tt 9976/6961}

\subsection{The $n$-th Bernoulli number : {\tt bernoulli}}\index{bernoulli}
\noindent {\tt bernoulli} takes as argument an integer $n$.\\
{\tt bernoulli} returns the $n$-th Bernoulli number $B(n)$.\\
The Bernoulli numbers are defined by :
\[ \frac{t}{e^t-1}=\sum_{n=0}^{+\infty} \frac{B(n)}{n!}t^n \]
Bernoulli polynomials $B_k$ are defined by :
\[ B_0=1, \quad B_k{'}(x)=kB_{k-1}(x), \quad  \int_0^1B_k(x)dx=0 \]
and the relation $B(n)=B_n(0)$ holds.\\
Input :
\begin{center}{\tt bernoulli(6)}\end{center}
Output :
\begin{center}{\tt 1/42}\end{center}

\subsection{Access to PARI/GP commands: {\tt pari}}\index{pari}
\begin{itemize}
\item
{\tt pari} with a string as first argument (the  PARI command name) 
execute the corresponding PARI command with the remaining arguments. 
For example {\tt pari("weber",1+i)} executes the PARI command 
{\tt weber} with the argument {\tt 1+i}.
\item
{\tt pari} without argument exports all PARI/GP functions 
\begin{itemize}
\item with the same command name if they are not already defined inside {\tt
    Xcas}
\item with their original command name with the prefix {\tt pari\_}
\end{itemize}
For example, after calling {\tt pari()}, {\tt pari\_weber(1+i)} or
{\tt weber(1+i)} will execute the PARI command 
{\tt weber} with the argument {\tt 1+i}.
\end{itemize}

The documentation of PARI/GP is available with the menu
Help->Manuals.

\section{Real numbers}
\subsection{Eval a real at a given precision : {\tt evalf} and {\tt
    Digits}, {\tt DIGITS})}\index{evalf}\index{Digits}\index{DIGITS}
\begin{itemize}
\item A real number is an exact number and its numeric evaluation at a given
precision is a floating number represented in base 2.\\
The precision of a floating number is the number of bits of it's
mantissa, which is at least 53 (hardware float numbers, also known as {\tt
 double}). Floating numbers are displayed in base 10 with a number
of digits controlled by the user either by assigning the {\tt Digits}
variable or by modifying the Cas configuration. 
By default {\tt Digits} is equal to 12.
The number of digits displayed controls the number of bits of the
mantissa, if Digits is less than 15, 53 bits are used, if Digits is
strictly greater than 15, the number of bits is a roundoff of
Digits times the log of 10 in base 2.
\item
An expression is coerced into a floating number with the {\tt evalf} 
command. {\tt evalf} may have an optional second argument which will
be used to evaluate with a given precision.
\item
Note that if an expression contains a floating number, evaluation will try
to convert other arguments to floating point numbers in order
to coerce the whole expression to a single floating number.
\end{itemize}
Input :
\begin{center}{\tt 1+1/2}\end{center}
Output :
\begin{center}{\tt 3/2}\end{center}
Input :
\begin{center}{\tt 1.0+1/2}\end{center}
Output  :
\begin{center}{\tt 1.5}\end{center}
Input:
\begin{center}{\tt exp(pi*sqrt(20))}\end{center}
Output :
\begin{center}{\tt exp(pi*2*sqrt(5)) }\end{center}
With {\tt evalf}, input :
\begin{center}{\tt evalf(exp(pi*2*sqrt(5)))}\end{center}
Output :
\begin{center}{\tt 1263794.75367}\end{center}
Input :
\begin{center}{\tt 1.1\verb|^|{20}}\end{center}
Output :
\begin{center}{\tt 6.72749994933}\end{center}
Input :
\begin{center}{\tt sqrt(2)\verb|^|21}\end{center}
Output :
\begin{center}{\tt sqrt(2)*2\verb|^|10}\end{center}
Input for a result with 30 digits :
\begin{center}{\tt Digits:=30}\end{center}
Input for the numeric value of $e^{\pi\sqrt{163}}$:
\begin{center}{\tt evalf(exp(pi*sqrt(163)))}\end{center}
Output :
\begin{center}{\tt 0.262537412640768743999999999985e18}\end{center}
Note that {\tt Digits} is now set to 30. If you don't want to change
the value of {\tt Digits} you may input
\begin{center}{\tt evalf(exp(pi*sqrt(163)),30)}\end{center}

\subsection{Usual infixed functions on reals : {\tt +,-,*,/,\^\ }}
\index{+,-,*,/,\^\ }
\noindent {\tt +,-,*,/,\^\ } are the usual operators to do
additions, substractions, multiplications, divisions and for raising to a
power.\\
Input :
\begin{center}{\tt 3+2}\end{center}
Output :
\begin{center}{\tt 5}\end{center}
Input :
\begin{center}{\tt 3-2}\end{center}
Output :
\begin{center}{\tt 1}\end{center}
Input :
\begin{center}{\tt 3*2}\end{center}
Output :
\begin{center}{\tt 6}\end{center}
Input :
\begin{center}{\tt 3/2}\end{center}
Output :
\begin{center}{\tt 3/2}\end{center}
Input :
\begin{center}{\tt 3.2/2.1}\end{center}
Output :
\begin{center}{\tt 1.52380952381}\end{center}
Input :
\begin{center}{\tt 3\verb|^|2}\end{center}
Output :
\begin{center}{\tt 9}\end{center}
Input :
\begin{center}{\tt 3.2\verb|^|2.1}\end{center}
Output :
\begin{center}{\tt 11.5031015682}\end{center}

{\bf Remark}\\
You may use the square key or the cube key if your keyboard has one,
for example : ${\tt 3^2}$ returns 9.

{\bf Remark on non integral powers }
\begin{itemize}
\item If $x$ is not an integer, then $a^x=\exp(x \* \ln(a))$, hence 
$a^x$ is well-defined only for $a>0$ if $x$ is not rational. If $x$
is rational and $a<0$, the principal determination of the logarithm 
is used, leading to a complex number.
\item Hence be aware of the difference between $\sqrt[n]{a}$ and $a^{\frac{1}{n}}$ 
when $n$ is an odd integer.\\
For example, to draw the graph of $y=\sqrt[3]{x^3-x^2}$, input :
\begin{center}
{\tt plotfunc(ifte(x>0,(x\verb|^|3-x\verb|^|2)\verb|^|(1/3),\\
-(x\verb|^|2-x\verb|^|3)\verb|^|(1/3)),x,xstep=0.01)}
\end{center}
You might also input : \\
{\tt plotimplicit(y\verb|^|3=x\verb|^|3-x\verb|^|2)} \\
but this is much slower and much less accurate.
\end{itemize}

\subsection{Usual prefixed functions on reals : {\tt rdiv}}\index{rdiv} 
{\tt rdiv} is the prefixed form of the division function.\\
Input :
\begin{center}{\tt rdiv(3,2)}\end{center}
Output :
\begin{center}{\tt 3/2}\end{center}
Input :
\begin{center}{\tt rdiv(3.2,2.1}\end{center}
Output :
\begin{center}{\tt 1.52380952381}\end{center}

\subsection{$n$-th root : {\tt root}}\index{root}
\noindent{\tt root} takes two arguments : an integer $n$ and a number $a$.\\
{\tt root} returns the $n$-th root of $a$ (i.e. $a^{1/n}$).
If $a<0$, the $n$-th root is a complex number of argument $2\pi/n$.\\
Input :
\begin{center}{\tt root(3,2)}\end{center}
Output :
\begin{center}{\tt 2\verb|^|(1/3)}\end{center}
\noindent Input :
\begin{center}{\tt root(3,2.0)}\end{center}
Output :
\begin{center}{\tt 1.259921049892}\end{center}
Input :
\begin{center}{\tt root(3,sqrt(2))}\end{center}
Output :
\begin{center}{\tt 2\verb|^|(1/6)}\end{center}

\subsection{Error function : {\tt erf}}\index{erf}
\noindent{\tt erf} takes as argument a number $a$.\\
{\tt erf} returns the floating point value of the error function at $x=a$, 
where the error function is defined by~:
\[ \mbox{erf}(x)=\frac{2}{\sqrt{\pi}}\int_0^{x}e^{-t^2}dt \]
The normalization is choosen so that: 
\[ \mbox{erf}(+\infty)=1, \quad  \mbox{erf}(-\infty)=-1 \]
since :
\[ \int_0^{+\infty}e^{-t^2}dt=\frac{\sqrt{\pi}}{2} \]
Input :
\begin{center}{\tt erf(1)}\end{center}
Output :
\begin{center}{\tt 0.84270079295}\end{center}
Input :
\begin{center}{\tt erf(1/(sqrt(2)))*1/2+0.5}\end{center}
Output :
\begin{center}{\tt 0.841344746069}\end{center}
{\bf Remark}\\
The relation between {\tt erf} and {\tt normal\_cdf} is :\\
\[ \mbox{\tt normal\_cdf}(x)=\frac{1}{2}+\frac{1}{2}\*\mbox{\tt
  erf}(\frac{x}{\sqrt{2}}) \]
Indeed, making the change of variable $t=u*\sqrt{2}$ in 
\[ \mbox{normal\_cdf}(x)=\frac{1}{2}+\frac{1}{\sqrt{2\pi}}\int_0^{x}e^{-t^2/2}dt\]
gives~:
\[ \mbox{normal\_cdf}(x)=\frac{1}{2}+\frac{1}{\sqrt{\pi}}\int_0^{\frac{x}{\sqrt{2}}}e^{-u^2}du=\frac{1}{2}+\frac{1}{2}\*\mbox{erf}(\frac{x}{\sqrt{2}})\]
Check :\\
{\tt normal\_cdf(1)=0.841344746069}

\subsection{Complementary error function: {\tt erfc}}\index{erfc}
\noindent{\tt erfc} takes as argument a number $a$.\\
{\tt erfc} returns the value of the complementary error function at
$x=a$, this function is defined by~:
\[ \mbox{erfc}(x)=\frac{2}{\sqrt{\pi}}\int_x^{+\infty}e^{-t^2}dt=1-erf(x) \]
Hence erfc$(0)=1$, since~:
\[ \int_0^{+\infty}e^{-t^2}dt=\frac{\sqrt{\pi}}{2} \]
Input :
\begin{center}{\tt erfc(1)}\end{center}
Output :
\begin{center}{\tt 0.15729920705}\end{center}
Input :
\begin{center}{\tt 1- erfc(1/(sqrt(2)))*1/2}\end{center}
Output :
\begin{center}{\tt 0.841344746069}\end{center}
{\bf Remark}\\
The relation between {\tt erfc} and {\tt normal\_cdf} is :
\[ \mbox{\tt normal\_cdf}(x)=1-\frac{1}{2}\*\mbox{\tt erfc}
(\frac{x}{\sqrt{2}}) \]
Verification :\\
{\tt normal\_cdf(1)=0.841344746069}

\subsection{The $\Gamma$ function : {\tt Gamma}}\index{Gamma}
\noindent{\tt Gamma} takes as argument a number $a$.\\
{\tt Gamma} returns the value of the $\Gamma$ function in $a$, defined by~:
\[ \Gamma(x)=\int_0^{+\infty}e^{-t}t^{x-1}dt, \mbox{ if } x>0 \]
If $x$ is a positive integer, $\Gamma$ is computed by applying
the recurrence~:
\[ \Gamma(x+1)=x*\Gamma(x), \quad \Gamma(1)=1 \]
Hence~:
\[ \Gamma(n+1)=n! \]
Input :
\begin{center}{\tt Gamma(5)}\end{center}
Output :
\begin{center}{\tt 24}\end{center}
% Input :
% \begin{center}{\tt Gamma(1/2)}\end{center}
% Output :
% \begin{center}{\tt sqrt(pi)}\end{center}
Input :
\begin{center}{\tt Gamma(0.7)}\end{center}
Output :
\begin{center}{\tt 1.29805533265}\end{center}
Input :
\begin{center}{\tt Gamma(-0.3)}\end{center}
Output :
\begin{center}{\tt -4.32685110883}\end{center}
Indeed : {\tt Gamma(0.7)=-0.3*Gamma(-0.3)}\\
Input :
\begin{center}{\tt Gamma(-1.3)}\end{center}
Output :
\begin{center}{\tt 3.32834700679}\end{center}
Indeed {\tt Gamma(0.7)=-0.3*Gamma(-0.3)=(-0.3)*(-1.3)*Gamma(-1.3)}

\subsection{The $\beta$ function : {\tt Beta}}\index{Beta}
\noindent{\tt Beta} takes as argument two reals $a,b$.\\
{\tt Beta} returns the value of the $\beta$ function at $a,b \in
\mathbb R$, defined by~:
\[ \beta(x,y)=\int_0^1 t^{x-1} (1-t)^{y-1}
=\frac{\Gamma(x)*\Gamma(y)}{\Gamma(x+y)} \]
Remarkable values~:
\[ \beta(1,1)=1, \quad \beta(n,1)=\frac{1}{n}, \quad 
\beta(n,2)=\frac{1}{n(n+1)} \]
{\tt Beta(x,y)} is defined for $x$ and $y$ positive reals 
(to insure the convergence of the integral) and by
prolongation for $x$ and $y$ if they are not negative integers.\\
Input :
\begin{center}{\tt Beta(5,2)}\end{center}
Output :
\begin{center}{\tt 1/30}\end{center}
Input :
\begin{center}{\tt Beta(x,y)}\end{center}
Output :
\begin{center}{\tt Gamma(x)*Gamma(y)/Gamma(x+y)}\end{center}
Input :
\begin{center}{\tt Beta(5.1,2.2)}\end{center}
Output :
\begin{center}{\tt 0.0242053671402}\end{center}

\subsection{Derivatives of the DiGamma fonction : {\tt Psi}}\index{Psi}
\noindent{\tt Psi} takes as arguments a real $a$ and an integer $n$ (by 
default $n=0$).\\ 
{\tt Psi} returns the value of the $n$-th derivative of the DiGamma function 
at $x=a$, where the DiGamma fonction is the first derivative 
of $\ln(\Gamma(x))$. This function is used to evaluated sums of
rational functions having poles at integers.\\
Input :
\begin{center}{\tt Psi(3,1)}\end{center}
Output :
\begin{center}{\tt pi\verb|^|2/6-5/4}\end{center}

If {\tt n=0}, you may use {\tt Psi(a)} instead of {\tt Psi(a,0)} 
to compute the value of the DiGamma fonction at $x=a$.\\ 
Input :
\begin{center}{\tt Psi(3)}\end{center}
Output :
\begin{center}{\tt  Psi(1)+3/2}\end{center}
Input :
\begin{center}{\tt evalf(Psi(3))}\end{center}
Output :
\begin{center}{\tt  .922784335098}\end{center}

\subsection{The $\zeta$ function : {\tt Zeta}}\index{zeta}
\noindent{\tt Zeta} takes as argument a real $x$.\\ 
{\tt Zeta} returns for $x>1$ : 
\[ \zeta(x)= \sum_{n=1}^{+\infty} \frac{1}{n^x} \]
and for $x<1$ it's meromorphic continuation.\\
Input :
\begin{center}{\tt Zeta(2)}\end{center}
Output :
\begin{center}{\tt pi\verb|^|2/6}\end{center}
Input :
\begin{center}{\tt Zeta(4)}\end{center}
Output :
\begin{center}{\tt pi\verb|^|4/90}\end{center}

\subsection{Airy functions : {\tt Airy\_Ai} and {\tt Airy\_Bi}}\index{Airy\_Ai}\index{Airy\_Bi}
\noindent{\tt Airy\_Ai} and {\tt Airy\_Bi} takes as argument a real $x$.\\
{\tt Airy\_Ai} and {\tt Airy\_Bi} are two independant solutions
of the equation
\[ y^{\prime\prime}-x*y=0 \]
They are defined by~:
\begin{eqnarray*}
\mbox{Airy\_Ai}(x) &=& (1/\pi) \int_0^\infty \cos(t^3/3 + x*t) dt \\
\mbox{Airy\_Bi}(x) &=& (1/\pi) \int_0^\infty (e^{- t^3/3} + \sin( t^3/3 +
x*t)) dt
\end{eqnarray*}
Properties :\\
\begin{eqnarray*}
 \tt \mbox{Airy\_Ai}(x)&=&\mbox{Airy\_Ai}(0)*f(x)+
\mbox{Airy\_Ai}^\prime (0)*g(x) \\
\tt \mbox{Airy\_Bi}(x)&=&\sqrt{3}(\mbox{Airy\_Ai}(0)*f(x)
-\mbox{Airy\_Ai}^\prime (0)*g(x) )
\end{eqnarray*}
where $f$ and $g$ are two entire series solutions of  
\[ w^{\prime\prime}-x*w=0 \]
more precisely~:
\begin{eqnarray*}
f(x)&=&\sum_{k=0}^\infty 3^k\left (\frac{\Gamma(k+\frac{1}{3})}{\Gamma(\frac{1}{3})}\right ) \frac{x^{3k}}{(3k)!}\\
g(x)&=&\sum_{k=0}^\infty 3^k\left
  (\frac{\Gamma(k+\frac{2}{3})}{\Gamma(\frac{2}{3})}\right )
\frac{x^{3k+1}}{(3k+1)!}
\end{eqnarray*}
Input :
\begin{center}{\tt Airy\_Ai(1)}\end{center}
Output :
\begin{center}{\tt 0.135292416313}\end{center}
Input :
\begin{center}{\tt Airy\_Bi(1)}\end{center}
Output :
\begin{center}{\tt 1.20742359495}\end{center}
Input :
\begin{center}{\tt Airy\_Ai(0)}\end{center}
Output :
\begin{center}{\tt 0.355028053888}\end{center}
Input :
\begin{center}{\tt Airy\_Bi(0)}\end{center}
Output :
\begin{center}{\tt 0.614926627446}\end{center}

\section{Permutations}
A permutation $p$ of size $n$ is a bijection from $[0..n-1]$ on 
$[0..n-1]$ and is represented by the list :
 $[p(0),p(1),p(2)...p(n-1)]$.\\
For example, the permutation $p$ represented by $[1,3,2,0]$ is 
the application from $[0,1,2,3]$ on $[0,1,2,3]$ defined by :
\[ p(0)=1,\ p(1)=3,\ p(2)=2,\  p(3)=0 \]
A cycle $c$ of size $p$  is represented by the list
$[a_0,...,a_{p-1}]$ ($0\leq a_k\leq n-1$) it is the permutation such that 
\[ c(a_i)=a_{i+1} \mbox{ for }(i=0..p-2), \quad
c(a_{p-1})=a_0, \quad 
 c(k)=k \mbox{ otherwise }\]
A cycle $c$ is  represented by a list and a cycle decomposition
is  represented by a list of lists.\\
For example, the cycle $c$  represented by the list $[3,2,1]$ is the 
permutation $c$ defined by $c(3)=2,\ c(2)=1,\ c(1)=3,\ c(0)=0$ (i.e. the
permutation represented by the list $[0,3,1,2]$).
 
\subsection{Random permutation : {\tt randperm}}\index{randperm}
\noindent{\tt randperm} takes as argument an integer $n$.\\
{\tt randperm} returns a random permutation of $[0..n-1]$.\\
Input :
\begin{center}{\tt randperm(3)}\end{center}
Output :
\begin{center}{\tt [2,0,1]}\end{center}

\subsection{Decomposition as a product of disjoint cycles : \\
{\tt permu2cycles}}\index{permu2cycles}
\noindent {\tt permu2cycles} takes as argument a permutation.\\
{\tt permu2cycles} returns its decomposition as a product of
disjoint cycles.\\
Input :
\begin{center}{\tt permu2cycles([1,3,4,5,2,0])}\end{center}
Output :
\begin{center}{\tt [[0,1,3,5],[2,4]]}\end{center}
In the answer the cycles of size 1 are omitted, except if $n-1$ is a
fixed point of the permutation (this is required to find the value of
$n$ from the cycle decomposition).\\
Input :
\begin{center}{\tt permu2cycles([0,1,2,4,3,5])}\end{center}
Output :
\begin{center}{\tt [[5],[3,4]]}\end{center}
Input :
\begin{center}{\tt permu2cycles([0,1,2,3,5,4])}\end{center}
Output :
\begin{center}{\tt [[4,5]]}\end{center}

\subsection{Product of disjoint cycles to permutation: {\tt cycles2permu}}\index{cycles2permu}
\noindent{\tt cycles2permu} takes as argument a list of cycles.\\
{\tt cycles2permu} returns the permutation (of size $n$ choosen as small as 
possible) that is the product of the given cycles 
(it is the inverse of {\tt permu2cycles}).\\
Input :
\begin{center}{\tt cycles2permu([[1,3,5],[2,4]])}\end{center}
Output :
\begin{center}{\tt [0,3,4,5,2,1]}\end{center}
Input :
\begin{center}{\tt cycles2permu([[2,4]])}\end{center}
Output :
\begin{center}{\tt [0,1,4,3,2]}\end{center}
Input :
\begin{center}{\tt cycles2permu([[5],[2,4]])}\end{center}
Output :
\begin{center}{\tt [0,1,4,3,2,5]}\end{center}

\subsection{Transform a cycle into permutation : {\tt cycle2perm}}\index{cycle2perm}
\noindent{\tt cycle2perm} takes on cycle as argument.\\
{\tt cycle2perm} returns the permutation of size $n$ corresponding 
to the cycle given as argument, where $n$  is choosen as small 
as possible (see also {\tt permu2cycles} and {\tt cycles2permu}).\\
Input :
\begin{center}{\tt cycle2perm([1,3,5])}\end{center}
Output :
\begin{center}{\tt [0,3,2,5,4,1]}\end{center}

\subsection{Transform a permutation into a matrix : {\tt permu2mat}}\index{permu2mat}
\noindent{\tt permu2mat} takes as argument a permutation $p$ of size $n$.\\
{\tt permu2mat} returns the matrix of the permutation, that is
the matrix obtained by permuting the rows of the identity matrix of size $n$
with the permutation $p$.\\
Input :
\begin{center}{\tt permu2mat([2,0,1])}\end{center}
Output :
\begin{center}{\tt [[0,0,1],[1,0,0],[0,1,0]]}\end{center}

\subsection{Checking for a permutation : {\tt is\_permu}}\index{is\_permu}
\noindent{\tt is\_permu} is a  boolean function.\\
{\tt is\_permu} takes as argument a list.\\
{\tt is\_permu} returns 1 if the argument is a permutation and returns 0 if the
argument is not a permutation.\\
Input :
\begin{center}{\tt is\_permu([2,1,3]) }\end{center}
Output :
\begin{center}{\tt 0}\end{center}
Input :
\begin{center}{\tt is\_permu([2,1,3,0]) }\end{center}
Output :
\begin{center}{\tt 1}\end{center}

\subsection{Checking for a cycle : {\tt is\_cycle}}\index{is\_cycle}
\noindent{\tt is\_cycle} is a boolean function.\\
{\tt is\_cycle} takes a list as argument.\\
{\tt is\_cycle} returns 1 if the argument is a cycle and returns 0 if the
argument is not a cycle.\\
Input :
\begin{center}{\tt is\_cycle([2,1,3]) }\end{center}
Output :
\begin{center}{\tt 1}\end{center}
Input :
\begin{center}{\tt is\_cycle([2,1,3,2]) }\end{center}
Output :
\begin{center}{\tt 0}\end{center}

\subsection{Product of two permutations : {\tt p1op2}}\index{p1op2}
\noindent{\tt p1op2} takes as arguments two permutations.\\
{\tt p1op2} returns the permutation obtained by composition :
\[ 1^{\mbox{st}}\mbox{arg} \circ 2^{\mbox{nd}} \mbox{arg} \]
Input :
\begin{center}{\tt p1op2([3,4,5,2,0,1],[2,0,1,4,3,5])}\end{center}
Output :
\begin{center}{\tt [5,3,4,0,2,1]}\end{center}
{\bf Warning}\\
Composition is done using the standard mathematical notation,
that is the permutation given as second argument is performed first.

\subsection{Composition of a cycle and a permutation : {\tt c1op2}}\index{c1op2}
\noindent{\tt c1op2} takes as arguments a cycle and a permutation.\\
{\tt c1op2} returns the  permutation obtained by composition :
\[ 1^{\mbox{st}}\mbox{arg} \circ 2^{\mbox{nd}} \mbox{arg} \]
Input :
\begin{center}{\tt c1op2([3,4,5],[2,0,1,4,3,5])}\end{center}
Output :
\begin{center}{\tt [2,0,1,5,4,3]}\end{center}
{\bf Warning}\\
Composition is done using the standard mathematical notation,
that is the permutation given as second argument is performed first.

\subsection{Composition of a permutation and a cycle : {\tt p1oc2}}\index{p1oc2}
\noindent{\tt p1oc2} takes as arguments a permutation and a cycle.\\
{\tt p1oc2} returns the  permutation obtained by composition :
\[ 1^{\mbox{st}}\mbox{arg} \circ 2^{\mbox{nd}} \mbox{arg} \]
Input :
\begin{center}{\tt p1oc2([3,4,5,2,0,1],[2,0,1])}\end{center}
Output :
\begin{center}{\tt [4,5,3,2,0,1]}\end{center}
{\bf Warning}\\
Composition is done using the standard mathematical notation,
that is the cycle given as second argument is performed first.

\subsection{Product of two cycles : {\tt c1oc2}}\index{c1oc2}
\noindent {\tt c1oc2} takes as arguments two cycles.\\
{\tt c1oc2} returns the permutation obtained by composition :
\[ 1^{\mbox{st}}\mbox{arg} \circ 2^{\mbox{nd}} \mbox{arg} \]
Input :
\begin{center}{\tt c1oc2([3,4,5],[2,0,1])}\end{center}
Output :
\begin{center}{\tt [1,2,0,4,5,3]}\end{center}
{\bf Warning}\\
Composition is done using the standard mathematical notation,
that is the cycle given as second argument is performed first.

\subsection{Signature of a permutation : {\tt signature}}\index{signature}
\noindent{\tt signature} takes as argument a permutation.\\
{\tt signature} returns the signature of the permutation given as argument.\\
The signature of a permutation is equal to :
\begin{itemize}
\item 1 if the permutation is equal to an even product of transpositions,
\item -1 if the permutation is equal to an odd product of transpositions.
\end{itemize}
The signature of a cycle of size $k$ is : $(-1)^{k+1}$.\\ 
 Input :
\begin{center}{\tt signature([3,4,5,2,0,1])}\end{center}
Output :
\begin{center}{\tt -1}\end{center}
Indeed {\tt permu2cycles([3,4,5,2,0,1])=[[0,3,2,5,1,4]]}.

\subsection{Inverse of a permutation : {\tt perminv}}\index{perminv}
\noindent{\tt perminv} takes as argument a permutation.\\
{\tt perminv} returns the permutation that is the inverse of the permutation 
given as argument.\\
Input :
\begin{center}{\tt perminv([1,2,0])}\end{center}
Output
\begin{center}{\tt [2,0,1]}\end{center}

\subsection{Inverse of a cycle : {\tt cycleinv}}\index{cycleinv}
\noindent{\tt cycleinv} takes as argument a cycle.\\
{\tt cycleinv} returns the cycle that is the inverse of the cycle given as 
argument.\\
Input :
\begin{center}{\tt cycleinv([2,0,1])}\end{center}
Output
\begin{center}{\tt [1,0,2]}\end{center}

\subsection{Order of a permutation : {\tt permuorder}}\index{permuorder}
\noindent{\tt permuorder} takes as argument a permutation.\\
{\tt permuorder} returns the order $k$ of the permutation $p$ given as 
argument, that is the smallest integer $m$ such that $p^m$ is the identity.\\
Input :
\begin{center}{\tt permuorder([0,2,1])}\end{center}
Output
\begin{center}{\tt 2}\end{center}
Input :
\begin{center}{\tt permuorder([3,2,1,4,0])}\end{center}
Output
\begin{center}{\tt 6}\end{center}

\subsection{Group generated by two permutations : {\tt groupermu}}\index{groupermu}
\noindent{\tt groupermu} takes as argument two permutations {\tt a} and 
{\tt b}.\\
{\tt groupermu} returns the group of the permutations generated by {\tt a} and 
{\tt b}.\\
Input :
\begin{center}{\tt groupermu([0,2,1,3],[3,1,2,0])}\end{center}
Output
\begin{center}{\tt [[0,2,1,3],[3,1,2,0],[0,1,2,3],[3,2,1,0]]}\end{center}

\section{Complex numbers}
Note that complex numbers are also used to represent a point in the plan
or a 1-d function graph.

\subsection{Usual  complex functions : {\tt +,-,*,/,\^\ }}\index{+}\index{'+'}\index{-}\index{'-'}\index{\^\ }
\noindent {\tt +,-,*,/,\^\ } are the usual operators to perform
additions, substractions, multiplications, divisions and for raising to an
integer or a fractional power.\\
Input :
\begin{center}{\tt (1+2*i)\verb|^|2}\end{center}
Output :
\begin{center}{\tt -3+4*i}\end{center}

\subsection{Real part of a complex number : {\tt re real}}\index{re}\index{real}
\noindent{\tt re} (or {\tt real}) takes as argument a complex number (resp a 
point $A$).\\
{\tt re} (or {\tt real}) returns the real part of this complex number (resp
the projection on the $x$ axis of $A$).\\
Input :
\begin{center}{\tt re(3+4*i)}\end{center}
Output :
\begin{center}{\tt 3}\end{center}

\subsection{Imaginary part of a complex number : {\tt im imag}}\index{im}\index{imag}
\noindent{\tt im} (or {\tt imag}) takes as argument a complex number (resp a 
point $A$).\\
{\tt im} (or {\tt imag}) returns imaginary part  of this complex number (resp 
the projection on the $y$ axis of $A$).\\
Input :
\begin{center}{\tt im(3+4*i)}\end{center}
Output :
\begin{center}{\tt 4}\end{center}

\subsection{Write a complex as {\tt re(z)+i*im(z)} : {\tt evalc}}\index{evalc}
\noindent{\tt evalc} takes as argument a complex number {\tt z}.\\
{\tt evalc} returns of this complex number, written as
{\tt re(z)+i*im(z)}.\\
Input :
\begin{center}{\tt evalc(sqrt(2)*exp(i*pi/4))}\end{center}
Output :
\begin{center}{\tt 1+i}\end{center}

\subsection{Modulus of a complex number : {\tt abs}}\index{abs}
\noindent{\tt abs} takes as argument a complex number.\\
{\tt abs} returns the modulus of this complex number.\\
Input :
\begin{center}{\tt abs(3+4*i)}\end{center}
Output :
\begin{center}{\tt 5}\end{center}

\subsection{Argument of a complex number : {\tt arg}}\index{arg|textbf}
\noindent{\tt arg} takes as argument a complex number.\\
{\tt arg} returns the argument of this complex number.\\
Input :
\begin{center}{\tt arg(3+4.i)}\end{center}
Output :
\begin{center}{\tt atan(4/3)}\end{center}

\subsection{The normalized complex number : {\tt normalize unitV}}\index{unitV}\index{normalize}
\noindent{\tt normalize} or {\tt unitV} takes as argument a complex number.\\
{\tt normalize} or {\tt unitV} returns the complex number divided by the
modulus of this complex number.\\
Input :
\begin{center}{\tt normalize(3+4*i)}\end{center}
Output :
\begin{center}{\tt (3+4*i)/5}\end{center}

\subsection{Conjuguate of a complex number : {\tt conj}}\index{conj|textbf}
\noindent{\tt conj} takes as argument a complex number.\\
{\tt conj} returns the complex conjuguate of this complex number.\\
Input :
\begin{center}{\tt conj(3+4*i)}\end{center}
Output :
\begin{center}{\tt 3-4*i}\end{center}

\subsection{Multiplication by the complex conjugate  :\\
 {\tt mult\_c\_conjugate}}\index{mult\_c\_conjugate}
\noindent {\tt mult\_c\_conjugate} takes as argument an complex expression.\\ 
If this expression has a complex denominator,
{\tt mult\_c\_conjugate} multiplies the numerator and the denominator of this 
 expression by the complex conjuguate of the denominator.\\
If this  expression has not a complex denominator,
{\tt mult\_c\_conjugate} multiplies the numerator and the denominator of this 
expression by the complex conjuguate of the numerator.\\
Input :
\begin{center}{\tt mult\_c\_conjugate((2+i)/(2+3*i))}\end{center}
Output :
\begin{center}{\tt (2+i)*(2+3*(-i))/((2+3*(i))*(2+3*(-i)))}\end{center}
Input :
\begin{center}{\tt mult\_c\_conjugate((2+i)/2)}\end{center}
Output :
\begin{center}{\tt (2+i)*(2+-i)/(2*(2+-i))}\end{center}

\subsection{Barycenter of complex numbers : {\tt barycentre}}\index{barycentre}\label{sec:baryc}
{\bf See also :} \ref{sec:barycentre2} and \ref{sec:barycentre3}.\\
\noindent{\tt barycentre} takes as argument two lists of the same size
(resp. a matrix with two columns): 
\begin{itemize}
\item the elements of the first list (resp column) 
are points $A_j$ or complex numbers $a_j$ (the affixes of the points),
\item the elements of the second list (resp column) are real coefficients 
$\alpha_j$ such that $\sum \alpha_j \neq 0$.
\end{itemize}
{\tt barycentre} returns the barycenter point of the  points $A_j$ 
weighted by the real coefficients  $\alpha_j$.
If $\sum \alpha_j = 0$, {\tt barycentre} returns an
error.\\
{\bf Warning} To have a complex number in the output, the input must be :\\
{\tt affixe(barycentre(...,...))} 
because {\tt barycentre(...,...)} returns a point, not a complex number.\\
Input :
\begin{center}{\tt affixe(barycentre([1+i,1-i],[1,1]))}\end{center}
Or :
\begin{center}{\tt affixe(barycentre([[1+i,1],[1-i,1]]))}\end{center}
Output :
\begin{center}{\tt i}\end{center}

\section{Algebraic expressions}
\subsection{Evaluate an expression : {\tt eval}}\index{eval}
\noindent {\tt eval} is used to evaluate an expression. Since 
{\tt Xcas} always evaluate expressions entered in the commandline, 
{\tt eval} is mainly used 
to evaluate a sub-expression in the equation writer.\\
Input :
\begin{center}{\tt a:=2}\end{center}
Output :
\begin{center}{\tt 2}\end{center}
Input :
\begin{center}{\tt eval(2+3*a)}\end{center}
or
\begin{center}{\tt 2+3*a}\end{center}
Output :
\begin{center}{\tt 8}\end{center}

\subsection{Evaluate algebraic expressions : {\tt evala}}
\index{evala}
\noindent  In Maple, {\tt evala} is used to evaluate an expression with
algebraic extensions. In {\tt Xcas}, {\tt evala} is not necessary, it
behaves like {\tt eval}.\\

\subsection{Prevent evaluation : {\tt quote hold '}}\index{quote|textbf}\index{hold|textbf}\index{'|textbf}
A quoted subexpression (either with {\tt '} or with the 
{\tt quote} or {\tt hold}) command will not be evaluated.\\
{\bf Remark}
{\tt a:=quote(a)} (or {\tt a:=hold(a)}) is equivalent to {\tt purge(a)} 
(for the sake of Maple compatibility). It returns 
the value of this variable (or the hypothesis done on this variable). \\
Input :
\begin{center}{\tt a:=2;quote(2+3*a)}\end{center}
or
\begin{center}{\tt a:=2;'2+3*a'}\end{center}
Output :
\begin{center}{\tt (2,2+3.a)}\end{center}

\subsection{Force evaluation : {\tt unquote}}\index{unquote}
{\tt unquote} is used to evaluate inside a quoted expression.\\
For example in an affectation, the variable is automatically quoted 
(not evaluated) so that the user does not have to quote it explicitely
each time he want to modify it's value. In some circumstances, you
might however want to evaluate it.
\\
Input:
\begin{center}{\tt purge(b);a:=b;unquote(a):=3}\end{center}
Output :
\begin{center}{\tt b contains 3, hence a evals to 3}\end{center}

\subsection{Distributivity : {\tt expand fdistrib}}\index{fdistrib}\index{expand}
\noindent {\tt expand} or {\tt fdistrib} takes as argument an expression.\\
{\tt expand} ou {\tt fdistrib} returns the expression where the distributivity
of the multiplication with respect to the addition is applied.\\
Input :
\begin{center}{\tt expand((x+1)*(x-2))}\end{center}
Or :
\begin{center}{\tt fdistrib((x+1)*(x-2))}\end{center}
Output :
\begin{center}{\tt x\verb|^|2-2*x+x-2}\end{center} 

\subsection{Canonical form : {\tt canonical\_form}}\index{canonical\_form}
\noindent{\tt canonical\_form} takes as argument a trinomial of second 
degree.\\ 
{\tt canonical\_form} returns the canonical form of the argument.\\
Example :\\
Find the canonical form of :
$$x^2-6x+1$$
Input :
\begin{center}{\tt canonical\_form(x\verb|^|2-6*x+1)}\end{center}
Outpout :
\begin{center}{\tt (x-3)\verb|^|2-8}\end{center}

\subsection{Multiplication by the conjugate quantity : \\
{\tt mult\_conjugate}}\index{mult\_conjugate} 
\noindent {\tt mult\_conjugate} takes as argument an expression  with a 
denominator or a numerator supposed to contain a square root :
\begin{itemize}
\item if the denominator contains a square root,\\
{\tt mult\_conjugate} multiplies the numerator and the denominator
of the expression by the conjugate quantity of the denominator.
\item otherwise, if the numerator contains a square root,\\
{\tt mult\_conjugate} multiplies the numerator and the denominator of this 
expression by the  conjugate quantity of the numerator. 
\end{itemize}
Input :
\begin{center}{\tt mult\_conjugate((2+sqrt(2))/(2+sqrt(3)))}\end{center}
Output :
\begin{center}{\tt (2+sqrt(2))*(2-sqrt(3))/((2+sqrt(3))*(2-sqrt(3)))}\end{center}
Input :
\begin{center}{\tt mult\_conjugate((2+sqrt(2))/(sqrt(2)+sqrt(3)))}\end{center}
Output :
\begin{center}{\tt (2+sqrt(2))*(-sqrt(2)+sqrt(3))/}\end{center}
\begin{center}{\tt ((sqrt(2)+sqrt(3))*(-sqrt(2)+sqrt(3)))}\end{center}
Input :
\begin{center}{\tt mult\_conjugate((2+sqrt(2))/2)}\end{center}
Output :
\begin{center}{\tt (2+sqrt(2))*(2-sqrt(2))/(2*(2-sqrt(2)))}\end{center}

\subsection{Separation of variables : {\tt split}}\index{split}
\noindent{\tt split} takes two arguments : an expression depending
on two variables and the list of these two variables.\\
If the expression may be factorized into two factors 
where each factor depends 
only of one variable, {\tt split} returns the list of this two 
factors, otherwise it returns the list {\tt [0]}.\\
Input :
\begin{center}{\tt split((x+1)*(y-2),[x,y])}\end{center}
Or :
\begin{center}{\tt split(x*y-2*x+y-2,[x,y])}\end{center}
Output :
\begin{center}{\tt [x+1,y-2]}\end{center} 
Input :
\begin{center}{\tt split((x\verb|^|2*y\verb|^|2-1,[x,y])}\end{center}
Output :
\begin{center}{\tt [0]}\end{center}

\subsection{Factorisation : {\tt factor}}\index{factor|textbf}\label{sec:factore}
\noindent{\tt factor} takes as argument an expression.\\
{\tt factor} factorizes this expression on the field of it's coefficients,
with the addition of $i$ in complex mode. If {\tt sqrt} is enabled
in the Cas configuration, polynomials of order 2 are factorized in
complex mode or in real mode if the discriminant is positive.\\
{\bf Examples}
\begin{enumerate}
\item Factorize $x^4-1$ over $\mathbb Q$.\\
Input :
\begin{center}{\tt factor(x\verb|^|4-1)}\end{center}
Output :
\begin{center}{\tt (x\verb|^|2+1)*(x+1)*(x-1)}\end{center}
The coefficients are rationals, hence the factors are polynomials with
rationals coefficients.\\
\item Factorize $x^4-1$ over $\mathbb Q[i]$ \\
To have a complex factorisation, check {\tt complex} in the {\tt cas}
configuration (red button displaying the status line).\\
Input :
\begin{center}{\tt factor(x\verb|^|4-1)}\end{center}
Output :
\begin{center}{\tt -i*(-x+-i)*(i*x+1)*(-x+1)*(x+1)}\end{center}
\item  Factorize $x^4+1$ over $\mathbb Q$\\
Input :
\begin{center}{\tt factor(x\verb|^|4+1)}\end{center}
Output :
\begin{center}{\tt x\verb|^|4+1}\end{center}
Indeed $ x^4+1$ has no factor with rational coefficients.\\
\item  Factorize  $x^4+1$ over $\mathbb Q[i]$\\
Check {\tt complex} in the {\tt cas}
configuration (red button rouge displaying the status line).\\
Input :
\begin{center}{\tt factor(x\verb|^|4-1)}\end{center}
Output :
\begin{center}{\tt (x\verb|^|2+i)*(x\verb|^|2+-i)}\end{center}
\item  Factorize $x^4+1$ over $\mathbb R$.\\
You have to provide the square root required for extending the
rationals. In order to do that with the help of {\tt Xcas}, 
first check {\tt complex} in the {\tt cas}
configuration and  input :\\
\begin{center}{\tt solve(x\verb|^|4+1,x)}\end{center}\index{solve}\index{resoudre}
Output :
\begin{center}{\tt  [sqrt(2)/2+(i)*sqrt(2)/2,sqrt(2)/2+(i)*(-(sqrt(2)/2)),
 -sqrt(2)/2+(i)*sqrt(2)/2,-sqrt(2)/2+(i)*(-(sqrt(2)/2))]}\end{center}
The roots depends on $\sqrt 2$. Uncheck complex mode in the Cas configuration
and input :
\begin{center}{\tt factor(x\verb|^|4+1,sqrt(2))}\end{center}
Output :
\begin{center}{\tt (x\verb|^|2+sqrt(2)*x+1)*(x\verb|^|2+(-(sqrt(2)))*x+1)}\end{center}
To factorize over $\mathbb C$, check {\tt complex} in the 
{\tt cas} configuration and input {\tt cFactor(x\verb|^|4+1,sqrt(2))} 
(cf {\tt cFactor}).
\end{enumerate}

\subsection{Complex factorisation : {\tt cFactor}}\index{cFactor}
\noindent{\tt cFactor} takes as argument an expression.\\
{\tt cFactor} factorizes this expression on the field 
$\mathbb Q[i] \subset \mathbb C$ (or over the complexified field of 
the coefficients of the argument) even if you are in real mode.\\
{\bf Examples}
\begin{enumerate}
\item Factorize $x^4-1$ over $\mathbb Z[i]$.\\
Input :
\begin{center}{\tt cFactor(x\verb|^|4-1)}\end{center}
Output :
\begin{center}{\tt -((x+-i)*((-i)*x+1)*((-i)*x+i)*(x+1))}\end{center}
\item Factorize $x^4+1$ over $\mathbb Z[i]$.\\
Input :
\begin{center}{\tt cFactor(x\verb|^|4+1)}\end{center}
Output :
\begin{center}{\tt (x\verb|^|2+i)*(x\verb|^|2+-i)}\end{center}
\item For a complete factorization of $x^4+1$, 
check the sqrt box in the Cas configuration or input :
\begin{center}{\tt cFactor(x\verb|^|4+1,sqrt(2))}\end{center}
Output :
\begin{center}{\tt sqrt(2)*1/2*(sqrt(2)*x+1-i)*(sqrt(2)*x-1+i)*sqrt(2)* 1/2*(sqrt(2)*x+1+i)*(sqrt(2)*x-1-i)}\end{center}
\end{enumerate}

\subsection{Zeros of an expression : {\tt zeros}}\index{zeros}
\noindent{\tt zeros} takes as argument an expression depending on $x$.\\
{\tt zeros} returns a list of values of $x$ where the expression
vanishes. The list may be incomplete in exact mode if the expression
is not polynomial or if intermediate
factorizations have irreducible factors of order strictly
greater than 2.\\
In real mode, (complex box unchecked in the Cas configuration
or {\tt complex\_mode:=0}), only reals zeros are returned. In
({\tt complex\_mode:=1}) reals and complex zeros are returned. See
also {\tt cZeros} to get complex zeros in real mode.\\
Input in real mode : 
\begin{center}{\tt zeros(x\verb|^|2+4)}\end{center} 
Output :
\begin{center}{\tt []}\end{center} 
Input in complex mode : 
\begin{center}{\tt zeros(x\verb|^|2+4)}\end{center} 
Output :
\begin{center}{\tt [-2*i,2*i]}\end{center} 
Input in real mode : 
\begin{center}{\tt zeros(ln(x)\verb|^|2-2)}\end{center} 
Output :
\begin{center}{\tt [exp(sqrt(2)),exp(-(sqrt(2)))]}\end{center} 
Input in real mode : 
\begin{center}{\tt zeros(ln(y)\verb|^|2-2,y)}\end{center} 
Output :
\begin{center}{\tt [exp(sqrt(2)),exp(-(sqrt(2)))]}\end{center} 
Input in real mode : 
\begin{center}{\tt zeros(x*(exp(x))\verb|^|2-2*x-2*(exp(x))\verb|^|2+4)}\end{center} 
Output :
 \begin{center}{\tt [[log(sqrt(2)),2]}\end{center} 

\subsection{Complex zeros of an expression : {\tt cZeros}}\index{cZzeros}
\noindent{\tt cZeros} takes as argument an expression depending on $x$.\\
{\tt cZeros} returns a list of comnplex values of $x$ where the expression
vanishes. The list may be incomplete in exact mode if the expression
is not polynomial or if intermediate
factorizations have irreducible factors of order strictly
greater than 2.\\
Input in real or complex mode : 
\begin{center}{\tt cZeros(x\verb|^|2+4)}\end{center} 
Output :
\begin{center}{\tt [-2*i,2*i]}\end{center} 
Input : 
\begin{center}{\tt cZeros(ln(x)\verb|^|2-2)}\end{center} 
Output :
\begin{center}{\tt [exp(sqrt(2)),exp(-(sqrt(2)))]}\end{center} 
Input : 
\begin{center}{\tt cZeros(ln(y)\verb|^|2-2,y)}\end{center} 
Output :
\begin{center}{\tt [exp(sqrt(2)),exp(-(sqrt(2)))]}\end{center} 
Input : 
\begin{center}{\tt cZeros(x*(exp(x))\verb|^|2-2*x-2*(exp(x))\verb|^|2+4)}\end{center} 
Output :
\begin{center}{\tt [[log(sqrt(2)),log(-sqrt(2)),2]}\end{center} 

\subsection{Normal form : {\tt normal}}\index{normal|textbf}
\noindent{\tt normal} takes as argument an expression. 
The expression is considered as a rational fraction with respect 
to generalized identifiers
(either true identifiers or transcendental functions replaced by 
a temporary identifiers) with coefficients in $\mathbb Q$ or $\mathbb Q[i]$
or in an algebraic extension (e.g. $\mathbb Q[\sqrt{2}]$).
{\tt normal} returns the expanded irreducible representation
of this rational fraction. See also {\tt ratnormal} for pure rational
fractions or {\tt simplify} if the transcendental functions are
not algebraically independant.\\
Input :  
\begin{center}{\tt normal((x-1)*(x+1))}\end{center}
Output :
 \begin{center}{\tt x\verb|^|2-1}\end{center}  
{\bf Remarks}
\begin{itemize}
\item Unlike {\tt simplify},
{\tt normal} does not try to find algebraic relations between
transcendental functions like $\cos(x)^2+\sin(x)^2=1$.
\item
It is sometimes necessary to run the {\tt normal} command twice to
get a fully irreducible representation of an expression
containing algebraic extensions.
\end{itemize}
%% Input :  
%% \begin{center}{\tt normal(3-54*sqrt(1/162))}\end{center}
%% Output :
%%  \begin{center}{\tt (-9*sqrt(2)+9)/3}\end{center}
%% Input :  
%% \begin{center}{\tt normal((-9*sqrt(2)+9)/3)}\end{center}
%% Output :
%%  \begin{center}{\tt -(3*sqrt(2))+3}\end{center}

\subsection{Simplify : {\tt simplify}}\index{simplify|textbf}
\noindent{\tt simplify} simplifies an expression. It behaves
like {\tt normal} for rational fractions and algebraic extensions. 
For expressions
containing transcendental functions, {\tt simplify} tries first to rewrite
them in terms of algebraically independant transcendental functions.
For trigonometric expressions, this requires radian mode
(check {\tt radian} in the {\tt cas}
configuration or input {\tt angle\_radian:=1}).\\
Input :  
\begin{center}{\tt simplify((x-1)*(x+1))}\end{center}
Output :
 \begin{center}{\tt x\verb|^|2-1}\end{center}  
Input :  
\begin{center}{\tt simplify(3-54*sqrt(1/162))}\end{center}
Output :
 \begin{center}{\tt -3*sqrt(2)+3}\end{center} 
Input :
\begin{center}{\tt simplify((sin(3*x)+sin(7*x))/sin(5*x))}\end{center}
Output :
\begin{center}{\tt 4*(cos(x))\verb|^|2-2}\end{center}
 
\subsection{Normal form for rational fractions : {\tt ratnormal}}\index{ratnormal}
\noindent{\tt ratnormal} rewrites an expression using
it's irreductible representation. The expression is viewed
as a multivariate rational fraction with 
coefficients in $\mathbb Q$ (or $\mathbb Q[i]$). The variables are
generalized identifiers which are assumed to be algebraically independant.
Unlike with {\tt normal}, an algebraic extension
is considered as a generalized identifier. Therefore {\tt ratnormal}
is faster but might miss some simplifications if
the expression contains radicals or algebraically dependant transcendental
functions.\\
Input :  
\begin{center}{\tt ratnormal((x\verb|^|3-1)/(x\verb|^|2-1))}\end{center}
Output :
 \begin{center}{\tt (x\verb|^|2+x+1)/(x+1)}\end{center}  
Input :  
\begin{center}{\tt ratnormal((-2x\verb|^|3+3x\verb|^|2+5x-6)/(x\verb|^|2-2x+1))}\end{center}
Output :
 \begin{center}{\tt (-2*x\verb|^|2+x+6)/(x-1)}\end{center} 

\subsection{Substitue a variable by a value : {\tt subst}}\index{subst|textbf}\label{sec:subst}
\noindent{\tt subst} takes two or three arguments : 
\begin{itemize}
\item an expression depending on a variable,
an equality (variable=value of substitution) or a list of equalities.
\item an expression depending on a variable, a variable or a list
of variables, a value or a list of values for substitution.
\end{itemize}
{\tt subst} returns the expression with the substitution done.
Note that {\tt subst} does not quote it's argument, hence
in a normal evaluation process, the substitution variable should
be purged otherwise it will be replaced by it's assigned value
before substitution is done.\\
Input :
\begin{center}{\tt subst(a\verb|^|2+1,a=2)}\end{center} 
or :
\begin{center}{\tt subst(a\verb|^|2+1,a,2)}\end{center} 
Output (if the variable {\tt a} is purged else first input {\tt purge(a)}) :
\begin{center}{\tt 5}\end{center} 
Input :
\begin{center}{\tt subst(a\verb|^|2+b,[a,b],[2,1])}\end{center} 
Or :
\begin{center}{\tt subst(a\verb|^|2+b,[a=2,b=1])}\end{center} 
Output  (if the variables {\tt a} and {\tt b} are purged else first input 
{\tt purge(a,b)}) :
 \begin{center}{\tt 2\verb|^|2+1}\end{center}
{\tt subst} may also be used to make a change of variable in an integral. 
In this case the {\tt integrate} command should be quoted 
(otherwise, the integral would be computed before substitution) or
the inert form {\tt Int} should be used.
In both cases, the name of the integration variable must be given as
argument of {\tt Int} or {\tt integrate} even you are integrating
with respect to {\tt x}.\\
Input :
\begin{center}{\tt subst('integrate(sin(x\verb|^|2)*x,x,0,pi/2)',x=sqrt(t))}\end{center}
Or :
\begin{center}{\tt subst(Int(sin(x\verb|^|2)*x,x,0,pi/2),x=sqrt(t))}\end{center}
Output
\begin{center}{\tt integrate(sin(t)*sqrt(t)*1/2*1/t*sqrt(t),t,0,(pi/2)\verb|^|2)}\end{center} 
Input :
\begin{center}{\tt subst('integrate(sin(x\verb|^|2)*x,x)',x=sqrt(t))}\end{center}
Or :
\begin{center}{\tt subst(Int(sin(x\verb|^|2)*x,x),x=sqrt(t))}\end{center}
Output
\begin{center}{\tt integrate(sin(t)*sqrt(t)*1/2*1/t*sqrt(t),t)}\end{center} 

\subsection{Substitue a variable by a value (Maple and Mupad compatibility) : {\tt subs}}\index{subs}\label{sec:subs}
\noindent In {\tt Maple} and in {\tt Mupad}, one would use the {\tt subs}
command to substitue a variable 
by a value in an expression. But the order of the arguments differ
between {\tt Maple} and {\tt Mupad}. Therefore, to achieve compatibility,
{\tt Xcas} {\tt subs} command arguments order depends on the mode
\begin{itemize}
\item
In {\tt Maple} mode,  {\tt subs} takes two arguments : an equality 
(variable=substitution value) and the expression.\\
To substitue several variables in an expression, use a list of equality
(variable names {\tt =} substitution value) as first argument.
\item In {\tt Mupad} or {\tt  Xcas} or {\tt TI}, {\tt subs} 
takes two or three arguments : 
an expression and an equality (variable=substitution value) or 
an expression, a variable name and the substitution value.\\
To substitue several variables, {\tt subs} takes two ou three arguments :
\begin{itemize}
\item an expression of variables and a list of   
(variable names {\tt =} substitution value),
\item
an expression of variables, a list of variables and a list of their 
substitution values.
\end{itemize}
\end{itemize}
{\tt subs} returns the expression with the substitution done.
Note that {\tt subs} does not quote it's argument, hence
in a normal evaluation process, the substitution variable should
be purged otherwise it will be replaced by it's assigned value
before substitution is done.\\
Input in {\tt Maple} mode (if the variable {\tt a} is purged  else input 
{\tt purge(a)}) :
\begin{center}{\tt subs(a=2,a\verb|^|2+1)}\end{center}
Output 
\begin{center}{\tt 2\verb|^|2+1}\end{center}
Input in {\tt Maple} mode (if the variables {\tt a} and {\tt b} are purged
  else input {\tt purge(a,b)}):
\begin{center}{\tt subs([a=2,b=1],a\verb|^|2+b)}\end{center} 
Output  :
\begin{center}{\tt 2\verb|^|2+1}\end{center}
Input :
\begin{center}{\tt subs(a\verb|^|2+1,a=2)}\end{center} 
or :
\begin{center}{\tt subs(a\verb|^|2+1,a,2)}\end{center} 
Output (if the variable {\tt a} is purged else input {\tt purge(a)}) :
\begin{center}{\tt 5}\end{center} 
Input :
\begin{center}{\tt subs(a\verb|^|2+b,[a=2,b=1])}\end{center} 
or :
\begin{center}{\tt subs(a\verb|^|2+b,[a,b],[2,1])}\end{center} 
Output (if the variables {\tt a} and {\tt b} are purged else input 
{\tt purge(a,b)}) :
\begin{center}{\tt 2\verb|^|2+1}\end{center} 

\subsection{Evaluate a primitive at boundaries: {\tt preval}}\index{preval}
\noindent{\tt preval} takes three arguments : an expression {\tt F} 
depending on
the variable {\tt x}, and two expressions {\tt a} and {\tt b}.\\
{\tt preval}  computes $F_{|x=b}-F_{|x=a}$.\\
 {\tt preval} is used to compute a definite integral 
when the primitive $F$ of the integrand $f$ is known. Assume
for example that {\tt F:=int(f,x)}, then {\tt preval(F,a,b)} is equivalent
to {\tt int(f,x,a,b)} but does not require to compute again {\tt F}
from {\tt f} if you change the values of $a$ or $b$.\\
Input :
\begin{center}{\tt preval(x\verb|^|2+x,2,3)}\end{center}
Output :
\begin{center}{\tt 6}\end{center}

\subsection{Sub-expression of an expression : {\tt part}}\index{part}
\noindent{\tt part} takes two arguments : an expression and an integer $n$.\\
{\tt part} evaluate the expression and then returns the $n$-th sub-expression
of this expression.\\
Input :
\begin{center}{\tt part(x\verb|^|2+x+1,2)}\end{center}
Output :
\begin{center}{\tt x}\end{center}
Input :
\begin{center}{\tt part(x\verb|^|2+(x+1)*(y-2)+2,2)}\end{center}
Output :
\begin{center}{\tt (x+1)*(y-2)}\end{center}
Input :
\begin{center}{\tt part((x+1)*(y-2)/2,2)}\end{center}
Output :
\begin{center}{\tt y-2}\end{center}

\section{Values of $u_n$}
\subsection{Array of values of a sequence : {\tt tablefunc}}\index{tablefunc}
{\tt tablefunc} is a command that should be used inside a spreadsheet
(opened with {\tt Alt+t}),
it returns a template to fill two columns, with
the table of values of a function. If the step value is 1,
{\tt tablefunc(ex,n,n0,1)}, where {\tt ex} is an expression
depending on {\tt n}, will fill the spreadsheet with
the values of the sequence $u_n=ex$ for $n=n0,\ n0+1,\ n0+2,....$.

{\bf Example} : display the values of the sequence $u_n=\sin(n)$\\
Select a cell of a spreadsheet (for example {\tt C0}) 
and input in the command line : 
\begin{center}{\tt tablefunc(sin(n),n,0,1)}\end{center}
Output :
\begin{center}{\tt two columns : {\tt n} and {\tt sin(n)}}\end{center}
\begin{itemize}
\item in the column C: the variable name {\tt n}, the value of the step 
(this value should be equal to 1 for a sequence),
the value of {\tt n0} (here 0), then a recurrence 
formula ({\tt C2+C\$1}, ...). 
\item  in the column D: {\tt sin(n)}, {\tt "Tablefunc"}, then a 
recurrence formula.
\item For each row,
the values of the sequence ${\tt u_n=\sin(n)}$ correspond to 
the values of {\tt n} starting from {\tt n=n0} (here 0).
\end{itemize} 

\subsection{Table of values and graph of a recurrent sequence : {\tt tableseq} and {\tt plotseq}}\index{tableseq|textbf}\index{plotseq}
{\tt tableseq} is a command that should be used inside a spreadsheet
(opened with {\tt Alt+t}),
it returns a template to fill one column with
${\tt u_0, \ u_{n+1}=f(u_{n})}$ (one-term recurrence) or
more generally $u_0,...,u_k, \ \ u_{n+k+1}=f(u_n,u_{n+1},...,u_{n+k})$.
The template fills the column starting from the selected cell, or
starting from 0 if the whole column was selected.\\
See also {\tt plotseq} (section \ref{sec:plotseq}) for a graphic representation
of a one-term recurrence sequence.

{\bf Examples} :
\begin{itemize}
\item display the values of the sequence $u_0=3.5, \ u_n=\sin(u_{n-1})$\\
Select a cell of the spreadsheet (for example {\tt B0}) and 
 input in the command line :
\begin{center}{\tt tableseq(sin(n),n,3.5)}\end{center}
Output :
\begin{center}{\tt a column with sin(n), n, 3.5 
and the formula evalf(subst(B\$0,B\$1,B2))}
\end{center} 
You get the values of the sequence 
${\tt u_0=3.5,\ u_n=sin(u_{n-1})}$ in the column 
{\tt B}.
\item 
display the values of the Fibonacci sequence 
$u_0=1, u_1=1 \ u_{n+2}=u_n+u_{n+1}$\\
Select a cell, say {\tt B0}, and input in the command line 
\begin{center}{\tt tableseq(x+y,[x,y],[1,1])}\end{center}
This fills the B column sheet with
\begin{center}{\tt \begin{tabular}{|l|l|}
\hline
row &B\\
\hline
0 &x+y \\
\hline
1 & x\\
\hline
2 & y\\
\hline
3 & 1\\
\hline
4 & 1\\
\hline
5 & 2\\
\hline
.. &..\\
\hline
7 & 5\\
\hline
.. &..\\
\hline
\end{tabular}}\end{center}
\end{itemize}

\section{Operators or infixed functions}
An operator is an infixed function.

\subsection{Usual operators :{\tt +, -, *, /, \^\ }}\index{+}\index{'+'}\index{-}\index{'-'}\index{\^\ }
{\tt +, -, *, /, \^\ } are the operators to do
additions, substractions, multiplications, divisions and for raising to a
power.

\subsection{{\tt Xcas} operators }\index{\@}\index{\@\@}\index{\$}\index{\%} 
\begin{itemize}
\item
{\tt \$ } is the infixed  version  of {\tt seq} for example :\\
{\tt (2\verb|^|k)\$(k=0..3)= seq(2\verb|^|k,k=0..3)=(1,2,4,8)} (do not forget 
to put parenthesis around the arguments),
\item
{\tt mod} or {\tt \%} to define a modular number,
\item
{\tt @} to compose functions for example :
{\tt (f@g)(x)=f(g(x))},
\item
{\tt @@ } to compose a function many times (like a power, replacing
multiplication by composition), for example :
{\tt (f@@3)(x)=f(f(f(x)))},
\item
{\tt minus union intersect} to have the difference, the union and the 
intersection of two sets,
\item
{\tt ->} to define a function,
\item
{\tt := =>} to store an expression in a une variable (it is the infixed 
version of {\tt sto} and the argument order is permuted for {\tt :=}), 
for example : {\tt a:=2} or {\tt 2=>a} or {\tt sto(2,a)}.
\item
{\tt =<} to store an expression in a variable, but the storage is
done by reference if the target is a matrix element or a list element.
This is faster if you modify objects inside an existing list or matrix
of large size, because no copy is made, the change is done in place.
Use with care, all objects pointing to this matrix or list will
be modified.
\end{itemize}


\subsection{Define an operator:  {\tt user\_operator}}\index{user\_operator}\index{Binary@{\sl Binary}|textbf}\index{Delete@{\sl Delete}|textbf}
\noindent {\tt user\_operator} takes as argument :
\begin{itemize}
\item a string : the name of the operator,
\item a function of two variables with values in $\mathbb R$ or in 
{\tt true, false},
\item an option {\tt Binary} for the definition or {\tt Delete} to annulate 
this definition.
\end{itemize}
{\tt user\_operator} returns 1 if the definition is done and else returns 0.

{\bf Example 1}\\
Let $R$ be defined on $\mathbb R$ by $x\ R \ y= x*y+x+y$.\\
To define the law $R$, input :
\begin{center}{\tt user\_operator("R",(x,y)->x*y+x+y,Binary)}\end{center}
Output :
\begin{center}{\tt 1}\end{center}  
Input :
\begin{center}{\tt 5 R 7}\end{center}
Do not forget to put spaces around {\tt R}.\\
Output :
\begin{center}{\tt 47}\end{center}
  
{\bf Example 2}\\
Let $S$ by defined on $\mathbb N$ by :\\
for  $x$ and $y$ integers, $x\ S \ y <=> x$ and $y$ are not coprime.\\
To define the law  $S$, input :
\begin{center}{\tt user\_operator("S",(x,y)->(gcd(x,y))!=1,Binary)}\end{center}
Output :
\begin{center}{\tt 1}\end{center}  
Input :
\begin{center}{\tt 5 S 7}\end{center}
Do not forget to put spaces around {\tt S}.\\
Output :
\begin{center}{\tt 0}\end{center}  
Input :
\begin{center}{\tt 8 S 12}\end{center}
Do not forget to put spaces around {\tt S}.\\
Output :
\begin{center}{\tt 1}\end{center}

\section{Functions and expressions with symbolic variables}
\subsection{Difference between function and expression}\index{->}\index{:=}
A function {\tt f} is defined for example by :\\
{\tt f(x):=x\verb|^|2-1} or by {\tt f:=x->x\verb|^|2-1} \\
that is to say, for all $x$, $f(x)$ is equal to the expression 
$x^2-1$. In that case, to have the value of $f$ for $x=2$, input :{\tt f(2)}.\\
But if the input is 
{\tt g:=x\verb|^|2-1}, then {\tt g} is a variable where the 
expression $x^2-1$ is stored. In that case, to have the value of $g$ for $x=2$,
input : {\tt subst(g,x=2)} ($g$ is an expression depending on $x$).

When a command expects a function as argument, this argument should
be either the definition of the function (e.g. {\tt x->x\verb|^|2-1})
or a variable name assigned to a function (e.g. {\tt f}
previously defined by e.g. {\tt f(x):=x\verb|^|2-1}).\\
When a command expects an expression as argument, this argument should
be either the definition of the expression (for example {\tt x\verb|^|2-1}), 
or a variable name assigned to an expression (e.g. 
{\tt g} previously defined, for example, by 
{\tt g:=x\verb|^|2-1}), or the evaluation of a function. e.g.
{\tt f(x)} if {\tt f} is a previously defined function,
for example, by {\tt f(x):=x\verb|^|2-1}).

\subsection{Transform an expression into a fonction : {\tt unapply}}\index{unapply}
\noindent  {\tt unapply} is used to transform an expression into a function.\\
{\tt unapply} takes two arguments an expression and the name of a variable.\\
{\tt unapply} returns the function  defined by this expression and
this variable.

{\bf Warning} when a function is defined,
the right member of the affectation is not evaluated,
hence \verb|g:=sin(x+1); f(x):=g| does not defined the function 
$f: x \rightarrow sin(x+1)$ but defines the function
$f: x \rightarrow g$. To defined the former function, {\tt unapply}
should be used, like in the following example:\\
Input :
\begin{center}{\tt g:= sin(x+1); f:=unapply(g,x)}\end{center}
Output :
\begin{center}{\tt (sin(x+1), (x)->sin(x+1))}\end{center} 
hence, the variable {\tt g} is assigned to a symbolic expression
and the variable {\tt f} is assigned to a function.\\
Input :
\begin{center}{\tt unapply(exp(x+2),x)}\end{center}
Output :
\begin{center}{\tt (x)->exp(x+2)}\end{center} 
Input :
\begin{center}{\tt f:=unapply(lagrange([1,2,3],[4,8,12]),x)}\end{center}
Output :
\begin{center}{\tt (x)->4+4*(x-1)}\end{center} 
Input :
\begin{center}{\tt f:=unapply(integrate(log(t),t,1,x),x)}\end{center}
Output :
\begin{center}{\tt  (x)->x*log(x)-x+1}\end{center} 
Input :
\begin{center}{\tt f:=unapply(integrate(log(t),t,1,x),x)}\end{center}
\begin{center}{\tt f(x)}\end{center}
Output :
\begin{center}{\tt  x*log(x)-x+1}\end{center}
{\bf Remark}
Suppose that $f$ is a function of 2 variables $f:(x,w)\rightarrow f(x,w)$, 
and that $g$ is the function defined by
$g: w \rightarrow h_w$ where $h_w$ is the function defined by 
$h_w(x)=f(x,w)$.\\ 
{\tt unapply} is  also used to define $g$ with {\tt Xcas}.\\
Input : 
\begin{center}{\tt f(x,w):=2*x+w}\end{center}
\begin{center}{\tt g(w):=unapply(f(x,w),x)}\end{center}
\begin{center}{\tt g(3)}\end{center}
Output :
\begin{center}{\tt  x->2$\cdot$ x+3}\end{center} 

\subsection{Top and leaves of an expression : {\tt sommet feuille op}}\index{sommet|textbf}\index{feuille|textbf}\index{op|textbf}\label{sec:op}
An operator is an  infixed function : for exemple '+' is an 
operator and 'sin' is a function.\\
An expression can be represented by a tree. The top of the tree is 
either an operator, or a function and the leaves of the tree are the 
arguments of the operator or of the function 
(see also \ref{sec:makesuiteop}).\\
The instruction {\tt sommet} (resp {\tt feuille} (or {\tt op}))
returns the top (resp. the list of the leaves) of an expression.\\
Input :
\begin{center}{\tt sommet(sin(x+2))}\end{center}
Output :
\begin{center}{\tt 'sin'}\end{center}  
Input :
\begin{center}{\tt sommet(x+2*y)}\end{center}
Output :
\begin{center}{\tt '+'}\end{center}  
Input :
\begin{center}{\tt feuille(sin(x+2))}\end{center}
Or :
\begin{center}{\tt op(sin(x+2))}\end{center}
Output :
\begin{center}{\tt x+2}\end{center}  
Input :
\begin{center}{\tt feuille(x+2*y)}\end{center}
Or :
\begin{center}{\tt op(x+2*y)}\end{center}
Output :
\begin{center}{\tt (x,2*y) }\end{center} 
{\bf Remark}\\
Suppose that a function is defined by a program, for example 
let us define the {\tt pgcd} function :
\begin{center}{\tt pgcd(a,b):=\{local r; while (b!=0) \{r:=irem(a,b);a:=b;b:=r;\} return a;\}}\end{center}
Then input :
\begin{center}{\tt sommet(pgcd)}\end{center}
Output :
\begin{center}{\tt 'program'}\end{center}  
Then input :
\begin{center}{\tt feuille(pgcd)[0]}\end{center} 
Output :
\begin{center}{\tt (a,b)}\end{center}
Then input :
\begin{center}{\tt feuille(pgcd)[1]}\end{center} 
Output :
\begin{center}{\tt (0,0) or (15,25) if the last input was pgcd(15,25)}\end{center}
Then input :
\begin{center}{\tt feuille(pgcd)[2]}\end{center} 
Output :
\begin{center}{\tt The body of the program : \{local r;....return(a);\}}\end{center}


\section{Functions}
\subsection{Context-dependant functions.}
\subsubsection{Operators {\tt +} and {\tt -}}\index{+}\index{'+'}\index{-}\index{'-'}
 \noindent{\tt +} (resp {\tt -}) is an infixed function and {\tt '+'} (resp 
{\tt '-'}) is a prefixed fonction. The result depends on the nature of its 
arguments.\\
Examples with {\tt +} (all examples except the last one work also 
with {\tt -} instead of {\tt +}) :
\begin{itemize}
\item input (1,2)+(3,4) or (1,2,3)+4 or 1+2+3+4 or '+'(1,2,3,4), output 10,
\item input  1+i+2+3*i or '+'(1,i,2,3*i), output 3+4*i,
\item input  [1,2,3]+[4,1] or [1,2,3]+[4,1,0] or '+'([1,2,3],[4,1]), output 
[5,3,3],
\item  input [1,2]+[3,4] or '+'([1,2],[3,4]), output [4,6], 
\item  input [[1,2],[3,4]]+ [[1,2],[3,4]], output [[2,4],[6,8]],
\item input  [1,2,3]+4 or '+'([1,2,3],4), output poly1[1,2,7],
\item input  [1,2,3]+(4,1) or '+'([1,2,3],4,1), output poly1[1,2,8],
\item  input "Hel"+"lo" or  '+'("Hel","lo"), output "Hello".
\end{itemize}

\subsubsection{Operator {\tt *}}\index{*}\index{'*'}
\noindent{\tt *} is an infixed function and {\tt '*'} 
is a prefixed function. The result depends on the nature of its arguments.\\
Examples with {\tt *} :
\begin{itemize}
\item input (1,2)*(3,4) or (1,2,3)*4=1*2*3*4  or '*'(1,2,3,4), output 24,
\item  input 1*i*2*3*i or '*'(1,i,2,3*i), output -6,
\item  input [10,2,3]*[4,1] or [10,2,3]*[4,1,0] or '+'([10,2,3],[4,1]), 
output 42 (scalar product),
\item  input [1,2]*[3,4]='*'([1,2],[3,4]), output 11 (scalar product),
\item  input [[1,2],[3,4]]* [[1,2],[3,4]], output [[7,10],[15,22]],
\item  input [1,2,3]*4 or '*'([1,2,3],4), output [4,8,12],
\item  input [1,2,3]*(4,2) or '*'([1,2,3],4,2) or [1,2,3]*8, output [8,16,24],
\item  input (1,2)+i*(2,3) or 1+2+i*2*3, output 3+6*i.
\end{itemize}

\subsubsection{Operator {\tt /}}\index{/}\index{'/'}
\noindent{\tt /} is an infixed function and {\tt '/'} 
is a prefixed function. The result depends of the nature of its arguments.\\
Examples with {\tt /} :
\begin{itemize}
\item input [10,2,3]/[4,1], output invalid dim
\item input [1,2]/[3,4] or '/'([1,2],[3,4]), output [1/3,1/2], 
\item input 1/[[1,2],[3,4]] or '/'(1,[[1,2],[3,4]], output 
[[-2,1],[3/2,(-1)/2]],
\item input [[1,2],[3,4]]*1/ [[1,2],[3,4]], output [[1,0],[0,1]],
\item input [[1,2],[3,4]]/ [[1,2],[3,4]], output [[1,1],[1,1]] (division term 
by term),
%\item input [1,2,3]*4 or '*'([1,2,3],4), output [4,8,12],
%\item input [1,2,3]/(4,2) or '*'([1,2,3],4,2), output [1,2,3]*8=[8,16,24].
%\item (1,2)+i/(2,3)=1+2+i*2*3=3+6*i
\end{itemize}

\subsection{Usual functions}
\begin{itemize}
\item {\tt max}\index{max|textbf}  takes as argument two real numbers and 
returns their maximum,
\item
{\tt min}\index{min|textbf}  takes as argument two real numbers and returns 
their minimum,
\item
{\tt abs}\index{abs} takes as argument a complex number and returns the 
modulus of the complex parameter (the absolute value if the complex is
real),
\item
{\tt sign}\index{sign|textbf}  takes as argument a real number and returns its
sign (+1 if it is positive, 0 if it is null, and -1 if it is
negative),
\item
{\tt floor}\index{floor|textbf} (or {\tt iPart}\index{iPart|textbf}) 
takes as argument a real number $r$, 
and returns  the largest integer $\leq r$,
\item
{\tt round}\index{round|textbf} takes as argument a real number and returns 
it's nearest integer,
\item
{\tt ceil} or {\tt ceiling}\index{ceil|textbf}\index{ceiling|textbf}  takes as
argument a real number and returns the smallest integer $\geq r$
\item
{\tt frac}\index{frac|textbf} (or {\tt fPart}\index{fPart|textbf})  takes as
argument a real number and returns its fractionnal part,
\item
{\tt trunc}\index{trunc|textbf} takes as 
argument a real number and returns the integer equal to the real without its 
fractionnal part,
\item
{\tt id}\index{id|textbf} is the identity function,
\item
{\tt sq}\index{sq|textbf} is the square function,
\item
{\tt sqrt}\index{sqrt|textbf} is the squareroot function,
\item
{\tt exp}\index{exp|textbf} is the exponential function,
\item
{\tt log}\index{log|textbf} or {\tt ln}\index{ln|textbf} is the 
natural logarithm function,
\item 
{\tt log10}\index{log10|textbf} is the base-10 logarithm function,
\item
{\tt logb}\index{logb|textbf} is the logarithm function where the second 
argument is the basis of the logarithm: 
{\tt logb(7,10)=log10(7)=log(7)/log(10)},
\item
{\tt sin}\index{sin|textbf} (resp. {\tt cos}\index{cosh|textbf},
{\tt tan}\index{tan|textbf})
is the sinus function, cosinus function, tangent function,
\item {\tt cot, sec, csc} are the cotangeant, secant, cosecant function
\item {\tt asin} (or {\tt arcsin})\index{asin|textbf}\index{arcsin|textbf},{
\tt acos} (or {\tt arccos})\index{acos|textbf}\index{arccos|textbf}, 
{\tt atan} (or {\tt arctan})\index{atan|textbf}\index{arctan|textbf}, 
{\tt acot, asec, acsc} are the inverse trigonometric functions (see 
section \ref{sec:trigo} for more info on trigonometric functions)
\item
{\tt sinh}\index{sinh|textbf} (resp. {\tt cosh}\index{cosh|textbf},
{\tt tanh}\index{tanh|textbf})
is the hyperbolic sinus function, cosinus function, tangent function,
\item
{\tt asinh} or {\tt arcsinh}\index{asinh|textbf}\index{arcsinh|textbf} (resp 
{\tt acosh} or {\tt arccosh}\index{acosh|textbf}\index{arccosh|textbf}, 
{\tt atanh} or {\tt arctanh}\index{atanh|textbf}\index{arctanh|textbf})
is the inverse function of {\tt sinh} (resp {\tt cosh}, {\tt tanh})
\end{itemize}

\subsection{Defining algebraic functions}
\subsubsection{Defining a function from $\mathbb{R}^p$ to $\mathbb{R}$}
\noindent For $p=1$, e.g. for $f\ :\ (x)\rightarrow x*\sin(x)$, input :
\begin{center}{\tt f(x):=x*sin(x)}\end{center}
Or :
\begin{center}{\tt f:=x->x*sin(x)}\end{center}
Output :
\begin{center}{\tt  (x)->x*sin(x)}\end{center}
If $p>1$, e.g. for $f\ :\ (x,y)\rightarrow x*\sin(y)$, input :
\begin{center}{\tt f(x,y):=x*sin(y)}\end{center}
Or :
\begin{center}{\tt f:=(x,y)->x*sin(y)}\end{center}
Output :
\begin{center}{\tt  (x,y)->x*sin(y)}\end{center}
{\bf Warning !!!} the expression after {\tt  -> } is not evaluated.
You should use {\tt unapply} if you expect the second member to
be evaluated before the function is defined.

\subsubsection{Defining a function from  $\mathbb{R}^p$ to $\mathbb{R}^q$}
For example:
\begin{itemize}
\item  To define the function $h\ :\ (x,y)\rightarrow (x*\cos(y),x*\sin(y))$.\\
 Input :
\begin{center}{\tt h(x,y):=(x*cos(y),x*sin(y))}\end{center}
Output :
\begin{center}{\tt expr(" (x,y)->\{ \\
  x*cos(y),x*sin(y);\\  
\}",0)}\end{center}
\item  To define the function $h\ :\ (x,y)\rightarrow [x*\cos(y),x*\sin(y)]$.\\
 Input :
\begin{center}{\tt h(x,y):=[x*cos(y),x*sin(y)];}\end{center}
Or :
\begin{center}{\tt h:=(x,y)->[x*cos(y),x*sin(y)];}\end{center}
Or :
\begin{center}{\tt h(x,y):=\{[x*cos(y),x*sin(y)]\};}\end{center}
Or : 
\begin{center}{\tt h:=(x,y)->return[x*cos(y),x*sin(y)];}\end{center}
Or : 
\begin{center}{\tt h(x,y):=\{return [x*cos(y),x*sin(y)];\}}\end{center}
Output :
\begin{center}{\tt   (x,y)->\{return([x*cos(y),x*sin(y)]);\}}\end{center}
\end{itemize}
{\bf Warning !!!} the expression after {\tt  -> } is not evaluated.

\subsubsection{Defining families of function from $\mathbb{R}^{p-1}$ 
to $\mathbb{R}^q$ using a function from $\mathbb{R}^p$ to $\mathbb{R}^q$}
Suppose that the function $f: (x,y) \rightarrow  f(x,y)$ is defined, 
and we want to define a family of functions $g(t)$ such
that $g(t)(y):=f(t,y)$ (i.e. $t$ is viewed as a parameter).
Since the expression after {\tt -> } (or {\tt :=})
is not evaluated, we should not define $g(t)$ by {\tt g(t):=y->f(t,y)},
we have to use the {\tt unapply} command.

For example, assuming that $f:(x,y)\rightarrow x\sin(y)$ and $g(t): y\rightarrow f(t,y)$, input :
\begin{center}{\tt f(x,y):=x*sin(y);g(t):=unapply(f(t,y),y)}\end{center}
Output :
\begin{center}{\tt ((x,y)->x*sin(y), (t)->unapply(f(t,y),y))}\end{center}
Input 
\begin{center}{\tt g(2)}\end{center}
Output :
\begin{center}{\tt   y->2$\cdot$ sin(y)}\end{center}
Input 
\begin{center}{\tt g(2)(1)}\end{center}
Output :
\begin{center}{\tt   2$\cdot$ sin(1)}\end{center}

Next example, suppose that the function 
$h: (x,y) \rightarrow  [x*\cos(y),x*\sin(y)]$ is defined, and 
we want to define the family of  functions $k(t)$ having $t$ as
parameter such that $k(t)(y):=h(t,y)$.
To define the function $h(x,y)$, input :
\begin{center}{\tt h(x,y):=(x*cos(y),x*sin(y))}\end{center}
To define properly the function  $k(t)$, input :
\begin{center}{\tt k(t):=unapply(h(x,t),x)}\end{center}
Output :
\begin{center}{\tt (t)->unapply(h(x,t),x)}\end{center}
Input 
\begin{center}{\tt k(2)}\end{center}
Output :
\begin{center}{\tt (x)->(x*cos(2),x*sin(2))}\end{center}
Input 
\begin{center}{\tt k(2)(1)}\end{center}
Output :
\begin{center}{\tt   (2*cos(1),2*sin(1))}\end{center}

\subsection{Composition of two functions: {\tt @}}\index{\@|textbf}
With {\tt Xcas}, the composition of functions is done with the infixed operator
{\tt @}.\\
Input :
\begin{center}{\tt (sq@sin+id)(x)}\end{center}
Output :
\begin{center}{\tt (sin(x))\verb|^|2+x}\end{center}  
Input :
\begin{center}{\tt (sin@sin)(pi/2)}\end{center}
Output :
\begin{center}{\tt sin(1)}\end{center}  

\subsection{Repeted function composition: {\tt @@}}\index{\@\@|textbf}
With {\tt Xcas}, the repeted composition of a function with itself
 $n \in {\mathbb N}$ times is done with the infixed operator {\tt @@}.\\
Input :
\begin{center}{\tt (sin@@3)(x)}\end{center}
Output :
\begin{center}{\tt sin(sin(sin(x)))}\end{center}  
Input :
\begin{center}{\tt (sin@@2)(pi/2)}\end{center}
Output :
\begin{center}{\tt sin(1)}\end{center} 

\subsection{Define a fonction with the history : {\tt as\_function\_of}}\index{as\_function\_of}
\noindent If an entry defined the variable {\tt a} and if in a later
entry defines the variable {\tt b} (supposed to be dependant on
{\tt a}), then
{\tt c:=as\_function\_of(b,a)} will define a function {\tt c} such that 
{\tt c(a)=b}.\\
Input :
\begin{center}{\tt  a:=sin(x)}\end{center}
Output :
\begin{center}{\tt  sin(x)}\end{center}
Input :
\begin{center}{\tt  b:=sqrt(1+a\verb|^|2)}\end{center}
Output :
\begin{center}{\tt  sqrt(1+sin(x)\verb|^|2)}\end{center}
Input :
\begin{center}{\tt  c:=as\_function\_of(b,a)}\end{center}
Output :
\begin{flushleft}{\tt (a)-> \\
\{ local NULL;\\ 
  return(sqrt(1+a\verb|^|2));\\  
\}}\end{flushleft}
Input :
\begin{center}{\tt  c(x)}\end{center}
Output :
\begin{center}{\tt sqrt(1+x\verb|^|2)}\end{center}
Input :
\begin{center}{\tt  a:=2}\end{center}
Output :
\begin{center}{\tt  2}\end{center}
Input :
\begin{center}{\tt  b:=1+a\verb|^|2}\end{center}
Output :
\begin{center}{\tt  5}\end{center}
Input :
\begin{center}{\tt  c:=as\_function\_of(b,a)}\end{center}
Output :
\begin{flushleft}{\tt (a)-> \\
\{ local NULL;\\ 
  return(sqrt(1+a\verb|^|2));\\  
\}}\end{flushleft}
Input :
\begin{center}{\tt  c(x)}\end{center}
Output :
\begin{center}{\tt 1+x\verb|^|2}\end{center}

{\bf Warning !!}\\
If the variable {\tt b} has been assigned
several times, the first affectation of {\tt b} following the last 
affectation of {\tt a} will be used. Moreover, the order used is the
order of validation of the commandlines, 
which may not be reflected by the Xcas interface
if you reused previous commandlines.\\
Input for example :\\
{\tt a:=2} then\\
{\tt b:=2*a+1} then\\
{\tt b:=3*a+2} then\\
{\tt  c:=as\_function\_of(b,a)}\\
Output :
\begin{center}{\tt (a)-> \{local NULL; return(2*a+1);\}}\end{center}
i.e. {\tt c(x)} is equal to {\tt 2*x+1}. \\
But, input :\\
{\tt a:=2} then\\
{\tt b:=2*a+1} then\\
{\tt a:=2} then\\
{\tt b:=3*a+2} then\\
{\tt  c:=as\_function\_of(b,a)}\\
Output :
\begin{center}{\tt (a)-> \{local NULL; return(3*a+2);\}}\end{center}
i.e. {\tt c(x)} is equal to {\tt 3*x+2}. \\
Hence the line where {\tt a} is define must be revalided before the good
definition of {\tt b}.  

\section{Derivation and applications.}
\subsection{Functional derivative  : {\tt function\_diff}}\index{function\_diff}
{\tt function\_diff} takes a function as argument.\\
{\tt function\_diff} returns the derivative function of this function.\\
Input :
\begin{center}{\tt function\_diff(sin)}\end{center}
Output :
\begin{center}{\tt (` x`)->cos(` x`)}\end{center}  
Input :
\begin{center}{\tt function\_diff(sin)(x)}\end{center}
Output :
\begin{center}{\tt cos(x)}\end{center}  
Input :
\begin{center}{\tt f(x):=x\verb|^|2+x*cos(x)}\end{center} 
\begin{center}{\tt function\_diff(f)}\end{center}
Output :
\begin{center}{\tt  (` x`)->2*` x`+cos(` x`)+` x`*(-(sin(` x`)))}\end{center}  
Input :
\begin{center}{\tt function\_diff(f)(x)}\end{center}
Output :
\begin{center}{\tt  cos(x)+x*(-(sin(x)))+2*x}\end{center}  
To define the function $g$ as $f'$, input :\\
\begin{center}{\tt g:=function\_diff(f)}\end{center}
The {\tt function\_diff} instruction has the same effect as
using the expression derivative in conjonction with {\tt unapply} :
\begin{center}{\tt g:=unapply(diff(f(x),x),x)}\end{center}
\begin{center}{\tt g(x)}\end{center} 
Output :
\begin{center}{\tt  cos(x)+x*(-(sin(x)))+2*x}\end{center}  
{\bf Warning !!!}\\
In {\tt Maple} mode, for compatibility,
{\tt D} may be used in place of {\tt function\_diff}.
For this reason, it is impossible to assign a variable named 
{\tt D} in {\tt Maple} mode (hence you can not name a 
geometric object {\tt D}).

\subsection{Length of an arc : {\tt arcLen}}\index{arcLen}
\noindent {\tt arcLen} takes four arguments : an expression $ex$ (resp a list
of two expressions $[ex1,ex2]$), the name of a parameter and two values $a$
and $b$ of this parameter.\\
{\tt arcLen} computes the length of the curve define by the equation 
$y=f(x)=ex$ (resp by $x=ex1,y=ex2$) when the parameter values varies from $a$ 
to $b$, using the formula
{\tt arcLen(f(x),x,a,b)=}\\  
{\tt integrate(sqrt(diff(f(x),x)\verb|^|2+1),x,a,b)}\\
or \\
{\tt integrate(sqrt(diff(x(t),t)\verb|^|2+diff(y(t),t)\verb|^|2),t,a,b)}.\\

{\bf Examples}
\begin{itemize}
\item Compute the length of the parabola $y=x^2$ from $x=0$ to $x=1$.\\
Input :
\begin{center}{\tt arcLen(x\verb|^|2,x,0,1)}\end{center}
or
\begin{center}{\tt arcLen([t,t\verb|^|2],t,0,1)}\end{center}
Output :
\begin{center}{\tt -1/4*log(sqrt(5)-2)-(-(sqrt(5)))/2}\end{center} 
\item Compute the length of the curve $y=\cosh(x)$ from $x=0$ to 
$x=\ln(2)$.\\
Input :
\begin{center}{\tt arcLen(cosh(x),x,0,log(2))}\end{center}
Output :
\begin{center}{\tt 3/4}\end{center}
\item Compute the length of the circle $x=\cos(t),y=\sin(t)$ from $t=0$ to 
$t=2*\pi$.\\
Input :
\begin{center}{\tt arcLen([cos(t),sin(t)],t,0,2*pi)}\end{center}
Output :
\begin{center}{\tt 2*pi}\end{center}
\end{itemize}

\subsection{Maximum and minimum of an expression: {\tt fMax fMin}}\index{fMax}\index{fMin} 
\noindent{\tt fMax} and {\tt fMin} take one or two arguments : an expression 
of a variable and the name of this variable (by default {\tt x}).\\
{\tt fMax} returns the abscissa 
of a maximum of the expression.\\
{\tt fMin} returns the abscissa 
of a minimum of the expression.\\
Input :
\begin{center}{\tt fMax(sin(x),x)}\end{center}
Or :
\begin{center}{\tt fMax(sin(x))}\end{center}
Or :
\begin{center}{\tt fMax(sin(y),y)}\end{center}
Output :
\begin{center}{\tt pi/2}\end{center} 
Input :
\begin{center}{\tt fMin(sin(x),x)}\end{center}
Or :
\begin{center}{\tt fMin(sin(x))}\end{center}
Or :
\begin{center}{\tt fMin(sin(y),y)}\end{center}
Output :
\begin{center}{\tt -pi/2}\end{center} 
Input :
\begin{center}{\tt fMin(sin(x)\verb|^|2,x)}\end{center}
Output :
\begin{center}{\tt 0}\end{center}

\subsection{Table of values and graph : {\tt tablefunc} and {\tt plotfunc}}\index{tablefunc|textbf}\index{plotfunc}   
{\tt tablefunc} is a special command that should be run from inside
the spreadsheet. It returns the evaluation of an expression $ex$ 
depending on a variable $x$ for $x=x_0,\ x_0+h,....$~:
\begin{center}
{\tt tablefunc(ex,x,x\_0,h)} or {\tt tablefunc(ex,x)}
\end{center}
In the latter case, the default value for ${\tt x_0}$
is the default minimum value of $x$ from the graphic configuration
and the default value for the step $h$ is 0.1 times the difference
between the default maximum and minimum values of $x$ (from the
graphic configuration).\\
Example: type {\tt Alt+t} to open a spreadsheet if none are open.
Then select a cell of the spreadsheet (for example {\tt C0}) and to get
the table of {\tt "sinus"}, input in the command line of the spreadsheet : 
\begin{center}{\tt tablefunc(sin(x),x)}\end{center}
This will fill two columns with the numeric value of {\tt x} and 
{\tt sin(x)} :
\begin{itemize}
\item in the first column the variable {\tt x}, 
the value of the step {\tt h}
(1.0),  the minimum value of $x$ (-5.0), then a formula, for example 
{\tt=C2+C\$1}, and the remaining rows 
of the column is filled by pasting this formula.
\item in the next column the function {\tt sin(x)}, the word
"Tablefunc", a formula, 
for example {\tt =evalf(subst(D\$0,C\$0,C2))}, and the remaining rows
of the column are filled by pasting this formula.
\end{itemize}
Hence the values of {\tt sin(x)} are on the same rows as the values 
of {\tt x}. Note that the step and begin value and the expression 
may be easily changed by modifying the correspondant cell.

The graphic representation may be plotted with the {\tt plotfunc} command 
(see \ref{sec:plotfunc}).

\subsection{Derivative and partial derivative}\index{diff|textbf}\index{derive|textbf}\index{deriver|textbf}
\noindent{\tt diff} or {\tt derive} may have one or two arguments 
to compute a first order derivative (or first order partial
derivative) of an expression or of a list of expressions, 
or several arguments to compute 
the $n$-th partial derivative of an expression or list of expressions.

\subsubsection{Derivative and first order partial derivative : {\tt diff derive deriver}}
{\tt diff} (or {\tt derive}) takes two arguments : an expression and a variable
(resp a vector of the variable name) (see several variable functions in
 \ref{sec:plusvar}). If only one argument is provided, the derivative
is taken with respect to {\tt x}\\
{\tt diff} (or {\tt derive}) returns the derivative (resp a vector of 
derivative) of the expression with respect to the variable (resp with respect 
to each variable) given as second argument.\\
Examples :
\begin{itemize}
\item Compute :
$$\frac {\partial (x.y^2.z^3+x.y.z)}{\partial z}$$
Input :
\begin{center}{\tt  diff(x*y \verb|^|2*z\verb|^|3+x*y*z,z)}\end{center}
Output :
\begin{center}{\tt x*y\verb|^|2*3*z\verb|^|2+x*y}\end{center}
\item Compute the 3 first order partial derivatives of $x*y^2*z^3+x*y*z$.\\
Input :
\begin{center}{\tt  diff(x*y\verb|^|2*z\verb|^|3+x*y,[x,y,z])}\end{center}
Output :
\begin{center}{\tt [y\verb|^|2*z\verb|^|3+y*z, x*2*y*z\verb|^|3+x*z, x*y\verb|^|2*3*z\verb|^|2+x*y]}\end{center}
% \item Compute :
% $$\frac {\partial^3 (x.y^2.z^3+x.y.z)}{\partial y\partial^2 z}$$
% Input :
% \begin{center}{\tt  diff(x*y \verb|^|2*z\verb|^|3+x*y*z,y,z\$2)}\end{center}
% Output :
% \begin{center}{\tt x*2*y*3*2*z}\end{center}
\end{itemize}

\subsubsection{Derivative and $n$-th order
partial derivative : {\tt diff derive deriver}}\index{\$}
\noindent {\tt derive} (or {\tt diff}) may take more than two arguments : an
expression and the names of the derivation variables (each variable
may be followed by \$$n$ to indicate the number $n$ of derivations).\\
{\tt diff} returns the partial derivative of the expression with respect to 
the variables given after the first argument.

The notation \$ is usefull if you want to derive $k$ times with
respect to the same variable, instead of entering $k$ times the
same variable name, one enters the variable name followed by {\tt \$k},
for example {\tt x\$3} instead of {\tt(x,x,x)}. 
Each variable may be followed by a \$, for example 
{\tt diff(exp(x*y),x\$3,y\$2,z)} is the same as 
{\tt diff(exp(x*y),x,x,x,y,y,z)}\\
{\bf Examples}
\begin{itemize}
\item Compute :
$$\frac {\partial^2 (x.y^2.z^3+x.y.z)}{\partial x\partial z}$$
Input :
\begin{center}{\tt diff(x*y \verb|^|2*z\verb|^|3+x*y*z,x,z)}\end{center}
Output  :
\begin{center}{\tt y\verb|^|2*3*z\verb|^|2+y}\end{center}
\item Compute :
$$\frac {\partial^3 (x.y^2.z^3+x.y.z)}{\partial x\partial^2 z}$$
Input :
\begin{center}{\tt  diff(x*y \verb|^|2*z\verb|^|3+x*y*z,x,z,z)}\end{center}
Or input :
\begin{center}{\tt  diff(x*y \verb|^|2*z\verb|^|3+x*y*z,x,z\$2)}\end{center}
Output  :
\begin{center}{\tt y\verb|^|2*3*2*z}\end{center}
\item Compute the third derivative of :
$$\frac{1}{x^2+2}$$
Input :
\begin{center}{\tt  normal(diff((1)/(x\verb|^|2+2),x,x,x))}\end{center}
Or :
\begin{center}{\tt  normal(diff((1)/(x\verb|^|2+2),x\$3))}\end{center}
Output  :
\begin{center}{\tt (-24*x\verb|^|3+48*x)/(x\verb|^|8+8*x\verb|^|6+24*x\verb|^|4+32*x\verb|^|2+16)}\end{center}
\end{itemize}
{\bf Remark}
\begin{itemize}
\item 
Note the difference between {\tt diff(f,x,y)} and {\tt  diff(f,[x,y])} :\\
{\tt diff}$(f,x,y)$ returns $\displaystyle \frac{\partial^2(f)}{\partial x\partial y}$ and\\
{\tt diff}$(f,[x,y])$ returns
$\displaystyle[\frac{\partial(f)}{\partial x},\frac{\partial
  (f)}{\partial y}]$ 
\item Never define a derivative function with {\tt
    f1(x):=diff(f(x),x)}.
Indeed, {\tt x} would mean two different things Xcas is unable to
deal with: the variable name to
define the $f_1$ function and the differentiation variable.
The right way to define a derivative is either with {\tt
  function\_diff} or:
\begin{center}
{\tt f1:=unapply(diff(f(x),x),x)}
\end{center}
\end{itemize}

\section{Integration}
\subsection{Antiderivative and definite integral : {\tt integrate int Int}}\index{integrate}\index{Int}\index{int}
\noindent{\tt integrate} (or {\tt int}) compute the primitive
or a definite integral. A difference between the two 
commands is that, if you input {\tt quest()}, just after the evaluation of 
{\tt  integrate}, the answer is written with the $\int$ symbol.

{\tt integrate} (or {\tt int} or {\tt Int}) takes one, two or four arguments.
\begin{itemize}
\item with one or two arguments\\
an expression or an expression and 
the name of a variable (by default {\tt x}),\\
{\tt integrate} (or {\tt int}) returns a primitive of the expression with 
respect to the  variable given as second argument.\\
Input :
\begin{center}{\tt integrate(x\verb|^|2)}\end{center}
Output  :
\begin{center}{\tt x\verb|^|3/3}\end{center}
Input :
\begin{center}{\tt integrate(t\verb|^|2,t)}\end{center}
Output  :
\begin{center}{\tt t\verb|^|3/3}\end{center}
\item with four arguments :\\
an expression, a name of a variable and the bounds of the definite integral,\\ 
{\tt integrate} (or {\tt int}) returns the exact
value of the definite integral if the computation was successfull or
an unevaluated integral otherwise.\\
Input :
\begin{center}{\tt integrate(x\verb|^|2,x,1,2)}\end{center}
Output  :
\begin{center}{\tt 7/3}\end{center}
Input :
\begin{center}{\tt integrate(1/(sin(x)+2),x,0,2*pi)}\end{center}
Output  after simplification (with the {\tt simplify} command) :
\begin{center}{\tt 2*pi*sqrt(3)/3}\end{center}
\end{itemize}


{\tt Int} is the inert form of {\tt integrate}, it prevents evaluation
for example to avoid a symbolic computation that might not be
successfull if you just want a numeric
evaluation.\\
Input :
\begin{center}{\tt evalf(Int(exp(x\verb|^|2),x,0,1))}\end{center}
Or :
\begin{center}{\tt evalf(int(exp(x\verb|^|2),x,0,1))}\end{center}
Output  :
\begin{center}{\tt 1.46265174591}\end{center}

{\bf Exercise 1}\\
Let $$f(x)=\frac {x}{x^2-1}+\ln(\frac {x+1}{x-1})$$
Find a primitive of $f$.\\
Input :
\begin{center}{\tt int(x/(x\verb|^|2-1)+ln((x+1)/(x-1)))}\end{center}
Output : 
\begin{center}{\tt x*log((x+1)/(x-1))+log(x\verb|^|2-1)+1/2*log(2*x\verb|^|2/2-1)}\end{center}
Or define the function {\tt f}, input :
\begin{center}{\tt f(x):=x/(x\verb|^|2-1)+ln((x+1)/(x-1))}\end{center}
then input :
\begin{center}{\tt int(f(x))}\end{center}
Output of course the same result.\\
{\bf Warning}\\
For {\tt Xcas}, {\tt log} is the natural logarithm (like {\tt ln}),
as {\tt log10} is 10-basis logarithm

{\bf Exercise 2}\\
Compute :
$$\int \frac {2}{x^6+2 \cdot x^4+x^2} \ dx $$
Input :
\begin{center}{\tt int(2/(x\verb|^|6+2*x\verb|^|4+x\verb|^|2))}\end{center}
Output :
\begin{center}{\tt 2*((3*x\verb|^|2+2)/(-(2*(x\verb|^|3+x)))+-3/2*atan(x))}\end{center}

{\bf Exercise 3}\\
Compute :
$$\int \frac {1}{\sin(x)+\sin(2 \cdot x )} \ dx $$
Input :
\begin{center}{\tt integrate(1/(sin(x)+sin(2*x )))}\end{center}
Output :
\begin{center}{\tt (1/-3*log((tan(x/2))\verb|^|2-3)+1/12*log((tan(x/2))\verb|^|2))*2}\end{center} 

% \subsection{Primitive and definite integral : {\tt risch}}\index{risch}
% \noindent{\tt risch}  compute a primitive or a definite integral using the
% Risch algorithm.\\
% Input :
% \begin{center}{\tt risch(x\verb|^|2)}\end{center}
% Output  :
% \begin{center}{\tt x\verb|^|3/3}\end{center}
% Input :
% \begin{center}{\tt risch(x\verb|^|2,x,0,1)}\end{center}
% Output  :
% \begin{center}{\tt 1/3}\end{center}
% Input :
% \begin{center}{\tt risch(exp(-x\verb|^|2))}\end{center}
% Output  :
% \begin{center}{\tt $\int$ exp(x\verb|^|2) dx}\end{center}
% that is to say that $\exp(-x^2)$ has no primitive expressing
% with usual functions.

\subsection{Discrete summation: {\tt sum}}\index{sum|textbf}
\noindent{\tt sum} takes two or four arguments :
\begin{itemize}
\item four arguments\\
an expression, the name of the variable (for 
example {\tt n}), and the bounds (for example {\tt a} and {\tt b}).\\
{\tt sum} returns the discrete sum of this expression with respect to
the variable from $a$ to $b$.\\
Input :
\begin{center}{\tt sum(1,k,-2,n) }\end{center}
Output  :
\begin{center}{\tt n+1+2}\end{center}
Input :
\begin{center}{\tt normal(sum(2*k-1,k,1,n))}\end{center}
Output  :
\begin{center}{\tt n\verb|^|2}\end{center}
Input :
\begin{center}{\tt sum(1/(n\verb|^|2),n,1,10)}\end{center}
Output  :
\begin{center}{\tt 1968329/1270080}\end{center} 
Input :
\begin{center}{\tt sum(1/(n\verb|^|2),n,1,+(infinity)) }\end{center}
Output  :
\begin{center}{\tt pi\verb|^|2/6}\end{center}
Input :
\begin{center}{\tt sum(1/(n\verb|^|3-n),n,2,10) }\end{center}
Output  :
\begin{center}{\tt 27/110}\end{center} 
Input :
\begin{center}{\tt sum(1/(n\verb|^|3-n),n,1,+(infinity)) }\end{center}
Output  :
\begin{center}{\tt 1/4}\end{center}
This result comes from the decomposition of ${\tt 1/(n\verb|^|3-n)}$.\\
Input :
\begin{center}{\tt partfrac(1/(n\verb|^|3-n)) }\end{center}
Output  :
\begin{center}{\tt 1/(2*(n+1))-1/n+1/(2*(n-1))}\end{center}
Hence :\\
$\displaystyle \sum_{n=2}^N -\frac{1}{n}=-\sum_{n=1}^{N-1} \frac{1}{n+1}=-\frac{1}{2}-\sum_{n=2}^{N-2} \frac{1}{n+1}-\frac{1}{N}$\\
$\displaystyle \frac{1}{2}*\sum_{n=2}^N \frac{1}{n-1}=\frac{1}{2}*(\sum_{n=0}^{N-2} \frac{1}{n+1})=\frac{1}{2}*(1+\frac{1}{2}+\sum_{n=2}^{N-2}\frac{1}{n+1})$\\
$\displaystyle \frac{1}{2}*\sum_{n=2}^N \frac{1}{n+1}=\frac{1}{2}*(\sum_{n=2}^{N-2} \frac{1}{n+1}+\frac{1}{N}+\frac{1}{N+1})$\\
After simplification by $\sum_{n=2}^{N-2}$, it remains :\\
 $\displaystyle -\frac{1}{2}+\frac{1}{2}*(1+\frac{1}{2})-\frac{1}{N}+\frac{1}{2}*(\frac{1}{N}+\frac{1}{N+1})=\frac{1}{4}-\frac{1}{2N(N+1)}$\\
Therefore :
\begin{itemize}
\item for $N=10$ the sum is equal to : $1/4-1/220=27/110$
\item for $N=+\infty$ the sum is equal to : $1/4$ because $\frac{1}{2N(N+1)}$ 
approaches zero when $N$ approaches infinity.
\end{itemize}

\item two arguments \\
an expression of one variable (for example $f$) and the name of this
 variable (for example $x$).\\
{\tt sum} returns the discrete antiderivative of this expression, i.e. 
an expression $G$ such that $G_{|x=n+1}-G_{|x=n}=f_{|x=n}$.\\ 
Input :
\begin{center}{\tt sum(1/(x*(x+1)),x)}\end{center}
Output  :
\begin{center}{\tt -1/x}\end{center}
\end{itemize}

\subsection{Riemann sum : {\tt sum\_riemann}}\index{sum\_riemann}
\noindent{\tt sum\_riemann} takes two arguments : an expression depending of 
two variables and the list of the name of these two variables.\\ 
{\tt sum\_riemann(expression(n,k),[n,k])} returns in the neighboorhoud of
 $ n=+\infty$ an equivalent of $\sum_{k=1}^n expression(n,k)$ (or of
$ \sum_{k=0}^{n-1} expression(n,k)$ or of $ \sum_{k=1}^{n-1} expression(n,k)$) 
when the sum is looked as a Riemann sum associated to a continue 
function defined on [0,1] or returns  
{\tt "it is probably not a Riemann sum"} when the resarch is unavailing.\\
{\bf Exercise 1}\\
Suppose $\displaystyle S_n=\sum_{k=1}^n \frac{k^2}{n^3}$.\\
Compute $\displaystyle \lim_{n \rightarrow  +\infty} S_n$.\\
Input :
\begin{center}{\tt sum\_riemann(k\verb|^|2/n\verb|^|3,[n,k])}\end{center}
Output  :
\begin{center}{\tt 1/3}\end{center}
{\bf Exercise 2}\\
Suppose $\displaystyle S_n=\sum_{k=1}^n \frac{k^3}{n^4}$.\\
Compute $\displaystyle \lim_{n \rightarrow  +\infty} S_n$.\\
Input :
\begin{center}{\tt sum\_riemann(k\verb|^|3/n\verb|^|4,[n,k])}\end{center}
Output  :
\begin{center}{\tt 1/4}\end{center}
{\bf Exercise 3}\\
Compute 
$\displaystyle \lim_{n \rightarrow  +\infty}(\frac{1}{n+1}+\frac{1}{n+2}+...+\frac{1}{n+n})$.\\
Input :
\begin{center}{\tt sum\_riemann(1/(n+k),[n,k])}\end{center}
Output :
\begin{center}{\tt log(2)}\end{center}
{\bf Exercise 4}\\
Suppose $\displaystyle S_n=\sum_{k=1}^n \frac{32n^3}{16n^4-k^4}$.\\
Compute $\displaystyle \lim_{n \rightarrow  +\infty} S_n$.\\
Input :
\begin{center}{\tt sum\_riemann(32*n\verb|^|3/(16*n\verb|^|4-k\verb|^|4),[n,k])}\end{center}
Output :
\begin{center}{\tt 2*atan(1/2)+log(3)}\end{center}

\subsection{Integration by parts : {\tt ibpdv} et {\tt ibpu}}
\subsubsection{\tt ibpdv}\index{ibpdv}
\noindent{\tt ibpdv} is used to search the primitive of an expression written 
as $u(x).v'(x)$.\\
{\tt ibpdv} takes two arguments :
\begin{itemize}
\item an expression 
 $u(x).v'(x)$ and $v(x)$ (or a list of two expressions 
$[F(x), u(x)*v'(x)]$ and $v(x)$),
\item or an expression $g(x)$ and $0$ (or a list of two expressions 
$[F(x), g(x)]$ and $0$).
\end{itemize}
{\tt ibpdv} returns :
\begin{itemize}
\item if $v(x) \neq 0$, the list $[u(x).v(x),-v(x).u'(x)]$ (or 
$[F(x)+u(x).v(x),-v(x).u'(x)]$),
\item if the second argument is zero, a primitive of the first argument 
$g(x)$ (or $F(x)$+a primitive of $g(x)$) :\\
hence, {\tt ibpdv(g(x),0)} returns a primitive {\tt G(x)} of {\tt g(x)} or \\
{\tt ibpdv([F(x),g(x)],0)} returns {\tt F(x)+G(x)} where {\tt diff(G(x))=g(x)}.
\end{itemize}
Hence, {\tt ibpdv} returns the terms computed in an integration by parts, 
with the possibility of doing several {\tt ibpdv} succesively.\\
When the answer of {\tt ibpdv(u(x)*v'(x),v(x))} is computed, to obtain a 
primitive of $u(x).v'(x)$, it remains to 
compute the integral of the second term of this answer and then, to sum this 
integral with the first term of this answer : to do this, just use  
{\tt ibpdv} command with the answer as first argument and  
a new $v(x)$ (or $0$ to terminate the integration) as second argument.\\ 
Input :
\begin{center}{\tt ibpdv(ln(x),x) }\end{center}
Output :
\begin{center}{\tt [x.ln(x),-1]}\end{center}
then
\begin{center}{\tt ibpdv([x.ln(x),-1],0) }\end{center}
Output :
\begin{center}{\tt -x+x.ln(x)}\end{center}
{\bf Remark}\\
 When the first argument of {\tt ibpdv} is a list of two elements, {\tt ibpdv} 
works only on the last element of this list and adds the integrated term to
the first element of this list.  
(therefore it is possible to do several {\tt ibpdv} successively).\\
For example :\\
{\tt ibpdv((log(x))\verb|^|2,x) = [x*(log(x))\verb|^|2,-(2*log(x))]}\\ 
it remains to integrate {\tt -(2*log(x))}, the input :\\
{\tt ibpdv(ans(),x)} or input :\\
{\tt ibpdv([x*(log(x))\verb|^|2,-(2*log(x))],x)}\\
Output :\\
{\tt [x*(log(x))\verb|^|2+x*(-(2*log(x))),2]}\\
and it remains to integrate {\tt 2}, hence input {\tt ibpdv(ans(),0)} or\\
{\tt ibpdv([x*(log(x))\verb|^|2+x*(-(2*log(x))),2],0)}.\\
Output :
{\tt x*(log(x))\verb|^|2+x*(-(2*log(x)))+2*x}
\subsubsection{\tt ibpu}\index{ibpu}
\noindent{\tt ibpu} is used to search the primitive of an expression written 
as $u(x).v'(x)$
{\tt ibpu} takes two arguments  : 
\begin{itemize}
\item an expression $u(x).v'(x)$ and $u(x)$ (or a list of two expressions 
$[F(x), u(x)*v'(x)]$ and $u(x)$),
\item an expression $g(x)$ and $0$ (or a list of two expressions $[F(x) g(x)]$ 
and $0$).
\end{itemize}
{\tt ibpu} returns :
\begin{itemize}
\item if $u(x) \neq 0$, the list $[u(x).v(x),-v(x).u'(x)]$ 
(or returns the list $[F(x)+u(x).v(x),-v(x).u'(x)]$),
\item if the second  argument is zero, a primitive of the first argument $g(x)$
(or $F(x)$+a primitive of $g(x)$):\\ 
{\tt ibpu(g(x),0)} returns {\tt G(x)} where {\tt diff(G(x))=g(x)} or\\
 {\tt ibpu([F(x),g(x)],0)} returns {\tt F(x)+G(x)} where {\tt diff(G(x))=g(x)}.
\end{itemize}
Hence, {\tt ibpu} returns the terms computed in an integration by parts, 
with the possibility of doing several {\tt ibpu} succesively.\\
When the answer of {\tt ibpu(u(x)*v'(x),u(x))} is computed, to obtain a 
primitive of $u(x).v'(x)$, it remains to 
compute the integral of the second term of this answer and then, to sum this 
integral with the first term of this answer : to do this, just use  
{\tt ibpu} command with the answer as first argument and  
a new $u(x)$ (or $0$ to terminate the integration) as second argument.\\ 
Input :
\begin{center}{\tt ibpu(ln(x),ln(x)) }\end{center}
Output :
\begin{center}{\tt [x.ln(x),-1]}\end{center}
then
\begin{center}{\tt ibpu([x.ln(x),-1],0) }\end{center}
Output :
\begin{center}{\tt -x+x.ln(x)}\end{center}
{\bf Remark}\\
When the first argument of {\tt ibpu} is a list of two elements, {\tt ibpu} 
works only on the last element of this list and adds the integrated term to
the first element of this list.  
(therefore it is possible to do several {\tt ibpu} successively).\\
For example :\\
{\tt ibpu((log(x))\verb|^|2,log(x)) = [x*(log(x))\verb|^|2,-(2*log(x))]}\\ 
it remains to integrate {\tt -(2*log(x))}, hence input : \\
{\tt ibpu(ans(),log(x))}
 or input :\\
{\tt ibpu([x*(log(x))\verb|^|2,-(2*log(x))],log(x))}\\
Output :\\
{\tt [x*(log(x))\verb|^|2+x*(-(2*log(x))),2]}\\
it remains to integrate  {\tt 2}, hence input :\\
{\tt ibpu(ans(),0)} or input :\\
{\tt ibpu([x*(log(x))\verb|^|2+x*(-(2*log(x))),2],0)}.\\
Output :
{\tt x*(log(x))\verb|^|2+x*(-(2*log(x)))+2*x}

\subsection{Change of variables : {\tt subst}}
See the {\tt subst} command  in the section \ref{sec:subst}. 

\section{Limits}
\subsection{Limites : {\tt limit}}\index{limit|textbf}\label{sec:limit}

{\tt limit} compute the limit of an expression in a finite or infinite point.
It is also possible with an optional argument to  compute unidirectional
limit (1 for right limit  and -1 for left limit .\\
{\tt limit} takes three or four arguments :\\
an expression, the name of a variable (for example {\tt x}), the limit point 
(for example {\tt a}) and an optional argument, by default {\tt 0}, to 
indicate if the limit is unidirectional. 
This argument is equal to 
{\tt -1} for a left limit ({\tt x<a}) or  is equal to {\tt  1} 
for a right limit ({\tt x>a}) or is equal to {\tt 0} for a limite.\\
{\tt limit} returns the limit of the expression when the  variable (for example
{\tt x}) approachs the limit point (for example {\tt a}).\\
{\bf Remark}\\
It is also possible to put {\tt x=a} as  argument instead of {\tt x,a}, hence :
{\tt limit} takes also as arguments an expression depending of a variable, 
an equality (variable =value of the limit point) and perhaps 1 or -1 to 
indicate the direction.\\ 
Input :
\begin{center}{\tt limit(1/x,x,0,-1)}\end{center}
or
\begin{center}{\tt limit(1/x,x=0,-1)}\end{center}
Output :
\begin{center}{\tt -(infinity)}\end{center} 
Input :
\begin{center}{\tt limit(1/x,x,0,1)}\end{center}
or
\begin{center}{\tt limit(1/x,x=0,1)}\end{center}
Output :
\begin{center}{\tt +(infinity)}\end{center} 
Input :
\begin{center}{\tt limit(1/x,x,0,0)}\end{center}
or
\begin{center}{\tt limit(1/x,x,0)}\end{center}
or
\begin{center}{\tt limit(1/x,x=0)}\end{center}
Output :
\begin{center}{\tt infinity}\end{center} 
Hence, {\tt abs(1/x)} approachs $+\infty$ when $x$ approachs $0$.

{\bf Exercises} :
\begin{itemize}
\item Find for $n>2$, the limit  when $x$ approachs $0$ of :
$$ \frac{n\tan(x)-\tan(nx)}{\sin(nx)-n\sin(x)}$$
Input :
\begin{center}{\tt limit((n*tan(x)-tan(n*x))/(sin(n*x)-n*sin(x)),x=0)}\end{center}
Output :
\begin{center}{\tt 2 }\end{center}
\item Find the limit  when $x$ approachs $+\infty$ of :
$$\sqrt{x+\sqrt{x+\sqrt x}}-\sqrt x$$ 
Input :
\begin{center}{\tt limit(sqrt(x+sqrt(x+sqrt(x)))-sqrt(x),x=+infinity)}\end{center}
Output :
\begin{center}{\tt 1/2 }\end{center}
\item Find the limit  when $x$ approachs 0 of :
$$\frac{\sqrt{1+x+x^2/2}-\exp(x/2)}{(1-\cos(x))\sin(x)}$$ 
Input :
\begin{center}{\tt limit((sqrt(1+x+x\verb|^|2/2)-exp(x/2))/((1-cos(x))*sin(x)),x,0)}\end{center}
Output :
\begin{center}{\tt -1/6 }\end{center}
\end{itemize}

{\bf Remark}\\
To compute limit, it is better sometimes to quote the first argument.\\  
Input  :
\begin{center}{\tt limit('(2*x-1)*exp(1/(x-1))',x=+infinity)}\end{center}
Note that the first argument is quoted,  because it is better that
this argument is not simplified (i.e. not evaluated).\\
Output :
\begin{center}{\tt +(infinity)}\end{center}

\subsection{Integral and limit}\index{limit} \index{limite} 
Just two examples :\\
\begin{itemize}
\item Find the limit, when $a$ approachs $+\infty$, of :
$$  \int _2^a \frac {1}{x^2}\ dx$$
Input :
\begin{center}{\tt limit(integrate(1/(x\verb|^|2),x,2,a),a,+(infinity))}\end{center}
Output (if {\tt a} is not formal then input {\tt purge(a)}) :
\begin{center}{\tt 1/2}\end{center}
\item Find the limit, when $a$ approachs $+\infty$, of :
$$  \int _2^a (\frac {x}{x^2-1}+\ln(\frac {x+1}{x-1}))\ dx$$
Input :
\begin{center}{\tt limit(integrate(x/(x\verb|^|2-1)+log((x+1)/(x-1)),x,2,a),}\end{center} 
\begin{center}{\tt a,+(infinity))}\end{center} 
Output (if {\tt a} is not formal then input {\tt purge(a)}) :
\begin{center}{\tt +(infinity)}\end{center}
\end{itemize}

\section{Rewriting transcendental and trigonometric expressions}
\subsection{Expand a transcendental and trigonometric expression : {\tt texpand tExpand}}\index{texpand|textbf}\index{tExpand|textbf}
\noindent{\tt texpand} or {\tt tExpand} takes as argument an
expression containing transcendental or trigonometric functions.\\
{\tt texpand} or {\tt tExpand} expands these functions, like simultaneous
calling {\tt expexpand}, {\tt lnexpand} and {\tt trigexpand}, 
for example,  $\ln(x^n)$ becomes $\ n\ln(x)$, $\exp(nx)$ 
becomes $\ \exp(x)^n$, $\sin(2x)$ becomes $\ 2\sin(x)\cos(x)$...\\
{\bf Examples} :\\
\begin{itemize}
\item
\begin{enumerate}
\item Expand $\cos(x+y)$.\\
Input :
\begin{center}{\tt texpand(cos(x+y))}\end{center}
Output :
\begin{center}{\tt cos(x)*cos(y)-sin(x)*sin(y)}\end{center}
\item Expand $\cos(3x)$.\\
Input :
\begin{center}{\tt texpand(cos(3*x))}\end{center}
Output :
\begin{center}{\tt 4*(cos(x))\verb|^| 3-3*cos(x)}\end{center}
\item Expand $\displaystyle \frac{\sin(3*x)+\sin(7*x)}{\sin(5*x)}$.\\
Input :
\begin{center}{\tt texpand((sin(3*x)+sin(7*x))/sin(5*x))}\end{center}
Output
\begin{center}{\tt (4*(cos(x))\verb|^|2-1)*(sin(x)/(16*(cos(x))\verb|^|4- 12*(cos(x))\verb|^|2+1))/sin(x)+(64*(cos(x))\verb|^|6- 80*(cos(x))\verb|^|4+24*(cos(x))\verb|^|2-1)*sin(x)/ (16*(cos(x))\verb|^|4-12*(cos(x))\verb|^|2+1)/sin(x)}\end{center}
Output, after a simplification with {\tt normal(ans())} :
\begin{center}{\tt 4*(cos(x))\verb|^|2-2}\end{center}
\end{enumerate}
\item \begin{enumerate}
\item Expand $\exp(x+y)$.\\
Input :
\begin{center}{\tt texpand(exp(x+y))}\end{center}
Output :
\begin{center}{\tt exp(x)*exp(y)}\end{center}
\item Expand $\ln(x\times y)$.\\
Input :
\begin{center}{\tt texpand(log(x*y))}\end{center}
Output :
\begin{center}{\tt log(x)+log(y)}\end{center}
\item Expand $\ln(x^n)$.\\
Input :
\begin{center}{\tt  texpand(ln(x\verb|^|n))}\end{center}
Output :
\begin{center}{\tt n*ln(x)}\end{center}
\item Expand $\ln((e2)+\exp(2*\ln(2))+exp(\ln(3)+\ln(2)))$.\\
Input :
\begin{center}{\tt texpand(log(e\verb|^|2)+exp(2*log(2))+exp(log(3)+log(2)))}\end{center}
Output :
\begin{center}{\tt 6+3*2}\end{center}
Or input :
\begin{center}{\tt texpand(log(e\verb|^|2)+exp(2*log(2)))+ lncollect(exp(log(3)+log(2)))}\end{center}
Output :
\begin{center}{\tt 12}\end{center}
\end{enumerate}
\item 
Expand $\exp(x+y)+\cos(x+y)+\ln(3x2)$.\\
Input :
\begin{center}{\tt texpand(exp(x+y)+cos(x+y)+ln(3*x\verb|^|2))}\end{center}
Output :
\begin{center}{\tt cos(x)*cos(y)-sin(x)*sin(y)+exp(x)*exp(y)+ ln(3)+2*ln(x)}\end{center}
\end{itemize}

\subsection{Combine terms of same type  : {\tt combine}}\index{combine}\index{exp@{\sl exp}|textbf}\index{log@{\sl log}|textbf}\index{ln@{\sl ln}|textbf}\index{sin@{\sl sin}|textbf}\index{cos@{\sl cos}|textbf}\index{trig@{\sl trig}|textbf}
\noindent{\tt combine} takes two arguments : an expression and 
the name of a function or class of functions
{\tt exp,log,ln, sin,cos,trig}.\\
Whenever possible, {\tt combine} put together subexpressions corresponding
to the second argument:
\begin{itemize}
\item {\tt combine(expr,ln)} or {\tt combine(expr,log)} gives the same result 
as {\tt lncollect(expr)}
\item
{\tt combine(expr,trig)} or {\tt combine(expr,sin)}  or {\tt combine(expr,cos)}
gives the same result as {\tt tcollect(expr)}.
\end{itemize}
Input :
\begin{center}{\tt combine(exp(x)*exp(y)+sin(x)*cos(x)+ln(x)+ln(y),exp)}\end{center}
Output :
\begin{center}{\tt exp(x+y)+sin(x)*cos(x)+ln(x)+ln(y)}\end{center}
Input :
\begin{center}{\tt combine(exp(x)*exp(y)+sin(x)*cos(x)+ln(x)+ln(y),trig)}\end{center}
or
\begin{center}{\tt combine(exp(x)*exp(y)+sin(x)*cos(x)+ln(x)+ln(y),sin)}\end{center}
or
\begin{center}{\tt combine(exp(x)*exp(y)+sin(x)*cos(x)+ln(x)+ln(y),cos)}\end{center}
Output :
\begin{center}{\tt exp(y)*exp(x)+(sin(2*x))/2+ln(x)+ln(y)}\end{center}
Input :
\begin{center}{\tt combine(exp(x)*exp(y)+sin(x)*cos(x)+ln(x)+ln(y),ln)}\end{center}
or
\begin{center}{\tt combine(exp(x)*exp(y)+sin(x)*cos(x)+ln(x)+ln(y),log)}\end{center}
Output :
\begin{center}{\tt exp(x)*exp(y)+sin(x)*cos(x)+ln(x*y)}\end{center}

\section{Trigonometry}
\subsection{Trigonometric functions}\label{sec:trigo}
\begin{itemize}
\item {\tt sin} \index{sin} is the sine function,
\item {\tt cos} \index{cos}  is the cosine function,
\item  {\tt tan} \index{tan} is the tangent function ({\tt tan(x)=
    sin(x)/cos(x)}),
\item 
{\tt cot} \index{cot|textbf}  is the cotangent function ({\tt cot(x)=
  cos(x)/sin(x)}),
\item 
{\tt sec} \index{sec|textbf}  is the secant function ({\tt sec(x)=
  1/cos(x)}),
\item
{\tt csc} \index{csc|textbf}  is the cosecant function ({\tt csc(x) =
  1/sin(x)}),
\item
{\tt asin} or {\tt arcsin}\index{asin}\index{arcsin}, {\tt acos} or {\tt arccos}\index{acos}\index{arccos}, {\tt atan} or {\tt arctan}\index{atan}\index{arctan}, {\tt acot}\index{acot|textbf}, {\tt asec}\index{asec|textbf}, {\tt acsc}\index{acsc|textbf}
are the inverse trigonometric functions. The latter are defined by:
\begin{enumerate}
\item {\tt asec(x) = acos(1/x)}, 
\item
{\tt acsc(x) = asin(1/x)},
\item
{\tt  acot(x) = atan(1/x)}. 
\end{enumerate}
\end{itemize}

\subsection{Expand a trigonometric expression : {\tt trigexpand}}\index{trigexpand}
\noindent{\tt trigexpand} takes as argument an expression
containing trigonometric functions.\\
{\tt trigexpand} expands sums, differences and products by an integer
inside the trigonometric functions \\
Input :
\begin{center}{\tt trigexpand(cos(x+y))}\end{center}
Output :
\begin{center}{\tt cos(x)*cos(y)-sin(x)*sin(y)}\end{center}


\subsection{Linearize  a trigonometric expression : {\tt tlin}}\index{tlin}
\noindent{\tt tlin} takes as argument an expression
containing trigonometric functions.\\
{\tt tlin} linearize products and integer powers of the trigonometric
functions (e.g. in terms of $\sin(n.x)$ and  
$\cos(n.x)$)\\
{\bf Examples}
\begin{itemize}
\item Linearize $\cos(x)*\cos(y)$.\\
Input :
\begin{center}{\tt tlin(cos(x)*cos(y))}\end{center}
Output :
\begin{center}{\tt 1/2*cos(x-y)+1/2*cos(x+y)}\end{center}
\item Linearize $\cos(x)3$.\\
Input :
\begin{center}{\tt tlin(cos(x)\verb|^|3)}\end{center}
Output :
\begin{center}{\tt 3/4*cos(x)+1/4*cos(3*x)}\end{center}
\item Linearize $4\cos(x)2-2$.\\
Input :
\begin{center}{\tt tlin(4*cos(x)\verb|^|2-2)}\end{center}
Output :
\begin{center}{\tt 2*cos(2*x)}\end{center}
\end{itemize}

\subsection{Put together sine and cosine of the same angle : {\tt tcollect tCollect}}\index{tcollect}\index{tCollect}
\noindent{\tt tcollect} or {\tt tCollect} takes as argument 
an expression containing trigonometric functions.\\
{\tt tcollect} first linearizes this expression 
(e.g. in terms of $\sin(n.x)$ and $\cos(n.x)$),  
then, puts together sine and cosine of the same angle.\\
Input :
\begin{center}{\tt tcollect(sin(x)+cos(x))}\end{center}
Output :
\begin{center}{\tt sqrt(2)*cos(x-pi/4)}\end{center}
Input :
\begin{center}{\tt tcollect(2*sin(x)*cos(x)+cos(2*x))}\end{center}
Output :
\begin{center}{\tt sqrt(2)*cos(2*x-pi/4)}\end{center}

\subsection{Simplify : {\tt simplify}}\index{simplify}
\noindent{\tt simplify} simplifies the expression.\\
As with all automatic simplifications, do not expect miracles,
you will have to use specific rewriting rules if it does not work.\\ 
Input :
\begin{center}{\tt simplify((sin(3*x)+sin(7*x))/sin(5*x))}\end{center}
Output :
\begin{center}{\tt 4*(cos(x))\verb|^|2-2}\end{center}
{\bf Warning} {\tt simplify} is more efficient in {\tt radian} mode (check 
{\tt radian} in the {\tt cas} configuration 
  or  input {\tt angle\_radian:=1}).

\subsection{Transform arccos into arcsin : {\tt acos2asin}}\index{acos2asin}
\noindent{\tt acos2asin} takes as argument an expression containing 
inverse trigonometric functions.\\
{\tt acos2asin}  replaces $\arccos(x)$ by 
$\displaystyle \frac{\pi}{2}-\arcsin(x)$, in this expression.\\
Input :
\begin{center}{\tt acos2asin(acos(x)+asin(x))}\end{center}
Output after simplification :
\begin{center}{\tt pi/2}\end{center}

\subsection{Transform arccos into arctan : {\tt acos2atan}}\index{acos2atan}
\noindent{\tt acos2atan} takes as argument an expression containing 
inverse trigonometric functions.\\
{\tt acos2atan}  replaces $\arccos(x)$ by
$\displaystyle \frac{\pi}{2}-\arctan(\frac{x}{\sqrt{1-x2}})$, in this 
expression.\\
Input :
\begin{center}{\tt acos2atan(acos(x))}\end{center}
Output :
\begin{center}{\tt  pi/2-atan(x/sqrt(1-x\verb|^|2))}\end{center}

\subsection{Transform arcsin into arccos : {\tt asin2acos}}\index{asin2acos}
\noindent{\tt asin2acos} takes as argument an 
expression containing inverse trigonometric functions.\\
{\tt asin2acos} replaces $\arcsin(x)$  by
$\displaystyle \frac{\pi}{2}-\arccos(x)$, in this expression.\\
Input :
\begin{center}{\tt asin2acos(acos(x)+asin(x))}\end{center}
Output after simplification :
\begin{center}{\tt pi/2}\end{center}

\subsection{Transform arcsin into arctan : {\tt asin2atan}}\index{asin2atan}
\noindent{\tt asin2atan} takes as argument an expression containing 
inverse trigonometric functions.\\
{\tt asin2atan} replaces $\arcsin(x)$  by 
$\displaystyle \arctan(\frac{x}{\sqrt{1-x2}})$, in this expression.\\
Input :
\begin{center}{\tt asin2atan(asin(x))}\end{center}
Output :
\begin{center}{\tt atan(x/sqrt(1-x\verb|^|2))}\end{center}

\subsection{Transform arctan into arcsin : {\tt atan2asin}}\index{atan2asin}
\noindent{\tt atan2asin} takes as argument an expression
containing inverse trigonometric functions.
{\tt atan2asin} replaces $\arctan(x)$ by 
$\displaystyle \arcsin(\frac{x}{\sqrt{1+x2}})$, in this expression.\\
Input :
\begin{center}{\tt atan2asin(atan(x))}\end{center}
Output :
\begin{center}{\tt asin(x/sqrt(1+x\verb|^|2))}\end{center}

\subsection{Transform arctan into arccos : {\tt atan2acos}}\index{atan2acos}
\noindent{\tt atan2acos} takes as argument an expression containing 
inverse trigonometric functions.\\
{\tt atan2acos} replaces $\arctan(x)$ by 
$\displaystyle \frac{\pi}{2}-\arccos(\frac{x}{\sqrt{1+x2}})$, 
in this expression.\\
Input :
\begin{center}{\tt atan2acos(atan(x))}\end{center}
Output :
\begin{center}{\tt pi/2-acos(x/sqrt(1+x\verb|^|2))}\end{center}

\subsection{Transform complex exponentials into sin and cos : {\tt sincos exp2trig}}\index{sincos}\index{exp2trig}
\noindent{\tt sincos}  or {\tt exp2trig} takes as argument an expression 
containing complex exponentials.\\
{\tt sincos} or {\tt exp2trig} rewrites this expression in terms of  
$\sin$ and  $\cos$.\\
Input :
\begin{center}{\tt sincos(exp(i*x))}\end{center}
Output :
\begin{center}{\tt cos(x)+(i)*sin(x)}\end{center}
Input :
\begin{center}{\tt exp2trig(exp(-i*x))}\end{center}
Output :
\begin{center}{\tt cos(x)+(i)*(-(sin(x)))}\end{center}
Input :
\begin{center}{\tt simplify(sincos(((i)*(exp((i)*x))\verb|^|2-i)/(2*exp((i)*x))))}\end{center}
Or :
\begin{center}{\tt simplify(exp2trig(((i)*(exp((i)*x))\verb|^|2-i)/(2*exp((i)*x))))}\end{center}
Output :
\begin{center}{\tt -sin(x)}\end{center}

\subsection{Transform tan(x) into sin(x)/cos(x) : {\tt tan2sincos}}\index{tan2sincos}
\noindent{\tt tan2sincos} takes as argument an expression containing 
trigonometric functions.\\
{\tt tan2sincos} replaces $\tan(x)$ by
 $\displaystyle \frac{\sin(x)}{\cos(x)}$, in this expression.\\
Input :
\begin{center}{\tt tan2sincos(tan(2*x))}\end{center}
Output :
\begin{center}{\tt sin(2*x)/cos(2*x)}\end{center}

\subsection{Rewrite tan(x) with sin(2x) and  cos(2x) : {\tt tan2sincos2}}\index{tan2sincos2}
\noindent{\tt tan2sincos2} takes as argument an expression containing 
trigonometric functions.\\
{\tt tan2sincos2} replaces $\tan(x)$ by 
$\displaystyle \frac{\sin(2.x)}{1+\cos(2.x)}$, in this  expression.\\
Input :
\begin{center}{\tt tan2sincos2(tan(x))}\end{center}
Output :
\begin{center}{\tt sin(2*x)/(1+cos(2*x))}\end{center}

\subsection{Rewrite tan(x) with cos(2x) and  sin(2x) : {\tt tan2cossin2}}\index{tan2cossin2}
\noindent{\tt tan2cossin2} takes as argument an expression 
containing trigonometric functions.\\
{\tt tan2cossin2} replaces $\tan(x)$ by 
$\displaystyle \frac{1-\cos(2.x)}{\sin(2.x)}$ , in this expression.\\
Input :
\begin{center}{\tt tan2cossin2(tan(x))}\end{center}
Output :
\begin{center}{\tt (1-cos(2*x))/sin(2*x)}\end{center}

\subsection{Rewrite sin, cos, tan in terms of tan(x/2) : {\tt halftan}}\index{halftan}
\noindent{\tt halftan} takes as argument an expression 
containing trigonometric functions.\\
{\tt halftan} rewrites $\sin(x),\ \cos(x)$ and  $ \tan(x)$ 
 in terms of $\tan(\frac{x}{2})$.\\
Input :
\begin{center}{\tt halftan(sin(2*x)/(1+cos(2*x)))}\end{center}
Output :
\begin{center}{\tt 2*tan(2*x/2)/((tan(2*x/2))\verb|^|2+1)/}\end{center}
\begin{center}{\tt (1+(1-(tan(2*x/2))\verb|^|2)/((tan(2*x/2))\verb|^|2+1))}\end{center}
Output, after simplification with {\tt normal(ans())} :
\begin{center}{\tt tan(x)}\end{center}
Input :
\begin{center}{\tt halftan(sin(x)\verb|^|2+cos(x)\verb|^|2)}\end{center}
Output :
\begin{center}{\tt (2*tan(x/2)/((tan(x/2))\verb|^|2+1))\verb|^|2+}\end{center}
\begin{center}{\tt ((1-(tan(x/2))\verb|^|2)/((tan(x/2))\verb|^|2+1))\verb|^|2}\end{center}
Output, after simplification avec {\tt normal(ans())} :
\begin{center}{\tt 1}\end{center}

\subsection{Rewrite trigonometric functions as function of tan(x/2) 
and hyperbolic functions as function of exp(x): \\
{\tt halftan\_hyp2exp}}\index{halftan\_hyp2exp}
\noindent{\tt halftan\_hyp2exp} takes as argument a trigonometric and  
hyperbolic expression.\\
{\tt halftan\_hyp2exp} rewrites $\sin(x),\ \cos(x), \tan(x)$ 
 in terms of $\tan(\frac{x}{2})$ 
and $\sinh(x),\ \cosh(x), \tanh(x)$ in terms of $\exp(x)$.\\
Input :
\begin{center}{\tt halftan\_hyp2exp(tan(x)+tanh(x))}\end{center}
Output :
\begin{center}{\tt (2*tan(x/2))/((1-(tan(x/2))\verb|^|2))+(((exp(x))\verb|^|2-1))/ (((exp(x))\verb|^|2+1))}\end{center}
Input :
\begin{center}{\tt halftan\_hyp2exp(sin(x)\verb|^|2+cos(x)\verb|^|2-sinh(x)\verb|^|2+cosh(x)\verb|^|2)}\end{center}
Output, after simplification with {\tt normal(ans())} :
\begin{center}{\tt 2}\end{center}

\subsection{Transform inverse trigonometric functions into logarithms : {\tt atrig2ln}}\index{atrig2ln}
\noindent{\tt atrig2ln}  takes as argument an expression containing
inverse trigonometric functions.\\
{\tt atrig2ln} rewrites these functions with complex logarithms.\\
Input :
\begin{center}{\tt atrig2ln(asin(x))}\end{center}
Output :
\begin{center}{\tt i*log(x+sqrt(x\verb|^|2-1))+pi/2}\end{center}

\subsection{Transform trigonometric functions into complex exponentials  : {\tt trig2exp}}\index{trig2exp}
\noindent{\tt trig2exp} takes as argument an expression containing 
trigonometric functions.\\
{\tt trig2exp} rewrites the trigonometric functions with complex exponentials
({\sc without} linearization).\\ 
Input :
\begin{center}{\tt trig2exp(tan(x))}\end{center}
Output :
\begin{center}{\tt ((exp((i)*x))\verb|^|2-1)/((i)*((exp((i)*x))\verb|^|2+1))}\end{center}
Input :
\begin{center}{\tt trig2exp(sin(x))}\end{center}
Output :
\begin{center}{\tt (exp((i)*x)-1/(exp((i)*x)))/(2*i)}\end{center}

\subsection{Simplify and express preferentially with sine : {\tt trigsin}}\index{trigsin}
\noindent{\tt trigsin} takes as argument an expression
containing trigonometric functions.\\
{\tt trigsin} simplify this expression with the formula :\\
$\sin(x)2+\cos(x)2=1$, $\displaystyle \tan(x)=\frac{\sin(x)}{\cos(x)}$ and 
tries to rewrite the expression only with sine.\\ 
Input :
\begin{center}{\tt trigsin(sin(x)\verb|^|4+cos(x)\verb|^|2+1)}\end{center}
Output :
\begin{center}{\tt sin(x)\verb|^|4-sin(x)\verb|^|2+2}\end{center}

\subsection{Simplify and express preferentially with cosine : {\tt trigcos}}\index{trigcos}
\noindent{\tt trigcos} takes as argument an expression
containing trigonometric functions.\\
{\tt trigcos} simplifies this expression with the formula :\\
$\sin(x)2+\cos(x)2=1$, $\displaystyle \tan(x)=\frac{\sin(x)}{\cos(x)}$  and  
tries to rewrite the expression only with cosine.\\ 
Input :
\begin{center}{\tt trigcos(sin(x)\verb|^|4+cos(x)\verb|^|2+1)}\end{center}
Output :
\begin{center}{\tt cos(x)\verb|^|4-cos(x)\verb|^|2+2}\end{center}

\subsection{Simplify and express preferentially with tangents : {\tt trigtan}}\index{trigtan}
\noindent{\tt trigtan} takes as argument an expression 
containing trigonometric functions.\\
{\tt trigtan} simplifies this expression with the formula :\\
$\sin(x)2+\cos(x)2=1$, $\displaystyle \tan(x)=\frac{\sin(x)}{\cos(x)}$ and  
tries to rewrite the expression only with tangents.\\ 
Input :
\begin{center}{\tt trigtan(sin(x)\verb|^|4+cos(x)\verb|^|2+1)}\end{center}
Output :
\begin{center}{\tt((tan(x))\verb|^|2/(1+(tan(x))\verb|^|2))\verb|^|2+1/(1+(tan(x)\verb|^|2)+1}\end{center}
Output, after simplification with {\tt normal} :
\begin{center}{\tt (2*tan(x)\verb|^|4+3*tan(x)\verb|^|2+2)/(tan(x)\verb|^|4+2*tan(x))\verb|^|2+1)}\end{center}

\subsection{Rewrite an expression with different options : {\tt convert convertir}}\index{convert|textbf}\index{convertir|textbf}\index{sin@{\sl sin}|textbf}\index{cos@{\sl cos}|textbf}\index{sincos@{\sl sincos}|textbf}\index{exp@{\sl exp}|textbf}\index{tan@{\sl tan}|textbf}\index{ln@{\sl ln}|textbf}\index{expln@{\sl expln}|textbf}\index{string@{\sl string}|textbf}\index{matrix@{\sl matrix}|textbf}\index{polynom@{\sl polynom}}\index{parfrac@{\sl parfrac}|textbf}\index{partfrac@{\sl partfrac}|textbf}\index{fullparfrac@{\sl fullparfrac}|textbf}\label{sec:convert}
\noindent{\tt convert} takes two arguments an expression and an option.\\
{\tt convert} rewrites this expression applying rules depending 
on the option. Valid options are :
\begin{itemize}
\item{\tt sin} converts an expression like {\tt trigsin}.
\item{\tt cos} converts an expression like{\tt trigcos}.
\item{\tt sincos} converts an expression like {\tt sincos}.
\item{\tt trig} converts an expression like {\tt sincos}.
\item{\tt tan} converts an expression like {\tt halftan}.
\item{\tt exp} converts an expression like {\tt trig2exp}.
\item{\tt ln} converts an expression like {\tt trig2exp}.
\item{\tt expln} converts an expression like {\tt trig2exp}.
\item{\tt string} converts an expression into a string.
\item{\tt matrix} converts a list of lists into a matrix.
\item{\tt polynom} converts a Taylor series into a un polynomial 
by removing the remainder (cf \ref{sec:convertpoly}).
\item{\tt parfrac} or {\tt partfrac} or {\tt fullparfrac} converts a rational 
fraction into it's partial fraction decomposition (\ref{sec:convertparf}).
\end{itemize}
{\tt convert} can also :
\begin{itemize}
\item convert units, for example 
{\tt convert(1000\_g,\_kg)=1.0\_kg} (cf \ref{sec:convertunit}).
\item write a real as a continued fraction  : 
{\tt convert(a,confrac,'fc')} writes {\tt a} as a continued fraction
stored in {\tt fc}. Do not forget to quote the last argument if it
was assigned.\\
For example, {\tt convert(1.2,confrac,'fc')=[1,5]} and  {\tt fc} contains the 
continue fraction \'equal to 1.2 (cf \ref{sec:convertdfc}). 
\item  transform an integer into the list of its ciphers in a 
basis, begining with the unit cipher (and reciprocally)
\begin{itemize}
\item
{\tt convert(n,base,b)} transforms the integer {\tt n} into the list of its 
ciphers in a basis {\tt b} begining with the unit cipher.\\ For example,
{\tt convert(123,base,10)=[3,2,1]} and  reciproqualy
\item
{\tt convert(l,base,b)} transforms the list {\tt l} into the integer {\tt n} 
which have {\tt l} as list of its 
ciphers in a basis {\tt b} begining with the unit cipher.\\ For example, 
{\tt convert([3,2,1],base,10)=123} (cf \ref{sec:convertbase}). 
\end{itemize}
\end{itemize}

\section{Fourier transformation}
\subsection{Fourier coefficients : {\tt fourier\_an} and  {\tt fourier\_bn} or {\tt fourier\_cn}} \index{integer}
Let $f$ be a $T$-periodic continuous functions on
$\mathbb{R}$ except maybe at a finite number of points.
One can prove that if $f$ is continuous at $x$, then;
\begin{eqnarray*}
f(x)&=&\frac{a_0}{2}+\sum _{n=1}^{+\infty} a_n \cos(\frac{2\pi
  nx}{T})+b_n \sin(\frac{2\pi nx}{T}) \\
 &=&\sum _{n=-\infty}^{+\infty} c_n e^{\frac{2i\pi nx}{T}}
\end{eqnarray*}
where the coefficients $a_n,\ b_n$, $n\in N$, (or $c_n$, $n \in Z$) are the 
Fourier coefficients of $f$.
The commands{\tt fourier\_an} and {\tt fourier\_bn} or {\tt fourier\_cn} 
compute these coefficients.  

\subsubsection{\tt fourier\_an}\index{fourier\_an}\label{sec:fourier_an}
\noindent{\tt fourier\_an} takes four or five arguments : an expression $expr$
depending of a variable, the name of this variable (for example $x$), the 
period $T$, an integer $n$ and a real $a$ (by default $a=0$).\\
{\tt fourier\_an(expr,x,T,n,a)} returns the Fourier coefficient $a_n$ of a 
function $f$ of 
variable $x$ defined on $[a,a+T[$ by $f(x)=expr$ and such that
$f$ is periodic of period $T$:
$$\displaystyle a_n=\frac{2}{T}\int_a^{a+T}f(x)\cos(\frac{2\pi nx }{T})dx$$
To simplify the computations, ons should input {\tt assume(n,integer)} 
before calling {\tt fourier\_an} to specify 
that $n$ is an integer.\\
{\bf Example} Let the function $f$, of period $T=2$, defined on $[-1;1[$ by 
$f(x)=x^2$.\\
Input, to have the coefficient $a_0$ :
\begin{center}{\tt fourier\_an(x\verb|^|2,x,2,0,-1)}\end{center}
Output :
\begin{center}{\tt 1/3}\end{center}
Input, to have the coefficient $a_n$ ($n\neq 0$) :
 \begin{center}{\tt assume(n,integer);fourier\_an(x\verb|^|2,x,2,n,-1)}\end{center}
Output :
\begin{center}{\tt 4*(-1)\verb|^|n/(pi\verb|^|2*n\verb|^|2)}\end{center}

\subsubsection{\tt fourier\_bn}\index{fourier\_bn}\label{sec:fourier_bn}
\noindent{\tt fourier\_bn} takes four or five arguments : an expression $expr$
depending of a variable, the name of this variable (for example $x$), the 
period $T$, an integer $n$ and a real $a$ (by default $a=0$).\\
{\tt fourier\_bn(expr,x,T,n,a)} returns the Fourier coefficient $b_n$ of a 
function $f$ of variable $x$ defined on $[a,a+T[$ by $f(x)=expr$ and  periodic 
of period $T$:
$$\displaystyle b_n=\frac{2}{T}\int_a^{a+T}f(x)\sin(\frac{2\pi nx}{T})dx$$
To simplify the computations, one should input {\tt assume(n,integer)} 
before calling {\tt fourier\_bn} to specify that $n$ is an integer.\\
{\bf Examples} 
\begin{itemize}
\item Let the function $f$, of period $T=2$, defined on $[-1;1[$ by 
$f(x)=x^2$.\\
Input, to have the coefficient $b_n$ ($n\neq 0$) :
 \begin{center}{\tt  assume(n,integer);fourier\_bn(x\verb|^|2,x,2,n,-1)}\end{center}
Output :
\begin{center}{\tt  0}\end{center}

\item Let the function $f$, of period $T=2$, defined on $[-1;1[$ by
$f(x)=x^3$.\\
Input, to have the coefficient  $b_1$ :
 \begin{center}{\tt fourier\_bn(x\verb|^|3,x,2,1,-1)}\end{center}
Output :
\begin{center}{\tt (2*pi\verb|^|2-12)/pi\verb|^|3}\end{center}
\end{itemize}

\subsubsection{\tt fourier\_cn}\index{fourier\_cn}\label{sec:fourier_cn}
\noindent{\tt fourier\_cn} takes four or five arguments : an expression $expr$
depending of a variable, the name of this variable (for example $x$), the 
period $T$, an integer $n$ and a real $a$ (by default $a=0$).\\
{\tt fourier\_cn(expr,x,T,n,a)} returns the Fourier coefficient $c_n$ of a 
function$f$ of variable $x$ defined on $[a,a+T[$ by $f(x)=expr$ and  periodic 
of period $T$:
$$\displaystyle c_n=\frac{1}{T}\int_a^{a+T}f(x)e^{\frac{-2i\pi nx}{T}}dx$$
To simplify the computations, one should
input {\tt assume(n,integer)} before calling {\tt fourier\_cn}
to specify that $n$ is an integer.\\
{\bf Examples}
\begin{itemize}
\item Find the Fourier coefficients $c_n$ of the periodic function $f$ of
period $2$ and  defined on $[-1;1[$ by $ f(x)=x^2$.\\ 
Input, to have $c_0$ :
\begin{center}{\tt fourier\_cn(x\verb|^|2,x,2,0,-1)}\end{center}
Output:
\begin{center}{\tt 1/3}\end{center}
Input, to have $c_n$ :
\begin{center}{\tt assume(n,integer)}\end{center}
\begin{center}{\tt fourier\_cn(x\verb|^|2,x,2,n,-1)}\end{center}
Output:
\begin{center}{\tt 2*(-1)\verb|^|n/(pi\verb|^|2*n\verb|^|2)}\end{center}

\item Find the Fourier coefficients $c_n$ of the periodic function $f$, of 
period $2$, and defined on $[0;2[$ by $ f(x)=x^2$.\\ 
Input,  to have $c_0$ :
\begin{center}{\tt fourier\_cn(x\verb|^|2,x,2,0)}\end{center}
Output:
\begin{center}{\tt 4/3}\end{center}
Input, to have $c_n$ :
\begin{center}{\tt assume(n,integer)}\end{center}
\begin{center}{\tt fourier\_cn(x\verb|^|2,x,2,n)}\end{center}
Output:
\begin{center}{\tt ((2*i)*pi*n+2)/(pi\verb|^|2*n\verb|^|2)}\end{center}

\item Find the Fourier coefficients $c_n$ of the periodic function $f$ of 
period $2.\pi$ and  defined on $[0;2.\pi[$ by $ f(x)=x^2$.\\ 
Input \index{assume} :
\begin{center}{\tt assume(n,integer)}\end{center}
\begin{center}{\tt fourier\_cn(x\verb|^|2,x,2*pi,n)}\end{center}
Output :
\begin{center}{\tt ((2*i)*pi*n+2)/n\verb|^|2}\end{center}
If you don't specify {\tt assume(n,integer)}, the output will not be 
simplified :
\begin{center}{\tt ((2*i)*pi\verb|^|2*n\verb|^|2*exp((-i)*n*2*pi)+2*pi*n*exp((-i)*n*2*pi)+}\end{center}
\begin{center}{\tt (-i)*exp((-i)*n*2*pi)+i)/(pi*n\verb|^|3)}\end{center}
You might simplify this expression by replacing 
{\tt exp((-i)*n*2*pi)} by {\tt 1}, input :
\begin{center}{\tt subst(ans(),exp((-i)*n*2*pi)=1)}\end{center}
Output :
\begin{center}{\tt ((2*i)*pi\verb|^|2*n\verb|^|2+2*pi*n+-i+i)/pi/n\verb|^|3}\end{center}
This expression is then simplified with {\tt normal}, the final
output is :
\begin{center}{\tt ((2*i)*pi*n+2)/n\verb|^|2}\end{center}
Hence for $n \neq 0$, $\displaystyle c_n=\frac{2in\pi+2}{n^2}$.
As shown in this example, it is better to input  {\tt
  assume(n,integer)} before calling {\tt fourier\_cn}.\\
We must also compute $c_n$ for $n=0$, input :
\begin{center}{\tt fourier\_cn(x\verb|^|2,x,2*pi,0)}\end{center}
Output :
\begin{center}{\tt  4*pi\verb|^|2/3}\end{center}
Hence for  $n= 0$, $\displaystyle c_0=\frac{4.{\pi}^2}{3}$. 
\end{itemize}
{\bf Remarks} :
\begin{itemize}
\item Input {\tt purge(n)}\index{purge} to remove the hypothesis done
  on $n$.
\item
Input {\tt about(n)}\index{about} or {\tt assume(n)}\index{assume}, to know 
the hypothesis done on the variable $n$.
\end{itemize}

\subsection{Discrete Fourier Transform}
Let $N$ be an integer.
The Discrete Fourier Transform (DFT) is a transformation $F_N$ defined on
the set of periodic sequences of period $N$, it depends on a choice
of a primitive $N$-th root of unity $\omega_N$. If the
DFT is defined on sequences with complex coefficients, we take:
\[ \omega_N=e^{\frac{2 i \pi}{N}}\]
If $x$ is a periodic sequence of period 
$N$, defined by the vector $x=[x_0,x_1,...x_{N-1}]$ then 
$F_N(x)=y$ is a periodic sequence of period $N$, defined by:
\[ {(F_{N,\omega_N}(x))}_k=y_k=\sum_{j=0}^{N-1}x_j\omega_N^{-k\cdot j}, k=0..N-1 \]
where $\omega_N$ is a primitive $N$-th root of unity. 
The discrete Fourier transform may be computed faster than by
computing each $y_k$ individually, by the Fast Fourier Transform (FFT).
{\tt Xcas} implements the FFT algorithm to compute
the discrete Fourier transform only if $N$ is a power of 2.

\subsubsection{The properties of the Discrete Fourier Transform}
The Discrete Fourier Transform $F_N$ is a bijective transformation 
on periodic sequences such that 
\begin{eqnarray*}
 F_{N,\omega_N}^{-1}&=&\frac{1}{N} F_{N,\omega_N^{-1}} \\
&=&\frac{1}{N} \overline{F_{N}} \quad \mbox{ on } \mathbb C
\end{eqnarray*}
i.e. :
\[ {(F_N^{-1}(x))}_k=\frac{1}{N}\sum_{j=0}^{N-1}x_j\omega_N^{k\cdot j} \]
Inside {\tt Xcas} the discrete Fourier transform and it's inverse
are denote by {\tt fft} and  {\tt ifft}:
\begin{center}
{\tt fft(x)}=$\displaystyle F_N(x)$, \ {\tt ifft(x)}=$\displaystyle F_N^{-1}(x)$
\end{center}
{\bf Definitions}\\
Let $x$ and  $y$ be two periodic sequences of period $N$.
\begin{itemize}
\item The Hadamard product (notation $\cdot$) is defined by:
\[ {(x \cdot y)}_k = x_k y_k \]
\item the convolution product (notation $*$) is defined by:
\[ {(x * y)}_k=\sum_{j=0}^{N-1}x_jy_{k-j} \]
\end{itemize}
{\bf Properties} :
\begin{eqnarray*}
N*F_N(x \cdot y)&=&F_N(x) * F_N(y)\\
F_N(x * y)&=&F_N(x) \cdot F_N(y)
\end{eqnarray*}

\subsubsection{Applications}
\begin{enumerate}
\item Value of a polynomial\\ 
Define a polynomial $P(x)=\sum_{j=0}^{N-1}c_jx^j$ by the vector of its 
coefficients $c:=[c_0,c_1,..c_{N-1}]$, where zeroes may be added so that
$N$ is a power of 2.
\begin{itemize}
\item Compute the values of $P(x)$ at
\[ x=a_k=\omega_N^{-k}=\exp(\frac{-2ik\pi}{N}), \quad k=0..N-1 \]
This is just the discrete Fourier transform of $c$ since
\[ P(a_k)=\sum_{j=0}^{N-1}c_j(\omega_N^{-k})^j=F_N(c)_k \]
Input, for example :
\begin{center}
{\tt P(x):=x+x\verb|^|2;  w:=i}
\end{center}
Here the coefficients of $P$ are [0,1,1,0],  
$N=4$ and $\omega=\exp(2i\pi/4)=i$.\\
Input :\\
{\tt fft([0,1,1,0])}\\
Output :\\
{\tt [2,-1-i,0,-1+i]}\\
hence 
\begin{itemize}
\item {\tt P(0)=2},
\item {\tt P(-i)=P(w\verb|^|-1)=-1-i},
\item {\tt P(-1)=P(w\verb|^|-2)=0},
\item {\tt P(i)=P(w\verb|^|-3)=-1+i}.
\end{itemize}

\item Compute the values of $P(x)$ at
\[ x=b_k=\omega_N^{k}=\exp(\frac{2ik\pi}{N}), \quad k=0..N-1 \]
This is $N$ times the inverse fourier transform of $c$ since
\[ P(a_k)=\sum_{j=0}^{N-1}c_j(\omega_N^{k})^j=NF_N^{-1}(c)_k \]
Input, for example :\\
{\tt P(x):=x+x\verb|^|2} and {\tt w:=i}\\
Hence, the coefficients of $P$ are [0,1,1,0], 
$N=4$ and $\omega=\exp(2i\pi/4)=i$.\\
Input :\\
{\tt 4*ifft([0,1,1,0])}\\
Output :\\
{\tt [2,-1+i,0,-1-i]}\\
hence : \begin{itemize}
\item {\tt P(0)=2},
\item {\tt  P(i)=P(w\verb|^|1)=-1+i},
\item {\tt  P(-1)=P(w\verb|^|2)=0},
\item {\tt  P(-i)=P(w\verb|^|3)=-1-i}.
\end{itemize}
We find of course the same values as above...
\end{itemize}

\item Trigonometric interpolation\\
Let $f$ be periodic function of period $2\pi$, assume that $f(2k\pi/N)=f_k$ 
for $k=0..(N-1)$. Find a trigonometric polynomial $p$ that interpolates $f$ 
at $x_k=2k\pi/N$, that is find $p_j, j=0..N-1$ such that
\[  p(x)= \sum_{j=0}^{N-1} p_j \exp(ijx), \quad p(x_k)=f_k\]
Replacing $x_k$ by it's value in $p(x)$ we get:
\[ \sum_{j=0}^{N-1} p_j \exp(i\frac{j2k\pi}{N}) = f_k\]
In other words, $(f_k)$ is the inverse DFT of $(p_k)$, hence
\[ (p_k)= \frac{1}{N} F_N( \ (f_k) \ ) \]
If the function $f$ is real, $p_{-k}=\overline p_k$, hence depending
whether $N$ is even or odd:
\begin{eqnarray*}
p(x)&=&p_0+
2 \Re(\sum_{k=0}^{\frac{N}{2}-1}p_k\exp(ikx))+\Re(p_{\frac{N}{2}} \exp(i\frac{Nx}{2})) \\
p(x)&=&p_0+ 2 \Re(\sum_{k=0}^{\frac{N-1}{2}}p_k\exp(ikx))
\end{eqnarray*}

\item  Fourier series\\
Let $f$ be a periodic function of period $2\pi$, such that
\[ f(x_k)=y_k, \quad x_k=\frac{2k\pi}{N}, k=0..N-1 \]
Suppose that the Fourier serie of $f$ converges to $f$ (this will
be the case if for example $f$ is continuous). If $N$ is large,
a good approximation of $f$ will be given by:
\[ \sum_{-\frac{N}{2} \leq n<\frac{N}{2}} c_n \exp(inx) \]
Hence we want a numeric approximation of
\[ c_n=\frac{1}{2\pi} \int_0^{2\pi}f(t)\exp(-int)dt \]
The  numeric value of the integral $\int_0^{2\pi}f(t)\exp(-int)dt$ may be
computed by the trapezoidal rule
(note that the Romberg algorithm would not work here, 
because the Euler Mac Laurin developpement 
has it's coefficients equal to zero, since the integrated function is 
periodic, hence all it's derivatives have the same value at $0$ and at $2\pi$).
If $\tilde{c_n}$ is the numeric value of $c_n$ obtained by the
trapezoidal rule, then 
\[
\tilde{c_n}=\frac{1}{2\pi}\frac{2\pi}{N}\sum_{k=0}^{N-1}y_k\exp(-2i\frac{nk\pi}{N}),
\quad  -\frac{N}{2} \leq n<\frac{N}{2} \]
Indeed, since $x_k=2k\pi/N$ and  $f(x_k)=y_k$:
\begin{eqnarray*} 
f(x_k)\exp(-inx_k)&=&y_k\exp(-2i\frac{nk\pi}{N}), \\
f(0)\exp(0)=f(2\pi)\exp(-2i\frac{nN\pi}{N})&=&y_0=y_N 
\end{eqnarray*}
Hence :
\[
[\tilde{c}_0,..\tilde{c}_{\frac{N}{2}-1},\tilde{c}_{\frac{-N}{2}},..c_{-1}]=
\frac{1}{N}F_N([y_0,y_1...y_{(N-1)}]) \]
since
\begin{itemize}
\item if $n\geq0$, $\tilde{c}_n=y_n$ 
\item if $n<0$ $\tilde{c}_n=y_{n+N}$
\item $\omega_N=\exp(\frac{2i\pi}{N})$, 
then $\omega_N^n=\omega_N^{n+N}$ 
\end{itemize}

{\bf Properties}
\begin{itemize}
\item The coefficients of the trigonometric polynomial that interpolates $f$ 
at $x=2k\pi/N$ are
\[ p_n=\tilde{c}_n, \quad -\frac{N}{2} \leq n<\frac{N}{2} \]
\item
If $f$ is a trigonometric polynomial $P$ of degree $m\leq \frac{N}{2}$, 
then
\[ f(t)=P(t)=\sum_{k=-m}^{m-1}c_k\exp(2ik\pi t) \]
the trigonometric polynomial that interpolate $f=P$ is $P$, the numeric 
approximation of the coefficients are in fact exact ($\tilde{c}_n=c_n$).
\item More generally, we can compute $\tilde{c}_n-c_n$.\\
Suppose that $f$ is equal to it's Fourier serie, i.e. that :\\
\[ f(t)=\sum_{m=-\infty}^{+\infty}c_m\exp(2i\pi mt), \quad
\sum_{m=-\infty}^{+\infty}|c_m|<\infty \]
Then :
\[ f(x_k)=f(\frac{2k\pi}{N})=y_k=\sum_{m=-\infty}^{+\infty}c_m\omega_N^{km},
\quad
\tilde{c_n}=\frac{1}{N}\sum_{k=0}^{N-1}y_k\omega_N^{-kn} \]
Replace $y_k$ by it's value in $\tilde{c_n}$:
\[
\tilde{c_n}=\frac{1}{N}\sum_{k=0}^{N-1}\sum_{m=-\infty}^{+\infty}
c_m\omega_N^{km}\omega_N^{-kn} \]
If $m\neq n \pmod N$, $\omega_N^{m-n}$ is a $N$-th root of unity different
from 1, hence:
\[ \omega_N^{(m-n)N}=1, \quad \sum_{k=0}^{N-1}\omega_N^{(m-n)k}=0 \]
Therefore, if $m-n$ is a multiple of $N$ ($m=n+l\cdot N$) then 
$\sum_{k=0}^{N-1}\omega_N^{k(m-n)}=N$, otherwise 
$\sum_{k=0}^{N-1}\omega_N^{k(m-n)}=0$.
By reversing the two sums, we get
\begin{eqnarray*}
\tilde{c_n}&=&\frac{1}{N}\sum_{m=-\infty}^{+\infty}c_m\sum_{k=0}^{N-1}\omega_N^{k(m-n)} \\
&=&\sum_{l=-\infty}^{+\infty}c_{(n+l\cdot N)} \\
&=&...c_{n-2\cdot N}+c_{n-N}+c_{n}+c_{n+N}+c_{n+2\cdot
  N}+.....
\end{eqnarray*}
Conclusion: if $|n|<N/2$, $\tilde{c_n}-c_n$ is a sum of $c_j$ of large indices 
(at least $N/2$ in absolute value), hence is small (depending on the
rate of convergence of the Fourier series).
\end{itemize}
{\bf Example}, input
\begin{center}
{\tt f(t):=cos(t)+cos(2*t)}\\
{\tt x:=f(2*k*pi/8)\$(k=0..7)}
\end{center}
Output :
\begin{center}
 ${\tt x=\{2,(\sqrt
  2)/2,-1,-((\sqrt2)/2),0,-((\sqrt2)/2),-1,(\sqrt2)/2\}}$ \\
{\tt fft(x)=[0.0,4.0,4.0,0.0,0.0,0.0,4.0,4.0]}
\end{center}
After a division by $N=8$, we get
\begin{center} $c_0=0,c_1=4.0/8,c_2=4.0/2,c_3=0.0$,\\
$c_{-4}=0,c_{-3}=0,c_{-2}=4.0/8,=c_{-1}=4.0/8$
\end{center}
Hence $b_k=0$ and  $a_k=c_{-k}+c_k$ is equal to 1 if $k=1,2$ and 0 otherwise. 

\item Convolution Product\\
If $P(x)=\sum_{j=0}^{n-1}a_jx^j$  
and $Q(x)=\sum_{j=0}^{m-1}b_jx^j$ 
are given by the vector of their coefficients 
$a=[a_0,a_1,..a_{n-1}]$ and  $b=[b_0,b_1,..b_{m-1}]$, we may
compute the product of these two polynomials using the DFT.
The product of polynomials is the convolution product 
of the periodic sequence of their coefficients 
if the period is greater or equal to  
$(n+m)$. Therefore we complete $a$ (resp $b$) with $m+p$ 
(resp $n+p$) zeros, where
$p$ is choosen such that $N=n+m+p$ is a power of 2.
If $a=[a_0,a_1,..a_{n-1},0..0]$ and  $b=[b_0,b_1,..b_{m-1},0..0]$, then:
\[ P(x)Q(x)=\sum_{j=0}^{n+m-1}(a*b)_jx^j \]
We compute $F_N(a)$, $F_N(b)$, then $ab=F_N^{-1}(F_N(a)\cdot F_N(b))$
using the properties
\[ NF_N(x \cdot y)=F_N(x) * F_N(y), \quad
F_N(x * y)=F_N(x) \cdot F_N(y) \]
\end{enumerate}

\subsection{Fast Fourier Transform : {\tt fft}}\index{fft}
\noindent{\tt fft} takes as argument a list (or a sequence)
${\tt [a_0,..a_{N-1}]}$ where {\tt N} is a power of two.\\
{\tt fft} returns the list ${\tt [b_0,..b_{N-1}]}$ such that, 
for {\tt k=0..N-1} 
\[ {\tt 
  {fft([a_0,..a_{N-1}])}[k]=b_k=\sum_{j=0}^{N-1}x_j\omega_N^{-k\cdot
    j}} \]
where $\omega_N$ is a primitive $N$-th root of the unity.\\
Input :
\begin{center}{\tt fft(0,1,1,0)}\end{center}
Output :
\begin{center}{\tt [2.0, -1-i, 0.0, -1+i]}\end{center}

\subsection{Inverse Fast Fourier Transform : {\tt ifft}}\index{ifft}
\noindent{\tt ifft} takes as argument a list ${\tt [b_0,..b_{N-1}]}$ where
{\tt N} is a power of two.\\
{\tt ifft} returns the list ${\tt [a_0,..a_{N-1}]}$ such that
\[ {\tt fft([a_0,..a_{N-1}])=[b_0,..b_{N-1}]} \]
Input :
\begin{center}{\tt ifft([2,-1-i,0,-1+i])}\end{center}
Output :
\begin{center}{\tt [0.0, 1.0, 1.0, 0.0]}\end{center}

\subsection{An {\bf exercice} with {\tt fft}}
Here are the temperatures $T$, in Celsius degree, at time $t$ :
\begin{center}
\begin{tabular}{|r|rrrrrrrr|}
\hline
t & 0 & 3 & 6 & 9 &12 & 15 & 19 & 21\\
\hline
T & 11 & 10 & 17 & 24 & 32 & 26 & 23 & 19\\
\hline
\end{tabular}
\end{center}
What was the temperature at 13h45 ?

Here $N=8=2*m$. The interpolation polynomial is
\[ p(t)=\frac{1}{2} p_{-m}(\exp(-2i\frac{\pi mt}{24})+
\exp(2i\frac{\pi mt}{24}))+
\sum_{k=-m+1}^{m-1}p_k \exp(2i\frac{\pi kt}{24}) \]
and
\[ p_k=\frac{1}{N} \sum_{k=j}^{N-1}T_k \exp(2i\frac{\pi k}{N}) \]
Input :\\
{\tt q:=1/8*fft([11,10,17,24,32,26,23,19])}\\
Output :\\
{\tt q:=[20.25,-4.48115530061+1.72227182413*i,-0.375+0.875*i,\\
-0.768844699385+0.222271824132*i,0.5,\\
-0.768844699385-0.222271824132*i,\\
-0.375-0.875*i,-4.48115530061-1.72227182413*i]}\\
hence:
\begin{itemize}
\item $p_0=20.25$
\item $p_1=-4.48115530061+1.72227182413*i=\overline{p_{-1}}$,
\item $p_2=0.375+0.875*i=\overline{p_{-2}}$,
\item $p_3=-0.768844699385+0.222271824132*i=\overline{p_{-3}}$,
\item $p_{-4}=0.5$
\end{itemize}
Indeed
\[
q=[q_0,...q_{N-1}]=[p_0,..p_{\frac{N}{2}-1},p_{-\frac{N}{2}},..,p_{-1}]=\frac{1}{N}F_N([y_0,..y_{N-1}])={\tt
  \frac{1}{N}fft(y)} \]
Input :\\
{\tt pp:=[q[4],q[5],q[6],q[7],q[0],q[1],q[2],q[3]]}\\
Here, $p_k=pp[k+4]$ for $k=-4...3$.
It remains to compute the value of the interpolation polynomial at point
$t0=13,75=55/4$, Input\\
{\tt t0(j):=exp(2*i*pi*(13+3/4)/24*j)}\\
{\tt T0:=1/2*pp[0]*(t0(4)+t0(-4))+sum(pp[j+4]*t0(j),j,-3,3)}\\
{\tt evalf(re(T0))}\\
Output :\\
{\tt 29.4863181684}\\
The temperature is predicted to be equal to 29.49 Celsius degrees.\\
Input :\\
{\tt q1:=[q[4]/2,q[3],q[2],q[1],q[0]/2]}\\
{\tt a:=t0(1)} (ou {\tt a:=-exp(i*pi*7/48)})\\
{\tt g(x):=r2e(q1,x)}\\
{\tt evalf(2*re(g(a)))}\\
or\\
{\tt 2.0*re(q[0]/2+q[1]*t0(1)+q[2]*t0(2)+q[3]*t0(3)+q[4]/2*t0(4))}\\
Output :\\
{\tt 29.4863181684}\\

{\bf Remark}\\
Using the Lagrange interpolation polynomial (the polynomial is not periodic),
input :\\
{\tt l1:=[0,3,6,9,12,15,18,21]}\\
{\tt l2:=[11,10,17,24,32,26,23,19]}\\
{\tt subst(lagrange(l1,l2,13+3/4),x=13+3/4)}\\
Output :\\
${\tt \displaystyle \frac{8632428959}{286654464}\simeq 30.1144061688}$

\section{Exponentials and Logarithms}
\subsection{Rewrite hyperbolic functions as exponentials : {\tt hyp2exp}}\index{hyp2exp}
\noindent{\tt hyp2exp} takes as argument an hyperbolic expression.\\
{\tt hyp2exp} rewrites each hyperbolic functions with exponentials
(as a rational fraction of one exponential,
i.e. {\sc without} linearization).\\ 
Input :
\begin{center}{\tt hyp2exp(sinh(x))}\end{center}
Output :
\begin{center}{\tt (exp(x)-1/(exp(x)))/2}\end{center}

\subsection{Expand exponentials : {\tt expexpand}}\index{expexpand}
\noindent{\tt expexpand} takes as argument an expression with exponentials.\\
{\tt expexpand} expands this expression (rewrites exp of sums as
product of exp).\\
Input :
\begin{center}{\tt expexpand(exp(3*x)+exp(2*x+2))}\end{center}
Output :
\begin{center}{\tt exp(x)\verb|^|3+exp(x)\verb|^|2*exp(2)}\end{center}

\subsection{Expand logarithms : {\tt lnexpand}}\index{lnexpand}
\noindent{\tt lnexpand} takes as argument an expression with logarithms.\\
{\tt lnexpand} expands this expression (rewrites ln of products
as sum of ln).\\
Input :
\begin{center}{\tt lnexpand(ln(3*x\verb|^|2)+ln(2*x+2))}\end{center}
Output :
\begin{center}{\tt  ln(3)+2*ln(x)+ln(2)+ln(x+1)}\end{center}

\subsection{Linearize exponentials : {\tt lin}}\index{lin}
\noindent{\tt lin} takes as argument an expression with
exponentials.\\
{\tt lin} rewrites hyperbolic functions as exponentials if required,
then linearizes this expression (i.e. replace product of
exponentials by exponential of sums).\\
{\bf Examples}
\begin{itemize}
\item Input :
\begin{center}{\tt lin(sinh(x)\verb|^|2)}\end{center}
Output :
\begin{center}{\tt 1/4*exp(2*x)+1/-2+1/4*exp(-(2*x))}\end{center}

\item Input :
\begin{center}{\tt lin((exp(x)+1)\verb|^|3)}\end{center}
Output :
\begin{center}{\tt exp(3*x)+3*exp(2*x)+3*exp(x)+1}\end{center}
\end{itemize}

\subsection{Collect logarithms : {\tt lncollect}}\index{lncollect}
\noindent{\tt lncollect} takes as argument an expression with logarithms.\\
{\tt lncollect} collects the logarithms (rewrites sum of ln
as ln of products). 
It may be a good idea to factor the 
expression with {\tt factor} before collecting by {\tt lncollect}).\\
Input :
\begin{center}{\tt lncollect(ln(x+1)+ln(x-1))}\end{center}
Output :
\begin{center}{\tt log((x+1)*(x-1))}\end{center}
Input :
\begin{center}{\tt lncollect(exp(ln(x+1)+ln(x-1)))}\end{center}
Output :
\begin{center}{\tt (x+1)*(x-1)}\end{center}
{\bf Warning!!!}  For {\tt Xcas}, {\tt log=ln} (use {\tt log10}
for 10-base logarithm).

\subsection{Expand powers : {\tt powexpand}}\index{powexpand}
\noindent{\tt powexpand} rewrites a power of sum as a product of powers.\\
Input :
\begin{center}{\tt powexpand(a\verb|^|(x+y))}\end{center}
Output :
\begin{center}{\tt a\verb|^|x*a\verb|^|y}\end{center}


\subsection{Rewrite a power as an exponential : {\tt pow2exp}}\index{pow2exp}
\noindent{\tt pow2exp} rewrites a power as an exponential.\\
Input :
\begin{center}{\tt  pow2exp(a\verb|^|(x+y))}\end{center}
Output :
\begin{center}{\tt exp((x+y)*ln(a))}\end{center}

\subsection{Rewrite exp(n*ln(x)) as a power : {\tt exp2pow}}\index{exp2pow}
\noindent{\tt exp2pow} rewrites expression of the form $\exp(n*\ln(x))$
as a power of $x$.\\
Input :
\begin{center}{\tt  exp2pow(exp(n*ln(x)))}\end{center}
Output :
\begin{center}{\tt x\verb|^|n}\end{center}
Note the difference with {\tt lncollect} :\\
{\tt lncollect(exp(n*ln(x))) = exp(n*log(x))}\\
{\tt lncollect(exp(2*ln(x))) = exp(2*log(x))}\\
{\tt exp2pow(exp(2*ln(x))) = x\verb|^|2 }\\
But :\\
{\tt lncollect(exp(ln(x)+ln(x))) = x\verb|^|2}\\
{\tt exp2pow(exp(ln(x)+ln(x))) = x\verb|^|(1+1)}\\

\subsection{Simplify complex exponentials : {\tt tsimplify}}\index{tsimplify}
\noindent{\tt tsimplify} simplifies transcendental expressions 
by rewriting the expression with complex exponentials.\\
It is a good idea to try other simplification instructions
and call {\tt tsimplify} if they do not work.\\ 
Input :
\begin{center}{\tt tsimplify((sin(7*x)+sin(3*x))/sin(5*x))}\end{center}
Output :
\begin{center}{\tt ((exp((i)*x))\verb|^|4+1)/(exp((i)*x))\verb|^|2 }\end{center}

\section{Polynomials}
A polynomial of one variable is represented either 
by a symbolic expression or by the list of it's 
coefficients by decreasing powers order (dense representation).
In the latter case, to avoid confusion with other kinds of list
\begin{itemize}
\item use \verb|poly1[...]| as delimiters in inputs
\item check for $\talloblong \ \talloblong$ in {\tt Xcas} output.
\end{itemize}
Note that polynomials represented as lists of coefficients
are always written in decreassing powers order even if  
{\tt increasing power} is checked in  {\tt cas} configuration.

A polynomial of several variables is represented
\begin{itemize}
\item by a symbolic expression 
\item or by a dense recursive 1-d representation like above
\item or by a sum of
monomials with non-zero coefficients (distributed sparse
representation).\\
A monomial with several variables is represented by a coefficent and a
list of integer (interpreted as powers of a variable list). The 
delimiters for monomials are
{\tt \%\%\%\{} and  {\tt \%\%\%\}}, for example $3x^2y$ is represented by
{\tt \%\%\%\{3,[2,1]\%\%\%\}} with respect to the variable list 
{\tt [x,y]}).
\end{itemize} 


\subsection{Convert to a symbolic polynomial : {\tt r2e poly2symb}}\index{r2e}\index{poly2symb}
\noindent{\tt r2e} or  {\tt poly2symb} takes as argument 
\begin{itemize}
\item a list of 
coefficients of a polynomial (by decreasing order) and a symbolic
variable name 
(by default {\tt x})
\item or a sum of monomials {\tt \%\%\%\{coeff,[n1,....nk] \%\%\%\}} 
and a vector of symbolic variables {\tt [x1,...,xk]}).
\end{itemize}
{\tt r2e} or  {\tt poly2symb} transforms the argument into a symbolic
polynomial.\\
Example with univariate polynomials, input :
\begin{center}{\tt r2e([1,0,-1],x)}\end{center}
or :
\begin{center}{\tt r2e([1,0,-1])}\end{center}
or :
\begin{center}{\tt poly2symb([1,0,-1],x)}\end{center}
Output :
\begin{center}{\tt  x*x-1}\end{center}
Example with sparse multivariate polynomials, input:
\begin{center}{\tt poly2symb(\%\%\%\{1,[2]\%\%\%\}+\%\%\%\{-1,[0]\%\%\%\},[x])}\end{center}
or :
\begin{center}{\tt r2e(\%\%\%\{1,[2]\%\%\%\}+\%\%\%\{-1,[0]\%\%\%\},[x])}\end{center}
Output :
\begin{center}{\tt  x\verb|^2|-1}\end{center}
Input :
\begin{center}{\tt r2e(\%\%\%\{1,[2,0]\%\%\%\}+\%\%\%\{-1,[1,1]\%\%\%\}+\%\%\%\{2,[0,1]\%\%\%\},[x,y])}\end{center}
or :
\begin{center}{\tt poly2symb(\%\%\%\{1,[2,0]\%\%\%\}+\%\%\%\{-1,[1,1]\%\%\%\}+\%\%\%\{2,[0,1]\%\%\%\},[x,y])}\end{center}
Output :
\begin{center}{\tt  x\verb|^|2-x*y+2*y}\end{center}

\subsection{Convert from a symbolic polynomial : {\tt e2r symb2poly}}\index{e2r}\index{symb2poly}
\noindent{\tt e2r} or {\tt symb2poly} takes as argument a symbolic polynomial 
and either a symbolic variable name (by default {\tt x}) or
a list of symbolic variable names.\\
{\tt e2r} or {\tt symb2poly} transforms the polynomial into a list 
(dense representation of the univariate polynomial, coefficients
written by decreasing order) or into a sum of monomials (sparse
representation of multivariate polynomials).\\
Input :
\begin{center}{\tt e2r(x\verb|^|2-1)}\end{center}
or :
\begin{center}{\tt symb2poly(x\verb|^|2-1)}\end{center}
or :
\begin{center}{\tt symb2poly(y\verb|^|2-1,y)}\end{center}
or :
\begin{center}{\tt e2r(y\verb|^|2-1,y)}\end{center}
Output :
\begin{center}{\tt $\talloblong$1,0,-1$\talloblong$}\end{center}
Input :
\begin{center}{\tt e2r(x\verb|^|2-x*y+y, [x,y])}\end{center}
or :
\begin{center}{\tt symb2poly(x\verb|^|2-x*y+2*y, [x,y])}\end{center}
Output :
\begin{center}{\tt \%\%\%\{1,[2,0]\%\%\%\}+\%\%\%\{-1,[1,1]\%\%\%\}+\%\%\%\{2,[0,1]\%\%\%\}}\end{center}

\subsection{Coefficients of a polynomial: {\tt coeff coeffs}}\index{coeff}\index{coeffs}
\noindent{\tt coeff} or {\tt coeffs} takes three arguments : the polynomial, 
the name of the variable (or the list of the names of  variables) and
the degree (or the list of the degrees of the variables).\\
{\tt coeff} or {\tt coeffs} returns the coefficient of the polynomial
of the degree given as third argument. 
If no degree was specified, {\tt coeffs} return
the list of the coefficients of the polynomial, including 0 in the
univariate dense case and excluding 0 in the multivariate sparse case.\\
Input :
\begin{center}{\tt coeff(-x\verb|^|4+3*x*y\verb|^|2+x,x,1)}\end{center}
Output :
\begin{center}{\tt 3*y\verb|^|2+1}\end{center}  
Input :
\begin{center}{\tt coeff(-x\verb|^|4+3x*y\verb|^|2+x,y,2)}\end{center}
Output :
\begin{center}{\tt 3*x}\end{center} 
Input :
\begin{center}{\tt coeff(-x\verb|^|4+3x*y\verb|^|2+x,[x,y],[1,2])}\end{center}
Output :
\begin{center}{\tt 3}\end{center} 

\subsection{Polynomial degree : {\tt degree}}\index{degree}
\noindent{\tt degree} takes as argument a polynomial given by it's symbolic 
representation or by the list of it's coefficients.\\
{\tt degree} returns the degree of this polynomial (highest
degree of it's non-zero monomials).\\ 
Input :
\begin{center}{\tt degree(x\verb|^|3+x)}\end{center}
Output :
\begin{center}{\tt 3}\end{center} 
Input :
\begin{center}{\tt degree([1,0,1,0])}\end{center}
Output :
\begin{center}{\tt 3}\end{center}

\subsection{Polynomial valuation : {\tt valuation ldegree}}\index{valuation}\index{ldegree}
\noindent{\tt valuation} or {\tt ldegree} takes as argument a polynomial given 
by a symbolic expression or by the list of it's coefficients.\\
{\tt valuation} or {\tt ldegree} returns the valuation of this 
polynomial, that is the lowest degree of it's non-zero monomials.\\
Input :
\begin{center}{\tt valuation(x\verb|^|3+x)}\end{center}
Output :
\begin{center}{\tt 1}\end{center} 
Input :
\begin{center}{\tt valuation([1,0,1,0])}\end{center}
Output :
\begin{center}{\tt 1}\end{center}

\subsection{Leading coefficient of a polynomial : {\tt lcoeff}}\index{lcoeff}
\noindent{\tt lcoeff}  takes as argument a polynomial given by a
symbolic expression or by the list of it's coefficients.\\
{\tt lcoeff} returns the leading coefficient of this polynomial,
that is the coefficient of the monomial of highest degree.\\
Input :
\begin{center}{\tt lcoeff([2,1,-1,0])}\end{center}
Output :
\begin{center}{\tt  2}\end{center}
Input :
\begin{center}{\tt lcoeff(3*x\verb|^|2+5*x,x)}\end{center}
Output :
\begin{center}{\tt  3}\end{center}
Input :
\begin{center}{\tt lcoeff(3*x\verb|^|2+5*x*y\verb|^|2,y)}\end{center}
Output :
\begin{center}{\tt  5*x}\end{center}

\subsection{Trailing coefficient degree of a polynomial : {\tt tcoeff}}\index{tcoeff}
\noindent{\tt tcoeff}  takes as argument a polynomial given by a
symbolic expression 
or by the list of its coefficients.\\
{\tt tcoeff}  returns the coefficient of the monomial of lowest degree 
of this polynomial ({\tt tcoeff}=trailing coefficient).\\
Input :
\begin{center}{\tt tcoeff([2,1,-1,0])}\end{center}
Output :
\begin{center}{\tt  -1}\end{center}
 Input :
\begin{center}{\tt tcoeff(3*x\verb|^|2+5*x,x)}\end{center}
Output :
\begin{center}{\tt  5}\end{center}
 Input :
\begin{center}{\tt tcoeff(3*x\verb|^|2+5*x*y\verb|^|2,y)}\end{center}
Output :
\begin{center}{\tt  3*x\verb|^|2}\end{center}

\subsection{Evaluation of a polynomial : {\tt peval polyEval}}\index{peval}
\index{polyEval}
\noindent{\tt peval} or {\tt polyEval} takes as argument a polynomial 
{\tt p} given by the list of its coefficients and a real {\tt a} .\\
{\tt peval} or {\tt polyEval} returns the exact or numeric value of 
{\tt p(a)} using Horner algorithm.\\ 
 Input :
\begin{center}{\tt peval([1,0,-1],sqrt(2))}\end{center}
Output :
\begin{center}{\tt sqrt(2)*sqrt(2)-1}\end{center} 
Then :
\begin{center}{\tt normal(sqrt(2)*sqrt(2)-1)}\end{center} 
Output :
\begin{center}{\tt {\tt 1}}\end{center} 
Input :
\begin{center}{\tt peval([1,0,-1],1.4)}\end{center}
Output :
\begin{center}{\tt  0.96}\end{center} 

\subsection{Factorize $x^n$ in a polynomial : {\tt factor\_xn}}\index{factor\_xn}
\noindent{\tt factor\_xn} takes as argument a polynomial {\tt P}.\\
{\tt factor\_xn} returns the polynomial {\tt P} written
as the product of it's monomial of largest degree $x^n$ ({\tt n=degree(P)})
with a rational fraction having a non-zero finite limit at infinity.\\ 
 Input :
\begin{center}{\tt factor\_xn(-x\verb|^|4+3)}\end{center}
Output :
\begin{center}{\tt x\verb|^|4*(-1+3*x\verb|^|-4)}\end{center} 

\subsection{GCD of the coefficients of a polynomial : {\tt content}}\index{content|textbf}
\noindent{\tt content} takes as argument a polynomial {\tt P} given by 
a symbolic expression or by the list of it's coefficients.\\
{\tt content} returns the content of {\tt P},
that is the GCD (greatest common divisor) of the coefficients of 
{\tt P}.\\
Input :
\begin{center}{\tt content(6*x\verb|^|2-3*x+9)}\end{center}
or:
\begin{center}{\tt content([6,-3,9],x))}\end{center}
Output :
\begin{center}{\tt  3}\end{center} 

\subsection{Primitive part of a polynomial : {\tt primpart}}\index{primpart}
\noindent{\tt primpart} takes as argument a polynomial {\tt P} given by a
symbolic expression or by the list of it's coefficients.\\
{\tt primpart} returns the primitive part of {\tt P},
that is {\tt P} divided  by the GCD 
(greatest common divisor) of it's coefficients.\\
Input :
\begin{center}{\tt primpart(6x\verb|^|2-3x+9)}\end{center}
or:
\begin{center}{\tt  primpart([6,-3,9],x))}\end{center}
Output :
\begin{center}{\tt 2*x\verb|^|2-x+3}\end{center} 

\subsection{Factorization : {\tt collect}}\index{collect}
\noindent{\tt collect} takes as argument a polynomial or a list of 
polynomials and optionnaly an algebraic extension like {\tt sqrt(n)}
(for $\sqrt{n}$).\\
{\tt collect} factorizes the polynomial (or the polynomials of the
list) on the field of it's coefficient (for example $\mathbb Q$)
or on the smallest extension containing the optional second argument (e.g.
$\mathbb Q[\sqrt{n}]$). In complex mode, the field is complexified.\\
{\bf Examples} :
\begin{itemize}
\item Factorize $x2-4$ over the integers,
input :
\begin{center}{\tt collect(x\verb|^|2-4)}\end{center}
Output in real mode :
\begin{center}{\tt (x-2)*(x+2)}\end{center}
\item Factorize $x2+4$ over the integers, input :
\begin{center}{\tt collect(x\verb|^|2+4)}\end{center}
Output  in real mode :
\begin{center}{\tt x\verb|^|2+4}\end{center}
Output  in complex mode :
\begin{center}{\tt (x+2*i)*(x-2*i)}\end{center}
\item Factorize $x2-2$ over the integers, input :
\begin{center}{\tt collect(x\verb|^|2-2)}\end{center}
Output in real mode :
\begin{center}{\tt x\verb|^|2-2}\end{center}
But if you input :
\begin{center}{\tt collect(sqrt(2)*(x\verb|^|2-2))}\end{center}
Output :
\begin{center}{\tt sqrt(2)*(x-sqrt(2))*(x+sqrt(2))}\end{center}
\item Factorize over the integers : 
$$x3-2x2+1 \mbox{ and } x2-x$$
Input :
 \begin{center}{\tt collect([x\verb|^|3-2*x\verb|^|2+1,x\verb|^|2-x])}\end{center}
Output :
\begin{center}{\tt  [(x-1)*(x\verb|^|2-x-1),x*(x-1)]}\end{center}
But, input :
 \begin{center}{\tt collect((x\verb|^|3-2*x\verb|^|2+1)*sqrt(5))}\end{center}
Output :
\begin{center}{\tt ((19*sqrt(5)-10)*((sqrt(5)+15)*x+7*sqrt(5)-5)* ((sqrt(5)+25)*x-13*sqrt(5)-15)*(x-1))/6820}\end{center}
Or, input :
\begin{center}{\tt collect(x\verb|^|3-2*x\verb|^|2+1,sqrt(5))}\end{center}
Output :
\begin{center}{\tt ((2*sqrt(5)-19)*((sqrt(5)+25)*x-13*sqrt(5)-15)*(-x+1)*((sqrt(5)+15)*x+7*sqrt(5)-5))/6820}\end{center}

\end{itemize}

\subsection{Factorization : {\tt factor factoriser}}\index{factor}\index{factoriser}\label{sec:factor}
\noindent {\tt factor} takes as argument a polynomial or a list of 
polynomials and optionnally an algebraic extension, e.g. {\tt sqrt(n)}.\\
{\tt factor} factorize the polynomial (or the polynomials of the list) on the
field of it's coefficients (the field is complexified in complex mode)
or on the smallest extension containing the optionnal second argument.
Unlike {\tt collect},
{\tt factor} will further factorize each factor of degree 2
if {\tt Sqrt} is  checked in the {\tt cas} configuration
(see also \ref{sec:factore}).
You can check the current configuration in the status button under
{\tt Xcas} and change the configuration by hitting this status button.\\
Input :
 \begin{center}{\tt factor(x\verb|^|2+2*x+1)}\end{center}
Output :
\begin{center}{\tt (x+1)\verb|^|2}\end{center}
Input :
\begin{center}{\tt factor(x\verb|^|4-2*x\verb|^|2+1)}\end{center}
Output :
\begin{center}{\tt (-x+1)\verb|^|2*(x+1)\verb|^|2}\end{center}
Input :
 \begin{center}{\tt factor(x\verb|^| 3-2*x\verb|^|2+1)}\end{center}
Output if {\tt Sqrt} is not checked in the {\tt cas} configuration :
\begin{center}{\tt  (x-1)*(x\verb|^|2-x-1)}\end{center}
Output if {\tt Sqrt} is  checked in the {\tt cas} configuration :
\begin{center}{\tt (x-1)*(x+(sqrt(5)-1)/2)*(x+(-sqrt(5)-1)/2)}\end{center}
Input :
 \begin{center}{\tt factor(x\verb|^| 3-2*x\verb|^|2+1,sqrt(5))}\end{center}
Output :
\begin{center}{\tt ((2*sqrt(5)-19)*((sqrt(5)+15)*x+7*sqrt(5)-5)*(-x+1)*((sqrt(5)+25)*x-13*sqrt(5)-15))/6820}\end{center}
Input :
 \begin{center}{\tt factor(x\verb|^|2+1)}\end{center}
Output in real mode :
\begin{center}{\tt  x\verb|^|2+1}\end{center}
Output in complex mode :
\begin{center}{\tt  ((-i)*x+1)*((i)*x+1)}\end{center}

\subsection{Square-free factorization : {\tt sqrfree}}\index{sqrfree}
\noindent{\tt sqrfree} takes as argument a polynomial.\\
{\tt sqrfree} factorizes this polynomial as a product of
powers of coprime factors, where each factor has roots of multiplicity 1
(in other words, a factor and it's derivative are coprime).\\
Input : 
\begin{center}{\tt sqrfree((x\verb|^|2-1)*(x-1)*(x+2))}\end{center} 
Output :
 \begin{center}{\tt (x\verb|^|2+3*x+2)*(x-1)\verb|^|2}\end{center} 
Input : 
\begin{center}{\tt sqrfree((x\verb|^|2-1)\verb|^|2*(x-1)*(x+2)\verb|^|2)}\end{center} 
Output :
 \begin{center}{\tt (x\verb|^|2+3*x+2)*(x-1)\verb|^|3}\end{center} 

\subsection{List of factors : {\tt factors}}\index{factors|textbf}
\noindent{\tt factors}  has either a polynomial or a list of polynomials as 
argument.\\
{\tt factors} returns a list containing the factors of the polynomial
and their exponents.\\
Input :
 \begin{center}{\tt factors(x\verb|^|2+2*x+1)}\end{center}
Output :
\begin{center}{\tt  [x+1,2]}\end{center}
Input :
 \begin{center}{\tt factors(x\verb|^|4-2*x\verb|^|2+1)}\end{center}
Output :
\begin{center}{\tt [x+1,2,x-1,2]}\end{center}
Input :
 \begin{center}{\tt factors([x\verb|^|3-2*x\verb|^|2+1,x\verb|^|2-x])}\end{center}
Output :
\begin{center}{\tt [[x-1,1,x\verb|^|2-x-1,1],[x,1,x-1,1]]}\end{center}
Input :
 \begin{center}{\tt factors([x\verb|^|2,x\verb|^|2-1])}\end{center}
Output :
\begin{center}{\tt  [[x,2],[x+1,1,x-1,1]]}\end{center}

\subsection{Evaluate a polynomial : {\tt horner}}\index{horner}
\noindent{\tt  horner} takes two arguments : a polynomial {\tt P} given by its 
symbolic expression or by the list of its coefficients and a number {\tt a}.\\ 
{\tt  horner} returns {\tt P(a)} computed using H\"{o}rner algorithm.\\
Input :
\begin{center}{\tt  horner(x\verb|^|2-2*x+1,2)}\end{center}
or  :
\begin{center}{\tt  horner([1,-2,1],2)}\end{center}
Output :
\begin{center}{\tt 1}\end{center}

\subsection{Rewrite in terms of the powers of (x-a) : {\tt ptayl}}\index{ptayl}
{\tt ptayl} is used to rewrite a polynomial {\tt P} depending of {\tt x}
in terms of the powers of {\tt (x-a)} 
({\tt ptayl} means polynomial Taylor)\\
{\tt ptayl} takes two arguments: a polynomial {\tt P} given by a
symbolic expression or by the list of it's coefficients and 
a number {\tt a}.\\
{\tt ptayl} returns the polynomial {\tt Q} such that {\tt Q(x-a)=P(x)}\\
Input :
\begin{center}{\tt ptayl(x\verb|^|2+2*x+1,2)}\end{center}
Output, the  polynomial Q:
\begin{center}{\tt  x\verb|^|2+6*x+9}\end{center}
Input :
\begin{center}{\tt  ptayl([1,2,1],2)}\end{center}
Output :
\begin{center}{\tt [1,6,9]}\end{center}
{\bf Remark}
\begin{center}{\tt P(x)=Q(x-a)}\end{center}
i.e. for the example :\\
$x2+2x+1=(x-2)2+6(x-2)+9$

\subsection{Compute with the exact root  of a polynomial : {\tt rootof}}\index{rootof}
Let $P$ and $Q$ be two polynomials given by the list of their coefficients
then {\tt rootof(P,Q)} denotes the value $P(\alpha)$ where $\alpha$ is the 
root of $Q$ with largest real part (and largest imaginary part in
case of equality).\\
In exact computations, {\tt Xcas} will rewrite rational evaluations
of {\tt rootof} as a unique {\tt rootof} with degree$(P)<$degree$(Q)$.
If the resulting rootof is the solution of a second degree equation,
it will be simplified.

{\bf Example}\\
Let $\alpha$ be the root with largest imaginary
part of $Q(x)=x4+10x2+1$ (all roots of $Q$ have real part equal to 0).
\begin{itemize}
\item Compute $\displaystyle \frac{1}{\alpha}$. Input :
\begin{center}{\tt normal(1/rootof([1,0],[1,0,10,0,1])) }\end{center}
$P(x)=x$ is represented by [1,0] and  $\alpha$
by {\tt rootof([1,0],[1,0,10,0,1])}.\\
Output :
\begin{center}{\tt rootof([[-1,0,-10,0],[1,0,10,0,1]])}\end{center}
i.e. :
\[  \frac{1}{\alpha}=-\alpha3-10\alpha \]
\item Compute $\alpha2$. Input :
\begin{center}{\tt
    normal(rootof([1,0],[1,0,10,0,1])\verb|^|2)}\end{center}
or (since $P(x)=x2$ is represented by [1,0,0]) input
\begin{center}{\tt normal(rootof([1,0,0],[1,0,10,0,1]))}\end{center}
Output :
\begin{center}{\tt -5-2*sqrt(6)}\end{center}
\end{itemize}

\subsection{Exact roots of a polynomial : {\tt roots}}\index{roots}
\noindent{\tt roots} takes as arguments a symbolic
polynomial expression and the name of it's variable.\\
{\tt roots} returns a 2 columns matrix : each row is 
the list of a root of the polynomial and it's multiplicity.\\
{\bf Examples}
\begin{itemize}
\item Find the roots of $P(x)=x5-2x4+x3$.\\
Input :
\begin{center}{\tt roots(x\verb|^|5-2*x\verb|^|4+x\verb|^|3) }\end{center}
Output :
\begin{center}{\tt [[8+3*sqrt(7),1],[8-3*sqrt(7),1],[0,3]]}\end{center}
\item  Find the roots of
$x^{10}-15x8+90x6-270x4+405x2-243=(x2-3)5$.\\
 Input :
\begin{center}{\tt roots(x\verb|^|10-15*x\verb|^|8+90*x\verb|^|6-270*x\verb|^|4+405*x\verb|^|2-243)}\end{center}
Output :
\begin{center}{\tt[[sqrt(3),5],[-(sqrt(3)),5]]}\end{center}
\item  Find the roots of $(t3-3)$.\\
Input :
\begin{center}{\tt roots(t\verb|^|3-1,t)}\end{center}
Output :
\begin{center}{\tt[[(-1+(i)*sqrt(3))/2,1],[(-1-(i)*sqrt(3))/2,1],[1,1]]}\end{center}
\end{itemize}

\subsection{Coefficients of a polynomial defined by its roots : {\tt pcoeff pcoef}}\index{pcoeff}\index{pcoef}
\noindent{\tt pcoeff} (or {\tt pcoef}) takes as argument a list of
the  roots of a polynomial $P$.\\
{\tt pcoeff} (or {\tt pcoef}) returns a univariate polynomial having
these roots,
represented as the list of it's coefficients by decreasing order.\\
Input :
\begin{center}{\tt pcoef([1,2,0,0,3])}\end{center}
Output :
\begin{center}{\tt [1,-6,11,-6,0,0]}\end{center}
i.e. $(x-1)(x-2)(x2)(x-3)=x5-6x4+11x3-6x2$.

\subsection{Truncate of order $n$ : {\tt truncate}}\index{truncate}
\noindent{\tt truncate} takes as argument, a polynomial and an integer 
{\tt n}.\\
{\tt truncate} truncates this polynomial at order {\tt n} (removing
all terms of order greater or equal to {\tt n+1}).\\
{\tt truncate} may be used to transform a series expansion into a 
polynomial or to compute series expansion step by step.\\
Input :
\begin{center}{\tt truncate((1+x+x\verb|^|2/2)\verb|^|3,4)}\end{center}
Output :
\begin{center}{\tt (9*x\verb|^|4+16*x\verb|^|3+18*x\verb|^|2+12*x+4)/4}\end{center}
Input :
\begin{center}{\tt truncate(series(sin(x)),4)}\end{center}
Output :
\begin{center}{\tt (-x\verb|^|3-(-6)*x)/6}\end{center}
Note that the returned polynomial is normalized.

\subsection{Convert a series expansion into a polynomial : {\tt convert convertir}}\index{convert}\index{convertir}\index{polynom@{\sl polynom}|textbf}\label{sec:convertpoly}
\noindent{\tt convert}, with the option {\tt polynom}, converts a Taylor series
into a polynomial. It should be used for operations like drawing 
the graph of the Taylor series of a function near a point.\\
{\tt convert} takes two arguments : an expression
and the option {\tt polynom}.\\
{\tt convert} replaces the {\tt order\_size} functions by 0 inside the
expression.\\
Input :
\begin{center}{\tt convert(taylor(sin(x)),polynom)}\end{center}
Output :
\begin{center}{\tt x+1/-6*x\verb|^|3+1/120*\verb|x^|5+x\verb|^|6*0}\end{center}
Input :
\begin{center}{\tt convert(series(sin(x),x=0,6),polynom)}\end{center}
Output :
\begin{center}{\tt x+1/-6*x\verb|^|3+1/120*\verb|x^|5+x\verb|^|7*0}\end{center}

\subsection{Random polynomial : {\tt randpoly randPoly}}\index{randpoly}\index{randPoly}
\noindent{\tt randpoly} (or {\tt randPoly}) takes two arguments: the name of a 
variable (by default {\tt x}) and  an integer {\tt n} (the order of the
arguments is not important).\\
{\tt randpoly} returns a polynomial with respect to the variable 
given argument (or {\tt x} if none was provided), 
of degree the second argument, having as coefficients
random integers evenly distributed on -99..+99.\\ 
Input :
\begin{center}{\tt randpoly(t,4)}\end{center}
Output for example:
\begin{center}{\tt -8*t\verb|^|4-87*t\verb|^|3-52*t\verb|^|2+94*t+80}\end{center}
Input :
\begin{center}{\tt randpoly(4)}\end{center}
Output for example:
\begin{center}{\tt 70*x\verb|^|4-46*x\verb|^|3-7*x\verb|^|2-24*x+52}\end{center}
Input :
\begin{center}{\tt randpoly(4,u)}\end{center}
Output for example:
\begin{center}{\tt 2*u\verb|^|4+33*u\verb|^|3-6*u\verb|^|2-92*u-12}\end{center}

\subsection{Change the order of variables : {\tt reorder}}\index{reorder}
\noindent{\tt reorder}  takes  two arguments : an expression and a vector 
of variable names.\\
{\tt reorder} expands the expression according to the order of variables
given as second argument.\\
Input :
\begin{center}{\tt reorder(x\verb|^|2+2*x*a+a\verb|^|2+z\verb|^|2-x*z,[a,x,z])}\end{center}
Output :
\begin{center}{\tt a\verb|^|2+2*a*x+x\verb|^|2-x*z+z\verb|^|2}\end{center}
{\bf Warning} :\\
The variables must be symbolic (if not, purge them before calling
{\tt reorder})

\subsection{Random list : {\tt ranm}}\index{ranm}\label{sec:ranm1}
\noindent{\tt ranm} takes as argument an integer {\tt n}.\\
{\tt ranm} returns a list of {\tt n} random integers (between -99 and  +99).
This list can be seen as the coefficients of an univariate 
polynomial of degree {\tt n-1}
(see also \ref{sec:ranm2} and  \ref{sec:ranm3}).\\
Input :
\begin{center}{\tt ranm(3)}\end{center}
Output :
\begin{center}{\tt [68,-21,56]}\end{center}

\subsection{Lagrange's polynomial  : {\tt lagrange interp}}\index{lagrange}\index{interp}
\noindent{\tt lagrange} takes as argument two lists of size {\tt n} (resp a 
matrix with two rows and  {\tt n} columns) and the name of a  variable 
{\tt var} (by default {\tt x}).\\
The first list (resp row) corresponds to the abscissa values $x_k$ ($k=1..n$), 
and the second list (resp row) corresponds to ordinate values $y_k$ 
($k=1..n$).\\
{\tt lagrange} returns a polynomial expression {\tt P} 
with respect to {\tt var} of degree 
{\tt n-1}, such that $P(x_i)=y_i$.\\
Input :
\begin{center}{\tt lagrange([[1,3],[0,1]])}\end{center}
or :
\begin{center}{\tt lagrange([1,3],[0,1])}\end{center}
Output :
\begin{center}{\tt (x-1)/2}\end{center}
since $\frac{x-1}{2}=0$ for $x=1$,  and  $\frac{x-1}{2}=1$ for $x=3$.\\ 
Input :
\begin{center}{\tt lagrange([1,3],[0,1],y)}\end{center}
Output :
\begin{center}{\tt (y-1)/2}\end{center}
{\bf Warning}\\
{\tt f:=lagrange([1,2],[3,4],y)} does not return a function 
but an expression with respect to $y$.
To define $f$ as a function, input
\begin{center}
{\tt f:=unapply(lagrange([1,2],[3,4],x),x)}
\end{center}
Avoid {\tt f(x):=lagrange([1,2],[3,4],x)} since
the Lagrange polynomial would be computed each time {\tt f} is called
(indeed in a function definition, the second member of the affectation
is not evaluated).
Note also that \\
{\tt g(x):=lagrange([1,2],[3,4])} would not work
since the default argument of {\tt lagrange}
would be global, hence not the same as the local
variable used for the definition of {\tt g}.

\subsection{Natural splines: {\tt spline}}\index{spline|textbf}
\subsubsection{Definition}
Let $\sigma_n$ be a subdivision of a real interval $[a,b]$~:
\[ a=x_0,\quad x_1,\quad...,\quad x_n=b \]
$s$ is a spline function of degree $l$, if $s$ is an  application from $[a,b]$ 
in $\mathbb R$ such that~:
\begin{itemize}
\item $s$ has continuous derivatives up to the order $l-1$,
\item on each interval of the subdivision, $s$ 
is a polynomial of degree less or equal than $l$.
\end{itemize}

\subsubsection{Theorem}
The set of spline functions of degree $l$ on $\sigma_n$ is a
$\mathbb R$-vectorial subspace of dimension $n+l$.

{\bf Proof}\\
On $[a,x_1]$, $s$ is a polynomial $A$ of degree less or equal to
$l$, hence on $[a,x_1]$, $s=A(x)=a_0+a_1x+...a_lx^l$ and  $A$ is a linear 
combinaison of $1,x,...x^l$.\\
On $[x_1,x_2]$, $s$ is a polynomial $B$ of degree less or equal to
$l$, hence on $[x_1,x_2]$, $s=B(x)=b_0+b_1x+...b_lx^l$.\\
$s$ has continuous derivatives up to order $l-1$, hence :
\[ \forall 0 \leq j \leq l-1, \quad  B^{(j)}(x_1)-A^{(j)}(x_1)=0\]
therefore $B(x)-A(x)=\alpha_1(x-x_1)^l$ or $B(x)=A(x)+\alpha_1(x-x_1)^l$.\\
Define the function :
\[\mbox{q}_1(x)  \mbox{ = }
\left\{
\begin{array}{rcl}
0 & \mbox{sur} & [a,x_1] \\
(x-x_1)^l  & \mbox{sur} & [x_1,b]\\
\end{array} 
\right.
\]
Hence :
\[ s|_{[a,x_2]}=a_0+a_1x+...a_lx^l+\alpha_1q_1(x) \]
On $[x_2,x_3]$, $s$ is a polynomial $C$ of degree less or equal than
$l$, hence on $[x_2,x_3]$, $s=C(x)=c_0+c_1x+...c_lx^l$.\\
$s$ has continuous derivatives until $l-1$, hence :  
\[ \forall 0 \leq j \leq l-1, \quad  C^{(j)}(x_2)-B^{(j)}(x_2)=0\]
therefore $C(x)-B(x)=\alpha_2(x-x_2)^l$ or $C(x)=B(x)+\alpha_2(x-x_2)^l$.\\
Define the function :
\[\mbox{q}_2(x)  \mbox{ = }
\left\{
\begin{array}{rcl}
0 & \mbox{on} & [a,x_2] \\
(x-x_2)^l  & \mbox{on} & [x_2,b]\\
\end{array} 
\right.
\]
Hence :
$s|_{[a,x_3]}=a_0+a_1x+...a_lx^l+\alpha_1q_1(x)+\alpha_2q_2(x)$\\
And so on, the functions are defined by :
\[\forall 1 \leq j \leq n-1, \mbox{q}_j(x)  \mbox{ = }
\left\{
\begin{array}{rcl}
0 & \mbox{on} & [a,x_j] \\
(x-x_j)^l  & \mbox{on} & [x_j,b]\\
\end{array} 
\right.
\]
hence,
\[ s|_{[a,b]}=a_0+a_1x+...a_lx^l+\alpha_1q_1(x)+....+\alpha_{n-1}q_{n-1}(x) \]
and $s$ is a linear combination of $n+l$ independant functions 
$1,x,..x^l,q_1,..q_{n-1}$.

\subsubsection{Interpolation with spline functions}
If we want to interpolate a function $f$ on $\sigma_n$ by a spline function
 $s$ of degree $l$, then $s$ must verify $s(x_k)=y_k=f(x_k)$ for all 
$0\geq k\geq n$. Hence there are $n+1$ conditions, and $l-1$ degrees of 
liberty. We can therefore add $l-1$ conditions, these conditions are on the 
derivatives of $s$ at $a$ and  $b$.

Hermite interpolation, natural interpolation and periodic interpolation
are three kinds of interpolation obtained by specifying three kinds 
of constraints. The unicity of the  
solution of the interpolation problem can be proved
for each kind of constraints.

If $l$ is odd ($l=2m-1$), there are  $2m-2$ degrees of
liberty. The constraints are defined by :
\begin{itemize}
\item Hermite interpolation
\[ \forall 1\leq j\leq m-1, \quad s^{(j)}(a)=f^{(j)}(a),
s^{(j)}(b)=f^{(j)}(b) \]
\item  Natural interpolation
\[ \forall m \leq j \leq 2m-2, \quad s^{(j)}(a)=s^{(j)}(b)=0 \]
\item periodic interpolation 
\[\forall 1\leq j\leq 2m-2, \quad s^{(j)}(a)=s^{(j)}(b) \]
\end{itemize}

If $l$ is even ($l=2m$), there are $2m-1$ degrees of
liberty. The constraints are defined by :
\begin{itemize}
\item Hermite interpolation
\[ \forall 1\leq j\leq m-1, \quad s^{(j)}(a)=f^{(j)}(a),
s^{(j)}(b)=f^{(j)}(b) \] 
and
\[s^{(m)}(a)=f^{(m)}(a)\] 
\item Natural interpolation 
\[ \forall m \leq j \leq 2m-2, \quad s^{(j)}(a)=s^{(j)}(b)=0 \]
and
\[s^{(2m-1)}(a)=0\] 
\item  Periodic interpolation
\[\forall 1\leq j\leq 2m-1, \quad s^{(j)}(a)=s^{(j)}(b) \]
\end{itemize}
A natural spline 
is a spline function which verifies the natural interpolation constraints.

{\tt spline} takes as arguments a list of abscissa (by increasing order), 
a list of ordinates, a variable name, and a degree.\\
{\tt spline} returns the natural spline function (with the specified degree
and crossing points) as a list of polynomials, each 
polynomial being valid on an interval.

Examples:
\begin{enumerate}
\item a natural spline of degree 3, crossing through the points 
$x_0=0,y_0=1$, $x_1=1,y_1=3$ and  $x_2=2, y_2=0$, input~:
\begin{center}
{\tt spline([0,1,2],[1,3,0],x,3)}
\end{center}
Output is a list of two polynomial expressions of $x$~:
\[[ -5*x3/4+13*x/4+1, \quad 5*(x-1)3/4-15*(x-1)2/4+(x-1)/-2+3 ]\]
defined respectivly on the intervals $[0,1]$ and  $[1,2]$.
\item a natural spline of degree 4, crossing through the points 
$x_0=0,y_0=1$, $x_1=1,y_1=3$, $x_2=2, y_2=0$ and  $x_3=3, y_3=-1$, 
input~:
\begin{center}
{\tt spline([0,1,2,3],[1,3,0,-1],x,4)}
\end{center}
Output is a list of three polynomial functions of $x$~:
\[ [(-62*x4+304*x)/121+1,\] 
\[(201*(x-1)4-248*(x-1)3-372*(x-1)2+56*(x-1))/121+3,\] 
\[(-139*(x-2)4+556*(x-2)3+90*(x-2)2+-628*(x-2))/121]\]
defined respectivly on the intervals $[0,1]$, $[1,2]$ and  $[2,3]$.
\item The natural spline interpolation of $\cos$ on 
$[0,\pi/2,3\pi/2]$, input~:
\begin{center}
{\tt spline([0,pi/2,3*pi/2],cos([0,pi/2,3*pi/2]),x,3)}
\end{center}
Output~:
\[
[((3*\pi3+(-7*\pi2)*x+4*x3)*1/3)/(\pi3),\]
\[((15*\pi3+(-46*\pi2)*x+36*\pi*x2-8*x3)*1/12)/(\pi3)]
\]
\end{enumerate}


\section{Arithmetic and polynomials}
Polynomials are represented by expressions or by list of coefficients
by decreasing power order. In the first case, for instructions requiring
a main variable (like extended gcd computations), the variable
used by default is $x$ if not specified. For modular coefficients
in $\Z/n\Z$, use {\tt \% n } for each coefficient of the list
or apply it to the expression defining the polynomial.

\subsection{The divisors of a polynomial : {\tt divis}}\index{divis}
\noindent{\tt divis} takes as argument a polynomial (or a list of 
polynomials) and returns the list
 of the divisors of the polynomial(s).\\ 
Input : 
\begin{center}{\tt divis(x\verb|^|4-1)}\end{center}
Output :
\begin{center}{\tt [1,x\verb|^|2+1,x+1,(x\verb|^|2+1)*(x+1),x-1,(x\verb|^|2+1)*(x-1),}\end{center}
\begin{center}{\tt (x+1)*(x-1),(x\verb|^|2+1)*(x+1)*(x-1)]}\end{center}
Input : 
\begin{center}{\tt divis([x\verb|^|2,x\verb|^|2-1])}\end{center}
Output :
\begin{center}{\tt [[1,x,x\verb|^|2],[1,x+1,x-1,(x+1)*(x-1)]]}\end{center}

\subsection{Euclidean quotient : {\tt quo}}\index{quo|textbf}
\noindent{\tt quo} returns the euclidean quotient  $q$ of the
Euclidean division between two polynomials (decreasing power division)
If the polynomials are represented as 
expressions, the variable may be specified as a third
argument.\\
Input :
\begin{center}{\tt quo(x\verb|^|2+2*x +1,x)}\end{center}
Output :
\begin{center}{\tt x+2}\end{center}
Input :
\begin{center}{\tt quo(y\verb|^|2+2*y +1,y,y)}\end{center}
Output :
\begin{center}{\tt y+2}\end{center}
In list representation, the quotient of $x^2+2x+4$ by $x^2+x+2$ 
one can also input :
\begin{center}{\tt quo([1,2,4],[1,1,2])}\end{center}
Output :
\begin{center}{\tt [1]}\end{center}
that is to say  the polynomial {\tt 1}.

\subsection{Euclidean quotient : {\tt Quo}}\index{Quo|textbf}
\noindent {\tt Quo} is the inert form of {\tt quo}.\\
{\tt Quo} returns the euclidean quotient between two polynomials
(decreasing power division) without evaluation. 
It is used when {\tt Xcas} is in Maple mode to compute
the euclidean quotient of the division of two
polynomials with coefficients in $\Z/p\Z$ using Maple-like syntax.\\
In {\tt Xcas}  mode, input :
\begin{center}{\tt Quo(x\verb|^|2+2*x+1,x)}\end{center}
Output :
\begin{center}{\tt quo(x\verb|^|2+2*x+1,x)}\end{center}
In {\tt Maple}  mode, input :
\begin{center}{\tt Quo(x\verb|^|3+3*x,2*x\verb|^|2+6*x+5) mod 5}\end{center}
Output :
\begin{center}{\tt -(2)*x+1)}\end{center}
The division was done using modular arithmetic, unlike with
\begin{center}{\tt quo(x\verb|^|3+3*x,2*x\verb|^|2+6*x+5) mod 5}\end{center}
where the division is done in $\Z[X]$ and reduced after to:
\begin{center}{\tt 3*x-9}\end{center}
If {\tt Xcas} is not in Maple mode, polynomial division 
in $\Z/p\Z[X]$ is done e.g. by~:
\begin{center}
\verb|quo((x^3+3*x)% 5,(2x^2+6x+5)%5)|
\end{center}

\subsection{Euclidean remainder : {\tt rem}}\index{rem|textbf}
\noindent{\tt rem} returns the euclidean remainder between two polynomials
(decreasing power division). If the polynomials are represented as 
expressions, the variable may be specified as a third
argument.\\
Input :
\begin{center}{\tt rem(x\verb|^|3-1,x\verb|^|2-1)}\end{center}
Output :
\begin{center}{\tt x-1}\end{center}
To have the remainder of $x^2+2x+4$ by $x^2+x+2$ we can also input :
\begin{center}{\tt  rem([1,2,4],[1,1,2])}\end{center}
Output :
\begin{center}{\tt [1,2]}\end{center}
i.e. le polynomial $x+2$.

\subsection{Euclidien remainder: {\tt Rem}}\index{Rem|textbf}
\noindent{\tt Rem}  is the inert form of {\tt rem}.\\
{\tt Rem} returns the euclidean remainder between two polynomials
(decreasing power division) without evaluation. 
It is used when {\tt Xcas} is in Maple mode to compute
the euclidean remainder of the division of two
polynomials with coefficients in $\Z/p\Z$ using Maple-like syntax.\\
In {\tt Xcas}  mode, input :
\begin{center}{\tt Rem(x\verb|^|3-1,x\verb|^|2-1)}\end{center}
Output :
\begin{center}{\tt rem(x\verb|^|3-1,x\verb|^|2-1)}\end{center}
In {\tt Maple}  mode, input  :
\begin{center}{\tt Rem(x\verb|^|3+3*x,2*x\verb|^|2+6*x+5) mod 5}\end{center}
Output :
\begin{center}{\tt 2*x}\end{center}
The division was done using modular arithmetic, unlike with
\begin{center}{\tt rem(x\verb|^|3+3*x,2*x\verb|^|2+6*x+5) mod 5}\end{center}
where the division is done in $\Z[X]$ and reduced after to:
\begin{center}{\tt 12*x}\end{center}
If {\tt Xcas} is not in Maple mode, polynomial division 
in $\Z/p\Z[X]$ is done e.g. by~:
\begin{center}\verb|rem((x^3+3*x)% 5,(2x^2+6x+5)%5)|
\end{center}

\subsection{Quotient and remainder : {\tt quorem divide}}\index{quorem|textbf}\index{divide|textbf}\label{sec:quorem} 
\noindent{\tt quorem} (or {\tt divide}) returns the list of the quotient and 
the remainder of the euclidian division (by decreassing power) of two
polynomials.\\
Input :
\begin{center}{\tt quorem([1,2,4],[1,1,2]) }\end{center}
Output :
\begin{center}{\tt [poly1[1],poly1[1,2]]}\end{center}
Input :
\begin{center}{\tt quorem(x\verb|^|3-1,x\verb|^|2-1)}\end{center}
Output :
\begin{center}{\tt [x,x-1]}\end{center}

\subsection{GCD of two polynomials with Euclide algorithm: {\tt gcd}}\index{gcd}\label{sec:gcd}
\noindent{\tt gcd} denotes the gcd (greatest common divisor) of two polynomials
(or of a list of polynomials or of a sequence of polynomials) 
(see also \ref{sec:igcd} for GCD of integers).

{\bf Examples}\\ 
Input :
\begin{center}{\tt gcd(x\verb|^|2+2*x+1,x\verb|^|2-1)}\end{center}
Output :
\begin{center}{\tt x+1 }\end{center} 
Input :
\begin{center}{\tt gcd(x\verb|^|2-2*x+1,x\verb|^|3-1,x\verb|^|2-1,x\verb|^|2+x-2)}\end{center}
or
\begin{center}{\tt gcd([x\verb|^|2-2*x+1,x\verb|^|3-1,x\verb|^|2-1,x\verb|^|2+x-2])}\end{center}
Output :
\begin{center}{\tt x-1}\end{center}

For polynomials with modular coefficients, input e.g. :
\begin{center}{\tt gcd((x\verb|^|2+2*x+1) mod 5,(x\verb|^|2-1) mod 5)}\end{center} 
Output :
\begin{center}{\tt x \% 5}\end{center}
Note that :
\begin{center}{\tt gcd(x\verb|^|2+2*x+1,x\verb|^|2-1) mod 5}\end{center} 
will output :
\begin{center}{\tt 1}\end{center}
since the mod operation is done after the GCD is computed in $\Z[X]$.

\subsection{GCD of two polynomials with Euclide algorithm : {\tt Gcd}}\index{Gcd}
\noindent{\tt Gcd}  is the inert form of  {\tt gcd}.
{\tt Gcd} returns the gcd (greatest common divisor) of two polynomials
(or of a list of polynomials or of a sequence of polynomials) without
evaluation. It is used when {\tt Xcas} is in Maple mode to compute
gcd of polynomials with coefficients in $\Z/p\Z$ using Maple-like syntax.\\
Input in {\tt Xcas} mode  :
\begin{center}{\tt Gcd(x\verb|^|3-1,x\verb|^|2-1)}\end{center}
Output :
\begin{center}{\tt gcd(x\verb|^|3-1,x\verb|^|2-1)}\end{center}
Input in {\tt Maple} mode  :
\begin{center}{\tt Gcd(x\verb|^|2+2*x,x\verb|^|2+6*x+5) mod 5}\end{center}
Output :
\begin{center}{\tt 1}\end{center}

\subsection{Choosing  the GCD algorithm  of two polynomials : 
{\tt ezgcd heugcd modgcd psrgcd}}\index{ezgcd}\index{psrgcd}\index{modgcd}\index{heugcd}
\noindent{\tt ezgcd heugcd modgcd psrgcd} denotes the gcd 
(greatest common divisor) of two univariate or multivariate
polynomials with coefficients
in $\Z$ or $\Z[i]$ using a specific algorithm~:
\begin{itemize}
\item {\tt ezgcd} ezgcd algorithm,
\item {\tt heugcd} heuristic gcd algorithm,
\item {\tt modgcd} modular algorithm,
\item {\tt psrgcd} sub-resultant algorithm.
\end{itemize}
Input :
\begin{center}{\tt ezgcd(x\verb|^|2-2*x*y+y\verb|^|2-1,x-y)}\end{center}
or
\begin{center}{\tt heugcd(x\verb|^|2-2*x*y+y\verb|^|2-1,x-y)}\end{center}
or
\begin{center}{\tt modgcd(x\verb|^|2-2*x*y+y\verb|^|2-1,x-y)}\end{center}
or
\begin{center}{\tt psrgcd(x\verb|^|2-2*x*y+y\verb|^|2-1,x-y)}\end{center}
Output :
\begin{center}{\tt 1 }\end{center} 
Input :
\begin{center}{\tt ezgcd((x+y-1)*(x+y+1),(x+y+1)\verb|^|2)}\end{center}
or
\begin{center}{\tt heugcd((x+y-1)*(x+y+1),(x+y+1)\verb|^|2)}\end{center}
or
\begin{center}{\tt modgcd((x+y-1)*(x+y+1),(x+y+1)\verb|^|2)}\end{center}
Output :
\begin{center}{\tt x+y+1}\end{center}
Input :
\begin{center}{\tt psrgcd((x+y-1)*(x+y+1),(x+y+1)\verb|^|2)}\end{center}
Output :
\begin{center}{\tt -x-y-1}\end{center}
Input :
\begin{center}{\tt ezgcd((x+1)\verb|^|4-y\verb|^|4,(x+1-y)\verb|^|2)}\end{center}
Output :
\begin{center}{\tt "GCD not successfull Error: Bad Argument Value"}\end{center}
 But input :
\begin{center}{\tt heugcd((x+1)\verb|^|4-y\verb|^|4,(x+1-y)\verb|^|2)}\end{center}
or 
\begin{center}{\tt modgcd((x+1)\verb|^|4-y\verb|^|4,(x+1-y)\verb|^|2)}\end{center}
or 
\begin{center}{\tt psrgcd((x+1)\verb|^|4-y\verb|^|4,(x+1-y)\verb|^|2)}\end{center}
Output :
\begin{center}{\tt x-y+1 }\end{center} 

\subsection{LCM of two polynomials : {\tt lcm}}\index{lcm}\label{sec:lcm}
\noindent{\tt lcm} returns the LCM (Least Common Multiple) of two polynomials
(or of a list of polynomials or of a sequence of polynomials)
(see \ref{sec:ilcm} for LCM of integers).\\
Input :
\begin{center}{\tt lcm(x\verb|^|2+2*x+1,x\verb|^|2-1)}\end{center}
Output :
\begin{center}{\tt  (x+1)*(x\verb|^|2-1)}\end{center}
Input :
\begin{center}{\tt lcm(x,x\verb|^|2+2*x+1,x\verb|^|2-1)}\end{center}
or
\begin{center}{\tt lcm([x,x\verb|^|2+2*x+1,x\verb|^|2-1])}\end{center}
Output :
\begin{center}{\tt (x\verb|^|2+x)*(x\verb|^|2-1)}\end{center}

\subsection{B\'ezout's Identity : {\tt egcd gcdex}}\index{egcd}\index{gcdex}
This function compute the polynomial coefficients of the B\'ezout's 
Identity (also known as Extended Greatest Common Divisor). 
Given two polynomials $A(x),B(x)$, {\tt egcd} computes 3 polynomials
$U(x),V(x)$ and $D(x)$ such that~:
\[    U(x)*A(x)+V(x)*B(x)=D(x)=GCD(A(x),B(x)) \]
{\tt egcd} takes 2 or 3 arguments: the polynomials $A$ and $B$ as
expressions in terms of a variable, if the variable is not specified
it will default to $x$. Alternatively, $A$ and $B$ may be given
as list-polynomials.\\
Input :
\begin{center}{\tt egcd(x\verb|^|2+2*x+1,x\verb|^|2-1)}\end{center}
Output :
\begin{center}{\tt  [1,-1,2*x+2]}\end{center}
Input :
\begin{center}{\tt egcd([1,2,1],[1,0,-1])}\end{center}
Output :
\begin{center}{\tt  [[1],[-1],[2,2]]}\end{center}
Input :
\begin{center}{\tt egcd(y\verb|^|2-2*y+1,y\verb|^|2-y+2,y)}\end{center}
Output :
\begin{center}{\tt  [y-2,-y+3,4]}\end{center}
Input :
\begin{center}{\tt egcd([1,-2,1],[1,-1,2])}\end{center}
Output :
\begin{center}{\tt [[1,-2],[-1,3],[4]]}\end{center}

\subsection{Solving au+bv=c over polynomials: {\tt abcuv}}\index{abcuv}
{\tt abcuv} solves the polynomial equation
\[ C(x)=U(x)*A(x)+V(x)*B(x) \]
where $A,B,C$ are given polynomials and $U$ and $V$ are unknown
polynomials. $C$ must be a multiple of the gcd of $A$ and $B$
for a solution to exist. {\tt abcuv} takes 3 expressions as argument,
and an optional variable specification (which defaults to $x$)
and returns a list of 2 expressions ($U$ and $V$). Alternatively, the
polynomials $A,B,C$ may be entered as list-polynomials.

Input :
\begin{center}{\tt abcuv(x\verb|^|2+2*x+1 ,x\verb|^|2-1,x+1)}\end{center}
Output :
\begin{center}{\tt [1/2,1/-2]}\end{center}
Input :
\begin{center}{\tt abcuv(x\verb|^|2+2*x+1 ,x\verb|^|2-1,x\verb|^|3+1)}\end{center}
Output :
\begin{center}{\tt [1/2*x\verb|^|2+1/-2*x+1/2,-1/2*x\verb|^|2-1/-2*x-1/2]}\end{center}
Input :
\begin{center}{\tt abcuv([1,2,1],[1,0,-1],[1,0,0,1])}\end{center}
Output :
\begin{center}{\tt [poly1[1/2,1/-2,1/2],poly1[1/-2,1/2,1/-2]]}\end{center}

% 

\subsection{Chinese remainders : {\tt chinrem}}\index{chinrem}
\noindent{\tt chinrem} takes two lists as argument, each list being made of 2  
polynomials (either expressions or as a list of coefficients in decreassing 
order). If the polynomials are expressions, an optionnal third
argument may be provided to specify the main variable, by default
{\tt x} is used.
{\tt chinrem([A,R],[B,Q])} returns the list of two polynomials
{\tt P} and {\tt S} such that :
\[  S=R.Q, \quad  P=A \pmod R, P=B \pmod Q \]
If {\tt R} and {\tt Q} are coprime, a solution {\tt P} always exists 
and all the solutions are congruent modulo {\tt S=R*Q}.
For example, assume we want to solve :
\[ {\tt \left\{ \begin{array}{rlr} P(x)=&x\ &\bmod\ (x^2+1)\\
      P(x)=&x-1\ &\bmod\ (x^2-1) \end{array}\right.} \]
Input :
\begin{center}{\tt chinrem([[1,0],[1,0,1]],[[1,-1],[1,0,-1]])}\end{center}
Output :
\begin{center}{\tt [[1/-2,1,1/-2],[1,0,0,0,-1]]}\end{center}
or :
\begin{center}{\tt chinrem([x,x\verb|^|2+1],[x-1,x\verb|^|2-1])}\end{center}
Output :
\begin{center}{\tt [1/-2*x\verb|^|2+x+1/-2,x\verb|^|4-1]}\end{center}
hence $\displaystyle P(x)=-\frac{x^2-2.x+1}{2} \ (\bmod\  x^4-1)$\\
Another example, input :
\begin{center}{\tt chinrem([[1,2],[1,0,1]],[[1,1],[1,1,1]])}\end{center}
Output :
\begin{center}{\tt [[-1,-1,0,1],[1,1,2,1,1]]}\end{center}
or :
\begin{center}{\tt chinrem([y+2,y\verb|^|2+1],[y+1,y\verb|^|2+y+1],y)}\end{center}
Output :
\begin{center}{\tt [-y\verb|^|3-y\verb|^|2+1,y\verb|^|4+y\verb|^|3+2*y\verb|^|2+y+1]}\end{center}

\subsection{Cyclotomic polynomial : {\tt cyclotomic}}\index{cyclotomic}
\noindent{\tt cyclotomic}  takes an integer $n$ as argument and
returns the list of the coefficients of the cyclotomic 
polynomial of index $n$.  This
is the polynomial having the $n$-th pritmitive roots of the unity
as zeros (a $n$-th root of the unity is primitive if the set of its 
powers is the set of all the $n$-th root of the unity).

For example, let $n=4$, the fourth roots of the unity are:
$\{ 1,i,-1,-i\}$ and the primitive roots are: $\{i,-i\}$.
Hence, the cyclotomic polynomial of index $4$ is $(x-i).(x+i)=x^2+1$.
Verification:
\begin{center}{\tt cyclotomic(4)}\end{center}
Output :
\begin{center}{\tt [1,0,1]}\end{center}
Another example, input :
\begin{center}{\tt cyclotomic(5)}\end{center}
Output :
\begin{center}{\tt [1,1,1,1,1]}\end{center}
Hence, the cyclotomic polynomial of index $5$ is $x^4+x^3+x^2+x+1$
which divides $x^5-1$ since $(x-1)*(x^4+x^3+x^2+x+1)=x^5-1$.\\
Input :
\begin{center}{\tt cyclotomic(10)}\end{center}
Output :
\begin{center}{\tt [1,-1,1,-1,1]}\end{center}
Hence, the cyclotomic polynomial of index $10$ is $x^4-x^3+x^2-x+1$ and
\[ (x^5-1)*(x+1)*(x^4-x^3+x^2-x+1)=x^{10}-1 \]
Input :
\begin{center}{\tt cyclotomic(20)}\end{center}
Output :
\begin{center}{\tt [1,0,-1,0,1,0,-1,0,1]}\end{center}
Hence, the cyclotomic polynomial of index $20$ is $x^8-x^6+x^4-x^2+1$ and
\[ (x^{10}-1)*(x^2+1)*(x^8-x^6+x^4-x^2+1)=x^{20}-1 \]

\subsection{Sturm sequences and number of sign changes 
of $P$ on $]a;\ b]$ : {\tt sturm}}\index{sturm}
\noindent{\tt sturm} takes two or four arguments : $P$ a polynomial expression
or $P/Q$ a rational fraction and a variable name or $P$ a polynomial 
expression, a variable name and two real or complex numbers $a$ and $b$.

If {\tt sturm} takes two arguments, {\tt sturm} returns the list of the Sturm 
sequences and multiplicities of the square-free factors of $P$ (or
$P/Q$) (in this case {\tt sturm} behaves like {\tt sturmseq}).

If {\tt sturm} takes four arguments, it behaves like {\tt sturmab}~:
\begin{itemize}
\item if $a$ and $b$ are reals, 
{\tt sturm} returns the number of sign changes of $P$ on $]a;\ b]$
\item if $a$ or $b$ are complex, 
{\tt sturm} returns the number of complex roots of $P$ in the rectangle 
having $a$ and $b$ as opposite vertices.
\end{itemize} 
Input :
\begin{center}{\tt sturm(2*x\verb|^|3+2,x)}\end{center}
Output :
\begin{center}{\tt [2,[[1,0,0,1],[3,0,0],-9],1]}\end{center}
Input :
\begin{center}{\tt sturm((2*x\verb|^|3+2)/(x+2),x)}\end{center}
Output :
\begin{center}{\tt [2,[[1,0,0,1],[3,0,0],-9],1,[[1,2],1]]}\end{center}
Input :
\begin{center}{\tt sturm(x\verb|^|2*(x\verb|^|3+2),x,-2,0)}\end{center}
Output :
\begin{center}{\tt 1}\end{center}

\subsection{Number of zeros in $[a,b[$ : {\tt sturmab}}\index{sturmab}
\noindent{\tt sturmab} takes four arguments: a polynomial expression $P$, a 
variable name and two real or complex numbers $a$ and $b$
\begin{itemize}
\item if $a$ and $b$ are reals, 
{\tt sturmab} returns the number of sign changes of $P$ on $]a;\ b]$.
In other words, it returns the number of zeros in $[a,b[$ of the 
polynomial $P/G$ where $G=\mbox{gcd}(P,\mbox{diff}(P))$.
\item if $a$ or $b$ are complex, 
{\tt sturmab} returns the number of complex roots of $P$ in the rectangle 
having $a$ and $b$ as opposite vertices.
\end{itemize} 
Input :
\begin{center}{\tt sturmab(x\verb|^|2*(x\verb|^|3+2),x,-2,0)}\end{center}
Output :
\begin{center}{\tt 1}\end{center}
Input :
\begin{center}{\tt sturmab(x\verb|^|3-1,x,-2-i,5+3i}\end{center}
Output :
\begin{center}{\tt 3}\end{center}
Input :
\begin{center}{\tt sturmab(x\verb|^|3-1,x,-i,5+3i}\end{center}
Output :
\begin{center}{\tt 1}\end{center}
{\bf Warning !!!!}\\
 $P$ is defined by its symbolic expression.\\
Input  :\\
{\tt sturmab([1,0,0,2,0,0],x,-2,0)},\\ 
Output :\\
{\tt Bad argument type}.

\subsection{Sturm sequences : {\tt sturmseq}}\index{sturmseq}
\noindent{\tt sturmseq} takes as argument, a polynomial expression $P$ or a 
rationnal fraction $P/Q$ and returns the list of the Sturm sequences 
of the square-free factors of odd multiplicity of $P$ (or of $P/Q$).
For $F$ a square-free factor of odd multiplicity, the Sturm 
sequence $R_1,R_2,...$ is made from $F$, $F'$ by a recurrence
relation~:
\begin{itemize}
\item 
$R_1$ is the opposite of the euclidian division remainder of $F$ by
$F'$ then,
\item
$R_2$ is the opposite of the euclidian division remainder of  $F'$ by
$R_1$, 
\item ... 
\item and so on untill $R_k=0$.
\end{itemize}
Input :
\begin{center}{\tt sturmseq(2*x\verb|^|3+2)}\end{center}
or 
\begin{center}{\tt sturmseq(2*y\verb|^|3+2,y)}\end{center}
Output :
\begin{center}{\tt [2,[[1,0,0,1],[3,0,0],-9],1]}\end{center}
The first term gives the content of the numerator (here 2), 
then the Sturm sequence (in list representation) $[x^3+1,3x^2,-9]$.\\
Input :
\begin{center}{\tt sturmseq((2*x\verb|^|3+2)/(3*x\verb|^|2+2),x)}\end{center}
Output :
\begin{center}{\tt [2,[[1,0,0,1],[3,0,0],-9],1,[1,[[3,0,2],[6,0],-72]]}\end{center}
The first term gives the content of the numerator (here 2), 
then the Sturm sequence of the numerator ([[1,0,0,1],[3,0,0],-9]), 
then the content of the denominator (here 1) and the Sturm 
sequence of the denominator ([[3,0,2],[6,0],-72]). As expressions,
$[x^3+1,3x^2, -9]$ is the Sturm sequence of the numerator and
$[3x^2+2,6x,-72]$ is the Sturm sequence of the denominator.\\
Input :
\begin{center}{\tt sturmseq((x\verb|^|3+1)\verb|^|2,x)}\end{center}
Output :
\begin{center}{\tt [1,1]}\end{center}
Indeed $F=1$.\\
Input :
\begin{center}{\tt sturmseq(3*(3*x\verb|^|3+1)/(2*x+2),x)}\end{center}
Output :
\begin{center}{\tt[3,[[3,0,0,1],[9,0,0],-81],2,[[1,1],1]]}\end{center}
The first term gives the content of the numerator 
(here {\tt 3}),\\
the second term gives the Sturm sequence of the numerator
(here {\tt 3x\verb|^|3+1, 9x\verb|^|2, -81}),\\
the third term gives the content of the denominator (here 
{\tt 2}),\\
the fourth  term gives the Sturm sequence of the denominator 
({\tt x+1,1}).\\
{\bf Warning !!!!}\\
$P$ is defined by its symbolic expression.\\
Input  :\\  
{\tt sturmseq([1,0,0,1],x)},\\ 
Output :\\
{\tt Bad argument type}.

\subsection{Sylvester matrix of two polynomials : {\tt sylvester}}\index{sylvester}
\noindent{\tt sylvester} takes two polynomials as arguments.\\
{\tt sylvester} returns the Sylvester matrix $S$ of these polynomials.\\
If $A(x)=\sum_{i=0}^{i=n} a_ix^i$ and 
$B(x)=\sum_{i=0}^{i=m}b_ix^i$ are 2 polynomials, their Sylvester matrix 
$S$ is a squared matrix of size {\tt m+n} where {\tt m=degree(B(x))} and 
{\tt n=degree(A(x))}. The {\tt m} first lines are made with the  $A(x)$
coefficients, so that :
$$\left(\begin{array}{ccccccc}
s_{11}=a_n & s_{12}=a_{n-1}& \cdots & s_{1(n+1)}=a_0 & 0 & \cdots & 0\\
s_{21}=0 & s_{22}=a_{n}& \cdots & s_{2(n+1)}=a_1 & s_{2(n+2)}=a_0 & \cdots & 0\\
\vdots &\vdots &\vdots &\ddots &\vdots &\ddots &\vdots\\
s_{m1}=0 & s_{m2}=0& \cdots & s_{m(n+1)}=a_{m-1} & s_{m(n+2)}=a_{m-2} & \cdots&a_0 
\end{array}\right)$$
and the {\tt n} further lines  are made with the  $B(x)$
coefficients, so that :
$$\left(\begin{array}{ccccccc}
s_{(m+1)1}=b_m & s_{(m+1)2}=b_{m-1}& \cdots & s_{(m+1)(m+1)}=b_0 & 0 & \cdots & 0\\
\vdots &\vdots &\vdots &\ddots &\vdots &\ddots &\vdots\\
s_{(m+n)1}=0 & s_{(m+n)2}=0& \cdots & s_{(m+n)(m+1)}=b_{n-1}  & b_{n-2}  &\cdots&b_0 
\end{array}\right)$$
Input :
\begin{center}{\tt sylvester(x\verb|^|3-p*x+q,3*x\verb|^|2-p,x)}\end{center}
Output :
\begin{center}{\tt [[1,0,-p,q,0],[0,1,0,-p,q],[3,0,-p,0,0], [0,3,0,-p,0],[0,0,3,0,-p]]}\end{center}
Input :
\begin{center}{\tt det([[1,0,-p,q,0],[0,1,0,-p,q],[3,0,-p,0,0], [0,3,0,-p,0],[0,0,3,0,-p]])}\end{center}
Output :
\begin{center}{\tt -4*p\verb|^|3--27*q\verb|^|2}\end{center}

\subsection{Resultant of two polynomials : {\tt resultant}}\index{resultant}
\noindent{\tt resultant} takes as argument two polynomials and
returns the resultant of the two polynomials.\\
The resultant of two polynomials is the determinant of their
Sylvester matrix $S$. 
The Sylvester matrix $S$ of two polynomials $A(x)=\sum_{i=0}^{i=n} a_ix^i$
and $B(x)=\sum_{i=0}^{i=m} b_ix^i$
is a square matrix with $m+n$ rows and columns; its first $m$ rows
are made from the coefficients of $A(X)$:
$$\left(\begin{array}{ccccccc}
s_{11}=a_n & s_{12}=a_{n-1}& \cdots & s_{1(n+1)}=a_0 & 0 & \cdots & 0\\
s_{21}=0 & s_{22}=a_{n}& \cdots & s_{2(n+1)}=a_1 & s_{2(n+2)}=a_0 & \cdots & 0\\
\vdots &\vdots &\vdots &\ddots &\vdots &\ddots &\vdots\\
s_{m1}=0 & s_{m2}=0& \cdots & s_{m(n+1)}=a_{m-1} & s_{m(n+2)}=a_{m-2} & \cdots&a_0 
\end{array}\right)$$
and the following $n$ rows are made in the same way from the
coefficients of $B(x)$ :
$$\left(\begin{array}{ccccccc}
s_{(m+1)1}=b_m & s_{(m+1)2}=b_{m-1}& \cdots & s_{(m+1)(m+1)}=b_0 & 0 & \cdots & 0\\
\vdots &\vdots &\vdots &\ddots &\vdots &\ddots &\vdots\\
s_{(m+n)1}=0 & s_{(m+n)2}=0& \cdots & s_{(m+n)(m+1)}=b_{n-1}  & b_{n-2}  &\cdots&b_0 
\end{array}\right)$$

If $A$ and $B$ have integer coefficients with non-zero resultant $r$, 
then the polynomials equation 
\[ AU+BV=r\]
has a unique solution $U,V$ such that degree$(U)<$degree$(B)$ and 
degree$(V)<$degree$(A)$, and this solution has integer coefficients.

Input :
\begin{center}{\tt resultant(x\verb|^|3-p*x+q,3*x\verb|^|2-p,x)}\end{center}
Output :
\begin{center}{\tt -4*p\verb|^|3--27*q\verb|^|2}\end{center}
{\bf Remark}\\
discriminant(P)=resultant(P,P').

{\bf An example using resultant}\\
Let, $F1$ and $F2$ be 2 fixed points in the plan and
$A$, a variable point on the circle of center $F1$ and radius $2a$.
Find the cartesian equation of the set of points $M$, intersection of
the line $F1A$ and of the segment bisector of $F2A$.

Geometric answer~:
\[ MF1+MF2=MF1+MA=F1A=2a\] 
hence $M$ is on an ellipse with focus  $F1,F2$ and major axis $2a$.

Analytic answer~:
In the Cartesian coordinate system of center $F1$ 
and $x$-axis having the same 
direction than the vector $F1F2$, the coordinates of $A$ are :
\[  A= (2a\cos(\theta);2a\sin(\theta)) \] 
where $\theta$ is the $(Ox,OA)$ angle.
Now choose $t=\tan(\theta/2)$  as parameter, such that the coordinates
of  $A$ are rational functions with respect to $t$.
More precisely~:
\[ A=(ax;ay)=(2a\frac{1-t^2}{1+t^2};2a\frac{2t}{1+t^2}) \]
If $F1F2=2c$ and if $I$ is the midel point of $AF2$, 
since the coordinates of $F2$ are $F2=(2c,0)$, the coordinates 
of $I$ 
\[ I=(c+ax/2;ay/2)=(c+a\frac{1-t^2}{1+t^2};a\frac{2t1-t^2}{1+t^2}) \]
$IM$ is  orthogonal to $AF2$, hence $M=(x;y)$ verify the equation
$eq1=0$ where 
\[ eq1:=(x-ix)*(ax-2*c)+(y-iy)*ay \]
But $M=(x;y)$ is also on $F1A$, hence $M$ verify the equation $eq2=0$
\[ eq2:=y/x-ay/ax \]
The resultant of both equations with respect to $t$ 
{\tt resultant(eq1,eq2,t)} is a polynomial $eq3$ depending on the
variables $x,y$, independant of $t$ which is the cartesian equation
of the set of points $M$ when $t$ varies.
Input :\\
{\tt ax:=2*a*(1-t\verb|^|2)/(1+t\verb|^|2);ay:=2*a*2*t/(1+t\verb|^|2);}\\
{\tt ix:=(ax+2*c)/2; iy:=(ay/2)}\\
{\tt eq1:=(x-ix)*(ax-2*c)+(y-iy)*ay}\\
{\tt eq2:=y/x-ay/ax}\\
{\tt factor(resultant(eq1,eq2,t))}\\
Output gives as resultant :\\
${\tt -(64\cdot(x^2+y^2)\cdot(x^2\cdot a^2-x^2\cdot c^2+-2\cdot x\cdot a^2\cdot
c+2\cdot x\cdot c^3-a^4+2\cdot a^2\cdot c^2+}$\\
${\tt  a^2\cdot y^2-c^4))}$\\
The factor ${\tt -64\cdot (x^2+y^2)}$ is always different from zero, 
hence the locus equation of $M$~:
\[ {\tt x^2a^2-x^2c^2+-2xa^2c+2xc^3-a^4+2a^2c^2+a^2y^2-c^4=0} \]
If the frame origin is $O$, the middle point of $F1F2$,
we find the cartesian equation of an ellipse. 
To make the change of origin 
$\overrightarrow{F1M}=\overrightarrow{F1O}+\overrightarrow{OM}$, input :
\[ {\tt normal(subst(x^2\cdot a^2-x^2\cdot c^2+-2\cdot x\cdot a^2\cdot
c+2\cdot x\cdot c^3-a^4+2\cdot a^2\cdot c^2+} \]
\[ {\tt  a^2\cdot y^2-c^4,[x,y]=[c+X,Y]))} \]
Output :
\[ {\tt -c^2*X^2+c^2*a^2+X^2*a^2-a^4+a^2*Y^2} \]
or if $b^2=a^2-c^2$, input :
\[ {\tt
  normal(subst(-c^2*X^2+c^2*a^2+X^2*a^2-a^4+a^2*Y^2,c^2=a^2-b^2))} \]
Output :
\[ {\tt -a^2*b^2+a^2*Y^2+b^2*X^2} \]
that is to say, after division by $a^2*b^2$, $M$ verifies the equation :
\[ \frac{X^2}{a^2}+\frac{Y^2}{b^2}=1 \]

{\bf Another example using resultant}\\
Let $F1$ and $F2$ be fixed points and $A$ a variable point on the 
circle of center $F1$ and radius $2a$.
Find the cartesian equation of the hull of $D$, the segment bisector 
of $F2A$.

The segment bisector of $F2A$ is tangent to the ellipse of focus  
$F1,F2$ and major axis $2a$.

In the Cartesian coordinate system of center $F1$ and $x$-axis having the same 
direction than the vector $F1F2$, the coordinates of $A$ are :
\[ A= (2a\cos(\theta);2a\sin(\theta)) \]
where $\theta$ is the $(Ox,OA)$ angle.
Choose $t=\tan(\theta/2)$ as parameter, such that the coordinates of $A$ are
rational functions with respect to $t$.
More precisely~:
\[ A=(ax;ay)=(2a\frac{1-t^2}{1+t^2};2a\frac{2t}{1+t^2}) \]
If $F1F2=2c$ and if $I$ is the middle point of $AF2$:\\
\[ F2=(2c,0), \quad
I=(c+ax/2;ay/2)=(c+a\frac{1-t^2}{1+t^2};a\frac{2t1-t^2}{1+t^2}) 
\]
Since $D$ is orthogonal to $AF2$, the equation of $D$ is
$eq1=0$ where
\[ eq1:=(x-ix)*(ax-2*c)+(y-iy)*ay \]
So, the hull of $D$ is the locus of $M$, the intersection point of $D$ 
and $D'$ where $D'$ has equation $eq2:=diff(eq1,t)=0$.
Input :\\
{\tt ax:=2*a*(1-t\verb|^|2)/(1+t\verb|^|2);ay:=2*a*2*t/(1+t\verb|^|2);}\\
{\tt ix:=(ax+2*c)/2; iy:=(ay/2)}\\
{\tt eq1:=normal((x-ix)*(ax-2*c)+(y-iy)*ay)}\\
{\tt eq2:=normal(diff(eq1,t))}\\
{\tt factor(resultant(eq1,eq2,t))}\\
Output gives as resultant :\\
${\tt (-(64\cdot a\verb|^|2))\cdot(x\verb|^|2+y\verb|^|2)\cdot(x\verb|^|2\cdot a\verb|^|2-x\verb|^|2\cdot c\verb|^|2+-2\cdot x\cdot a\verb|^|2\cdot c+}$\\
${\tt 2\cdot x\cdot c\verb|^|3-a\verb|^|4+2\cdot a\verb|^|2\cdot c\verb|^|2+a\verb|^|2\cdot y\verb|^|2-c\verb|^|4)}$\\
The factor ${\tt -64\cdot (x^2+y^2)}$ is always different from zero, 
therefore the locus equation is :
\[ {\tt x^2a^2-x^2c^2+-2xa^2c+2xc^3-a^4+2a^2c^2+a^2y^2-c^4=0} \]
If $O$, the middle point of $F1F2$, is choosen as origin,
we find again the cartesian equation of the ellipse~:
\[ \frac{X^2}{a^2}+\frac{Y^2}{b^2}=1 \]

\section{Orthogonal polynomials}
\subsection{Legendre polynomials: {\tt legendre}}\index{legendre}
\noindent{\tt legendre} takes as argument an integer $n$ and
optionnally a variable name (by default $x$).\\
{\tt legendre} returns the Legendre polynomial of degree $n$ : it is
 a polynomial $L(n,x)$, solution of the differential equation:
$$(x^2-1).y''-2.x.y'-n(n+1).y=0$$ 
The Legendre polynomials verify the following recurrence relation:
\[ L(0,x)=1, \quad 
L(1,x)=x, \quad
L(n,x)=\frac{2n-1}{n}x L(n-1,x)-\frac{n-1}{n}L(n-2,x)
\]
These polynomials are orthogonal for the scalar product :
\[ <f,g>=\int_{-1}^{+1}f(x)g(x)\ dx \]
Input :
\begin{center}{\tt legendre(4)}\end{center}
Output :
\begin{center}{\tt (35*x\verb|^|4+-30*x\verb|^|2+3)/8}\end{center}
Input :
\begin{center}{\tt legendre(4,y)}\end{center}
Output :
\begin{center}{\tt (35*y\verb|^|4+-30*y\verb|^|2+3)/8}\end{center}

\subsection{Hermite polynomial : {\tt hermite}}\index{hermite}
\noindent{\tt hermite} takes as argument an integer $n$ and
 optionnally a variable name (by default $x$).\\
{\tt hermite} returns the Hermite polynomial of degree $n$.\\
If $H(n,x)$ denotes the Hermite polynomial of degree $n$,
the following recurrence relation holds:
\[  H(0,x)=1, \quad
H(1,x)=2x, \quad
H(n,x)=2xH(n-1,x)-2(n-1)H(n-2,x) \]
These polynomials are orthogonal for the scalar product:
\[ <f,g>=\int_{-\infty}^{+\infty}f(x)g(x)e^{-x^2}dx \]
Input :
\begin{center}{\tt hermite(6)}\end{center}
Output :
\begin{center}{\tt 64*x\verb|^|6+-480*x\verb|^|4+720*x\verb|^|2-120}\end{center}Input :
\begin{center}{\tt hermite(6,y)}\end{center}
Output :
\begin{center}{\tt 64*y\verb|^|6+-480*y\verb|^|4+720*y\verb|^|2-120}\end{center}

\subsection{Laguerre polynomials: {\tt laguerre}}\index{laguerre}
\noindent{\tt laguerre} takes as argument an integer $n$ and optionnally 
 a variable name (by default $x$) and a parameter name  (by default $a$).\\
{\tt laguerre} returns the  Laguerre polynomial of degree $n$ and of 
parameter $a$.\\
If $L(n,a,x)$ denotes the Laguerre polynomial of degree $n$ and 
parameter $a$, the following recurrence relation holds:
\[ L(0,a,x)=1, \quad
L(1,a,x)=1+a-x, \quad
L(n,a,x)=\frac{2n+a-1-x}{n}L(n-1,a,x)-\frac{n+a-1}{n}L(n-2,a,x) \]
These polynomials are orthogonal for the scalar product
\[ <f,g>=\int_{0}^{+\infty}f(x)g(x)x^ae^{-x}dx \]
Input :
\begin{center}{\tt laguerre(2)}\end{center}
Output :
\begin{center}{\tt (a\verb|^|2+-2*a*x+3*a+x\verb|^|2+-4*x+2)/2}\end{center}
Input :
\begin{center}{\tt laguerre(2,y)}\end{center}
Output :
\begin{center}{\tt (a\verb|^|2+-2*a*y+3*a+y\verb|^|2+-4*y+2)/2}\end{center}
Input :
\begin{center}{\tt laguerre(2,y,b)}\end{center}
Output :
\begin{center}{\tt (b\verb|^|2+-2*b*y+3*b+y\verb|^|2+-4*y+2)/2}\end{center}

\subsection{Tchebychev polynomials of first kind: {\tt tchebyshev1}}\index{tchebyshev1}
\noindent{\tt tchebyshev1} takes as argument an integer $n$ and optionnally a 
variable name (by default $x$).\\
{\tt tchebyshev1} returns the Tchebychev polynomial of first kind
of degree $n$.\\
The Tchebychev polynomial of first kind $T(n,x)$ is defined by
\[ T(n,x)= \cos(n.\arccos(x)) \]
and verify the recurrence relation:
\[ T(0,x)=1, \quad 
T(1,x)=x, \quad T(n,x)=2xT(n-1,x)-T(n-2,x) \]
The polynomials $T(n,x)$  are orthogonal for the scalar product
\[ <f,g>=\int_{-1}^{+1}\frac{f(x)g(x)}{\sqrt{1-x^2}}dx \]
Input :
\begin{center}{\tt tchebyshev1(4)}\end{center}
Output :
\begin{center}{\tt 8*x\verb|^|4+-8*x\verb|^|2+1}\end{center}
Input :
\begin{center}{\tt tchebyshev1(4,y)}\end{center}
Output :
\begin{center}{\tt 8*y\verb|^|4+-8*y\verb|^|2+1}\end{center}
Indeed
\begin{eqnarray*}
\cos( 4.x)&=&Re((\cos(x)+i.\sin(x))^4) \\
          &=&\cos(x)^4-6.\cos(x)^2.(1-\cos(x)^2)+((1-\cos(x)^2)^2 \\
          &=&T(4,\cos(x))
\end{eqnarray*}

\subsection{Tchebychev polynomial of second kind: {\tt tchebyshev2}}\index{tchebyshev2}
\noindent{\tt tchebyshev2} takes as argument an integer $n$ and optionnally  
a variable name (by default $x$).\\
{\tt tchebyshev2} returns the Tchebychev polynomial of second kind
of degree $n$.\\
The Tchebychev polynomial of second kind $U(n,x)$ is defined by:
$$U(n,x)=\frac{\sin((n+1).\arccos(x))}{\sin(\arccos(x))}$$
or equivalently:
$$\sin((n+1)x)=\sin(x)*U(n,\cos(x))$$ 
The $U(n,x)$ verifies the recurrence relation:
\[ U(0,x)=1, \quad
U(1,x)=2x, \quad
U(n,x)=2xU(n-1,x)-U(n-2,x) \]
The polynomials $U(n,x)$ are orthogonal for the scalar product
\[ <f,g>=\int_{-1}^{+1}f(x)g(x)\sqrt{1-x^2}dx \]
Input :
\begin{center}{\tt tchebyshev2(3)}\end{center}
Output :
\begin{center}{\tt 8*x\verb|^|3+-4*x}\end{center}
Input :
\begin{center}{\tt tchebyshev2(3,y)}\end{center}
Output :
\begin{center}{\tt 8*y\verb|^|3+-4*y}\end{center}
Indeed:
\[ \sin(4.x)=\sin(x)*(8*\cos(x)^3-4.\cos(x))=\sin(x)*U(3,\cos(x)) \]



\section{Gr\"obner basis and Gr\"obner reduction}
 \subsection{Gr\"obner basis : {\tt gbasis}}\index{gbasis}
\label{sec:gbasis}
\noindent{\tt gbasis} takes at least two arguments
\begin{itemize}
\item a vector of multivariate polynomials 
\item a vector of variables names,
\end{itemize}
Optionnal arguments may be used to specify the ordering and
algorithms. By default, the ordering is lexicographic (with respect to the
list of variable names ordering)
and the polynomials are written in decreasing power orders with
respect to this order. 
For example, the output will be like 
$...+x^2 y^4 z^3+x^2 y^3 z^4+...$ if the second argument is $[x,y,z]$ because
$(2,4,3)>(2,3,4)$ but the output would be like
$...+x^2 y^3z^4+x^2 y^4 z^3+...$  if the second argument is $[x,z,y]$.\\
{\tt gbasis} returns a Gr\"obner basis of the polynomial ideal spanned
by these polynomials.

{\bf Property}\\
If $I$ is an ideal and if $(G_k)_{k \in K}$ is a Gr\"obner basis of this 
ideal $I$ then, if $F$ is a non zero polynomial in $I$, the greatest monomial 
of $F$ is divisible by the greatest monomial of one of the $G_k$.
In other words, if you do an euclidian division of $F\neq 0$ 
by the corresponding $G_k$, take the remainder of this division, do
again the same and so on, at some point you get a null remainder.
  
Input :
\begin{center}{\tt gbasis([2*x*y-y\verb|^|2,x\verb|^|2-2*x*y],[x,y])}
\end{center}
Output :
\begin{center}{\tt
 [4*x\verb|^|2+-4*y\verb|^|2,2*x*y-y\verb|^|2,-(3*y\verb|^|3)]}
\end{center}

As indicated above, {\tt gbasis} may have more than 2 arguments~:
\begin{itemize}
\item {\tt plex} (lexicographic only), {\tt tdeg} (total degree then
lexicographic order),
{\tt revlex} (total degree then inverse lexicographic order), to
specify an order on the monomials 
({\tt plex} is the order by default),
\item {\tt with\_cocoa=true} or {\tt with\_cocoa=false}, if you want to use
the {\tt CoCoA} library to compute the Gr\"obner basis (recommended,
requires that {\tt CoCoA} support compiled in)

\item {\tt with\_f5=true} or {\tt with\_f5=false} for using the F5 algorithm
of the {\tt CoCoA} librairy .
In this case the  specify order is not used (the polynomials are 
homogeneized).
\end{itemize}
Input~:
\begin{center}
{\tt gbasis([x1+x2+x3,x1*x2+x1*x3+x2*x3,x1*x2*x3-1], [x1,x2,x3],tdeg,with\_cocoa=false)}
\end{center}
Output
\begin{center}
\verb|[x3^3-1,-x2^2-x2*x3-x3^2,x1+x2+x3]|
\end{center}

\subsection{Gr\"obner reduction : {\tt greduce}}\index{greduce}
\noindent{\tt greduce} has three arguments : a multivariate
polynomial, 
a vector made of polynomials which is supposed to be a Gr\"obner
basis,  and a vector of variable names.\\
{\tt greduce} returns the reduction of 
the polynomial given as first argument
with respect to the Gr\"obner basis given as the second argument.
It is 0 if and only if the polynomial belongs to the ideal.

Input :
\begin{center}{\tt greduce(x*y-1,[x\verb|^|2-y\verb|^|2,2*x*y-y\verb|^|2,y\verb|^|3],[x,y])}\end{center}
Output :
\begin{center}{\tt y\verb|^|2-2}\end{center}
that is to say $xy-1=\frac{1}{2}(y^2-2)\ \bmod I$ where $I$ is the ideal 
generated by the Gr\"obner basis $[x^2-y^2,2xy-y^2,y^3]$, because 
$ y^2-2$ is the euclidian division rmainder of $2(xy-1)$ by $G_2=2x y-y^2$.\\
% {\bf Remark}\\
% The multiplcative constant can be fixed by observing how the constant 
% coefficient is converted. In the example, the constant coefficient 
% {\tt -1} is converted into the constant coefficient {\tt -2}, so 
% the multiplcative constant is  {\tt 1/2}.

Like {\tt gbasis} (cf. \ref{sec:gbasis}),
{\tt greduce} may have more than 3 arguments to specify ordering and
algorithm if they differ from the default (lexicographic ordering).
Input~:
\begin{center}
{\tt greduce(x1\verb|^|2*x3\verb|^|2,[x3\verb|^|3-1,-x2\verb|^|2-x2*x3-x3\verb|^|2,x1+x2+x3], [x1,x2,x3],tdeg)}
\end{center}
Output
\begin{center}
\verb|x2|
\end{center}

\subsection{Build a polynomial from it's evaluation : {\tt genpoly}}\index{genpoly}
\noindent{\tt genpoly} takes three arguments : a polynomial $P$ with $n-1$ 
variables, an integer $b$ and the name of a variable {\tt var}.\\ 
{\tt genpoly} returns the polynomial $Q$ with $n$ variables (the $P$ variables
and the variable {\tt var} given as second argument), such that~:
\begin{itemize}
\item {\tt subst(Q,var=b)==P} 
\item the coefficients of $Q$ belongs to the interval  $]-b/2 \ ; \ b/2]$
\end{itemize}
In other words, $P$ is written in base $b$ but using the convention
that the euclidean remainder belongs to $]-b/2 \ ; \ b/2]$ 
(this convention is also known as s-mod representation).
Input :
\begin{center}{\tt genpoly(61,6,x) }\end{center}
Output :
\begin{center}{\tt 2*x\verb|^|2-2*x+1}\end{center}
Indeed 61 divided by 6 is 10, remains 1, then 10 divided by 6 is 2
remains -2 (instead of the usual quotient 1 and remainder 4 out of bounds),
\[ 61=2*6^2-2*6+1 \]
Input :
\begin{center}{\tt genpoly(5,6,x) }\end{center}
Output :
\begin{center}{\tt x-1}\end{center}
Indeed : $5=6-1$\\
Input :
\begin{center}{\tt genpoly(7,6,x) }\end{center}
Output :
\begin{center}{\tt x+1}\end{center}
Indeed : $7=6+1$\\
Input :
\begin{center}{\tt genpoly(7*y+5,6,x) }\end{center}
Output :
\begin{center}{\tt x*y+x+y-1}\end{center}
Indeed : $x*y+x+y-1=y(x+1)+(x-1)$\\
Input :
\begin{center}{\tt genpoly(7*y+5*z\verb|^2|,6,x)}\end{center}
Output :
\begin{center}{\tt x*y+x*z+y-z}\end{center}
Indeed : $x*y+x*z+y-z=y*(x+1)+z*(x-1)$

\section{Rational fractions}
\subsection{Numerator : {\tt getNum}}\index{getNum}\label{sec:getnum}
\noindent {\tt getNum} takes as argument a rational fraction 
and returns the numerator of this fraction. Unlike {\tt numer},
{\tt getNum} does not simplify the fraction before extracting
the numerator.\\
Input :
\begin{center}{\tt getNum((x\verb|^|2-1)/(x-1)) }\end{center}
Output :
\begin{center}{\tt x\verb|^|2-1}\end{center}
Input :
\begin{center}{\tt getNum((x\verb|^|2+2*x+1)/(x\verb|^|2-1)) }\end{center}
Output :
\begin{center}{\tt x\verb|^|2+2*x+1}\end{center}

\subsection{Numerator after simplification : {\tt numer}}\index{numer}\label{sec:numer}
\noindent{\tt numer} takes as argument a rational fraction
and  returns the numerator of an irreducible representant of
this fraction (see also \ref{sec:inumer}).\\
Input :
\begin{center}{\tt numer((x\verb|^|2-1)/(x-1)) }\end{center}
Output :
\begin{center}{\tt x+1}\end{center}
Input :
\begin{center}{\tt numer((x\verb|^|2+2*x+1)/(x\verb|^|2-1)) }\end{center}
Output :
\begin{center}{\tt x+1}\end{center}

\subsection{Denominator : {\tt getDenom}}\index{getDenom}\label{sec:getdenom}
\noindent{\tt getDenom} takes as argument a rational fraction and  returns the 
denominator of this fraction. Unlike {\tt denom},
{\tt getDenom} does not simplify the fraction before extracting
the denominator.\\
Input :
\begin{center}{\tt getDenom((x\verb|^|2-1)/(x-1)) }\end{center}
Output :
\begin{center}{\tt x-1}\end{center}
Input :
\begin{center}{\tt getDenom((x\verb|^|2+2*x+1)/(x\verb|^|2-1)) }\end{center}
Output :
\begin{center}{\tt x\verb|^|2-1}\end{center}

\subsection{Denominator after simplification : {\tt denom}}\index{denom}\label{sec:denom}
\noindent{\tt denom} (or {\tt getDenom}) takes as argument a rational fraction 
and  returns the denominator of an irreducible representant
of this fraction (see also \ref{sec:idenom}).\\
Input :
\begin{center}{\tt denom((x\verb|^|2-1)/(x-1)) }\end{center}
Output :
\begin{center}{\tt 1}\end{center}
Input :
\begin{center}{\tt denom((x\verb|^|2+2*x+1)/(x\verb|^|2-1)) }\end{center}
Output :
\begin{center}{\tt x-1}\end{center}

\subsection{Numerator and  denominator : {\tt f2nd fxnd}}\index{fxnd|textbf}\index{f2nd|textbf}\label{sec:fxnd}
\noindent{\tt f2nd} (or {\tt fxnd}) takes as argument a rational fraction and 
returns the liste of the numerator and the denominator of an irreducible
representant of this fraction (see also \ref{sec:ifxnd}).\\
Input :
\begin{center}{\tt f2nd((x\verb|^|2-1)/(x-1)) }\end{center}
Output :
\begin{center}{\tt [x+1,1]}\end{center}
Input :
\begin{center}{\tt f2nd((x\verb|^|2+2*x+1)/(x\verb|^|2-1)) }\end{center}
Output :
\begin{center}{\tt [x+1,x-1]}\end{center}

\subsection{Simplify : {\tt simp2}}\index{simp2}\label{sec:simp2}
\noindent{\tt simp2} takes as argument two polynomials (or two integers\ see 
\ref{sec:isimp2}).
These two polynomials are seen as the numerator and denominator
of a rational fraction.\\ 
{\tt simp2} returns a list of two polynomials seen as the numerator
and denominator of an irreducible representant of
this rational fraction.\\ 
 Input :
\begin{center}{\tt simp2(x\verb|^|3-1,x\verb|^|2-1)}\end{center}
Output :
\begin{center}{\tt  [x\verb|^|2+x+1,x+1]}\end{center} 

\subsection{Common denominator : {\tt comDenom}}\index{comDenom|textbf}
\noindent{\tt comDenom} takes as argument a sum of rational fractions.\\
{\tt comDenom} rewrite the sum as a unique rational fraction.
The denominator of this rational fraction is the common denominator of the
rational fractions given as argument.\\
Input :
\begin{center}{\tt comDenom(x-1/(x-1)-1/(x\verb|^|2-1))}\end{center}
Output :
\begin{center}{\tt (x\verb|^|3+-2*x-2)/(x\verb|^|2-1)}\end{center} 

\subsection{Integer and fractional part : {\tt propfrac}}\index{propfrac}\label{sec:propfrac}
\noindent{\tt propfrac} takes as argument a rational fraction.\\
{\tt propfrac} rewrites this rational fraction as the sum of it's
integer part and proper fractional part.\\
{\tt propfrac(A(x)/B(x))} writes the fraction $\frac{A(x)}{B(x)}$ (after 
reduction), as :
\[ Q(x)+\frac{R(x)}{B(x)} \quad  \mbox{ where } R(x)=0 
\mbox{ or } 0\leq \mbox{degree}(R(x))< \mbox{degree}(B(x)) \]
Input :
\begin{center}{\tt  propfrac((5*x+3)*(x-1)/(x+2))}\end{center}
Output :
\begin{center}{\tt 5*x-12+21/(x+2)}\end{center}

\subsection{Partial fraction expansion  : {\tt partfrac}}\index{partfrac|textbf}\label{sec:convertparf}
{\tt partfrac} takes as argument a rational fraction.\\
{\tt partfrac} returns the partial fraction expansion of this rational 
fraction.\\
The {\tt partfrac} command is equivalent to the {\tt convert} command with 
{\tt parfrac} (or {\tt partfrac} or {\tt fullparfrac}) as option 
(see also \ref{sec:convert}).\\
{\bf Example} :\\
Find the partial fraction expansion of :
$$\frac{x^5-2x^3+1}{x^4-2x^3+2x^2-2x+1}$$
Input :
\begin{center}{\tt partfrac((x\verb|^|5-2*x\verb|^|3+1)/(x\verb|^|4-2*x\verb|^|3+2*x\verb|^|2-2*x+1))}\end{center}
Output in real mode :
\begin{center}{\tt x+2-1/(2*(x-1))+(x-3)/(2*(x\verb|^|2+1)) }\end{center}
Output in complex mode:
\begin{center}{\tt x+2+(-1+2*i)/((2-2*i)*((i)*x+1))+1/(2*(-x+1))+}\end{center}
\begin{center}{\tt (-1-2*i)/((2-2*i)*(x+i))}\end{center}

\section{Exact roots of a polynomial}
\subsection{Exact bounds for complex roots of a polynomial :\\ 
{\tt complexroot}}\index{complexroot}
\noindent {\tt complexroot} takes 2 or 4 arguments : a polynomial and a real 
number $\epsilon$ and optionnally two complex numbers $\alpha,\beta$.\\
{\tt complexroot} returns a list of vectors. 
\begin{itemize}
\item If {\tt complexroot} has 2 arguments, 
the elements of each vector are
\begin{itemize}
\item either an interval (the 
boundaries of this interval are the opposite vertices of a rectangle with sides
parallel to the axis and containing a complex root of the polynomial) and the 
multiplicity of this root.\\
Let the interval be $[a_1+ib_1,a_2+ib_2]$ then $|a_1-a_2|<\epsilon$,  
$|b_1-b_2|<\epsilon$ and the root $a+ib$ verifies 
$a_1\leq a \leq a_2$ and  $b_1\leq b \leq b_2$.
\item or the value of an exact complex root of 
the polynomial and the multiplicity of this root 
\end{itemize}
\item If {\tt complexroot} has 4 arguments, {\tt complexroot} returns a list of
vectors as above, but only for the roots lying in 
the rectangle with sides parallel to the axis having $\alpha,\beta$ as
opposite vertices.\\
\end{itemize}
To find the roots of $x^3+1$, input:
\begin{center}{\tt complexroot(x\verb|^|3+1,0.1)}\end{center}
Output :
\begin{center}{\tt [[-1,1],[[(4-7*i)/8,(8-13*i)/16],1],[[(8+13*i)/16,(4+7*i)/8],1]]}\end{center}
Hence, for  $x^3+1$ :
\begin{itemize}
\item -1 is a root of multiplicity 1, 
\item 1/2+i*$b$ is a root of  multiplicity 1 with  $-7/8\leq b \leq
  -13/16$, 
\item 1/2+i*$c$ is a root of multiplicity 1 with  $13/1\leq c \leq
  7/8$.
\end{itemize}
To find the roots of $x^3+1$ lying inside the rectangle 
of opposite vertices $-1,1+2*i$, input:
\begin{center}{\tt complexroot(x\verb|^|3+1,0.1,-1,1+2*i)}\end{center}
Output :
\begin{center}{\tt [[-1,1],[[(8+13*i)/16,(4+7*i)/8],1]]}\end{center} 

\subsection{Exact bounds for real roots of a polynomial : {\tt realroot}}\index{realroot}
\noindent {\tt realroot} has 2 or 4 arguments : a polynomial and a real number 
$\epsilon$ and optionnally two reals numbers $\alpha,\beta$.\\
{\tt realroot} returns a list of vectors.
\begin{itemize}
\item If {\tt realroot} has 2 arguments, the elements of each vector are
\begin{itemize}
\item 
either a real interval containing a real root of the polynomial 
and the multiplicity of this root.
Let the interval be $[a_1,a_2]$ then $|a_1-a_2|<\epsilon$ and 
the root $a$ verifies $a_1\leq a \leq a_2$.
\item or the value of an exact real root of the
polynomial and the multiplicity of this roots 
\end{itemize}
\item If {\tt realroot} has 4 arguments, {\tt realroot} returns a list of
vectors as above, but only for the roots inside
the interval $[\alpha,\beta]$.
\end{itemize}
To find the real roots of $x^3+1$, input:
\begin{center}{\tt realroot(x\verb|^|3+1, 0.1)}\end{center}
Output :
\begin{center}{\tt [[-1,1]] }\end{center} 
To find the real roots of $x^3-x^2-2x+2$, input:
\begin{center}{\tt realroot(x\verb|^|3-x\verb|^|2-2*x+2, 0.1)}\end{center}
Output :
\begin{center}{\tt [[1,1],[[(-3)/2,(-45)/32],1],[[45/32,3/2],1]]}\end{center} 
To find the real roots of $x^3-x^2-2x+2$ in the interval $[0;2]$, input:
\begin{center}{\tt realroot(x\verb|^|3-x\verb|^|2-2*x+2, 0.1,0,2)}\end{center}
Output :
\begin{center}{\tt [[1,1],[[11/8,23/16],1]]}\end{center} 

\subsection{Exact values of rational roots of a polynomial : \\
{\tt rationalroot}}\index{rationalroot}
\noindent {\tt rationalroot} takes 1 or 3 arguments : a polynomial and  
optionnally two reals numbers $\alpha,\beta$.
\begin{itemize}
\item If {\tt rationalroot} has 1 argument, {\tt rationalroot} returns the list
of the value of the  rational roots of the polynomial without multiplicity.
\item If {\tt rationalroot} has 3 arguments, {\tt rationalroot} returns only 
the rational roots of the polynomial which are in the interval 
$[\alpha,\beta]$.
\end{itemize}
To find the rational roots of $2*x^3-3*x^2-8*x+12$, input:
\begin{center}{\tt rationalroot(2*x\verb|^|3-3*x\verb|^|2-8*x+12)}\end{center}
Output :
\begin{center}{\tt [2,3/2,-2]}\end{center} 
To find the rational roots of $2*x^3-3*x^2-8*x+12$ in $[1;2]$, input:
\begin{center}{\tt rationalroot(2*x\verb|^|3-3*x\verb|^|2-8*x+12,1,2)}\end{center}
Output :
\begin{center}{\tt [2,3/2]}\end{center} 
To find the rational roots of $2*x^3-3*x^2+8*x-12$, input:
\begin{center}{\tt rationalroot(2*x\verb|^|3-3*x\verb|^|2+8*x-12)}\end{center}
Output :
\begin{center}{\tt [3/2]}\end{center} 
To find the rational roots of $2*x^3-3*x^2+8*x-12$, input:
\begin{center}{\tt rationalroot(2*x\verb|^|3-3*x\verb|^|2+8*x-12)}\end{center}
Output :
\begin{center}{\tt [3/2]}\end{center} 
To find the rational roots of $(3*x-2)^2*(2x+1)=18*x^3-15*x^2-4*x+4$, input:
\begin{center}{\tt rationalroot(18*x\verb|^|3-15*x\verb|^|2-4*x+4)}\end{center}
Output :
\begin{center}{\tt [(-1)/2,2/3]}\end{center} 

\subsection{Exact values of the complex rational roots of a polynomial : {\tt crationalroot}}\index{crationalroot}
\noindent {\tt crationalroot} takes 1 or 3 arguments : a polynomial and  
optionnally two complex numbers $\alpha,\beta$.
\begin{itemize}
\item If {\tt crationalroot} has 1 argument, {\tt crationalroot} returns the 
list of the complex rational roots of the 
polynomial without multiplicity.
\item if {\tt crationalroot} has 3 arguments, {\tt crationalroot} returns only
the complex rational roots of the 
polynomial which are in the rectangle with sides parallel to the 
axis having $[\alpha,\beta]$ as opposite vertices.
\end{itemize}
To find the rational complex roots of 
$(x^2+4)*(2x-3)=2*x^3-3*x^2+8*x-12$, input :
\begin{center}{\tt crationalroot(2*x\verb|^|3-3*x\verb|^|2+8*x-12)}\end{center}
Output :
\begin{center}{\tt [2*i,3/2,-2*i]}\end{center} 

\section{Exact roots and poles}
\subsection{Roots and poles of a rational function : {\tt froot}}\index{froot}
\noindent{\tt froot} takes a rational function $F(x)$ as argument.\\
{\tt froot} returns a vector whose components are the roots and the poles
of $F[x]$, each one followed by it's multiplicity.\\
If {\tt Xcas} can not find the exact values of the roots or poles,
it tries to find approximate values if $F(x)$ has numeric coefficients.\\
Input :
\begin{center}{\tt froot((x\verb|^|5-2*x\verb|^|4+x\verb|^|3)/(x-2)) }\end{center}
Output :
\begin{center}{\tt [1,2,0,3,2,-1]}\end{center}
Hence, for $\displaystyle F(x)=\frac{x^5-2.x^4+x^3}{x-2}$ :
\begin{itemize}
\item $1$ is a root of multiplicity 2,
\item $0$ is a root of multiplicity 3,
\item $2$ is a pole of order 1.
\end{itemize}
Input :
\begin{center}{\tt froot((x\verb|^|3-2*x\verb|^|2+1)/(x-2)) }\end{center}
Output :
\begin{center}{\tt [1,1,(1+sqrt(5))/2,1,(1-sqrt(5))/2,1,2,-1]}\end{center}
{\bf Remark} : to have the complex roots and the poles, check {\tt Complex} in
the {\tt cas} configuration (red button giving the state line).\\
Input :
\begin{center}{\tt froot((x\verb|^|2+1)/(x-2)) }\end{center}
Output :
\begin{center}{\tt [-i,1,i,1,2,-1]}\end{center}

\subsection{Rational function given by roots and poles : {\tt fcoeff}}\index{fcoeff}
\noindent{\tt fcoeff} has as argument a vector
whose components are the roots and poles of a rational function
$F[x]$, each one followed by it's multiplicity.\\
{\tt fcoeff} returns the rational function $F(x)$.\\
Input :
\begin{center}{\tt fcoeff([1,2,0,3,2,-1]) }\end{center}
Output :
\begin{center}{\tt (x-1)\verb|^|2*x\verb|^|3/(x-2)}\end{center}



\section{Computing in $\Z/p\Z$ or in $\Z/p\Z[x]$}\index{\%|textbf}\label{sec:modulaire}
The way to compute over $\Z/p\Z$ or over $\Z/p\Z[x]$ depends
on the syntax mode :
\begin{itemize}
\item In {\tt Xcas} mode, an object $n$ over $\Z/p\Z$ is written 
$n \%  p$. Some examples of input for
\begin{itemize}
\item an integer {\tt n} in $\Z/13\Z$\\ 
{\tt n:=12\%13}.
\item a vector {\tt V} in $\Z/13\Z$ \\
{\tt V:=[1,2,3]\%13} or 
{\tt V:=[1\%13,2\%13,3\%13]}.
\item a matrix {\tt A} in $\Z/13\Z$ \\
{\tt A:=[[1,2,3],[2,3,4]]\%13} or \\
{\tt A:=[[1\%13,2\%13,3\%13],[[2\%13,3\%13,4\%13]]}.
\item
a polynomial {\tt A} in $\Z/13\Z[x]$ in symbolic representation\\
{\tt A:=(2*x\verb|^|2+3*x-1)\%13} or \\ 
{\tt A:=2\%13*x\verb|^|2+3\%13*x-1\%13}.
\item
a polynomial {\tt A} in $\Z/13\Z[x]$ in list representation\\
{\tt A:=poly1[1,2,3]\%13} or 
{\tt A:=poly1[1\%13,2\%13,3\%13]}.
\end{itemize} 
To recover an object {\tt o} with integer coefficients instead of modular
coefficients, input {\tt o \% 0}. For example, input {\tt o:=4\%7} and
 {\tt o\%0},then output is {\tt -3}.
\item
In {\tt Maple} mode, integers modulo $p$ are represented like
usual integers instead of using specific modular integers.
To avoid confusion with normal commands, modular
commands are written with a capital letter (inert form) and followed
by the mod command (see also the next section).
\end{itemize} 
{\bf Remark} 
\begin{itemize}
\item For some commands in $\Z/p\Z$ or in $\Z/p\Z[x]$, {\tt p} must be
a prime integer.
\item The representation is the symetric representation :\\
{\tt 11\%13} returns {\tt -2\%13}.
\end{itemize}

\subsection{Expand and reduce : {\tt normal}}\index{normal}
\noindent{\tt normal} takes as argument a polynomial expression.\\
{\tt normal} expand and  reduce this expression in $\Z/p\Z[x]$.\\
Input :
\begin{center}{\tt normal(((2*x\verb|^|2+12)*( 5*x-4))\%13)}\end{center}
Output :
\begin{center}{\tt (-3\%13)*x\verb|^|3+(5\%13)*x\verb|^|2+(-5\%13)*x+4\%13}\end{center}

\subsection{Addition in $\Z/p\Z$ or in $ \Z/p\Z[x]$ : {\tt +}}\index{+}
\noindent{\tt +} adds two integers in $\Z/p\Z$, or
two polynomials in $\Z/p\Z[x]$. For polynomials expressions, 
use the {\tt normal} command to simplify\index{normal}.\\
For integers in $\Z/p\Z$, input :
\begin{center}{\tt 3\%13+10\%13}\end{center}
Output :
\begin{center}{\tt 0\%13}\end{center}
For polynomials with coefficients in $\Z/p\Z$, input :
\begin{center}{\tt normal((11*x+5 )\% 13+(8*x+6)\%13)}\end{center} 
or 
\begin{center}{\tt normal(11\% 13*x+5\%13+8\% 13*x+6\%13)}\end{center} 
Output :
\begin{center}{\tt  (6\%13)*x+-2\%13}\end{center}

\subsection{Substraction in $\Z/p\Z$ or in $ \Z/p\Z[x]$ : {\tt -}}\index{-|textbf}
\noindent{\tt -} substracts two integers in $\Z/p\Z$ or
two polynomials in $\Z/p\Z[x]$. For polynomial expressions, 
use the {\tt normal} command to simplify\index{normal}.\\ 
For integers in $\Z/p\Z$, input :
\begin{center}{\tt 31\%13-10\%13}\end{center}
Output :
\begin{center}{\tt  -5\%13}\end{center}
For polynomials with coefficients in $\Z/p\Z$, input :
\begin{center}{\tt normal((11*x+5)\%13-(8*x+6)\%13)}\end{center}
or also : 
\begin{center}{\tt normal(11\% 13*x+5\%13-8\% 13*x+6\%13)}\end{center} 
Output :
\begin{center}{\tt  (3\%13)*x+-1\%13}\end{center}

\subsection{Multiplication in $\Z/p\Z$ or in $ \Z/p\Z[x]$ : {\tt *}}\index{*}
\noindent {\tt *} multiplies two integers in $\Z/p\Z$ or
two polynomials in $\Z/p\Z[x]$. For polynomial expressions, 
use the {\tt normal} command to simplify\index{normal}.\\
For integers in $\Z/p\Z$, input :
\begin{center}{\tt 31\%13*10\%13}\end{center}
Output :
\begin{center}{\tt  -2\%13}\end{center}
For polynomials with coefficients in $\Z/p\Z$, input :
\begin{center}{\tt normal((11*x+5)\%13*(8*x+6 )\% 13)}\end{center}
or also :
\begin{center}{\tt normal((11\% 13*x+5\%13)*(8\% 13*x+6\%13))}\end{center} 
Output :
\begin{center}{\tt (-3\%13)*x\verb|^|2+(2\%13)*x+4\%13}\end{center}

\subsection{Euclidian quotient  : {\tt quo}}\index{quo}
\noindent{\tt quo} takes as arguments  
two polynomials $A$ and $B$ with coefficients in $\Z/p\Z$, where
$A$ and $B$ are list polynomials or symbolic polynomials with
respect to $x$ or to an optionnal third argument.\\
{\tt quo} returns the quotient of the euclidian division 
of $A$ by $B$ in $\Z/p\Z[x]$.\\
Input :
\begin{center}{\tt quo((x\verb|^|3+x\verb|^|2+1)\%13,(2*x\verb|^|2+4)\%13)}\end{center}
Or :
\begin{center}{\tt quo((x\verb|^|3+x\verb|^|2+1,2*x\verb|^|2+4)\%13)}\end{center}
Output:
\begin{center}{\tt (-6\%13)*x+-6\%13}\end{center}
Indeed $\displaystyle x^3+x^2+1=(2x^2+4)(\frac{x+1}{2})+\frac{5x-4}{4}$
and $-3*4=-6*2=1 \ \bmod 13$.

\subsection{Euclidian remainder : {\tt rem}}\index{rem}
\noindent{\tt rem} takes as arguments  
two polynomials $A$ and $B$ with coefficients in $\Z/p\Z$, where
$A$ and $B$ are list polynomials or symbolic polynomials with
respect to $x$ or to an optionnal third argument.\\
{\tt rem} returns the remainder of the euclidian division  
of $A$ by $B$ in  $\Z/p\Z[x]$.\\
Input :
\begin{center}{\tt rem((x\verb|^|3+x\verb|^|2+1)\%13,(2*x\verb|^|2+4)\%13)}\end{center}
Or :
\begin{center}{\tt rem((x\verb|^|3+x\verb|^|2+1,2*x\verb|^|2+4)\%13)}\end{center}
Output:
\begin{center}{\tt (-2\%13)*x+-1\%13}\end{center}
Indeed $\displaystyle x^3+x^2+1=(2x^2+4)(\frac{x+1}{2})+\frac{5x-4}{4}$
and $-3*4=-6*2=1 \ \bmod 13$.

\subsection{Euclidian quotient and euclidian remainder : {\tt quorem}}\index{quorem}
\noindent{\tt quorem} takes as arguments  
two polynomials $A$ and $B$ with coefficients in $\Z/p\Z$, where
$A$ and $B$ are list polynomials or symbolic polynomials with
respect to $x$ or to an optionnal third argument.\\
{\tt quorem} returns the list of the quotient and remainder of the 
euclidian division of $A$ by $B$ in $\Z/p\Z[x]$
(see also \ref{sec:iquorem} and  \ref{sec:quorem}).\\
Input :
\begin{center}{\tt quorem((x\verb|^|3+x\verb|^|2+1)\%13,(2*x\verb|^|2+4)\%13)}\end{center}
Or :
\begin{center}{\tt quorem((x\verb|^|3+x\verb|^|2+1,2*x\verb|^|2+4)\%13)}\end{center}
Output:
\begin{center}{\tt [(-6\%13)*x+-6\%13,(-2\%13)*x+-1\%13]}\end{center}
Indeed
$\displaystyle x^3+x^2+1=(2x^2+4)(\frac{x+1}{2})+\frac{5x-4}{4}$\\
and $-3*4=-6*2=1 \ \bmod 13$.

\subsection{Division in $\Z/p\Z$ or in $\Z/p\Z[x]$ : {\tt /}}\index{/}
\noindent{\tt /} divides two integers in $\Z/p\Z$ or 
two polynomials $A$ and $B$ in $\Z/p\Z[x]$.\\
For polynomials, the result is the irreducible representant
of the fraction $\frac{A}{B}$ in $\Z/p\Z[x]$.\\
For integers in $\Z/p\Z$, input :
\begin{center}{\tt 5\%13/2\% 13}\end{center}
Since $2$ is invertible in $Z/13\Z$, we get the output :
\begin{center}{\tt -4\%13}\end{center}
For polynomials with coefficients in $\Z/p\Z$, input :
\begin{center}{\tt (2*x\verb|^|2+5)\%13/(5*x\verb|^|2+2*x-3)\%13}\end{center}
Output :
\begin{center}{\tt ((6\%13)*x+1\%13)/((2\%13)*x+2\%13)}\end{center}

\subsection{Power in $\Z/p\Z$ and in $\Z/p\Z[x]$ : {\tt \^\ }}\index{\^\ }
To compute {\tt a} to the power {\tt n} in $\Z/p\Z$, we use the operator 
\verb|^|. {\tt Xcas} implementation is the binary power algorithm.\\
Input :
\begin{center}{\tt (5\%13)\verb|^|2}\end{center}
Output :
\begin{center}{\tt -1\%13}\end{center}
To compute {\tt A} to the power {\tt n} in $\Z/p\Z[x]$, we use the operator 
\verb|^| and the {\tt normal} command \index{normal}.\\
Input :
\begin{center}{\tt normal(((2*x+1)\%13)\verb|^|5)}\end{center}
Output :
\begin{center}{\tt (6\%13)*x\verb|^|5+(2\%13)*x\verb|^|4+(2\%13)*x\verb|^|3+(1\%13)*x\verb|^|2+(-3\%13)*x+1\%13}\end{center}
because
 $10=-3 \ (\bmod\ 13) \ \  40=1\ (\bmod\ 13)\ \   80=2 \ (\bmod\ 13)\ \ 32=6\ (\bmod\ 13)$. 

\subsection{Compute $a^n\ \bmod \ p$ : {\tt powmod powermod}}\index{powmod}\index{powermod}
\noindent{\tt powmod} (or {\tt powermod} takes as argument $a,n,p$.\\
{\tt powmod} (or {\tt powermod}) returns $a^n\ \bmod \ p$ in $[0;p-1]$.\\
Input :
\begin{center}{\tt powmod(5,2,13)}\end{center}
Output :
\begin{center}{\tt 12}\end{center}
Input :
\begin{center}{\tt powmod(5,2,12)}\end{center}
Output :
\begin{center}{\tt 1}\end{center}

\subsection{Inverse in $\Z/p\Z$ : {\tt inv inverse} or {\tt /}}\index{/}\index{inv}
To compute the inverse of an integer {\tt n} in $\Z/p\Z$, input {\tt 1/n\%p} 
or {\tt inv(n\%p)} or {\tt inverse(n\%p)}.\\
Input :
\begin{center}{\tt inv(3\%13) }\end{center}
Output :
\begin{center}{\tt -4\%13}\end{center}
Indeed $3\times-4=-12=1\ (\bmod\ 13)$.

\subsection{Rebuild a fraction from it's value modulo $p$ : {\tt fracmod}}\index{fracmod}
\noindent {\tt fracmod} takes two arguments, an integer $n$ 
(representing a fraction) and an integer $p$ (the modulus).\\
If possible, {\tt fracmod} returns a fraction $a/b$ such that 
\[ -\frac{\sqrt{p}}{2} < a \leq \frac{\sqrt{p}}{2}, \quad
 0 \leq b < \frac{\sqrt{p}}{2}, \quad 
 n \times b =a \pmod p \]
In other words $n=a/b\pmod p$.\\
Input :
\begin{center}{\tt fracmod(3,13) }\end{center}
Output :
\begin{center}{\tt -1/4}\end{center}
Indeed : $3*-4=-12=1\ (\bmod\ 13)$, hence $3=-1/4\%13$.\\
Input :
\begin{center}{\tt fracmod(13,121)}\end{center}
Output :
\begin{center}{\tt -4/9}\end{center}
Indeed : $13\times-9=-117=4\ (\bmod\ 121)$ hence $13=-4/9\%13$.

\subsection{GCD in $\Z/p\Z[x]$ : {\tt gcd}}\index{gcd}\label{sec:gcdm}
\noindent {\tt gcd} takes as arguments two polynomials with 
coefficients in $\Z/p\Z$ ($p$ must be prime).\\
{\tt gcd} returns the GCD of these polynomials
computed in $\Z/p\Z[x]$ (see also 
\ref{sec:gcd} for polynomials with non modular coefficients).\\
Input :
\begin{center}{\tt gcd((2*x\verb|^|2+5)\%13,(5*x\verb|^|2+2*x-3)\%13)}\end{center}
Output :
\begin{center}{\tt (-4\%13)*x+5\%13}\end{center}
Input :
\begin{center}{\tt gcd((x\verb|^|2+2*x+1,x\verb|^|2-1)) mod 5)}\end{center} 
Output :
\begin{center}{\tt x\%5}\end{center}
Note the difference with a gcd computation in $\Z[X]$ followed
by a reduction modulo 5, input:
\begin{center}{\tt gcd(x\verb|^|2+2*x+1,x\verb|^|2-1) mod 5}\end{center} 
Output :
\begin{center}{\tt 1}\end{center}

\subsection{Factorization over $\Z/p\Z[x]$ : {\tt factor factoriser}}\index{factor}\index{factoriser}
\noindent{\tt factor} takes as argument a polynomial
with coefficients in $\Z/p\Z[x]$.\\
{\tt factor} factorizes this polynomial in $\Z/p\Z[x]$ ($p$ must
be prime).\\
Input :
\begin{center}{\tt factor((-3*x\verb|^|3+5*x\verb|^|2-5*x+4)\%13)}\end{center}
Output :
\begin{center}{\tt ((1\%13)*x+-6\%13)*((-3\%13)*x\verb|^|2+-5\%13)}\end{center}

\subsection{Determinant of a matrix in $\Z/p\Z$ : {\tt det}}\index{det}
\noindent{\tt det} takes as argument a matrix $A$ with coefficients in 
$Z/pZ$.\\
{\tt det} returns the determinant of this matrix $A$.\\
Computation are done in $\Z/p\Z$ by Gauss reduction.
Input :
\begin{center}{\tt det([[1,2,9]\%13,[3,10,0]\%13,[3,11,1]\%13])}\end{center} 
Or :
\begin{center}{\tt det([[1,2,9],[3,10,0],[3,11,1]]\%13)}\end{center} 
Output :
\begin{center}{\tt 5\%13}\end{center} 
hence, in  $\Z/13\Z$, the determinant of  
$A=[[1,2,9],[3,10,0],[3,11,1]]$ is {\tt 5\%13} (in $\Z$, {\tt det(A)=31}).

\subsection{Inverse of a matrix with coefficients in $\Z/p\Z$ : {\tt inv inverse}}\index{inv}\index{inverse}
\noindent{\tt inverse} (or {\tt inv}) takes as argument a matrix $A$ in 
$\Z/p\Z$.\\
{\tt inverse} (ou {\tt inv}) returns the inverse of the matrix 
$A$ in $Z/p\Z$.\\
Input :
\begin{center}{\tt inverse([[1,2,9]\%13,[3,10,0]\%13,[3,11,1]\%13])}\end{center} 
Or :
\begin{center}{\tt inv([[1,2,9]\%13,[3,10,0]\%13,[3,11,1]\%13])}\end{center} 
Or :
\begin{center}{\tt inverse([[1,2,9],[3,10,0],[3,11,1]]\%13)}\end{center} 
Or :
\begin{center}{\tt inv([[1,2,9],[3,10,0],[3,11,1]]\%13)}\end{center}
Output :
\begin{center}{\tt [[2\%13,-4\%13,-5\%13],[2\%13,0\%13,-5\%13], [-2\%13,-1\%13,6\%13]]}\end{center} 
it is the inverse of $A=[[1,2,9],[3,10,0],[3,11,1]]$ in $\Z/13\Z$.

\subsection{Row reduction to echelon form in $\Z/p\Z$ : {\tt rref}}\index{rref}\label{sec:rrefm}
\noindent{\tt rref} find the row reduction to echelon form of
a matrix with coefficients in $\Z/p\Z$. 

This may be used
to solve a linear system of equations with coefficients in  $\Z/p\Z$, 
by rewriting it in matrix form (see also \ref{sec:rref}) :
\begin{center}{\tt A*X=B}\end{center}
{\tt rref} takes as argument the augmented matrix 
of the system (the matrix obtained by augmenting matrix {\tt A} to the 
right with the column vector {\tt B}).\\
{\tt rref} returns a matrix {\tt [A1,B1]} : {\tt A1} has 1 on
it's principal diagonal, and zeros outside, and the
solutions in $\Z/p\Z$, of :
\begin{center}{\tt A1*X=B1}\end{center} 
are the same as the solutions of:
\begin{center}{\tt A*X=B}\end{center}
Example, solve in $\Z/13\Z$
$$\left \{\begin{array}{lcr}\ \  x\ +\ \  2 \cdot y & = &9 \\3 \cdot x +10 \cdot y & =& 0 \end{array}\right.$$
Input :
\begin{center}{\tt rref([[1, 2, 9]\%13,[3,10,0]\%13])}\end{center} 
Or :
\begin{center}{\tt rref([[1, 2, 9],[3,10,0]])\%13}\end{center} 
Output :
\begin{center}{\tt [[1\%13,0\%13,3\%13],[0\%13,1\%13,3\%13]]}\end{center} 
hence {\tt x=3\%13} and  {\tt y=3\%13}.

\subsection{Construction of a Galois field : {\tt GF}}\index{GF}
\noindent{\tt GF} takes as arguments a prime integer $p$ 
and an integer $n>1$.\\
{\tt GF} returns a Galois field of caracteristic $p$ having $p^n$
elements.\\
Elements of the field and the field itself
are represented by {\tt GF(...)} where {\tt ...} is the following 
sequence:
\begin{itemize}
\item the caracteristic $p$ ($px=0$),
\item an irreducible primitive minimal polynomial generating an
ideal $I$ in $\Z/p\Z[X]$, the Galois field being the quotient
of $\Z/p\Z[X]$ by $I$,
\item the name of the polynomial variable, by default {\tt x},
\item a polynomial (a remainder modulo the minimal polynomial) 
for an element of the field
(field elements are represented with the additive representation)
or {\tt undef} for the field itself.
\end{itemize}
You should give a name to this field (for example {\tt G:=GF(p,n)}),
in order to build elements of the field from a polynomial in
$\Z/p\Z[X]$, for example {\tt G(x\verb|^|3+x)}. Note that {\tt G(x)}
is a generator of the multiplicative group {\tt $G^*$}.\\
Input :
\begin{center}{\tt G:=GF(2,8)}\end{center}
Output :
\begin{center}{\tt GF(2,x\verb|^|8-x\verb|^|6-x\verb|^|4-x\verb|^|3-x\verb|^|2-x-1,x,undef)}\end{center}
The field $G$ has $2^8=256$ elements and  
$x$ generates the multiplicative group
of this field  ($\{ 1,x,x^2,...x^{254} \}$).\\
Input :
\begin{center}{\tt G(x\verb|^|9)}\end{center}
Output :
\begin{center}{\tt GF(2,x\verb|^|8-x\verb|^|6-x\verb|^|4-x\verb|^|3-x\verb|^|2-x-1,x,x\verb|^|7+x\verb|^|5+x\verb|^|4+x\verb|^|3+x\verb|^|2+x)}\end{center}
indeed $x^8=x^6+x^4+x^3+x^2+x+1$, hence $x^9=x^7+x^5+x^4+x^3+x^2+x$.\\
Input :
\begin{center}{\tt G(x)\verb|^|255}\end{center}
Output should be the unit, indeed:
\begin{center}
{\tt GF(2,x\verb|^|8-x\verb|^|6-x\verb|^|4-x\verb|^|3-x\verb|^|2-x-1,x,1)}\end{center}
As one can see on these examples, the output contains many times the same
informations that you would prefer no to see
if you work many times with the same field. For this reason,
the definition of a Galois field may have an optionnal argument,
a variable name which will be used thereafter to represent elements
of the field. Since you will also most
likely want to modify the name of the indeterminate, the field
name is grouped with the variable name in a list
passed as third argument to {\tt GF}.
Note that these two variable names must be quoted.\\
Example, input :
\begin{center}{\tt G:=GF(2,2,['w','G']):; G(w\verb|^|2)}\end{center}
Output :
\begin{center}{\tt Done, G(w+1)}\end{center}
Input :
\begin{center}{\tt G(w\verb|^|3)}\end{center}
Output :
\begin{center}{\tt G(1)}\end{center}
Hence, the elements of {\tt GF(2,2)} are
{\tt G(0),G(1),G(w),G(w\verb|^|2)=G(w+1)}.

We may also impose the irreductible primitive polynomial that we whish
to use, by putting it as second argument (instead of $n$), 
for example :
\begin{center}\verb|G:=GF(2,w^8+w^6+w^3+w^2+1,['w','G'])|\end{center}
If the polynomial is not primitive, {\tt Xcas} will replace it
automatically by a primitive polynomial, for example :
\begin{center}\verb|G:=GF(2,w^8+w^7+w^5+w+1,['w','G'])|\end{center}
Output :
\begin{center}\verb|G:=GF(2,w^8-w^6-w^3-w^2-1,['w','G'],undef)|\end{center}

\subsection{Factorize a polynomial with coefficients in a Galois field : {\tt factor}}\index{factor}
\noindent{\tt factor} can also factorize a univariate
polynomial with coefficients in a Galois field.\\
Input for example to have {\tt G=}$\mathbb F_4$:\\
\begin{center}{\tt G:=GF(2,2,['w','G'])}\end{center}
Output :
\begin{center}{\tt GF(2,w\verb|^|2+w+1,[w,G],undef)}\end{center}
Input for example :
\begin{center}{\tt a:=G(w)}\end{center}
\begin{center}{\tt factor(a\verb|^|2*x\verb|^|2+1))}\end{center}
Output :
\begin{center}{\tt (G(w+1))*(x+G(w+1))\verb|^|2}\end{center}

\section{Compute in $\Z/p\Z[x]$ using Maple syntax}\index{mod}\index{\%}\label{sec:modulmap}
\subsection{Euclidean quotient : {\tt Quo}}\index{Quo}
\noindent {\tt Quo} is the inert form of {\tt quo}.\\
{\tt Quo} returns the euclidean quotient between two polynomials
 without evaluation.\\ 
It is used in conjonction with {\tt mod} in Maple syntax mode to compute
the euclidean quotient of the division of two
polynomials with coefficients in $\Z/p\Z$.\\
Input in {\tt Xcas} mode:
\begin{center}{\tt Quo((x\verb|^|3+x\verb|^|2+1) mod 13,(2*x\verb|^|2+4) mod 13)}\end{center}
Output :
\begin{center}{\tt quo((x\verb|^|3+x\verb|^|2+1)\%13,(2*x\verb|^|2+4)\%13)}\end{center}
you need to {\tt eval(ans())} to get :
\begin{center}{\tt (-6\%13)*x+-6\%13}\end{center}
Input in {\tt Maple} mode :
\begin{center}{\tt Quo(x\verb|^|3+x\verb|^|2+1,2*x\verb|^|2+4) mod 13}\end{center}
Output :
\begin{center}{\tt (-6)*x-6}\end{center}
Input in {\tt Maple} mode :
\begin{center}{\tt Quo(x\verb|^|2+2*x,x\verb|^|2+6*x+5) mod 5}\end{center}
Output :
\begin{center}{\tt 1}\end{center}

\subsection{Euclidien remainder: {\tt Rem}}\index{Rem}
\noindent{\tt Rem} is the inert form of {\tt rem}.\\
{\tt Rem} returns the euclidean remainder between two polynomials
without evaluation. 
It is used in conjonction with {\tt mod} in Maple syntax mode to compute
the euclidean remainder of the division of two
polynomials with coefficients in $\Z/p\Z$.\\
Input in {\tt Xcas} mode :
\begin{center}{\tt Rem((x\verb|^|3+x\verb|^|2+1) mod 13,(2*x\verb|^|2+4) mod 13)}\end{center}
Output :
\begin{center}{\tt rem((x\verb|^|3+x\verb|^|2+1)\%13,(2*x\verb|^|2+4)\%13)}\end{center}
you need to {\tt eval(ans())} to get :
\begin{center}{\tt (-2\%13)*x+-1\%13}\end{center}
Input in {\tt Maple} mode :
\begin{center}{\tt Rem(x\verb|^|3+x\verb|^|2+1,2*x\verb|^|2+4) mod 13}\end{center}
Output :
\begin{center}{\tt (-2)*x-1}\end{center}
Input in {\tt Maple} mode :
\begin{center}{\tt Rem(x\verb|^|2+2*x,x\verb|^|2+6*x+5) mod 5}\end{center}
Output :
\begin{center}{\tt 1*x}\end{center}

\subsection{GCD in $\Z/p\Z[x]$ : {\tt Gcd}}\index{Gcd}
\noindent{\tt Gcd}  is the inert form of  {\tt gcd}.\\
{\tt Gcd} returns the gcd (greatest common divisor) of two polynomials
(or of a list of polynomials or of a sequence of polynomials) without
evaluation.\\ 
It is used in conjonction with {\tt mod} in Maple syntax mode to compute
the gcd of two polynomials with coefficients in $\Z/p\Z$ with $p$ prime
(see also \ref{sec:gcd}).\\
Input in {\tt Xcas} mode :
\begin{center}{\tt Gcd((2*x\verb|^|2+5,5*x\verb|^|2+2*x-3)\%13)}\end{center}
Output :
\begin{center}{\tt gcd((2*x\verb|^|2+5)\%13,(5*x\verb|^|2+2*x-3)\%13)}\end{center}
you need to {\tt eval(ans())} to get :
\begin{center}{\tt (1\%13)*x+2\%13}\end{center}
Input in {\tt Maple} mode :
\begin{center}{\tt Gcd(2*x\verb|^|2+5,5*x\verb|^|2+2*x-3) mod 13}\end{center}
Output :
\begin{center}{\tt 1*x+2}\end{center}
Input:
\begin{center}{\tt Gcd(x\verb|^|2+2*x,x\verb|^|2+6*x+5) mod 5}\end{center}
Output :
\begin{center}{\tt 1*x}\end{center}

\subsection{Factorization in $\Z/p\Z[x]$ : {\tt Factor}}\index{Factor}
\noindent{\tt Factor} is the inert form of {\tt factor}.\\
{\tt Factor} takes as argument a polynomial.\\
{\tt Factor} returns {\tt factor} without evaluation. 
It is used in conjonction with {\tt mod} in Maple syntax mode to 
factorize a polynomial with coefficients in $\Z/p\Z$
where $p$ must be prime.\\
Input in {\tt Xcas} mode :
\begin{center}{\tt Factor((-3*x\verb|^|3+5*x\verb|^|2-5*x+4)\%13)}\end{center}
Output :
\begin{center}{\tt factor((-3*x\verb|^|3+5*x\verb|^|2-5*x+4)\%13)}\end{center}
you need to {\tt eval(ans())} to get :
\begin{center}{\tt ((1\%13)*x+-6\%13)*((-3\%13)*x\verb|^|2+-5\%13)}\end{center}
Input in {\tt Maple} mode :
\begin{center}{\tt Factor(-3*x\verb|^|3+5*x\verb|^|2-5*x+4) mod 13}\end{center}
Output :
\begin{center}{\tt -3*(1*x-6)*(1*x\verb|^|2+6)}\end{center}

\subsection{Determinant of a matrix with coefficients in $\Z/p\Z$ : {\tt Det}}\index{Det}
\noindent{\tt Det} is the inert form of {\tt det}.\\
{\tt Det} takes as argument a matrix with coefficients in $\Z/p\Z$.\\ 
{\tt Det} returns {\tt det} without evaluation. 
It is used in conjonction with {\tt mod} in Maple syntax mode to 
find the determinant of a matrix with coefficients in $\Z/p\Z$.\\
Input in {\tt Xcas} mode :
\begin{center}{\tt Det([[1,2,9] mod 13,[3,10,0] mod 13,[3,11,1] mod 13])}\end{center} 
Output :
\begin{center}{\tt det([[1\%13,2\%13,-4\%13],[3\%13,-3\%13,0\%13], [3\%13,-2\%13,1\%13]])}\end{center}
you need to {\tt eval(ans())} to get :
\begin{center}{\tt 5\%13}\end{center} 
hence, in  $\Z/13\Z$, the determinant of
$A=[[1, 2, 9],[3,10,0],[3,11,1]]$ is {\tt 5\%13} (in $\Z$ {\tt det(A)=31}).\\
Input in {\tt Maple} mode :
\begin{center}{\tt Det([[1,2,9],[3,10,0],[3,11,1]]) mod 13}\end{center}
Output :
\begin{center}{\tt 5}\end{center}

\subsection{Inverse of a matrix in $\Z/p\Z$ : {\tt Inverse}}\index{Inverse}
\noindent{\tt Inverse}   is the inert form of {\tt inverse}.\\
{\tt Inverse} takes as argument a matrix with coefficients in $\Z/p\Z$.\\
{\tt Inverse} returns {\tt inverse} without evaluation. 
It is used in conjonction with {\tt mod} in Maple syntax mode to 
find the inverse of a matrix with coefficients in $\Z/p\Z$.\\
Input in {\tt Xcas} mode :
\begin{center}{\tt Inverse([[1,2,9] mod 13,[3,10,0] mod 13,[3,11,1] mod13])}\end{center} 
Output :
\begin{center}{\tt inverse([[1\%13,2\%13,9\%13],[3\%13,10\%13,0\%13], [3\%13,11\%13,1\%13]])}\end{center} 
you need to {\tt eval(ans())} to get :
\begin{center}{\tt [[2\%13,-4\%13,-5\%13],[2\%13,0\%13,-5\%13], [-2\%13,-1\%13,6\%13]]}\end{center} 
which is the inverse of $A=[[1,2,9],[3,10,0],[3,11,1]]$ in $\Z/13\Z$.\\
Input in {\tt Maple} mode :
\begin{center}{\tt Inverse([[1,2,9],[3,10,0],[3,11,1]]) mod 13}\end{center}
Output :
\begin{center}{\tt [[2,-4,-5],[2,0,-5],[-2,-1,6]]}\end{center}

\subsection{Row reduction to echelon form in $\Z/p\Z$ : {\tt Rref}}\index{Rref}
\noindent{\tt Rref}  is the inert form of {\tt rref}.\\ 
{\tt Rref} returns {\tt rref} without
evaluation. 
It is used in conjonction with {\tt mod} in Maple syntax mode to 
find the row reduction to echelon form 
of a matrix with coefficients in $\Z/p\Z$ (see 
also \ref{sec:rref}).\\
Example, solve in $\Z/13\Z$
$$\left \{\begin{array}{lcr}\ \  x\ +\ \  2 \cdot y & = &9 \\3 \cdot x +10 \cdot y & =& 0 \end{array}\right.$$
Input in {\tt Xcas} mode :
\begin{center}{\tt Rref([[1,2,9] mod 13,[3,10,0] mod 13])}\end{center} 
Output :
\begin{center}{\tt rref([[1\%13, 2\%13, 9\%13],[3\%13,10\%13,0\%13]])}\end{center}
you need to {\tt eval(ans())} to get :
\begin{center}{\tt [[1\%13,0\%13,3\%13],[0\%13,1\%13,3\%13]]}\end{center} 
and conclude that {\tt x=3\%13} and  {\tt y=3\%13}.\\
Input in {\tt Maple} mode :
\begin{center}{\tt Rref([[1,2,9],[3,10,0],[3,11,1]]) mod 13}\end{center}
Output :
\begin{center}{\tt [[1,0,0],[0,1,0],[0,0,1]]}\end{center}


\section{Taylor and asymptotic expansions}
\subsection{Division by increasing power order : {\tt divpc}}\index{divpc}
\noindent{\tt divpc} takes three arguments : two polynomials
expressions $A,\ B$ depending on $x$,
such that the constant term of $B$ is not 0, and an integer $n$.\\
{\tt divpc} returns the  quotient $Q$ of the division of $A$ by $B$ 
by increasing power order, with  {\tt degree}$(Q)\leq n$ or $ Q=0$.
In other words, $Q$ is the Taylor expansion at order $n$ of
$\displaystyle \frac{A}{B}$ in the vicinity of $x=0$. \\ 
Input :
\begin{center}{\tt divpc(1+x\verb|^|2+x\verb|^|3,1+x\verb|^|2,5)}\end{center}
Output :
\begin{center}{\tt -x\verb|^|5+x\verb|^|3+1}\end{center}
Note that this command does not work on polynomials written
as list of coefficients.

\subsection{Taylor expansion : {\tt taylor}}\index{taylor}\index{order\_size|textbf} 
\noindent{\tt taylor} takes from one to four arguments :
\begin{itemize}
\item an expression dependending of a variable (by default {\tt x}),
\item an equality variable=value (e.g. $x=a$) where to compute
the Taylor expansion, by default {\tt x=0}, 
\item an integer $n$, the order of the series expansion,
by default {\tt 5}
\item a direction  {\tt -1, 1} (for unidirectional series expansion)
  or {\tt 0} (for bidirectional series expansion) (by default {\tt
    0}).
\end{itemize}
Note that the syntax {\tt ...,x,$n$,$a$,...} 
(instead of {\tt ...,x=$a$,$n$,...}) is also accepted.\\
{\tt taylor} returns  a polynomial in {\tt x-a}, plus a remainder 
of the form:\\
 {\tt (x-a)\verb|^|n*order\_size(x-a)}\\
where {\tt order\_size} is a function such that,
\[ \forall r>0, \quad \lim_{x\rightarrow 0} x^r \mbox{order\_size}(x) = 0 \]
For regular series expansion, {\tt order\_size} is a bounded function,
but for non regular series expansion, it might tend slowly to
infinity, for example like a power of $\ln(x)$.\\
Input :
\begin{center}{\tt taylor(sin(x),x=1,2)}\end{center}
Or (be carefull with the  order of the arguments !) :
\begin{center}{\tt taylor(sin(x),x,2,1)}\end{center}
Output :
\begin{center}{\tt sin(1)+cos(1)*(x-1)+(-(1/2*sin(1)))*(x-1)\verb|^|2+ (x-1)\verb|^|3*order\_size(x-1)}\end{center}
{\bf Remark}\\
The order returned by {\tt taylor} may be smaller than $n$ if
cancellations between numerator and denominator occur, for example
\[ \mbox{taylor}(\frac{x^3+\sin(x)^3}{x-\sin(x)}) \]
Input :
\begin{center}{\tt taylor(x\verb|^|3+sin(x)\verb|^|3/(x-sin(x)))}\end{center}
The output is only a 2nd-order series expansion :
\begin{center}{\tt
    6+-27/10*x\verb|^2|+x\verb|^|3*order\_size(x)}\end{center}
Indeed the numerator and denominator valuation is 3, hence we loose 3
orders. To get order 4, we should ask $n=7$, input :
\begin{center}{\tt taylor(x\verb|^|3+sin(x)\verb|^|3/(x-sin(x)),x=0,7)}\end{center}
Output is a 4th-order series expansion :
\begin{center}{\tt 6+-27/10*x\verb|^|2+x\verb|^|3+711/1400*x\verb|^|4+x\verb|^|5*order\_size(x)}\end{center}

\subsection{Series expansion : {\tt series}}\index{series}\index{order\_size} 
\noindent{\tt series} takes from one to four arguments :
\begin{itemize}
\item an expression dependending of a variable (by default {\tt x}),
\item an equality variable=value (e.g. $x=a$) where to compute
the series expansion, by default {\tt x=0}, 
\item an integer $n$, the order of the series expansion,
by default {\tt 5}
\item a direction  {\tt -1, 1} (for unidirectional series expansion)
  or {\tt 0} (for bidirectional series expansion) (by default {\tt
    0}).
\end{itemize}
Note that the syntax {\tt ...,x,$a$,$n$,...} 
(instead of {\tt ...,x=$a$,$n$,...}) is also accepted.\\
{\tt series} returns  a polynomial in {\tt x-a}, plus a remainder 
of the form:
\begin{center}
 {\tt (x-a)\verb|^|n*order\_size(x-a)}
\end{center}
where {\tt order\_size} is a function such that,
\[ \forall r>0, \quad \lim_{x\rightarrow 0} x^r \mbox{order\_size}(x) = 0 \]
The order returned by {\tt series} may be smaller than $n$ if
cancellations between numerator and denominator occur.

Examples~:
\begin{itemize}
\item  series expansion in the vicinity of {\tt x=0}\\
 Find an series expansion of 
$\displaystyle\frac{x^3+\sin(x)^3}{x-\sin(x)}$ 
in the vicinity of {\tt x=0}.\\
Input :
\begin{center}{\tt series(x\verb|^|3+sin(x)\verb|^|3/(x-sin(x)))}\end{center}
Output is only a 2nd-order series expansion :
\begin{center}{\tt 6+-27/10*x\verb|^2|+x\verb|^|3*order\_size(x)}\end{center}
We have lost 3 orders because the valuation of the numerator and
denominator is 3. To get a 4-th order expansion, we must therefore 
take $n=7$, input:
\begin{center}{\tt series(x\verb|^|3+sin(x)\verb|^|3/(x-sin(x)),x=0,7)}\end{center}
Or :
\begin{center}{\tt series(x\verb|^|3+sin(x)\verb|^|3/(x-sin(x)),x,0,7)}\end{center}
Output is a 4th-order series expansion :
\begin{center}{\tt 6+-27/10*x\verb|^|2+x\verb|^|3+711/1400*x\verb|^|4+
x\verb|^|5*order\_size(x)}\end{center}
\item  series expansion in the vicinity of {\tt x=a}\\
Find a series 4th-order expansion of $\cos(2x)^2$ in the vicinity of
$x=\frac{\pi}{6}$. \\
Input:
\begin{center}{\tt series(cos(2*x)\verb|^|2,x=pi/6, 4)}\end{center}
Output :
\begin{center}{\tt 1/4+(-(4*sqrt(3)))/4*(x-pi/6)+(4*3-4)/4*(x-pi/6)\verb|^|2+ 32*sqrt(3)/3/4*(x-pi/6)\verb|^|3+(-16*3+16)/3/4*(x-pi/6)\verb|^|4+ (x-pi/6)\verb|^|5*order\_size(x-pi/6)}\end{center} 
\item  series expansion in the vicinity of {\tt x=+$\infty$} or  {\tt
    x=-$\infty$}
\begin{enumerate}
\item 
Find a 5th-order series expansion of $\arctan(x)$ in the vicinity of
{\tt x=+$\infty$}.\\
 Input :
\begin{center}{\tt series(atan(x),x=+infinity,5)}\end{center}
Output :
\begin{center}{\tt pi/2-1/x+1/3*(1/x)\verb|^|3+1/-5*(1/x)\verb|^|5+
(1/x)\verb|^|6*order\_size(1/x)}\end{center}
Note that the expansion variable and the argument of the 
{\tt order\_size} function is
$\displaystyle h=\frac{1}{x} \rightarrow_{x\rightarrow + \infty} 0 $.
\item
Find a series 2nd-order expansion of $(2x-1)e^{\frac{1}{x-1}}$ in the vicinity of
{\tt x=+$\infty$}. \\
Input :
\begin{center}{\tt series((2*x-1)*exp(1/(x-1)),x=+infinity,3)}\end{center}
Output is only a 1st-order series expansion :
\begin{center}{\tt  2*x+1+2/x+(1/x)\verb|^|2*order\_size(1/x)}\end{center}
To get a 2nd-order series expansion in $1/x$, input:
\begin{center}{\tt series((2*x-1)*exp(1/(x-1)),x=+infinity,4)}\end{center}
Output :
\begin{center}{\tt
    2*x+1+2/x+17/6*(1/x)\verb|^|2+(1/x)\verb|^|3*order\_size(1/x)}\end{center}
\item
Find a 2nd-order series expansion of $(2x-1)e^{\frac{1}{x-1}}$ in the vicinity 
of {\tt x=-$\infty$}.\\
Input :
\begin{center}{\tt series((2*x-1)*exp(1/(x-1)),x=-infinity,4)}\end{center}
Output :
\begin{center}{\tt -2*(-x)+1-2*(-1/x)+17/6*(-1/x)\verb|^|2+\\
(-1/x)\verb|^|3*order\_size(-1/x)}\end{center}
\end{enumerate}
\item unidirectional series expansion.\\
The fourth parameter indicates the direction :
\begin{itemize}
\item {\tt 1} to do an series expansion in the vicinity of $x=a$ with 
$ \ x>a$,
\item{\tt -1} to do an series expansion in the vicinity of $x=a$ with 
$ \ x<a$,
\item{\tt 0}  to do an series expansion in the vicinity of $x=a$ with 
$ \ x \neq a$.
\end{itemize}
For example, 
find a 2nd-order series expansion of $\ \frac{(1+x)^{\frac{1}{x}}}{x^3}\ $ in 
the vicinity of $x=0^+$. Input :
\begin{center}{\tt series((1+x)\verb|^|(1/x)/x\verb|^|3,x=0,2,1)}\end{center}
Output :
\begin{center}{\tt exp(1)/x\verb|^|3+(-(exp(1)))/2/x\verb|^|2+1/x*order\_size(x)}\end{center}
\end{itemize}

\subsection{R\'esidu d'une expression en un point : {\tt residue}}\index{residue}
{\tt residue} takes as argument an expression depending of a variable, 
this variable name and a complex $a$ or an expression 
depending of a variable and the equality : variable\_name=$a$.
{\tt residue} returns the residue of this exppression at the point $a$.\\
Input :
\begin{center}{\tt residue(cos(x)/x\verb|^|3,x,0)}\end{center}
Or :
\begin{center}{\tt residue(cos(x)/x\verb|^|3,x=0)}\end{center}
Output :
\begin{center}{\tt (-1)/2}\end{center}

\subsection{Pad\'e expansion: {\tt pade}}\index{pade}
{\tt pade} takes 4 arguments
\begin{itemize}
\item an expression, 
\item the variable name the expression depends on,
\item an integer $n$ or a polynomial $N$,
\item an integer $p$.
\end{itemize}
{\tt pade} returns a rationnal fraction  $P/Q$ such that {\tt
  degree(P)}$<p$ and $P/Q=f \pmod{x^{n+1}}$ or $P/Q=f \pmod{N}$.
In the first case, it means that $P/Q$ and $f$ have the same 
Taylor expansion at 0 up to order $n$.\\ 
Input :
\begin{center}{\tt pade(exp(x),x,5,3)}\end{center}
Or :
\begin{center}{\tt pade(exp(x),x,x\verb|^|6,3)}\end{center}
Output :
\begin{center}{\tt (3*x\verb|^|2+24*x+60)/(-x\verb|^|3+9*x\verb|^|2-36*x+60)}\end{center}
To verify input :
\begin{center}{\tt taylor((3*x\verb|^|2+24*x+60)/(-x\verb|^|3+9*x\verb|^|2-36*x+60))}\end{center}
Output :
\begin{center}{\tt 1+x+1/2*x\verb|^|2+1/6*x\verb|^|3+1/24*x\verb|^|4+1/120*x\verb|^|5+x\verb|^|6*order\_size(x)}\end{center}
which is the 5th-order series expansion of {\tt exp(x)} at $x=0$.\\
Input :
\begin{center}{\tt pade((x\verb|^|15+x+1)/(x\verb|^|12+1),x,12,3)}\end{center}
Or :
\begin{center}{\tt pade((x\verb|^|15+x+1)/(x\verb|^|12+1),x,x\verb|^|13,3)}\end{center}
Output :
\begin{center}{\tt x+1}\end{center}
Input :
\begin{center}{\tt pade((x\verb|^|15+x+1)/(x\verb|^|12+1),x,14,4)}\end{center}
Or :
\begin{center}{\tt pade((x\verb|^|15+x+1)/(x\verb|^|12+1),x,x\verb|^|15,4)}\end{center}
Output :
\begin{center}{\tt (-2*x\verb|^|3-1)/(-x\verb|^|11+x\verb|^|10-x\verb|^|9+x\verb|^|8-x\verb|^|7+x\verb|^|6-x\verb|^|5+x\verb|^|4- x\verb|^|3-x\verb|^|2+x-1)}\end{center}
To verify, input :
\begin{center}{\tt series(ans(),x=0,15)}\end{center}
Output :
\begin{center}{\tt 1+x-x\verb|^|{12}-x\verb|^|{13}+2x\verb|^|{15}+x\verb|^|{16}*order\_size(x)}\end{center}
then input :
\begin{center}{\tt series((x\verb|^|15+x+1)/(\verb|x^|12+1),x=0,15)}\end{center}
Output :
\begin{center}{\tt 1+x-x\verb|^|{12}-x\verb|^|{13}+x\verb|^|{15}+x\verb|^|{16}*order\_size(x)}\end{center}
These two expressions have the same 14th-order series expansion at $x=0$.

\section{Intervals}
\subsection{Definition of an interval : {\tt a1..a2}}\index{..|textbf}
An interval is represented by two real numbers 
separated by {\tt ..}, for example 
\begin{center}{\tt 1..3}\\
{\tt 1.2..sqrt(2)}
\end{center}
Input :
\begin{center}{\tt A:=1..4}\end{center}
\begin{center}{\tt B:=1.2..sqrt(2)}\end{center}
{\bf Warning!}\\
The order of the boundaries of the interval is significant. For
example, if you input 
\begin{center}
{\tt B:=2..3; C:=3..2},
\end{center}
then {\tt B} and {\tt C} are different, {\tt B==C} returns {\tt 0}.

\subsection{Boundaries of an interval : {\tt left right}}\index{[]}\index{sommet}\index{feuille}\index{op}\index{left}\index{right} 
\noindent {\tt left} (resp {\tt right}) takes as argument an interval.\\
{\tt left} (resp {\tt right}) returns the left (resp right) boundary
of this interval. \\
Note that {\tt ..} is an  infixed operator, therefore:
\begin{itemize}
\item {\tt sommet(1..5)} is equal to {\tt '..'} and {\tt feuille(1..5)}
 is equal to {\tt (1,5)}.
\item the name of the interval followed by 
{\tt [0]} returns the operator {\tt ..}
\item 
the name of the interval followed by {\tt [1]} 
(or the {\tt left} command)  returns the left boundary.
\item
The name of the interval followed by {\tt [2]} 
(or the {\tt right} command) 
returns the right boundary.
\end{itemize}
Input :
\begin{center}{\tt (3..5)[0]}\end{center}
Or :
\begin{center}{\tt sommet(3..5)}\end{center}
Output :
\begin{center}{\tt '..'}\end{center}
Input :
\begin{center}{\tt left(3..5)}\end{center}
Or :
\begin{center}{\tt (3..5)[1]}\end{center}
Or :
\begin{center}{\tt feuille(3..5)[0]}\end{center}
Or :
\begin{center}{\tt op(3..5)[0]}\end{center}
Output :
\begin{center}{\tt 3}\end{center}
Input :
\begin{center}{\tt right(3..5)}\end{center}
Or :
\begin{center}{\tt (2..5)[2]}\end{center}
Or :
\begin{center}{\tt feuille(3..5)[1]}\end{center}
Or :
\begin{center}{\tt op(3..5)[1]}\end{center}
Output :
\begin{center}{\tt 5}\end{center}
{\bf Remark}\\
{\tt left} (resp {\tt right}) returns also the left (resp right) member of an 
equation (for example {\tt left(2*x+1=x+2)} returns {\tt 2*x+1}).

\subsection{Center of an interval : {\tt interval2center}}\index{interval2center}
\noindent {\tt interval2center} takes as argument an interval or a list of
intervals.\\
{\tt interval2center} returns the center of this interval or the list of
centers of these intervals.\\
Input :
\begin{center}{\tt interval2center(3..5)}\end{center}
Output :
\begin{center}{\tt 4}\end{center}
Input :
\begin{center}{\tt interval2center([2..4,4..6,6..10])}\end{center}
Output :
\begin{center}{\tt [3,5,8]}\end{center}

\subsection{Intervals defined by their center : {\tt center2interval}}\index{center2interval}
\noindent {\tt center2interval} takes as argument a vector {\tt V} of reals
and optionnally a real as second argument 
(by default {\tt V[0]-(V[1]-V[0])/2}).\\
{\tt center2interval} returns a vector of intervals having 
the real values of the first argument as centers, where
the value of the second argument is
the left boundary of the first interval.\\
Input :
\begin{center}{\tt center2interval([3,5,8])}\end{center}
Or (since the default value is 3-(5-3)/2=2) :
\begin{center}{\tt center2interval([3,5,8],2)}\end{center}
Output :
\begin{center}{\tt [2..4,4..6,6..10]}\end{center}
Input :
\begin{center}{\tt center2interval([3,5,8],2.5)}\end{center}
Output :
\begin{center}{\tt [2.5..3.5,3.5..6.5,6.5..9.5]}\end{center}

\section{Sequences}
\subsection{Definition : {\tt seq[]  ()}}\index{seq[]}\index{()}
A sequence is represented by 
a sequence of elements separated by commas, without
delimiters or with either {\tt ( )} or {\tt seq[...]}
as delimiters, for example
\begin{center}
{\tt (1,2,3,4)}\\
{\tt seq[1,2,3,4]}
\end{center}
Input :
\begin{center}{\tt A:=(1,2,3,4)} or {\tt A:=seq[1,2,3,4]}\end{center}
\begin{center}{\tt B:=(5,6,3,4)} or {\tt B:=seq[5,6,3,4]}\end{center}
{\bf Remarks}
\begin{itemize}
\item The order of the elements of the sequence is significant.
For example, if {\tt B:=(5,6,3,4)} and  {\tt C:=(3,4,5,6)}, then
{\tt B==C} returns {\tt 0}.
\item
(see also \ref{sec:seq})\\
{\tt seq([0,2])=(0,0)} and  {\tt seq([0,1,1,5])=[0,0,0,0,0]} but\\
{\tt seq[0,2]=(0,2)} and  {\tt seq[0,1,1,5]=(0,1,1,5)}
\end{itemize}

\subsection{Concat two sequences : {\tt ,}}\index{,}
The infix operator {\tt ,} concatenates two sequences.\\
Input :
\begin{center}{\tt A:=(1,2,3,4)}\end{center}
\begin{center}{\tt B:=(5,6,3,4)}\end{center}
\begin{center}{\tt A,B}\end{center}
Output :
\begin{center}{\tt (1,2,3,4,5,6,3,4)}\end{center}

\subsection{Get an element of a sequence : {\tt []}}\index{[]}
The elements of a sequence have indexes begining at 0 in {\tt Xcas}
mode or 1 in other modes.\\
A sequence or a variable name assigned to a sequence
followed by {\tt [n]} returns the element of index {\tt n} of the sequence.\\
Input :
\begin{center}{\tt (0,3,2)[1]}\end{center}
Output :
\begin{center}{\tt 3}\end{center}

\subsection{Sub-sequence of a sequence : {\tt []}}\index{[]}\index{..}
A sequence or a variable name assigned to a sequence followed by
{\tt [n1..n2]} returns the sub-sequence of this sequence
starting at index {\tt n1} and ending at index {\tt n2}.\\
Input :
\begin{center}{\tt (0,1,2,3,4)[1..3]}\end{center}
Output :
\begin{center}{\tt (1,2,3)}\end{center}

\subsection{Make a sequence or a list : {\tt seq \$}}\index{seq|textbf}\index{\$|textbf}\label{sec:seq}
\noindent{\tt seq} takes two, three, four or five arguments : the first 
argument is an expression depending of a parameter (for example $j$) and  
the remaining argument(s) describe which values of $j$ will be used to
generate the sequence. More precisely $j$ is assumed to move 
from $a$ to $b$:
\begin{itemize}
\item with a default step of 1 or -1: {\tt j=a..b} or 
{\tt j,a..b} (Maple-like syntax), {\tt j,a,b} (TI-like syntax)
\item or with a specific step: 
{\tt j=a..b,p} (Maple-like syntax), {\tt j,a,b,p} (TI-like syntax).
\end{itemize}
If the Maple-like syntax is used, {\tt seq} returns a sequence,
if the TI-like syntax is used, {\tt seq} returns a list.
 
{\tt \$} is the infixed version of {\tt seq} when {\tt seq} has only two 
arguments and returns always a sequence.\\
{\bf Remark:} 
\begin{itemize}
\item In {\tt Xcas} mode, the precedence of {\tt \$} is not the same as
for example in {\tt Maple}, in case of doubt 
put the arguments of {\tt \$} in parenthesis.
For example, the equivalent of {\tt seq(j\verb|^|2,j=-1..3)} is
{\tt (j\verb|^|2)\$(j=-1..3)} and
returns {\tt (1,0,1,4,9)}. 
The equivalent of {\tt seq(4,3)} is {\tt 4\$3} and returns 
{\tt (4,4,4)}.
\item
With {\tt Maple} syntax, {\tt j,a..b,p} is not valid.
To specify a step $p$ for the variation of 
$j$ from $a$ to $b$, use {\tt j=a..b,p} or use the {\tt TI} syntax
{\tt j,a,b,p} and get the sequence from the list with {\tt op(...)}.
\end{itemize}
In summary, the different way to build a sequence are :
\begin{itemize}
\item with {\tt Maple}-like {\bf syntax}  
\begin{enumerate}
\item {\tt seq} has two arguments 
either an expression depending of a parameter 
(for example $j$) and  $j=a..b$  where $a$ and  $b$ are  reals, 
or a constant expression and an integer $n$.\\ 
{\tt seq} returns the sequence where $j$ is replaced in the 
expression by $a$, $a+1$,...,$b$ if $b>a$ and by $a$, $a-1$,...,$b$ if $b<a$,
or {\tt seq} returns the sequence made by copying $n$ times the constant.
\item {\tt seq} has three arguments an expression depending of a parameter 
(for example $j$) and $j=a..b,p$ where $a$, $b$ are reals and $p$ is a 
real number.\\
{\tt seq} returns the sequence where $j$ is replaced in the 
expression by $a$, $a+p$,...,$b$ if $b>a$ and by $a$, $a-p$,...,$b$ 
if $b<a$.\\ 
Note that $j,a..b$ is also valid but $j,a..b,p$ is not valid. 
\end{enumerate}
\item {\tt TI} {\bf syntax}
\begin{enumerate}
\item {\tt seq} has four arguments an expression depending of a parameter (for 
example $j$), the name of the parameter (for example $j$), $a$ and  $b$ where
$a$ and  $b$ are reals.\\
{\tt seq} returns the list  where $j$ is replaced in the 
expression by $a$, $a+1$,...,$b$ if $b>a$ and by $a$, $a-1$,...,$b$ if $b<a$.
\item {\tt seq} has five arguments an expression depending of a parameter (for 
example $j$), the name of the parameter (for example $j$), $a$, $b$ and  $p$ 
where $a$, $b$ and  $p$ are reals.\\
{\tt seq} returns the list  where 
$j$ is substitued in the 
expression by $a$, $a+p$,...,$a+k*p$ ($a+k*p \leq b <a+(k+1)*p$ or 
$a+k*p \geq b> a+(k+1)*p$). 
By default, $p$=1 if $b>a$ and  $p$=-1  if $b<a$. 
%If the sign of $p$ is not correct, {\tt Xcas} corrects it !
\end{enumerate}
\end{itemize}
{\bf Note} that
in {\tt Maple} syntax, {\tt seq} takes no more than 3 arguments and
returns a sequence 
as in {\tt TI} syntax, {\tt seq} takes at least 4 arguments 
and returns a list.\\
Input to have a sequence with same elements :
\begin{center}{\tt seq(t,4)}\end{center}
Or : 
\begin{center}{\tt seq(t,k=1..4)}\end{center}
Or :
\begin{center}{\tt t\$4}\end{center} 
Output :
\begin{center}{\tt (t,t,t,t)}\end{center}
Input to have a sequence :
\begin{center}{\tt seq(j\verb|^|3,j=1..4)}\end{center}
Or : 
\begin{center}{\tt (j\verb|^|3)\$(j=1..4)}\end{center} 
Or :
\begin{center}{\tt seq(j\verb|^|3,j,1..4)}\end{center}
Output :
\begin{center}{\tt (1,4,9,16)}\end{center}
Input to have a sequence :
\begin{center}{\tt seq(j\verb|^|3,j=-1..4,2)}\end{center}
Output :
\begin{center}{\tt (1,1,9)}\end{center}
Or to have a list,\\
Input :
\begin{center}{\tt seq(j\verb|^|3,j,1,4)}\end{center}
Output :
\begin{center}{\tt [1,4,9,16]}\end{center}
Input :
\begin{center}{\tt seq(j\verb|^|3,j,0,5,2)}\end{center}
Output :
\begin{center}{\tt [0,8,64]}\end{center}
Input :
\begin{center}{\tt seq(j\verb|^|3,j,5,0,-2)}\end{center}
or
\begin{center}{\tt seq(j\verb|^|3,j,5,0,2)}\end{center}
Output :
\begin{center}{\tt [125,27,1]}\end{center}
Input :
\begin{center}{\tt seq(j\verb|^|3,j,1,3,0.5)}\end{center}
Output :
\begin{center}{\tt [1,3.375,8,15.625,27]}\end{center}
Input :
\begin{center}{\tt seq(j\verb|^|3,j,1,3,1/2)}\end{center}
Output :
\begin{center}{\tt [1,27/8,8,125/8,27]}\end{center}
{\bf Examples}
\begin{itemize}
\item Find the third derivative of $\ \ln(t)$, input:
\begin{center}{\tt diff(log(t),t\$3)}\end{center}
Output :
\begin{center}{\tt -((-(2*t))/t\verb|^|4)}\end{center}
\item Input :
\begin{center}{\tt l:=[[2,3],[5,1],[7,2]]}\end{center}
\begin{center}{\tt seq((l[k][0])\$(l[k][1]),k=0 .. size(l)-1)}\end{center}
Output :
\begin{center}{\tt 2,2,2,seq[5],7,7}\end{center}
then {\tt eval(ans())} returns:
\begin{center}{\tt 2,2,2,5,7,7}\end{center}
\item Input to transform a string into the list of its characters :
\begin{verbatim}
f(chn):={
 local l;
 l:=size(chn);
 return seq(chn[j],j,0,l-1);
}
\end{verbatim}
then input:
\begin{center}{\tt f("abracadabra")}\end{center}
Output :
\begin{center}{\tt
    ["a","b","r","a","c","a","d","a","b","r","a"]}\end{center}
\end{itemize}

\subsection{Transform a sequence into a list : {\tt [] nop}}\index{[]}\index{nop}
To transform a sequence into list, just put square brackets ({\tt []}) around
the sequence or use the command {\tt nop}.\\
Input :
\begin{center}{\tt [seq(j\verb|^|3,j=1..4)]}\end{center}
or :
\begin{center}{\tt seq(j\verb|^|3,j,1,4)}\end{center}
or :
\begin{center}{\tt [(j\verb|^|3)\$(j=1..4)]}\end{center} 
Output :
\begin{center}{\tt [1,4,9,16]}\end{center}
Input :
\begin{center}{\tt nop(1,4,9,16)}\end{center}
Output :
\begin{center}{\tt [1,4,9,16]}\end{center}

\subsection{The {\tt +} operator applied on sequences}\index{+}
The infixed operator {\tt +}, with two sequences as argument,
returns the total sum of the elements of the two sequences.\\
Note the difference with the lists, where 
the term by term sums of the elements of the two lists would
be returned.\\
Input :
\begin{center}{\tt (1,2,3,4,5,6)+(4,3,5)}\end{center}
Or :
\begin{center}{\tt '+'((1,2,3,4,5,6),(4,3,5))}\end{center}
Output :
\begin{center}{\tt 33}\end{center}
But input :
\begin{center}{\tt [1,2,3,4,5,6]+[4,3,5]}\end{center}
Output :
\begin{center}{\tt [5,5,8,4,5,6]}\end{center}
{\bf Warning}\\
When the operator {\tt +} is prefixed, it has to be quoted ({\tt '+'}).

\section{Sets}
\subsection{Definition : {\tt set[]}}\index{\%\{ \%\}}\index{set[]}
To define a set of elements, put the elements separated by a comma, with 
{\tt \%\{ ... \%\}} or {\tt set[ ... ]} as delimiters.\\
Input :
\begin{center}
{\tt \%\{1,2,3,4\%\}}\\
{\tt set[1,2,3,4]}
\end{center}
In the {\tt Xcas} answers, the set delimiters are displayed
as $\llbracket$ and $\rrbracket$ in order
not to confuse sets with lists.
For example, $\llbracket$1,2,3$\rrbracket$ is the set {\tt \%\{1,2,3\%\}}, 
unlike [1,2,3] (normal brackets) which is the list {\tt [1,2,3]}.\\
Input :
\begin{center}{\tt A:=\%\{1,2,3,4\%\}} or {\tt A:=set[1,2,3,4]}\end{center}
Output :
\begin{center}{\tt $\llbracket$1,2,3,4$\rrbracket$  }\end{center}
Input :
\begin{center}{\tt B:=\%\{5,5,6,3,4\%\}} or {\tt B:=set[5,5,6,3,4]}\end{center}
Output :
\begin{center}{\tt  $\llbracket$5,6,3,4$\rrbracket$ }\end{center}
{\bf Remark}\\
The order in a set is not significant and 
the elements in a set are all distincts. If you input
{\tt B:=\%\{5,5,6,3,4\%\}} and  {\tt C:=\%\{3,4,5,3,6\%\}}, then 
{\tt B==C} will return  {\tt 1}.

\subsection{Union of two sets or of two lists : {\tt union}}\index{union}
\noindent{\tt union} is an infixed operator.\\
{\tt union} takes as argument two sets or two lists
{\tt union}  returns the union set of the arguments.\\
Input : 
\begin{center}{\tt set[1,2,3,4] union set[5,6,3,4]}\end{center}
Or : 
\begin{center}{\tt \%\{1,2,3,4\%\} union \%\{5,6,3,4\%\}}\end{center}
Output :
\begin{center}{\tt $\llbracket$1,2,3,4,5,6$\rrbracket$}\end{center}
Input : 
\begin{center}{\tt [1,2,3] union [2,5,6]}\end{center}
Output :
\begin{center}{\tt $\llbracket$1,2,3,5,6$\rrbracket$}\end{center}

\subsection{Intersection of two sets or of two lists : {\tt intersect}}\index{intersect}
\noindent {\tt intersect} is an infixed operator.\\
{\tt intersect} takes as argument two sets or two lists.\\
{\tt intersect} returns the intersection set of the arguments.\\
Input :
\begin{center}{\tt set[1,2,3,4] intersect set[5,6,3,4]}\end{center}
Or :
\begin{center}{\tt \%\{1,2,3,4\%\} intersect \%\{5,6,3,4\%\}}\end{center}
Output :
\begin{center}{\tt $\llbracket$3,4$\rrbracket$}\end{center}
Input :
\begin{center}{\tt [1,2,3,4] intersect [5,6,3,4]}\end{center}
Output :
\begin{center}{\tt $\llbracket$3,4$\rrbracket$}\end{center}

\subsection{Difference of two sets or of two lists : {\tt minus}}\index{minus}
\noindent{\tt minus} is an infixed operator.\\
{\tt minus}  takes as argument two sets or two lists.\\
{\tt minus} returns the difference set of the arguments.\\
Input :
\begin{center}{\tt set[1,2,3,4] minus set[5,6,3,4]}\end{center}
Or :
\begin{center}{\tt \%\{1,2,3,4\%\} minus \%\{5,6,3,4\%\}}\end{center}
Output :
\begin{center}{\tt $\llbracket$1,2$\rrbracket$}\end{center}
Input :
\begin{center}{\tt [1,2,3,4] minus [5,6,3,4]}\end{center}
Output :
\begin{center}{\tt $\llbracket$1,2$\rrbracket$}\end{center}

\section{Lists and vectors}\index{[]|textbf}
\subsection{Definition}
A list (or a vector) is delimited by {\tt [ ]},
it's elements must be separated by a comma. 
For example {\tt [1,2,5]} is a list of three integers.

Lists can contain lists (for example, a matrice is a list of lists 
of the same size). Lists may be used to represent vectors
(list of coordinates), matrices, univariate polynomials 
(list of coefficients by decreasing order). 

Lists are different from sequences, because sequences are flat : an element 
of a sequence cannot be a sequence.
Lists are different from sets, because for a list, the order is
important and the same element can be repeted in a list (unlike in
a set where each element is unique). 

In {\tt Xcas} answers :
\begin{itemize}
\item vector (or lists) delimiters are displayed as {\tt []}, 
\item matrix delimiters are displayed as {\bf []},
\item polynomial delimiters are displayed as $\talloblong \ \talloblong$,
\item set delimiters are displayed as $\llbracket \ \rrbracket$.
\end{itemize}

The list elements are indexed starting from 0 in Xcas syntax mode
and from 1 in all other syntax mode.


\subsection{Get an element or a sub-list of a list : {\tt at []}}\index{at|textbf}\label{sec:at}
\subsubsection{Get an element}
\noindent The $n$-th element of a list {\tt l} of size $s$
is addressed by {\tt l[n]} where $n$ is in $[0..s-1]$ or $[1..s]$.
The equivalent prefixed function is
{\tt at}, which takes as argument a list and an integer {\tt n}.\\
{\tt at} returns the element of the list of index {\tt n}.\\
Input :
\begin{center}{\tt [0,1,2][1]}\end{center}
or
\begin{center}{\tt at([0,1,2],1)}\end{center}
Output :
\begin{center}{\tt  1}\end{center}

\subsubsection{Extract a sub-list}
If $l$ is a list of size $s$, {\tt l[n1..n2]} returns the list
extracted from {\tt l} containing the elements of indices $n_1$ to $n_2$
where $0 \leq n_1\leq n_2 < s$ (in Xcas syntax mode) or
$0 < n_1\leq n_2 \leq s$ in other syntax modes.
The equivalent prefixed function is
{\tt at} with a list and an interval of integers ({\tt n1..n2}) 
as arguments.\\
{\bf See also} : {\tt mid}, section \ref{sec:mid}.\\
Input :
\begin{center}{\tt [0,1,2,3,4][1..3]}\end{center}
or
\begin{center}{\tt at([0,1,2,3,4],1..3)}\end{center}
Output :
\begin{center}{\tt  [1,2,3]}\end{center}
{\bf Warning}\\
{\tt at} can not be used for sequences, index notation
must be used, like in {\tt (0,1,2,3,4,5)[2..3]}. 


\subsection{Extract a sub-list : {\tt mid}}\index{mid}\label{sec:mid}
{\bf See also :} {\tt at} section \ref{sec:at}.\\
\noindent{\tt mid} is used to extract a sub-list of a list\index{mid}.\\
{\tt mid} takes as argument a list, the index of the begining of the 
sub-list and the length of the sub-list.\\
{\tt mid} returns the sub-list.\\
Input :
\begin{center}{\tt mid([0,1,2,3,4,5],2,3)}\end{center}
Output :
\begin{center}{\tt  [1,2,3]}\end{center}
{\bf Warning}\\
{\tt mid} can not be used to extract a subsequence of a sequence,
because the arguments of {\tt mid} would be merged with the sequence.
Index notation must be used, like e.g.{\tt (0,1,2,3,4,5)[2..3]}. 

\subsection{Get the first element of a list : {\tt head}}\index{head}
\noindent{\tt head} takes as argument a list.\\
{\tt head} returns the first element of this list.\\
Input :
\begin{center}{\tt head([0,1,2,3])}\end{center}
Output :
\begin{center}{\tt  0}\end{center}
{\tt a:=head([0,1,2,3])} does the same thing than {\tt a:=[0,1,2,3][0]}

\subsection{Remove an element in a list : {\tt suppress}}\index{suppress}
\noindent{\tt suppress} takes as argument a list and an integer {\tt n}.\\
{\tt suppress} returns the list where the element of index {\tt n} is 
removed.\\
Input :
\begin{center}{\tt suppress([3,4,2],1)}\end{center}
Output :
\begin{center}{\tt  [3,2]}\end{center}

\subsection{Remove the first  element : {\tt tail}}\index{tail}
\noindent{\tt tail} takes as argument a list.
{\tt tail} returns the list without it's first element.\\
Input :
\begin{center}{\tt tail([0,1,2,3])}\end{center}
Output :
\begin{center}{\tt  [1,2,3]}\end{center}
{\tt l:=tail([0,1,2,3])} does the same thing as
{\tt l:=suppress([0,1,2,3],0)}\\

\subsection{Reverse order in a list : {\tt revlist}}\index{revlist}
\noindent{\tt revlist} takes as argument a list (resp sequence).\\
{\tt revlist} returns the list (resp sequence) in the reverse order.\\
Input :
\begin{center}{\tt revlist([0,1,2,3,4])}\end{center}
Output :
\begin{center}{\tt  [4,3,2,1,0]}\end{center}
Input :
\begin{center}{\tt revlist([0,1,2,3,4],3)}\end{center}
Output :
\begin{center}{\tt 3,[0,1,2,3,4]}\end{center}

\subsection{Reverse a list starting from its n-th element : {\tt rotate}}\index{rotate}
\noindent{\tt rotate} takes as argument a list and an integer {\tt n} (by 
default {\tt n=-1}).\\
{\tt rotate} rotates the list by {\tt n} places to the left if {\tt n>0}
or to the right if {\tt n<0}. Elements leaving the list from one
side come back on the other side.
By default {\tt n=-1} and the last element becomes first.\\
Input :
\begin{center}{\tt rotate([0,1,2,3,4])}\end{center}
Output :
\begin{center}{\tt  [4,0,1,2,3]}\end{center}
Input :
\begin{center}{\tt rotate([0,1,2,3,4],2)}\end{center}
Output :
\begin{center}{\tt  [2,3,4,0,1]}\end{center}
Input :
\begin{center}{\tt rotate([0,1,2,3,4],-2)}\end{center}
Output :
\begin{center}{\tt  [3,4,0,1,2]}\end{center}

\subsection{Permuted list from its n-th element : {\tt shift}}\index{shift}
\noindent{\tt shift} takes as argument a list {\tt l} and an integer {\tt n}
(by default {\tt n}=-1).\\
{\tt shift} rotates the list to the left if {\tt n>0} or to
the right if {\tt n<0}. Elements leaving the list from one side
are replaced by {\tt undef} on the other side.\\
Input :
\begin{center}{\tt shift([0,1,2,3,4])}\end{center}
Output :
\begin{center}{\tt  [undef,0,1,2,3]}\end{center}
Input :
\begin{center}{\tt shift([0,1,2,3,4],2)}\end{center}
Output :
\begin{center}{\tt  [2,3,4,undef,undef]}\end{center}
Input :
\begin{center}{\tt shift([0,1,2,3,4],-2)}\end{center}
Output :
\begin{center}{\tt  [undef,undef,0,1,2]}\end{center}

\subsection{Modify an element in a list : {\tt subsop}}\index{subsop}
\noindent {\tt subsop} modifies an element in a list.
%? directly (it is not necessary to store this element in a variable).\\
{\tt subsop} takes as argument a list and an equality (an index=a new
value) in all syntax modes, but in {\tt Maple} syntax mode
the order of the arguments is reversed. \\ 
{\bf Remark} If the second argument is {\tt 'k=NULL'}, the element of index 
{\tt k} is removed of the list.\\
Input in {\tt Xcas} mode (the index of the first element is 0) :
\begin{center}{\tt subsop([0,1,2],1=5)}\end{center}
Or :
\begin{center}{\tt L:=[0,1,2];L[1]:=5}\end{center}
Output :
\begin{center}{\tt [0,5,2]}\end{center}
Input in {\tt Xcas} mode (the index of the first element is 0) :
\begin{center}{\tt subsop([0,1,2],'1=NULL')}\end{center}
Output :
\begin{center}{\tt [0,2]}\end{center}

Input in {\tt Mupad TI} mode  (the index of the first element is 1) :
\begin{center}{\tt subsop([0,1,2],2=5)}\end{center}
Or :
\begin{center}{\tt L:=[0,1,2];L[2]:=5}\end{center}
Output :
\begin{center}{\tt [0,5,2]}\end{center}
In {\tt Maple} mode the arguments are permuted and  the index of
the first element is 1.\\
Input :
\begin{center}{\tt subsop(2=5,[0,1,2])}\end{center}
Or :
\begin{center}{\tt L:=[0,1,2];L[2]:=5}\end{center}
Output :
\begin{center}{\tt [0,5,2]}\end{center}

\subsection{Transform a list into a sequence : {\tt op makesuite}}\index{op}\index{makesuite}
\noindent{\tt op} or {\tt makesuite} takes as argument a list.\\
{\tt op} or {\tt makesuite} transforms this list into a sequence.
\label{sec:makesuiteop}\\
See \ref{sec:op} for other usages of {\tt op}.\\
Input :
\begin{center}{\tt op([0,1,2])}\end{center}
Or :
\begin{center}{\tt makesuite([0,1,2])}\end{center}
Output :
\begin{center}{\tt (0,1,2)}\end{center}

\subsection{Transform a sequence into a list : {\tt makevector []}}\index{makevector}\index{[]}
Square brackets put around a sequence transform this sequence into a list 
or vector. The equivalent prefixed function is
{\tt makevector} which takes a sequence as argument.\\
{\tt makevector} transforms this sequence into a list or vector.\\
Input :
\begin{center}{\tt makevector(0,1,2)}\end{center}
Output :
\begin{center}{\tt [0,1,2]}\end{center}
Input :
\begin{center}{\tt a:=(0,1,2)}\end{center}
Input :
\begin{center}{\tt [a]}\end{center}
Or :
\begin{center}{\tt makevector(a)}\end{center}
Output :
\begin{center}{\tt [0,1,2]}\end{center}

\subsection{Length of a list : {\tt size nops length}}\index{size}\index{nops}\index{length}
\noindent{\tt size} or {\tt nops} or {\tt length} takes as argument a list 
(resp sequence).\\
{\tt size} or {\tt nops} or {\tt length} returns the length of this list (resp 
 sequence).\\
Input :
\begin{center}{\tt nops([3,4,2])}\end{center}
ou
\begin{center}{\tt size([3,4,2])}\end{center}
ou
\begin{center}{\tt length([3,4,2])}\end{center}
Output :
\begin{center}{\tt  3}\end{center}

\subsection{Sizes of a list of lists : {\tt sizes}}\index{sizes}
\noindent {\tt sizes} takes as argument a list of lists.\\
{\tt sizes} returns the list of the lengths of these lists.\\
Input :
\begin{center}{\tt sizes([[3,4],[2]])}\end{center}
Output :
\begin{center}{\tt [2,1]}\end{center}

\subsection{Concatenate two lists or a list and an element : {\tt concat augment}}\index{concat|textbf}\index{augment|textbf}
\noindent{\tt concat} (or {\tt augment}) takes as argument a list and an 
element or two lists.\\
{\tt concat} (or {\tt augment}) concats this list and this element, or concats 
these two lists.\\
Input :
\begin{center}{\tt concat([3,4,2],[1,2,4])}\end{center}
Or :
\begin{center}{\tt augment([3,4,2],[1,2,4])}\end{center}
Output :
\begin{center}{\tt [3,4,2,1,2,4]}\end{center}
Input :
\begin{center}{\tt concat([3,4,2],5)}\end{center}
Or :
\begin{center}{\tt augment([3,4,2],5)}\end{center}
Output :
\begin{center}{\tt [3,4,2,5]}\end{center}
{\bf Warning}
If you input :
\begin{center}{\tt concat([[3,4,2]],[[1,2,4]]}\end{center}
or
\begin{center}{\tt augment([[3,4,2]],[[1,2,4]]}\end{center}
the output will be:
\begin{center}{\tt [[3,4,2,1,2,4]]}\end{center}

\subsection{Append an element at the end of a list : {\tt append}}\index{append}
\noindent{\tt append} takes as argument a list and an element.\\
{\tt append} puts this element at the end of this list.\\
Input :
\begin{center}{\tt append([3,4,2],1)}\end{center}
Output :
\begin{center}{\tt  [3,4,2,1]}\end{center}
Input :
\begin{center}{\tt append([1,2],[3,4])}\end{center}
Output :
\begin{center}{\tt [1,2,[3,4]]}\end{center}

\subsection{Prepend an element at the begining of a list : {\tt prepend}}\index{prepend}
\noindent{\tt prepend} takes as argument a list and an element.\\
{\tt prepend} puts this element at the begining of this list.\\
Input :
\begin{center}{\tt prepend([3,4,2],1)}\end{center}
Output :
\begin{center}{\tt  [1,3,4,2]}\end{center}
Input :
\begin{center}{\tt prepend([1,2],[3,4])}\end{center}
Output :
\begin{center}{\tt [[3,4],1,2]}\end{center}

\subsection{Sort : {\tt sort}}\index{sort}
\noindent{\tt sort} takes as argument a list or an expression.
\begin{itemize}
\item For a list,\\
{\tt sort} returns the list sorted in increasing order.\\
Input :
\begin{center}{\tt sort([3,4,2])}\end{center}
Output :
\begin{center}{\tt [2,3,4]}\end{center}

\item For an expression,\\
 {\tt sort} sorts and  collects terms in sums and products.\\
Input :  
\begin{center}{\tt sort(exp(2*ln(x))+x*y-x+y*x+2*x)}\end{center}
Output :
\begin{center}{\tt 2*x*y+exp(2*ln(x))+x}\end{center}  
Input :  
\begin{center}{\tt simplify(exp(2*ln(x))+x*y-x+y*x+2*x)}\end{center}
Output :
\begin{center}{\tt x\verb|^|2+2*x*y+x}\end{center}  
\end{itemize}
{\tt sort} accepts an optionnal second argument, which is a bivariate
function returning 0 or 1. If provided, this function
will be used to sort the list, for example
{\tt (x,y)->x>=y} may be used as second argument
to sort the list in decreasing order.
This may also be used to sort list of lists 
(that {\tt sort} with one argument does not know how to sort).\\
Input :
\begin{center}{\tt sort([3,4,2],(x,y)->x>=y)}\end{center}
Output :
\begin{center}{\tt [4,3,2]}\end{center}

\subsection{Sort a list by increasing order : {\tt SortA}}\index{SortA}
\noindent{\tt SortA} takes as argument a list.\\
{\tt SortA} returns this list sorted by increasing order.\\
Input :
\begin{center}{\tt SortA([3,4,2])}\end{center}
Output :
\begin{center}{\tt [2,3,4]}\end{center}
{\tt SortA} may have a matrix as argument and in this case, 
{\tt SortA} modifies the order of columns by sorting the first matrix
row by increasing order.\\
Input :
\begin{center}{\tt SortA([[3,4,2],[6,4,5]])}\end{center}
Output :
\begin{center}{\tt [[2,3,4],[5,6,4]]}\end{center}

\subsection{Sort a list by decreasing order : {\tt SortD}}\index{SortD}
\noindent{\tt SortD} takes a list as argument.\\
{\tt SortD} returns this list sorted by decreasing order.\\
Input :
\begin{center}{\tt SortD([3,4,2])}\end{center}
Output :
\begin{center}{\tt [2,3,4]}\end{center}
{\tt SortD} may have a matrix as argument and in this case, 
{\tt SortD} modifies the order of columns by sorting the first matrix
row by decreasing order.\\
Input :
\begin{center}{\tt SortD([[3,4,2],[6,4,5]])}\end{center}
Output :
\begin{center}{\tt [[4,3,2],[4,6,5]]}\end{center}

\subsection{Select the elements of a list : {\tt select}}\index{select}
\noindent{\tt select} takes as arguments : a boolean function {\tt f}
 and a list {\tt L}.\\
{\tt select} selects in the list {\tt L}, the elements {\tt c} such that
{\tt f(c)==true}.\\
Input :
\begin{center}{\tt select(x->(x>=2),[0,1,2,3,1,5])}\end{center}
Output :
\begin{center}{\tt  [2,3,5]}\end{center}

\subsection{Remove elements of a list : {\tt remove}}\index{remove}
\noindent{\tt remove} takes as argument : a  boolean function {\tt f} and 
a list {\tt L}.\\
{\tt remove} removes in the list {\tt L}, the elements {\tt c} such that 
{\tt f(c)==true}.\\
Input :
\begin{center}{\tt remove(x->(x>=2),[0,1,2,3,1,5])}\end{center}
Output :
\begin{center}{\tt  [0,1,1]}\end{center}
{\bf Remark} The same applies on strings, for example,
to remove all the "a" of a string:\\
Input :
\begin{center}{\tt ord("a")}\end{center}
Output :
\begin{center}{\tt  97}\end{center}
Input :
\begin{verbatim}
f(chn):={
  local l:=length(chn)-1;
  return remove(x->(ord(x)==97),seq(chn[k],k,0,l));
}
\end{verbatim}
Then, input :
\begin{center}{\tt f("abracadabra")}\end{center}
Output :
\begin{center}{\tt  ["b","r","c","d","b","r"]}\end{center}
To get a string, input :
\begin{center}{\tt  char(ord(["b","r","c","d","b","r"])}\end{center}
Output :
\begin{center}{\tt "brcdbr"}\end{center}

\subsection{Test if a value is in a list : {\tt member}}\index{member|textbf}
\noindent{\tt member} takes as argument a value {\tt c} and a list
(or a set) {\tt L}.\\
{\tt member} is a function that tests if {\tt c} is an element of the 
list {\tt L}.\\
{\tt member} returns {\tt 0} if {\tt c} is not in {\tt L}, or
a strictly positive integer which is 
1 plus the index of the first occurence of {\tt c} in {\tt L}.\\
Note the order of the arguments (required for compatibility reasons)\\
Input :
\begin{center}{\tt member(2,[0,1,2,3,4,2])}\end{center}
Output :
\begin{center}{\tt  3}\end{center}
Input :
\begin{center}{\tt member(2,\%\{0,1,2,3,4,2\%\})}\end{center}
Output :
\begin{center}{\tt  3}\end{center}

\subsection{Test if a value is in a list : {\tt contains}}\index{contains|textbf}
\noindent{\tt contains}  takes as argument a list (or a set) 
{\tt L} and a value {\tt c}.\\
{\tt contains} tests if {\tt c} is an element of the list {\tt L}.\\
 {\tt contains} returns {\tt 0} if {\tt c} is not in {\tt L}, 
or a strictly positive integer which is  
1+the index of the first occurence of {\tt c} in {\tt L}.\\
Input :
\begin{center}{\tt contains([0,1,2,3,4,2],2)}\end{center}
Output :
\begin{center}{\tt  3}\end{center}
Input :
\begin{center}{\tt contains(\%\{0,1,2,3,4,2\%\},2)}\end{center}
Output :
\begin{center}{\tt  3}\end{center}

\subsection{Sum of list (or matrix) elements 
transformed by a function : {\tt count}}\index{count|textbf}
\noindent{\tt count} takes as argument : a real function {\tt f} and a list 
{\tt l} of length {\tt n} (or a matrix {\tt A} of dimension {\tt p*q}).\\
{\tt count} applies the function to the list (or matrix) elements and returns 
their sum, i.e. :\\
{\tt count(f,l)} returns {\tt f(l[0])+f(l[1])+...+f(l[n-1])} or\\
{\tt count(f,A)} returns {\tt f(A[0,0])+....+f(A[p-1,q-1])}.\\
If {\tt f} is a boolean  function {\tt count} returns the number of elements 
of the list (or of the matrix) for which the boolean function is true.\\
Input :
\begin{center}{\tt count((x)->x,[2,12,45,3,7,78])}\end{center}
Output :
\begin{center}{\tt  147}\end{center}
because : 2+12+45+3+7+78=147.\\
Input :
\begin{center}{\tt count((x)->x<12,[2,12,45,3,7,78])}\end{center}
Output :
\begin{center}{\tt  3}\end{center}
Input :
\begin{center}{\tt count((x)->x==12,[2,12,45,3,7,78])}\end{center}
Output :
\begin{center}{\tt  1}\end{center}
Input :
\begin{center}{\tt count((x)->x>12,[2,12,45,3,7,78])}\end{center}
Output :
\begin{center}{\tt  2}\end{center}
Input :
\begin{center}{\tt count(x->x\verb|^|2,[3,5,1])}\end{center}
Output :
\begin{center}{\tt 35}\end{center}
Indeed $32+52+11=35$.\\
Input :
\begin{center}{\tt count(id,[3,5,1])}\end{center}
Output :
\begin{center}{\tt 9}\end{center}
Indeed, {\tt id} is the identity functions and  3+5+1=9.\\
Input :
\begin{center}{\tt count(1,[3,5,1])}\end{center}
Output :
\begin{center}{\tt 3}\end{center}
Indeed, {\tt 1} is the constant function equal to 1 and 1+1+1=3.

\subsection{Number of elements equal to a given value : {\tt count\_eq}}\index{count\_eq|textbf}
\noindent{\tt count\_eq} takes as argument : a real and a real list
(or matrix).\\
{\tt count\_eq} returns the number of elements of the list (or matrix)
which are equal to the first argument.\\
Input :
\begin{center}{\tt count\_eq(12,[2,12,45,3,7,78])}\end{center}
Output :
\begin{center}{\tt  1}\end{center}

\subsection{Number of elements smaller than a given value : {\tt count\_inf}}\index{count\_inf|textbf}
\noindent{\tt count\_inf} takes as argument : a real and a real list 
(or matrix).\\
{\tt count\_inf} returns the number of elements of the list (or matrix) which
are strictly inferior to the first argument.\\
Input :
\begin{center}{\tt count\_inf(12,[2,12,45,3,7,78])}\end{center}
Output :
\begin{center}{\tt  3}\end{center}

\subsection{Number of elements greater than a given value : {\tt count\_sup}}\index{count\_sup|textbf}
\noindent{\tt count\_sup} takes as argument : a real and a real list 
(or matrix).\\
{\tt count\_sup} returns the number of elements of the list 
(or matrix) which are strictly greater to the first argument.\\
Input :
\begin{center}{\tt count\_sup(12,[2,12,45,3,7,78])}\end{center}
Output :
\begin{center}{\tt  2}\end{center}

\subsection{Sum of elements of a list : {\tt sum add}}\index{sum}\index{add}
\noindent{\tt sum} or {\tt add} takes as argument a list {\tt l} (resp 
sequence) of reals.\\ 
{\tt sum} or {\tt add} returns the sum of the elements of {\tt l}.\\
Input :
\begin{center}{\tt sum(2,3,4,5,6)}\end{center}
Output :
\begin{center}{\tt 20}\end{center}

\subsection{Cumulated sum of the elements of a list : {\tt cumSum}}\index{cumSum|textbf}
\noindent{\tt cumSum} takes as argument a list {\tt l} (resp sequence) 
of numbers or of strings.\\
{\tt cumSum} returns the list (resp sequence) with same length as {\tt l} and
 with $k$-th element the sum (or concatenation) of the 
elements ${\tt l[0],..,l[k]}$.\\
Input :
\begin{center}{\tt cumSum(sqrt(2),3,4,5,6)}\end{center}
Output :
\begin{center}{\tt sqrt(2),3+sqrt(2),3+sqrt(2)+4,3+sqrt(2)+4+5,}\end{center}
\begin{center}{\tt 3+sqrt(2)+4+5+6}\end{center}
Input :
\begin{center}{\tt normal(cumSum(sqrt(2),3,4,5,6))}\end{center}
Output :
\begin{center}{\tt  sqrt(2),sqrt(2)+3,sqrt(2)+7,sqrt(2)+12,sqrt(2)+18}\end{center}Input :
\begin{center}{\tt cumSum(1.2,3,4.5,6)}\end{center}
Output :
\begin{center}{\tt  1.2,4.2,8.7,14.7}\end{center}
Input :
\begin{center}{\tt cumSum([0,1,2,3,4])}\end{center}
Output :
\begin{center}{\tt  [0,1,3,6,10]}\end{center}
Input :
\begin{center}{\tt cumSum("a","b","c","d")}\end{center}
Output :
\begin{center}{\tt  "a","ab","abc","abcd"}\end{center}
Input :
\begin{center}{\tt cumSum("a","ab","abc","abcd")}\end{center}
Output :
\begin{center}{\tt "a","aab","aababc","aababcabcd"}\end{center}

\subsection{Product : {\tt product mul}}\index{product|textbf}\index{mul|textbf}
See also \ref{sec:product}, \ref{sec:product1} and
\ref{sec:product2}).

\subsubsection{Product of values of an expression : {\tt product}}\label{sec:product0}
\noindent{\tt product(expr,var,a,b,p)} or {\tt mul(expr,var,a,b,p)} returns the
product of values of an expression {\tt ex} when the variable {\tt var} goes 
from {\tt a} to {\tt b} with a step {\tt p} (by default p=1) : this syntax is 
for compatiblity with Maple.\\
Input :
\begin{center}{\tt product(x\verb|^|2+1,x,1,4)}\end{center}
Or:
\begin{center}{\tt mul(x\verb|^|2+1,x,1,4)}\end{center}
Output :
\begin{center}{\tt 1700}\end{center}
Indeed $2*5*10*17=1700$\\
Input :
\begin{center}{\tt product(x\verb|^|2+1,x,1,5,2)}\end{center}
Or:
\begin{center}{\tt mul(x\verb|^|2+1,x,1,5,2)}\end{center}
Output :
\begin{center}{\tt 520}\end{center}
Indeed $2*10*26=520$

\subsubsection{Product of elements of a list : {\tt product}}
\noindent{\tt product} or {\tt mul} takes as argument a list {\tt l}
of reals (or floating numbers) or two lists of the same size (see 
also \ref{sec:product0}, \ref{sec:product1} and  \ref{sec:product2}).
\begin{itemize}
\item if {\tt product} or {\tt mul} has a list {\tt l}
as argument, {\tt product} or 
{\tt mul} returns the product of the elements of {\tt l}\label{sec:product}.\\
Input :
\begin{center}{\tt product([2,3,4])}\end{center}
Input :
\begin{center}{\tt mul([2,3,4])}\end{center}
Output :
\begin{center}{\tt 24}\end{center}
Input :
\begin{center}{\tt product([[2,3,4],[5,6,7]])}\end{center}
Output :
\begin{center}{\tt [10,18,28]}\end{center}
\item if {\tt product}  or {\tt mul} takes as arguments 
{\tt l1} and {\tt l2}
(two lists or two matrices), {\tt product}  or {\tt mul} returns
the term by  term  product of the elements of {\tt l1} and 
{\tt l2}.\\
Input :
\begin{center}{\tt product([2,3,4],[5,6,7])}\end{center}
Or :
\begin{center}{\tt mul([2,3,4],[5,6,7])}\end{center}
Output :
\begin{center}{\tt [10,18,28]}\end{center}
Input :
\begin{center}{\tt product([[2,3,4],[5,6,7]],[[2,3,4],[5,6,7]])}\end{center}
Or :
\begin{center}{\tt mul([[2,3,4],[5,6,7]],[[2,3,4],[5,6,7]])}\end{center}
Output :
\begin{center}{\tt [[4,9,16],[25,36,49]]}\end{center}
\end{itemize}

\subsection{Apply a function of one variable to the elements of a list : {\tt map apply of}}\index{map}\index{apply}\index{of}
\noindent{\tt map} or  {\tt apply} or {\tt of} applies a function to a list
of elements.\\
{\tt of} is the prefixed function equivalent to the parenthesis  : 
{\tt Xcas} translates {\tt f(x)} internally to {\tt of(f,x)}. 
It is more natural to call {\tt map} 
or {\tt apply} than {\tt of}. Be carefull with the order of arguments
(that is required for compatibility reasons).\\
Note that {\tt apply} returns a list ({\tt []})
even if the second argument is not a list.\\
Input :
\begin{center}{\tt apply(x->x\verb|^|2,[3,5,1])}\end{center}
or
\begin{center}{\tt of(x->x\verb|^|2,[3,5,1])}\end{center}
or
\begin{center}{\tt map([3,5,1],x->x\verb|^|2)}\end{center}
or first define the function $h(x)=x2$, input :
\begin{center}{\tt h(x):=x\verb|^|2}\end{center}
then
\begin{center}{\tt apply(h,[3,5,1])}\end{center}
or
\begin{center}{\tt of(h,[3,5,1])}\end{center}
or
\begin{center}{\tt map([3,5,1],h)}\end{center}
Output :
\begin{center}{\tt   [9,25,1]}\end{center}
Next example, define the function $g(x)=[x,x2,x3]$, input :
\begin{center}{\tt g:=(x)->[x,x\verb|^|2,x\verb|^|3]}\end{center}
then
\begin{center}{\tt apply(g,[3,5,1])}\end{center}
or
\begin{center}{\tt of(g,[3,5,1])}\end{center}
or
\begin{center}{\tt map([3,5,1],g)}\end{center}
Output :
\begin{center}{\tt   [[3,9,27],[5,25,125],[1,1,1]]}\end{center}
{\bf Warning!!!} first purge {\tt x} if {\tt x} is not symbolic.\\
Note that if {\tt l1,l2,l3} are lists
{\tt sizes([l1,l2,l3])} is equivalent to {\tt map(size,[l1,l2,l3]}.

\subsection{Apply a bivariate function to the elements of two lists : {\tt zip}}\index{zip}
\noindent{\tt zip} applies a bivariate function to the elements of 2 lists.\\
Input :
\begin{center}{\tt zip('sum',[a,b,c,d],[1,2,3,4])}\end{center}
Output :
\begin{center}{\tt   [a+1,b+2,c+3,d+4]}\end{center}
Input :
\begin{center}{\tt zip((x,y)->x\verb|^|2+y\verb|^|2,[4,2,1],[3,5,1])}\end{center}
Or :
\begin{center}{\tt f:=(x,y)->x\verb|^|2+y\verb|^|2}\end{center}
then,
\begin{center}{\tt zip(f,[4,2,1],[3,5,1])}\end{center}
Output :
\begin{center}{\tt   [25,29,2]}\end{center}
Input :
\begin{center}{\tt f:=(x,y)->[x\verb|^|2+y\verb|^|2,x+y]}\end{center}
puis,
\begin{center}{\tt zip(f,[4,2,1],[3,5,1])}\end{center}
Output :
\begin{center}{\tt   [[25,7],[29,7],[2,2]]}\end{center}

\subsection{Make a list with zeros : {\tt newList}}\index{newList}
\noindent{\tt newList(n)} makes a list of {\tt n} zeros.\\
Input :
\begin{center}{\tt newList(3)}\end{center}
Output :
\begin{center}{\tt   [0,0,0]}\end{center}

\subsection{Make a list with a function : {\tt makelist}}\index{makelist}
\noindent{\tt makelist} takes as argument a function {\tt f}, 
the bounds {\tt a,b} of an index variable and a step {\tt s} 
(by default 1 or -1 depending on the bounds order).\\ 
{\tt makelist} makes the list {\tt [f(a),f(a+p)...f(a+k*p)]} with $k$ such
that~: $a<a+k*p \leq b <a+(k+1)*p$ or $a>a+k*p \geq b >a+(k+1)*p$.\\
Input :
\begin{center}{\tt makelist(x->x\verb|^|2,3,5)}\end{center}
or
\begin{center}{\tt makelist(x->x\verb|^|2,3,5,1)}\end{center}
or first define the function $h(x)=x2$ by {\tt h(x):=x\verb|^|2}
then input
\begin{center}{\tt makelist(h,3,5,1)}\end{center}
Output :
\begin{center}{\tt [9,16,25]}\end{center}
Input :
\begin{center}{\tt makelist(x->x\verb|^|2,3,6,2)}\end{center}
Output :
\begin{center}{\tt [9,25]}\end{center}
{\bf Warning!!!}  purge {\tt x} if {\tt x} is not symbolic.

\subsection{Make a random vector or list  : {\tt randvector}}\index{randvector}
\label{sec:ranm4}
\noindent{\tt randvector} takes as argument an integer $n$ and optionnally a 
second argument, either an integer $k$ or the quoted name of
a random distribution law
(see also \ref{sec:ranm1}, \ref{sec:ranm4} and \ref{sec:ranm3}).\\
{\tt randvector} returns a vector of size $n$ containing random integers 
uniformally distributed between -99 and +99 (default), or between 0 and $k-1$
or containing random 
integers according to the law put between quotes.\\
Input :
\begin{center}{\tt randvector(3)}\end{center}
Output :
\begin{center}{\tt [-54,78,-29]}\end{center}
Input :
\begin{center}{\tt randvector(3,5)}\end{center}
Or input :
\begin{center}{\tt randvector(3,'rand(5)')}\end{center}
Output :
\begin{center}{\tt [1,2,4]}\end{center}
Input :
\begin{center}{\tt randvector(3,'randnorm(0,1)')}\end{center}
Output :
\begin{center}{\tt [1.39091705476,-0.136794772167,0.187312440336]}\end{center}
Input :
\begin{center}{\tt randvector(3,2..4)}\end{center}
Output :
\begin{center}{\tt [3.92450003885,3.50059241243,2.7322040787]}\end{center}

\subsection{List of differences of consecutive terms  : {\tt deltalist}}\index{deltalist}
\noindent{\tt deltalist} takes as argument a list.\\
{\tt deltalist} returns the list of the difference of all 
pairs of consecutive terms of this list.\\
Input :
\begin{center}{\tt deltalist([5,8,1,9])}\end{center}
Output :
\begin{center}{\tt [3,-7,8]}\end{center}

\subsection{Make a matrix with a list : {\tt list2mat}}\index{list2mat}
\noindent{\tt list2mat} takes as argument a list {\tt l} and an integer 
{\tt p}.\\
{\tt list2mat} returns a matrix having {\tt p} column 
by cutting the list {\tt l} in rows of length {\tt p}. 
The matrix is filled with {\tt 0} if the size of {\tt l} is not
a multiple of {\tt p}.\\
Input :
\begin{center}{\tt list2mat([5,8,1,9,5,6],2)}\end{center}
Output :
\begin{center}{\tt  [[5,8],[1,9],[5,6]]}\end{center}
Input :
\begin{center}{\tt list2mat([5,8,1,9],3)}\end{center}
Output :
\begin{center}{\tt  [[5,8,1],[9,0,0]]}\end{center}
{\bf Remark} \\
{\tt Xcas} displays matrix with {\bf[} and  {\bf]} and lists with $[$ and  $]$ 
as delimiters (the vertical bar of the brackets are thicker for matrices). 

\subsection{Make a list with a matrix : {\tt mat2list}}\index{mat2list}
\noindent{\tt mat2list}\index{mat2list}  takes as argument a matrix.\\
{\tt mat2list} returns the list of the coefficients of this matrix.\\
Input :
\begin{center}{\tt mat2list([[5,8],[1,9]])}\end{center}
Output :
\begin{center}{\tt [5,8,1,9]}\end{center}

\section{Functions for vectors}
\subsection{Norms of a vector : {\tt maxnorm l1norm l2norm
norm}}\index{norm|textbf}
The instructions to compute the different norm of a vector are :
\begin{itemize}
\item{\tt maxnorm} returns the ${\mathnormal{l}}^\infty$ norm of a
vector, 
defined as the maximum of the absolute values of its 
coordinates\index{maxnorm|textbf}\label{sec:maxnormv}.\\
Input :
\begin{center}{\tt maxnorm([3,-4,2])}\end{center}
Output :
\begin{center}{\tt 4}\end{center}
Indeed : {\tt x=3, y=-4, z=2} and  {\tt 4=max(|x|,|y|,|z|)}.
\item{\tt l1norm}  returns the ${\tt {\mathnormal{l}}^1}$ norm of a 
vector defined as the sum of  the absolute values of its 
coordinates\index{l1norm}\label{sec:l1normv}.\\
Input :
\begin{center}{\tt l1norm([3,-4,2])}\end{center}
Output :
\begin{center}{\tt 9}\end{center}
Indeed : {\tt x=3, y=-4, z=2} and  {\tt 9=|x|+|y|+|z|}.
\item{\tt norm} or  {\tt l2norm}  returns the 
 ${\mathnormal{l}}^2$ norm of a vector defined as the square root 
of the sum of the squares of its 
coordinates\index{l2norm}\label{sec:l2normv}.\\
Input :
\begin{center}{\tt norm([3,-4,2])}\end{center}
Output :
\begin{center}{\tt sqrt(29)}\end{center}
Indeed : {\tt x=3, y=-4, z=2} and  $ 29=|x|^2+|y|^2+|z|^2$.
\end{itemize}

\subsection{Normalize a vector : {\tt normalize
unitV}}\index{normalize|textbf}\index{unitV|textbf}
\noindent {\tt normalize} or {\tt unitV} takes as argument a vector.\\
 {\tt normalize} or {\tt unitV}  normalizes this  vector for the 
${\mathnormal{l}}^2$ norm
(the square root of the sum of the squares of its coordinates).\\
Input :
\begin{center}{\tt normalize([3,4,5])}\end{center}
Output :
\begin{center}{\tt
[3/(5*sqrt(2)),4/(5*sqrt(2)),5/(5*sqrt(2))]}\end{center}
Indeed : {\tt x=3, y=4, z=5} and  $ 50=|x|^2+|y|^2+|z|^2$.

\subsection{Term by term sum of two lists : {\tt +
.+}}\index{+|textbf}
\index{.+|textbf}
The infixed operator {\tt +} or {\tt .+} and the prefixed operator
 {\tt '+'} returns the term by term sum of two lists.\\
If the two lists do not have the same size, the smallest list is
completed with
zeros.\\
Note the difference with sequences : if the infixed operator {\tt +}
or the 
prefixed operator {\tt '+'} takes as arguments two sequences, it
merges the sequences, hence return the 
sum of all the terms of the two sequences.\\
Input :
\begin{center}{\tt [1,2,3]+[4,3,5]}\end{center}
Or :
\begin{center}{\tt [1,2,3] .+[4,3,5]}\end{center}
Or :
\begin{center}{\tt '+'([1,2,3],[4,3,5])}\end{center}
Or :
\begin{center}{\tt '+'([[1,2,3],[4,3,5]])}\end{center}
Output :
\begin{center}{\tt [5,5,8]}\end{center}
Input :
\begin{center}{\tt [1,2,3,4,5,6]+[4,3,5]}\end{center}
Or :
\begin{center}{\tt '+'([1,2,3,4,5,6],[4,3,5])}\end{center}
Or :
\begin{center}{\tt '+'([[1,2,3,4,5,6],[4,3,5]])}\end{center}
Output :
\begin{center}{\tt [5,5,8,4,5,6]}\end{center}
{\bf Warning !}\\
When the operator {\tt +} is prefixed, it should be quoted ({\tt
'+'}).

\subsection{Term by term difference of two lists : {\tt -
.-}}\index{-|textbf}
\index{.-|textbf}
The infixed operator {\tt -} or {\tt .-} and  the prefixed operator 
{\tt '-'} returns the term by term difference of two lists.\\
If the two lists do not have the same size, the smallest list is
completed with
zeros.\\
Input :
\begin{center}{\tt [1,2,3]-[4,3,5]}\end{center}
Or :
\begin{center}{\tt [1,2,3] .+ [4,3,5]}\end{center}
Or :
\begin{center}{\tt '-'([1,2,3],[4,3,5])}\end{center}
Or :
\begin{center}{\tt '-'([[1,2,3],[4,3,5]])}\end{center}
Output :
\begin{center}{\tt [-3,-1,-2]}\end{center}
{\bf Warning !}\\
When the operator {\tt -} is prefixed, it should be quoted ({\tt
'-'}).

\subsection{Term by term product of two lists : {\tt
.*}}\index{.*|textbf}
The infixed operator {\tt .*} returns the term by term product of two
lists of 
the same size.\\
Input :
\begin{center}{\tt [1,2,3] .* [4,3,5]}\end{center}
Output :
\begin{center}{\tt [4,6,15]}\end{center}

\subsection{Term by term quotient of two lists : {\tt
./}}\index{./|textbf}
The infixed operator {\tt ./} returns the term by term quotient of two
lists 
of the same size.\\
Input :
\begin{center}{\tt [1,2,3] ./ [4,3,5]}\end{center}
Output :
\begin{center}{\tt [1/4,2/3,3/5]}\end{center}

\subsection{Scalar product  : {\tt scalar\_product * dotprod dot dotP
scalar\_Product}}\index{dot}\index{dotP}\index{dotprod}\index{scalar\_product}\index{*|textbf}\index{scalarProduct} 
{\tt dot} or {\tt dotP} or {\tt dotprod} or {\tt scalar\_product} or 
{\tt scalarProduct} or the infixed operator {\tt *} takes as argument 
two vectors.\\
{\tt dot} or {\tt dotP} or {\tt dotprod} or {\tt scalar\_product} or 
{\tt scalarProduct} or {\tt *} returns the  scalar product of these
two 
vectors.\\
Input :
\begin{center}{\tt dot([1,2,3],[4,3,5])}\end{center}
or : 
\begin{center}{\tt scalar\_product([1,2,3],[4,3,5])}\end{center}
or :
\begin{center}{\tt [1,2,3]*[4,3,5]}\end{center}
or :
\begin{center}{\tt '*'([1,2,3],[4,3,5])}\end{center}
Output :
\begin{center}{\tt 25}\end{center}
Indeed {\tt 25=1*4+2*3+3*5}.

Note that {\tt *} may be used to find the product of two polynomials
represented as list of their coefficients, but to avoid ambiguity,
the polynomial lists must be {\tt poly1[...]}.

\subsection{Cross product : {\tt cross crossP
crossproduct}}\index{cross}\index{crossP}\index{crossproduct}
{\tt cross} or {\tt crossP} or {\tt crossproduct} takes as argument 
two vectors.\\
{\tt cross} or {\tt crossP} or {\tt crossproduct} returns the cross
product
of these two vectors.\\
Input :
\begin{center}{\tt cross([1,2,3],[4,3,2])}\end{center}
Output :
\begin{center}{\tt [-5,10,-5]}\end{center}
Indeed : 
$-5=2*2-3*3$, $ 10=-1*2+4*3$, $ -5=1*3-2*4$.
\section{Statistic functions : {\tt mean,variance,stddev, stddevp,median,quantile,quartiles,boxwhisker}}\index{mean} \index{stddev}\index{variance}\index{median}\index{stddevp}\index{quantile}\index{boxwhisker}\index{quartiles}\label{sec:statlist}
The functions described here may be used if the statistic serie 
is contained in a list. See also section \ref{sec:statmat} for matrices and  
chapter \ref{sec:stat} for weighted lists.
\begin{itemize}
\item{\tt mean} computes the arithmetic mean of a list\\
Input :
\begin{center}{\tt mean([3,4,2])}\end{center}
Output :
\begin{center}{\tt  3}\end{center}
Input :
\begin{center}{\tt mean([1,0,1])}\end{center}
Output 
\begin{center}{\tt  2/3}\end{center}
\item{\tt stddev} computes the standard deviation of a population,
if the argument is the population\\
Input :
\begin{center}{\tt stddev([3,4,2])}\end{center}
Output :
\begin{center}{\tt sqrt(2/3)}\end{center}
\item{\tt stddevp} computes an unbiaised estimate of
the standard deviation of the population,
if the argument is a sample. The following
relation holds:
\begin{center}
 {\tt stddevp(l)\verb|^|2=size(l)*stddev(l)\verb|^|2/(size(l)-1)}.
\end{center}
Input :
\begin{center}{\tt stddevp([3,4,2])}\end{center}
Output :
\begin{center}{\tt 1}\end{center}
\item{\tt variance} computes the variance of a list, that is
the square of {\tt stddevp}\\
Input :
\begin{center}{\tt variance([3,4,2])}\end{center}
Output :
\begin{center}{\tt 2/3}\end{center}
\item{\tt median} computes the median of  a list.\\
Input :
\begin{center}{\tt median([0,1,3,4,2,5,6])}\end{center}
Output :
\begin{center}{\tt 3.0}\end{center}
\item{\tt quantile} computes the deciles of a list given as first
argument, where the decile is the second argument.\\
Input :
\begin{center}{\tt quantile([0,1,3,4,2,5,6],0.25)}\end{center}
Output the first quartile :
\begin{center}{\tt [1.0]}\end{center}
Input :
\begin{center}{\tt quantile([0,1,3,4,2,5,6],0.5)}\end{center}
Output the median :
\begin{center}{\tt [3.0]}\end{center}
Input :
\begin{center}{\tt quantile([0,1,3,4,2,5,6],0.75)}\end{center}
Output the third quartile :
\begin{center}{\tt [4.0]}\end{center}
\item{\tt quartiles} computes the minimum, the first quartile, the 
median, the third quartile and the maximum of a list.\\
Input :
\begin{center}{\tt quartiles([0,1,3,4,2,5,6])}\end{center}
Output :
\begin{center}{\tt [[0.0],[1.0],[3.0],[4.0],[6.0]]}\end{center}
\item{\tt boxwhisker} draws the whisker box of a statistic serie
stored in a list.\\
Input :
\begin{center}{\tt  boxwhisker([0,1,3,4,2,5,6])}\end{center}
Output 
\begin{center}{\tt the graph of the whisker box of this statistic list}\end{center} 
\end{itemize}
{\bf Example}\\
Define the list {\tt A} by:
\begin{center}
{\tt A:=[0,1,2,3,4,5,6,7,8,9,10,11]}
\end{center}
Outputs :
\begin{enumerate}
\item {\tt 11/2} for {\tt mean(A)}
\item
{\tt sqrt(143/12)} for {\tt stddev(A)}
\item
{\tt 0} for {\tt min(A)}
\item
{\tt [1.0]} for {\tt quantile(A,0.1)}
\item
{\tt [2.0]} for {\tt quantile(A,0.25)}
\item
{\tt [5.0]} for {\tt median(A)} or for {\tt quantile(A,0.5)}
\item
{\tt [8.0]} for {\tt quantile(A,0.75)}
\item
{\tt [9.0]} for {\tt quantile(A,0.9)}
\item
{\tt 11} for {\tt max(A)}
\item
{\tt [[0.0],[2.0],[5.0],[8.0],[11.0]]} for {\tt quartiles(A)}
\end{enumerate}

\section{Table with string as index : {\tt table}}\index{table}
A table is an associative container (or map), it is used to store informations
associated to indexes which are much more general than integers,
like strings or sequences. It may be used for example to store
a table of phone numbers indexed by names.\\
In {\tt Xcas}, the indexes in a table may be any kind of {\tt Xcas}
objects. Access is done by a binary search algorithm, where the
sorting function first sorts by {\tt type} then uses an order for
each type (e.g. $<$ for numeric types, lexicographic order for
strings, etc.)\\
{\tt table} takes as argument a list or a sequence of equalities
{\tt index\_name=element\_value}.\\
{\tt table} returns this table.\\
Input :
\begin{center}{\tt T:=table(3=-10,"a"=10,"b"=20,"c"=30,"d"=40)}\end{center}
Input :
\begin{center}{\tt T["b"]}\end{center}
Output :
\begin{center}{\tt 20}\end{center}
Input :
\begin{center}{\tt T[3]}\end{center}
Output :
\begin{center}{\tt -10}\end{center}
{\bf Remark}\\
If you assign {\tt T[n]:= ...} where {\tt T} is a variable name 
and {\tt n} an integer
\begin{itemize}
\item if the variable name was assigned to a list or a sequence, then the 
$n$-th element of {\tt T} is modified,
\item if the variable name was not assigned, a table {\tt T}
is created with one entry (corresponding to the index $n$). Note
that after the assignation {\tt T} is not a list, despite the fact that $n$
was an integer.
\end{itemize}

\section{Usual matrix}
A matrix is represented by a list of lists, all having the same size.
In the {\tt Xcas} answers, the matrix delimiters are {\bf []} (bold brackets).
For example, {\bf [}1,2,3{\bf ]} is the matrix [[1,2,3]] with only one row, 
unlike [1,2,3] (normal brackets) which is the list [1,2,3].\\
In this document, the input notation ([[1,2,3]]) will be used for input
and output.

\subsection{Identity matrix : {\tt idn identity}}\index{idn}\index{identity}
\noindent{\tt idn} takes as argument an integer $n$ or a square matrix.\\
{\tt idn} returns the identity matrice of size $n$ or of the same size
as the matrix argument.\\
Input :
\begin{center}{\tt idn(2)}\end{center}
Output :
\begin{center}{\tt  [[1,0],[0,1]]}\end{center}
Input :
\begin{center}{\tt idn(3)}\end{center}
Output :
\begin{center}{\tt  [[1,0,0],[0,1,0],[0,0,1]]}\end{center}

\subsection{Zero matrix : {\tt newMat matrix}}\index{newMat}
\noindent{\tt newMat(n,p)} or {\tt matrix(n,p)}
takes as argument two integers.\\
{\tt newMat(n,p)} returns the zero matrix with {\tt n} rows and 
{\tt p} columns.\\
Input :
\begin{center}{\tt newMat(4,3)}\end{center}
Output :
\begin{center}{\tt[[0,0,0],[0,0,0],[0,0,0],[0,0,0]]}\end{center}

\subsection{Random matrix : {\tt ranm randMat randmatrix}}\index{ranm}\index{randMat}\index{randmatrix}\label{sec:ranm2}
\noindent{\tt ranm} or {\tt randMat} or {\tt randmatrix} takes as argument an 
integer $n$ or two integers $n,m$ and optionnally a third argument, either an 
integer $k$ or the quoted name of a random distribution law
(see also \ref{sec:ranm1}, \ref{sec:ranm4} and \ref{sec:ranm3}).\\
{\tt ranm} returns a vector of size $n$ or a matrix of size $n\times m$
 containing random integers uniformally distributed between -99 and +99 
(default), or between 0 and $k-1$ or  a matrix  of size $n\times m$
containing random integers according to the law put between quotes.\\
Input :
\begin{center}{\tt ranm(3)}\end{center}
Output :
\begin{center}{\tt [-54,78,-29]}\end{center}
Input :
\begin{center}{\tt ranm(2,4)}\end{center}
Output :
\begin{center}{\tt [[27,-29,37,-66],[-11,76,65,-33]]}\end{center}
Input :
\begin{center}{\tt ranm(2,4,3)}\end{center}
Or input :
\begin{center}{\tt ranm(2,4,'rand(3)')}\end{center}
Output :
\begin{center}{\tt [[0,1,1,0],[0,1,2,0]]}\end{center}
Input :
\begin{center}{\tt ranm(2,4,'randnorm(0,1)')}\end{center}
Output :
\begin{center}{\tt [[1.83785427742,0.793007112053,-0.978388964902,-1.88602023857], [-1.50900874199,-0.241173369698,0.311373795585,-0.532752431454]]}\end{center}
Input :
\begin{center}{\tt ranm(2,4,2..4)}\end{center}
Output :
\begin{center}{\tt [[2.00549363438,3.03381264955,2.06539073586,2.04844321217],
 [3.88383254968,3.28664474655,3.76909781061,2.39113253355]]}\end{center}


\subsection{Diagonal of a matrix or matrix of a diagonal : {\tt BlockDiagonal diag}}\index{diag}\index{BlockDiagonal}
\noindent{\tt diag} or {\tt BlockDiagonal} takes as argument a matrix $A$ or
a list $l$.\\
{\tt diag} returns the diagonal of $A$ or the diagonal matrix with the list
$l$ on the diagonal (and 0 elsewhere).\\
Input :
\begin{center}{\tt diag([[1,2],[3,4]])}\end{center}
Output :
\begin{center}{\tt  [1,4]}\end{center}
Input :
\begin{center}{\tt diag([1,4])}\end{center}
Output :
\begin{center}{\tt  [[1,0],[0,4]]}\end{center}

\subsection{Jordan bloc : {\tt JordanBlock}}\index{JordanBlock}
\noindent {\tt JordanBlock} takes as argument an expression $a$ and an integer 
$n$.\\
{\tt JordanBlock} returns a square matrix of size $n$ with $a$
on the  principal diagonal, 1 above this diagonal and 0 elsewhere.\\
Input :
\begin{center}{\tt JordanBlock(7,3)}\end{center}
Output :
\begin{center}{\tt [[7,1,0],[0,7,1],[0,0,7]]}\end{center}

\subsection{Hilbert matrix : {\tt hilbert}}\index{hilbert}
\noindent{\tt hilbert} takes as  argument an integer $n$.\\
{\tt hilbert} returns the Hilbert matrix.\\
 A Hilbert matrix is a square matrix of size $n$ whose elements 
$a_{j,k}$ are :
\[ a_{j,k}=\frac{1}{j+k+1}, \quad 0\leq j, 0 \leq k \]
Input :
\begin{center}{\tt hilbert(4)}\end{center}
Output :
\begin{center}{\tt [[1,1/2,1/3,1/4],[1/2,1/3,1/4,1/5],[1/3,1/4,1/5,1/6], [1/4,1/5,1/6,1/7]]}\end{center}

\subsection{Vandermonde matrix : {\tt vandermonde}}\index{vandermonde}
\noindent{\tt vandermonde} takes as argument a vector  whose  components are
denoted by $x_j$ for $j=0..n-1$.\\
{\tt vandermonde} returns the corresponding Vandermonde matrix
(the $k$-th row of the matrix is the vector whose components are
$x_i^{k}$ for $i=0..n-1$ and $k=0..n-1$).\\
{\bf Warning !}\\ 
The indices of the rows and columns begin at 0 with {\tt Xcas}.\\
Input :
\begin{center}{\tt vandermonde([a,2,3])}\end{center}
Output (if {\tt a} is symbolic else purge(a)) :
\begin{center}{\tt  [[1,1,1],[a,2,3],[a*a,4,9]]}\end{center}

\section{Arithmetic and matrix}
\subsection{Evaluate a matrix : {\tt evalm}}\index{evalm}
\noindent {\tt evalm} is used in {\tt Maple} to evaluate a matrix.  
In {\tt Xcas}, matrices are evaluated by default, the command 
{\tt evalm} is only available for compatibility, it is equivalent
to {\tt eval}.

\subsection{Addition and substraction of two matrices : {\tt + - .+ .-}}\index{+}\index{-}\index{.+}\index{.-}  
\noindent The infixed operator {\tt +} or {\tt .+} (resp {\tt -} or {\tt .-})
are used for the  addition (resp substraction) of two matrices.\\
Input :
\begin{center}{\tt [[1,2],[3,4]] + [[5,6],[7,8]]}\end{center}
Output :
\begin{center}{\tt [[6,8],[10,12]]}\end{center}
Input :
\begin{center}{\tt [[1,2],[3,4]] - [[5,6],[7,8]]}\end{center}
Output :
\begin{center}{\tt [[-4,-4],[-4,-4]]}\end{center}
{\bf Remark}\\
{\tt +} can be used as a prefixed operator, in that case 
{\tt +} must be quoted ({\tt '+'}).\\
Input :
\begin{center}{\tt '+'([[1,2],[3,4]],[[5,6],[7,8]],[[2,2],[3,3]])}\end{center}
Output :
\begin{center}{\tt [[8,10],[13,15]]}\end{center}

\subsection{Multiplication of two matrices : {\tt * \&*}}\index{*}\index{\&*}
\noindent The infixed operator {\tt *} (or {\tt \&*}) is used for the
multiplication of two matrices.\\
Input :
\begin{center}{\tt [[1,2],[3,4]] * [[5,6],[7,8]]}\end{center}
Or :
\begin{center}{\tt [[1,2],[3,4]] \&* [[5,6],[7,8]]}\end{center}
Output :
\begin{center}{\tt [[19,22],[43,50]]}\end{center}

\subsection{Addition of elements of a column of a matrix : {\tt sum}}\index{sum} 
\noindent {\tt sum} takes as argument a matrix $A$.\\
{\tt sum} returns the list whose elements are the sum of the elements of each 
column of the matrix $A$.\\
Input :
\begin{center}{\tt sum([[1,2],[3,4]])}\end{center}
Output :
\begin{center}{\tt [4,6]}\end{center}

\subsection{Cumulated sum of elements of each column of a matrix : {\tt cumSum}}\index{cumSum} 
\noindent {\tt cumSum} takes as argument a matrix $A$.\\
{\tt cumSum} returns the matrix whose columns are the cumulated sum of the
elements of the corresponding column of the matrix $A$.\\
Input :
\begin{center}{\tt cumSum([[1,2],[3,4],[5,6]])}\end{center}
Output :
\begin{center}{\tt [[1,2],[4,6],[9,12]]}\end{center}
since the  cumulated sum are : 1, 1+3=4, 1+3+5=9 and 2, 2+4=6, 2+4+6=12.

\subsection{Multiplication of elements of each column of a matrix : {\tt product}}\index{product}\label{sec:product1}
\noindent {\tt product} takes as argument a matrix $A$.\\
{\tt product} returns the list whose elements are the product of the elements 
of each column of the matrix  $A$ (see also \ref{sec:product} and 
\ref{sec:product2}).\\
Input :
\begin{center}{\tt product([[1,2],[3,4]])}\end{center}
Output :
\begin{center}{\tt [3,8]}\end{center}

\subsection{Power of a matrix :\ \^\  \ \&\^\ }\index{\^\ |textbf}\index{\&\^\ }
The infixed operator {\tt \verb|^|} (or {\tt \&\verb|^|}) is used to 
raise a matrix to an integral power.\\
Input :
\begin{center}{\tt [[1,2],[3,4]] \verb|^| 5}\end{center}
Or :
\begin{center}{\tt [[1,2],[3,4]] \&\verb|^| 5}\end{center}
Output :
\begin{center}{\tt [[1069,1558],[2337,3406]]}\end{center}

\subsection{Hadamard product : {\tt hadamard product}}\index{hadamard}\index{product}\label{sec:product2}
\noindent{\tt hadamard} (or {\tt product}) takes as arguments two matrices $A$ 
and  $B$ of the same size.\\
{\tt hadamard} (or {\tt product}) returns the matrix where each term is the 
term by term product of $A$ and  $B$.\\ 
Input :
\begin{center}{\tt hadamard([[1, 2],[3,4]],[[5, 6],[7, 8]])}\end{center}
Output :
\begin{center}{\tt [[5,12],[21,32]]}\end{center}
See also \ref{sec:product} and \ref{sec:product1} for {\tt product}.

\subsection{Hadamard product (infixed version): {\tt .*}}\index{.*}
\noindent{\tt .*} takes as arguments two matrices or two lists $A$ and  $B$ 
of the same size.\\
{\tt  .*} is an infixed operator that returns the matrix or the list 
where each term is the term by term product of the corresponding
terms of $A$ and  $B$.\\ 
Input :
\begin{center}{\tt [[1, 2],[3,4]] .* [[5, 6],[7, 8]]}\end{center}
Output :
\begin{center}{\tt [[5,12],[21,32]]}\end{center}
Input :
\begin{center}{\tt [1,2,3,4] .* [5,6,7,8]}\end{center}
Output :
\begin{center}{\tt [5,12,21,32]}\end{center}

\subsection{Hadamard division (infixed version): {\tt ./}}\index{./}
\noindent{\tt ./} takes as arguments two matrices or two lists $A$ and 
$B$ of the same size.\\
{\tt  ./} is an infixed operator that returns the matrix or the list 
where each term is the term by term division of the corresponding
terms of $A$ and  $B$.\\ 
Input :
\begin{center}{\tt [[1, 2],[3,4]] ./ [[5, 6],[7, 8]]}\end{center}
Output :
\begin{center}{\tt [[1/5,1/3],[3/7,1/2]]}\end{center}

\subsection{Hadamard power (infixed version): {\tt .\^\ }}\index{.\^\ }
\noindent{\tt .\verb|^|} takes as arguments a matrix or a list
$A$ and a real $b$.\\
{\tt  .\verb|^|}  is an infixed operator that returns the matrix 
or the list where each term is the corresponding
term of $A$ raised to the power $b$.\\ 
Input :
\begin{center}{\tt [[1, 2],[3,4]] .\verb|^| 2}\end{center}
Output :
\begin{center}{\tt [[1,4],[9,16]]}\end{center}

\subsection{Extracting element(s) of a matrix : {\tt [] at}}\index{at}
Recall that a matrix is a list of lists with same size.\\
Input : 
\begin{center}{\tt A:=[[3,4,5],[1,2,6]]}\end{center}
Output :
\begin{center}{\tt [[3,4,5],[1,2,6]]}\end{center} 
The prefixed function {\tt at} or the 
index notation {\tt [...]} is used to access 
to an element or a row or a column of a matrix:
\begin{itemize}
\item To extract an element, put the matrix and then, beetween square 
brackets put its row index, a comma, and its column index.
In {\tt Xcas} mode the first index is 0, in other modes the first
index is 1.\\
Input :
\begin{center}{\tt [[3,4,5],[1,2,6]][0,1]}\end{center}
or
\begin{center}{\tt A[0,1]}\end{center}
or
\begin{center}{\tt A[0][1]}\end{center}
or
\begin{center}{\tt at(A,[0,1])}\end{center}
Output :
\begin{center}{\tt 4}\end{center}

\item To extract a row of the matrix {\tt A}, 
put the matrix and then, beetween 
square brackets put the row index, input :
\begin{center}{\tt  [[3,4,5],[1,2,6]][0]}\end{center}
or
\begin{center}{\tt A[0]}\end{center}
or
\begin{center}{\tt at(A,0)}\end{center}
Output :
\begin{center}{\tt [3,4,2]}\end{center}

\item To extract a part of a row, put two arguments 
beetween the square brackets : 
the row index and an interval to design the selected columns.\\
Input :
\begin{center}{\tt A[1,0..2]}\end{center}
Output :
\begin{center}{\tt [1,2,6]}\end{center}
Input :
\begin{center}{\tt A[1,1..2]}\end{center}
Output :
\begin{center}{\tt [2,6]}\end{center}

\item To extract a column of the matrix {\tt A}, first tranpose
{\tt A} ({\tt transpose(A)}) then extract the row like above.\\
Input :
\begin{center}{\tt tran(A)[1]}\end{center}
or
\begin{center}{\tt at(tran(A),1)}\end{center}
Output :
\begin{center}{\tt [4,2]}\end{center}

\item  To extract a part of a column of the matrix {\tt A} 
as a list, put two arguments 
beetween the square brackets : an index interval to 
design the selected rows and the column index.\\
Input :
\begin{center}{\tt A[0..0,1]}\end{center}
Output :
\begin{center}{\tt [4]}\end{center}

This may be used to extract a full column, by specifying all the rows
as index interval.\\
Input :
\begin{center}{\tt A[0..1,1]}\end{center}
Output :
\begin{center}{\tt [4,2]}\end{center}

\item
To extract a sub-matrix of a matrix, put between the square brackets two 
intervals : one interval for the selected rows and one interval for the 
selected columns.\\
To definie the matrix {\tt A}, input :
\begin{center}{\tt A:=[[3,4,5],[1,2,6]]}\end{center}
Input :
\begin{center}{\tt A[0..1,1..2]}\end{center}
Output :
\begin{center}{\tt [[4,5],[2,6]]}\end{center}
Input :
\begin{center}{\tt A[0..1,1..1]}\end{center}
Output :
\begin{center}{\tt [[4],[2]]}\end{center}
{\bf Remark}
If the second interval is omitted, the sub-matrix is made with the consecutive 
rows given by the first interval.\\ 
Input :
\begin{center}{\tt A[1..1]}\end{center}
Output :
\begin{center}{\tt [[1,2,6]]}\end{center}
\end{itemize}

You may also assign an element of a matrix using the index notation,
if you assign with {\tt :=} a new copy of the matrix is created
and the element is modified, if you assign with {\tt =<},
the matrix is modified in place.

\subsection{Modify an element or a row of a matrix : {\tt subsop}}\index{subsop|textbf}
\noindent {\tt subsop} modifies an element or a row of a matrix.
It is used mainly for {\tt Maple} and {\tt MuPAD} compatibility.
Unlike {\tt :=} or {\tt =<},
it does not require to store the matrix in a variable.\\
{\tt subsop} takes two or three arguments,
{\bf these arguments are permuted} in {\tt Maple} mode.
\begin{enumerate}
\item Modify an element
\begin{itemize}
\item In {\tt Xcas} mode, the first index is 0\\
{\tt subsop} has two (resp three) arguments: a matrix {\tt A} and an 
equality {\tt [r,c]=v} (resp a matrix {\tt A}, a list of index {\tt [r,c]},
a value {\tt v}).\\ 
{\tt subsop} replaces the element {\tt A[r,c]} by {\tt v}.\\
Input in {\tt Xcas} mode :
\begin{center}{\tt subsop([[4,5],[2,6]],[1,0]=3)}\end{center}
Or :
\begin{center}{\tt subsop([[4,5],[2,6]],[1,0],3)}\end{center}
Output :
\begin{center}{\tt [[4,5],[3,6]]}\end{center}
{\bf Remark}\\
If the matrix is stored in a variable, for example 
{\tt A:=[[4,5],[2,6]]}, it is easier to input {\tt A[1,0]:=3}
which modifies {\tt A} into the matrix\\ {\tt [[4,5],[3,6]]}.

\item In {\tt Mupad, TI} mode, the first index is 1\\
{\tt subsop} has two (resp three) arguments: a matrix {\tt A} and an 
equality {\tt [r,c]=v} (resp a matrix {\tt A}, a list of index {\tt [r,c]},
a value {\tt v}).\\ 
{\tt subsop} replaces the element {\tt A[r,c]} by {\tt v}.\\
Input in {\tt Mupad, TI} mode :
\begin{center}{\tt subsop([[4,5],[2,6]],[2,1]=3)}\end{center}
Or :
\begin{center}{\tt subsop([[4,5],[2,6]],[2,1],3)}\end{center}
Output :
\begin{center}{\tt [[4,5],[3,6]]}\end{center}
{\bf Remark}\\
If the matrix is stored in a variable, for example 
{\tt A:=[[4,5],[2,6]]}, it is easier to input {\tt A[2,1]:=3} which
modifies {\tt A} into the matrix \\{\tt [[4,5],[3,6]]}.

\item In {\tt Maple} mode, 
the arguments are permuted and the first index is 1\\
{\tt subsop} has two arguments: an equality {\tt [r,c]=v} and a matrix 
{\tt A}.\\
{\tt subsop} replaces the element {\tt A[r,c]} by {\tt v}.\\
Input in {\tt Maple} mode
\begin{center}{\tt subsop([2,1]=3,[[4,5],[2,6]])}\end{center}
Output :
\begin{center}{\tt [[4,5],[3,6]]}\end{center}
{\bf Remark}\\
If the matrix is stored in a variable, for example 
{\tt A:=[[4,5],[2,6]]}, it is easier to input {\tt A[2,1]:=3} which
modifies {\tt A} into the matrix\\ {\tt [[4,5],[3,6]]}.
\end{itemize}

\item Modify a row
\begin{itemize}
\item in {\tt Xcas} mode, the first index is 0\\ 
{\tt subsop} takes two arguments : a matrix and an 
equality (the index of the row to be modified, the {\tt =} sign and the new 
row value).\\ 
Input in {\tt Xcas} mode  :
\begin{center}{\tt subsop([[4,5],[2,6]],1=[3,3])}\end{center}
Output :
\begin{center}{\tt [[4,5],[3,3]]}\end{center}
{\bf Remark}\\
If the matrix is stored in a variable, for example 
{\tt A:=[[4,5],[2,6]]}, is is easier to input {\tt A[1]:=[3,3]}
which modifies {\tt A} into the matrix\\ {\tt [[4,5],[3,3]]}.

\item In {\tt Mupad, TI} mode, the first index is 1 \\
{\tt subsop} takes two arguments : a matrix and an 
equality (the index of the row to be modified, the {\tt =} sign and  the new 
row value).\\ 
Input in {\tt Mupad, TI} mode :
\begin{center}{\tt subsop([[4,5],[2,6]],2=[3,3])}\end{center}
Output :
\begin{center}{\tt [[4,5],[3,3]]}\end{center}
{\bf Remark}\\
If the matrix is stored in a variable, for example 
{\tt A:=[[4,5],[2,6]]}, it is easier to input {\tt A[2]:=[3,3]} which modifies
{\tt A} into the matrix\\ {\tt [[4,5],[3,3]]}.

\item  in {\tt Maple} mode, the arguments are permuted and the first index
is 1 :\\ 
{\tt subsop} takes two arguments : an 
equality (the index of the row to be modified, the {\tt =} sign and the new 
row value) and a matrix.\\ 
Input in {\tt Maple} mode :
\begin{center}{\tt subsop(2=[3,3],[[4,5],[2,6]])}\end{center}
Output :
\begin{center}{\tt [[4,5],[3,3]]}\end{center}
{\bf Remark}\\
If the matrix is stored in a variable, for example 
{\tt A:=[[4,5],[2,6]]}, it is easier to input {\tt A[2]:=[3,3]} which modifies
{\tt A} into the matrix\\ {\tt [[4,5],[3,3]]}.
\end{itemize}
\end{enumerate}
{\bf Remark}\\
Note also that {\tt subsop} with a {\tt 'n=NULL'} argument 
deletes row number {\tt n}.
In {\tt Xcas} mode input :
\begin{center}{\tt subsop([[4,5],[2,6]],'1=NULL')}\end{center}
Output :
\begin{center}{\tt [[4,5]]}\end{center}

\subsection{Extract rows or columns of a matrix (Maple compatibility) : {\tt row col}}\index{row}\index{col}
\noindent{\tt row} (resp {\tt col}) extract one or several rows (resp columns) 
of a matrix.\\
{\tt row} (resp {\tt col}) takes 2 arguments : a matrix $A$, and an integer $n$
or an interval $n_1..n_2$.\\
{\tt row} (resp {\tt col}) returns the row (resp column) of index $n$ of $A$, 
or the sequence of rows (resp columns) of index from $n_1$ to $n_2$ of $A$.\\
Input :
\begin{center}{\tt row([[1,2,3],[4,5,6],[7,8,9]],1)}\end{center}
Output :
\begin{center}{\tt [4,5,6]}\end{center}
Input :
\begin{center}{\tt row([[1,2,3],[4,5,6],[7,8,9]],0..1)}\end{center}
Output :
\begin{center}{\tt ([1,2,3],[4,5,6])}\end{center}
Input :
\begin{center}{\tt  col([[1,2,3],[4,5,6],[7,8,9]],1)}\end{center}
Output :
\begin{center}{\tt [2,5,8]}\end{center}
Input :
\begin{center}{\tt  col([[1,2,3],[4,5,6],[7,8,9]],0..1)}\end{center}
Output :
\begin{center}{\tt ([1,4,7,[2,5,8])}\end{center}

\subsection{Remove rows or columns of a matrix : {\tt delrows delcols}}\index{delrows}\index{delcols}
\noindent{\tt delrows} (resp {\tt delcols}) removes one or several rows (resp 
columns) of a matrix.\\
{\tt delrows} (resp {\tt delcols}) takes 2 arguments : a matrix $A$, and  
an interval $n_1..n_2$.\\
{\tt delrows} (resp {\tt delcols}) returns the matrix where the rows 
(resp columns) of index from $n_1$ to $n_2$ of $A$ are removed.\\
Input :
\begin{center}{\tt delrows([[1,2,3],[4,5,6],[7,8,9]],1..1)}\end{center}
Output :
\begin{center}{\tt [[1,2,3],[7,8,9]]}\end{center}
Input :
\begin{center}{\tt delrows([[1,2,3],[4,5,6],[7,8,9]],0..1)}\end{center}
Output :
\begin{center}{\tt [[7,8,9]]}\end{center}
Input :
\begin{center}{\tt delcols([[1,2,3],[4,5,6],[7,8,9]],1..1)}\end{center}
Output :
\begin{center}{\tt [[1,3],[4,6],[7,9]]}\end{center}
Input :
\begin{center}{\tt delcols([[1,2,3],[4,5,6],[7,8,9]],0..1)}\end{center}
Output :
\begin{center}{\tt [[3],[6],[9]]}\end{center}

\subsection{Extract a sub-matrix of a matrix (TI compatibility) : {\tt subMat}}\index{subMat}
\noindent{\tt subMat} takes 5 arguments : a matrix $A$, and 4 integers 
$nl1,nc1,nl2,nc2$, where
$nl1$ is the index of the first row, $nc1$ is
the index of the first column, $nl2$ is the index of
the last row and  $nc2$ is the index of the last column.\\    
{\tt subMat(A,nl1,nc1,nl2,nc2)} extract the sub-matrix of the matrix {\tt A}
with first element {\tt A[nl1,nc1]} and last element 
{\tt A[nl2,nc2]}.\\
Define the matrix {\tt A} :
\begin{center}{\tt A:=[[3,4,5],[1,2,6]]}\end{center}
Input :
\begin{center}{\tt subMat(A,0,1,1,2)}\end{center}
Output :
\begin{center}{\tt [[4,5],[2,6]]}\end{center}
Input :
\begin{center}{\tt subMat(A,0,1,1,1]}\end{center}
Output :
\begin{center}{\tt [[4],[2]]}\end{center}
By default $nl1=0$, $nc1=0$, $nl2$={\tt nrows(A)}-1 and 
$nc2$={\tt ncols(A)}-1\\
Input :
\begin{center}{\tt  subMat(A,1)}\end{center}
Or :
\begin{center}{\tt  subMat(A,1,0)}\end{center}
Or :
\begin{center}{\tt  subMat(A,1,0,1)}\end{center}
Or :
\begin{center}{\tt  subMat(A,1,0,1,2)}\end{center}
Output :
\begin{center}{\tt [[1,2,6]]}\end{center}

\subsection{Add a row to another row : {\tt rowAdd}}\index{rowAdd}
\noindent{\tt rowAdd} takes three arguments : a matrix $A$ and two integers 
$n1$ and $n2$.\\
{\tt rowAdd} returns the matrix obtained by replacing in $A$, the row of index
$n2$ by the sum of the rows of index $n1$ and $n2$.\\
Input :
\begin{center}{\tt rowAdd([[1,2],[3,4]],0,1)}\end{center}
Output :
\begin{center}{\tt  [[1,2],[4,6]]}\end{center}

\subsection{Multiply a row by an expression : {\tt mRow}}\index{mRow}
\noindent{\tt mRow} takes three arguments : an expression, a matrix $A$ and an 
integer $n$.\\
{\tt mRow} returns the matrix obtained by replacing in $A$, the row of index 
$n$ by the product of the row of index $n$ by the expression.\\
Input :
\begin{center}{\tt mRow(12,[[1,2],[3,4]],1)}\end{center}
Output :
\begin{center}{\tt [[1,2],[36,48]]}\end{center}

\subsection{Add $k$ times a row to an another row : {\tt mRowAdd}}\index{mRowAdd}
\noindent{\tt mRowAdd} takes four arguments : a real $k$, a matrix $A$ and two
integers $n1$ and $n2$.\\
{\tt mRowAdd} returns the matrix  obtained by replacing in $A$, the  
row of index $n2$ by the sum of the row of index $n2$ and $k$ times the row of 
index $n1$.\\
Input :
\begin{center}{\tt mRowAdd(1.1,[[5,7],[3,4],[1,2]],1,2)}\end{center}
Output :
\begin{center}{\tt [[5,7],[3,4],[4.3,6.4]]}\end{center}

\subsection{Exchange two rows : {\tt rowSwap}}\index{rowSwap}
\noindent{\tt rowSwap} takes three arguments : a matrix $A$ and two integers 
$n1$ and  $n2$.\\
{\tt rowSwap} returns the matrix obtained by exchanging in $A$, the row of 
index $n1$ with the row of index $n2$.\\
Input :
\begin{center}{\tt rowSwap([[1,2],[3,4]],0,1)}\end{center}
Output :
\begin{center}{\tt  [[3,4],[1,2]]}\end{center}

\subsection{Make a matrix with a list of matrix : {\tt blockmatrix}}\index{blockmatrix}
\noindent{\tt blockmatrix} takes as arguments two integers $n,m$ and a 
list of size  $n*m$ of matrices of the same dimension $p \times q$ 
(or more generally such that the $m$ first matrices 
have the same number of rows and $c$ columns, the 
$m$ next rows have the same number of rows and $c$ columns, and so on ...).
In both cases, we have $n$ blocks of $c$ columns.\\
{\tt  blockmatrix} returns a matrix having  $c$ columns 
by putting these $n$ blocks one under another (vertical gluing). 
If the matrix arguments
have the same dimension $p \times q$, the answer is a matrix of
dimension $p*n \times q*m$.\\
Input :
\begin{center}{\tt blockmatrix(2,3,[idn(2),idn(2),idn(2), idn(2),idn(2),idn(2)])}\end{center}
Output :
\begin{center}{\tt [[1,0,1,0,1,0],[0,1,0,1,0,1], [1,0,1,0,1,0],[0,1,0,1,0,1]]}\end{center}
Input :
\begin{center}{\tt blockmatrix(3,2,[idn(2),idn(2), idn(2),idn(2),idn(2),idn(2)])}\end{center}
Output :
\begin{center}{\tt [[1,0,1,0],[0,1,0,1], [1,0,1,0],[0,1,0,1],[1,0,1,0],[0,1,0,1]]}\end{center}
Input :
\begin{center}{\tt blockmatrix(2,2,[idn(2),newMat(2,3), newMat(3,2),idn(3)])}\end{center}
Output :
\begin{center}{\tt [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0], [0,0,0,1,0],[0,0,0,0,1]] }\end{center}
Input :
\begin{center}{\tt blockmatrix(3,2,[idn(1),newMat(1,4), newMat(2,3),idn(2),newMat(1,2),[[1,1,1]]])}\end{center}
Output :
\begin{center}{\tt [[1,0,0,0,0],[0,0,0,1,0],[0,0,0,0,1],[0,0,1,1,1]]}\end{center}
Input :
\begin{center}{\tt A:=[[1,1],[1,1]];B:=[[1],[1]]}\end{center}
then :
\begin{center}{\tt blockmatrix(2,3,[2*A,3*A,4*A,5*B,newMat(2,4),6*B])}\end{center}
Output :
\begin{center}{\tt [[2,2,3,3,4,4],[2,2,3,3,4,4], [5,0,0,0,0,6],[5,0,0,0,0,6]]}\end{center}

\subsection{Make a matrix from two matrices : {\tt semi\_augment}}\index{semi\_augment|textbf}
\noindent {\tt semi\_augment} concat two matrices with the same number 
of columns.\\
Input :
\begin{center}{\tt  semi\_augment([[3,4],[2,1],[0,1]],[[1,2],[4,5]])}\end{center}
Output :
\begin{center}{\tt [[3,4],[2,1],[0,1],[1,2],[4,5]]}\end{center}
Input :
\begin{center}{\tt semi\_augment([[3,4,2]],[[1,2,4]])}\end{center}
Output :
\begin{center}{\tt [[3,4,2],[1,2,4]]}\end{center}
Note the difference with {\tt concat}.\\
Input :
\begin{center}{\tt concat([[3,4,2]],[[1,2,4]]}\end{center}
Output :
\begin{center}{\tt [[3,4,2,1,2,4]]}\end{center}
Indeed, when the two matrix $A$ and  $B$ have the same dimension, {\tt concat} 
makes a matrix with the same number of rows than $A$ and $B$ by
gluing them side by side.\\
Input :
\begin{center}{\tt concat([[3,4],[2,1],[0,1]],[[1,2],[4,5]]}\end{center}
Output :
\begin{center}{\tt [[3,4],[2,1],[0,1],[1,2],[4,5]]}\end{center}
but :
\begin{center}{\tt concat([[3,4],[2,1]],[[1,2],[4,5]]}\end{center}
Output :
\begin{center}{\tt [[3,4,1,2],[2,1,4,5]]}\end{center}

\subsection{Make a  matrix from two matrices : {\tt augment concat}}\index{augment}\index{concat}
\noindent {\tt augment} or {\tt concat} concats two matrices $A$ and $B$ 
having the same number of rows, or having the same number of columns. 
In the first case, it returns a matrix having the same number of rows 
than $A$ and  $B$ by horizontal gluing, in the second case
it returns a matrix having the same number of columns by
vertical gluing.\\
Input :
\begin{center}{\tt  augment([[3,4,5],[2,1,0]],[[1,2],[4,5]])}\end{center}
Output :
\begin{center}{\tt [[3,4,5,1,2],[2,1,0,4,5]]}\end{center}
Input :
\begin{center}{\tt  augment([[3,4],[2,1],[0,1]],[[1,2],[4,5]])}\end{center}
Output :
\begin{center}{\tt [[3,4],[2,1],[0,1],[1,2],[4,5]]}\end{center}
Input :
\begin{center}{\tt augment([[3,4,2]],[[1,2,4]]}\end{center}
Output :
\begin{center}{\tt [[3,4,2,1,2,4]]}\end{center}
Note that if $A$ and $B$ have the same dimension, {\tt augment} 
makes a matrix with the same number of rows than $A$ and $B$ 
by horizontal gluing, in that case
you must use {\tt semi\_augment} for vertical gluing.\\
Input :
\begin{center}{\tt  augment([[3,4],[2,1]],[[1,2],[4,5]])}\end{center}
Output :
\begin{center}{\tt [[3,4,1,2],[2,1,4,5]]]}\end{center}

\subsection{Build a matrix with a function : {\tt makemat}}\index{makemat}
\noindent{\tt makemat} takes three arguments : 
\begin{itemize}
\item a function of two variables {\tt j} and {\tt k} which
should return the value of $a_{j,k}$, the element of
row index {\tt j} and column index {\tt k} of the matrix to be built.
\item two integers $n$ and $p$.
\end{itemize}
{\tt makemat} returns the matrix $A=(a_{j,k})$ 
($j=0..n-1$ and $k=0..p-1$) of dimension $n \times p$.\\
Input :
\begin{center}{\tt makemat((j,k)->j+k,4,3)}\end{center}
or first define the  $h$ function:
\begin{center}{\tt h(j,k):=j+k}\end{center}
then, input:
\begin{center}{\tt makemat(h,4,3)}\end{center}
Output :
\begin{center}{\tt [[0,1,2],[1,2,3],[2,3,4],[3,4,5]]}\end{center}
Note that the indices are counted starting from 0.

\subsection{Define a matrix : {\tt matrix}}\index{matrix}
\noindent{\tt matrix} takes three arguments :
\begin{itemize}
\item  two integers $n$ and $p$.  
\item  a function of two variables {\tt j} and {\tt k} which
should return the value of $a_{j,k}$, the element of
row index {\tt j} and column index {\tt k} of the matrix to be build.
\end{itemize}
{\tt matrix} returns the matrix $A=(a_{j,k})$ ($j=1..n$ and $k=1..p$) of 
dimension $n \times p$.\\
Input :
\begin{center}{\tt matrix(4,3,(j,k)->j+k)}\end{center}
or first define the $h$ function:
\begin{center} {\tt h(j,k):=j+k}\end{center}
then, input:
\begin{center}{\tt matrix(4,3,h)}\end{center}
Output :
\begin{center}{\tt [[2,3,4],[3,4,5],[4,5,6],[5,6,7]]}\end{center}
Note the argument order and the fact that the indices are counted
starting from 1. If the last argument is not provided, it defaults to 0.

\subsection{Append a column to a matrix : {\tt border}}\index{border}
\noindent{\tt border} takes as argument a matrix {\tt A} of dimension $p*q$
 and a list {\tt b} of size $p$ (i.e. {\tt nrows(A)=size(b)}).\\
{\tt border} returns the matrix obtained by appending 
{\tt tran(b)} as last column to the matrix {\tt A}, therefore:
\begin{center}
{\tt border(A,b)=tran([op(tran(A)),b])=tran(append(tran(A),b))}
\end{center}
Input :
\begin{center}{\tt border([[1,2,4],[3,4,5]],[6,7])}\end{center}
Output :
\begin{center}{\tt  [[1,2,4,6],[3,4,5,7]]}\end{center}
Input :
\begin{center}{\tt border([[1,2,3,4],[4,5,6,8],[7,8,9,10]],[1,3,5])}\end{center}
Output :
\begin{center}{\tt  [[1,2,3,4,1],[4,5,6,8,3],[7,8,9,10,5]]}\end{center}

\subsection{Count the elements of a matrix verifying a property : {\tt count}}\index{count}
\noindent{\tt count} takes as arguments : a real function {\tt f} and 
a real matrix {\tt A} of dimension {\tt p*q} (resp a list {\tt l} of size 
{\tt n}).\\
{\tt count} returns {\tt f(A[0,0])+..f(A[p-1,q-1])} (resp  
{\tt f(l[0])+..f(l[n-1])})\\
Hence, if {\tt f} is a boolean function, {\tt count} returns the number 
of elements of the matrix {\tt A} (resp the  list {\tt l}) verifying 
the property {\tt f}.\\
Input :
\begin{center}{\tt count(x->x,[[2,12],[45,3],[7,78]])}\end{center}
Output :
\begin{center}{\tt  147}\end{center}
indeed: 2+12+45+3+7+78=147.\\
Input :
\begin{center}{\tt count(x->x<10,[[2,12],[45,3],[7,78]])}\end{center}
Output :
\begin{center}{\tt  3}\end{center}

\subsection{Count the elements equal to a given value : {\tt count\_eq}}\index{count\_eq}
\noindent{\tt count\_eq} takes as arguments: a real and a real list or 
a real matrix.\\
{\tt count\_eq} returns the number of elements of the list or matrix
equal to the first argument.\\
Input :
\begin{center}{\tt count\_eq(12,[[2,12,45],[3,7,78]])}\end{center}
Output :
\begin{center}{\tt  1}\end{center}

\subsection{Count the elements smaller than a given value : {\tt count\_inf}}\index{count\_inf}
\noindent{\tt count\_inf} takes as arguments: a real and a real list or a real
matrix.\\
{\tt count\_inf} returns the number of elements of the list or
matrix which are strictly inferior to the first argument.\\
Input :
\begin{center}{\tt count\_inf(12,[2,12,45,3,7,78])}\end{center}
Output :
\begin{center}{\tt  3}\end{center}

\subsection{Count the elements greater than a given value : {\tt count\_sup}}\index{count\_sup}
\noindent{\tt count\_sup} takes as arguments: a real and a real list or a real
 matrix.\\
{\tt count\_sup} returns the number of elements of the list or matrix
which are strictly greater to the first argument.\\
Input :
\begin{center}{\tt count\_sup(12,[[2,12,45],[3,7,78]])}\end{center}
Output :
\begin{center}{\tt  2}\end{center}

\subsection{Statistics functions acting on column matrices : {\tt mean}, {\tt stddev}, {\tt variance}, {\tt median}, {\tt quantile}, {\tt quartiles}, {\tt boxwhisker}}\label{sec:statmat}
\index{mean} \index{stddev}\index{variance}\index{median}\index{quartiles}\index{quantile}\index{boxwhisker}
The following functions work on matrices, acting column by column:
\begin{itemize}
\item{\tt mean} computes the arithmetic means of the statistical series
stored in the columns of a matrix.\\ 
Input :
\begin{center}{\tt mean([[3,4,2],[1,2,6]])}\end{center}
Output is the vector of the means of each column :
\begin{center}{\tt  [2,3,4]}\end{center}
Input :
\begin{center}{\tt mean([[1,0,0],[0,1,0],[0,0,1]])}\end{center}
Output 
\begin{center}{\tt [1/3,1/3,1/3]}\end{center}

\item{\tt stddev} computes the standard deviations of the population
statistical series stored in the columns of a matrix.\\  
Input :
\begin{center}{\tt stddev([[3,4,2],[1,2,6]])}\end{center}
Output is the vector of the standard deviations of each column :
\begin{center}{\tt [1,1,2]}\end{center}
\item{\tt variance} computes the variances of the statistical series
stored in the columns of a matrix.\\ 
Input :
\begin{center}{\tt variance([[3,4,2],[1,2,6]])}\end{center}
Output is the vector of the variance of each column :
\begin{center}{\tt [1,1,4]}\end{center}

\item{\tt median} computes the medians of the statistical series
stored in the columns of a matrix.\\ 
Input :
\begin{center}{\tt median([[6,0,1,3,4,2,5],[0,1,3,4,2,5,6],[1,3,4,2,5,6,0], [3,4,2,5,6,0,1],[4,2,5,6,0,1,3],[2,5,6,0,1,3,4]])}\end{center}
Output is the vector of the median of each column  :
\begin{center}{\tt [3,3,4,4,4,3,4]}\end{center}

\item{\tt quantile} computes the deciles as specified by the second
argument of the statistical series stored in the columns of a matrix.\\ 
Input :\begin{center}{\tt quantile([[6,0,1,3,4,2,5],[0,1,3,4,2,5,6],[1,3,4,2,5,6,0], [3,4,2,5,6,0,1],[4,2,5,6,0,1,3],[2,5,6,0,1,3,4]],0.25)}\end{center}
Output is the vector of the first quartile of each column  :
\begin{center}{\tt [1,1,2,2,1,1,1]}\end{center}
Input :
\begin{center}{\tt quantile([[6,0,1,3,4,2,5],[0,1,3,4,2,5,6],[1,3,4,2,5,6,0], [3,4,2,5,6,0,1],[4,2,5,6,0,1,3],[2,5,6,0,1,3,4]],0.75)}\end{center}
Output is the vector of the third quartile of each column  :
\begin{center}{\tt [3,3,4,4,4,3,4]}\end{center}

\item{\tt quartiles} computes the minima, the first quartiles, the 
medians, the third quartiles and the maxima of the statistical series
stored in the columns of a matrix.\\ 
Input :
\begin{center}{\tt quartiles([[6,0,1,3,4,2,5],[0,1,3,4,2,5,6],[1,3,4,2,5,6,0], [3,4,2,5,6,0,1], [4,2,5,6,0,1,3], [2,5,6,0,1,3,4]])}\end{center}
Output is a matrix, it's first row is the minima of each column,
it's second row is the fist quartiles of each column, 
it's third row the medians 
of each column, it's fourth row the third
quartiles of each column and its last row the maxima of each column:
\begin{center}{\tt [[0,0,1,0,0,0,0],[1,1,2,2,1,1,1], [2,2,3,3,2,2,3],}\end{center}
\begin{center}{\tt [3,3,4,4,4,3,4],[6,5,6,6,6,6,6]]}\end{center}

\item{\tt boxwhisker} draws the whisker boxes of the statistical series
stored in the columns of a matrix .\\
Input :
\begin{center}{\tt boxwhisker([[6,0,1,3,4,2,5],[0,1,3,4,2,5,6], [1,3,4,2,5,6,0],[3,4,2,5,6,0,1], [4,2,5,6,0,1,3],[2,5,6,0,1,3,4]])}\end{center}
Output :
\begin{center}{\tt the drawing of the whisker boxes of the statistical 
series of each column of the matrix argument}\end{center} 
\end{itemize}

\subsection{Dimension of a matrix : {\tt dim}}\index{dim}
\noindent{\tt dim} takes as argument a matrix $A$.\\
{\tt dim} returns the list of the number of rows and columns
of the matrix $A$.\\
Input :
\begin{center}{\tt dim([[1,2,3],[3,4,5]])}\end{center}
Output :
\begin{center}{\tt  [2,3]}\end{center}

\subsection{Number of rows : {\tt rowdim rowDim nrows}}\index{rowdim}\index{rowDim}\index{nrows}
\noindent{\tt rowdim} (or {\tt rowDim} or {\tt nrows}) takes as argument a 
matrix $A$.\\
{\tt rowdim} (ou {\tt rowDim} or {\tt nrows}) returns the number of rows of the
matrix $A$.\\
Input :
\begin{center}{\tt rowdim([[1,2,3],[3,4,5]])}\end{center}
or
\begin{center}{\tt nrows([[1,2,3],[3,4,5]])}\end{center}
Output :
\begin{center}{\tt  2}\end{center}

\subsection{Number of columns : {\tt coldim colDim ncols}}\index{coldim}\index{colDim}\index{ncols}
\noindent{\tt coldim} (or {\tt colDim} or {\tt ncols}) takes as argument a 
matrix $A$.\\
{\tt coldim} (or {\tt colDim} or {\tt ncols}) returns the number of columns of 
the matrix $A$.\\
Input :
\begin{center}{\tt coldim([[1,2,3],[3,4,5]])}\end{center}
or
\begin{center}{\tt ncols([[1,2,3],[3,4,5]])}\end{center}
Output :
\begin{center}{\tt  3}\end{center}


\section{Linear algebra }
\subsection{Transpose of a matrix : {\tt tran transpose}}\index{tran}\index{transpose}
\noindent{\tt tran} or {\tt transpose} takes as argument a matrix $A$.\\
{\tt tran} or {\tt transpose} returns the transpose matrix of $A$.\\
Input :
\begin{center}{\tt tran([[1,2],[3,4]])}\end{center}
Output :
\begin{center}{\tt [[1,3],[2,4]]}\end{center}

\subsection{Inverse of a matrix : {\tt inv /}}\index{inv|textbf}\index{/|textbf}
\noindent{\tt inv} takes as argument a square matrix $A$.\\
{\tt inv} returns the inverse matrix of $A$.\\
Input :
\begin{center}{\tt inv([[1,2],[3,4]])}\end{center}
or
\begin{center}{\tt 1/[[1,2],[3,4]])}\end{center}
or
\begin{center}{\tt A:=[[1,2],[3,4]];1/A}\end{center}
Output :
\begin{center}{\tt  [[-2,1],[3/2,1/-2]]}\end{center}

\subsection{Trace of a matrix : {\tt trace}}\index{trace}
\noindent{\tt trace} takes as argument a matrix $A$.\\
{\tt trace} returns the trace of the matrix $A$, that is 
the sum of the diagonal elements.\\
Input :
\begin{center}{\tt trace([[1,2],[3,4]])}\end{center}
Output :
\begin{center}{\tt  5}\end{center}

\subsection{Determinant of a matrix : {\tt det}}\index{det|textbf}
\noindent{\tt det} takes as argument a matrix $A$.\\
{\tt det} returns the determinant of the matrix $A$.\\
Input :
\begin{center}{\tt det([[1,2],[3,4]])}\end{center}
Output :
\begin{center}{\tt -2}\end{center}
Input :
\begin{center}{\tt det(idn(3))}\end{center}
Output :
\begin{center}{\tt 1}\end{center}

\subsection{Determinant of a sparse matrix : {\tt det\_minor}}\index{det\_minor}
\noindent{\tt det\_minor} takes as argument a matrix $A$.\\
{\tt det\_minor} returns the determinant of the matrix $A$ computed by 
expanding the determinant using Laplace algorithm.\\
Input :
\begin{center}{\tt det\_minor([[1,2],[3,4]])}\end{center}
Output :
\begin{center}{\tt -2}\end{center}
Input :
\begin{center}{\tt det\_minor(idn(3))}\end{center}
Output :
\begin{center}{\tt 1}\end{center}

\subsection{Rank of a matrix : {\tt rank}}\index{rank}
\noindent{\tt rank} takes as argument a matrix $A$.\\
{\tt rank} returns the rank of the matrix $A$.\\
Input :
\begin{center}{\tt rank([[1,2],[3,4]])}\end{center}
Output :
\begin{center}{\tt 2}\end{center}
Input :
\begin{center}{\tt rank([[1,2],[2,4]])}\end{center}
Output :
\begin{center}{\tt 1}\end{center}

\subsection{Transconjugate of a matrix : {\tt trn}}\index{trn}
\noindent{\tt trn} takes as argument a matrix $A$.\\
{\tt trn} returns the transconjugate of $A$ (i.e. the conjugate of the 
transpose matrix of $A$).\\
Input :
\begin{center}{\tt trn([[i, 1+i],[1, 1-i]])}\end{center}
Output after simplification:
\begin{center}{\tt [[-i,1],[1-i,1+i]]}\end{center}


\subsection{Equivalent matrix : {\tt changebase}}\index{changebase}
\noindent{\tt changebase} takes as argument a matrix $A$ and a
change-of-basis matrix $P$.\\
{\tt changebase} returns the matrix $B$ such that $B=P^{-1}AP$.\\
Input :
\begin{center}{\tt changebase([[1,2],[3,4]],[[1,0],[0,1]])}\end{center}
Output :
\begin{center}{\tt [[1,2],[3,4]]}\end{center}
Input :
\begin{center}{\tt changebase([[1,1],[0,1]],[[1,2],[3,4]])}\end{center}
Output :
\begin{center}{\tt [[-5,-8],[9/2,7]]}\end{center}
Indeed :
 $${\left[\begin{array}{rr} 1 & 2\\3&4\end{array}\right]}^{-1}*\left[\begin{array}{rr}1 & 1\\0&1\end{array}\right]*\left[\begin{array}{rr}1 & 2\\3&4\end{array}\right]=\left[\begin{array}{rr}-5 & -8\\\frac{9}{2}&7\end{array}\right]$$.

\subsection{Basis of a linear subspace  : {\tt basis}}\index{basis}
\noindent{\tt basis} takes as argument a list of vectors generating
a linear subspace of $\mathbb R^n$.\\
{\tt basis} returns a list of vectors, that is a basis of this
linear subspace.\\
Input :
\begin{center}{\tt basis([[1,2,3],[1,1,1],[2,3,4]])}\end{center}
Output :
\begin{center}{\tt [[1,0,-1],\ [0,1,2]]}\end{center}

\subsection{Basis of the intersection of two subspaces : {\tt ibasis}}\index{ibasis}
\noindent{\tt ibasis} takes as argument two lists of vectors generating
two subspaces of $\mathbb R^n$.\\ 
{\tt ibasis} returns a list of vectors that is a basis of the 
intersection of these two subspaces.\\
Input :
\begin{center}{\tt ibasis([[1,2]],[[2,4]])}\end{center}
Output :
\begin{center}{\tt [[1,2]]}\end{center}

\subsection{Image of a linear application : {\tt image}}\index{image}
\noindent{\tt image} takes as argument the matrix of an linear 
application $f$ with respect to the canonical basis.\\
{\tt image} returns a list of vectors that is a basis of the image 
of $f$.\\
Input :
\begin{center}{\tt image([[1,1,2],[2,1,3],[3,1,4]])}\end{center}
Output :
\begin{center}{\tt   [[-1,0,1],[0,-1,-2]]}\end{center}

\subsection{Kernel of a linear application : {\tt kernel nullspace ker}}\index{ker}\index{kernel}\index{nullspace}
\noindent{\tt ker} (or {\tt kernel} or {\tt nullspace}) takes as argument the 
matrix of an linear application $f$ with respect to the canonical basis.\\
{\tt ker} (or {\tt kernel} or  {\tt nullspace}) returns a list of
vectors that is a basis of the kernel of $f$.\\
Input :
\begin{center}{\tt ker([[1,1,2],[2,1,3],[3,1,4]])}\end{center}
Output :
\begin{center}{\tt [[1,1,-1]]}\end{center}
The kernel is generated by the vector {\tt [1,1,-1]}.

\subsection{Kernel of a linear application : {\tt Nullspace}}\index{Nullspace}
\noindent {\bf Warning} This function is useful in Maple mode only 
(hit the state line red button then {\tt Prog style}, 
then choose Maple and Apply).\\
{\tt Nullspace} is the inert form of {\tt nullspace}.\\
{\tt Nullspace} takes as argument an integer matrix of an linear 
application $f$ with respect to the canonical basis.\\
{\tt Nullspace}) followed by {\tt mod p} returns a list of vectors 
that is a basis of the kernel of $f$ computed in $\mathbb Z/p\mathbb Z[X]$.\\
Input :
\begin{center}{\tt Nullspace([[1,1,2],[2,1,3],[3,1,4]])}\end{center}
Output :
\begin{center}{\tt nullspace([[1,1,2],[2,1,3],[3,1,4]])}\end{center}
Input (in Maple mode):
\begin{center}{\tt Nullspace([[1,2],[3,1]]) mod 5}\end{center}
Output :
\begin{center}{\tt [2,-1]}\end{center}
In Xcas mode, the equivalent input is :
\begin{center}{\tt nullspace([[1,2],[3,1]] \% 5)}\end{center}
Output :
\begin{center}{\tt [2\% 5,-1]}\end{center}

\subsection{Subspace generated by the columns of a matrix : {\tt colspace}}\index{colspace}
\noindent{\tt colspace} takes as argument the matrix $A$ of an linear 
application $f$ with respect to the canonical basis.\\
{\tt colspace} returns a matrix. The columns of this  matrix are a basis of the
subspace generated by the columns of $A$.\\
{\tt colspace} may have a variable name as second argument, where 
{\tt  Xcas}
will store the dimension of the subspace generated by the columns of $A$.\\
Input :
\begin{center}{\tt colspace([[1,1,2],[2,1,3],[3,1,4]])}\end{center}
Output :
\begin{center}{\tt  [[-1,0],[0,-1],[1,-2]]}\end{center}
Input :
\begin{center}{\tt colspace([[1,1,2],[2,1,3],[3,1,4]],dimension)}\end{center}
Output :
\begin{center}{\tt  [[-1,0],[0,-1],[1,-2]]}\end{center}
Then input:
\begin{center}{\tt dimension}\end{center}
Output :
\begin{center}{\tt  2}\end{center}

\subsection{Subspace generated by the rows of a matrix : {\tt rowspace}}\index{rowspace}
\noindent{\tt rowspace} takes as argument the matrix $A$ of an linear 
application $f$ with respect to the canonical basis.\\
{\tt rowspace} returns a list of vectors that is a basis of the 
subspace generated by the rows of $A$.\\
{\tt rowspace} may have a variable name as second argument where {\tt Xcas}
will store the dimension of the subspace generated by the rows of $A$.\\
Input :
\begin{center}{\tt rowspace([[1,1,2],[2,1,3],[3,1,4]])}\end{center}
Output :
\begin{center}{\tt  [[-1,0,-1],[0,-1,-1]]}\end{center}
Input :
\begin{center}{\tt rowspace([[1,1,2],[2,1,3],[3,1,4]],dimension)}\end{center}
Output :
\begin{center}{\tt  [[-1,0,-1],[0,-1,-1]]}\end{center}
Then input:
\begin{center}{\tt dimension}\end{center}
Output :
\begin{center}{\tt  2}\end{center}

\section{Linear Programmation}\index{simplex\_reduce|textbf}
Linear programming problems are maximization problem of a linear
functional under linear equality or inequality constraints.
The most simple case can be solved directly by the so-called simplex
algorithm. Most cases requires to solve an auxiliary linear
programming problem to find an initial vertex for the simplex
algorithm.

\subsection{Simplex algorithm: {\tt simplex\_reduce}}
{\bf The simple case}\\
The function {\tt simplex\_reduce} makes the reduction 
by the simplex algorithm to find : 
\[ \mbox{max}(c.x), \quad  A.x \leq b,\ x \geq 0,\ b\geq 0 \]
where $c,x$ are vectors of $\mathbb R^n$, $b\geq 0$ is a vector of 
$\mathbb R^p$ and $A$ is a matrix of $p$ rows and $n$ columns.\\
{\tt simplex\_reduce} takes as argument {\tt A,b,c} et
returns  {\tt max(c.x)}, the augmented solution of {\tt x}
(augmented since the algorithm works by adding rows($A$) auxiliary
variables) and the reduced matrix.\\ 
{\bf Example}\\
Find \[ \mbox{max}(X+2Y)  \mbox{ where }
\left\{
\begin{array}{rcl}
(X,Y) & \geq & 0 \\
-3X +2Y  & \leq & 3\\
X +Y  & \leq & 4
\end{array} 
\right.
\]
Input :
\begin{center}{\tt simplex\_reduce([[-3,2],[1,1]],[3,4],[1,2])}\end{center}
Output :
\begin{center}{\tt 7,[1,3,0,0],[[0,1,1/5,3/5,3],[1,0,(-1)/5,2/5,1], [0,0,1/5,8/5,7]]}\end{center}
Which means that the maximum of {\tt X+2Y} under these conditions
is {\tt 7}, it is obtained for {\tt X=1,Y=3} 
because {\tt [1,3,0,0]} is the augmented solution and the reduced matrix is :\\
{\tt [[0,1,1/5,3/5,3],[1,0,(-1)/5,2/5,1], [0,0,1/5,8/5,7]]}.

{\bf A more complicate case that reduces to the simple case}\\
With the former call of {\tt simplex\_reduce}, we have to :
\begin{itemize}
\item rewrite constraints to the form $x_k \geq 0$,
\item remove variables without constraints,
\item add variables such that all the constraints have positive components.
\end{itemize}
For example, find :
\[ \mbox{min}(2x+y-z+4)  \quad \mbox{ where }
\left\{
\begin{array}{rcl}
x & \leq & 1 \\
y & \geq & 2 \\
x+3y-z & = & 2 \\
2x-y+z & \leq & 8\\
-x+y & \leq & 5
\end{array} 
\right.
\]
Let $x=1-X$, $y=Y+2$, $z=5-X+3Y$
the problem is equivalent to finding the minimum of
$(-2X+Y-(5-X+3Y)+8)$ 
where :
\[ 
\left\{
\begin{array}{rcl}
X & \geq & 0 \\
Y & \geq & 0 \\
2(1-X)-(Y+2)+ 5-X+3Y & \leq & 8\\
-(1-X) +(Y+2)  & \leq & 5
\end{array} 
\right.
\]
or to find the minimum of~:
\[ (-X-2Y+3) \quad \mbox{ where } 
\left\{
\begin{array}{rcl}
X & \geq & 0 \\
Y & \geq & 0 \\
-3X+2Y & \leq & 3\\
X +Y  & \leq & 4
\end{array} 
\right.
\]
i.e. to find the maximum of $-(-X-2Y+3)=X+2Y-3$
under the same conditions, hence it is the same problem as 
to find the maximum of $X+2Y$ seen before. We found {\tt 7}, 
hence, the result here is {\tt 7-3=4}.

{\bf The general case}\\
A linear programming problem may not in general be directly
reduced like above to the simple case. The reason is that
a starting vertex must be found before applying the simplex
algorithm. Therefore,
{\tt simplex\_reduce} may be called by specifying this starting
vertex, in that case, all the arguments including the starting
vertex are grouped in a single matrix. 

We first illustrate this kind
of call in the simple case where the starting point does not
require solving an auxiliary problem.
If {\tt A} has $p$ rows and $n$ columns and if we define :
\begin{center}
{\tt B:=augment(A,idn(p));} {\tt C:=border(B,b);} \\
{\tt d:=append(-c,0\$(p+1));} {\tt D:=augment(C,[d]);}
\end{center}
{\tt simplex\_reduce} may be called with {\tt D} as single argument.\\
For the previous example, input :
\begin{center}{\tt A:=[[-3,2],[1,1]];B:=augment(A,idn(2)); C:=border(B,[3,4]);
D:=augment(C,[[-1,-2,0,0,0]])}\end{center}
Here 
{\tt C=[[-3,2,1,0,3],[1,1,0,1,4]]}\\
and {\tt D=[[-3,2,1,0,3],[1,1,0,1,4],[-1,-2,0,0,0]]}\\
Input :
\begin{center}{\tt simplex\_reduce(D)}\end{center}
Output is the same result as before.

{\bf Back to the general case.}\\
The standard form of a linear programming problem is similar
to the simplest case above, but with $Ax=b$ (instead of $Ax\leq b$)
under the conditions $x\geq 0$. We may further assume that $b\geq 0$
(if not, one can change the sign of the corresponding line).
\begin{itemize}
\item The first problem is to find an $x$ in the $Ax=b, x\geq 0$ domain.
Let $m$ be the number of lines of $A$. Add artificial variables
$y_1,...,y_m$ and maximize
$-\sum y_i$ under the conditions $Ax=b, x \geq 0, y \geq 0$ 
starting with initial value $0$ for $x$ variables
and $y=b$
(to solve this with {\tt Xcas}, call \verb|simplex_reduce| with
a single matrix argument obtained by augmenting $A$ by the
identity, $b$ unchanged and an artificial
$c$ with 0 under $A$ and 1 under the identity).
If the maximum exists and is 0, the identity submatrix above the last
column corresponds to an $x$ solution, we may forget the artificial
variables (they are 0 if the maximum is 0).
\item Now we make a second call to \verb|simplex_reduce|
with the original $c$ and the value of $x$ we found in the domain.
\item
Example~: find the minimum of $2x+3y-z+t$ with 
$x,y,z,t\geq 0$ and~:
\[ \left\{ \begin{array}{rcl}
-x-y+t&=&1\\
y-z+t&=&3
\end{array}
\right. \]
This is equivalent to find the opposite of the maximum of $-(2x+3y-z+t)$.
Let us add two artificial variables $y_1$ and $y_2$,
\begin{verbatim}
simplex_reduce([[-1,-1,0,1,1,0,1],
[0,1,-1,1,0,1,3],
[0,0,0,0,1,1,0]])
\end{verbatim}
Output: optimum=0, artificial variables=0, and the matrix
\[
\left(\begin{array}{ccccccc}
-1/2 & 0 & -1/2 & 1 & 1/2 & 1/2 & 2 \\
1/2 & 1 & -1/2 & 0 & -1/2 & 1/2 & 1 \\
0 & 0 & 0 & 0 & 1 & 1 & 0
\end{array}\right) 
\]
Columns 2 and 4 are the columns of the identity (in lines 1 and 2).
Hence $x=(0,1,0,2)$ is an initial point in the domain.
We are reduced to solve the initial problem, after replacing the
lines of $Ax=b$ by the two first lines of the answer above,
removing the last columns corresponding to the artificial variables.
We add $c.x$ as last line
\begin{verbatim}
simplex_reduce([[-1/2,0,-1/2,1,2],
[1/2,1,-1/2,0,1],[2,3,-1,1,0]])
\end{verbatim}
Output: maximum=-5, hence the minimum of the opposite is 5,
obtained for $(0,1,0,2)$, after replacement 
$x=0$, $y=1$, $z=0$ and $t=2$.
\end{itemize}

For more details, search google for \verb|simplex algorithm|.

\section{Different matrix norm}
\subsection{$l^2$ matrix norm : {\tt nomm l2norm}}\index{norm}\index{l2norm|textbf}\label{sec:l2normm}
\noindent{\tt norm} (or {\tt l2norm}) takes as argument a matrix $A=a_{j,k}$ 
(see also \ref{sec:l2normv}).\\
{\tt norm} (or {\tt l2norm}) returns 
$\displaystyle \sqrt{\sum_{j,k} a_{j,k}^2}$.\\
Input :
\begin{center}{\tt norm([[1,2],[3,-4]])}\end{center}
or
\begin{center}{\tt l2norm([[1,2],[3,-4]])}\end{center}
Output :
\begin{center}{\tt sqrt(30)}\end{center}

\subsection{$l^\infty$ matrix norm : {\tt maxnorm}}\index{maxnorm}\label{sec:maxnormm}
\noindent{\tt maxnorm} takes as argument a matrix $A=a_{j,k}$ (see also \ref{sec:maxnormv}).\\
{\tt maxnorm} returns $ \max(|a_{j,k}|)$.\\
Input :
\begin{center}{\tt maxnorm([[1,2],[3,-4]])}\end{center}
Output :
\begin{center}{\tt 4}\end{center}

\subsection{Matrix row norm : {\tt rownorm rowNorm}}\index{rowNorm}\index{rownorm}
\noindent{\tt rownorm} (or {\tt rowNorm}) takes as argument a matrix $A=a_{j,k}$.\\
{\tt rownorm} (or {\tt rowNorm}) returns $\max_k(\sum_j |a_{j,k}|)$.\\
Input :
\begin{center}{\tt rownorm([[1,2],[3,-4]])}\end{center}
or
\begin{center}{\tt rowNorm([[1,2],[3,-4]])}\end{center}
Output :
\begin{center}{\tt 7}\end{center}
Indeed : $\max(1+2,3+4)=7$

\subsection{Matrix column norm : {\tt colnorm colNorm}}\index{colNorm}\index{colnorm}
\noindent{\tt colnorm} (or {\tt colNorm}) takes as argument a matrix 
$A=a_{j,k}$.\\
{\tt colnorm} (or {\tt colNorm}) returns $\max_j(\sum_k(|a_{j,k}|))$.\\
Input :
\begin{center}{\tt colnorm([[1,2],[3,-4]])}\end{center}
or
\begin{center}{\tt colNorm([[1,2],[3,-4]])}\end{center}
Output :
\begin{center}{\tt 6}\end{center}
Indeed : $\max(1+3,2+4)=6$

\section{Matrix reduction}
\subsection{Eigenvalues : {\tt eigenvals}}\index{eigenvals}
\noindent{\tt eigenvals} takes as argument a square
matrix $A$ of size $n$.\\
{\tt eigenvals} returns the sequence of the $n$ eigenvalues of $A$.\\
{\bf Remark} : If $A$ is exact, {\tt Xcas} may not be able
to find the exact roots of the characteristic polynomial, 
{\tt eigenvals} will return approximate eigenvalues of $A$ if the
coefficients are numeric or a subset of the eigenvalues if the
coefficients are symbolic.\\
Input :
\begin{center}{\tt eigenvals([[4,1,-2],[1,2,-1],[2,1,0]])}\end{center}
Output :
\begin{center}{\tt (2,2,2) }\end{center}
Input :
\begin{center}{\tt eigenvals([[4,1,0],[1,2,-1],[2,1,0]])}\end{center}
Output :
\begin{center}{\tt (0.324869129433,4.21431974338,1.46081112719)}\end{center}

\subsection{Eigenvalues : {\tt egvl eigenvalues eigVl}}\index{egvl}\index{eigVl}\index{eigenvalues}
\noindent{\tt egvl} (or {\tt eigenvalues eigVl}) takes as argument a 
square matrix $A$ of size $n$.\\
{\tt egvl} (or {\tt eigenvalues eigVl}) returns the Jordan normal
form of $A$.\\
{\bf Remark} : If $A$ is exact, {\tt Xcas} may not be able
to find the exact roots of the characteristic polynomial, 
{\tt eigenvalues} will return an approximate diagonalozation of $A$ if the
coefficients are numeric.\\
Input :
\begin{center}{\tt egvl([[4,1,-2],[1,2,-1],[2,1,0]])}\end{center}
Output :
\begin{center}{\tt [[2,1,0],[0,2,1],[0,0,2]] }\end{center}
Input :
\begin{center}{\tt egvl([[4,1,0],[1,2,-1],[2,1,0]])}\end{center}
Output :
\begin{center}{\tt [[0.324869129433,0,0],[0,4.21431974338,0],[0,0,1.46081112719]]}\end{center}

\subsection{Eigenvectors : {\tt egv eigenvectors eigenvects \\
eigVc}}\index{egv}\index{eigenvectors}\index{eigenvects}\index{eigVc}
\noindent{\tt egv} (or {\tt eigenvectors eigenvects eigVc}) takes as argument 
a square matrix $A$ of size $n$.\\
If $A$ is a diagonalizable matrix, {\tt egv} (or 
{\tt eigenvectors eigenvects eigVc}) returns a matrix which columns are the 
eigenvectors of the matrix $A$. Otherwise, it will fail (see also
{\tt jordan} for characteristic vectors).\\ 
Input :
\begin{center}{\tt egv([[1,1,3],[1,3,1],[3,1,1]])}\end{center}
Output :
\begin{center}{\tt [[-1,1,1],[2,1,0],[-1,1,-1]] }\end{center}
Input :
\begin{center}{\tt egv([[4,1,-2],[1,2,-1],[2,1,0]])}\end{center}
Output :
\begin{center}{\tt "Not diagonalizable at eigenvalue 2"}\end{center}
In complex mode, input :
\begin{center}{\tt egv([[2,0,0],[0,2,-1],[2,1,2]])}\end{center}
Output :
\begin{center}{\tt [0,1,0],[-1,-2,-1],[i,0,-i]]}\end{center}

\subsection{Rational Jordan matrix : {\tt rat\_jordan}}\index{rat\_jordan}
\noindent {\tt rat\_jordan} takes as argument a square
matrix $A$ of size $n$ with exact coefficients.\\
{\tt rat\_jordan} returns :
\begin{itemize}
\item in {\tt Xcas}, {\tt Mupad} or {\tt TI} mode\\ 
a sequence of two matrix : a matrix $P$ (the columns of $P$ are
the eigenvectors if $A$ is diagonalizable in the field of it's coefficients)
and the rational Jordan matrix $J$ of $A$, that is the most reduced
matrix in the field of the coefficients of $A$ (or the complexified
field in complex mode), where 
\[ J=P^{-1}AP \]
\item in {\tt Maple} mode\\
the Jordan matrix $J$ of $A$. We can also have the matrix $P$ verifying
$J=P^{-1}AP$ in a variable 
by passing this variable as second argument, for example 
\begin{center} {\tt rat\_jordan([[1,0,0],[1,2,-1],[0,0,1]],'P')}
\end{center}
\end{itemize}
{\bf Remarks}
\begin{itemize}
\item the syntax {\tt Maple} is also valid in the other modes, for example, in
{\tt Xcas} mode input 
\begin{center} {\tt rat\_jordan([[4,1,1],[1,4,1],[1,1,4]],'P')}
\end{center}
Output :
\begin{center} {\tt [[1,-1,1/2],[1,0,-1],[1,1,1/2]]}
\end{center}
then {\tt P} returns
\begin{center} {\tt [[6,0,0],[0,3,0],[0,0,3]]}
\end{center}
\item the coefficients of $P$ and $J$ belongs to the same field as the 
coefficients of $A$.\\
For example, in {\tt Xcas} mode, input :
\begin{center} {\tt rat\_jordan([[1,0,1],[0,2,-1],[1,-1,1]])}
\end{center}
Output :
\begin{center} {\tt [[1,1,2],[0,0,-1],[0,1,2]],[[0,0,-1],[1,0,-3],[0,1,4]]}\end{center}
Input (put {\tt -pcar(...)} because the argument of {\tt companion} is an unit 
polynomial (see \ref{sec:compagne})
\begin{center} {\tt companion(-pcar([[1,0,1],[0,2,-1],[1,-1,1]],x),x)}\end{center}
Output :
\begin{center} {\tt [[0,0,-1],[1,0,-3],[0,1,4]]}\end{center}
Input :
\begin{center} {\tt rat\_jordan([[1,0,0],[0,1,1],[1,1,-1]])}\end{center}
Output :
\begin{center} {\tt [[-1,0,0],[1,1,1],[0,0,1]],[[1,0,0],[0,0,2],[0,1,0]]}\end{center}
Input :
\begin{center} {\tt factor(pcar([[1,0,0],[0,1,1],[1,1,-1]],x))}\end{center}
Output :
\begin{center} {\tt -(x-1)*(x\verb|^|2-2)}\end{center}
Input :
\begin{center} {\tt companion((x\verb|^|2-2),x)}\end{center}
Output :
\begin{center} {\tt [[0,2],[1,0]]}\end{center}



\item When $A$ is symetric and has eigenvalues with an multiple order,
{\tt Xcas} returns orthogonal eigenvectors (not always of norm equal to 1)
i.e. {\tt tran(P)*P} is a diagonal matrix where the diagonal is the square norm
of the eigenvectors, for example :
\begin{center} {\tt rat\_jordan([[4,1,1],[1,4,1],[1,1,4]])}
\end{center}
returns :
\begin{center} {\tt [[1,-1,1/2],[1,0,-1],[1,1,1/2]],[[6,0,0],[0,3,0],[0,0,3]]}
\end{center}
\end{itemize} 
Input in {\tt Xcas}, {\tt Mupad} or {\tt TI} mode :
\begin{center}{\tt rat\_jordan([[1,0,0],[1,2,-1],[0,0,1]])}\end{center}
Output :
\begin{center}{\tt [[0,1,0],[1,0,1],[0,1,1]],[[2,0,0],[0,1,0],[0,0,1]]}\end{center}
Input in {\tt Xcas}, {\tt Mupad} or {\tt TI} mode :
\begin{center}{\tt rat\_jordan([[4,1,-2],[1,2,-1],[2,1,0]])}\end{center}
Output :
\begin{center}{\tt  [[[1,2,1],[0,1,0],[1,2,0]],[[2,1,0],[0,2,1],[0,0,2]]]}\end{center}
In complex mode and in {\tt Xcas}, {\tt Mupad} or {\tt TI} mode , input :
\begin{center}{\tt rat\_jordan([[2,0,0],[0,2,-1],[2,1,2]])}\end{center}
Output :
\begin{center}{\tt [[1,0,0],[-2,-1,-1],[0,-i,i]],[[2,0,0],[0,2-i,0],[0,0,2+i]]}\end{center}
Input  in {\tt Maple} mode :
\begin{center}{\tt rat\_jordan([[1,0,0],[1,2,-1],[0,0,1]],'P')}\end{center}
Output :
\begin{center}{\tt [[2,0,0],[0,1,0],[0,0,1]]}\end{center}
then input : 
\begin{center}{\tt P)}\end{center}
Output :
\begin{center}{\tt [[0,1,0],[1,0,1],[0,1,1]]]}\end{center}

\subsection{Jordan normal form : {\tt jordan}}\index{jordan}
\noindent {\tt jordan} takes as argument a square
matrix $A$ of size $n$.\\
{\tt jordan} returns :
\begin{itemize}
\item in {\tt Xcas}, {\tt Mupad} or {\tt TI} mode\\ 
a sequence of two matrix : a matrix $P$ which columns are
the eigenvectors and characteristic vectors
of the matrix $A$ and the Jordan matrix $J$ of $A$ verifying $J=P^{-1}AP$,
\item in {\tt Maple} mode\\
the Jordan matrix $J$ of $A$. We can also have the matrix $P$ verifying
$J=P^{-1}AP$ in a variable 
by passing this variable as second argument, for example 
\begin{center} {\tt jordan([[1,0,0],[0,1,1],[1,1,-1]],'P')}
\end{center}
\end{itemize}
{\bf Remarks}
\begin{itemize}
\item the syntax {\tt Maple} is also valid in the other modes, for example, in
{\tt Xcas} mode input :
\begin{center} {\tt jordan([[4,1,1],[1,4,1],[1,1,4]],'P')}
\end{center}
Output :
\begin{center} {\tt [[1,-1,1/2],[1,0,-1],[1,1,1/2]]}
\end{center}
then {\tt P} returns
\begin{center} {\tt [[6,0,0],[0,3,0],[0,0,3]]}
\end{center}
\item When $A$ is symetric and has eigenvalues with an multiple order,
{\tt Xcas} returns orthogonal eigenvectors (not always of norm equal to 1)
i.e. {\tt tran(P)*P} is a diagonal matrix where the diagonal is the square norm
of the eigenvectors, for example :
\begin{center} {\tt jordan([[4,1,1],[1,4,1],[1,1,4]])}
\end{center}
returns :
\begin{center} {\tt [[1,-1,1/2],[1,0,-1],[1,1,1/2]],[[6,0,0],[0,3,0],[0,0,3]]}
\end{center}
\end{itemize} 
 Input in {\tt Xcas}, {\tt Mupad} or {\tt TI} mode :
\begin{center}{\tt jordan([[1,0,0],[0,1,1],[1,1,-1]])}\end{center}
Output :
\begin{center}{\tt [[1,0,0],[0,1,1],[1,1,-1]],[[-1,0,0],[1,1,1],[0,-sqrt(2)-1,sqrt(2)-1]],[[1,0,0],[0,-(sqrt(2)),0],[0,0,sqrt(2)]]}\end{center}
Input  in {\tt Maple} mode :
\begin{center}{\tt jordan([[1,0,0],[0,1,1],[1,1,-1]])}\end{center}
Output :
\begin{center}{\tt [[1,0,0],[0,-(sqrt(2)),0],[0,0,sqrt(2)]]}\end{center}
then input : 
\begin{center}{\tt P)}\end{center}
Output :
\begin{center}{\tt [[-1,0,0],[1,1,1],[0,-sqrt(2)-1,sqrt(2)-1]]}\end{center}
Input  in {\tt Xcas}, {\tt Mupad} or {\tt TI} mode :
\begin{center}{\tt jordan([[4,1,-2],[1,2,-1],[2,1,0]])}\end{center}
Output :
\begin{center}{\tt  [[[1,2,1],[0,1,0],[1,2,0]],[[2,1,0],[0,2,1],[0,0,2]]]}\end{center}
In complex mode and in {\tt Xcas}, {\tt Mupad} or {\tt TI} mode , input :
\begin{center}{\tt jordan([[2,0,0],[0,2,-1],[2,1,2]])}\end{center}
Output :
\begin{center}{\tt [[1,0,0],[-2,-1,-1],[0,-i,i]],[[2,0,0],[0,2-i,0],[0,0,2+i]]}\end{center}

\subsection{Characteristic polynomial : {\tt charpoly}}\index{pcar}\index{charpoly}
\noindent{\tt charpoly} (or {\tt pcar}) takes one or two argument(s),
 a square matrix $A$ of size $n$ and optionnally
the name of a symbolic variable.\\
{\tt charpoly} returns the characteristic polynomial 
$P$ of $A$ written as the
list of its coefficients if no variable name was provided
or written as an expression with respect to
the variable name provided as second argument.\\
The characteristic polynomial $P$ of $A$ is defined as
\[ P(x)=\det(x.I-A) \]
Input :
\begin{center}{\tt charpoly([[4,1,-2],[1,2,-1],[2,1,0]])}\end{center}
Output :
\begin{center}{\tt[1,-6,12,-8]}\end{center}
Hence, the characteristic polynomial of this matrix is
$x^3-6x^2+12x-8$ (input {\tt normal(poly2symb([1,-6,12,-8],x))} to get
its symbolic representation).\\
Input :
\begin{center}{\tt purge(X):;
charpoly([[4,1,-2],[1,2,-1],[2,1,0]],X)}\end{center}
Output :
\begin{center}{\tt X\verb|^|3-6*X\verb|^|2+12*X-8}\end{center}

\subsection{Characteristic polynomial using Hessenberg algorithm :\\
 {\tt pcar\_hessenberg}}\index{pcar\_hessenberg}
\noindent{\tt pcar\_hessenberg} takes as argument a square 
matrix $A$ of size $n$ and optionnaly the name of a symbolic variable.\\
{\tt pcar\_hessenberg} returns the characteristic polynomial $P$ of $A$ written
as the list of its coefficients if no variable was provided
or written in its symbolic form with respect to the variable name given 
as second argument, where
\[ P(x)=\det(xI-A) \]
The characteristic polynomial is computed using the Hessenberg algorithm
(see e.g. Cohen) which is more efficient ($O(n^3)$ deterministic) if 
the coefficients of $A$ are in a finite field or use a finite 
representation like approximate numeric coefficients. Note however that
this algorithm behaves badly if the coefficients are e.g. in $\mathbb Q$.\\
Input :
\begin{center}{\tt pcar\_hessenberg([[4,1,-2],[1,2,-1],[2,1,0]] \% 37)}\end{center}
Output :
\begin{center}{\tt[1 \% 37 ,-6\% 37,12 \% 37,-8 \% 37]}\end{center}
Input :
\begin{center}{\tt pcar\_hessenberg([[4,1,-2],[1,2,-1],[2,1,0]] \% 37,x)}\end{center}
Output :
\begin{center}{\tt x\verb|^|3-6 \%37 *x\verb|^|2+12 \% 37 *x-8 \% 37}\end{center}
Hence, the characteristic polynomial of [[4,1,-2],[1,2,-1],[2,1,0]] in
$\mathbb Z/37 \mathbb Z$ is
\[ x^3-6x^2+12x-8 \]

\subsection{Minimal polynomial : {\tt pmin}}\index{pmin}
\noindent{\tt pmin}  takes one (resp two) argument(s):
a square matrix $A$ of size $n$ and optionnaly
the name of a symbolic variable.\\
{\tt pmin} returns the minimal polynomial of $A$ written as a
list of its coefficients if no variable was provided, or
written in symbolic form with respect to the  
variable name given as second argument.
The minimal polynomial of $A$ is the polynomial $P$ 
having minimal degree such that $P(A)=0$.\\
Input :
\begin{center}{\tt pmin([[1,0],[0,1]])}\end{center}
Output :
\begin{center}{\tt [1,-1]}\end{center}
Input :
\begin{center}{\tt pmin([[1,0],[0,1]],x)}\end{center}
Output :
\begin{center}{\tt x-1}\end{center}
Hence the minimal polynomial of [[1,0],[0,1]] is {\tt x-1}.\\
Input :
\begin{center}{\tt pmin([[2,1,0],[0,2,0],[0,0,2]])}\end{center}
Output :
\begin{center}{\tt [1,-4,4]}\end{center}
 Input :
\begin{center}{\tt pmin([[2,1,0],[0,2,0],[0,0,2]],x)}\end{center}
Output :
\begin{center}{\tt x\verb|^|2-4*x+4}\end{center}
Hence, the minimal polynomial of [[2,1,0],[0,2,0],[0,0,2]] is $x^2-4x+4$.

\subsection{Adjoint matrix : {\tt adjoint\_matrix}}\index{adjoint\_matrix}
\noindent{\tt adjoint\_matrix } takes as argument  a square matrix 
$A$ of size $n$.\\
{\tt adjoint\_matrix } returns the list of the coefficients of $P$ 
(the characteristic polynomial of $A$), and
the list of the matrix coefficients of $Q$ (the adjoint matrix 
of $A$). 

The comatrix of a square matrix $A$ of size $n$ is the matrix $B$ 
defined by $A\times B=\det(A)\times I$. The adjoint matrix of $A$
is the comatrix of $xI-A$. It is a polynomial of degree $n-1$ in $x$
having matrix coefficients.
The following relation holds:
\[ P(x)\times I=\det(xI-A)I=(xI-A)Q(x)\]
Since the polynomial $P(x)\times I-P(A)$ (with matrix coefficients)
is also divisible by $x\times I-A$ (by algebraic identities), 
this proves that $P(A)=0$.
We also have $Q(x)\ =\ I\times  x^{n-1}+...+B_0 $ 
where $B_0=$ is the comatrix of $A$ (up to the sign if $n$ is odd).
Input :
\begin{center}{\tt adjoint\_matrix([[4,1,-2],[1,2,-1],[2,1,0]])}\end{center}
Output :
\begin{center}
{\tt [
  {\bf [}1,-6,12,-8{\bf ]},\\
{\bf [} [[1,0,0],[0,1,0],[0,0,1]],
  [[-2,1,-2], [1,-4,-1],[2,1,-6]],
  [[1,-2,3],[-2,4,2],[-3,-2,7]] {\bf ]}
] }\end{center}
Hence the characteristic polynomial is :
\[ P(x)=x^3-6*x^2+12*x-8 \]
The determinant of $A$ is equal to $-P(0)=8$.
The comatrix of $A$ is equal to :
\[ B=Q(0)=[[1,-2,3],[-2,4,2],[-3,-2,7]] \]
Hence the inverse of $A$ is equal to :
\[ 1/8*[[1,-2,3],[-2,4,2],[-3,-2,7]] \]
The adjoint matrix of $A$ is :
\[ [[x^2-2x+1,x-2,-2x+3],[x-2,x^2-4x+4,-x+2],[2x-3,x-2,x^2-6x+7]] \]
Input :
\begin{center}{\tt adjoint\_matrix([[4,1],[1,2]])}\end{center}
Output :
\begin{center}{\tt[[1,-6,7],[[[1,0],[0,1]],[[-2,1],[1,-4]]]]}\end{center}
Hence the characteristic polynomial $P$ is :
\[ P(x)=x^2-6*x+7 \]
The determinant of $A$ is equal to $+P(0)=7$.
The comatrix of $A$ is equal to 
\[ Q(0)= -[[-2,1],[1,-4]] \]
Hence the inverse of $A$ is equal to :
\[ -1/7*[[-2,1],[1,-4]] \]
The adjoint matrix of $A$ is :
\[ -[[x-2,1],[1,x-4]] \]

\subsection{Companion matrix of a polynomial : {\tt companion}}\index{companion|textbf}\label{sec:compagne}
\noindent{\tt companion} takes as argument an unitary polynomial $P$ and the 
name of its variable.\\
{\tt companion} returns the matrix whose characteristic polynomial is $P$.\\
If $P(x)=x^n+a_{n-1}x^{n-1}+...+a_{-1}x+a_0$,
this matrix is equal to the unit matrix of size $n-1$ bordered with
$[0,0..,0,-a_0]$ as first row, and with
$[-a_0,-a_1,....,-a_{n-1}]$ as last column.\\
Input :
\begin{center}{\tt companion(x\verb|^|2+5x-7,x)}\end{center}
Output :
\begin{center}{\tt  [[0,7],[1,-5]]}\end{center}
Input :
\begin{center}{\tt companion(x\verb|^|4+3x\verb|^|3+2x\verb|^|2+4x-1,x)}\end{center}
Output :
\begin{center}{\tt  [[0,0,0,1],[1,0,0,-4],[0,1,0,-2],[0,0,1,-3]]}\end{center}

\subsection{Hessenberg matrix reduction : {\tt hessenberg}}\index{hessenberg}
\noindent{\tt hessenberg} takes as argument a matrix $A$.\\
{\tt hessenberg} returns a matrix $B$ equivalent to $A$ where the 
coefficients below the sub-principal diagonal are zero. 
$B$ is a Hessenberg matrix.\\
Input :
\begin{center}{\tt hessenberg([[3,2,2,2,2],[2,1,2,-1,-1],[2,2,1,-1,1], [2,-1,-1,3,1],[2,-1,1,1,2]])}\end{center}
Output :
\begin{center}{\tt  [[3,8,5,10,2],[2,1,1/2,-5,-1],[0,2,1,8,2], [0,0,1/2,8,1],[0,0,0,-26,-3]]}\end{center}
Input 
\begin{center}
{\tt A:=[[3,2,2,2,2],[2,1,2,-1,-1],[2,2,1,-1,1],}\\
{\tt \ [2,-1,-1,3,1],[2,-1,1,1,2]] :;}\\
{\tt B:= hessenberg(A):; pcar(A); pcar(B)
}
\end{center}
Output: {\tt [1,-7,-66,-24]}.

\subsection{Hermite normal form : {\tt ihermite}}\index{ihermite}
\noindent {\tt ihermite} takes as argument a matrix {\tt A} with coefficients 
in $\mathbb Z$.\\
{\tt ihermite} returns two matrices {\tt U} and {\tt B} such that 
{\tt B=U*A}, {\tt U} is invertible in $\mathbb Z$ (det$(U) = \pm 1$)
and {\tt B} is upper-triangular. Moreover,
the absolute value of the coefficients above the diagonal of {\tt B}  are 
smaller than the pivot of the column divided by 2.

The answer is obtained by a Gauss-like reduction algorithm
using only operations of rows with integer coefficients
and invertible in $\mathbb Z$.\\
Input :
\begin{center}{\tt A:=[[9,-36,30],[-36,192,-180],[30,-180,180]]; U,B:=ihermite(A)}\end{center}
Output :
\begin{center}{\tt [[9,-36,30],[-36,192,-180],[30,-180,180]], [[13,9,7],[6,4,3],[20,15,12]],[[3,0,30],[0,12,0],[0,0,60]]}\end{center}

{\bf Application: Compute a $\mathbb Z$-basis of the kernel of a
matrix having integer coefficients}\\
Let {\tt M} be a matrix with integer coefficients.
Input :
\begin{center}
{\tt (U,A):=ihermite(transpose(M))}.
\end{center}
This returns $U$ and $A$ such that {\tt A=U*transpose(M)} hence \\
{\tt transpose(A)=M*transpose(U)}.\\
The columns of {\tt transpose(A)} which are identically 0 (at the right,
coming from the rows of $A$ which are identically 0 at the bottom)
correspond to columns of {\tt transpose(U)} which form a basis 
of {\tt Ker(M)}. In other words, the rows of {\tt A}
which are identically 0 correspond to rows of {\tt U} 
which form a basis of {\tt Ker(M)}.\\ 
{\bf Example}\\
Let {\tt  M:=[[1,4,7],[2,5,8],[3,6,9]]}. Input 
\begin{center}{\tt  U,A:=ihermite(tran(M))}\end{center}
Output
\begin{center}
{\tt  U:=[[-3,1,0],[4,-1,0],[-1,2,-1]] and A:=[[1,-1,-3],[0,3,6],[0,0,0]]}
\end{center}
Since {\tt A[2]=[0,0,0]}, a $\mathbb Z$-basis of {\tt Ker(M)} is
{\tt U[2]=[-1,2,-1]}.\\
Verification {\tt  M*U[2]=[0,0,0]}.

\subsection{Smith normal form : {\tt ismith}}\index{ismith}
\noindent {\tt ismith} takes as argument a matrix with coefficients in
$\mathbb Z$.\\
{\tt ismith} returns three matrices {\tt U,B} and {\tt V} such 
that {\tt B=U*A*V}, {\tt U} and {\tt V} are invertible in  $\mathbb Z$, 
{\tt B} is diagonal, and {\tt B[i,i]} divides {\tt B[i+1,i+1]}.
The coefficients {\tt B[i,i]} are called 
invariant factors, they are used to describe
the structure of finite abelian groups.\\
Input :
\begin{center}
{\tt A:=[[9,-36,30],[-36,192,-180],[30,-180,180]]; 
U,B,V:=ismith(A)}
\end{center}
Output :
\begin{center}{\tt
[[-3,0,1],[6,4,3],[20,15,12]],
[[3,0,0],[0,12,0],[0,0,60]], 
[[1,24,-30],[0,1,0],[0,0,1]] }
\end{center}
The invariant factors are 3, 12 and 60.

\section{Isometries}
\subsection{Recognize an isometry : {\tt isom}}\index{isom}
\noindent{\tt isom} takes as argument the matrix of an linear
application in dimension 2 or 3.\\
{\tt isom} returns :
\begin{itemize}
\item  
if the linear application is a direct isometry,\\
the list of the characteristic elements of this isometry and {\tt +1},
\item if the linear application is an indirect isometry,\\
the list of the characteristic elements of this isometry and {\tt -1} 
\item if the linear application is not an isometry,\\
{\tt [0]}.
\end{itemize}
Input :
\begin{center}{\tt isom([[0,0,1],[0,1,0],[1,0,0]])}\end{center}
Output :
\begin{center}{\tt  [[1,0,-1],-1]}\end{center}
which means that this isometry is a 3-d symmetry with respect to the plane 
$x\ -\ z\ =\ 0$.\\ 
Input :
\begin{center}{\tt isom(sqrt(2)/2*[[1,-1],[1,1]])}\end{center}
Output :
\begin{center}{\tt [pi/4,1]}\end{center}
Hence, this isometry is a 2-d rotation of angle 
$\displaystyle \frac{\pi}{4}$.\\
Input :
\begin{center}{\tt isom([[0,0,1],[0,1,0],[0,0,1]])}\end{center}
Output :
\begin{center}{\tt [0]}\end{center}
therefore this transformation is not an isometry.

\subsection{Find the matrix of an isometry : {\tt mkisom}}\index{mkisom}
{\tt mkisom} takes as argument :
\begin{itemize}
\item  In dimension 3, the list of characteristic elements 
(axis direction, angle for a rotation or normal to the plane for
a symmetry) and {\tt +1} for a direct isometry or 
{\tt -1} an indirect isometry.
\item In dimension 2,  a characteristic element (an angle or a vector) and 
{\tt +1} for a direct isometry (rotation) or {\tt -1} for an
indirect isometry (symmetry).
\end{itemize}
{\tt mkisom} returns the matrix of the corresponding isometry.\\ 
Input :
\begin{center}{\tt mkisom([[-1,2,-1],pi],1)}\end{center}
Output the matrix of the rotation of axis $[-1,2,-1]$ and angle $\pi$:
\begin{center}{\tt [[-2/3,-2/3,1/3],[-2/3,1/3,-2/3],[1/3,-2/3,-2/3]]}\end{center}
Input :
\begin{center}{\tt  mkisom([pi],-1)}\end{center}
Output the matrix of the symmetry with respect to $O$ :
\begin{center}{\tt [[-1,0,0],[0,-1,0],[0,0,-1]]}\end{center}
Input :
\begin{center}{\tt  mkisom([1,1,1],-1)}\end{center}
Output the matrix of the symmetry with respect to the plane $x+y+z=0$ :
\begin{center}{\tt [[1/3,-2/3,-2/3],[-2/3,1/3,-2/3],[-2/3,-2/3,1/3]]}\end{center}
Input :
\begin{center}{\tt mkisom([[1,1,1],pi/3],-1)}\end{center}
Output the matrix of the product of a rotation of axis $[1,1,1]$ and angle 
$\frac{\pi}{3}$ and of a symmetry with respect to the plane $x+y+z=0$:
\begin{center}{\tt  [[0,-1,0],[0,0,-1],[-1,0,0]]}\end{center}
Input :
\begin{center}{\tt mkisom(pi/2,1)}\end{center}
Output the matrix of the plane rotation of angle $\frac{\pi}{2}$ :
\begin{center}{\tt [[0,-1],[1,0]]}\end{center}
Input :
\begin{center}{\tt mkisom([1,2],-1)}\end{center}
Output matrix of the plane symmetry with respect to the line 
of equation $x+2y=0$:
\begin{center}{\tt [[3/5,-4/5],[-4/5,-3/5]]}\end{center}

\section{Matrix factorizations}\label{sec:factormatrice}
Note that most matrix factorization algorithms are implemented numerically,
only a few of them will work symbolically.

\subsection{Cholesky decomposition : {\tt cholesky}}\index{cholesky}
\noindent{\tt cholesky} takes as argument a square symetric
positive definite matrix {\tt M} of size $n$.\\
{\tt cholesky} returns a symbolic or numeric matrix {\tt P}. {\tt P} is a
lower triangular matrix  such that :
\begin{center}
{\tt tran(P)*P=M}
\end{center}
Input :
\begin{center}{\tt cholesky([[1,1],[1,5]])}\end{center}
Output :
\begin{center}{\tt [[1,0],[1,2]]}\end{center}
Input :
\begin{center}{\tt cholesky([[3,1],[1,4]])}\end{center}
Output :
\begin{center}{\tt [[sqrt(3),0],[(sqrt(3))/3,(sqrt(33))/3]]}\end{center}
Input :
\begin{center}{\tt cholesky([[1,1],[1,4]])}\end{center}
Output :
\begin{center}{\tt [[1,0],[1,sqrt(3)]]}\end{center}
{\bf Warning} If the matrix argument $A$ is not a symetric matrix,
{\tt cholesky} does not return an error, instead {\tt cholesky} will
use the symetric matrix $B$ of the the quadratic form $q$ 
corresponding to the (non symetric) bilinear form of matrix $A$.\\
Input :
\begin{center}{\tt cholesky([[1,-1],[-1,4]])}\end{center}
or :
\begin{center}{\tt cholesky([[1,-3],[1,4]])}\end{center}
Output :
\begin{center}{\tt [[1,0],[-1,sqrt(3)]]}\end{center}

\subsection{QR decomposition : {\tt qr}}\index{qr}
\noindent{\tt qr} takes as argument a numeric
square matrix $A$ of size $n$.\\
{\tt qr} factorizes  numerically 
%(symbolically when it is possible) 
this matrix as $Q*R$ where
$Q$ is an orthogonal matrix (${}^tQ*Q=I$) and $R$ is an upper triangular 
matrix. 
{\tt qr(A)} returns only {\tt R}, run {\tt Q=A*inv(R)} to get {\tt Q}.\\
Input :
\begin{center}{\tt qr([[3,5],[4,5]])}\end{center}
Output is the matrix {\tt R} :
\begin{center}{\tt [[-5,-7],[0,-1]]}\end{center}
Input :
\begin{center}{\tt qr([[1,2],[3,4]])}\end{center}
Output is the matrix {\tt R} :
\begin{center}{\tt [[-3.16227766017,-4.42718872424],[0,-0.632455532034]] }\end{center}

\subsection{QR decomposition (for TI compatibility) : {\tt QR}}\index{QR}
\noindent{\tt QR} takes as argument a numeric square matrix $A$ of size 
$n$ and two variable names, {\tt var1} and {\tt var2}.\\
{\tt QR} factorizes this matrix  numerically as $Q*R$ where
$Q$ is an orthogonal matrix (${}^tQ*Q=I$) and $R$ is an upper triangular 
matrix. {\tt QR(A,var1,var2)} returns {\tt R}, stores {\tt Q=A*inv(R)} in {\tt
  var1} and {\tt R} in {\tt var2}.\\
Input :
\begin{center}{\tt QR([[3,5],[4,5]],Q,R)}\end{center}
Output the matrix {\tt R} :
\begin{center}{\tt [[-5,-7],[0,-1]]}\end{center}
Then input :
\begin{center}{\tt Q}\end{center}
Output the matrix {\tt Q} :
\begin{center}{\tt [[-0.6,-0.8],[-0.8,0.6]]}\end{center}

\subsection{LU decomposition : {\tt lu}}\index{lu}
\noindent{\tt lu} takes as argument a square matrix $A$ of size $n$ (numeric or
symbolic).\\
{\tt lu(A)} returns a permutation $p$ of 0..$n-1$, 
a lower triangular matrix $L$, with $1$ on the diagonal, 
and an upper triangular matrix $U$, such that : 
\begin{itemize}
\item $P*A=L*U$ where $P$ is the permutation matrix 
associated to $p$ (that may be computed by {\tt P:=permu2mat(p)}),
\item the equation $A*x=B$ is equivalent to :
\[ L*U*x=P*B=p(B) \mbox{ where } p(B)=[b_{p(0)},b_{p(1)}..b_{p(n-1)}],
\quad  B=[b_0,b_1..b_{n-1}] \]
\end{itemize}
The permutation matrix $P$ is defined from $p$ by :
\[ P[i, p(i)]=1, \quad P[i, j]=0 \mbox{ if } j \ \neq\ p(i) \]
In other words, it is the identity matrix where the rows are permuted 
according to the permutation $p$. 
The function {\tt permu2mat}\index{permu2mat} may be used to compute $P$
({\tt permu2mat(p)} returns ${\tt P}$).\\ 
Input :
\begin{center}{\tt (p,L,U):=lu([[3.,5.],[4.,5.]])}\end{center}
Output :
\begin{center}{\tt [1,0],[[1,0],[0.75,1]],[[4,5],[0,1.25]]}\end{center}
Here $n=2$, hence :
\[ P[0,p(0)]=P_2[0,1]=1, \quad  P[1,p(1)]=P_2[1,0]=1, \quad
P=[[0,1],[1,0]] \]
Verification :\\
Input :
\begin{center}{\tt permu2mat(p)*A; L*U}\end{center}
Output:
\begin{center}{\tt [[4.0,5.0],[3.0,5.0]],[[4.0,5.0],[3.0,5.0]]}\end{center}
Note that the permutation is different for exact input (the choice of
pivot is the simplest instead of the largest in absolute value).\\
Input :
\begin{center}{\tt lu([[1,2],[3,4]])}\end{center}
Output :
\begin{center}{\tt [1,0],[[1,0],[3,1]],[[1,2],[0,-2]]}\end{center}
Input :
\begin{center}{\tt lu([[1.0,2],[3,4]])}\end{center}
Output :
\begin{center}{\tt [1,0],[[1,0],[0.333333333333,1]],[[3,4], [0,0.666666666667]]}\end{center}

\subsection{LU decomposition (for TI compatibility) : {\tt LU}}\index{LU}
\noindent{\tt LU} takes as argument a numeric
square matrix $A$ of size $n$ and three variable names, {\tt var1}, 
{\tt var2} and {\tt var3}.\\
{\tt LU(A,var1,var2,var3)} returns $P$, a permutation matrix, and stores :
\begin{itemize}
\item a lower triangular matrix $L$, with $1$ on the diagonal, in 
{\tt var1},
\item an upper triangular matrix $U$ in {\tt var2},
\item the permutation matrix $P$, result of the command {\tt LU}, in 
{\tt var3}.
\end{itemize}
These matrix are such that 
\begin{center}
the equation $A*x=B$ is equivalent to $L*U*x=P*B$.
\end{center}
Input :
\begin{center}{\tt LU([[3,5],[4,5]],L,U,P)}\end{center}
Output :
\begin{center}{\tt [[0,1],[1,0]]}\end{center}
Input :
\begin{center}{\tt L}\end{center}
Output :
\begin{center}{\tt [[1,0],[0.75,1]]}\end{center}
Input :
\begin{center}{\tt U}\end{center}
Output :
\begin{center}{\tt [[4,5],[0,1.25]]}\end{center}
Input :
\begin{center}{\tt P}\end{center}
Output :
\begin{center}{\tt [[0,1],[1,0]]}\end{center}

\subsection{Singular value decomposition : {\tt svd}}\index{svd}
\noindent{\tt svd} (singular value decomposition) takes as argument a numeric
square matrix of size $n$.\\
{\tt svd(A)} returns an orthogonal matrix $U$, the diagonal $s$ of a diagonal
matrix $S$ and an orthogonal matrix $Q$ (${}^tQ*Q=I$) such that :
\[ A=U.S.{}^tQ \]
Input :
\begin{center}{\tt svd([[1,2],[3,4]])}\end{center}
Output :
\begin{center}{\tt [[-0.404553584834,-0.914514295677],[-0.914514295677, 0.404553584834]], [5.46498570422,0.365966190626], [[-0.576048436766,0.81741556047],[-0.81741556047, -0.576048436766]]}\end{center}
Input :
\begin{center}{\tt (U,s,Q):=svd([[3,5],[4,5]])}\end{center}
Output :
\begin{center}{\tt [[-0.672988041811,-0.739653361771],[-0.739653361771, 0.672988041811]],[8.6409011028,0.578643354497], [[-0.576048436766,0.81741556047],[-0.81741556047, -0.576048436766]]}\end{center}
Verification :
Input :
\begin{center}{\tt U*diag(s)*tran(Q)}\end{center}
Output :
\begin{center}{\tt [[3.0,5.0],[4.0,5.0]]}\end{center}

\subsection{Short basis of a lattice : {\tt lll}}\index{lll}
\noindent{\tt lll} takes as argument an invertible matrix $M$ with
integer coefficients.\\
{\tt lll} returns $(S,A,L,O)$ such that:
\begin{itemize}
\item the rows of $S$ is a short basis of the $\mathbb Z$-module 
generated by the rows of $M$,
\item $A$ is the change-of-basis matrix from the short basis to the basis 
defined by the rows of $M$ ($A*M=S$),
\item $L$ is a lower triangular matrix, the modulus of it's non diagonal
coefficients are less than 1/2,
\item $O$ is a matrix with orthogonal rows such that $L*O=S$.
\end{itemize}
% If in 2 dimension, $[a,b]$ are  coordinates of a vector system in the basis 
% defined by $M$ and if  $[a1,b1]$ are its coordinates in the short basis 
% defined by  $S$ i.e. if $[a,b]*M=[a1,b1]*S$, then :\\ 
% $[a,b]=[a1,b1]*A$\\
% $[a1,b1]*S=[a1,b1]*A*M=[a,b]*M$ et\\
% $[a,b]*M=[a,b]*A^{-1}*S=[a1,b1]*S$\\
Input :
\begin{center}{\tt (S,A,L,O):=lll(M:=[[2,1],[1,2]])}\end{center}
Output :
\begin{center}{\tt [[-1,1],[2,1]], [[-1,1],[1,0]], [[1,0],[1/-2,1]], [[-1,1],[3/2,3/2]]}\end{center}
Hence :\\
{\tt S=[[-1,1],[2,1]]}\\
{\tt A=[[-1,1],[1,0]]}\\
{\tt L=[[1,0],[1/-2,1]]}\\
{\tt O=[[-1,1],[3/2,3/2]]}\\
Hence the original basis is {\tt v1=[2,1], v2=[1,2]}\\
and the short basis is {\tt w1=[-1,1], w2=[2,1]}.\\
Since {\tt w1=-v1+v2} and {\tt w2=v1} then :\\
{\tt A:=[[-1,1],[1,0]]}, {\tt A*M==S} and {\tt L*O==S}.\\
Input :
\begin{center}{\tt (S,A,L,O):=lll([[3,2,1],[1,2,3],[2,3,1]])}\end{center}
Output :
\begin{center}{\tt S=[[-1,1,0],[-1,-1,2],[3,2,1]] }\end{center}
\begin{center}{\tt A= [[-1,0,1],[0,1,-1],[1,0,0]]}\end{center}
\begin{center}{\tt L= [[1,0,0],[0,1,0],[(-1)/2,(-1)/2,1]]}\end{center}
\begin{center}{\tt O= [[-1,1,0],[-1,-1,2],[2,2,2]]}\end{center}
Input :\\
{\tt M:=[[3,2,1],[1,2,3],[2,3,1]]}\\
Properties :\\
{\tt A*M==S} and {\tt L*O==S}

\section{Quadratic forms}
\subsection{Matrix of a quadratic form : {\tt q2a}}\index{q2a} 
\noindent{\tt q2a} takes two arguments : the symbolic expression
of a quadratic form $q$ and a
vector of variable names.\\ 
{\tt q2a} returns the matrix $A$ of $q$.\\ 
Input :
\begin{center}{\tt q2a(2*x*y,[x,y])}\end{center}
Output :
\begin{center}{\tt  [[0,1],[1,0]]}\end{center}

\subsection{Transform a matrix into a quadratic form : {\tt a2q}}\index{a2q}
\noindent{\tt a2q} takes two arguments : the symetric matrix $A$ 
of a quadratic 
form $q$ and a vector of variable names of the same size.\\
{\tt a2q} returns the symbolic expression of quadratic form $q$.\\   
Input :
\begin{center}{\tt a2q([[0,1],[1,0]],[x,y])}\end{center}
Output :
\begin{center}{\tt 2*x*y}\end{center}
Input :
\begin{center}{\tt a2q([[1,2],[2,4]],[x,y]) }\end{center}
Output :
\begin{center}{\tt x\verb|^|2+4*x*y+4*y\verb|^|2}\end{center}

\subsection{Reduction of a quadratic form : {\tt gauss}}\index{gauss}
\noindent{\tt gauss} takes two arguments : a symbolic expression
representing a quadratic form $q$ and a 
vector of variable names.\\ 
{\tt gauss} returns  $q$ written as sum or difference of squares
using Gauss algorithm.\\      
Input :
\begin{center}{\tt gauss(2*x*y,[x,y])}\end{center}
Output :
\begin{center}{\tt (y+x)\verb|^|2/2+(-(y-x)\verb|^|2)/2}\end{center}

\subsection{Gramschmidt orthonormalization : {\tt gramschmidt}}\index{gramschmidt}
\noindent{\tt gramschmidt} takes one or two arguments : 
\begin{itemize}
\item a matrix viewed as a list of row vectors, 
the scalar product being the canonical
  scalar product, or
\item a list of elements 
that is a basis of a vector subspace, and a function that defines a scalar 
product on this vector space.
\end{itemize}
{\tt gramschmidt} returns an orthonormal basis for this scalar product.\\ 
Input :
\begin{center}{\tt normal(gramschmidt([[1,1,1],[0,0,1],[0,1,0]]))}\end{center}
Or input :
\begin{center}{\tt normal(gramschmidt([[1,1,1],[0,0,1],[0,1,0]],dot))}\end{center}
Output :
\begin{center}{\tt [[(sqrt(3))/3,(sqrt(3))/3,(sqrt(3))/3],[(-(sqrt(6)))/6,(-(sqrt(6)))/6,(sqrt(6))/3],[(-(sqrt(2)))/2,(sqrt(2))/2,0]]}\end{center}
{\bf Example}\\
We define a scalar product on the vector space of 
polynomials by: 
$$P.Q=\int_{-1}^1P(x).Q(x)dx $$
Input :
 \begin{center}{\tt gramschmidt([1,1+x],(p,q)->integrate(p*q,x,-1,1))}\end{center}
Or define the function {\tt p\_scal}, input :\\
{\tt p\_scal(p,q):=integrate(p*q,x,-1,1)}\\
then input :
\begin{center}{\tt gramschmidt([1,1+x],p\_scal)}\end{center}
Output :
\begin{center}{\tt [1/(sqrt(2)),(1+x-1)/sqrt(2/3)]}\end{center}

\subsection{Graph of a conic : {\tt conique}}\index{conique}
\noindent{\tt conique} takes as argument the equation of a conic with
respect to $x,y$. You may also specify the names of the variables as
second and third argument or as a vector as second argument.\\ 
{\tt conique} draws this conic.\\
Input :
\begin{center}{\tt conique(2*x\verb|^|2+2*x*y+2*y\verb|^|2+6*x)}\end{center}
Output :
\begin{center}{\tt the graph of the ellipsis of center -2+i and equation 2*x\verb|^|2+2*x*y+2*y\verb|^|2+6*x=0}\end{center}
{\bf Remark} :\\
See also {\tt conique\_reduite} for the parametric equation of the conic.

\subsection{Conic reduction : {\tt conique\_reduite}}\index{conique\_reduite}
\noindent{\tt conique\_reduite} takes two arguments : the equation of a conic
and a vector of variable names.\\ 
{\tt conique\_reduite} returns a list whose elements are:
\begin{itemize}
\item the origin of the conic,
\item the matrix of a basis in which the conic is reduced, 
\item 0 or 1 (0 if the conic is degenerated), 
\item the reduced equation of the conic 
\item a vector of it's parametric equations.
\end{itemize}  
Input :
\begin{center}{\tt conique\_reduite(2*x\verb|^|2+2*x*y+2*y\verb|^|2+5*x+3,[x,y])}\end{center}
Output :
\begin{center}{\tt [[-5/3,5/6],[[-1/(sqrt(2)),1/(sqrt(2))],[-1/(sqrt(2)), -1/(sqrt(2))]],1,3*x\verb|^|2+y\verb|^|2+-7/6,[[(-10+5*i)/6+ (1/(sqrt(2))+(i)/(sqrt(2)))*((sqrt(14)*cos(`~t`))/6+ ((i)*sqrt(42)*sin(` t`))/6),` t`,0,2*pi,(2*pi)/60]]]}\end{center}
Which means that the conic is not degenerated, it's reduced equation is 
\[3x^2+y^2-7/6=0 \] 
origin is $-5/3+5*i/6$, axis are
parallel to the vectors $(-1,1)$ and $(-1,-1)$.
It's parametric equation is
\[ \displaystyle \frac{-10+5*i}{6}+
\frac{(1+i)}{\sqrt 2}*\frac{(\sqrt{14}*cos(t)+i*\sqrt{42}*sin(t))}{6}
\]
where the suggested parameters value for drawing are
$t$ from 0 to $2\pi$ with {\tt tstep}= $2\pi/60$.

{\bf Remark} :\\
Note that if the conic is degenerated and is made of 1 or 2 line(s), 
the lines are not given by 
their parametric equation but by the list of two points of the line.\\ 
Input :
\begin{center}{\tt conique\_reduite(x\verb|^|2-y\verb|^|2+3*x+y+2)}\end{center}
Output :
\begin{center}{\tt [[(-3)/2,1/2],[[1,0],[0,1]],0,x\verb|^;|2-y\verb|^|2, [[(-1+2*i)/(1-i),(1+2*i)/(1-i)], [(-1+2*i)/(1-i),(-1)/(1-i)]]]}\end{center}

\subsection{Graph of a quadric : {\tt quadrique}}\index{quadrique}
\noindent{\tt quadrique} takes as arguments the expression of a
quadric with respect to $x,y,z$. You may also specify the variables
as a vector (second argument) or as second, third and fourth arguments.\\ 
{\tt quadrique} draws this quadric.\\
Input :
\begin{center}{\tt quadrique(7*x\verb|^|2+4*y\verb|^|2+4*z\verb|^|2+4*x*y- 4*x*z-2*y*z-4*x+5*y+4*z-18)}\end{center}
Output :
\begin{center}{\tt the drawing of the ellipsoid of equation 7*x\verb|^|2+4*y\verb|^|2+4*z\verb|^|2+4*x*y-4*x*z-2*y*z-4*x+5*y+4*z-18=0}\end{center}
See also {\tt quadrique\_reduite} for
the parametric equation of the quadric.

\subsection{Quadric reduction : {\tt quadrique\_reduite}}\index{quadrique\_reduite}
\noindent{\tt quadrique\_reduite} takes two arguments : the equation of a 
quadric and a vector of variable names.\\ 
{\tt quadrique\_reduite} returns a list whose elements are:
\begin{itemize}
\item the origin, 
\item the matrix of a basis where the quadric is reduced, 
\item 0 or 1 (0 if the quadric is degenerated), 
\item the reduced equation of the quadric 
\item a vector with its parametric equations.
\end{itemize}  
{\bf Warning !} 
{\tt u,v} will be used as parameters of the parametric equations : 
these variables should not be assigned ({\tt purge} them before
calling {\tt quadrique\_reduite}).\\
Input :
\begin{center}{\tt quadrique\_reduite(7*x\verb|^|2+4*y\verb|^|2+4*z\verb|^|2+ 4*x*y-4*x*z-2*y*z-4*x+5*y+4*z-18)}\end{center}
Output is a list containing :
\begin{itemize}
\item The origin (center of symmetry) of the quadric
\begin{center}{\tt [11/27,(-26)/27,(-29)/54],}\end{center}
\item The matrix of the basis change:
\begin{center}{\tt  [[(sqrt(6))/3,(sqrt(5))/5,(-(sqrt(30)))/15],
    [(sqrt(6))/6,0,(sqrt(30))/6],
    [(-(sqrt(6)))/6,(2*sqrt(5))/5,(sqrt(30))/30]],}\end{center}
\item 1 hence the quadric is not degenerated
\item the reduced equation of the quadric :
\begin{center}{\tt
    0,9*x\verb|^|2+3*y\verb|^|2+3*z\verb|^|2+(-602)/27,}\end{center} 
\item
The parametric equations (in the original frame) are :
\begin{center}{\tt [[(sqrt(6)*sqrt(602/243)*sin(u)*cos(v))/3+
    (sqrt(5)*sqrt(602/81)*sin(u)*sin(v))/5+
    ((-(sqrt(30)))*sqrt(602/81)*cos(u))/15+11/27,
    (sqrt(6)*sqrt(602/243)*sin(u)*cos(v))/6+
    (sqrt(30)*sqrt(602/81)*cos(u))/6+(-26)/27,
    ((-(sqrt(6)))*sqrt(602/243)*sin(u)*cos(v))/6+
    (2*sqrt(5)*sqrt(602/81)*sin(u)*sin(v))/5+
    (sqrt(30)*sqrt(602/81)*cos(u))/30+(-29)/54], 
     u=(0 .. pi),v=(0.. (2*pi)),ustep=(pi/20),
     vstep=((2*pi)/20)]]}\end{center}
\end{itemize}
Hence the quadric is an ellipsoid and its reduced equation is :
\[ 9*x^2+3*y^2+3*z^2+(-602)/27 \]
after the change of origin $[11/27,(-26)/27,(-29)/54]$,
the matrix of basis change {\tt P} is :
\[ \left[
\begin{array}{ccc}
\displaystyle \frac{\sqrt 6}{3} & \displaystyle\frac{\sqrt 5}{5} & \displaystyle-\frac{\sqrt{30}}{15}\\
\displaystyle \frac{\sqrt 6}{6} & 0 & \displaystyle \frac{\sqrt{30}}{6}\\
\displaystyle -\frac{\sqrt 6}{6} & \displaystyle \frac{2\sqrt{5}}{5} & \displaystyle \frac{\sqrt{30}}{30}\\
\end{array}
\right] \]
Its parametric equation is :
\[ \left\{
\begin{array}{l}
x =\displaystyle \frac{\sqrt 6\sqrt{\frac{602}{243}}\sin(u)\cos(v)}{3}+\frac{\sqrt 5\sqrt{\frac{602}{81}}\sin(u)\sin(v)}{5}-\frac{\sqrt{30}\sqrt{\frac{602}{81}}\cos(u)}{15}+\frac{11}{27}\\
y =\displaystyle \frac{\sqrt 6\sqrt{\frac{602}{243}}\sin(u)\cos(v)}{6}+\frac{\sqrt{30}\sqrt{\frac{602}{81}}\cos(u))}{6}-\frac{26}{27}\\
z =\displaystyle \frac{-\sqrt 6\sqrt{\frac{602}{243}}*\sin(u)\cos(v)}{6}+\frac{2\sqrt 5\sqrt{\frac{602}{81}}\sin(u)\sin(v)}{5}+\frac{\sqrt{30}\sqrt{\frac{602}{81}}\cos(u)}{30}-\frac{29}{54}
\end{array}
\right. 
\]
{\bf Remark} :\\
Note that if the quadric is degenerated and made of 1 or 2 plan(s), 
each plan is not given by 
its parametric equation but by the list of a point of the plan
and of a normal vector to the plan.\\ 
Input :
\begin{center}{\tt quadrique\_reduite(x\verb|^|2-y\verb|^|2+3*x+y+2)}\end{center}
Output :
\begin{center}{\tt [[(-3)/2,1/2,0],[[1,0,0],[0,1,0],[0,0,-1]],0,x\verb|^|2-y\verb|^|2, [hyperplan([1,1,0],[(-3)/2,1/2,0]), hyperplan([1,-1,0],[(-3)/2,1/2,0])]]}\end{center}

 \section{Multivariate calculus}\label{sec:plusvar}
\subsection{Gradient : {\tt derive deriver diff grad}}\index{derive}\index{diff}\index{grad}\index{deriver}\label{sec:derive}\index{solve}\index{resoudre}
\noindent{\tt derive} (or {\tt diff} or {\tt grad}) takes two arguments : an 
expression $F$ of $n$ real variables and a vector of these variable names.\\
{\tt derive} returns the gradient of $F$,
where the gradient is the vector of all partial derivatives,
for exmple in dimension $n=3$
\[ \overrightarrow{\mbox{grad}}(F)= [\frac{\partial F}{\partial x},\frac{\partial F}{\partial y},\frac{\partial F}{\partial z}] \]
{\bf Example} \\
Find the gradient of $F(x,y,z)=2x^2y-xz^3$.\\
Input :
\begin{center}{\tt derive(2*x\verb|^|2*y-x*z\verb|^|3,[x,y,z])}\end{center}
Or :
\begin{center}{\tt diff(2*x\verb|^|2*y-x*z\verb|^|3,[x,y,z])}\end{center}
Or :
\begin{center}{\tt grad(2*x\verb|^|2*y-x*z\verb|^|3,[x,y,z])}\end{center}
Output :
\begin{center}{\tt [2*2*x*y-z\verb|^|3,2*x\verb|^|2,-(x*3*z\verb|^|2)]}\end{center}
Output after simplification with {\tt normal(ans())} :
\begin{center}{\tt [4*x*y-z\verb|^|3,2*x\verb|^|2,-(3*x*z\verb|^|2)]}\end{center}
To find the critical points of 
$F(x,y,z)=2x^2y-xz^3$, input :
\begin{center}{\tt solve(derive(2*x\verb|^|2*y-x*z\verb|^|3,[x,y,z]),[x,y,z])}\end{center} 
Output :
\begin{center}{\tt [[0,y,0]]}\end{center} 

\subsection{Laplacian : {\tt laplacian}}\index{laplacian}
\noindent{\tt laplacian} takes two arguments : an 
expression $F$ of $n$ real variables and a vector of these variable names.\\
{\tt laplacian} returns the laplacian de $F$, that is the sum of all second
partial derivatives, for example in dimension $n=3$:
\[ \nabla^2(F)=\frac{\partial^2 F}{\partial x^2}+\frac{\partial^2 F}{\partial y^2}+\frac{\partial^2 F}{\partial z^2} \]
{\bf Example}\\
Find the laplacien of $F(x,y,z)=2x^2y-xz^3$.\\
Input :
\begin{center}{\tt laplacian(2*x\verb|^|2*y-x*z\verb|^|3,[x,y,z])}\end{center}
Output :
\begin{center}{\tt 4*y+-6*x*z}\end{center}

\subsection{Hessian matrix : {\tt hessian}}\index{hessian}
\noindent{\tt hessian}  takes two arguments : an 
expression $F$ of $n$ real variables and a vector of these variable names.\\
{\tt hessian} returns the hessian matrix of $F$, that is the matrix of the 
derivatives of order 2.\\
{\bf Example}\\
Find the hessian matrix of $F(x,y,z)=2x^2y-xz^3$.\\
Input :
\begin{center}{\tt hessian(2*x\verb|^|2*y-x*z\verb|^|3 , [x,y,z])}\end{center}
Output :
\begin{center}{\tt[[4*y,4*x,-(3*z\verb|^|2)],[2*2*x,0,0],[-(3*z\verb|^|2),0,x*3*2*z]]}\end{center}
To have the hessian matrix at the critical points, first input :
\begin{center}{\tt solve(derive(2*x\verb|^|2*y-x*z\verb|^|3,[x,y,z]),[x,y,z])}\end{center} 
Output is the critical points : 
\begin{center}{\tt [[0,y,0]]}\end{center}
Then, to have the hessian matrix at this points, input : 
\begin{center}{\tt subst([[4*y,4*x,-(3*z\verb|^|2)],[2*2*x,0,0], [-(3*z\verb|^|2),0,6*x*z]],[x,y,z],[0,y,0])}\end{center}
Output :
\begin{center}{\tt [[4*y,4*0,-(3*0\verb|^|2)],[4*0,0,0],[-(3*0\verb|^|2),0,6*0*0]]}\end{center}
and after simplification :
\begin{center}{\tt [[4*y,0,0],[0,0,0],[0,0,0]]}\end{center}

\subsection{Divergence : {\tt divergence}}\index{divergence}
\noindent{\tt divergence} takes two arguments : a vector 
field of dimension $n$ depending on $n$ real variables.\\
{\tt divergence} returns the divergence of $F$ that is the sum 
of the derivative of the $k$-th component with respect
to the $k$-th variable. For example in dimension $n=3$:
\begin{center}
  {\tt divergence([A,B,C],[x,y,z])}=$\displaystyle\frac{\partial A}{\partial x}+\frac{\partial B}{\partial y}+\frac{\partial C}{\partial z}$
\end{center}
Input :
\begin{center}{\tt divergence([x*z,-y\verb|^|2,2*x\verb|^|y],[x,y,z])}\end{center}
Output :
\begin{center}{\tt z+-2*y}\end{center}

\subsection{Rotationnal : {\tt curl}}\index{curl}
\noindent{\tt curl}  takes two arguments : a 3-d vector field
depending on 3 variables.\\
{\tt curl} returns the rotationnal of the vector, defined by:
\begin{center}
{\tt curl([A,B,C],[x,y,z])}=$\displaystyle [\frac{\partial C}{\partial y}-\frac{\partial B}{\partial z},\ \frac{\partial A}{\partial z}-\frac{\partial C}{\partial x},\ \frac{\partial B}{\partial x}-\frac{\partial A}{\partial y}]$
\end{center}
Note that $n$ {\bf must be equal to 3}.\\
Input :
\begin{center}{\tt curl([x*z,-y\verb|^|2,2*x\verb|^|y],[x,y,z])}\end{center}
Output :
\begin{center}{\tt [2*x\verb|^|y*log(x),x-2*y*x\verb|^|(y-1),0]}\end{center}

\subsection{Potential : {\tt potential}}\index{potential}
\noindent{\tt potential} takes two arguments : a vector field
$\overrightarrow V$ in $R^n$ with respect to $n$ real variables 
and the vector of these variable names.\\
{\tt  potential} returns, if it is possible, a function $U$ such that 
$\overrightarrow{\mbox{grad}}(U)=\overrightarrow V$. When it is possible we
say that $\overrightarrow V$ derive of the potential $U$, and
$U$ is defined up to a constant.\\
{\tt  potential} is the reciprocal function of {\tt derive}.\\
Input :
\begin{center}{\tt potential([2*x*y+3,x\verb|^|2-4*z,-4*y],[x,y,z])}\end{center}
Output :
\begin{center}{\tt 2*y*x\verb|^|2/
2+3*x+(x\verb|^|2-4*z-2*x\verb|^|2/2)*y}\end{center}
Note that in $\R^3$ 
a vector $\overrightarrow V$ is a gradient if and only if it's 
rotationnal is zero i.e. if {\tt curl(V)=0}.
In time-independant electro-magnetism, 
$\overrightarrow V$=$\overrightarrow E$ is the
electric field and $U$ is the electric potential.

\subsection{Conservative flux field : {\tt vpotential}}\index{vpotential}
\noindent{\tt  vpotential} takes two arguments : a vector field
$\overrightarrow V$ 
in $R^n$ with respect to $n$ real variables 
and the vector of these variable names.\\
{\tt  vpotential} returns, if it is possible, a vector $\overrightarrow U$ such
that $\overrightarrow{\mbox{curl}}(\overrightarrow U)=\overrightarrow V$.
When it is possible we say that  $\overrightarrow V$ is a conservative flux 
field or a solenoidal field.
The general solution is the sum of a particular solution and of the
gradient of an arbitrary function, {\tt Xcas} returns a particular
solution with zero as first component.\\ 
{\tt  vpotential} is the reciprocal function of {\tt curl}.\\
Input :
\begin{center}{\tt vpotential([2*x*y+3,x\verb|^|2-4*z,-2*y*z],[x,y,z]) }\end{center}
Output :~
\begin{center}{\tt [0,(-(2*y))*z*x,-x\verb|^|3/3-(-(4*z))*x+3*y]}\end{center}
In $\R^3$, a vector field $\overrightarrow V$ is a rotationnal  
if and only if it's 
divergence is zero \\({\tt divergence(V,[x,y,z])=0}).
In time-independant electro-magnetism,
$\overrightarrow V$= $\overrightarrow B$ is the magnetic field and
$\overrightarrow U$= $\overrightarrow A$ is the potential vector.

\section{Equations}
\subsection{Define an equation : {\tt equal}}\index{equal}
\noindent{\tt equal} takes as argument the two member of an equation.\\
{\tt equal} returns this equation. It is the prefixed version of {\tt =}\\
Input :
\begin{center}{\tt equal(2x-1,3)}\end{center}
Output :
\begin{center}{\tt (2*x-1)=3}\end{center}
We can also directly write {\tt (2*x-1)=3}.

\subsection{Transform an equation into a difference : {\tt equal2diff}}\index{equal2diff}
\noindent{\tt equal2diff} takes as argument an equation.\\
{\tt equal2diff} returns the difference of the two members of this equation.\\
Input :
\begin{center}{\tt equal2diff(2x-1=3)}\end{center}
Output :
\begin{center}{\tt 2*x-1-3}\end{center}

\subsection{Transform an equation into a list : {\tt equal2list}}\index{equal2list}
\noindent{\tt equal2list} takes as argument an equation.\\
{\tt equal2list} returns the list of the two members of this equation.\\
Input :
\begin{center}{\tt equal2list(2x-1=3)}\end{center}
Output :
\begin{center}{\tt [2*x-1,3]}\end{center}

\subsection{The left member of an equation : {\tt left  gauche lhs}}\index{left|textbf}\index{lhs|textbf}\index{gauche|textbf}
\noindent{\tt left} or {\tt lhs} takes as argument an equation or an 
interval.\\
{\tt left}  or {\tt lhs} returns the left member of this equation or the left
bound  of this interval.\\
Input :
\begin{center}{\tt left(2x-1=3)}\end{center}
Or input:
\begin{center}{\tt lhs(2x-1=3)}\end{center}
Output :
\begin{center}{\tt 2*x-1}\end{center}
Input :
\begin{center}{\tt left(1..3)}\end{center}
Or input:
\begin{center}{\tt lhs(1..3)}\end{center}
Output :
\begin{center}{\tt 1}\end{center}

\subsection{The right member of an equation : {\tt right  droit rhs}}\index{right|textbf}\index{rhs|textbf} \index{droit|textbf}
\noindent{\tt right} or {\tt rhs} takes as argument an quation or an 
interval.\\
{\tt right}  or  {\tt rhs} returns the right member of this equation or the 
right bound of this interval.\\
Input :
\begin{center}{\tt right(2x-1=3)}\end{center}
Or :
\begin{center}{\tt rhs(2x-1=3)}\end{center}
Output :
\begin{center}{\tt 3}\end{center}
Input :
\begin{center}{\tt right(1..3)}\end{center}
Or :
\begin{center}{\tt rhs(1..3)}\end{center}
Output :
\begin{center}{\tt 3}\end{center}

\subsection{Solving equation(s): {\tt solve}}\index{solve|textbf}
\noindent{\tt solve} solves an equation or a system of polynomial
equations. It takes 2 arguments:
\begin{itemize}
\item Solving an equation\\
{\tt solve} takes as arguments  an equation between two expressions or an 
expression ({\tt =0} is omitted), and a variable name (by default {\tt x}).\\
{\tt solve}  solves this equation.
\item Solving a system of polynomial equations\\
{\tt solve} takes as arguments two vectors : 
a vector of polynomial equations and a 
vector of variable names. \\ 
{\tt solve} solves this polynomial equation system.
\end{itemize}
{\bf Remarks}:
\begin{itemize}
\item In real mode, {\tt solve} returns only real solutions. To have 
the complex solutions, switch to complex mode, e.g. by checking 
{\tt Complex} in the cas configuration, or use the {\tt cSolve}
command.
\item
For trigonometric equations, {\tt solve} returns by default the principal
solutions. To have all the solutions check {\tt All\_trig\_sol} in the cas
configuration.
\end{itemize}
{\bf Examples} :
\begin{itemize}
\item Solve $x^4-1=3$\\
 Input :
\begin{center}{\tt  solve(x\verb|^|4-1=3)}\end{center}
Output in real mode :
\begin{center}{\tt [sqrt(2),-(sqrt(2))]}\end{center}
Output in complex mode :
\begin{center}{\tt [sqrt(2),-(sqrt(2)),(i)*sqrt(2),-((i)*sqrt(2))]}\end{center}
\item Solve $\exp(x)=2$ \\
Input :
\begin{center}{\tt  solve(exp(x)=2)}\end{center}
Output in real mode :
\begin{center}{\tt [log(2)]}\end{center}
\item Find $x,y$ such that $x+y=1,x-y=0$\\
 Input :
\begin{center}{\tt  solve([x+y=1,x-y],[x,y])}\end{center}
Output :
\begin{center}{\tt [[1/2,1/2]] }\end{center}
\item Find $x,y$ such that $x^2+y=2,x+y^2=2$\\
Input :
\begin{center}{\tt  solve([x\verb|^|2+y=2,x+y\verb|^|2=2],[x,y])}\end{center}
Output :
\begin{center}{\tt [[-2,-2],[1,1],[(-sqrt(5)+1)/2,(1+sqrt(5))/2],}\end{center}
\begin{center}{\tt [(sqrt(5)+1)/2,(1-sqrt(5))/2]] }\end{center}
\item Find $x,y,z$ such that $x^2-y^2=0,x^2-z^2=0$\\
Input :
\begin{center}{\tt  solve([x\verb|^|2-y\verb|^|2=0,x\verb|^|2-z\verb|^|2=0],[x,y,z])}\end{center}
Output :
\begin{center}{\tt [[x,x,x],[x,-x,-x],[x,-x,x],[x,x,-x]]}\end{center}
\item Solve $\cos(2*x)=1/2$\\
Input :
\begin{center}{\tt  solve(cos(2*x)=1/2)}\end{center}
Output :
\begin{center}{\tt [pi/6,(-pi)/6]}\end{center}
Output with {\tt All\_trig\_sol} checked :
\begin{center}{\tt [(6*pi*n\_0+pi)/6,(6*pi*n\_0-pi)/6]}\end{center}
\item
Find the intersection of a straight line 
(given by a list of equations) and a plane.\\ For example,
let $D$ be the straight line of cartesian equations 
$[y-z=0,z-x=0]$ and let $P$ the plane of equation $x-1+y+z=0$.
Find the intersection of $D$ and $P$.\\
Input :
\begin{center}{\tt solve([[y-z=0,z-x=0],x-1+y+z=0],[x,y,z])}\end{center}
Output :
\begin{center}{\tt [[1/3,1/3,1/3]]}\end{center}
\end{itemize}

\subsection{Equation solving in $\mathbb C$ : {\tt cSolve}}\index{cSolve}
\noindent{\tt cSolve} takes two arguments and solves an equation or a system
of polynomial equations.
\begin{itemize}
\item solving an equaion\\
{\tt cSolve} takes as arguments an equation between two expressions or an 
expression ({\tt =0} is omitted), and a variable name (by default {\tt x}).\\
{\tt cSolve} solves this equation in $\mathbb C$ even if you are in
real mode.
\item solving system of polynomial equations\\
{\tt cSolve} takes as arguments two vectors : a vector of polynomial equations 
and a vector of variable names. \\
{\tt cSolve} solves this equation system in $\mathbb C$ even if you are in
real mode.
\end{itemize}
Input :
\begin{center}{\tt  cSolve(x\verb|^|4-1=3)}\end{center}
Output :
\begin{center}{\tt [sqrt(2),-(sqrt(2)),(i)*sqrt(2),-((i)*sqrt(2))]}\end{center}
Input :
\begin{center}{\tt  cSolve([-x\verb|^|2+y=2,x\verb|^|2+y],[x,y])}\end{center}
Output :
\begin{center}{\tt [[i,1],[-i,1]]}\end{center}


\section{Linear systems}
In this paragraph, we call "augmented matrix" of the system
$A \cdot X=B$ (or matrix "representing" the system $A \cdot X=B$),
the matrix obtained by gluing the column vector $B$ or $-B$
to the right of the matrix $A$, as with {\tt border(A,tran(B))}.
   
\subsection{Matrix of a system : {\tt syst2mat}}\index{syst2mat}
\noindent{\tt syst2mat} takes two vector as argument. The components of the 
first vector are the equations of a linear system and the components of the
second vector are the variable names.\\
{\tt syst2mat} returns the augmented matrix of the system $AX=B$,
obtained by gluing the column vector $-B$
to the right of the matrix $A$.\\
Input :
\begin{center}{\tt syst2mat([x+y,x-y-2],[x,y])}\end{center}
Output :
\begin{center}{\tt [[1,1,0],[1,-1,-2]]}\end{center}
Input :
\begin{center}{\tt syst2mat([x+y=0,x-y=2],[x,y])}\end{center}
Output :
\begin{center}{\tt [[1,1,0],[1,-1,-2]]}\end{center}
{\bf Warning !!!}\\
The variables (here {\tt x} and {\tt y}) must be purged.

\subsection{Gauss reduction of a matrix : {\tt ref}}\index{ref}\label{ref} \label{sec:ref}
\noindent{\tt ref} is used to solve a linear system of equations written in
matrix form:
 \begin{center}{\tt A*X=B}\end{center}
The argument of {\tt ref} is the augmented matrix of the system
(the matrix obtained by augmenting the matrix {\tt A} to the right with
the column vector {\tt B}).\\
The result is a matrix {\tt [A1,B1]} where {\tt A1} has zeros
under its principal diagonal, and the solutions of:
\begin{center}{\tt A1*X=B1}\end{center} 
are the same as the solutions of:
\begin{center}{\tt A*X=B}\end{center}

For example, solve the system :
\[ \left \{
\begin{array}{lcr} 3x + y & = &-2 \\3x +2y & =& 2 \end{array}\right.
\] 
Input  :
\begin{center}{\tt ref([[3,1,-2],[3,2,2]])}\end{center}
Output :
\begin{center}{\tt [[1,1/3,-2/3],[0,1,4]]}\end{center}
Hence the solution is $y=4$ (last row) and $x=-2$ (substitute $y$ 
in the first row).

\subsection{Gauss-Jordan reduction: {\tt rref gaussjord}}\index{rref|textbf}\index{gaussjord|textbf}\label{sec:rref}
\noindent{\tt rref} solves a linear system of equations written in
matrix form (see also \ref{sec:rrefm}) :
 \begin{center}{\tt A*X=B}\end{center}
{\tt rref} takes one or two arguments.
\begin{itemize}
\item
If {\tt rref}  has only one argument, this argument is the augmented matrix 
of the system (the matrix obtained by augmenting matrix {\tt A} to the 
right with the column vector {\tt B}).\\
The result is a matrix {\tt [A1,B1]} : {\tt A1} has zeros both above and under 
its principal diagonal and has 1 on its principal diagonal, and the solutions 
of:
\begin{center}{\tt A1*X=B1}\end{center} 
are the same as :
\begin{center}{\tt A*X=B}\end{center}
For example, to solve the system:
\[
\left \{
\begin{array}{lcr} 3x + y & = &-2 \\3x +2y & =& 2 \end{array}\right.
\] 
input :
\begin{center}{\tt rref([[3,1,-2],[3,2,2]])}\end{center}
Output :
\begin{center}{\tt [[1,0,-2],[0,1,4]]}\end{center}
Hence $x=-2$ and $y=4$ is the solution of this system.

\noindent{\tt rref} can also solve several linear systems
of equations having the same first member.
We write the second members as a column matrix.\\ 
Input  :
\begin{center}{\tt rref([[3,1,-2,1],[3,2,2,2]])}\end{center}
Output  :
\begin{center}{\tt [[1,0,-2,0],[0,1,4,1]]}\end{center}
Which means that ($x=-2$ and $y=4$) is the solution of the system
$$\left \{
\begin{array}{lcr} 3x + y & = &-2 \\3x +2y & =& 2 \end{array}\right.$$
and ($x=0$ and $y=1$) is the solution of the system
$$\left \{
\begin{array}{lcr} 3x + y & = &1 \\3x +2y & =& 2 \end{array}\right.$$
\item
If {\tt rref}  has two parameters, the second parameter must be an integer 
$k$, and the Gauss-Jordan reduction will be performed on (at most)
the first $k$ columns.\\
Input  :
\begin{center}{\tt rref([[3,1,-2,1],[3,2,2,2]],1)}\end{center}
Output  :
\begin{center}{\tt [[3,1,-2,1],[0,1,4,1]]}\end{center}
\end{itemize}

\subsection{Solving A*X=B : {\tt simult}}\index{simult}
\noindent{\tt simult} is used to solve a linear system of equations (resp. 
several linear systems of equations with the same matrix {\tt A}) written 
in matrix form (see also \ref{sec:rrefm}) :
\begin{center}{\tt A*X=b  (resp A*X=B)}\end{center}
{\tt simult} takes as arguments the matrix {\tt A} of the system and the 
column vector (i.e. a one column matrix) {\tt b} of the second 
member of the system (resp.
the matrix {\tt B} whose columns are the 
vectors {\tt b} of the second members of the different systems).\\
The result is a column vector, solution of the system (resp. a matrix 
whose columns are the solutions of the different systems).\\
For example, to solve the system :
$$\left \{
\begin{array}{lcr} 3x + y & = &-2 \\3x +2y & =& 2 \end{array}\right.$$ 
input  :
\begin{center}{\tt simult([[3,1],[3,2]],[[-2],[2]])}\end{center}
Output  :
\begin{center}{\tt [[-2],[4]]}\end{center}
Hence $x=-2$ and $y=4$ is the solution.\\
Input  :
\begin{center}{\tt simult([[3,1],[3,2]],[[-2,1],[2,2]])}\end{center}
Output :
\begin{center}{\tt [[-2,0],[4,1]]}\end{center}
Hence $x=-2$ and $y=4$ is the solution of
$$\left \{
\begin{array}{lcr} 3x + y & = &-2 \\3x +2y & =& 2 \end{array}\right.$$
whereas $x=0$ and $y=1$ is the solution of
$$\left \{
\begin{array}{lcr} 3x + y & = &1 \\3x +2y & =& 2 \end{array}\right.$$

\subsection{Step by step Gauss-Jordan reduction of a matrix : {\tt pivot}}\index{pivot}\label{sec:pivot}
\noindent{\tt pivot} takes three arguments : a matrix with $n$ rows and $p$ 
columns and two integers $l$ and $c$ such that $0\leq l<n$, $0\leq c<p$
and $A_{l,c}\neq 0$.\\
{\tt pivot(A,l,c)} performs one step of the Gauss-Jordan method
using {\tt A[l,c]} as pivot and returns an equivalent matrix 
with zeros in the column {\tt c} of {\tt A} (except at row $l$).\\
Input  :
\begin{center}{\tt pivot([[1,2],[3,4],[5,6]],1,1)}\end{center}
Output  :
\begin{center}{\tt [[-2,0],[3,4],[2,0]]}\end{center}
Input  :
\begin{center}{\tt pivot([[1,2],[3,4],[5,6]],0,1)}\end{center}
Output  :
\begin{center}{\tt [[1,2],[2,0],[4,0]]}\end{center}

\subsection{Linear system solving: {\tt linsolve}}\index{linsolve}
\noindent{\tt linsolve} is used to solve a system of linear equations.\\
{\tt linsolve} has two arguments: a list of equations or
expressions (in that case the convention is that the equation 
is $expression = 0$), and a list of variable names.\\
{\tt linsolve} returns the solution of the system in a list.\\
Input :
\begin{center}{\tt linsolve([2*x+y+z=1,x+y+2*z=1,x+2*y+z=4],[x,y,z])}\end{center}
Output  :
\begin{center}{\tt  [1/-2,5/2,1/-2]}\end{center} 
Which means that
\[ x=-\frac{1}{2}, y=\frac{5}{2}, z=-\frac{1}{2} \]
is the solution of the system :
$$\left\{
\begin{array}{rl}
2x+y+z &=1\\
x+y+2z &=1\\
x+2y+z &=4
\end{array}
\right.$$ 

\subsection{Finding linear recurrences : {\tt reverse\_rsolve}}\index{reverse\_rsolve}
\noindent{\tt reverse\_rsolve} takes as argument a vector 
$v=[v_0...v_{2n-1}]$ made of the first $2n$ terms of a sequence $(v_n)$
which is supposed to verify a linear recurrence relation of 
degree smaller than $n$
\[ x_n*v_{n+k}+...+x_0*v_k=0 \]
where the $x_j$ are $n+1$ unknowns.\\
{\tt reverse\_rsolve} returns the list $x=[x_n,...,x_0]$
of the $x_j$ coefficients (if $x_n\neq 0$ it is reduced to 1).

In other words {\tt reverse\_rsolve} solves the linear system of  
 $n$ equations :
\begin{eqnarray*}
x_n*v_{n}+...+x_0*v_0 &=&0 \\
...\\
x_n*v_{n+k}+...+x_0*v_k &=&0 \\
...\\
x_n*v_{2*n-1}+...+x_0*v_{n-1}&=&0
\end{eqnarray*}
The matrix $A$ of the system has $n$ rows and $n+1$ columns :
\[ A=[[v_0,v_1...v_n],[v_1,v_2,...v_{n-1}],...,[v_{n-1},v_n...v_{2n-1}]] \]
{\tt reverse\_rsolve} returns the list $x=[x_n,...x_1,x_0]$ with $x_n=1$
and $x$ is the solution of the system $A*{\tt revlist}(x)$.

{\bf Examples}
\begin{itemize}
\item Find a sequence verifying a linear recurrence of degree at 
most 2 whose first elements 1, -1, 3, 3.\\
Input :
\begin{center}{\tt reverse\_rsolve([1,-1,3,3])}\end{center}
Output  :
\begin{center}{\tt  [1,-3,-6]}\end{center} 
Hence $x_0=-6$, $x_1=-3$, $x_2=1$ and the recurrence relation is
 \[ v_{k+2} -3v_{k+1} -6 v_k =0\]
Without {\tt reverse\_rsolve}, we would write the matrix of the system :\\
{\tt [[1,-1,3],[-1,3,3]]} and use the {\tt rref} command :\\
{\tt rref([[1,-1,3],[-1,3,3]])}\\
Output is {\tt [[1,0,6],[0,1,3]]} hence $x_0=-6$ and $x_1=-3$ 
(because $x_2=1$).

\item Find a sequence verifying a linear recurrence of degree at 
most 3 whose first elements are 1, -1, 3, 3,-1, 1.\\
Input :
\begin{center}{\tt reverse\_rsolve([1,-1,3,3,-1,1])}\end{center}
Output  :
\begin{center}{\tt [1,(-1)/2,1/2,-1]}\end{center} 
Hence so, $x_0=-1$, $x_1=1/2$, $x_2=-1/2$, $x_3=1$, the recurrence
relation is
\[ v_{k+3} -\frac{1}{2} v_{k+2} +\frac{1}{2} v_{k+1} -v_k =0 \]
Without {\tt reverse\_rsolve}, we would write the matrix of the system :\\
{\tt [[1,-1,3,3],[-1,3,3,-1],[3,3,-1,1]]}.\\
Using {\tt rref} command, we would input :\\
{\tt rref([[1,-1,3,3],[-1,3,3,-1],[3,3,-1,1]])}\\
Output is {\tt [1,0,0,1],[0,1,0,1/-2],[0,0,1,1/2]]}
hence $x_0=-1$, $x_1=1/2$ and $x_2=-1/2$ because $x_3=1$),
\end{itemize}

\section{Differential equations}
This section is limited to symbolic (or exact) solutions of
differential equations.
For numeric solutions of differential equations, see {\tt odesolve}.
For graphic representation of solutions of differential equations, 
see  {\tt plotfield}, {\tt plotode} and {\tt interactive\_plotode}. 

\subsection{Solving differential equations : {\tt desolve deSolve \\
dsolve}}\index{desolve}\index{deSolve}\index{dsolve}
{\tt desolve} (or {\tt deSolve}) can solve :
\begin{itemize}
\item linear differential equations with constant coefficients,
\item first order linear differential equations,
\item first order differential equations without $y$,
\item first order differential equations without $x$,
\item first order differential equations with separated variables,
\item first order homogeneous differential equations ($y'=F(y/x)$),
\item first order differential equations with integrating factor,
\item first order Bernoulli differential equations ($a(x)y'+b(x)y=c(x)y^n$),
\item first order Clairaut differential equations ($y=x*y'+f(y')$).
\end{itemize}
{\tt desolve} takes as arguments : 
\begin{itemize}
\item  if the independant variable is the current variable (here supposed
to be $x$), 
\begin{itemize}
\item the differential equation (or the list of
the differential equation and of the initial conditions) 
\item the unknown (usually {\tt y}).
\end{itemize}
In the differential equation, the function $y$ is denoted by $y$, 
it's first derivative $y \prime$  is denoted by 
${\tt y'}$, and it's second derivative $y'{'}$ is written 
${\tt y''}$.\\
For example {\tt desolve(y''+2*y'+y,y)} or \\
{\tt desolve([y''+2*y'+y,y(0)=1,y'(0)=0],y)}.
\item if the independant variable is not the current variable, 
for example $t$ instead of $x$, 
\begin{itemize}
\item the differential equation (or the list of
the differential equation and of the initial conditions), 
\item the variable, e.g. {\tt t} 
\item the unknown as a variable {\tt y} or as a function {\tt y(t)}.
\end{itemize}
In the differential equation, the function $y$ is denoted by $y(t)$,
it's derivative $y \prime$  is denoted by
{\tt diff(y(t),t)}, and it's second derivative
$y'{'}$  is denoted by {\tt diff(y(t),t\$2)}.\\ 
For example : \\
{\tt desolve(diff(y(t),t\$2)+2*diff(y(t),t)+y(t),y(t))}; or\\
{\tt desolve(diff(y(t),t\$2)+2*diff(y(t),t)+y(t),t,y)};
and \\
\begin{verbatim}
desolve([diff(y(t),t$2)+2*diff(y(t),t)+y(t),
         y(0)=1,y'(0)=0],y(t)); or
desolve([diff(y(t),t$2)+2*diff(y(t),t)+y(t), 
         y(0)=1,y'(0)=0],t,y);
\end{verbatim}
\end{itemize}
If there is no initial conditions (or one initial condition for a second
order equation),
{\tt desolve} returns the general solution in terms of 
constants of integration 
{\tt c\_0, c\_1}, where {\tt y(0)=c\_0} and {\tt y'(0)=c\_1},
or a list of  solutions.\\
{\bf Examples}
\begin{itemize}
\item Examples of second linear differential equations with constant 
coefficients.
\begin{enumerate}
\item 
Solve :
$$y''+y=\cos (x) $$
Input (typing twice prime for {\tt y''}): 
\begin{center}{\tt desolve(y''+y=cos(x),y)}\end{center}
or input :
\begin{center}{\tt desolve((diff(diff(y))+y)=(cos(x)),y)}\end{center}
Output :
\begin{center}{\tt  c\_0*cos(x)+(x+2*c\_1)*sin(x)/2}\end{center}
{\tt c\_0, c\_1} are the constants  of integration : {\tt y(0)=c\_0} and 
{\tt y'(0)=c\_1}.\\ 
If the variable is not {\tt x} but {\tt t}, input : 
\begin{center}
{\tt desolve(derive(derive(y(t),t),t)+y(t)=cos(t),t,y)}
\end{center}
Output :
\begin{center}{\tt  c\_0*cos(t)+(t+2*c\_1)/2*sin(t)}\end{center}
{\tt c\_0, c\_1} are the constants of integration : {\tt y(0)=c\_0} and
{\tt y'(0)=c\_1}.
\item
Solve :
$$y''+y=\cos (x), \; \; y(0)=1 $$
Input :
\begin{center}{\tt desolve([y''+y=cos(x),y(0)=1],y)}\end{center}
Output   :
\begin{center}{\tt [cos(x)+(x+2*c\_1)/2*sin(x)]}\end{center}
the components of this vector are solutions (here there is just one component, 
so we have just one solution depending of the constant {\tt c\_1}).
\item
Solve :
$$y''+y=\cos (x) \; \; (y(0))^2=1 $$
Input :
\begin{center}{\tt desolve([y''+y=cos(x),y(0)\verb|^|2=1],y)}\end{center}
Output :
\begin{center}{\tt [-cos(x)+(x+2*c\_1)/2*sin(x),cos(x)+(x+2*c\_1)/2*sin(x)]}\end{center}
each component of this list is a solution, 
we have two solutions depending
on the constant {\tt c\_1} ($y'(0)=c_1$)
and corresponding to $y(0)=1$ and to $y(0)=-1$.
\item
Solve :
$$y''+y=\cos (x), \; \; (y(0))^2=1 \; \; y'(0)=1$$
Input :
\begin{center}{\tt desolve([y''+y=cos(x),y(0)\verb|^|2=1,y'(0)=1],y)}
\end{center}
Output :
\begin{center}{\tt [-cos(x)+(x+2)/2*sin(x),cos(x)+(x+2)/2*sin(x)]}\end{center}
each component of this list is a solutions (we have two solutions).
\item
Solve :
$$y''+2y'+y=0$$
Input :
\begin{center}{\tt desolve(y''+2*y'+y=0,y)}\end{center}
Output :
\begin{center}{\tt (x*c\_0+x*c\_1+c\_0)*exp(-x)}\end{center}
the solution depends of 2 constants of integration : 
{\tt c\_0, c\_1} ({\tt y(0)=c\_0} and {\tt y'(0)=c\_1}).
\item
Solve :
$$y''-6y'+9y=xe^{3x}$$
Input:
\begin{center}{\tt desolve(y''-6*y'+9*y=(x*exp(3*x),y)}\end{center}
Output :
\begin{center}{\tt (x\verb|^|3+(-(18*x))*c\_0+6*x*c\_1+6*c\_0)*1/6*exp(3*x)}\end{center}
the solution depends on 2  constants of integration : 
{\tt c\_0, c\_1} ({\tt y(0)=c\_0} and {\tt y'(0)=c\_1}).
\end{enumerate}
\item Examples of first order linear differential equations.
\begin{enumerate}
\item 
Solve :
$$xy'+y-3x^2=0$$
Input :
\begin{center}{\tt desolve(x*y'+y-3*x\verb|^|2,y)}\end{center}
Output :
\begin{center}{\tt(3*1/3*x\verb|^|3+c\_0)/x }\end{center}
\item
Solve :
$$y'+x*y=0, y(0)=1$$
Input :
\begin{center}{\tt desolve([y'+x*y=0, y(0)=1]),y)}\end{center}
or :
\begin{center}{\tt desolve((y'+x*y=0) \&\& (y(0)=1),y)}\end{center}
Output  :
\begin{center}{\tt [1/(exp(1/2*x\verb|^|2))]}\end{center} 
\item
Solve :
$$x(x^2-1)y'+2y=0$$
Input :
\begin{center}{\tt desolve(x*(x\verb|^|2-1)*y'+2*y=0,y)}\end{center}
Output  :
\begin{center}{\tt (c\_0)/((x\verb|^|2-1)/(x\verb|^|2))}\end{center}
\item
Solve :
$$x(x^2-1)y'+2y=x^2$$
Input :
\begin{center}{\tt desolve(x*(x\verb|^|2-1)*y'+2*y=x\verb|^|2,y)}\end{center}
Output  :
\begin{center}{\tt (ln(x)+c\_0)/((x\verb|^|2-1)/(x\verb|^|2))}\end{center}
\item
If the variable is $t$ instead of $x$, for example  :
$$t(t^2-1)y'(t)+2y(t)=t^2$$
Input :
\begin{center}{\tt desolve(t*(t\verb|^|2-1)*diff(y(t),t)+2*y(t)=(t\verb|^|2),y(t))}\end{center}
Output :
\begin{center}{\tt (ln(t)+c\_0)/((t\verb|^|2-1)/(t\verb|^|2))}\end{center}
\item
Solve :
$$x(x^2-1)y'+2y=x^2,y(2)=0$$
Input :
\begin{center}{\tt desolve([x*(x\verb|^|2-1)*y'+2*y=x\verb|^|2,y(0)=1],y)}\end{center}
Output  :
\begin{center}{\tt [(ln(x)-ln(2))*1/(x\verb|^|2-1)*x\verb|^|2]}\end{center}
\item
Solve :
$$\sqrt{1+x^2}y'-x-y=\sqrt{1+x^2}$$
Input :
\begin{center}{\tt desolve(y'*sqrt(1+x\verb|^|2)-x-y-sqrt(1+x\verb|^|2),y)}\end{center}
Output  :
\begin{center}{\tt (-c\_0+ln(sqrt(x\verb|^|2+1)-x))/(x-sqrt(x\verb|^|2+1))}\end{center}
\end{enumerate}

\item Examples of first differential equations with separated variables.
\begin{enumerate}
\item Solve :
$$y'=2\sqrt{y}$$
Input :
\begin{center}{\tt desolve(y'=2*sqrt(y),y)}\end{center}
Output  :
\begin{center}{\tt [x\verb|^|2+-2*x*c\_0+c\_0\verb|^|2]}\end{center}
\item
Solve :
$$xy'\ln(x)-y(3\ln(x)+1)=0$$
Input :
\begin{center}{\tt desolve(x*y'*ln(x)-(3*ln(x)+1)*y,y)}\end{center}
Output  :
\begin{center}{\tt c\_0*x\verb|^|3*ln(x)}\end{center}
\end{enumerate}

\item Examples of Bernoulli differential equations 
$a(x)y'+b(x)y=c(x)y^n$ where $n$ is a real constant.\\
The method used is to divide the equation by $y^n$, 
so that it becomes a first order linear differential equation 
in $u=1/y^{n-1}$.
\begin{enumerate}
\item 
Solve :
$$xy'+2y+xy^2=0$$
Input :
\begin{center}{\tt desolve(x*y'+2*y+x*y\verb|^|2,y)}\end{center}
Output :
\begin{center}{\tt [1/(exp(2*ln(x))*(-1/x+c\_0))]}\end{center}
\item
Solve :
$$xy'-2y=xy^3$$
Input :
\begin{center}{\tt desolve(x*y'-2*y-x*y\verb|^|3,y)}\end{center}
Output :
\begin{center}{\tt [((-2*1/5*x\verb|^|5+c\_0)*exp(-(4*log(x))))\verb|^|(1/-2),}\end{center}
\begin{center}{\tt -((-2*1/5*x\verb|^|5+c\_0)*exp(-(4*log(x))))\verb|^|(1/-2)]}\end{center}
\item 
Solve :
$$x^2y'-2y=xe^(4/x)y^3$$
Input :
\begin{center}{\tt desolve(x*y'-2*y-x*exp(4/x)*y\verb|^|3,y)}\end{center}
Output  :
\begin{center}{\tt [((-2*ln(x)+c\_0)*exp(-(4*(-(1/x)))))\verb|^|(1/-2),}\end{center}
\begin{center}{\tt -(((-2*ln(x)+c\_0)*exp(-(4*(-(1/x)))))\verb|^|(1/-2))]}\end{center}
\end{enumerate}

\item Examples of first order homogeneous differential equations ($y'=F(y/x)$,
the method of integration is to search $t=y/x$ instead of $y$).
\begin{enumerate}
\item 
Solve :
$$(3x^3y'=y(3x^2-y^2)$$
Input :
\begin{center}{\tt desolve(3*x\verb|^|3*diff(y)=((3*x\verb|^|2-y\verb|^|2)*y),y)}\end{center}
Output :
\begin{center}{\tt [0,pnt[c\_0*exp((3*1/2)/(` t`\verb|^|2)),` t`*c\_0*exp((3*1/2)/(` t`\verb|^|2))]]}\end{center}
hence the solutions are $y=0$ and the familiy of curves of parametric
equation $x=c_0\exp(3/(2t^2)), y=t*c_0\exp(3/(2t^2))$ 
(the parameter is denoted by {\tt ` t`} in the answer).
\item
Solve :
$$xy'=y+\sqrt{x^2+y^2}$$
Input :
\begin{center}{\tt desolve(x*y'=y+sqrt(x\verb|^|2+y\verb|^|2),y)}\end{center}
Output  :
\begin{center}{\tt [(-i)*x,(i)*x,pnt[c\_0/(sqrt(` t`\verb|^|2+1)-` t`),(` t`*c\_0)/(sqrt(` t`\verb|^|2+1)-` t`)]]}\end{center}
hence the solutions are  :
$$y=ix,y=-ix$$
 and the family of curves of parametric equations
$$x=c_0/(\sqrt{t^2+1}-t), y=t*c_0/(\sqrt{t^2+1}-t)$$ 
(the parameter is denoted by {\tt ` t`} in the answer).
\end{enumerate}


\item Examples of first order differential equations with an 
integrating factor. By multiplying the equation by a function of $x,y$,
it becomes a closed differential form.
\begin{enumerate}
\item 
Solve :
$$yy'+x$$
Input :
\begin{center}{\tt desolve(y*y'+x,y)}\end{center}
Output  :
\begin{center}{\tt [sqrt(-2*c\_0-x\verb|^|2),-(sqrt(-2*c\_0-x\verb|^|2))]}\end{center}
In this example, $xdx+ydy$ is closed, the integrating factor was 1.
\item
Solve :
$$2xyy'+x^2-y^2+a^2=0$$
Input :
\begin{center}{\tt desolve(2*x*y*y'+x\verb|^|2-y\verb|^|2+a\verb|^|2,y)}\end{center}
Output  :
\begin{center}{\tt [sqrt(a\verb|^|2-x\verb|^|2-c\_1*x),-(sqrt(a\verb|^|2-x\verb|^|2-c\_1*x))]}\end{center}
In this example, the integrating factor was $1/x^2$.
\end{enumerate}

\item Example of first order differential equations without $x$.\\
Solve :
$$(y+y')^4+y'+3y=0$$
This kind of equations can not be solved directly by {\tt Xcas}, we explain
how to solve them with it's help. 
The idea is to find a parametric representation of 
$F(u,v)=0$ where the equation is $F(y,y')=0$, 
Let $u=f(t),v=g(t)$ be such a parametrization of $F=0$, then 
$y=f(t)$ and $dy/dx=y'=g(t)$. Hence
\[ dy/dt=f'(t)=y'*dx/dt=g(t)*dx/dt \]
The solution is the curve of parametric equations
$x(t), y(t)=f(t)$, where $x(t)$ is solution of the differential equation 
 $g(t)dx=f'(t)dt$.\\
Back to the example, we put $y+y'=t$, hence:
\[ y=-t-8*t^4, \quad y'=dy/dx=3*t+8*t^4 \quad dy/dt=-1-32*t^3
\] 
therefore
\[ (3*t+8*t^4)*dx=(-1-32*t^3)dt \]
Input :
\begin{center}{\tt desolve((3*t+8*t\verb|^|4)*diff(x(t),t)=(-1-32*t\verb|^|3),x(t))}\end{center}
Output :
\begin{center}{\tt -11*1/9*ln(8*t\verb|^|3+3)+1/-9*ln(t\verb|^|3)+c\_0}\end{center}
eventually the solution is the curve of parametric equation :
\[ x(t)=-11*1/9*\ln(8*t^3+3)+1/-9*\ln(t^3)+c_0,
\quad y(t)=-t-8*t^4 \]

\item Examples of first order 
Clairaut differential equations ($y=x*y'+f(y')$).\\
The solutions are the lines $D_m$ of equation $y=mx+f(m)$ where
 $m$ is a real constant.
\begin{enumerate}
\item Solve :
$$xy'+y'^3-y)=0$$
Input :
\begin{center}{\tt desolve(x*y'+y'\verb|^|3-y),y)}\end{center}
Output  :
\begin{center}{\tt c\_0*x+c\_0\verb|^|3}\end{center}
\item 
Solve :
$$y-xy'=\sqrt{a^2+b^2*y'^2}=0$$
Input :
\begin{center}{\tt desolve((y-x*y'-sqrt(a\verb|^|2+b\verb|^|2*y'\verb|^|2),y)}\end{center}
Output  :
\begin{center}{\tt c\_0*x+sqrt(a\verb|^|2+b\verb|^|2*c\_0\verb|^|2)}\end{center}
\end{enumerate}
\end{itemize}

\subsection{Laplace transform and inverse Laplace transform : {\tt laplace ilaplace}}\index{laplace}\index{ilaplace}\label{sec:lap}
{\tt laplace} and {\tt ilaplace} takes one, two or three arguments :
 an expression and optionnaly the name(s) of the variable(s).\\
The expression is  an expression of the current variable (here $x$) or an 
expression of the variable given as second argument.\\
{\tt laplace} returns the Laplace transform of the expression given as argument
and {\tt ilaplace} the inverse Laplace transform of the expression given 
as argument. The result of {\tt laplace} and {\tt ilaplace} is expressed
in terms of the variable given as third argument if supplied
or second argument if supplied or $x$ otherwise.

Laplace transform ({\tt laplace}) and inverse Laplace transform
({\tt ilaplace}) are useful to solve linear differential equations
with constant coefficients. For example :
$$y \prime \prime +p. y \prime+q. y \ =\ f(x)$$ $$ y(0)=a, \ y\prime(0)=b$$
Denoting by ${\mathcal{L}}$ the Laplace transform,
the following relations hold :
\begin{eqnarray*}
{\mathcal{L}}(y)(x)&=&\int_0^{+\infty}e^{-x.u}y(u)du \\
{\mathcal{L}}^{-1}(g)(x)&=&\frac{1}{2i\pi}\int_C e^{z.x}g(z)dz
\end{eqnarray*}
where $C$ is a closed contour enclosing the poles of {\tt g}.\\
Input :
\begin{center}{\tt laplace(sin(x))}\end{center}
The expression (here $\sin(x)$) is an expression of the current variable 
(here $x$) and the answer will also be an expression of the current variable 
$x$.\\
Output :
\begin{center}{\tt 1/((-x)\verb|^|2+1)}\end{center}
Or input :
\begin{center}{\tt laplace(sin(t),t)}\end{center}
here the variable name is $t$ and this name is also used in the answer.\\
Output :
\begin{center}{\tt 1/((-t)\verb|^|2+1)}\end{center}
Or input :
\begin{center}{\tt laplace(sin(t),t,s)}\end{center}
here the variable name is $t$ and the variable name of the answer is $s$.\\
Output:
\begin{center}{\tt 1/((-s)\verb|^|2+1)}\end{center}
The following properties hold :
\begin{eqnarray*}
{\mathcal{L}}(y')(x) &=&-y(0)+x.{\mathcal{L}}(y)(x) \\
{\mathcal{L}}(y'')(x) &=&-y'(0)+x.{\mathcal{L}}(y')(x) \\
 &=& -y'(0)-x.y(0)+x^2.{\mathcal{L}}(y)(x)
\end{eqnarray*}
If $y \prime \prime(x) +p. y \prime(x)+q. y(x) \ =\ f(x)$, then :
\begin{eqnarray*}
{\mathcal{L}}(f)(x) &=&{\mathcal{L}}(y''+p.y'+q.y)(x) \\
&=& -y'(0)-x.y(0)+x^2.{\mathcal{L}}(y)(x)-p.y(0)+p.x.{\mathcal{L}}(y)(x))+q.{\mathcal{L}}(y)(x) \\
&=& (x^2+p.x+q).{\mathcal{L}}(y)(x)-y'(0)-(x+p).y(0)
\end{eqnarray*}
Therefore, if $a=y(0)$ et $b=y'(0)$, we have
$${\mathcal{L}}(f)(x)=(x^2+p.x+q).{\mathcal{L}}(y)(x)-(x+p).a-b$$
and the solution of the differential equation is :
\[ y(x)=
{\mathcal{L}}^{-1}(({\mathcal{L}}(f)(x)+(x+p).a +b)/(x^2+p.x+q))
\]
Example :\\
Solve :
\[ y\prime \prime -6. y\prime+9. y \ =\ x. e^{3. x},
\quad  y(0)=c\_0, \quad y\prime(0)=c\_1
\]
Here, $p=-6,\ q=9$.\\
Input :
\begin{center}{\tt laplace(x*exp(3*x))}\end{center}
Output :
\begin{center}{\tt 1/(x\verb|^| 2-6*x+9)}\end{center}
Input :
\begin{center}{\tt ilaplace((1/(x\verb|^|2-6*x+9)+(x-6)*c\_0+c\_1)/(x\verb|^|2-6*x+9))}\end{center}
Output :
\begin{center}{\tt (216*x\verb|^|3-3888*x*c\_0+1296*x*c\_1+1296*c\_0)*exp(3*x)/1296}\end{center}
After simplification and factorisation ({\tt factor} command) 
the solution $y$ is :
\begin{center}{\tt (-18*c\_0*x+6*c\_0+x\verb|^|3+6*x*c\_1)*exp(3*x)/6}\end{center}
Note that this equation could be solved directly, input :
\begin{center}{\tt desolve(y''-6*y'+9*y=x*exp(3*x),y)}\end{center}
Output :
\begin{center}{\tt exp(3*x)*(-18*c\_0*x+6*c\_0+x\verb|^|3+6*x*c\_1)/6}\end{center}

\section{Other functions}
\subsection{Replace small values by 0: {\tt epsilon2zero}}
\index{epsilon2zero} \label{sec:epsilon2zero}
\noindent{\tt epsilon2zero} takes as argument an expression of {\tt x}.\\
{\tt epsilon2zero} returns the expression where the values of modulus
less than  {\tt epsilon} are replaced by zero. The expression
is not evaluated.\\
The {\tt epsilon}\index{epsilon} value is defined in the {\tt cas} 
configuration (by default {\tt epsilon=1e-10}).\\
Input :
\begin{center}{\tt epsilon2zero(1e-13+x) }\end{center}
Output (with {\tt epsilon=1e-10}) :
\begin{center}{\tt 0+x}\end{center}
Input :
\begin{center}{\tt epsilon2zero((1e-13+x)*100000) }\end{center}
Output (with {\tt epsilon=1e-10}) :
\begin{center}{\tt (0+x)*100000}\end{center}
Input :
\begin{center}{\tt epsilon2zero(0.001+x) }\end{center}
Output (with {\tt epsilon=0.0001}) :
\begin{center}{\tt 0.001+x}\end{center}

\subsection{List of variables : {\tt lname indets}}\index{lname}\index{indets}
\noindent{\tt lname} (or {\tt indets}) takes as argument an expression.\\
{\tt lname} (or {\tt indets}) returns the list of the symbolic
variable names used in this expression.\\
Input :
\begin{center}{\tt lname(x*y*sin(x))}\end{center}
Output :
\begin{center}{\tt  [x,y]}\end{center}
Input :
\begin{center}{\tt a:=2;assume(b>0);assume(c=3);}\end{center}
\begin{center}{\tt lname(a*x\verb|^|2+b*x+c)}\end{center}
Output :
\begin{center}{\tt  [x,b,c]}\end{center}

\subsection{List of variables and of expressions : {\tt lvar}}\index{lvar}\label{sec:lvar}
\noindent{\tt lvar} takes as argument an expression.\\
{\tt lvar}  returns a list of variable names and non-rationnal
expressions such that it's argument is a rational fraction
with respect to the variables and expressions of the list.\\
Input :
\begin{center}{\tt lvar(x*y*sin(x)\verb|^|2)}\end{center}
Output :
\begin{center}{\tt [x,y,sin(x)]}\end{center}
Input :
\begin{center}{\tt lvar(x*y*sin(x)\verb|^|2+ln(x)*cos(y))}\end{center}
Output :
\begin{center}{\tt [x,y,sin(x),ln(x),cos(y)]}\end{center}
Input :
\begin{center}{\tt lvar(y+x*sqrt(z)+y*sin(x))}\end{center}
Output :
\begin{center}{\tt [x,y,sqrt(z),sin(x)]}\end{center}

\subsection{List of variables of an algebraic expressions: {\tt algvar}}\index{algvar}
\noindent{\tt algvar} takes as argument an expression.\\ 
{\tt algvar} returns the list of the symbolic
variable names used in this expression. The list is ordered
by the algebraic extensions required to build the original expression.\\
Input :
\begin{center}{\tt algvar(y+x*sqrt(z))}\end{center}
Output :
\begin{center}{\tt  [[y,x],[z]]}\end{center}
Input :
\begin{center}{\tt algvar(y*sqrt(x)*sqrt(z))}\end{center}
Output :
\begin{center}{\tt  [[y],[z],[x]]}\end{center}
Input :
\begin{center}{\tt algvar(y*sqrt(x*z))}\end{center}
Output :
\begin{center}{\tt  [[y],[x,z]]}\end{center}
Input :
\begin{center}{\tt algvar(y+x*sqrt(z)+y*sin(x))}\end{center}
Output :
\begin{center}{\tt [[x,y,sin(x)],[z]]}\end{center}

\subsection{Test if a variable is in an expression : {\tt has}}\index{has|textbf}
\noindent{\tt has} takes as argument an expression and the name of a 
variable.\\
{\tt has} returns {\tt 1} if this variable is in this expression, and else 
returns {\tt 0}.\\
Input :
\begin{center}{\tt has(x*y*sin(x),y)}\end{center}
Output :
\begin{center}{\tt  1}\end{center}
Input :
\begin{center}{\tt has(x*y*sin(x),z)}\end{center}
Output :
\begin{center}{\tt  0}\end{center}

\subsection{Numeric evaluation : {\tt evalf}}\index{evalf}
\noindent{\tt evalf} takes as argument an expression or a matrix.\\
{\tt evalf} returns the numeric value of this expression or of this matrix.\\
Input :
\begin{center}{\tt evalf(sqrt(2))}\end{center} 
Output :
\begin{center}{\tt 1.41421356237}\end{center}
Input :
\begin{center}{\tt evalf([[1,sqrt(2)],[0,1]])}\end{center} 
Output :
\begin{center}{\tt [[1.0,1.41421356237],[0.0,1.0]]}\end{center}

\subsection{Rational approximation : {\tt float2rational exact}}\index{float2rational}\index{exact}
\noindent{\tt float2rational} (or {\tt exact}) 
takes as argument an expression.\\
{\tt float2rational} returns a rational approximation of 
all the floating point numbers $r$ contained in this expression, such
that $|r-\mbox{\tt float2rational}(r)|<\epsilon$, where
$\epsilon$  is defined by {\tt epsilon} in the {\tt cas} configuration 
({\tt Cfg} menu, or {\tt cas\_setup} command).\\
Input :
\begin{center}{\tt float2rational(1.5)}\end{center}
Output :
\begin{center}{\tt 3/2}\end{center}
Input :
\begin{center}{\tt float2rational(1.414)}\end{center}
Output :
\begin{center}{\tt 707/500}\end{center}
Input :
\begin{center}{\tt float2rational(0.156381102937*2)}\end{center}
Output :
\begin{center}{\tt 5144/16447}\end{center}
Input :
\begin{center}{\tt float2rational(1.41421356237)}\end{center}
Output :
\begin{center}{\tt 114243/80782}\end{center}
Input :
\begin{center}{\tt float2rational(1.41421356237\verb|^|2)}\end{center}
Output :
\begin{center}{\tt 2}\end{center}

\chapter{Graphs}\label{sec:plot}
Most graph instructions take expressions as arguments. A few
exceptions (mostly maple-compatibility instructions) also accept
functions. 
Some optional arguments, like {\tt color, thickness}, can  be used as optional
attributes in all graphic instructions. They are described below.

\section{Graph and geometric objects attributes}
There are two kinds of attributes: global attributes of a graphic
scene and individual attributes. 

\subsection{Individual attributes}\index{color}\index{display}
\index{red@{\it red}|textbf}\index{blue@{\it blue}|textbf}\index{yellow@{\it yellow}|textbf}\index{magenta@{\it magenta}|textbf}\index{green@{\it green}|textbf}\index{cyan@{\it cyan}|textbf}\index{white@{\it white}|textbf}\index{black@{\it black}|textbf}\index{filled@{\it filled}}
Graphic attributes are optional arguments of the
form {\tt display=value}, they must be given
as last argument of a graphic instruction. Attributes
are ordered in several categories: color, point shape, point width,
line style, line thickness, legend value, position and presence. 
In addition, surfaces may be filled or not, 3-d surfaces
may be filled with a texture, 3-d objects may also have properties
with respect to the light. 
Attributes of different categories
may be added, e.g. \\
{\tt plotfunc($x^2+y^2$,[x,y],display=red+line\_width\_3+filled}
\begin{itemize}
\item Colors {\tt display=} or {\tt color=}
\begin{itemize}
\item {\tt black}, {\tt white}, {\tt red}, {\tt blue}, {\tt green}, 
{\tt magenta}, {\tt cyan}, {\tt yellow},
\item a numeric value between 0 and 255,
\item a numeric value between 256 and 256+7*16+14 for a color of the
rainbow,
\item any other numeric value smaller than 65535, the rendering
is not garanteed to be portable.
\end{itemize}
\item Point shapes {\tt display=} one of the following value
{\tt rhombus\_point plus\_point  square\_point cross\_point 
triangle\_point star\_point point\_point invisible\_point}
\item Point width: {\tt display=} one of the following value
{\tt point\_width\_n} where {\tt n} is an
integer between 1 and 7
\item Line thickness: {\tt thickness=n}
or {\tt display=line\_width\_n} where {\tt n} is an
integer between 1 and 7 or 
\item Line shape: {\tt display=} one of the following value
{\tt dash\_line solid\_line dashdot\_line dashdotdot\_line
  cap\_flat\_line cap\_square\_line cap\_round\_line }
\item Legend, value: {\tt legend="legendname"};
 position: {\tt display=} one of
{\tt quandrant1 quadrant2 quadrant3 quadrant4}
corresponding to the position of the legend of the object 
(using the trigonometric plan conventions).
The legend is not displayed if the attribute 
{\tt display=hidden\_name} is added
\item {\tt display=filled} specifies that surfaces will be filled,
\item {\tt gl\_texture="picture\_filename"} is used to fill 
a surface with a texture.  
Cf. the interface manual for a more complete
description and for {\tt gl\_material=} options.
\end{itemize}
{\bf Examples}
Input
\begin{center}{\tt polygon(-1,-i,1,2*i,legend="P")}\end{center}
Input
\begin{center}{\tt point(1+i,legend="hello")}\end{center}
Input
\begin{center}{\tt A:=point(1+i);B:=point(-1);display(D:=droite(A,B),hidden\_name)}\end{center}
Input
\begin{center}{\tt color(segment(0,1+i),red)}\end{center}
Input
\begin{center}{\tt segment(0,1+i,color=red)}\end{center}

\subsection{Global attributes}
These attributes are shared by all objets of the same scene
\begin{itemize}
\item {\tt title="titlename"} defines the title
\item {\tt labels=["xname","yname","zname"]}: names of the $x,y,z$
axis
\item {\tt gl\_x\_axis\_name="xname"}, {\tt gl\_y\_axis\_name="yname"},
{\tt gl\_z\_axis\_name=""}: individual definition
of the names of the $x,y,z$ axis
\item {\tt legend=["xunit","yunit","zunit"]}: units for the
$x,y,z$ axis
\item {\tt gl\_x\_axis\_unit="xunit"}, {\tt  gl\_y\_axis\_unit="yunit"},
{\tt gl\_z\_axis\_unit=""}: individual definition
of the units of the $x,y,z$ axis
\item {\tt axes=true or false} show or hide axis
\item {\tt gl\_texture="filename"}: background image
\item {\tt gl\_x=xmin..xmax}, {\tt gl\_y=ymin..ymax},
{\tt gl\_z=zmin..zmax}: set the graphic configuration 
(do not use for interactive scenes)
\item {\tt gl\_xtick=}, {\tt gl\_ytick=}, {\tt gl\_ztick=}:
set the tick mark for the axis 
\item {\tt gl\_shownames=true or false}: show or hide objects names
\item {\tt gl\_rotation=[x,y,z]}: defines the rotation axis
for the animation rotation of 3-d scenesé
\item {\tt gl\_quaternion=[x,y,z,t]}: defines the quaternion
for the visualization in 3-d scenes (do not use for interactive
scenes)
\item a few other OpenGL light configuration options are
available but not described here.
\end{itemize}
{\bf Examples}
Input
\begin{center}{\tt legend=["mn","kg"]}\end{center}
Input
\begin{center}{\tt titre="median\_line";triangle(-1-i,1,1+i);median\_line(-1-i,1,1+i);median\_line(1,-1-i,1+i);median\_line(1+i,1,-1-i)}\end{center}
Input
\begin{center}{\tt labels=["u","v"];plotfunc(u+1,u)}\end{center}

\section{Graph of a function : {\tt plotfunc funcplot DrawFunc Graph}}\index{plotfunc|textbf}\index{funcplot|textbf}\index{DrawFunc|textbf}\index{Graph|textbf}\index{xstep@{\sl xstep}}\index{ystep@{\sl ystep}}\index{zstep@{\sl zstep}}\index{nstep@{\sl nstep}}

\subsection{2-d graph}\label{sec:plotfunc}
\noindent{\tt plotfunc(f(x),x)} draws the graph of $y=f(x)$ for $x$ in
the default interval, 
{\tt plotfunc(f(x),x=a..b)} draws the graph of $y=f(x)$ for $a\leq x\leq b$.
{\tt plotfunc} accepts an optional \verb|xstep=...| argument to 
specify the discretisation step in $x$.\\
Input :
\begin{center}{\tt  plotfunc(x\verb|^|2-2)}\end{center}
or
\begin{center}{\tt  plotfunc(a\verb|^|2-2,a=-1..2)}\end{center}
Output :
\begin{center}{\tt the graph of y=x\verb|^|2-2}\end{center}
Input :
\begin{center}{\tt  plotfunc(x\verb|^|2-2,x,xstep=1)}\end{center}
Output :
\begin{center}{\tt a polygonal line which is a bad representation of y=x\verb|^|2-2 }\end{center}
It is also possible to specify the number of points used for the 
representation of the function with \verb|nstep=| instead of \verb|xstep=|.
For example, input~:
\begin{center}{\tt  plotfunc(x\verb|^|2-2,x=-2..3,nstep=30)}\end{center}

\subsection{3-d graph}\label{sec:plotfunc3}
\noindent{\tt plotfunc} takes two main arguments : an expression of two 
variables or a list of several expressions of two variables and the list of 
these two variables, where each variable may be replaced by
an equality variable=interval to specify the range for this variable
(if not specified, default values are taken from the graph configuration).
{\tt plotfunc} accepts two optional arguments to specify 
the discretisation step in $x$ and in $y$ by
{\tt xstep=...} and {\tt ystep=...}.
Alternatively one can specify the number of points used for the 
representation of the function with \verb|nstep=| (instead of \verb|xstep| and 
{\tt ystep}).\\
{\tt plotfunc} draws the surface(s) defined by $z=$ the first argument.\\
Input :
\begin{center}{\tt plotfunc( x\verb|^|2+y\verb|^|2,[x,y])}\end{center}
Output :
\begin{center}{\tt A 3D graph of z=x\verb|^|2+y\verb|^|2}\end{center}
Input :
\begin{center}{\tt plotfunc(x*y,[x,y]) }\end{center}
Output :
\begin{center}{\tt The surface z=x*y, default ranges}\end{center}
Input :
\begin{center}{\tt plotfunc([x*y-10,x*y,x*y+10],[x,y]) }\end{center}
Output :
\begin{center}{\tt The surfaces z=x*y-10, z=x*y and z=x*y+10}\end{center}
Input :
\begin{center}{\tt plotfunc(x*sin(y),[x=0..2,y=-pi..pi]) }\end{center}
Output :
\begin{center}{\tt The surface $z=x*y$ for the specified ranges}\end{center}
Now an example where we specify the $x$ and $y$ discretisation step 
with \verb|xstep| and \verb|ystep|. Input :
\begin{center}
{\tt plotfunc(x*sin(y),[x=0..2,y=-pi..pi],xstep=1,ystep=0.5) }\end{center}
Output :
\begin{center}{\tt A portion of surface $z=x*y$}\end{center}
Alternatively we may specify 
the number of points used for the representation of the
function with \verb|nstep| instead of \verb|xstep| and \verb|ystep|, input~:
\begin{center}{\tt plotfunc(x*sin(y),[x=0..2,y=-pi..pi],nstep=300)}\end{center}
Output :
\begin{center}{\tt A portion of surface $z=x*y$}\end{center}
{\bf Remarks}
\begin{itemize}
\item
Like any 3-d scene, the viewpoint may be modified by rotation 
around the {\tt x} axis, the {\tt y} axis or the
{\tt z} axis, either by dragging the mouse inside the graphic 
window (push the mouse outside the parallelepiped used for 
the representation), or with the shortcuts
{\tt x}, {\tt X}, {\tt y}, {\tt Y}, {\tt z} and {\tt Z}.
\item
If you want to print a graph or get a \LaTeX\ translation, use the graph
menu\\
{\tt Menu$\blacktriangleright$print$\blacktriangleright$Print(with
  Latex)}
\end{itemize}

\subsection{3-d graph with rainbow colors}\label{sec:plotfunc3d}
\noindent{\tt plotfunc} represents a pure imaginary expression {\tt i*E}
of two variables with a rainbow color depending 
on the value of {\tt z=E}. This gives an easy way to 
find points having the same third coordinate.\\
The first arguments of {\tt plotfunc} must be {\tt i*E} instead of {\tt E},
the remaining arguments are the same 
as for a real 3-d graph (cf \ref{sec:plotfunc3})
Input :
\begin{center}{\tt plotfunc(i*x*sin(y),[x=0..2,y=-pi..pi]) }\end{center}
Output :
\begin{center}{\tt A piece of the surface $z=x*\sin(y)$ with rainbow colors}\end{center}
{\bf Remark}\\
 If you want the impression or the  traduction Latex, you have to use :\\
{\tt Menu$\blacktriangleright$print$\blacktriangleright$Print(with Latex)}. 

\subsection{4-d graph.}\label{sec:plotfunc4}
\noindent{\tt plotfunc} represents a complex expression {\tt E} 
(such that {\tt re(E)} is not identically 0 on the discretisation mesh)
by the surface {\tt z=abs(E)} where {\tt arg(E)} defines the color 
from the rainbow. This gives an easy way to 
see the points having the same argument.
Note that if {\tt re(E)==0} on the discretisation mesh, 
it is the surface {\tt z=E/i} that is represented with rainbow colors 
(cf \ref{sec:plotfunc3d}).\\
The first argument of {\tt plotfunc} is {\tt E}, 
the remaining arguments are the same 
as for a real 3-d graph (cf \ref{sec:plotfunc3}).
Input :
\begin{center}{\tt plotfunc((x+i*y)\verb|^|2,[x,y])}\end{center}
Output :
\begin{center}{\tt A graph 3D of z=abs((x+i*y)\verb|^|2 with the same color for
points having the same argument}\end{center}
Input :
\begin{center}{\tt plotfunc((x+i*y)\verb|^|2x,[x,y], display=filled)}\end{center}
Output :
\begin{center}{\tt The same surface but filled}\end{center}
We may specify the range of variation of $x$ and $y$ and the number of 
discretisation points, input :
\begin{center}{\tt plotfunc((x+i*y)\verb|^|2,[x=-1..1,y=-2..2], nstep=900,display=filled)}\end{center}
Output :
\begin{center}{\tt The specified part of the surface with $x$ between -1 and 1, $y$ between -2 and 2 and with 900 points}\end{center}
 
\section{2d graph for Maple compatibility : {\tt plot}}
\index{plot} \label{sec:plot2d}
\noindent{\tt plot(f(x),x)} draws the graph of $y=f(x)$. 
The second argument may specify the range of values {\tt
  x=xmin..xmax}. One can also plot a function instead of an
expression using the syntax {\tt plot(f,xmin..xmax)}.
{\tt plot} accepts an optional argument to specify 
the step used in $x$ for the discretisation with  
\verb|xstep=| or the number of points of the discretization
with \verb|nstep=|.\\
Input :
\begin{center}{\tt  plot(x\verb|^|2-2,x)}\end{center}
Output :
\begin{center}{\tt the graph of y=x\verb|^|2-2}\end{center}
Input :
\begin{center}{\tt  plot(x\verb|^|2-2,xstep=1)}\end{center}
or 
\begin{center}{\tt  plot(x\verb|^|2-2,x,xstep=1)}\end{center}
Output :
\begin{center}{\tt a polygonal line which is a bad representation of
    y=x\verb|^|2-2 }\end{center}
Input!
\begin{center}{\tt  plot(x\verb|^|2-2,x=-2..3,nstep=30)}\end{center}


\section{3d surfaces for Maple compatibility {\tt plot3d}}\index{plot3d}
\noindent{\tt plot3d} takes three arguments : a function of two variables or 
an expression of two variables  or a list of three functions of two variables 
or a list of three expressions of two variables and the names of these two 
variables with an optional range (for expressions) or the ranges 
(for functions).\\
{\tt plot3d(f(x,y),x,y)} (resp {\tt plot3d([f(u,v),g(u,v),h(u,v)],u,v)}) draws 
the surface $z=f(x,y)$ (resp $x=f(u,v),y=g(u,v),z=h(u,v)$).
The syntax {\tt plot3d(f(x,y),x=x0..x1,y=y0..y1)} or 
{\tt plot3d(f,x0..x1,y0..y1)} specifies which part of surface 
will be computed (otherwise default values are taken from the graph
configuration).\\ 
Input :
\begin{center}{\tt plot3d(x*y,x,y)}\end{center}
Output :
\begin{center}{\tt The surface $z=x*y$}\end{center}
Input :
\begin{center}{\tt plot3d([v*cos(u),v*sin(u),v],u,v) }\end{center}
Output :
\begin{center}{\tt The cone $x=v*\cos(u),y=v*\sin(u),z=v$}\end{center}
Input :
\begin{center}{\tt plot3d([v*cos(u),v*sin(u),v],u=0..pi,v=0..3)}\end{center}
Output :
\begin{center}{\tt A portion of the cone $x=v*\cos(u),y=v*\sin(u),z=v$}\end{center}

\section{Graph of a line and tangent to a graph}
\subsection{Draw a line : {\tt line}}\index{line}\label{sec:doite}
{\bf See also :} \ref{sec:droite2} and \ref{sec:droite3} for line usage in 
geometry and see \ref{sec:axe2} and \ref{sec:axe3} for axis.\\
\noindent {\tt line} takes as argument cartesian(s) equation(s) :
\begin{itemize}
\item in 2D: one line equation,
\item in 3D: two plane equations.
\end{itemize}
{\tt line} defines and draws the corresponding line.\\
Input :
\begin{center}{\tt line(2*y+x-1=0)}\end{center}
Output :
\begin{center}{\tt the line 2*y+x-1=0}\end{center}
Input :
\begin{center}{\tt line(y=1)}\end{center}
Output :
\begin{center}{\tt the horizontal line y=1}\end{center}
Input :
\begin{center}{\tt line(x=1)}\end{center}
Output :
\begin{center}{\tt the vertical line x=1}\end{center}
Input :
\begin{center}{\tt line(x+2*y+z-1=0,z=2)}\end{center}
Output :
\begin{center}{\tt the line x+2*y+1=0 in the plane z=2}\end{center}
Input :
\begin{center}{\tt line(y=1,x=1)}\end{center}
Output :
\begin{center}{\tt the vertical line crossing through (1,1,0)}\end{center}
{\bf Remark}\\
{\tt line} defines an oriented line :
\begin{itemize}
\item when the 2D line is given by an equation, it is rewritten
as "left\_member-right\_member={\tt ax+by+c=0}", this determinates
its normal vector {\tt [a,b]} and the orientation is given by the vector 
{\tt [b,-a]}) (or its orientation is defined by the 3D cross product of its
normal vectors (with third coordinate 0) and the vector [0,0,1]).\\
For example {\tt line(y=2*x)} defines the line {\tt -2x+y=0} with as direction 
the vector {\tt [1,2]} (or {\tt cross([-2,1,0],[0,0,1])}={\tt [1,2,0]}).
\item when the 3D line is given by two plane equations, it's 
direction is defined by the cross product of the normals to the planes 
(where the plane equation is rewritten as
"left\_member-right\_member={\tt ax+by+cz+d=0}", so that
the normal is {\tt [a,b,c]}).\\
For example the {\tt line(x=y,y=z)} is the line {\tt x-y=0,y-z=0} and its
direction is :\\
{\tt cross([1,-1,0],[0,1,-1])}={\tt [1,1,1]}.
\end{itemize}

\subsection{Draw an 2D horizontal line : {\tt LineHorz}}\index{LineHorz}
\noindent {\tt LineHorz} takes as argument an expression $a$.\\
 {\tt LineHorz} draws the horizontal line $y=a$.\\
Input :
\begin{center}{\tt LineHorz(1)}\end{center}
Output :
\begin{center}{\tt the line y=1}\end{center}

\subsection{Draw a 2D vertical line : {\tt LineVert}}\index{LineVert}
\noindent {\tt LineVert} takes as argument an expression $a$.\\
 {\tt LineVert} draws the vertical line $x=a$.\\
Input :
\begin{center}{\tt LineVert(1)}\end{center}
Output :
\begin{center}{\tt the line x=1}\end{center}

\subsection{Tangent to a 2D graph : {\tt LineTan}}\index{LineTan}
\noindent {\tt LineTan} takes two arguments : an expression $E_x$ of the
variable $x$ and a value $x0$ of $x$.\\
 {\tt LineTan} draws the tangent at $x=x0$ to the graph of $y=E_x$.\\
Input :
\begin{center}{\tt LineTan(ln(x),1)}\end{center}
Output :
\begin{center}{\tt the line y=x-1}\end{center}
Input :
\begin{center}{\tt equation(LineTan(ln(x),1))}\end{center}
Output :
\begin{center}{\tt y=(x-1)}\end{center}

\subsection{Tangent to a 2D graph : {\tt tangent}}\index{tangent|textbf}\label{sec:tangente}
{\bf See also :} \ref{sec:tangent} for plane geometry and 
\ref{sec:tangent3} for 3D geometry.\\
\noindent {\tt tangent} takes two arguments : an geometric object and a point 
{\tt A}.\\
{\tt tangent} draws tangent(s) to this geometric object crossing through 
{\tt A}. If the geometric object is the graph {\tt G} of a 2D function, 
the second argument is either, a real number {\tt x0}, or a 
point {\tt A} on {\tt G}. In that case {\tt tangent} draws a tangent to this
graph {\tt G} crossing through the point {\tt A} or through the 
point of abscissa {\tt x0}.\\
For example, define the function {\tt g}
\begin{center} \verb|g(x):=x^2|\end{center}
then the graph {\tt G=\{(x,y)$\in \R^2$, y=g(x)\}}
of $g$ and a point $A$ on the graph $G$:
\begin{center}
{\tt G:=plotfunc(g(x),x);}\\
{\tt A:=point(1.2,g(1.2));}
\end{center}
If we want to draw the tangent at the point {\tt A} to the graph {\tt
  G}, we will input:
\begin{center}
{\tt T:=tangent(G, A)}
\end{center}
or :
\begin{center}
{\tt T:=tangent(G, 1.2)}
\end{center}
For the equation of the tangent line, input :
\begin{center}{\tt equation(T)}\end{center}

\subsection{Intersection of a 2D graph with the axis}\index{solve}\index{resoudre}
\begin{itemize}
\item The ordinate of the intersection of the graph of $f$ with the 
$y$-axis is returned by :
\begin{center}{\tt f(0)}\end{center}
indeed the point of coordinates $(0,f(0))$ is the intersection point of the 
graph of $f$ with the $y$-axis,
\item Finding the intersection of the graph of $f$ with the $x$-axis 
requires to solve the equation $f(x)=0$. \\
If the equation is polynomial-like, {\tt solve} will find
the exact values of the abscissa of these points. Input:
\begin{center}{\tt solve(f(x),x)}\end{center}
Otherwise, we can find numeric approximations of these 
abscissa. First look at the graph for an initial guess or a
range with an intersection and refine with {\tt fsolve}.
\end{itemize}

\section{Graph of inequations with 2 variables : {\tt plotinequation inequationplot}}\index{plotinequation|textbf}\index{inequationplot|textbf}
\noindent{\tt plotinequation([f1(x,y)<a1,...fk(x,y)<ak],[x=x1..x2,y=y1..y2])} 
draws the points of the plane whose coordinates
satisfy the inequations of 2 variables :
\[ \left\{ \begin{array}{ccc}
f1(x,y) &<&a1 \\
& ... & \\
fk(x,y)&<&ak 
\end{array}\right., \quad
x1\leq x \leq x2, y1 \leq y \leq y2 \]
Input :
\begin{center}{\tt plotinequation(x\verb|^|2-y\verb|^|2<3, [x=-2..2,y=-2..2],xstep=0.1,ystep=0.1)}\end{center}
Output :
\begin{center}{\tt the filled portion enclosing the origin and limited by the hyperbola x\verb|^|2-y\verb|^|2=3}\end{center}
Input :
\begin{center}{\tt plotinequation([x+y>3,x\verb|^|2<y], [x-2..2,y=-1..10],xstep=0.2,ystep=0.2)}\end{center}
Output :
\begin{center}{\tt the filled portion of the plane defined by -2<x<2,y<10,x+y>3,y>x\verb|^|2}\end{center}
Note that if the ranges for $x$ and $y$ are not specified, 
{\tt Xcas} takes the default values of 
{\tt X-,X+,Y-,Y+} defined in the general graphic configuration
({\tt Cfg$\blacktriangleright$Graphic configuration}).

\section{Graph of the area below a curve : {\tt plotarea areaplot}}\index{plotarea|textbf}\index{areaplot|textbf}\index{rectangle\_droit@{\sl rectangle\_droit}|textbf}\index{rectangle\_gauche@{\sl rectangle\_gauche}|textbf}\index{trapeze@{\sl trapeze}|textbf}\index{point\_milieu@{\sl point\_milieu}|textbf}
\begin{itemize}
\item With two arguments, {\tt plotarea} shades the area below a curve.\\ 
{\tt plotarea(f(x),x=a..b)} draws the area below the curve $y=f(x)$ for 
$a<x<b$, i.e. the portion of the plane defined by the inequations $a<x<b$ and
$0<y<f(x)$ or $0>y>f(x)$ according to the sign of $f(x)$ .\\
Input :
\begin{center}{\tt plotarea(sin(x),x=0..2*pi)}\end{center}
Output :
\begin{center}{\tt the portion of plane locates in the two archs of sin(x)}\end{center}
\item With four arguments, {\tt plotarea}  represents a numeric approximation
of the area below a curve, according to a quadrature method from the
following list:\\
{\tt trapezoid,rectangle\_left,rectangle\_right,middle\_point}.\\
For example {\tt plotarea(f(x),x=a..b,n,trapezoid)} 
draws the area of $n$ trapezes : the 
third argument is an integer $n$, and the fourth argument is the name of the 
numeric method of integration when $[a,b]$ is cut into $n$ equal parts.\\
Input :
\begin{center}{\tt plotarea((x\verb|^|2,x=0..1,5,trapezoid)}\end{center}
If you want to display the graph of the curve in contrast
(e.g. in bold red), input :
\begin{center}{\tt plotarea(x\verb|^|2,x=0..1,5,trapezoid); 
plot(x\verb|^|2,x=0..1,display=red+line\_width\_3)}\end{center}
Output :
\begin{center}{\tt the 5 trapezes used in the trapezoid method to approach the integral}\end{center}
Input :
\begin{center}{\tt plotarea((x\verb|^|2,x=0..1,5,middle\_point)}\end{center}
Or with the graph of the curve in bold red, input :
\begin{center}{\tt plotarea(x\verb|^|2,x=0..1,5,middle\_point); plot(x\verb|^|2,x=0..1,display=red+line\_width\_3)}\end{center}
Output :
\begin{center}{\tt the 5 rectangles used in the middle\_point method
    to approach the integral}\end{center}
\end{itemize}

\section{Contour lines: {\tt plotcontour contourplot \\DrwCtour}}\index{plotcontour|textbf}\index{contourplot|textbf}\index{DrwCtour|textbf}\label{sec:plotcontour}
\noindent{\tt plotcontour(f(x,y),[x,y])} (or {\tt DrwCtour(f(x,y),[x,y])} or \\
 {\tt contourplot(f(x,y),[x,y])})
draws the contour lines of the surface defined by $z=f(x,y)$ for $z=-10$, 
$z=-8$, .., $z=0$, $z=2$, .., $z=10$. You may specify the desired contour
lines by a list of values of $z$ given as third argument.\\
Input :
\begin{center}{\tt  plotcontour(x\verb|^|2+y\verb|^|2,[x=-3..3,y=-3..3],[1,2,3], display=[green,red,black]+[filled\$3])}\end{center}
Output :
\begin{center}{\tt  the graph of the three ellipses x\verb|^|2-y\verb|^|2=n for n=1,2,3; the zones between these ellipses are filled with the color green,red or black}\end{center}
Input :
\begin{center}{\tt  plotcontour(x\verb|^|2-y\verb|^|2,[x,y])}\end{center}
Output :
\begin{center}{\tt  the graph of 11 hyperbolas x\verb|^|2-y\verb|^|2=n for n=-10,-8,..10}\end{center}

If you want to draw the surface in 3-d representation, 
input {\tt plotfunc(f(x,y),[x,y])}, see \ref{sec:plotfunc3}):
\begin{center}{\tt plotfunc( x\verb|^|2-y\verb|^|2,[x,y])}\end{center}
Output :
\begin{center}{\tt A 3D representation of z=x\verb|^|2+y\verb|^|2}\end{center}

\section{2-d graph of a 2-d function with colors : 
{\tt plotdensity densityplot}}
\index{plotdensity|textbf}\index{densityplot|textbf}
\noindent{\tt plotdensity(f(x,y),[x,y])}  or  {\tt densityplot(f(x,y),[x,y])}
draws the graph of $z=f(x,y)$ in the plane where the values of
$z$ are represented by the rainbow colors. The optional argument
{\tt z=zmin..zmax} specifies the range of $z$ corresponding to the
full rainbow, if it is not specified, it is deduced from the minimum
and maximum value of $f$ on the discretisation. The discretisation
may be specified by optional {\tt xstep=...} and {\tt ystep=...}
or {\tt nstep=...} arguments.\\
Input :
\begin{center}{\tt plotdensity(x\verb|^|2-y\verb|^|2,[x=-2..2,y=-2..2], xstep=0.1,ystep=0.1)}\end{center}
Output :
\begin{center}{\tt A 2D graph where each hyperbola defined by
    x\verb|^|2-y\verb|^|2=z has a color from the rainbow}\end{center}
{\bf Remark} : A rectangle representing the scale of colors is 
displayed below the graph.

\section{Implicit graph: {\tt plotimplicit implicitplot}}\index{plotimplicit}\index{implicitplot}\index{unfactored}
\noindent{\tt plotimplicit} or {\tt implicitplot} draws curves or 
surfaces defined by an implicit expression or equation. 
If the option {\tt unfactored} is given as last argument, the
original expression is taken unmodified. Otherwise,
the expression is normalized, then replaced by the
factorization of the numerator of it's normalization.

Each factor of the expression corresponds to a component
of the implicit curve or surface. For each factor,
Xcas tests if it is of total
degree less or equal to 2, in that case {\tt conic} or
{\tt quadric} is called. Otherwise the numeric implicit solver
is called. 

Optional step and ranges arguments may be passed to the numeric
implicit solver, note that they are dismissed for each component
that is a conic or a quadric.

\subsection{2D implicit curve}\label{sec:implicitplot}
\begin{itemize}
\item {\tt plotimplicit(f(x,y),x,y)} draws the graphic representation of the
curve defined by the implicit equation $f(x,y)=0$ when $x$ (resp $y$) 
is in {\tt WX-, WX+} (resp in {\tt WY-, WY+}) defined by {\tt cfg}, 

\item {\tt plotimplicit(f(x,y),x=0..1,y=-1..1)} draws the graphic 
representation of the curve defined by the implicit equation $f(x,y)=0$ 
when $0\leq x \leq 1$ and $-1\leq y \leq 1$
\end{itemize} 
It is possible to add two arguments to specify the discretisation
steps for $x$ 
and $y$ with {\tt xstep=...} and {\tt ystep=...}.\\
Input :
\begin{center}{\tt plotimplicit(x\verb|^|2+y\verb|^|2-1,x,y)}\end{center}
Or :
\begin{center}{\tt plotimplicit(x\verb|^|2+y\verb|^|2-1,x,y,unfactored)}\end{center}
Output :
\begin{center}{\tt The unit circle}\end{center}
Input :
\begin{center}{\tt plotimplicit(x\verb|^|2+y\verb|^|2-1,x,y,xstep=0.2,ystep=0.3)}\end{center}
Or :
\begin{center}{\tt plotimplicit(x\verb|^|2+y\verb|^|2-1,[x,y],xstep=0.2,ystep=0.3)}\end{center}
Or :
\begin{center}{\tt plotimplicit(x\verb|^|2+y\verb|^|2-1,[x,y], xstep=0.2,ystep=0.3,unfactored)}\end{center}
Output :
\begin{center}{\tt The unit circle}\end{center}
Input :
\begin{center}{\tt plotimplicit(x\verb|^|2+y\verb|^|2-1,x=-2..2,y=-2..2, xstep=0.2,ystep=0.3)}\end{center}
Output :
\begin{center}{\tt The unit circle}\end{center}

\subsection{3D implicit surface}\label{sec:implicitplot3}
\begin{itemize}
\item {\tt plotimplicit(f(x,y,z),x,y,z)} draws the graphic 
representation of the surface defined by the implicit equation $f(x,y,z)=0$, 
\item {\tt plotimplicit(f(x,y,z),x=0..1,y=-1..1,z=-1..1)} draws the surface 
defined by the implicit equation $f(x,y,z)=0$, 
where $0\leq x \leq 1$, $-1\leq y \leq 1$ and $-1\leq z \leq 1$.
\end{itemize}
It is possible to add three arguments to specify the discretisation
steps used for $x$, $y$ and $z$ with {\tt xstep=...}, {\tt ystep=...} and 
{\tt zstep=...}.\\
Input :
\begin{center}{\tt plotimplicit(x\verb|^|2+y\verb|^|2+z\verb|^|2-1,x,y,z, xstep=0.2,ystep=0.1,zstep=0.3)}\end{center}
Input :
\begin{center}{\tt plotimplicit(x\verb|^|2+y\verb|^|2+z\verb|^|2-1,x,y,z, xstep=0.2,ystep=0.1,zstep=0.3,unfactored)}\end{center}
Output :
\begin{center}{\tt The unit sphere}\end{center}
Input :
\begin{center}{\tt plotimplicit(x\verb|^|2+y\verb|^|2+z\verb|^|2-1,x=-1..1,y=-1..1,z=-1..1)}\end{center}
Output :
\begin{center}{\tt The unit sphere}\end{center}

\section{Parametric curves and surfaces : {\tt plotparam paramplot DrawParm}}\index{plotparam|textbf}\index{paramplot|textbf}\index{DrawParm|textbf}
\subsection{2D parametric curve }
\noindent {\tt plotparam([f(t),g(t)],t)}
or {\tt plotparam(f(t)+i*g(t),t)} (resp 
{\tt plotparam(f(t)+i*g(t),t=t1..t2)})
draws the parametric representation of the curve 
defined by  $x=f(t),y=g(t)$ 
with the default range of values of $t$ (resp for $t1 \leq t\leq t2$).\\
The default range of values is taken as specified 
in the graphic configuration ({\tt t-} and {\tt t+}, 
cf. \ref{sec:configgeo}).
{\tt plotparam} accepts an optional argument to specify the discretisation
step for $t$ with {\tt tstep=}.\\ 
Input :
\begin{center}{\tt plotparam(cos(x)+i*sin(x),x) }\end{center}
or :
\begin{center}{\tt plotparam([cos(x),sin(x)],x) }\end{center}
Output :
\begin{center}{\tt The unit circle}\end{center}
If in the graphic configuration {\tt t} goes from -4 to 1, input :
\begin{center}{\tt plotparam(sin(t)+i*cos(t))}\end{center}
or :
\begin{center}{\tt plotparam(sin(t)+i*cos(t),t=-4..1) }\end{center}
or :
\begin{center}{\tt plotparam(sin(x)+i*cos(x),x=-4..1) }\end{center}
Output :
\begin{center}{\tt the arc (sin(-4)+i*cos(-4),sin(1)+i*cos(1)) of the unit circle}\end{center}
If in the graphic configuration {\tt t} goes from -4 to 1, input :
\begin{center}{\tt plotparam(sin(t)+i*cos(t),t,tstep=0.5)}\end{center}
Or :
\begin{center}{\tt plotparam(sin(t)+i*cos(t),t=-4..1,tstep=0.5)}\end{center}
Output :
\begin{center}{\tt A polygon approching the arc (sin(-4)+i*cos(-4),sin(1)+i*cos(1)) of the unit circle}\end{center}

\subsection{3D parametric surface : {\tt plotparam paramplot DrawParm}}\index{plotparam}\index{paramplot}\index{DrawParm}
\noindent{\tt plotparam} takes two main arguments,
a list of three 
expressions of two variables and the list of these variable names
where each variable name may be replaced by variable=interval
to specify the range of the parameters.
It accepts an optionnal argument to specify
the discretisation steps of the parameters $u$ and $v$ with 
{\tt ustep=...} and {\tt vstep=...}.\\
{\tt plotparam([f(u,v),g(u,v),h(u,v)],[u,v])} draws the surface defined by the 
first argument : $x=f(u,v),y=g(u,v),z=h(u,v)$, where $u$ and $v$
ranges default to the graphic configuration.\\
Input :
\begin{center}{\tt plotparam([v*cos(u),v*sin(u),v],[u,v])}\end{center}
Output :
\begin{center}{\tt The cone $x=v*\cos(u),y=v*\sin(u),z=v$}\end{center}
To specify the range of each parameters, replace each variable
by an equation variable=range, like this:
\begin{center}{\tt plotparam([v*cos(u),v*sin(u),v],[u=0..pi,v=0..3]) }\end{center}
Output :
\begin{center}{\tt A portion of the cone $x=v*\cos(u),y=v*\sin(u),z=v$}\end{center}
Input :
\begin{center}{\tt plotparam([v*cos(u),v*sin(u),v],[u=0..pi,v=0..3],ustep=0.5,vstep=0.5)}\end{center}
Output :
\begin{center}{\tt A portion of the cone $x=v*\cos(u),y=v*\sin(u),z=v$}\end{center}
 
\section{Curve defined in polar coordinates : {\tt plotpolar polarplot DrawPol courbe\_polaire}}\index{plotpolar|textbf}\index{polarplot|textbf}\index{DrawPol|textbf}\index{courbe\_polaire|textbf}
\noindent Let $E_t$ be an expression depending of the variable $t$.\\
{\tt plotpolar($E_t$,t)} draws the polar representation of the
curve defined by $\rho=E_t$ for $\theta=t$, that is
in cartesian coordinates the curve $(E_t \cos(t),E_t \sin(t))$.
The range of the parameter may be specified by replacing the second argument
by {\tt t=tmin..tmax}. The discretisation parameter may be specified
by an optional {\tt tstep=...} argument.\\
Input 
\begin{center}{\tt  plotpolar(t,t)}\end{center}
Output :
\begin{center}{\tt The spiral $\rho$=t is plotted}\end{center}
Input
\begin{center}{\tt  plotpolar(t,t,tstep=1)}\end{center}
or :
\begin{center}{\tt  plotpolar(t,t=0..10,tstep=1)}\end{center}
Output :
\begin{center}{\tt A polygon line approaching the spiral $\rho$=t is plotted}\end{center}

\section{Graph of a recurrent sequence : {\tt plotseq seqplot graphe\_suite}}\index{plotseq}\index{seqplot}\index{graphe\_suite}\label{sec:plotseq}
\noindent Let $f(x)$ be an expression depending of the variable $x$ 
(resp. $f(t)$ an expression depending of the variable $t$).\\
{\tt plotseq($f(x)$,a,n)} (resp. {\tt plotseq($f(t)$,t=a,n)}) draws the line 
$y=x$, the graph of $y=f(x)$ (resp $y=f(t)$) and the $n$ first terms of the
recurrent sequence defined by : $u_0=a,\ \ u_n=f(u_{n-1})$.
The $a$ value may be replaced by a list of 3 elements, $[a,x_-,x_+]$
where $x_-..x_+$ will be passed as $x$ range for the graph computation.\\ 
Input :
\begin{center}{\tt plotseq(sqrt(1+x),x=[3,0,5],5)}\end{center}
Output :
\begin{center}{\tt the graph of y=sqrt(1+x), of y=x and of the 5 first terms of the sequence u\_0=3 and u\_n=sqrt(1+u\_(n-1))}\end{center}

\section{Tangent field : {\tt plotfield fieldplot}}\index{plotfield}\index{fieldplot}
\begin{itemize}
\item Let $f(t,y)$ be an expression depending of two variables $t$ and $y$, 
then :
\begin{center}
{\tt plotfield(f(t,y),[t,y])}
\end{center} 
draws the tangent field of the 
differential equation $y'=f(t,y)$ where $y$ is a real variable and
where $t$ is the abscissa,
\item Let $V$ be 
a vector of two expressions depending of 2 variables $x,y$ but 
independant of the time $t$, then 
\begin{center}
{\tt plotfield(V,[x,y])}
\end{center}
draws the vector field $V$,
\item The range of values of $t,y$ or of $x,y$ can be specified with\\
{\tt t=tmin..tmax}, {\tt x=xmin..xmax}, {\tt y=ymin..ymax}\\
in place of the variable name.
\item The discretisation may be specified with optional
arguments {\tt xstep=...}, {\tt ystep=...}.
\end{itemize}
Input :
\begin{center}{\tt plotfield(4*sin(t*y),[t=0..2,y=-3..7]) }\end{center}
Output :
\begin{center}{\tt Segments with slope 4*sin(t*y), representing tangents, are plotting in different points}\end{center}
With two variables $x,y$, input :
\begin{center}
{\tt plotfield(5*[-y,x],[x=-1..1,y=-1..1]) }
\end{center}

\section{Plotting a solution of a differential equation : {\tt plotode odeplot}}\index{plotode}\index{odeplot}
\noindent Let $f(t,y)$ be an expression depending of two variables 
$t$ and $y$.
\begin{itemize}
\item {\tt plotode($f(t,y)$,[t,y],[t0,y0])} draws the solution of 
the differential equation $y'=f(t,y)$ crossing through 
the point {\tt (t0,y0)} (i.e. such that $y(t_0)=y_0$)
\item
By default, $t$ goes in both directions. The range of value of $t$
may be specified by the optional argument
{\tt t=tmin..tmax}.
\item
We can also represent, in the space or in the plane,
the solution of a differential equation 
$y'=f(t,y)$ where $y=(X,Y)$ is a vector of size 2.
Just replace  $y$ by the variable names $X,Y$
and the initial value $y_0$ by the two initial values of the
variables at time $t_0$.
\end{itemize}
Input :
\begin{center}{\tt plotode(sin(t*y),[t,y],[0,1]) }\end{center}
Output :
\begin{center}{The graph of the solution of y'=sin(t,y) crossing through the point (0,1)}\end{center}
Input~:
\begin{center}
{\tt S:=odeplot([h-0.3*h*p, 0.3*h*p-p], [t,h,p],[0,0.3,0.7])}
\end{center}
Output, the graph in the space of the solution of :
\[ [h,p]'=[h-0.3 h*p, 0.3 h*p-p] \quad [h,p](0)=[0.3,0.7] \]
To have a 2-d graph (in the plane), use the option 
{\tt plane}
\begin{center}
{\tt S:=odeplot([h-0.3*h*p, 0.3*h*p-p], [t,h,p],[0,0.3,0.7],plane)}
\end{center}
To compute the values of the solution, see
the section \ref{sec:odesolve}.

\section{Interactive plotting of solutions of a differential equation : {\tt interactive\_plotode interactive\_odeplot}}\index{interactive\_plotode}\index{interactive\_odeplot}
\noindent Let $f(t,y)$ be an expression depending of two 
varaiables $t$ and $y$.\\
{\tt interactive\_plotode(f(t,y),[t,y])} draws the tangent field
of the differential equation $y'=f(t,y)$ in a new window. 
In this window, one can click on a point to get the 
plot of the solution of $y'=f(t,y)$ crossing through this point.\\
You can further click to display 
several solutions. To stop  press
the {\tt Esc} key.\\
Input :
\begin{center}{\tt interactive\_plotode(sin(t*y),[t,y]) }\end{center}
Output :
\begin{center}{\tt The tangent field is plotted with the
    solutions of y'=sin(t,y) crossing through the points defined by
     mouse clicks}\end{center}

\section{Animated graphs (2D, 3D or "4D")}
{\tt Xcas} can display animated 2D, 3D or "4D" graphs. 
This is done first by computing
a sequence of graphic objects, then after completion,
by displaying the sequence in a loop.
\begin{itemize} 
\item To stop or start again the animation, click on the button 
$\blacktriangleright \mid$ (at the left of {\tt Menu}).
\item
The display time of each graphic objet is specified in {\tt animate} of the
graph configuration ({\tt cfg} button). Put a small time, 
to have a fast animation.
\item
If {\tt animate} is {\tt 0}, the animation is frozen,
you can move in the sequence of objects one by one by clicking
on the mouse in the graphic scene.
\end{itemize}

\subsection{Animation of a 2D graph~: {\tt animate}}\index{animate}
\noindent{\tt animate} can create a 2-d animation with graphs of functions
depending of a parameter. The parameter is specified as the 
third argument of 
{\tt animate}, the number of pictures as fourth argument with
{\tt frames=}\index{frames@{\sl frames}|textbf}number, 
the remaining arguments are the same as those of the {\tt plot} command, 
see section \ref{sec:plot2d}, p. \pageref{sec:plot2d}.\\
Input :
\begin{center}
{\tt animate(sin(a*x),x=-pi..pi,a=-2..2,frames=10,color=red)}
\end{center}
Output :
\begin{center}{\tt a sequence of graphic representations of y=sin($a$x) for 
11 values of $a$ between -2 and 2}\end{center}

\subsection{Animation of a 3D graph~: {\tt animate3d}}\index{animate3d}
\noindent{\tt animate3d} can create a 3-d animation with 
function graphs depending of a parameter. The parameter is specified as
the third argument of {\tt animate3d}, the number of pictures
as fourth argument with 
{\tt frames=}\index{frames@{\sl frames}}number, the remaining arguments
are the same as those of the {\tt plotfunc} command, see
section \ref{sec:plotfunc3}, p. \pageref{sec:plotfunc3}.\\
Input :
\begin{center}
{\tt animate3d(x\verb|^|2+a*y\verb|^|2,[x=-2..2,y=-2..2],a=-2..2, frames=10,display=red+filled)}
\end{center}
Output :
\begin{center}{\tt a sequence of graphic representations
 of z=x\verb|^|2+$a$*y\verb|^|2 for 11 values of $a$ between -2 and 2}
\end{center}

\subsection{Animation of a sequence of graphic objects~: {\tt animation}}\index{animation}
\noindent{\tt animation} animates the representation of a
sequence of graphic objects
with a given display time. The sequence of objects depends most of
the time of a parameter and is defined using the {\tt seq} command
but it is not mandatory.\\
{\tt animation} takes as argument the sequence of graphic objects.\\
To define a sequence of graphic objects with {\tt seq},
enter the definition of the graphic object (depending on
the parameter), the parameter name, it's minimum value, it's
 maximum value maximum and optionnaly a step value.\\
Input :
\begin{center}{\tt animation(seq(plotfunc(cos(a*x),x),a,0,10))}\end{center}
Output :
\begin{center}{\tt The sequence of the curves defined by $y=\cos(ax)$, for $a=0,1,2..10$}\end{center}
Input :
\begin{center}
{\tt animation(seq(plotfunc(cos(a*x),x),a,0,10,0.5))}\\
or\\
{\tt animation(seq(plotfunc(cos(a*x),x),a=0..10,0.5))}
\end{center}
Output :
\begin{center}{\tt The sequence of the curves defined by $y=\cos(ax)$, for $a=0,0.5,1,1.5..10$ }\end{center}
Input :
\begin{center}{\tt animation(seq(plotfunc([cos(a*x),sin(a*x)],x=0..2*pi/a), a,1,10))}\end{center}
Output :
\begin{center}{\tt The sequence of two curves defined by $y=\cos(ax)$ and $y=\sin(ax)$, for $a=1..10$ and for $x=0..2\pi/a$ }\end{center}
Input :
\begin{center}{\tt animation(seq(plotparam([cos(a*t),sin(a*t)], t=0..2*pi),a,1,10))}\end{center}
Output :
\begin{center}{\tt The sequence of the parametric curves defined by  $x=\cos(at)$ and $y=\sin(at)$, for $a=1..10$ and for $t=0..2\pi$ }\end{center}
Input :
\begin{center}{\tt animation(seq(plotparam([sin(t),sin(a*t)], t,0,2*pi,tstep=0.01),a,1,10))}\end{center}
Output :
\begin{center}{\tt The sequence of the parametric curves defined by $x=\sin(t),y=\sin(at)$, for $a=0..10$ and $t=0..2\pi$}\end{center}
Input :
\begin{center}{\tt animation(seq(plotpolar(1-a*0.01*t\verb|^|2, t,0,5*pi,tstep=0.01),a,1,10))}\end{center}
Output :
\begin{center}{\tt The sequence of the polar curves defined by $\rho=1-a*0.01*t^2$, for $a=0..10$ and $t=0..5\pi$}\end{center}
Input :
\begin{center}{\tt plotfield(sin(x*y),[x,y]); animation(seq(plotode(sin(x*y),[x,y],[0,a]),a,-4,4,0.5))}\end{center}
Output :
\begin{center}{\tt The tangent field of y'=sin(xy) and the sequence of the integral curves crossing through the point $(0,a)$ for $a$=-4,-3.5...3.5,4}\end{center}
Input :
\begin{center}{\tt animation(seq(display(square(0,1+i*a),filled),a,-5,5))}\end{center}
Output :
\begin{center}{\tt The sequence of the squares defined by the points 0 and 1+i*$a$ for $a=-5..5$}\end{center}
Input :
\begin{center}{\tt animation(seq(droite([0,0,0],[1,1,a]),a,-5,5))}\end{center}
Output :
\begin{center}{\tt The sequence of the lines defined by the points [0,0,0] and [1,1,$a$] for $a=-5..5$}\end{center}
Input :
\begin{center}{\tt animation(seq(plotfunc(x\verb|^|2-y\verb|^|a,[x,y]),a=1..3))}\end{center}
Output :
\begin{center}{\tt The sequence of the "3D" surface defined by $x^2-y^a$, for $a=1..3$ with rainbow colors}\end{center}
Input :
\begin{center}{\tt animation(seq(plotfunc((x+i*y)\verb|^|a,[x,y], display=filled),a=1..10)}\end{center}
Output :
\begin{center}{\tt The sequence of the "4D" surfaces defined by $(x+i*y)^a$, for $a=0..10$ with rainbow colors}\end{center}

{\bf Remark}
We may also define the sequence with a program, 
for example if we want to draw the
segments of length $1,\sqrt 2...\sqrt 20$ constructed with a 
right triangle of side 1 and the previous segment
(note that there is a {\tt c:=evalf(..)} statement
to force approx. evaluation otherwise the computing time 
would be too long) :
\begin{verbatim}
seg(n):={
 local a,b,c,j,aa,bb,L;
 a:=1;
 b:=1;
 L:=[point(1)];
 for(j:=1;j<=n;j++){
  L:=append(L,point(a+i*b));
  c:=evalf(sqrt(a^2+b^2));
  aa:=a;
  bb:=b;
  a:=aa-bb/c;
  b:=bb+aa/c;
 }
 L;
}
\end{verbatim}
Then input : 
\begin{center}{\tt animation(seg(20))}\end{center}
We see, each point, one to one with a display time that
depends of the {\tt animate} value in {\tt cfg}.\\
Or :
\begin{center}{\tt L:=seg(20); s:=segment(0,L[k])\$(k=0..20)}\end{center}
We see 21 segments. \\
Then, input :
\begin{center}{\tt animation(s)}\end{center}
We see, each segment, one to one with a display time that
depends of the {\tt animate} value in {\tt cfg}.



\chapter{Numerical computations}\label{sec:numeric}
Real numbers may have an exact representation
(e.g. rationals, symbolic expressions
involving square roots or constants like $\pi$, ...)
or approximate representation, which means that the real
is represented by a rational (with a denominator that is a power
of the basis of the representation) close to the real.
Inside {\tt Xcas}, the standard scientific notation is used
for approximate representation, that is a mantissa (with a point
as decimal separator) optionnally followed by the letter {\tt e}
and an integer exponent.

Note that the real number $10^{-4}$ is an exact number but
$1e-4$ is an approximate representation of this number.

\section{Floating point representation.}
In this section, we explain how real numbers are represented.

\subsection{Digits}
The {\tt Digits} variable is used to control how real numbers
are represented and also how they are displayed.
When the specified
number of digits is less or equal to 14 (for example {\tt
  Digits:=14}), then hardware floating point
numbers are used and they are displayed using the specified
number of digits.
When {\tt Digits} is larger than 14, Xcas uses the MPFR
library, the representation is similar to hardware floats
(cf. infra) but the number of bits of
the mantissa is not fixed and the range of exponents is much larger.
More precisely, the number of bits of the mantissa of created MPFR float
is {\tt ceil(Digits*log(10)/log(2))}.

Note that if you change the value of {\tt Digits}, this will affect
the creation of new real numbers compiled from commandlines 
or programs or by instructions like {\tt approx}, but it will
not affect existing real numbers. Hence hardware floats may coexist
with MPFR floats, and even in MPFR floats, some may have 100 bits
of mantissa and some may have 150 bits of mantissa. If operations
mix different kinds of floats, the most precise kind of floats
are coerced to the less precise kind of floats.

\subsection{Representation by hardware floats}
A real is represented by a floating number $d$, that is
\[ d=2^\alpha*(1+m),  \quad 0<m<1, -2^{10} < \alpha < 2^{10} \]
If $\alpha>1-2^{10}$, then $m \geq 1/2$, and $d$ is
a normalized floating point number, otherwise
$d$ is denormalized ($\alpha=1-2^{10}$). The special exponent $2^{10}$
is used to represent plus or minus infinity and NaN (Not a Number).
A hardware float is made of 64 bits:
\begin{itemize}
\item  the first bit is for the sign of $d$ (0 for '+' and 1 for '-')
\item  the 11 following bits represents the exponent, more precisely 
if $\alpha$ denotes the integer from the 11 bits,
the exponent is $\alpha+2^{10}-1$, 
\item  the 52 last bits codes the mantissa $m$, more precisely if
$M$ denotes the integer from the 52 bits, then
$m=1/2+M/2^{53}$ for normalized floats and $m=M/2^{53}$ for
denormalized floats.
\end{itemize}
Examples of representations of the exponent:
\begin{itemize}
\item $\alpha=0$ is coded by 011 1111 1111
\item $\alpha=1$ is coded by 100 0000 0000
\item $\alpha=4$ is coded by 100 0000 0011
\item $\alpha=5$ is coded by 100 0000 0100
\item $\alpha=-1$ is coded by 011 1111 1110
\item $\alpha=-4$ is coded by 011 1111 1011
\item $\alpha=-5$ is coded by 011 1111 1010
\item $\alpha=2^{10}$ is coded by 111 1111 1111
\item $\alpha=2^{-10}-1$ is coded by 000 0000 000
\end{itemize}
{\bf Remark}: $2^{-52}=0.2220446049250313e-15$

\subsection{Examples of representations of normalized floats}
\begin{itemize}
\item 3.1 :\\
We have :
\begin{eqnarray*}
3.1&=&2*(1+\frac{1}{2}+\frac{1}{2^5}+\frac{1}{2^6}+
\frac{1}{2^9}+\frac{1}{2^{10}}+....)\\
&=&2*(1+\frac{1}{2}+\sum_{k=1}^\infty(\frac{1}{2^{4*k+1}}+\frac{1}{2^{4*k+2}}) ) 
\end{eqnarray*}
hence $\alpha=1$ and 
$m=\frac{1}{2}+\sum_{k=1}^\infty(\frac{1}{2^{4*k+1}}+\frac{1}{2^{4*k+2}})$.
Hence the hexadecimal and binary representation of 3.1 is:
\begin{verbatim}
40 (01000000), 8 (00001000), cc (11001100), cc (11001100), 
cc (11001100), cc (11001100), cc (11001100), cd (11001101),
\end{verbatim}
the last octet is 1101, the last bit is 1, because the
following digit is 1 (upper rounding).
\item  3. :\\
We have $3=2*(1+1/2)$.
Hence the hexadecimal and binary representation of 3 is:
\begin{verbatim}
40 (01000000), 8 (00001000), 0 (00000000), 0 (00000000), 
0 (00000000), 0 (00000000), 0 (00000000), 0 (00000000)
\end{verbatim}
\end{itemize}

\subsection{Difference between the representation of (3.1-3) and of 0.1}
\begin{itemize}
\item representation of  0.1 :\\
We have :
\[ 0.1=2^{-4}*(1+\frac{1}{2}+\frac{1}{2^4}+\frac{1}{2^5}+
\frac{1}{2^8}+\frac{1}{2^9}+...)=
2^{-4}*\sum_{k=0}^\infty (\frac{1}{2^{4*k}}+\frac{1}{2^{4*k+1}}) \]
hence $\alpha=1$ and $m=\frac{1}{2}+
\sum_{k=1}^\infty (\frac{1}{2^{4*k}}+\frac{1}{2^{4*k+1}})$,
therefore the representation of 0.1 is
\begin{verbatim}
3f (00111111), b9 (10111001), 99 (10011001), 99 (10011001),
99 (10011001), 99 (10011001), 99 (10011001), 9a (10011010),
\end{verbatim}
the last octet is 1010, indeed the 2 last bits 
01 became 10  because the following digit is 1 (upper rounding).

\item representation of a:=3.1-3 :\\
Computing a is done by adjusting exponents (here nothing
to do), then substract the mantissa, and adjust the
exponent of the result to have a normalized float.
The exponent is $\alpha=-4$ (that corresponds at $2*2^{-5}$) 
and the bits 
corresponding to the mantissa begin at $1/2=2*2^{-6}$ :
the bits of the mantissa are shifted to the left of 5 positions
and we have :
\begin{verbatim}
3f (00111111), b9 (10111001), 99 (10011001), 99 (10011001),
99 (10011001), 99 (10011001), 99 (10011001), 9a (10100000),
\end{verbatim}
Therefore
$a>0.1$ and  $a-0.1=1/2^{50}+1/2^{51}$ 
(since 100000-11010=110)
\end{itemize}
{\bf Remark}\\
This is the reason why
\begin{center}
{\tt floor(1/(3.1-3))} 
\end{center}
returns {\tt 9} and not {\tt 10} when {\tt Digits:=14}.

\section{Approx. evaluation : {\tt evalf approx} and {\tt Digits}}\index{evalf|textbf}\index{approx|textbf}\index{DIGITS}\index{Digits}
\noindent {\tt evalf} or {\tt approx} evaluates to a numeric
approximation (if possible).\\
Input :
\begin{center}{\tt evalf(sqrt(2))}\end{center}
Output, if in the {\tt cas} configuration ({\tt Cfg} menu) {\tt Digits=7} 
(that is hardware floats are used, and 7 digits are displayed) :
\begin{center}{\tt 1.414214}\end{center}
You can change the number of digits in a commandline by assigning 
the variable {\tt DIGITS} or {\tt Digits}.
Input :
\begin{center}{\tt DIGITS:=20}\end{center}
\begin{center}{\tt evalf(sqrt(2))}\end{center}
Output :
\begin{center}{\tt 1.4142135623730950488}\end{center}
Input : 
\begin{center}{\tt evalf(10\verb|^|-5)}\end{center}
Output :
\begin{center}{\tt 1e-05}\end{center}
Input :
\begin{center}{\tt evalf(10\verb|^|15)}\end{center}
Output :
\begin{center}{\tt 1e+15}\end{center}
Input : 
\begin{center}{\tt evalf(sqrt(2))*10\verb|^|-5}\end{center}
Output :
\begin{center}{\tt 1.41421356237e-05}\end{center}

\section{Numerical algorithms}
\subsection{Approximate solution of an equation : {\tt newton}}\index{newton}
\noindent{\tt newton} takes as arguments : an expression {\tt ex}, 
the variable
name of this expression (by default {\tt x}), and three values {\tt a} (by 
default {\tt a=0}), {\tt eps} (by default {\tt eps=1e-8}) and {\tt nbiter} 
(by default {\tt nbiter=12}).\\
{\tt newton(ex,x,a,eps,nbiter)} computes an approximate 
solution {\tt x} of the equation {\tt ex=0}
using the Newton algorithm with starting point 
{\tt x=a}. The maximum number of iterations is {\tt nbiter}
and the precision is {\tt eps}.\\
Input :
\begin{center}{\tt newton(x\verb|^|2-2,x,1) }\end{center}
Output :
\begin{center}{\tt 1.41421356237}\end{center}
Input :
\begin{center}{\tt newton(x\verb|^|2-2,x,-1) }\end{center}
Output :
\begin{center}{\tt -1.41421356237}\end{center}
Input :
\begin{center}{\tt newton(cos(x)-x,x,0)}\end{center}
Output :
\begin{center}{\tt0.739085133215 }\end{center}

\subsection{Approximate computation of the derivative  number : {\tt nDeriv}}\index{nDeriv}
\noindent{\tt nDeriv} takes as arguments : an expression {\tt ex}, the variable
name of this expression (by default {\tt x}), and {\tt h} (by default 
{\tt h=0.001}).\\
{\tt nDeriv(ex,x,h)} computes an approximated value of the derivative of the
expression {\tt ex} at the point {\tt x} and returns :
\begin{center}{\tt (f(x+h)-f(x+h))/2*h}\end{center}
Input :
\begin{center}{\tt nDeriv(x\verb|^| 2,x)}\end{center}
Output :
\begin{center}{\tt ((x+0.001)\verb|^|2-(x+-0.001)\verb|^|2)*500.0}\end{center}
Input :
\begin{center}{\tt subst(nDeriv(x\verb|^| 2,x),x=1)}\end{center}
Output :
\begin{center}{\tt 2}\end{center}
Input :
\begin{center}{\tt nDeriv(exp(x\verb|^| 2),x,0.00001)}\end{center}
Output :
\begin{center}{\tt (exp((x+1e-05)\verb|^|2)-exp((x+-1e-05)\verb|^|2))*50000}\end{center}
Input :
\begin{center}{\tt subst(exp(nDeriv(x\verb|^| 2),x,0.00001),x=1)}\end{center}
Output :
\begin{center}{\tt 5.43656365783}\end{center}
which is an approximate value of {\tt 2e=5.43656365692}.

\subsection{Approximate computation of integrals : {\tt romberg nInt}}\index{romberg}\index{nInt}
\noindent{\tt romberg} or {\tt nInt} takes as arguments : an expression 
{\tt ex}, the variable name of this expression (by default {\tt x}), and 
two real values {\tt a,b}.\\
{\tt romberg(ex,x,a,b)} or {\tt nInt(ex,x,a,b)} computes an approximated 
value of the integral  $\int_a^b ex\ dx$ using the Romberg method. The
integrand must be sufficiently regular for the approximation to
be accurate. Otherwise, {\tt romberg} returns a list of real values,
that comes from the application of the
Romberg algorithm (the first list element is
the trapezoid rule approximation, the next ones come from the application
of the Euler-Mac Laurin formula to remove successive even powers of
the step of the trapezoid rule).\\
Input :
\begin{center}{\tt romberg(exp(x\verb|^|2),x,0,1)}\end{center}
Output :
\begin{center}{\tt 1.46265174591}\end{center}

\subsection{Approximate solution of y'=f(t,y) : {\tt odesolve}}\index{odesolve|textbf}
\begin{itemize}
\item Let $f$ be a function from $\mathbb R^2$ to $\mathbb R$.\\
 {\tt odesolve(f(t,y),[t,y],[t0,y0],t1)} or\\
{\tt odesolve(f(t,y),t=t0..t1,y,y0)} or\\
{\tt odesolve(t0..t1,f,y0)} or\\
{\tt odesolve(t0..t1,(t,y)->f(t,y),y0)}\\
returns an approximate value of $y(t1)$ where $y(t)$ is the  
solution of:
\[ y'(t)=f(t,y(t)), \quad  y(t0)=y0 \]
\item {\tt odesolve} accepts an optional argument for the 
discretisation of {\tt t} ({\tt tstep=value}). 
This value is passed as initial tstep value to the numeric solver
from the GSL (Gnu Scientific Library), it may be modified
by the solver. It is also used to control the number of iterations
of the solver by {\tt 2*(t1-t0)/tstep} (if the number
of iterations exceeds this value, the solver will stopsat a time $t<t1$).
\item {\tt odesolve} accepts {\tt curve} as an optional argument.
In that case, 
{\tt odesolve} returns the list of all the [$t,[y(t)]$] values
that where computed.
\end{itemize}
Input :
\begin{center}{\tt odesolve(sin(t*y),[t,y],[0,1],2)}\end{center}
or :
\begin{center}{\tt odesolve(sin(t*y),t=0..2,y,1)}\end{center}
or :
\begin{center}{\tt odesolve(0..2,(t,y)->sin(t*y),1)}\end{center}
or define the function :
\begin{center}{\tt f(t,y):=sin(t*y)} \end{center}
and input :
\begin{center}{\tt odesolve(0..2,f,1)}\end{center}
Output :
\begin{center}{\tt [1.82241255675]}\end{center}
Input :
\begin{center}{\tt odesolve(0..2,f,1,tstep=0.3)}\end{center}
Output :
\begin{center}{\tt [1.82241255675]}\end{center}
Input :
\begin{center}{\tt odesolve(sin(t*y),t=0..2,y,1,tstep=0.5)}\end{center}
Output :
\begin{center}{\tt [1.82241255675]}\end{center}
Input :
\begin{center}{\tt odesolve(sin(t*y),t=0..2,y,1,tstep=0.5,curve)}\end{center}
Output :
\begin{center}{\tt [[0.760963063136,[1.30972370515]],[1.39334557388,[1.86417104853]]]}\end{center}


\subsection{Approximate solution of the system v'=f(t,v) : {\tt odesolve}}\index{odesolve}
\begin{itemize}
\item If $v$ is a vector
of variables $[x1,..,xn]$ and if $f$ is given by a vector  of expressions
{\tt [e1,...,en]} depending of $t$ and of $[x1,..,xn]$,
if the  init value of $v$ at {\tt t0}
is the vector $[x10,...,xn0]$ then the instruction
\begin{center}
{\tt odesolve([e1,..,en],t=t0..t1,[x1,...,xn],
[x10,...,xn0])} 
\end{center}
returns an approximated value of $v$ at $t=t1$.
With the optional argument {\tt curve}, {\tt odesolve} returns the list of 
the intermediate values of [$t,v(t)$] computed by the solver. 

Example, to solve the system
\begin{eqnarray*}
x'(t) &=&-y(t)\\
y'(t)&=&x(t)
\end{eqnarray*}
input :
\begin{center}
{\tt odesolve([-y,x],t=0..pi,[x,y],[0,1])}\end{center}
Output :
\begin{center}{\tt  [-1.79045146764e-15,-1]}\end{center}

\item  If $f$ is a function from $\mathbb R \times \mathbb R^n$ to 
$\mathbb R^n$.\\
{\tt odesolve(t0..t1,(t,v)->f(t,v),v0)} or\\
{\tt odesolve(t0..t1,f,v0)}\\
computes an approximate value of $v(t1)$ where the vector $v(t)$
in $\mathbb R^n$ is the solution of
\[ v'(t)=f(t,v(t)), v(t0)=v0 \]
With the optional argument {\tt curve}, {\tt odesolve} returns the list of 
the intermediate value [$t,v(t)$] computed by the solver.

Example, to solve the system :\\
\begin{eqnarray*}
x'(t) &=&-y(t)\\
y'(t)&=&x(t)
\end{eqnarray*}
Input :
\begin{center}{\tt odesolve(0..pi,(t,v)->[-v[1],v[0]],[0,1])}\end{center}
Or define the function:
\begin{center}{\tt f(t,v):=[-v[1],v[0]]}\end{center}
then input : 
\begin{center}{\tt odesolve(0..pi,f,[0,1])}\end{center}
Output :
\begin{center}{\tt  [-1.79045146764e-15,-1]}\end{center}
Alternative input :
\begin{center}{\tt odesolve(0..pi/4,f,[0,1],curve)}\end{center}
Output :
\begin{center}{\tt  [[0.1781,[-0.177159948386,0.984182072936]], [0.3781,[-0.369155338156,0.929367707805]], [0.5781,[-0.54643366953,0.837502384954]], [0.7781,[-0.701927414872,0.712248484906]]]}\end{center}
\end{itemize}


\section{Solve equations with {\tt fsolve nSolve}}\index{fsolve}\index{nSolve}
\noindent{\tt fsolve} or {\tt nSolve} solves numeric equations
(unlike {\tt solve} or {\tt proot}, it is not limited to polynomial 
equations) of the form:
\[ f(x)=0, \quad x \in ]a,b[ \]
{\tt fsolve} or de {\tt nSolve} accepts a last optional argument,
the name of an iterative algorithm to be used by the GSL solver.
The different methods are explained in the following section.

\subsection{{\tt fsolve} or {\tt nSolve} with the option {\tt bisection\_solver}}\index{bisection\_solver@{\sl bisection\_solver}|textbf}
This algorithm of dichotomy is the simplest but also generically
the slowest. 
It encloses the zero of a function on an interval. 
Each iteration, cuts the interval into two parts. We compute the middle point 
value. The function sign at this point, gives us the half-interval 
on which the next iteration will be performed.\\
Input :
\begin{center}{\tt fsolve((cos(x))=x,x,-1.. 1,bisection\_solver)}\end{center}
Output :
\begin{center}{\tt [0.739085078239,0.739085137844]}\end{center}

\subsection{{\tt fsolve} or {\tt nSolve} with the option {\tt brent\_solver}}\index{brent\_solver{\sl brent\_solver}|textbf}\index{color@{\sl }|textbf}
The Brent method interpolates of $f$ at three points, finds
the intersection of the interpolation with the $x$ axis, computes
the sign of $f$ at this point and chooses the interval where the sign changes.
%: on prend l'intersection de la courbe d'interpolaton passant par 3 points with l'axe des $x$
It is generically faster than bisection.\\
Input :
\begin{center}{\tt fsolve((cos(x))=x,x,-1..1,brent\_solver)}\end{center}
Output :
\begin{center}{\tt [0.73908513321 5,0.739085133215]}\end{center}

\subsection{{\tt fsolve} or {\tt nSolve} with the option {\tt falsepos\_solver}}\index{falsepos\_solver{\sl falsepos\_solver}|textbf}
The "false position" algorithm is an iterative algorithm based on linear 
interpolation : we compute the value of $f$ at the intersection of the line  
$(a,f(a))$, $(b,f(b))$ with the $x$ axis. This value gives us the part of the 
interval containing the root, and on which a new iteration is performed.\\
The convergence is linear but generically faster than bisection.\\
Input :
\begin{center}{\tt fsolve((cos(x))=x,x,-1..1,falsepos\_solver)}\end{center}
Output :
\begin{center}{\tt [0.739085133215,0.739085133215]}\end{center}

\subsection{{\tt fsolve} or {\tt nSolve} with the option {\tt newton\_solver}}\index{newton\_solver{\sl newton\_solver}|textbf}
{\tt newton\_solver} is the standard Newton method.
The algorithm starts at an init value  $x_0$, then we search the 
intersection $x_1$ of the tangent at $x_0$ to the graph of $f$, with the $x$ 
axis, the next iteration is done with $x_1$ instead of $x_0$.
The  $x_i$ sequence is defined by
\[ x_0=x_0, \quad x_{n+1}=x_n-\frac{f(x_n)}{f'(x_n)} \]
If the Newton method converges, it is a quadratic convergence for 
roots of multiplicity 1.\\
Input :
\begin{center}{\tt fsolve((cos(x))=x,x,0,newton\_solver)}\end{center}
Output :
\begin{center}{\tt 0.739085133215}\end{center}

\subsection{{\tt fsolve} or {\tt nSolve} with the option {\tt secant\_solver}}\index{secant\_solver{\sl secant\_solver}|textbf}
The secant methode is a simplified version of the Newton method.
The computation of $x_1$ is done using the Newton method.
The computation of $f'(x_n), n>1$ is done approximatively. 
This method is used when the 
computation of the derivative is expensive:
\[ x_{i+1} = x_i-\frac{ f(x_i)}{f'_{est}}, \quad 
f'_{est} = \frac{f(x_i) - f(x_{i-1})}{(x_i - x_{i-1})}
\]
The convergence for roots of multiplicity 1
is of order $(1 + \sqrt5)/2 \approx 1.62... $.\\
Input :
\begin{center}{\tt fsolve((cos(x))=x,x,-1..1,secant\_solver)}\end{center}
Output :
\begin{center}{\tt [0.739085078239,0.739085137844]}\end{center}
Input :
\begin{center}{\tt fsolve((cos(x))=x,x,0,secant\_solver)}\end{center}
Output :
\begin{center}{\tt 0.739085133215}\end{center}

\subsection{{\tt fsolve} or {\tt nSolve} with the option {\tt steffenson\_solver}}\index{steffenson\_solver{\sl steffenson\_solver}|textbf}
The Steffenson method is generically the fastest method.\\
It combines the Newton method with a "delta-two" Aitken acceleration : 
with the Newton method, we obtain the sequence $x_i$ and the convergence
acceleration gives the Steffenson sequence 
\[ R_i =x_i - \frac{(x_{i+1} - x_i)^2}{ (x_{i+2} - 2 x_{i+1} + x_{i})} \]
Input :
\begin{center}{\tt fsolve(cos(x)=x,x,0,steffenson\_solver)}\end{center}
Output :
\begin{center}{\tt  0.739085133215}\end{center}

\section{Solve systems with {\tt fsolve}}\index{fsolve}
{\tt Xcas} provides six methods (inherited from the GSL)
to solve numeric systems of equations 
of the form $f(x)=0$:
\begin{itemize}
\item Three  methods  use the jacobian matrix $f'(x)$ and their names are 
terminated with {\tt j\_solver}. 
\item
The three other  methods use approximation for $f'(x)$ and use only 
$f$.
\end{itemize}
All methods use an iteration of Newton kind
\[ x_{n+1}=x_n-{f'(x_n)}^{-1}*f(x_n) \]
The four methods {\tt hybrid*\_solver} use also a method of 
gradient descent when the Newton iteration would make a too large step.
The length of the step is computed without scaling 
for {\tt hybrid\_solver} and {\tt hybridj\_solver}
or with scaling (computed from $f'(x_n)$) for 
{\tt hybrids\_solver} and {\tt hybridsj\_solver}.

\subsection{{\tt fsolve} with the option {\tt dnewton\_solver}}\index{dnewton\_solver{\sl dnewton\_solver}|textbf}
\noindent Input :
\begin{center}{\tt fsolve([x\verb|^|2+y-2,x+y\verb|^|2-2],[x,y],[2,2],dnewton\_solver)}\end{center}
Output :
\begin{center}{\tt [1.0,1.0]}\end{center}

\subsection{{\tt fsolve} with the option {\tt hybrid\_solver}}\index{hybrid\_solver{\sl hybrid\_solver}|textbf}
\noindent Input :
\begin{center}{\tt fsolve([x\verb|^|2+y-2,x+y\verb|^|2-2],[x,y],[2,2],}\end{center}
\begin{center}{\tt cos(x)=x,x,0,hybrid\_solver)}\end{center}
Output :
\begin{center}{\tt [1.0,1.0]}\end{center}

\subsection{{\tt fsolve} with the option {\tt hybrids\_solver}}\index{hybrids\_solver{\sl hybrids\_solver}|textbf}
\noindent Input :
\begin{center}{\tt fsolve([x\verb|^|2+y-2,x+y\verb|^|2-2],[x,y],[2,2],hybrids\_solver)}\end{center}
Output :
\begin{center}{\tt [1.0,1.0]}\end{center}

\subsection{{\tt fsolve} with the option {\tt newtonj\_solver}}\index{newtonj\_solver{\sl newtonj\_solver}|textbf}
\noindent Input :
\begin{center}{\tt fsolve([x\verb|^|2+y-2,x+y\verb|^|2-2],[x,y],[0,0],newtonj\_solver)}\end{center}
Output :
\begin{center}{\tt [1.0,1.0]}\end{center}

\subsection{{\tt fsolve} with the option {\tt hybridj\_solver}}\index{hybridj\_solver{\sl hybridj\_solver}|textbf}
\noindent Input :
\begin{center}{\tt fsolve([x\verb|^|2+y-2,x+y\verb|^|2-2],[x,y],[2,2],hybridj\_solver)}\end{center}
Output :
\begin{center}{\tt  [1.0,1.0]}\end{center}

\subsection{{\tt fsolve} with the option {\tt hybridsj\_solver}}\index{hybridsj\_solver{\sl hybridsj\_solver}|textbf}
\noindent Input :
\begin{center}{\tt fsolve([x\verb|^|2+y-2,x+y\verb|^|2-2],[x,y],[2,2],hybridsj\_solver)}\end{center}
Output :
\begin{center}{\tt  [1.0,1.0]}\end{center}

\section{Numeric roots of a polynomial : {\tt proot}}\index{proot}
\noindent{\tt proot} takes as argument a squarefree polynomial,
either in symbolic form or as a list of 
polynomial coefficients (written by decreasing order).\\
{\tt proot} returns a list of the numeric roots of this polynomial.\\
To find the numeric roots of $P(x)=x^3+1$, input :
\begin{center}{\tt proot([1,0,0,1]) }\end{center}
or :
\begin{center}{\tt proot(x\verb|^|3+1) }\end{center}
Output :
\begin{center}{\tt [0.5+0.866025403784*i,0.5-0.866025403784*i,-1.0]}\end{center}
To find the numeric roots of $x^2-3$, input :
\begin{center}{\tt proot([1,0,-3])}\end{center}
or  :
\begin{center}{\tt proot(x\verb|^|2-3)}\end{center}
Output :
\begin{center}{\tt [1.73205080757,-1.73205080757]}\end{center} 
%proot([1,0,-15,0,90,0,-270,0,405,0,-243])


\section{Numeric factorization of a matrix : {\tt cholesky qr lu svd}}
Matrix numeric factorizations of
\begin{itemize}
\item Cholesky,
\item QR,
\item LU,
\item svd,
\end{itemize}
are described in section \ref{sec:factormatrice}.

\chapter{Unit objects and physical constants}\label{sec:unit}
The {\tt Phys} menu contains:
\begin{itemize}
\item the physical constants ({\tt Constant} sub-menu), 
\item the unit conversion functions
({\tt Unit\_convert} sub-menu), 
\item the unit prefix ({\tt  Unit\_prefix} sub-menu) 
\item the unit objects organized by subject
\end{itemize}

\section{Unit objects}
\subsection{Notation of unit objects}\index{\_|textbf}
A unit object has two parts : a real number and a unit expression (a single 
unit or multiplicative combinaison of unit). The two parts are linked by the 
character {\tt \_} ("underscore"). For example {\tt 2\_m} for 2 meters.
For composite units, parenthesis must be used, e.g. {\tt 1\_(m*s)}.\\
If a prefix is put before the unit then the unit is multiplicated by a power of
10. For example {\tt k} or {\tt K} for kilo (indicate a multiplication by 
$10^3$), {\tt D} for  deca (indicate a multiplication by $10$), {\tt d} for
deci (indicate a multiplication by $10^{-1}$) etc...\\ 
Input :
\begin{center}{\tt 10.5\_m}\end{center}
Output :
\begin{center}{\tt a unit object of value 10.5 meters}\end{center}
Input :
\begin{center}{\tt 10.5\_km}\end{center}
Output :
\begin{center}{\tt a unit object of value 10.5 kilometers}\end{center}

\subsection{Computing with units}
{\tt Xcas} performs usual arithmetic operations (+, -, *, /, \verb|^|) on
unit objects. Different units may be used, but they must be 
compatible for + and -. The result is an unit object
\begin{itemize}
\item for the 
multiplication and the division of two unit objects 
{\tt \_u1} and {\tt \_u2} the unit of the result is written 
{\tt \_(u1*u2)} or {\tt \_(u1/u2)}. 
\item  for an addition or a substraction of compatible unit objects, 
the result is expressed with the same unit as the first term of the operation.
\end{itemize}
Input :
\begin{center}{\tt 1\_m+100\_cm}\end{center}
Output :
\begin{center}{\tt 2\_m}\end{center}
Input :
\begin{center}{\tt 100\_cm+1\_m}\end{center}
Output :
\begin{center}{\tt 200\_cm}\end{center}
Input :
\begin{center}{\tt 1\_m*100\_cm}\end{center}
Output :
\begin{center}{\tt 1\_m\verb|^|2}\end{center}

\subsection{Convert units into MKSA  units : {\tt mksa}}\index{mksa}
\noindent{\tt mksa} converts a unit object into  a unit object
written with the compatible {\tt MKSA} base unit.\\ 
\noindent Input :
\begin{center}{\tt mksa(15\_C)}\end{center}
Output :
\begin{center}{\tt 15\_(s*A)}\end{center}

\subsection{Convert units : {\tt convert}}\index{convert}\label{sec:convertunit}
\noindent {\tt convert} convert units : the first argument is an unit object 
and the second argument is the new unit (which must be compatible).\\
Input :
\begin{center}{\tt convert(1\_h,\_s) }\end{center}
Output :
\begin{center}{\tt 3600\_s}\end{center}
Input :
\begin{center}{\tt convert(3600\_s,\_h) }\end{center}
Output :
\begin{center}{\tt 1\_h}\end{center}

\subsection{Factorize an unit : {\tt ufactor}}\index{ufactor|textbf}
\noindent {\tt ufactor} factorizes an unit in a unit object : the first 
argument is an unit object and the second argument is the unit to factorize.\\ 
The result is an unit object multiplicated by the remaining {\tt MKSA} units.\\
Input :
\begin{center}{\tt ufactor(3\_J,\_W) }\end{center}
Output :
\begin{center}{\tt 3\_(W*s)}\end{center}
Input :
\begin{center}{\tt ufactor(3\_W,\_J) }\end{center}
Output :
\begin{center}{\tt 3\_(J/s)}\end{center}

\subsection{Simplify an unit : {\tt usimplify}}\index{usimplify}
\noindent {\tt usimplify} simplifies an unit in an unit object.\\
Input :
\begin{center}{\tt usimplify(3\_(W*s))}\end{center}
Output :
\begin{center}{\tt 3\_J}\end{center}

\subsection{Unit prefixes}
You can insert a unit prefix in front of a unit to indicate a power of ten.\\
The following tables gives the available prefixes:
\begin{center}
\begin{tabular}{|l|c|r||l|c|r|}
\hline
Prefix & Name & (*10\verb|^|) n & Prefix & Name & (*10\verb|^|) n \\
\hline
Y & yota & 24 & d & deci & -1\\
Z & zeta & 21 & c & cent & -2\\
E & exa & 18 & m & mili & -3\\
P & peta & 15 & mu & micro &-6\\
T & tera & 12 & n & nano & -9\\
G & giga & 9 & p & pico & -12\\
M & mega & 6 & f & femto & -15\\
k or K & kilo & 3 & a & atto & -18\\
h or H & hecto & 2 & z & zepto & -21\\
D & deca & 1 & y & yocto &-24\\
\hline
\end{tabular}
\end{center}
{\bf Remark}\\
You cannot use a prefix with a built-in unit if the result gives another 
built-in unit.\\
For example, 
{\tt 1\_a} is one are, but {\tt 1\_Pa} is one pascal and not 
{\tt 10\verb|^|15\_a}.
 
\section{Constants}
\subsection{Notation of physical constants}\index{\_}
If you want to use a physical constants inside Xcas, put
it's name between two characters {\tt \_} 
("underscore"). Don't confuse  physical constants with symbolic constants, 
for example, $e,\pi$ are symbolic constants as {\tt \_c\_,\_NA\_} are physical 
constants.\\
Input :
\begin{center}{\tt \_c\_ }\end{center}
Output speed of light in vacuum :
\begin{center}{\tt 299792458\_m*s\verb|^|-1}\end{center}
Input :
\begin{center}{\tt \_NA\_ }\end{center}
Output Avogadro's number :
\begin{center}{\tt 6.0221367e23\_gmol\verb|^|-1}\end{center}

\subsection{Constants Library}
The physical constants are in the {\tt Phys} menu, {\tt Constant}
sub-menu.
% or also in the {\tt Help} menu.\\ 
The following table gives the Constants Library  :
\begin{center}
\begin{tabular}{|l|l|}
\hline
Name & Description\\
\hline
{\tt \_NA\_} &Avogadro's number\\
{\tt \_k\_} &Boltzmann constant\\
{\tt \_Vm\_} &Molar volume\\
{\tt \_R\_} &Universal gas constant\\
{\tt \_StdT\_} &Standard temperature \\
{\tt \_StdP\_} &Standard pressure\\
{\tt \_sigma\_} &Stefan-Boltzmann constant\\
{\tt \_c\_} &Speed of light in vacuum\\
{\tt \_epsilon0\_} &Permittivity of vacuum\\
{\tt \_mu0\_} &Permeability of vacuum\\
{\tt \_g\_} &Acceleration of gravity\\
{\tt \_G\_} &Gravitational constant\\
{\tt \_h\_} &Planck's constant\\
{\tt \_hbar\_} &Dirac's constant\\
{\tt \_q\_} &Electron charge\\
{\tt \_me\_} &Electron rest mass\\
{\tt \_qme\_} &q/me (Electron charge/masse)\\
{\tt \_mp\_} &Proton rest mass\\
{\tt \_mpme\_} &mp/me (proton masse/electron masse)\\
{\tt \_alpha\_} &Fine structure constant\\
{\tt \_phi\_} &Magnetic flux quantum\\
{\tt \_F\_} & Faraday constant\\
{\tt \_Rinfinity\_} &Rydberg constant\\
{\tt \_a0\_} &Bohr radius\\
{\tt \_muB\_} &Bohr magneton\\
{\tt \_muN\_} &Nuclear magneton\\
{\tt \_lambda0\_} &Photon wavelength (ch/e)\\
{\tt \_f0\_} &Photon frequency (e/h)\\
{\tt \_lambdac\_} &Compton wavelength\\
{\tt \_rad\_} &1 radian\\
{\tt \_twopi\_} &2*pi radians\\
{\tt \_angl\_} &180 degrees angle\\
{\tt \_c3\_} &Wien displacement constant\\
{\tt \_kq\_} & k/q (Boltzmann/electron charge)\\
{\tt \_epsilon0q\_} &epsilon0/q (permitivity /electron charge)\\
{\tt \_qepsilon0\_} &q*epsilon0 (electron charge *permitivity)\\
{\tt \_epsilonsi\_} &Silicium dielectric constant\\
{\tt \_epsilonox\_} &Bioxyd of silicium dielectric constant\\
{\tt \_I0\_} &Reference intensity\\
\hline
\end{tabular}
\end{center}
To have the value of a constant, input the constant name in the command line 
of {\tt Xcas} and valid with {\tt enter} (don't forget to put 
{\tt \_} at the begining and at the end of the constant name).


\end{document}
