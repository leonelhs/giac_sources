{"!",{"Renvoie l'inverse logique de l'argument si préfixé ou factoriel si postfixé.","Returns the logical inverse of the argument if prefixed or factorial if infixed.",0,0},"Boolean","!(b==0); 5!","or,and,xor,factorial"},
{"!=",{"Opérateur booléen infixé qui teste la non égalité.","Boolean infixed operator that tests the difference.",0,0},"Expr,Expr"," 1+1!=2; 2!=3","==,<=,>="},
{"#",{"Transforme (dans un programme) une chaîne en le nom d'une variable.","Transforms (in a program) a string into the name of a variable.",0,0},"Str"," #(\"a\")","input"},
{"$",{"Version infixée de seq.","Infixed version of seq.",0,0},"(Expr(var)||Int(a..b)),(Var(var)=Int(a..b))||Intg(n)||Real(p)"," 0.3$4; t$4; 0$0; a:=(1,2,3);eval(a$4); (2^k)$(k=0..3); [(2^k)$(k=0..3)]; (0.3..2)$0.2; (k^2)$(k=(1..10)$2); (k^2)$(k=1..10,2); (k+1)$(k=(0..1)$(1/2)); (k+1)$(k=(0..1)$0.5); [k^2,k^3]$(k=1..10)","seq,makelist,range"},
{"%",{"Opérateur infixé qui renvoie n mod p un nombre de ℤ/pℤ.","Infixed operator which returns n mod p a number of ℤ/pℤ.",0,0},"Intg(n),Intg(p)"," 15 mod 6; (2 mod 10)^50; (72 mod 7) mod 0; (2%10)^50; (72%7)%0","smod,irem,fracmod"},
{"%/",{"Reste euclidien de 2 entiers ou de 2 entiers de Gauss : c'est la version infixée de irem).","Euclidean remainder of 2 integer : it is the infixed version of irem.",0,0},"Intg(a),Intg(b)"," 125 %/ 15; 125 %/ 41; -7 %/ 3; 25+12*i %/ 5+7*i","iquo,smod,rem,mod"},
{"%/",{"Reste euclidien de 2 entiers ou de 2 entiers de Gauss : c'est la version infixée de irem).","Euclidean remainder of 2 integer : it is the infixed version of irem.",0,0},"Intg(a),Intg(b)","iquo(125,15);iquo(125,41);iquo(-7,3);iquo(25+12*i,5+7*i)","irem,smod,quo"},
{"%{%}",{"set[] ou %{%} est utilisé pour définir un ensemble.","set[] or %{%} is used to define a set.",0,0},"Seq"," set[1,2,3]; %{1,2,3%}; L:=[1,2,2,3];S:=set[op(L)]; set[1,2]*set[2,3]","in,op"},
{"&&",{"opérateur booléen infixé (et).","infixed boolean operator (and).",0,0},"Expr, Expr"," 1==2 and 2>1; 1!=2 and 2>0","or,not,xor"},
{"&*",{"Multiplication de 2 matrices (opérateur infixé, &* compatibilité Maple).","Matrix multiplication (infixed operator, &* Maple compatibility).",0,0},"Mtrx,Mtrx"," [[1,2],[1,4]] &* [[1,2],[3,4]]","*"},
{"&^",{"Élève la matrice à la puissance n (opérateur infixé, &^ compatibilité Maple).","Calculates the n power of the matrix (infixed operator, &^ Maple compatibility).",0,0},"Mtrx,Intg(n)"," [[1,2],[3,4]] &^ 3; [[1,2],[3,4]] &^ n","^"},
{"'",{"Dérivée par rapport au second argument (version postfixée de diff).","Returns the derivative with respect to the 2nd argument (postfixed version of diff).",0,0},"Expr or Fnc,[SeqVar or LstVar]"," (x^3-x)'; (x^3-x,x$3)'; (x*y+z*y,y)'; (x*y+z*y,y,z)'; (x*y+z*y,[y,z])'; f(x):=sin(2x);g:=f';h:=f''","diff,function_diff,integrate"},
{"()",{"() renvoie la valeur d'une fonction ou permet de substituer des valeurs dans une expression.","() returns the value of a function or substitutes values in an expression",0,0},""," f(x,y,z):=x+2y+3z;f(1,2,z); f:=(x,y,z)->x+2y+3z;f(1,2,z); g:=x+2y+3z;g(x=1,y=2)","subst,->,:="},
{"*",{"Produit, ou produit scalaire de 2 vecteurs ou produit de 2 expressions ou produit de 2 matrices. C'est un opérateur infixé.","Scalar product infixed (or product of 2 expressions or 2 matrix).",0,0},"Vect,Vect||Mtrx,Mtrx,||Xpr,Xpr"," [1,2]*[3,4]","dot,cross,.*,hadamard"},
{"*=",{"Opérateur infixé : a*=b est équivalent à a:=a*b.","Infixed operator : a*=b equivalent to a:=a*b.",0,0},"Var,Real"," a:=2;a*=3","sto,:="},
{"+",{"Concaténation de 2 chaînes ou addition terme à terme de 2 expressions ou 2 listes ou 2 matrices (opérateur infixé).","String concatenation or addition element by element of 2 expressions or 2 lists or 2 matrix (infixed operator).",0,0},"Str||Lst||Expr, Str||Lst||Expr"," \"bon\"+\"jour\"; 1+2; [1,2]+[3,4,5]","concat"},
{"+&",{"Concaténation de 2 chaînes ou addition terme à terme de 2 expressions ou 2 listes ou 2 matrices (opérateur infixé, compatibilité TI).","String concatenation or addition element by element of 2 expressions or 2 lists or 2 matrix (infixed operator, TI compatibility).",0,0},"Str||Lst, Str||Lst, Expr||Expr"," \"bon\"+&\"jour\"; 1+&2; [1,2]+&[3,4,5]","concat"},
{"+=",{"Opérateur infixé : a+=b est équivalent à a:=a+b.","Infixed operator : a+=b equivalent to a:=a+b.",0,0},"Var,(Real or Str)"," a:=2;a+=3; a:=\"abc\";a+=\"d\"","sto,:="},
{"+infinity",{"Plus infini","Plus infinity",0,0},"",0,"infinity,-infinity"},
{"-<",{"Opérateur infixé (équivalent à l'instruction préfixée couleur) qui définit les attributs d'une figure géométrique.","Infixed operator (equivalent to the prefixed instruction color) which define the attributes of a geometrical figure.",0,0},"GeoObj,Attribut"," square(0,1) -< filled+red; square(0,2) -< green; square(0,2) -< green+dash_line; square(0,2) -< filled","color"},
{"-=",{"Opérateur infixé : a-=b est équivalent à a:=a-b.","Infixed operator : a-=b equivalent to a:=a-b.",0,0},"Var,Real"," a:=2;a-=3",":="},
{"->",{"Opérateur infixé qui définit une fonction utilisateur: x->f(x).","Infixed operator which define an user function: x->f(x).",0,0},"VectVar(x),Expr(f(x))"," x -> sin(x); f:= (x,y)->sin(x+y)+sin(x-y); k:=(x,y)->{if (x!=y) 0; else 1;}; g:=(x,y)->return(sin(x+y),sin(x-y))","for,if,local,{}"},
{"-infinity",{"Moins infini","Minus infinity",0,0},"",0,"infinity,+infinity,inf"},
{".*",{"Exécute le produit terme à terme de 2 listes ou de 2 matrices (opérateur infixé, compatibilité TI).","Performs an element by element multiplication of 2 lists or 2 matrix (infixed operator, TI compatibility).",0,0},"Lst||Mtrx,Lst||Mtrx"," [[1,2],[3,4]] .* [[3,4],[5,6]]; [1,2] .* [5,6]","hadamard,./,.^"},
{".+",{"Exécute l'addition terme à terme de 2 listes ou de 2 matrices ou ajoute $a$ à chaque terme de la liste ou de la matrice (opérateur infixé, compatibilité TI).","Performs an element by element addition of 2 lists or 2 matrix or add $a$ at each element of the list or matrix (infixed operator, TI compatibility).",0,0},"Lst||Mtrx, Real(a)||Lst||Mtrx"," [1,2,3].+4; [[1,2],[3,4]].+5; [[1,2],[3,4]].+[5,6]; [[1,2],[3,4]].+[[3,4],[5,6]]; [1,2] .+ [5,6]",".-"},
{".-",{"Exécute la soustraction terme à terme de 2 listes ou de 2 matrices ou retranche $a$ à chaque terme de la liste ou de la matrice (opérateur infixé, compatibilité TI).","Performs an element by element subtraction of 2 lists or 2 matrix or substract $a$ at each element of the list or matrix (infixed operator, TI compatibility).",0,0},"Lst||Mtrx,Real(a)||Lst||Mtrx"," [1,2,3].-4; [[1,2],[3,4]].-5; [[1,2],[3,4]] .- [[3,4],[5,6]]; [1,2] .- [5,6]",".+"},
{"./",{"Exécute la division terme à terme de 2 listes ou de 2 matrices (opérateur infixé, compatibilité TI).","Performs an element by element division of 2 lists or 2 matrix (infixed operator, TI compatibility).",0,0},"Lst||Mtrx,Lst||Mtrx"," [[1,2],[3,4]] ./ [[3,4],[5,6]]; [1,2] ./ [5,6]",".*"},
{".^",{"Élève à la puissance chaque élément de la matrice (opérateur infixé, compatibilité TI).","Calculates the power of each element of the matrix (infixed operator, TI compatibility).",0,0},"Mtrx,Intg(n)"," [[1,2],[3,4]] .^ 3",".*"},
{"/%",{"Quotient euclidien de 2 entiers ou de 2 entiers de Gauss : c'est la version infixée de iquo.","Euclidean quotient of 2 integers : it is the infixed version of iquo.",0,0},"Intg(a),Intg(b)","irem(125,15);irem(125,41);irem(-7,3);irem(25+12*i,5+7*i)","mod"},
{"/=",{"Opérateur infixé : a/=b est équivalent à a:=a/b.","Infixed operator : a/=b equivalent to a:=a/b.",0,0},"Var,Real"," a:=2;a/=3",":="},
{":=",{"Opérateur infixé qui stocke le deuxième argument dans la variable donnée comme premier argument.","Infixed operator that stores the second argument in the variable given as first argument.",0,0},"Var,(Real or Str)"," a:=2; b:=\"salut\"","sto,=<,=>"},
{"<",{"Opérateur booléen infixé qui teste l'inégalité.","Boolean infixed operator that tests the inequality.",0,0},"Expr,Expr"," 1+1<2; 2<3","!=,==,>=,<=,>"},
{"<=",{"Opérateur booléen infixé qui teste l'inégalité.","Boolean infixed operator that tests the inequality.",0,0},"Expr,Expr"," 1+1<=2; 2<=3","!=,==,>=,>,<"},
{"=",{"Symbole infixé pour relier les 2 membres d'une équation.","Infixed symbol that connects the 2 members of an equation.",0,0},"Expr,Expr"," x+4=2; x^2-3x+2=0; equal(x+4,2)","equal,equal2diff,equal2list,left,right"},
{"=<",{"Opérateur infixé qui stocke par référence le deuxième argument dans une variable (contenant une liste) donnée comme premier argument.","Infixed operator that stores by reference the second argument in a variable (containing a list) given as first argument.",0,0},"Var,(Real or Str)"," a:=[1,2,3]; a[1]=<5","sto,:="},
{"==",{"Opérateur booléen infixé qui teste l'égalité.","Boolean infixed operator that tests the equality.",0,0},"Expr,Expr"," 1+1==2; 2==3","!=,<=,>="},
{"=>",{"Opérateur infixé qui stocke le premier argument dans la variable donnée comme deuxième argument ou est la version infixée de convert.","Infixed operator that store the first argument in the variable given as second argument or is the infixed version of convert.",0,0},"(Real or Str),Var"," 2=>a; \"salut\"=>b; x^2+sin(x)=>diff; x^2-1=>*","sto,:=,convert"},
{">",{"Opérateur booléen infixé qui teste l'inégalité.","Boolean infixed operator that tests the inequality.",0,0},"Expr,Expr"," 1+1>2; 4>3","!=,==,>=,<=,<"},
{">=",{"Opérateur booléen infixé qui teste l'inégalité.","Boolean infixed operator that tests the inequality.",0,0},"Expr,Expr"," 1+1>=2; 2>=3","!=,==,<=,>,<"},
{"?",{"? est la version infixée de when : (Cond) ? Expr1:Expr2. Si la condition Cond=1 (même symbolique) renvoie Expr1 sinon renvoie Expr2.","? is the infixed version of when : (Cond) ? Expr1:Expr2. If condition Cond=1 (even symbolic) returns Expr1 else returns Expr2.",0,0},"Cond,Expr1,Expr2"," (x>0)?x+1:x-1; (n),1:0; (a>1)?a+1:0","when,if,then,else,ifte"},
{"?",{"Renvoie l'aide de la commande (si ? est infixé voir when).","Returns the help about the command (if ? is infixed see when) .",0,0},"Cmd","findhelp(ifactor)","ifte,when"},
{"@",{"Désigne la composition de fonctions (opérateur infixé).","Is the infixed operator for composition of functions.",0,0},"Fnc,Fnc"," sq@sin; sin@sin; (sq@sin)(x)","@@"},
{"@@",{"f @@ n désigne la fonction : fof..of (n fois) (opérateur infixé).","f @@ n is the function fof..of (n times) (infixed operator).",0,0},"Fnc(f),Intg(n)"," sin@@3; (sin@@3)(x)","@"},
{"ACOSH",{"Arc cosinus hyperbolique.","Hyperbolic arccosine.",0,0},"Expr","acosh(1)","cosh,acos"},
{"ACOT",{"Arc cotangente.","Arccotangent.",0,0},"Expr","acot(0)","atan,arccos"},
{"ACSC",{"Arc cosécante: acsc(x)=asin(1/x).","Arccosecant: acsc(x)=asin(1/x).",0,0},"Expr","acsc(1);acsc(2)","asin,csc"},
{"ASEC",{"Arc sécante: asec(x)=acos(1/x).","Arcsecant: asec(x)=acos(1/x).",0,0},"Expr","asec(1);asec(2)","acos,sec"},
{"ASIN",{"Arc sinus.","Arcsine.",0,0},"Expr","asin(0)","sin"},
{"ASINH",{"Arc sinus hyperbolique.","Hyperbolic arcsine.",0,0},"Expr","asinh(0)","sinh,asin"},
{"ATAN",{"Arc tangente.","Arctangent.",0,0},"Expr","atan(0)","tan,atanh"},
{"ATANH",{"Arc tangente hyperbolique.","Hyperbolic arctangent.",0,0},"Expr","atanh(0)","atan,tanh"},
{"Airy_Ai",{"Renvoie la valeur de la fonction Ai de Airy solution de w''-xw=0. Ai(x)=Ai(0)f(z)+Ai'(0)g(z)(f et g sont des séries entières sol de w''-xw=0).","Returns the value of Ai the Airy function solution of w''-xw=0. Ai(x)=Ai(0)f(z)+Ai'(0)g(z)(f et g are taylor's series sol of w''-xw=0).",0,0},"Real","Airy_Ai(0);Airy_Ai(1.5)","Airy_Bi"},
{"Airy_Bi",{"Renvoie la valeur de la fonction Bi de Airy solution de w''-xw=0. Bi(x)=sqrt(3)(Bi(0)f(z)-Bi'(0)g(z))(f et g sont des séries entières sol de w''-xw=0).","Returns the value of Ai the Airy function solution of w''-xw=0. Bi(x)=sqrt(3)(Bi(0)f(z)-Bi'(0)g(z))(f et g are taylor's series sol of w''-xw=0).",0,0},"Real","Airy_Bi(1.5);Airy_Bi(0)","Airy_Ai"},
{"Archive",{"Protège les variables données comme argument dans un fichier archive.","Protects the variables given as argument in an archive file.",0,0},"SeqVar","Archive(a,b)","Unarchiv,archive,unarchive"},
{"BesselJ",{"BesselJ(p,x) renvoie la fonction de Bessel de première espèce Jp(x).","BesselJ(p,x) returns the Bessel function of first kind Jp(x).",0,0},"Int(p),Real(x)","BesselJ(2,sqrt(2));BesselJ(-2,sqrt(2))","besselJ,BesselY,besselY"},
{"BesselY",{"BesselY(p,x) renvoie la fonction de Bessel de deuxième espèce Yp(x).","BesselY(p,x) returns the Bessel function of second kind Yp(x).",0,0},"Int(p),Real(x)","BesselJ(2,sqrt(2));BesselJ(-2,sqrt(2))","besselY,BesselJ,besselJ"},
{"Beta",{"Beta(a,b)=int(t^(a-1)*(1-t)^(b-1),t=0..1), Beta(a,b,p)=int(t^(a-1)*(1-t)^(b-1),t=0..p), Beta(a,b,p,1)=Beta(a,b,p)/Beta(a,b). (Beta(x,y) renvoie Gamma(x)*Gamma(y)/Gamma(x+y)).","Beta(a,b)=int(t^(a-1)*(1-t)^(b-1),t=0..1), Beta(a,b,p)=int(t^(a-1)*(1-t)^(b-1),t=0..p), Beta(a,b,p,1)=Beta(a,b,p)/Beta(a,b).(Beta(x,y) returns Gamma(x)*Gamma(y)/Gamma(x+y)).",0,0},"Expr,Expr,[Expr],[1]","Beta(x,y);Beta(3,2);Beta(3,2,0.5);Beta(3,2,0.5,1)","Gamma,igamma"},
{"BlockDiagonal",{"Renvoie soit la matrice diagonale de diagonale l soit la diagonale de A.","Returns either the diagonal matrix with diagonal l or the diagonal of A.",0,0},"Lst(l)||Mtrx(A)","BlockDiagonal([[1,2],[3,4]]);BlockDiagonal([1,2,3])","identity,diag "},
{"COND",{"Nombre de condition d'une matrice, utiliser COND(.,1) pour la norme l1, COND(.,2) pour l2 et COND(.,inf) pour linfini (1 est mis par défaut).","Condition number of a matrix, use COND(.,1) for l1, COND(.,2) for l2 norm and COND(.,inf) for linf (1 by default).",0,0},"Mtrx,[2]||[inf]","COND([[1,2],[1,4]]);COND([[1,2],[1,4]],1);COND([[1,2],[1,4]],2);COND([[1,2],[1,4]],inf)","SVL"},
{"COS",{"Cosinus ou Option de la commande convert ou convertir (id trigcos).","Cosine or Option of the convert or convertir command (id trigcos).",0,0},"Expr or Opt","cos(0); convert(cos(x)^4+sin(x)^2,cos)","acos,convert,trigsin"},
{"COSH",{"Cosinus hyperbolique.","Hyperbolic cosine.",0,0},"Expr","cosh(0)","acosh"},
{"COT",{"Cotangente.","Cotangent.",0,0},"Expr","cot(pi/2)","acot,tan"},
{"CSC",{"Cosécante: csc(x)=1/sin(x).","Cosecant: csc(x)=1/sin(x).",0,0},"Expr","csc(pi/2)","sin,acsc"},
{"CST",{"Nom de la variable permettant de créer le menu cust du bandeau.","Name of the variable creating the menu cust of the bandeau.",0,0},"Lst"," CST:=[evalc,[\"euro\",6.55957],[\"f\",x->2*x],[\"g\",g]]",""},
{"Celsius2Fahrenheit",{"Convertit les degrés Celsius en degrés Fahrenheit","Convert Celsius into Fahrenheit",0,0},"Unit","Celsius2Fahrenheit(10);Celsius2Fahrenheit(-40)","Fahrenheit2Celsius,_degreeF"},
{"Ci",{"Cosinus intégral int(cos(t)/t,t=-inf..x)","Cosine integral int(cos(t)/t,t=-inf..x)",0,0},"Expr","Ci(1.0)","Ei,Si,Li"},
{"Circle",{"Trace le cercle de centre (xc,yc) et de rayon r (par défaut option=1 et option=0 efface ce cercle).","Draws the circle with center (xc,yc) and radius r (by default option=1 and option=0 is to remove this circle).",0,0},"Real(xc),Real(yc),Real(r),[Intg(option)]","Circle(0,1,1);Circle(0,1,1,0);Circle(0,1,1,1)","circle"},
{"ClrDraw",{"Efface les graphes et les objets géométriques de l'écran graphique DispG.","Clear the graphs and the geometric objects on the graphic screen DispG.",0,0},"NULL","ClrGraph()","ClrIO,erase,erase3d,DispG"},
{"ClrGraph",{"Efface les graphes et les objets géométriques de l'écran graphique DispG.","Clear the graphs and the geometric objects on the graphic screen DispG.",0,0},"NULL","ClrGraph()","ClrIO,erase,erase3d,DispG"},
{"ClrIO",{"Efface l'écran des sorties.","Clear the output screen.",0,0},"NULL","ClrIO()","ClrGraph,ClrDraw"},
{"Col",{"Renvoie l'indice de la colonne de la cellule mise en surbrillance dans le tableur.","Returns the index of the column of the lightened cell in the matrixwriter.",0,0},"NULL","Col()","Row"},
{"CopyVar",{"Copie sans l'évaluer le contenu de var1 dans var2.","Copy the storage without evaluation of var1 into var2.",0,0},"Var(var1),Var(var2)","CopyVar(A,B)",""},
{"CyclePic",{"Réalise un enchaînement automatique de n images (stockées avec StoPic par exemple sous les noms des1,des2,des3...desn). L'affichage est fait n fois avec une pause de p secondes entre chaque image.","Realizes an automatic sequence of n pictures (stored with StoPic for example with name des1,des2,des3..desn). The display is done n times with a pause p seconds between each picture.",0,0},"Str(),Intg(n),Real(p),Intg(n)","CyclePic(\"des\",3,0.5,4)","StoPic"},
{"DIGITS",{"Pseudo-variable pour modifier le nombre n de chiffres significatifs (Digits:=n).","Pseudo-variable to modify the number of significant digits (Digits:=n).",0,0},":=Intg(n)"," Digits:=16; Digits:=24","cas_setup"},
{"DOM_COMPLEX",{"DOM_COMPLEX ou complex représente le type d'un complexe ou d'une variable complexe, valeur de la commande type. C'est aussi une option de assume.","DOM_COMPLEX or complex is the type of a complex or of a complex variable, as returned by the type command. It is also an option of the assume command.",0,0},"Opt"," assume(a,complex); assume(a,DOM_COMPLEX); a:=1+i;type(a)","type,assume,DOM_INT,DOM_FLOAT"},
{"DOM_FLOAT",{"DOM_FLOAT ou float est un entier qui représente le type d'une variable flottante, valeur de la commande type. C'est aussi une option de assume.","DOM_FLOAT or float is an integer representing the type of a floating point variable, returned by the type command. It is also an option of the assume command.",0,0},"Opt"," type(2.3); DOM_FLOAT+0; assume(a,DOM_FLOAT); assume(a,real); type(1.2)","type,assume,DOM_INT,DOM_SYMBOLIC"},
{"DOM_FUNC",{"DOM_FUNC ou func représente le type d'une fonction, valeur de la commande type. C'est aussi une option de assume.","DOM_FUNC or func is the type of a function, as returned by the type command. It is also an option of the assume command.",0,0},"Opt"," assume(a,DOM_FUNC); a(x):=1+x;type(a); type(sin); type(factor)","type,assume,DOM_INT,DOM_FLOAT"},
{"DOM_IDENT",{"DOM_IDENT ou identifier représente le type d'un identificateur, valeur de la commande type. C'est aussi une option de assume.","DOM_IDENT or identifier is the type of an identifier, as returned by the type command. It is also an option of the assume command.",0,0},"Opt"," purge(a);type(a)","type,assume,DOM_INT,DOM_FLOAT"},
{"DOM_INT",{"DOM_INT ou integer ou DOM_int est un entier qui représente le type d'une variable entière, valeur de la commande type. DOM_INT est utilisé si l'entier est < 2^31. C'est aussi une option de assume.","DOM_INT or integer or DOM_int is an integer which is the type of an integer variable, it is the value of the type command. DOM_INT is used for integers < 2^31. It is also an option of the assume command.",0,0},"Opt"," type(2^31); DOM_INT+0; assume(a,DOM_INT); assume(a,integer); a:=2;type(a)","type,assume,DOM_FLOAT,DOM_SYMBOLIC"},
{"DOM_LIST",{"DOM_LIST ou vector représente le type d'une liste ou d'une séquence, valeur de la commande type. C'est aussi une option de assume.","DOM_LIST or vector is the type of a list or of a sequence, as returned by the type command. It is also an option of the assume command.",0,0},"Opt"," assume(a,DOM_LIST); a:=[1,2,3];type(a); a:=1,2,3;type(a)","type,assume,DOM_INT,DOM_FLOAT"},
{"DOM_RAT",{"DOM_RAT ou rational représente le type d'un rationnel, valeur de la commande type. C'est aussi une option de assume.","DOM_RAT or rational is the type of a rational, as returned by the type command. It is also an option of the assume command.",0,0},"Opt"," assume(a,rational); assume(a,DOM_RAT); a:=1/2;type(a)","type,assume,DOM_INT,DOM_FLOAT"},
{"DOM_STRING",{"DOM_STRING ou string représente le type d'une chaîne de caractères, valeur de la commande type. C'est aussi une option de assume.","DOM_STRING or string is the type of a string, as returned by the type command. It is also an option of the assume command.",0,0},"Opt"," a:=\"123\";type(a); assume(a,DOM_STRING)","type,assume,DOM_INT,DOM_FLOAT"},
{"DOM_SYMBOLIC",{"DOM_SYMBOLIC ou symbol représente le type d'une variable symbolique, valeur de la commande type. C'est aussi une option de assume.","DOM_SYMBOLIC or symbol is the type of a symbolic variable, as returned by the type command. It is also an option of the assume command.",0,0},"Opt"," assume(a,symbol); assume(a,DOM_SYMBOLIC); a:=sqrt(2);type(a); type(2x+1)","type,assume,DOM_INT,DOM_FLOAT"},
{"DOM_int",{"DOM_INT ou integer ou DOM_int est un entier qui représente le type d'une variable entière, valeur de la commande type. DOM_INT est utilisé si l'entier est < 2^31. C'est aussi une option de assume.","DOM_INT or integer or DOM_int is an integer which is the type of an integer variable, it is the value of the type command. DOM_INT is used for integers < 2^31. It is also an option of the assume command.",0,0},"Opt"," type(2^31); DOM_INT+0; assume(a,DOM_INT); assume(a,integer); a:=2;type(a)","type,assume,DOM_FLOAT,DOM_SYMBOLIC"},
{"DelFold",{"Efface le répertoire indiqué (il y a erreur si ce répertoire n'est pas vide).","Remove the appointed folder (there is an error if this folder is not empty).",0,0},"Var","DelFold(essai)","SetFold,NewFold,GetFold"},
{"DelVar",{"purge(nomvar) enlève la valeur stockée dans la variable nomvar.","purge(varname) unassign the variable varname.",0,0},"Var","purge(t);purge(C)","sto,restart,assume,about"},
{"Det",{"Renvoie le déterminant d'une matrice carrée M, sans l'évaluer.","Determinant of a square matrix M, without evaluation.",0,0},"Mtrx","Det([[1,2],[3,4]]);Det([[1,2,3],[1,3,6],[2,5,7]])","det"},
{"Dialog",{"Dans un programme, fait des entrées :Dialog{Title(\"titre\");Text(\"Eleve\"+ string(c));Request(\"Nom=\",a);Request(\"Age=\",b);DropDown(\"Niveau\",[\"un\",\"deux\"],n);} (on peut remplacer {} en mettant EndDlog à la fin).","In a program, do inputs :Dialog{Title(\"title\");Text(\"Pupil\"+ string(c));Request(\"Name=\",a);Request(\"Age=\",b);DropDown(\"Level\",[\"un\",\"deux\"],n);} (you can replace {} with EndDlog at the end).",0,0},"Title;Text;Request;Request;DropDown;EndDlog"," Dialog Title(\"section TS\");Text(\"Pupil\"+ string(c));Request(\"Name=\",a);Request(\"Age=\",b);DropDown(\"Level\",[\"un\",\"deux\"],n);EndDlog","DropDown,Request,Text,Title"},
{"Digits",{"Pseudo-variable pour modifier le nombre n de chiffres significatifs (Digits:=n).","Pseudo-variable to modify the number of significant digits (Digits:=n).",0,0},":=Intg(n)"," Digits:=16; Digits:=24","cas_setup"},
{"Dirac",{"Distribution de Dirac (dérivée de Heaviside).","Function derivative of Heaviside.",0,0},"Real","Dirac(1);Dirac(-1); int(Dirac(x)*(x-1)^2,x,-1,2)","Heaviside"},
{"Disp",{"Permet d'afficher un résultat intermédiaire dans un programme.","Prints a result in a program.",0,0},"Expr or Str","print(\"salut\");print(a)",""},
{"DispG",{"Affiche la fenêtre DispG (DispG sans ()).","Shows DispG windows (DispG without ()).",0,0},""," DispG;","DispHome,ClrGraph"},
{"DispHome",{"Ferme la fenêtre DispG.","Closes DispG windows.",0,0},""," DispHome;","DispG"},
{"DrawFunc",{"Trace le graphe d'une expression d'1 ou 2 variables avec superposition.","Plot a 1 variable or 2 variables expression with superposition.",0,0},"Expr,[Var(x) or VectVar] ,[Intg(color)]","plotfunc(-2*x+1,x=1..2,color=red);plotfunc([-2*x+1,x^2-2],x=-2..2,color=[red,yellow],xstep=0.2);plotfunc(x^2-y^2,[x,y],xstep=0.5,ystep=0.3);plotfunc(x^2+y^2,[x=-1..1,y=-2..2],nstep=900);plotfunc((x+i*y)^2,[x=-1..1,y=-2..2],nstep=900,affichage=rempli)","plot,plot3d,plotparam,animate,animate3d,plotdensity"},
{"DrawInv",{"Trace le graphe du symétrique de l'expression par rapport à y=x.","Draws the graph of the symmetric of the expression with respect to y=x.",0,0},"Expr,[Var]","DrawInv(exp(x))","plotfunc"},
{"DrawParm",{"plotparam(a(x)+i*b(x),x=x0..x1) trace la courbe X=a(x),Y=b(x) x=x0..x1 ou plotparam([a(u,v),b(u,v),c(u,v)],[u=u0..u1,v=v0..v1]) trace la surface X=a(u,v),Y=b(u,v),Z=c(u,v) u=u0..u1 et v=v0..v1.","plotparam(a(x)+i*b(x),x=x0..x1) draws the curve X=a(x),Y=b(x) x=x0..x1 or plotparam([a(u,v),b(u,v),c(u,v)],[u=u0..u1,v=v0..v1]) draws the surface X=a(u,v),Y=b(u,v),Z=c(u,v) u=u0..u1 and v=v0..v1.",0,0},"Cplx||Lst,Var||Lst(Var)","plotparam(sin(t)+i*cos(t),t);plotparam([sin(x),cos(x)],x=0..1);plotparam([sin(x),cos(x)],x=0..1,affichage=rouge);plotparam(sin(x)+i*cos(x),x=0..1,tstep=0.01);plotparam([v*cos(u),v*sin(u),v],[u,v]);plotparam([v*cos(u),v*sin(u),v],[u=0..pi,v=0..3],ustep=0.1,vstep=0.2)","plotfunc,plotpolar"},
{"DrawPol",{"plotpolar(f(x),x,a,b) trace la courbe en polaire r=f(x) pour x dans [a,b].","plotpolar(f(x),x,a,b) draws the polar curve r=fx) for x in [a,b].",0,0},"Expr,Var,VarMin,VarMax","plotpolar(sin(2*x),x,0,pi);plotpolar(sin(2*x),x,0,pi,tstep=0.1)","plotparam,plotfunc,plotpolar"},
{"DrawSlp",{"Dessine la droite passant par le point (a,b) et de pente m: y-b=m(x-a).","Draws the line with slope m,going through the point (a,b): y-b=m(x-a).",0,0},"Real(a),Real(b),Real(m)","DrawSlp(2,1,-1)","line"},
{"DropDown",{"Dans un programme, instruction d'une boite de dialogue.","In a program, instruction of a dialog box.",0,0},"Str,LstVal,Var",0,"Dialog,choosebox"},
{"DrwCtour",{"Dessine soit 11 lignes de niveaux équiréparties entre z=z_min,,...z=z_max de la surface z=Xpr, soit les lignes de niveaux définies par le 3ème argument.","Draws whether 11 equirepartited contour-lines z=z_min,,...z=z_max of the surface z=Xpr, whether the contour-lines defined by the 3-rd argument.",0,0},"Expr(Xpr),[LstVar],[LstVal]","plotcontour(x^2+y^2);plotcontour(x^2+y^2,[x,y]);plotcontour(x^2+2*y^2-2,[x,y],[1.0,2.0,3.0]);plotcontour(x^2-y^2,[x=-4..4,y=-4..4],seq(k,k,-11,11,3),xstep=0.1,ystep=0.1)","plotdensity,plotimplicit"},
{"ERROR",{"Génère l'affichage d'une erreur dans un programme","Generates the display of an error in a program",0,0},"Str","error(\"Argument should be integer\");error(\"je provoque une erreur\")","try,catch"},
{"EXP",{"Exponentielle ou Option de la commande convert ou convertir (id trig2exp).","Exponential or Option of the convert or convertir command (id trig2exp).",0,0},"Expr or Opt","exp(0); convert(cos(x),exp)","ln,convert,trig2exp"},
{"Ei",{"Exponentielle intégrale int(exp(t)/t,t=-inf..x)","Exponential integral int(exp(t)/t,t=-inf..x)",0,0},"Expr","Ei(1.0)","Si,Ci,Li"},
{"EndDlog",{"Dans un programme, fait des entrées :Dialog{Title(\"titre\");Text(\"Eleve\"+ string(c));Request(\"Nom=\",a);Request(\"Age=\",b);DropDown(\"Niveau\",[\"un\",\"deux\"],n);} (on peut remplacer {} en mettant EndDlog à la fin).","In a program, do inputs :Dialog{Title(\"title\");Text(\"Pupil\"+ string(c));Request(\"Name=\",a);Request(\"Age=\",b);DropDown(\"Level\",[\"un\",\"deux\"],n);} (you can replace {} with EndDlog at the end).",0,0},"Title;Text;Request;Request;DropDown;EndDlog"," Dialog Title(\"section TS\");Text(\"Pupil\"+ string(c));Request(\"Name=\",a);Request(\"Age=\",b);DropDown(\"Level\",[\"un\",\"deux\"],n);EndDlog","DropDown,Request,Text,Title"},
{"FALSE",{"booléen valant faux ou 0.","boolean equal to false or 0.",0,0},""," a:=false","true"},
{"Factor",{"Renvoie la factorisation d'un polynôme, sans l'évaluer.","Factorizes a polynomial without evaluation.",0,0},"Expr","Factor(x^4-1);Factor(x^4+12*x^3+54*x^2+108*x+81)","factor,ifactor,normal"},
{"Fahrenheit2Celsius",{"Convertit les degrés Fahrenheit en degrés Celsius","Convert Fahrenheit into Celsius",0,0},"Unit","Fahrenheit2Celsius(50);Fahrenheit2Celsius(-40)","Celsius2Fahrenheit,_degreeF"},
{"False",{"booléen valant faux ou 0.","boolean equal to false or 0.",0,0},""," a:=false","true"},
{"Fill",{"Remplit la liste ou la matrice contenue dans A avec l'expression Xpr.","Fill the list or the matrix stored in A with Xpr.",0,0},"Expr(Xpr),Var(A)","Fill(1.1,A)","makelist,makemat"},
{"GF",{"Crée un corps de Galois (Galois Field) de caractéristique p ayant p^n éléments. Le polynome minimal est primitif sauf s'il est donné ou si on passe 0 en dernier argument.","Create a Galois Field of characteristic p with p^n elements. The minimal polynomial is primitive except if given or if 0 is passed as last argument.",0,0},"Intg(p), Intg(n)|Minpoly,[Variable],[0|undef|Poly]","GF(2,8);GF(5,9,a);GF(2,128,0);GF(2,w^8+w^7+w^5+w+1);GF(2,8,['a','G']); G:=GF(2,a^8+a^6+a^3+a^2+1,['a','G'],undef)",0},
{"Gamma",{"Calcule les valeurs de la fonction Gamma au point a (Gamma(n+1)=n! pour n entier) si a>0, Gamma(a)=int(e^{-t}*t^{a-1},t=0..inf) et Gamma(a)=Gamma(a+1)/a et Gamma(a,b)=ugamma(a,b).","Calculus of Gamma at a point a (Gamma(n+1)=n! for n integer) if a>0, Gamma(a)=int(e^{-t}*t^{a-1},t=0..inf)) and Gamma(a)=Gamma(a+1)/a and Gamma(a,b)=ugamma(a,b).",0,0},"Real(a),[Real(b)]","Gamma(5);Gamma(1/2);gamma(-5.1);Gamma(-5.1,2.1)","Psi,Beta,ugamma,igamma"},
{"Gcd",{"Renvoie le PGCD de 2 polynômes ou de 2 entiers ou de 2 rationnels sans l'évaluer","Returns the greatest common divisor of 2 polynomials or of 2 integers without evaluation",0,0},"(Intg or Poly),(Intg or Poly)","Gcd(45,75);Gcd(x^2-2*x+1,x^3-1);Gcd(x^2-2*x+1,x^2+x-2)","gcd"},
{"GetFold",{"Renvoie le nom du répertoire en cours.","Returns the name of the current folder.",0,0},"Var","GetFold()","SetFold,DelFold,NewFold"},
{"Graph",{"Trace le graphe d'une expression d'1 ou 2 variables avec superposition.","Plot a 1 variable or 2 variables expression with superposition.",0,0},"Expr,[Var(x) or VectVar] ,[Intg(color)]","plotfunc(-2*x+1,x=1..2,color=red);plotfunc([-2*x+1,x^2-2],x=-2..2,color=[red,yellow],xstep=0.2);plotfunc(x^2-y^2,[x,y],xstep=0.5,ystep=0.3);plotfunc(x^2+y^2,[x=-1..1,y=-2..2],nstep=900);plotfunc((x+i*y)^2,[x=-1..1,y=-2..2],nstep=900,affichage=rempli)","plot,plot3d,plotparam,animate,animate3d,plotdensity"},
{"Heaviside",{"Fonction qui vaut 0 si x<0 et 1 si x>=0.","Function equal to 0 if x<0 and 1 if x>=0.",0,0},"Real","Heaviside(1);Heaviside(-1);Heaviside(0)","Dirac,laplace"},
{"IFTE",{"Si condition renvoie Expr1 sinon renvoie Expr2.","If condition returns Expr1 else returns Expr2.",0,0},"Cond,Expr1,Expr2"," x:=3;ifte(x>0,x+1,x-1); a:=2;ifte(a>1,a+1,0)","if,then,else,when"},
{"Input",{"Instruction dans un programme permettant l'entrée d'une expression qui sera stockée dans var.","Instruction in a program so that you can input an expression and store it in var.",0,0},"[Str],Var(var)","input(\"age\",a)","InputStr,output"},
{"InputStr",{"Instruction dans un programme permettant l'entrée d'une chaîne de caractères qui sera stockée dans var.","Instruction in a program so that you can input a string and store it in var.",0,0},"[Str],Var(var)","InputStr(\"nom?\",N)","input"},
{"Int",{"Renvoie la primitive ou l'intégrale (bornes a et b) sans l'évaluer.","Returns the primitive or the calculus of the integrate (bounds a and b) without evaluation.",0,0},"Expr,[Var(x)],[Real(a)],[Real(b)]","Int(sin(x));Int(sin(t),t);Int(sin(x),x,0,pi)","int"},
{"Inverse",{"Renvoie l'inverse d'une expression ou d'une matrice sans l'évaluer.","Returns the reciprocal or the matrix inverse without evaluation.",0,0},"Expr||Mtrx","Inverse(9/5);Inverse([[1,2],[3,4]])","inv"},
{"JordanBlock",{"Renvoie une matrice n*n avec a sur la diagonale, 1 au-dessus et 0 ailleurs.","Returns a matrix n*n with a on the diagonal ,1 above and 0 everywhere else.",0,0},"Expr(a),Intg(n)","JordanBlock(7,3)","jordan"},
{"LN",{"Logarithme népérien ou Option de la commande convert ou convertir (id trig2exp).","Natural logarithm or Option of the convert or convertir command (id trig2exp).",0,0},"Expr or Opt","ln(1);ln(e); convert(cos(x),ln)","exp,convert,trig2exp,log10"},
{"LQ",{"Pour A une matrice numérique, renvoie L une matrice triangulaire inférieure, Q une matrice orthogonale et P une matrice de permutation vérifiant P*A=L*Q.","For a numerical matrix A, returns L a lower matrix, Q an orthogonal matrix and P a permutation matrix such that P*A=L*Q.",0,0},"Mtrx(A)","LQ([[1,2],[3,4]]);LQ([[6,12,18],[5,14,31],[3,8,18]]);LQ([[4,0,0],[8,-4,3]])","lu,QR"},
{"LSQ",{"Renvoie le vecteur (resp la matrice) X qui minimise la norme euclidienne (resp de Frobenius) de A*X-B correspondant au(x) système(s) linéaire(s) A*X=B lorsque B est un vecteur (resp une matrice).","Returns the vector (resp matrix) X which is the minimum of the euclidean (resp Frobenius) norm of A*X-B corresponding to the linear system A*X=B when B is a vector (resp matrix).",0,0},"Mtrx(A),(Mtrx || Vect)(B)","LSQ([[1,2],[3,4]],[5,11]);LSQ([[1,2],[3,4]],[[5,-1],[11,-1]])","lu,QR"},
{"LU",{"Pour A une matrice numérique, stocke dans L une matrice triangulaire inférieure, dans U une matrice triangulaire supérieure et dans P une matrice de permutation vérifiant P*A=L*U.","For a numerical matrix A, store in L a lower matrix, in U a upper matrix and in P a permutation matrix such that P*A=L*U.",0,0},"Mtrx(A),Var(L),Var(U),Var(P)","LU([[1,2],[3,4]],L,U,P);LU([[6,12,18],[5,14,31],[3,8,18]],L,U,P)","lu,QR"},
{"Li",{"Logarithme intégral Li(x)=Ei(ln(x)) primitive de 1/ln(x) ","Logarithm integral Li(x)=Ei(ln(x)) primitive de 1/ln(x) ",0,0},"Expr","Li(2.0)","Si,Ci,Ei"},
{"Line",{"Dessine le segment [a+i*b,c+i*d].","Draws the segment [a+i*b,c+i*d].",0,0},"Expr(a),Expr(b),Expr(c),Expr(d)","Line(-1,-2,1,2)","segment"},
{"LineHorz",{"Dessine la droite horizontale y=a.","Draws the horizontal line y=a.",0,0},"Expr(a)","LineHorz(-1)","Line,LineVert"},
{"LineTan",{"Trace la tangente au graphe de y=f(x) en x=a. Ne pas mettre de parenthèses ou les mettre à l'extérieur.","Draws the tangent to y=f(x) at x=a. Do not put parenthesis or put the parenthesis around.",0,0},"Expr(f(x)),[Var],Expr(a)"," LineTan sin(x),pi/4; LineTan sin(t),t=pi/4); LineTan sin(t),t,pi/4; LineTan x^2-x,1; (LineTan sin(t),t,pi/4)","tangent,droite_tangente"},
{"LineVert",{"Dessine la droite verticale x=a.","Draws the vertical line x=a.",0,0},"Expr(a)","LineVert(2)","Line,LineHorz"},
{"NORMALD",{"Renvoie la densité de probabilité de la loi normale (mu est la moyenne et sigma l'écart-type).","Returns the density of probability of the Normal law (mu is the mean and sigma the standard deviation).",0,0},"Real(mu),Real(sigma),Real(x0)","normald(1);normald(1,2,3.5); randvector(3,normald,1,0.5); ranm(4,3,normald,1,0.5)","normal_cdf,normal_icdf,randvector,ranm"},
{"NewFold",{"Crée un nouveau répertoire puis on est placé dans ce répertoire.","Make a new folder and then we are in this folder.",0,0},"Var","NewFold(essai)","SetFold,DelFold,GetFold"},
{"NewPic",{"Crée un image de nom pic1, composée des points définis par les lignes de A.","Creates a picture named pic1, made with the points defined by the rows of A.",0,0},"Mtrx_nrows_2cols(A),Var(pic1)","NewPic ([[1,1],[1,2],[2,2]],des1)",""},
{"Nullspace",{"Forme inerte de nullspace pour calculs modulaires (irem/mod)","Inert form of nullspace for modular computation (irem/mod)",0,0},"Mtrx","Nullspace([[1,2],[3,6]]);Nullspace([[1,2,3],[1,3,6],[2,5,9]])","image,rref,nullspace"},
{"Output",{"Instruction dans un programme permettant la sortie d'une expression stockée dans var.","Instruction in a program so that you can output an expression stored in var.",0,0},"[Str],Var(var)","output(\"age\",a)","input"},
{"Ox_2d_unit_vector",{"Ox_2d_unit_vector() dessine le vecteur unitaire de l'axe des x de l'écran de géométrie 2-d.","Ox_2d_unit_vector() draws the unit vector of the x-axis of the graphic-screen 2-d.",0,0},"NULL","Ox_2d_unit_vector(); legende(1,\"u\",vert,quadrant4),Ox_2d_unit_vector()","frame_2d,Oy_2d_unit_vector,Ox_3d_unit_vector,Oy_3d_unit_vector,Oz_3d_unit_vector,gl_x_axis_unit,gl_x_axis_name"},
{"Ox_3d_unit_vector",{"Ox_3d_unit_vector() dessine le vecteur unitaire de l'axe des x de l'écran de géométrie 3-d.","Ox_3d_unit_vector() draws the unit vector of the x-axis of the graphic-screen 3-d.",0,0},"NULL","Ox_3d_unit_vector(); legende(point(1,0,0),\"i\",vert),Ox_3d_unit_vector()","frame_3d,Oy_3d_unit_vector,Oz_3d_unit_vector,Ox_2d_unit_vector,Oy_2d_unit_vector"},
{"Oy_2d_unit_vector",{"Oy_2d_unit_vector() dessine le vecteur unitaire de l'axe des y de l'écran de géométrie 2-d.","Oy_2d_unit_vector() draws the unit vector of the y-axis of the graphic-screen 2-d.",0,0},"NULL","Oy_2d_unit_vector(); legende(i,\"v\",vert,quadrant2),Oy_2d_unit_vector()","frame_2d,Ox_2d_unit_vector,Ox_3d_unit_vector,Oy_3d_unit_vector,Oz_3d_unit_vector,gl_y_axis_unit,gl_y_axis_name"},
{"Oy_3d_unit_vector",{"Oy_3d_unit_vector() dessine le vecteur unitaire de l'axe des y de l'écran de géométrie 3-d.","Oy_3d_unit_vector() draws the unit vector of the y-axis of the graphic-screen 3-d.",0,0},"NULL","Oy_3d_unit_vector(); legende(point(0,1,0),\"j\",vert),Oy_3d_unit_vector()","frame_3d,Ox_3d_unit_vector,Oz_3d_unit_vector,Ox_2d_unit_vector,Oy_2d_unit_vector"},
{"Oz_3d_unit_vector",{"Oz_3d_unit_vector() dessine le vecteur unitaire de l'axe des z de l'écran de géométrie 3-d.","Oz_3d_unit_vector() draws the unit vector of the z-axis of the graphic-screen 3-d,",0,0},"NULL","Oz_3d_unit_vector(); legende(point(0,0,1),\"k\",vert),Oz_3d_unit_vector()","frame_3d,Ox_3d_unit_vector,Oy_3d_unit_vector,Ox_2d_unit_vector,Oy_2d_unit_vector"},
{"Pause",{"Pause; dans un programme permet de suspendre son exécution (ENTER permet de continuer l'exécution) [Pause n; suspend l'exécution pendant n secondes].","Pause; in a program stopping its execution (the execution goes on if you press ENTER) [Pause n; stopping its execution during n seconds].",0,0},""," Pause 3;","WAIT"},
{"Phi",{"Indicatrice d'Euler (euler(n)=card({p<n,gcd(n,p)=1})).","Euler's function (euler(n)=card({p<n,gcd(n,p)=1})).",0,0},"Intg(n)","euler(11);euler(6)","gcd"},
{"Pi",{"Le nombre pi","pi",0,0},""," pi/4; Pi/4; evalf(pi); evalf(Pi)","e,i"},
{"PopUp",{"Dans un programme, fait une entrée avec affichage d'une liste de choix.","In a program, do an input with a display of a choose list.",0,0},"Str(titel),LstVal,Var","choosebox(\"titre\",[\"un\",\"deux\",\"trois\"],a);choosebox(\"valeur de a\",[-1,0,1],a)","Dialog"},
{"Psi",{"Psi(a,n)=dérivée n-ième de la fonction DiGamma (=ln@Gamma) au point a (Psi(a,0)=Psi(a)).","Psi(a,n)=n-th derivative of the function DiGamma (=ln@Gamma) at point a (Psi(a,0)=Psi(a)).",0,0},"Real(a),Intg(n)","Psi(3,1)","Gamma"},
{"QR",{"Pour A une matrice numérique, stocke dans Q une matrice orthogonale et dans R une matrice triangulaire supérieure vérifiant A=Q*R [en remplaçant par 0 les éléments el tels que abs(el)<eps].","For a numerical matrix A, store in Q a orthogonal matrix and in U a lower matrix such that A=Q*R [exchanging by 0 the elements such that abs(el)<eps].",0,0},"Mtrx,Var(Q),Var(R),[Real(eps)]","QR([[1,2],[3,4]],Q,R)","qr,LU"},
{"Quo",{"Renvoie le quotient euclidien de 2 polynômes sans l'évaluer.","Returns the euclidean quotient of 2 polynomials without evaluation.",0,0},"(Vect or Poly),(Vect or Poly),[Var]","Quo([1,2,3,4],[-1,2]);Quo(x^3+2x^2+3x+4,-x+2);Quo(t^3+2t^2+3t+4,-t+2,t)","quo,quorem"},
{"REDIM",{"Redimensionne selon n1,n2 une matrice (resp vecteur) soit en la raccourcissant, soit en l'augmentant avec des 0.","Shrink or enlarge with 0 a matrix (or vector) according to the new n1 and n2 dimensions.",0,0},"Mtrx||Vect,Intg(n1),Intg(n2)","redim([[1,2,3],[3,-9,6],[4,5,6]],1,2);redim([[1,2,3],[3,-9,6],[4,5,6]],4,4)","replace"},
{"REPLACE",{"La matrice B est mise en remplacement dans A à partir des 2 indices n1,n2.","Replace part of matrix A from indices n1,n2 with the values of matrix B.",0,0},"Mtrx(A),Lst(n1,n2),Mtrx(B)","replace([[1,2,3],[3,-9,6],[4,5,6]],[1,0],[[7,8],[9,0]])","redim"},
{"RandSeed",{"Initialise les nombres aléatoires.","Initializes random numbers.",0,0},"Intg","RandSeed(321)","srand"},
{"RclPic",{"Rajoute au graphique de l'écran DispG, l'image stockée dans pic1 à l'aide de StoPic.","Adds to the graphic in the DispG screen, the picture stored with StoPic.",0,0},"Var(pic1)","RclPic(des1)","RplcPic,StoPic"},
{"Rem",{"Renvoie le reste euclidien de 2 polynômes sans l'évaluer.","Returns the euclidean remainder of 2 polynomials without evaluation.",0,0},"(Vect or Poly),(Vect or Poly),[Var]","Rem([1,2,3,4],[-1,2]);Rem(x^3+2*x^2+3*x+4,-x+2);Rem(t^3+2*t^2+3*t+4,-t+2,t)","rem,quorem"},
{"Request",{"Dans un programme, instruction d'une boite de dialogue.","In a program, instruction of a dialog box.",0,0},"Str,Var",0,"Dialog,input"},
{"Resultant",{"Forme inerte de résultant pour calculs modulaires (irem/mod)","Inert form of resultant for modular computation (irem/mod)",0,0},"Poly,Poly,Var","Resultant(x^3+x+1,x^2-x-2,x)","resultant"},
{"Row",{"Renvoie l'indice de la ligne de la cellule mise en surbrillance dans le tableur.","Returns the index of the row of the lightened cell in the matrixwriter.",0,0},"NULL","Row()","Col"},
{"RplcPic",{"Efface et remplace le graphique de l'écran DispG,par l'image stockée dans pic1 à l'aide de StoPic.","Erase and replaces the graphic in the DispG screen, with the picture stored with StoPic.",0,0},"Var(pic1)","RplcPic(des1)","StoPic,RclPic"},
{"Rref",{"Renvoie la réduction sous forme échelonnée de AX=b (M=A|(-b)) sans évaluation.","Returns the row reduction to echelon form of AX=b (M=A|b) without evaluation.",0,0},"Mtrx(M)","Rref([[3,1,-2],[3,2,2]]);Rref([[2,1,1,-1],[1,1,2,-1],[1,2,1,-4]])","rref"},
{"SCALE",{"Multiplie la ligne n1 de la matrice A par Xpr.","Multiplies the row n1 of the matrix A by Xpr.",0,0},"Mtrx(A),Expr(Xpr),Intg(n1)","scale([[1,2],[3,4],[5,6]],12,0)","rowAdd,scaleadd,mRowAdd"},
{"SCALEADD",{"Multiplie la ligne n1 de la matrice A par Xpr, puis l'ajoute à la ligne n2.","Multiplies the row n1 of the matrix A by Xpr, then adds it to the row n2.",0,0},"Mtrx(A),Expr(Xpr),Intg(n1),Intg(n2)","scaleadd([[1,2],[3,4],[5,6]],12,0,2)","rowAdd,scale,mRow"},
{"SCHUR",{"Réduction matricielle sous forme de Hessenberg. Renvoie les matrices numériques [P,B] tel que B=inv(P)*A*P avec B triangulaire : SCHUR(A)=hessenberg(A,-1) ","Matrix reduction to Hessenberg form. Returns [P,B] such that B=inv(P)*A*P:SCHUR(A)=hessenberg(A,-1).",0,0},"Mtrx(A)","SCHUR([[1,2,3],[4,5,6],[7,8,1]]);SCHUR([[1,2,3,4],[4,5,6,7],[7,8,9,0],[0,1,2,3]])","hessenberg"},
{"SIN",{"Sinus ou Option de la commande convert ou convertir (id trigsin).","Sine or Option of the convert or convertir command (id trigsin).",0,0},"Expr or Opt","sin(0); convert(cos(x)^4+sin(x)^2,sin)","asin,convert,trigsin"},
{"SVD",{"Pour A matrice numérique réelle renvoie une matrice orthogonale U, le vecteur S des valeurs singulières de A et une matrice orthogonale Q tel que A=U*diag(S)*trn(Q).","Singular Value Decomposition for a numerical real matrix A, returns U an orthogonal matrix, S the vector of singular values of A and Q an orthogonal matrix and S the vector of singular values such that A=U*diag(S)*trn(Q)",0,0},"Mtrx(A)","SVD([[1,4],[4,1]]);SVD([[6,12,18],[5,14,31],[3,8,18]])","lu,svd"},
{"SVL",{"Pour A une matrice numérique réelle renvoie le vecteur des valeurs singulières de A i.e. la racine carrée des valeurs propres de A*trn(A).","For a numerical real matrix A returns the singular value vector i.e. sqrt(eigenvals(A*trn(A))).",0,0},"Mtrx(A)","SVL([[1,4],[4,1]]);SVL([[6,12,18],[5,14,31],[3,8,18]])","lu,svd"},
{"SWAPCOL",{"Renvoie la matrice obtenue en échangeant dans A la colonne n1 et la colonne n2.","Returns the matrix get from A by swapping the n1-th column and the n2-th column.",0,0},"Mtrx(A),Intg(n1),Intg(n2)","colSwap([[1,2],[3,4],[5,6]],0,1)","rowSwap"},
{"SWAPROW",{"Renvoie la matrice obtenue en échangeant dans A la ligne n1 et la ligne n2.","Returns the matrix get from A by swapping the n1-th row and the n2-th row.",0,0},"Mtrx(A),Intg(n1),Intg(n2)","rowSwap([[1,2],[3,4],[5,6]],1,2)","rowAdd,colSwap"},
{"SetFold",{"Renvoie le nom du répertoire en cours et choisit le nom indiqué comme nouveau répertoire (main pour le répertoire racine).","Returns the name of the current folder and chooses the appointed name as new folder (main for the root folder).",0,0},"Var","SetFold(essai);SetFold(main)","NewFold,DelFold,GetFold"},
{"Si",{"Sinus intégral int(sin(t)/t,t=0..x)","Sine integral int(sin(t)/t,t=0..x)",0,0},"Expr","Si(1.0)","Ei,Ci,Li"},
{"SortA",{"Trie, en modifiant la valeur de l'argument, les listes par ordre croissant (comme TI) ou la 1ière ligne d'une matrice selon l'ordre croissant en conservant les colonnes.","Sorts the lists with increasing order (like TI).",0,0},"LstReal||Seq||Mtrx","SortA [3,4,2];SortA 3,4,2;SortA [3,4,2],[6,4,5];SortA [[3,4,2],[6,4,5]]","SortD,sorta,sort"},
{"SortD",{"Trie, en modifiant la valeur de l'argument, les listes par ordre décroissant (comme TI) ou la 1ière ligne d'une matrice selon l'ordre décroissant en conservant les colonnes.","Sorts the lists with decreasing order (like TI).",0,0},"LstReal||Seq||Mtrx","SortD [3,4,2];SortD 3,4,2;SortD [[3,4,2],[6,4,5]];SortD [3,4,2],[6,4,5]","SortA,sortd,sort"},
{"StoPic",{"Pour stocker des graphiques dans des variables de noms ayant même radical (radical1,radical2..) pour pouvoir faire ensuite une animation avec CyclePic.","To store graphics in variables with same root-name (radical1,radical2..) and then we can animate the graphics with CyclePic.",0,0},"Var","StoPic(des1);StoPic(des2);StoPic(des3)","CyclePic"},
{"Store",{"Stocke le premier argument dans la variable donnée comme deuxième argument.","Store the first argument in the variable given as second argument.",0,0},"(Real or Str),Var","sto(2,a);sto(\"salut\",b)",":=,=>"},
{"TAN",{"Tangente ou Option de la commande convert ou convertir (id halftan).","Tangent or Option of the convert or convertir command (id halftan)",0,0},"Expr","tan(0);tan(pi/4); convert(tan(x),tan)","atan or Opt,convert,halftan"},
{"TRUE",{"booléen valant vrai ou 1.","boolean equal to true or 1.",0,0},""," a:=true","false"},
{"TeX",{"L'expression évaluée est écrite en latex dans la réponse.","Returns the evaluated expression written in latex.",0,0},"Expr","latex(1/2);latex((x^4-1)/(x^2+3))","mathml"},
{"Text",{"Dans un programme, instruction d'une boite de dialogue.","In a program, instruction of a dialog box.",0,0},"Str",0,"Dialog"},
{"Title",{"Dans un programme, instruction d'une boite de dialogue.","In a program, instruction of a dialog box.",0,0},"Str",0,"Dialog"},
{"True",{"booléen valant vrai ou 1.","boolean equal to true or 1.",0,0},""," a:=true","false"},
{"UTPC",{"Renvoie la probabilité qu'une variable aléatoire Chisquare soit supérieure à x0 (n est le nombre de degrés de liberté).","Returns the probability that a Chisquare random variable is greater than x0 (n is the number of degrees of freedom).",0,0},"Intg(n),Real(x0)","UTPC(2,6.1);UTPC(4,6.1)","chisquare_cdf,chisquare_icdf"},
{"UTPF",{"Renvoie la probabilité qu'une variable aléatoire Fisher-Snedecor soit supérieure à x0 (n et d sont les nombres de degrés de liberté).","Returns the probability that a Fisher-Snedecor random variable is greater than x0 (n and d are the numbers of degrees of freedom).",0,0},"Intg(n),Intg(d),Real(x0)","UTPF(4,10,3.5);UTPF(4,4,2.1)","fisher_cdf,fisher_icdf"},
{"UTPN",{"Renvoie la probabilité qu'une variable aléatoire Normale soit supérieure à x0 (mu est la moyenne et v la variance).","Returns the probability that a Normal random variable is greater than x0 (mu is the mean and v the variance).",0,0},"Real(mu),Real(v),Real(x0)","UTPN(1.96);UTPN(1,4,2.96)+normal_cdf(1,2,2.96)","normal_cdf,normal_icdf"},
{"UTPT",{"Renvoie la probabilité qu'une variable aléatoire de Student soit supérieure à x0 (n est le nombre de degrés de liberté).","Returns the probability that a Student random variable is greater than x0 (n is the number of degrees of freedom).",0,0},"Intg(n),Real(x0)","UTPT(3,2.35);UTPT(3,-2.35)","student_cdf,student_icdf"},
{"Unarchiv",{"Déprotège les variables données comme argument.","Unprotects the variables given as argument.",0,0},"SeqVar","Unarchiv(a,b)","Archive,archive,unarchive"},
{"VARS",{"Liste des variables et des répertoires du répertoire courant.","List of the variables and folders of the current directory.",0,0},"NULL","VARS()","lvar"},
{"VAS",{"Renvoie une liste d'intervalles d'isolation des racines réelles de P par l'algorithme de Vincent-Akritas-Strzebonski.","Returns a list of intervals containing the real roots of P. Vincent-Akritas-Strzebonski's method (VAS) is used.",0,0},"Poly(P)","VAS(x^3-7*x+7)","VAS_positive,sturmab,realroot"},
{"VAS_positive",{"Renvoie une liste d'intervalles d'isolation des racines réelles positives de P par l'algorithme de Vincent-Akritas-Strzebonski.","Returns a list of intervals containing the positive roots of P. Vincent-Akritas-Strzebonski's method (VAS) is used.",0,0},"Poly(P)","VAS_positive(x^3-7*x+7)","poslbdLMQ,posubLMQ,VAS,realroot"},
{"WAIT",{"WAIT(n); dans un programme suspend son exécution pendant n secondes.","WAIT(n); in a program stopping its execution during n seconds.",0,0},"Var(n)","WAIT(3)","Pause"},
{"Zeta",{"Renvoie si a>1 sum(1/n^a,n,1,+infinity).","Returns if a>1 sum(1/n^a,n,1,+infinity).",0,0},"Real(a)","Zeta(2)","sum"},
{"^",{"Élève un nombre à la puissance n (opérateur infixé).","Calculates the n power of a number (infixed operator).",0,0},"Expr(a),Intg(n)"," 2^12; [[1,2],[3,4]] ^ 3","&^,matpow,.^,sqrt,surd,pow,powmod"},
{"_(cm/s)",{"centimètre par seconde.","centimetre per second.",0,0},""," 5_(cm/s); mksa(_(cm/s))",0},
{"_(ft/s)",{"foot par seconde (pied par seconde).","foot per second.",0,0},""," 5_(ft/s); mksa(_(ft/s))",0},
{"_(m/s)",{"mètre par seconde.","metre per second.",0,0},""," 5_(m/s); mksa(_(m/s))",0},
{"_(m/s^2)",{"mètre par seconde au carré.","metre per square second.",0,0},""," 5_(m/s^2); mksa(_(m/s^2))",0},
{"_(rad/s)",{"radian par seconde.","Radian per second.",0,0},""," 5_(rad/s); mksa(_(rad/s))",0},
{"_(rad/s^2)",{"radian par seconde au carré.","Radian per square second.",0,0},""," 5_(rad/s^2); mksa(_(rad/s^2))",0},
{"_(tr/min)",{"tour par minute.","Revolutions per minute.",0,0},""," 5_(tr/min); mksa(_(tr/min))",0},
{"_(tr/s)",{"tour par seconde.","Revolutions per second.",0,0},""," 5_(tr/s); mksa(_(tr/s))",0},
{"_A",{"ampère","Ampere",0,0},""," 5_A; mksa(_A)",0},
{"_Angstrom",{"angstrom","Angstrom",0,0},""," 5_Angstrom; mksa(_Angstrom)",0},
{"_Bq",{"becquerel","Becquerel",0,0},""," 5_Bq; mksa(_Bq)",0},
{"_Btu",{"Btu British thermal unit (unité thermique britannique)","Btu British thermal unit",0,0},""," 5_Btu; mksa(_Btu)",0},
{"_Ci",{"curie","Curie",0,0},""," 5_Ci; mksa(_Ci)",0},
{"_F",{"farad","Farad",0,0},""," 5_F; mksa(_F)",0},
{"_F_",{"Constante de Faraday","Faraday constant",0,0},""," mksa(_F_)",0},
{"_Fdy",{"faraday","Faraday",0,0},""," 5_Fdy; mksa(_fdy)",0},
{"_G_",{"Constante gravitationnelle","Gravitational constant",0,0},""," mksa(_G_)",0},
{"_Gal",{"gal=0.01_(m/s^2).","Gal=0.01_(m/s^2).",0,0},""," 5_Gal; mksa(_Gal)",0},
{"_Gy",{"gray","Gray",0,0},""," 5_Gy; mksa(_Gy)",0},
{"_H",{"henry","Henry",0,0},""," 5_H; mksa(_H)",0},
{"_Hz",{"hertz","Hertz",0,0},""," 5_Hz; mksa(_Hz)",0},
{"_I0_",{"Intensité de référence","Reference intensity",0,0},""," 5_I0_; mksa(_I0_)",0},
{"_J",{"joule","Joule",0,0},""," 5_J; mksa(_J)",0},
{"_K",{"kelvin","Kelvins",0,0},""," 5_K; mksa(_K)",0},
{"_Kcal",{"kilocalorie.","Kilocalorie.",0,0},""," 5_Kcal; mksa(_Kcal)",0},
{"_MHz",{"mégahertz.","Megahertz.",0,0},""," 5_MHz; mksa(_MHz)",0},
{"_MW",{"mégawatt.","Megawatt.",0,0},""," 5_MW; mksa(_MW)",0},
{"_MeV",{"mégaélectronvolt.","Megaelectronvolt.",0,0},""," 5_MeV; mksa(_MeV)",0},
{"_N",{"newton","Newton",0,0},""," 5_N; mksa(_N)",0},
{"_NA_",{"Nombre d'Avogadro.","Avogadro's number.",0,0},""," mksa(_NA_)",0},
{"_Ohm",{"ohm","Ohm",0,0},""," 5_Ohm; mksa(_Ohm)",0},
{"_P",{"poise (mesure la viscosité)","Poise (measures viscosity)",0,0},""," 5_P; mksa(_P)",0},
{"_PSun_",{"Puissance à la surface du Soleil","Power at the surface of the Sun",0,0},""," mksa(_PSun_)",0},
{"_Pa",{"pascal","Pascal",0,0},""," 5_Pa; mksa(_Pa)",0},
{"_R",{"röntgen 1_R=","Roentgen 1_R=",0,0},""," 5_R; mksa(_R)",0},
{"_REarth_",{"Rayon de la Terre","Radius of the Earth",0,0},""," mksa(_REarth_)",0},
{"_RSun_",{"Rayon du Soleil","Radius of the Sun",0,0},""," mksa(_RSun_)",0},
{"_R_",{"Constante universelle des gaz.","Universal gas constant.",0,0},""," mksa(_R_)",0},
{"_Rankine",{"degré Rankine.","Degree Rankine.",0,0},""," 5_Rankine; mksa(_Rankine)",0},
{"_Rinfinity_",{"Constante de Rydberg","Rydberg constant",0,0},""," mksa(_Rinfinity_)",0},
{"_S",{"Siemens","Siemens",0,0},""," 5_S; mksa(_S)",0},
{"_St",{"Stokes","Stokes",0,0},""," 5_St; mksa(_St)",0},
{"_StdP_",{"Pression standard.","Standard pressure.",0,0},""," mksa(_StdP_)",0},
{"_StdT_",{"Température standard.","Standard temperature.",0,0},""," mksa(_StdT_)",0},
{"_Sv",{"Sievert","Sievert",0,0},""," 5_Sv; mksa(_Sv)",0},
{"_T",{"Tesla","Tesla",0,0},""," 5_T; mksa(_T)",0},
{"_V",{"volt","Volt",0,0},""," 5_V; mksa(_V)",0},
{"_Vm_",{"Volume molaire.","Molar volume.",0,0},""," mksa(_Vm_)",0},
{"_W",{"watt","Watt",0,0},""," 5_W; mksa(_W)",0},
{"_Wb",{"weber","Weber",0,0},""," 5_Wb; mksa(_Wb)",0},
{"_Wh",{"wattheure.","Watt-hour.",0,0},""," 5_Wh; mksa(_Wh)",0},
{"_a",{"are (100 m^2)","Are (100 m^2)",0,0},""," 5_a; mksa(_a)",0},
{"_a0_",{"Rayon de Bohr","Bohr radius",0,0},""," mksa(_a0_)",0},
{"_acre",{"acre","Acre",0,0},""," 5_acre; mksa(_acre)",0},
{"_alpha_",{"Constante de structure fine","Fine structure constant",0,0},""," mksa(_alpha_)",0},
{"_angl_",{"Angle de 180 degrés","Angle of 180 degrees",0,0},""," mksa(_angl_)",0},
{"_arcmin",{"minutes d'arc","Minute of arc",0,0},""," 5_arcmin; mksa(_arcmin)",0},
{"_arcs",{"secondes d'arc","Second of arc",0,0},""," 5_arcs; mksa(_arcs)",0},
{"_atm",{"atmosphère normale","Atmosphere",0,0},""," 5_atm; mksa(_atm)",0},
{"_au",{"unité astronomique","Astronomical unit",0,0},""," 5_au; mksa(_au)",0},
{"_b",{"barn","Barn",0,0},""," 5_b; mksa(_b)",0},
{"_bar",{"bar","Bar",0,0},""," 5_bar; mksa(_bar)",0},
{"_bbl",{"baril","Barrel",0,0},""," 5_bbl; mksa(_bbl)",0},
{"_bblep",{"baril d'équivalent pétrole.","Barrel of oil equivalent.",0,0},""," 5_bblep; mksa(_bblep)",0},
{"_bu",{"bushel (boisseau britannique 1_bu=8_galUK)","Bushel (1_bu=8_galUK)",0,0},""," 5_bu; mksa(_bu)",0},
{"_buUS",{"bushel (boisseau américain)","coulomb",0,0},""," 5_buUS; mksa(_buUS); _C; 5_C; mksa(_C)",0},
{"_c3_",{"Constante de la loi de répartition de Wien","Wien displacement constant",0,0},""," mksa(_c3_)",0},
{"_c_",{"Vitesse de la lumière.","Speed of light in vacuum.",0,0},""," mksa(_c_)",0},
{"_cal",{"calorie","Calorie",0,0},""," 5_cal; mksa(_cal)",0},
{"_cd",{"candela","Candela",0,0},""," 5_cd; mksa(_cd)",0},
{"_chain",{"chain (1 chain = 66 pieds ou 22 yards)","Chain (1 chain = 66 feet or 22 yards)",0,0},""," 5_chain; mksa(_chain)",0},
{"_cm",{"centimètre.","Centimetre.",0,0},""," 5_cm; mksa(_cm)",0},
{"_cm^2",{"centimètre carré.","Square centimetre.",0,0},""," 5_cm^2; mksa(_cm^2)",0},
{"_cm^3",{"centimètre cube.","Cubic centimetre.",0,0},""," 5_cm^3; mksa(_cm^3)",0},
{"_ct",{"Carat métrique","Carat",0,0},""," 5_ct; mksa(_ct)",0},
{"_cu",{"cup US (coupe EUA)","US cup",0,0},""," 5_cu; mksa(_cu)",0},
{"_d",{"jour","Day",0,0},""," 5_d; mksa(_d)",0},
{"_dB",{"décibel","Decibel",0,0},""," 5_dB; mksa(_dB)",0},
{"_deg",{"degré (angle).","Degree (angle).",0,0},""," 5_deg; mksa(_deg)",0},
{"_degreeF",{"degré Fahrenheit.","Degree Fahrenheit.",0,0},""," 5_degreeF; mksa(_degreeF)",0},
{"_dyn",{"dyne","Dyne",0,0},""," 5_dyn; mksa(_dyn)",0},
{"_eV",{"électronvolt","Electron volt",0,0},""," 5_eV; mksa(_eV)",0},
{"_epsilon0_",{"Permittivité du vide","Permittivity of vacuum",0,0},""," mksa(_epsilon0_)",0},
{"_epsilon0q_",{"epsilon0/q (permittivité/charge de l'électron)","epsilon0/q (permittivity/charge of the electron)",0,0},""," mksa(_epsilon0q_)",0},
{"_epsilonox_",{"Constante diélectrique du dioxyde de silicium","Dielectric constant of Silicon dioxide",0,0},""," mksa(_epsilonox_)",0},
{"_epsilonsi_",{"Constante diélectrique du silicium","Dielectric constant",0,0},""," mksa(_epsilonsi_)",0},
{"_erg",{"erg","Erg",0,0},""," 5_erg; mksa(_erg)",0},
{"_f0_",{"Fréquence du photon (e/h)","Photon frequency (e/h)",0,0},""," mksa(_f0_)",0},
{"_fath",{"fathom (brasse)","Fathom",0,0},""," 5_fath; mksa(_fath)",0},
{"_fbm",{"board foot (pied planche)","Board foot",0,0},""," 5_fbm; mksa(_fbm)",0},
{"_fc",{"footcandle (1 footcandle ≈ 10.764 lux)","Footcandle (1 footcandle ≈ 10.764 lux)",0,0},""," 5_fc; mksa(_fc)",0},
{"_fermi",{"fermi","Fermi",0,0},""," 5_fermi; mksa(_fermi)",0},
{"_flam",{"footlambert","Footlambert",0,0},""," 5_flam; mksa(_flam)",0},
{"_fm",{"fathom (brasse)","Fathom",0,0},""," 5_fm; mksa(_fm)",0},
{"_ft",{"foot (pied)","International foot",0,0},""," 5_ft; mksa(_ft)",0},
{"_ft*lb",{"foot par pound.","foot per pound.",0,0},""," 5_ft*lb; mksa(_ft*lb)",0},
{"_ftUS",{"foot survey EUA","Survey foot",0,0},""," 5_ftUS; mksa(_ftUS)",0},
{"_ft^2",{"foot carré (pied carré).","Square foot.",0,0},""," 5_ft^2; mksa(_ft^2)",0},
{"_ft^3",{"foot cube.","Cubic foot.",0,0},""," 5_ft^3; mksa(_ft^3)",0},
{"_g",{"gramme","Gram",0,0},""," 5_g; mksa(_g)",0},
{"_g_",{"Accélération de la gravité","Acceleration of gravity",0,0},""," mksa(_g_)",0},
{"_ga",{"Standard freefall (chute libre standard)","Standard freefall",0,0},""," 5_ga; mksa(_ga)",0},
{"_galC",{"gallon canadien","Canadian gallon",0,0},""," 5_galC; mksa(_galC)",0},
{"_galUK",{"gallon britannique","UK gallon",0,0},""," 5_galUK; mksa(_galUK)",0},
{"_galUS",{"gallon EUA","US gallon",0,0},""," 5_galUS; mksa(_galUS)",0},
{"_gf",{"gramme-force (gravet)","Gram-force",0,0},""," 5_gf; mksa(_gf)",0},
{"_gmol",{"gramme-mole","Gram-mole",0,0},""," 5_gmol; mksa(_gmol)",0},
{"_gon",{"grade","Grade",0,0},""," 5_gon; mksa(_gon)",0},
{"_grad",{"grade","Grade",0,0},""," 5_grad; mksa(_grad)",0},
{"_grain",{"grain (unité de masse ≈ 0,0648 grammes)","Grain (1 grain ≈ 0,0648 grams)",0,0},""," 5_grain; mksa(_grain)",0},
{"_h",{"heure","Hour",0,0},""," 5_h; mksa(_h)",0},
{"_h_",{"Constante de Planck","Planck's constant",0,0},""," mksa(_h_)",0},
{"_ha",{"hectare","Hectare",0,0},""," 5_ha; mksa(_ha)",0},
{"_hbar_",{"Constante de Dirac","Dirac's constant",0,0},""," mksa(_hbar_)",0},
{"_hp",{"horsepower (cheval-vapeur)","Horsepower",0,0},""," 5_hp; mksa(_hp)",0},
{"_in",{"inch (pouce)","Inch",0,0},""," 5_in; mksa(_in)",0},
{"_inH20",{"inch of water, 60 degrés Fahrenheit","Inches of water, 60 degrees Fahrenheit",0,0},""," 5_inH20; mksa(_inH20)",0},
{"_inHg",{"inch of mercury (pouce de mercure), 0 degré Celsius","Inches of mercury, 0 degree Celsius",0,0},""," 5_inHg; mksa(_inHg)",0},
{"_in^2",{"inch carré (pouce carré).","Square inch.",0,0},""," 5_in^2; mksa(_in^2)",0},
{"_in^3",{"inch cube.","Cubic inch.",0,0},""," 5_in^3; mksa(_in^3)",0},
{"_j",{"jour","Day",0,0},""," 5_j; mksa(_j)",0},
{"_kWh",{"kilowattheure.","Kilowatt-hour.",0,0},""," 5_kWh; mksa(_kWh)",0},
{"_k_",{"Constante de Boltzmann.","Boltzmann constant.",0,0},""," mksa(_k_)",0},
{"_kg",{"kilogramme","Kilogram",0,0},""," 5_kg; mksa(_kg)",0},
{"_kip",{"kilopound-force","Kilopound-force",0,0},""," 5_kip; mksa(_kip)",0},
{"_km",{"kilomètre.","Kilometre.",0,0},""," 5_km; mksa(_km)",0},
{"_km^2",{"kilomètre carré.","Square kilometre.",0,0},""," 5_km^2; mksa(_km^2)",0},
{"_knot",{"mille nautique par heure","nautical miles per hour",0,0},""," 5_knot; mksa(_knot)",0},
{"_kph",{"kilomètre par heure","Kilometers per hour",0,0},""," 5_kph; mksa(_kph)",0},
{"_kq_",{"k/q (Boltzmann/charge de l'électron)","k/q (Boltzmann/charge of the electron)",0,0},""," mksa(_kq_)",0},
{"_l",{"litre","Liter",0,0},""," 5_l; mksa(_l)",0},
{"_lam",{"lambert","Lambert",0,0},""," 5_lam; mksa(_lam)",0},
{"_lambda0_",{"Longueur d'onde du photon (ch/e)","Photon wavelength (ch/e)",0,0},""," mksa(_lambda0_)",0},
{"_lambdac_",{"Longueur d'onde du Compton","Compton wavelength",0,0},""," mksa(_lambdac_)",0},
{"_lb",{"livre (1 livre = 16 oz)","pound (1 pound = 16 oz)",0,0},""," 5_lb; mksa(_lb)",0},
{"_lbf",{"pound-force","Pound-force",0,0},""," 5_lbf; mksa(_lbf)",0},
{"_lbmol",{"livre-mole","Pound-mole",0,0},""," 5_lbmol; mksa(_lbmol)",0},
{"_lbt",{"troy pound","Troy pound",0,0},""," 5_lbt; mksa(_lbt)",0},
{"_lep",{"litre d'équivalent pétrole.","Liter of oil equivalent.",0,0},""," 5_lep; mksa(_lep)",0},
{"_liqpt",{"US liquid pint (1_galUS=8_liqpt)","US liquid pint (1_galUS=8_liqpt)",0,0},""," 5_liqpt; mksa(_liqpt)",0},
{"_lm",{"lumen","Lumen",0,0},""," 5_lm; mksa(_lm)",0},
{"_lx",{"lux","Lux",0,0},""," 5_lx; mksa(_lx)",0},
{"_lyr",{"année-lumière","Light year",0,0},""," 5_lyr; mksa(_lyr)",0},
{"_m",{"Mètre (unit)","Metre (unit)",0,0},""," 5_m",0},
{"_mEarth_",{"Masse de la Terre","Mass of the Earth",0,0},""," mksa(_mEarth_)",0},
{"_m^2",{"mètre carré.","Square metre.",0,0},""," 5_m^2; mksa(_m^2)",0},
{"_m^3",{"mètre cube.","Cubic metre.",0,0},""," 5_m^3; mksa(_m^3)",0},
{"_me_",{"Masse élémentaire de l'électron","Electron rest mass",0,0},""," mksa(_me_)",0},
{"_mho",{"mho","Mho",0,0},""," 5_mho; mksa(_mho)",0},
{"_miUS",{"US statute mile","US statute mile",0,0},""," 5_miUS; mksa(_miUS)",0},
{"_miUS^2",{"US statue mile carré.","Square US statue mile.",0,0},""," 5_miUS^2; mksa(_miUS^2)",0},
{"_mi^2",{"mile carré international.","Square international mile.",0,0},""," 5_mi^2; mksa(_mi^2)",0},
{"_mil",{"mil","Mil",0,0},""," 5_mil; mksa(_mil)",0},
{"_mile",{"International mile","International mile",0,0},""," 5_mile; mksa(_mile)",0},
{"_mille",{"mille marin","Nautical mile",0,0},""," 5_mille; mksa(_mille)",0},
{"_ml",{"millilitre.","millilitre.",0,0},""," 5_ml; mksa(_ml)",0},
{"_mm",{"millimètre.","Millimetre.",0,0},""," 5_mm; mksa(_mm)",0},
{"_mmHg",{"millimètre de mercure (torr), 0 degré Celsius","Millimeter of mercury (torr), 0 degree Celsius",0,0},""," 5_mmHg; mksa(_mmHg)",0},
{"_mn",{"minute.","Minute.",0,0},""," 5_mn; mksa(_mn)","convert,mksa"},
{"_mol",{"mole","Mole",0,0},""," 5_mol; mksa(_mol)",0},
{"_mp_",{"Masse élémentaire du proton","Proton rest mass",0,0},""," mksa(_mp_)",0},
{"_mph",{"mile par heure","Miles per hour",0,0},""," 5_mph; mksa(_mph)",0},
{"_mpme_",{"Rapport mp/me (masse du proton/masse de l'électron)","Quotient mp/me (mass of the proton/mass of the electron)",0,0},""," mksa(_mpme_)",0},
{"_mu0_",{"Perméabilité du vide","Permeability of vacuum",0,0},""," mksa(_mu0_)",0},
{"_muB_",{"Magnéton de Bohr","Bohr magneton",0,0},""," mksa(_muB_)",0},
{"_muN_",{"Magnéton nucléaire","Nuclear magneton",0,0},""," mksa(_muN_)",0},
{"_oz",{"once","Ounce",0,0},""," 5_oz; mksa(_oz)",0},
{"_ozUK",{"once fluide britannique","UK fluid ounce",0,0},""," 5_ozUK; mksa(_ozUK)",0},
{"_ozfl",{"once fluide EUA","US fluid ounce",0,0},""," 5_ozfl; mksa(_ozfl)",0},
{"_ozt",{"once de troy","Troy ounce",0,0},""," 5_ozt; mksa(_ozt)",0},
{"_pc",{"parsec","Parsec",0,0},""," 5_pc; mksa(_pc)",0},
{"_pdl",{"poundal (unité de force)","Poundal (force)",0,0},""," 5_pdl; mksa(_pdl)",0},
{"_ph",{"phot","Phot",0,0},""," 5_ph; mksa(_ph)",0},
{"_phi_",{"Quantum de flux magnétique","Magnetic flux quantum",0,0},""," mksa(_phi_)",0},
{"_pk",{"US peck","US peck",0,0},""," 5_pk; mksa(_pk)",0},
{"_psi",{"pound-force par inch carré","Pounds per square inch",0,0},""," 5_psi; mksa(_psi)",0},
{"_ptUK",{"pinte britannique (1_galUK=8_ptUK)","UK pint (1_galUK=8_ptUK)",0,0},""," 5_ptUK; mksa(_ptUK)",0},
{"_q_",{"Charge de l'électron","Electron charge",0,0},""," mksa(_q_)",0},
{"_qepsilon0_",{"q*epsilon0 (charge de l'électron*permittivité)","q*epsilon0 (charge of the electron*permittivity)",0,0},""," mksa(_qepsilon0_)",0},
{"_qme_",{"Rapport q/me (charge/masse de l'électron)","Quotient q/me (charge/mass of the electron)",0,0},""," mksa(_qme_)",0},
{"_qt",{"quart (de gallon)","Quart",0,0},""," 5_qt; mksa(_qt)",0},
{"_rad",{"radian","Radian",0,0},""," 5_rad; mksa(_rad)",0},
{"_rad_",{"1 radian","1 radian",0,0},""," mksa(_rad_)",0},
{"_rd",{"rad 1_rd=0.01_Gy","Rad 1_rd=0.01_Gy",0,0},""," 5_rd; mksa(_rd)",0},
{"_rem",{"rem","Rem",0,0},""," 5_rem; mksa(_rem)",0},
{"_rod",{"rod 1_rod=5.029215842_m","Rod 1_rod=5.029215842_m",0,0},""," 5_rod; mksa(_rod)",0},
{"_rpm",{"tours par minute","Revolutions per minute",0,0},""," 5_rpm; mksa(_rpm)",0},
{"_s",{"seconde","Second",0,0},""," 5_s; mksa(_s)",0},
{"_s",{"seconde.","second.",0,0},""," 5_mn; mksa(_mn)","convert,mksa"},
{"_sb",{"stilb","Stilb",0,0},""," 5_sb; mksa(_sb)",0},
{"_sd_",{"Durée d'un jour sidéral","Duration of a sidereal day",0,0},""," mksa(_sd_)",0},
{"_sigma_",{"Constante de Stefan-Boltzmann.","Stefan-Boltzmann constant.",0,0},""," mksa(_sigma_)",0},
{"_slug",{"slug","Slug",0,0},""," 5_slug; mksa(_slug)",0},
{"_sr",{"stéradian","Steradian",0,0},""," 5_sr; mksa(_sr)",0},
{"_st",{"stère","Stere",0,0},""," 5_st; mksa(_st)",0},
{"_syr_",{"Durée d'une année sidérale","Duration of a sidereal year",0,0},""," mksa(_syr_)",0},
{"_t",{"tonne","Metric ton",0,0},""," 5_t; mksa(_t)",0},
{"_tbsp",{"tablespoon (cuillère à soupe)","Tablespoon",0,0},""," 5_tbps; mksa(_tbsp)",0},
{"_tec",{"tonne d'équivalent charbon.","Tonne of coal equivalent.",0,0},""," 5_tec; mksa(_tec)",0},
{"_tep",{"tonne d'équivalent pétrole.","Tonne of oil equivalent.",0,0},""," 5_tep; mksa(_tep)",0},
{"_tex",{"tex=10^-6 _(kg/m).","tex=10^-6 _(kg/m).",0,0},""," 5_tex; mksa(_tex)",0},
{"_therm",{"EEC therm","EEC therm",0,0},""," 5_therm; mksa(_therm)",0},
{"_ton",{"short ton (1 tonne courte = 2000 livres)","Short ton (1 short ton = 2000 pounds)",0,0},""," 5_ton; mksa(_ton)",0},
{"_tonUK",{"long (UK)","Long (UK)",0,0},""," 5_tonUK; mksa(_tonUK)",0},
{"_torr",{"torr (mmHg)","Torr (mmHg)",0,0},""," 5_torr; mksa(_torr)",0},
{"_tr",{"tour=2*pi _rad.","tour=2*pi _rad.",0,0},""," 5_tr; mksa(_tr)",0},
{"_tsp",{"teaspoon (cuillère à thé)","Teaspoon",0,0},""," 5_tsp; mksa(_tsp)",0},
{"_twopi_",{"2*pi radians","2*pi radians",0,0},""," mksa(_twopi_)",0},
{"_u",{"unité de masse atomique","Atomic mass unit",0,0},""," 5_u; mksa(_u)",0},
{"_yd",{"yard international","International yard",0,0},""," 5_yd; mksa(_yd)",0},
{"_yd^2",{"yard carré.","Square yard.",0,0},""," 5_yd^2; mksa(_yd^2)",0},
{"_yd^3",{"yard cube.","Cubic yard.",0,0},""," 5_yd^3; mksa(_yd^3)",0},
{"_yr",{"année","Year",0,0},""," 5_yr; mksa(_yr)",0},
{"_µ",{"micron","Micron",0,0},""," 5_µ; mksa(_µ)",0},
{"a2q",{"a2q(A,X)= la forme quadratique q associée à A, X =vecteur de variables.","a2q(A,X)=the quadratic form q associated to A, X=vector of variables.",0,0},"Mtrx,VectVar","a2q([[1,2],[4,4]],[x,y]);a2q([[1,3],[3,4]],[x,y])","q2a"},
{"abcuv",{"Renvoie [u,v] vérifiant au+bv=c pour 3 polynômes a,b,c.","Returns [u,v] such as au+bv=c for 3 polynomials a,b,c.",0,0},"Poly(a),Poly(b),Poly(c),[Var]","abcuv(x^2+2*x+1,x^2-1,x+1);abcuv(X^2+2*X+1,X^2-1,X+1,X);abcuv(x^2+2*x+1,x^2-1,x^3+1);abcuv(X^2+2*X+1,X^2-1,X^3+1,X);abcuv([1,2,1],[1,0,-1],[1,0,0,1])","egcd,iabcuv"},
{"about",{"Renvoie les hypothèses faites avec assume sur la variable a.","Returns the hypothesis made with assume on the variable a.",0,0},"Var(a)","about(a);about(n)","assume,purge"},
{"abs",{"Renvoie la valeur absolue ou le module de l'argument.","Returns the absolute value or the norm of its argument.",0,0},"Cplx||LstCplx","abs(-4);abs(1+2*i);abs((1+2*i)^2);abs([-2,1+i,-4])","arg"},
{"abscissa",{"Renvoie l'abscisse du point ou du vecteur.","Returns the abscissa of a point or a vector.",0,0},"Pnt or Vect","abscissa(point(1+2*i));abscissa(point(i)-point(1+2*i));abscissa(-1-i);abscissa(point(1,2,3))","ordinate,affix,cote,coordinates"},
{"accumulate_head_tail",{"Renvoie la liste obtenue à partir de l, en remplaçant les p premiers et les q derniers éléments par leur somme.","Returns the list where the first p and the last q elements of l are replaced by their sum.",0,0},"Lst(l),Intg(p),Intg(q)","accumulate_head_tail([0,1,2,3,4,5,6,7,8,9],3,2)",""},
{"acos",{"Arc cosinus","Arccosine",0,0},"Expr","acos(0)","cos,acosh"},
{"acos2asin",{"Remplace arccos(x) par pi/2-arcsin(x) dans l'argument.","Replaces arccos(x) by pi/2-arcsin(x) in the argument.",0,0},"Expr","acos2asin(acos(x)+asin(x));acos2asin(2*acos(x))","acos2atan"},
{"acos2atan",{"Remplace arccos(x) par pi/2-arctan(x/sqrt(1-x^2)) dans l'argument.","Replaces arccos(x) by pi/2-arctan(x/sqrt(1-x^2)) in the argument.",0,0},"Expr","acos2atan(2*acos(x));acos2atan(acos(sqrt(1-x^2))+acos(x))","acos2asin"},
{"acosh",{"Arc cosinus hyperbolique.","Hyperbolic arccosine.",0,0},"Expr","acosh(1)","cosh,acos"},
{"acot",{"Arc cotangente.","Arccotangent.",0,0},"Expr","acot(0)","atan,arccos"},
{"acsc",{"Arc cosécante: acsc(x)=asin(1/x).","Arccosecant: acsc(x)=asin(1/x).",0,0},"Expr","acsc(1);acsc(2)","asin,csc"},
{"add",{"Somme discrète (avec 4 ou 2 arguments renvoie la somme de a à b si a<=b ou de l'opposé de la somme de b+1 à a-1 si a>b+1 ou 0 si a=b+1) ou la primitive discrète ou la somme des éléments d'une liste (ou séquence).","Discrete sum (with 2 or 4 arguments return then sum from a to b if a<=b or of the opposite of the sum from b+1 to a-1 if a>b+1 or 0 if a=b+1) or the discrete primitive or sum of the elements of a list or a sequence.",0,0},"Expr,Var,VarMin(a),VarMax(b),[VarStep(p)]","sum(1/n^2,n,1,17);sum(1/n^2,n=1..17);sum(1/n^2,n,17,1);sum(1/n^2,n=17..1);sum(1/n^2,n,17,1,1);sum(1/n^2,n,1,17,2);sum(1,2,3,4);sum([[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9]]);sum(1/(x*(x+1)),x);sum(cos(n*x),n)","+"},
{"additionally",{"Rajout d'une hypothèse sur une variable.","Make an additionally assumption on a variable.",0,0},"Expr"," assume(n,integer);additionally(n>5); assume(n,integer);assume(n>=2,additionally)","purge,about,assume"},
{"adjoint_matrix",{"Renvoie le polynôme caractéristique de A et la comatrice de A-xI.","Returns the characteristic polynomial of A and the comatrix of A-xI.",0,0},"Mtrx","adjoint_matrix([[1,i],[2,3]])","pcar"},
{"affix",{"Nombre complexe égal à l'affixe d'un point ou d'un vecteur.","Complex number equal to the affix of a point or of a vector.",0,0},"Pnt||Vect","affix(point(i));affix(point(i)-point(1+2*i));affix([1,2])","point,vector"},
{"algsubs",{"Substitue dans l'expression Xpr, l'expression algébrique Xpr1 par l'expression algébrique Xpr2.","Substitutes in the expression Xpr, the algebraic expression Xpr1 by the algebraic expression Xpr2.",0,0},"Equal(Xpr1=Xpr2),Expr(Xpr)","algsubs(x^2=u,1+x^2+x^4);algsubs(a*b/c=d, 2*a*b^2/c);algsubs(2a=p^2-q^2,algsubs(2c=p^2+q^2,c^2-a^2))","subst,subs"},
{"algvar",{"Liste des variables par ordre d'extension algébrique.","List of the variables by ascending algebraic extension order.",0,0},"Expr","algvar(sqrt(x)+y)","lvar,lname"},
{"alog10",{"Fonction x->10^x.","Function x->10^x.",0,0},"Expr","alog10(3)","log10"},
{"alors",{"Instruction conditionnelle : (si...alors...sinon...fsi).","Conditional instruction : (si...alors...sinon...fsi).",0,0},""," si alors sinon fsi; n:=1; si n>0 alors triangle_plein(20*n); sinon disque(20*n);fsi;; n:=-1; si n>0 alors triangle_plein(20*n); sinon disque(20*n);fsi;; si x>0 alors x:=x+1; print(\"x est strictement plus grand que 1\");fsi;; si x>0 alors x:=x+1; print(\"x est strictement plus grand que 1\"); sinon x:=x-1;print(\"x est plus petit ou égal à -1\");fsi;","if"},
{"altitude",{"hauteur(A,B,C) trace la hauteur issue de A du triangle ABC","altitude(A,B,C) draws the altitude through A of the triangle ABC",0,0},"(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)","altitude(-1,1-i,i)","perpendicular,orthogonal,orthocenter,common_perpendicular"},
{"and",{"opérateur booléen infixé (et).","infixed boolean operator (and).",0,0},"Expr, Expr"," 1==2 and 2>1; 1!=2 and 2>0","or,not,xor"},
{"angle",{"angle(A,B,C) est égal à la valeur de la mesure de l'angle (AB,AC).","angle(A,B,C) is the value of the measure of the angle (AB,AC).",0,0},"(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)","angle(point(0),point(i),point(1));angle(0,1,i);angle(0,1,i,\"\");angle(0,1,i,\"a\");angle(i,1,1+i,\"b\")","triangle,bissector,legend,labels,angleat,angleatraw"},
{"angle_radian",{"Pseudo-variable pour travailler en radian (angle_radian:=1) ou en degré (angle_radian:=0).","Pseudo-variable to work with radian (angle_radian:=1) or degree (angle_radian:=0).",0,0},":=Intg(0 or 1)"," angle_radian:=1; angle_radian:=0","cas_setup"},
{"angleat",{"angleat(A,B,C,z0) affiche au point(z0) avec une légende, la valeur de la mesure de l'angle (AB,AC).","angleat(A,B,C,z0) displays at point(z0) with a legend, the value of the measure of the angle (AB,AC).",0,0},"Pnt(A),Pnt(B),Pnt(C),(Pnt or Cplx(z0))"," A:=point(0);B:=point(1);C:=point(i);angleat(A,B,C,-2-i)","angle,angleatraw,legend"},
{"angleatraw",{"angleat(A,B,C,z0) affiche au point(z0), la valeur de la mesure de l'angle (AB,AC).","angleatraw(A,B,C,z0) displays at point(z0), the value of the measure of the angle (AB,AC).",0,0},"Pnt(A)),Pnt(B),Pnt(C),(Pnt or Cplx(z0))"," A:=point(0);B:=point(1);C:=point(i);angleatraw(A,B,C,-2-i)","angle,angleat"},
{"animate",{"Anime le graphe de Xpr, dépendant de x, paramètre t en appelant plot.","Animates a plot of Xpr, depending of x, parameter t by calling plot.",0,0},"Expr(Xpr),x=xmin..xmax,t=tmin..tmax,frames=nframes","animate(sin(x*t),x=-pi..pi,t=-3..3,frames=30)","plot,animate3d,animation"},
{"animate3d",{"Anime le graphe de Xpr, dépendant de [x,y], paramètre t en appelant plotfunc.","Animate a plot of Xpr, depending of [x,y], parameter t by calling plotfunc.",0,0},"Expr(Xpr),[x=xmin..xmax,y=ymin..ymax],t=tmin..tmax,frames=nframes","animate3d(x^2+t*y^2,[x=-2..2,y=-2..2],t=-3..3,frames=10)","plotfunc,animate,animation"},
{"animation",{"Trace en boucle chaque objet d'une suite d'objets graphiques.","Draws in a loop each object of a geometric object sequence.",0,0},"Mtrx","animation(seq(plotfunc([cos(a*t),sin(a*t)],t=0..2*pi/a),a,1,12,0.3));animation(seq(plotparam([sin(t),sin(a*t)],t,0,2*pi,tstep=0.01),a,1,10,0.2));animation(seq(line([0,0,0],[1,1,a]),a,-5,5,0.5));animation(seq(plotfunc(x^2-y^a,[x,y]),a=1..3));animation(seq(plotfunc((x+i*y)^a,[x,y],display=filled),a=1..10)); plotfunc(x^2);animation([point(1),segment(1,1+i),point(1+i)],droite(y=2*x-1))","animate,animate3d"},
{"ans",{"Renvoie la (n+1)-ième réponse de l'historique des commandes si n>=0 ou, la (-n)-ième réponse précédente si n<0 (par défaut n=-1 pour la réponse précédente).","Returns the n+1-th answer of the command history if n>=0 or, the (-n)th previous answer if n<0 (by defaults n=-1 for the previous answer).",0,0},"Intg(n)","ans();ans(2);ans(-2)","quest"},
{"append",{"Rajoute un élément à la fin d'une liste.","Append an element to a list.",0,0},"(Lst||Seq|| Set,Elem","append([1,2,3],4);append(%{1,2,3%},4)","concat,prepend"},
{"apply",{"Applique la fonction f à tous les éléments d'une liste l (option matrix pour une matrice).","Apply the function f at the elements of the list l (option matrix for a matrix).",0,0},"Fnc(f),Lst(l)","apply(x->x^3,[1,2,3]);apply(x->x+1,[[1,2,3],[1,2,3]],matrix)","map,unapply,matrix"},
{"approx",{"Évaluation numérique du premier argument (le nombre de digits peut être donné comme second argument)","Numerical evaluation of the first argument (we can give the number of digits as second argument)",0,0},"Expr,[Int]","evalf(2/3);evalf(2/3,2);evalf(2*sin(1));evalf(2*sin(1),40);evalf(sqrt(2)+pi);evalf(sqrt(2)+pi,30)","evalb,eval"},
{"approx_mode",{"Pseudo-variable pour travailler en mode approximatif (approx_mode:=1) ou en mode exact (approx_mode:=0).","Pseudo-variable to work in approximative mode (approx_mode:=1) or in exact mode (approx_mode:=0).",0,0},":=Intg(0 or 1)"," approx_mode:=1; approx_mode:=0","cas_setup"},
{"arc",{"Trace un arc de cercle donné par 2 sommets et l'angle au centre [Xcas mettra le centre dans C et le rayon dans r]","Draws a circle arc given by 2 vertices and the angle at center [Xcas will put the center in C and the radius in r]",0,0},"Pnt, Pnt, Real,[Var(C)],[Var(r)]","arc(0,1,pi/4);arc(0,1,pi/4,C,r)","circle"},
{"arcLen",{"Calcule la longueur de l'arc de courbe définie par y=Xpr(ou par x=Xpr1,y=Xpr2) pour les valeurs du paramètre comprises entre a et b.","Returns the length of the arc of the curve defined by y=Xpr(or by x=Xpr1,y=Xpr2) when the parameter values are between a and b.",0,0},"Expr(Xpr) or Lst([Xpr1,Xpr2]),Var,Real(a),Real(b)","arcLen(t^2,t,1,2);arcLen([t,t^2],t,1,2);arcLen([cos(t),sin(t)],t,1,2)","int"},
{"arccos",{"Arc cosinus","Arccosine",0,0},"Expr","acos(0)","cos,acosh"},
{"arccosh",{"Arc cosinus hyperbolique.","Hyperbolic arccosine.",0,0},"Expr","acosh(1)","cosh,acos"},
{"archive",{"Archive le contenu d'une variable ou d'une liste de variables donnée comme argument dans le fichier spécifié (lisible avec unarchive).","Archive the value of a variable or of a list of variables given as argument in the specified file (legible with unarchive).",0,0},"Str(namefich),Seq(Var)","archive(\"toto\",[a,b]);archive(\"aa.txt\",aa)","unarchive,Archive,Unarchiv"},
{"arclen",{"Calcule la longueur de l'arc de courbe définie par y=Xpr(ou par x=Xpr1,y=Xpr2) pour les valeurs du paramètre comprises entre a et b.","Returns the length of the arc of the curve defined by y=Xpr(or by x=Xpr1,y=Xpr2) when the parameter values are between a and b.",0,0},"Expr(Xpr) or Lst([Xpr1,Xpr2]),Var,Real(a),Real(b)","arcLen(t^2,t,1,2);arcLen([t,t^2],t,1,2);arcLen([cos(t),sin(t)],t,1,2)","int"},
{"arcsin",{"Arc sinus.","Arcsine.",0,0},"Expr","asin(0)","sin"},
{"arcsinh",{"Arc sinus hyperbolique.","Hyperbolic arcsine.",0,0},"Expr","asinh(0)","sinh,asin"},
{"arctan",{"Arc tangente.","Arctangent.",0,0},"Expr","atan(0)","tan,atanh"},
{"arctanh",{"Arc tangente hyperbolique.","Hyperbolic arctangent.",0,0},"Expr","atanh(0)","atan,tanh"},
{"area",{"Aire algébrique d'un cercle ou d'un polygone étoilé (par exemple triangle, carré, ...) ou de l'aire sous une courbe en option la méthode de quadrature (trapeze,rectangle_gauche,rectangle_droit,point_milieu,simpson,rombergt,rombergm).","Algebraic area of a circle or of a (star) polygon (e.g. triangle, square, ...)or of the area below a curve, optionally with a quadrature method (trapezoid,left_rectangle,right_rectangle,middle_point,simpson,rombergt,rombergm).",0,0},"Polygone || Expr,x=a..b,[n],[Method]","area(triangle(0,1,i));area(square(0,2));area(circle(0,2));area(0,1,i);area(x^2,x=0..1,5,trapezoid);area(x^2,x=0..1,5,simpson);area(x^2,x=0..1,5,rombergm)","trapezoid,perimeter,areaatraw,areaat,areaplot"},
{"areaat",{"Affiche au point(z0), avec une légende, l'aire algébrique d'un cercle ou d'un polygone étoilé (par exemple triangle, carré, ...)","Displays at point(z0), with a legend, algebraic area of a circle or of a (star) polygon (e.g. triangle, square, ...)",0,0},"Polygone, Pnt||Cplx(z0)"," t:=triangle(0,1,i);areaat(t,(1+i)/2); c:=square(0,2);areaat(c,1+i); c2:=circle(0,2);areaat(c2,1+i); p:=polygon(0,1,i);areaat(p,1+i); A:=point(0);B:=point(1+i);c:=carre(A,B);areaat(c,i)","area,areaatraw,polygon,perimeteratraw,areaplot"},
{"areaatraw",{"Affiche au point(z0), l'aire algébrique d'un cercle ou d'un polygone étoilé (par exemple triangle, carré, ...)","Displays at point(z0), algebraic area of a circle or of a (star-)polygon (e.g. triangle, square, ...)",0,0},"Polygone, Pnt||Cplx(z0)","areaatraw(triangle(0,1,i),(1+i)/2);areaatraw(square(0,2),1+i);areaatraw(circle(0,2),1+i);areaatraw(polygon(0,1,i),1+i); A:=point(0);B:=point(1+i);c:=carre(A,B);areaatraw(c,i)","area,areaat,polygon,perimeteratraw,areaplot"},
{"areaplot",{"Affiche l'aire sous une courbe, en option la méthode de quadrature (trapeze,rectangle_gauche,rectangle_droit,point_milieu).","Displays the area below a curve, optionally with a quadrature method (trapezoid,left_rectangle,right_rectangle,middle_point).",0,0},"Expr,x=a..b,[n],[Method]","plotarea(sin(x),x=0..pi);plotarea(x^2,x=0..1,5,trapezoid);plotarea(x^2,x=0..1,5,middle_point)","integrate,plot,area,areaat,areaatraw"},
{"arg",{"Argument d'un nombre complexe.","Returns the argument of a complex number.",0,0},"Expr","arg(1+i);arg(1+2*i);arg((1+2*i)^2)","abs"},
{"args",{"Dans un programme args(NULL) désigne la liste formée par la fonction et ses arguments.","Inside a program args(NULL) is the list of the function and its arguments.",0,0},"NULL"," f(a,b):={local y; y:=args(NULL); print(y); return a+b;};f(12,5)",""},
{"array",{"Option de convert pour définir des matrices creuses.","Option for convert for definitions of sparse matrix definitions.",0,0},"Opt"," A[0..2,0..2]:=1;A[0..1,1..2]:=2;convert(A,array); B[0..1,1..2]:=1;B[2,2]:=2;convert(B,array)","convert,table"},
{"as_function_of",{"Renvoie un élément défini comme fonction d'un élément défini précédemment.","Returns an element defined as a function of an element previously defined.",0,0},"VarResult,VarArg","as_function_of(b,a)","locus"},
{"asc",{"Renvoie la liste des codes ASCII d'une chaîne.","Returns the list of the ASCII codes of a string.",0,0},"Str","asc(\"bonjour\");asc(\"A\")","char,ord"},
{"asec",{"Arc sécante: asec(x)=acos(1/x).","Arcsecant: asec(x)=acos(1/x).",0,0},"Expr","asec(1);asec(2)","acos,sec"},
{"asin",{"Arc sinus.","Arcsine.",0,0},"Expr","asin(0)","sin"},
{"asin2acos",{"Remplace arcsin(x) par pi/2-arccos(x) dans l'argument.","Replaces arcsin(x) by pi/2-arccos(x) in the argument.",0,0},"Expr","asin2acos(acos(x)+asin(x));asin2acos(2*asin(x))","asin2atan"},
{"asin2atan",{"Remplace arcsin(x) par arctan(x/sqrt(1-x^2)) dans l'argument.","Replaces arcsin(x) by arctan(x/sqrt(1-x^2)) in the argument.",0,0},"Expr","asin2atan(2*asin(x));asin2atan(asin(sqrt(1-x^2))+asin(x))","asin2acos"},
{"asinh",{"Arc sinus hyperbolique.","Hyperbolic arcsine.",0,0},"Expr","asinh(0)","sinh,asin"},
{"assert",{"Instruction dans un programme, renvoie une erreur si b==faux.","Instruction in a program, returns an error if b==false.",0,0},"Boolean(b)","assert(a>0);","break"},
{"assign",{"Stocke le deuxième argument (de l'égalité) dans la variable donnée comme premier argument (de l'égalité) (compatibilité Maple).","Store the second argument (of the equality) in the variable given as first argument (of the equality) (Maple compatibility).",0,0},"(Var,value) or Equal or LstEq.","assign(a,2);assign(a=2);assign([a1=1,a2=2,a3=3])","sto,:="},
{"assume",{"Hypothèse sur une variable.","Make an assumption on a variable.",0,0},"Expr","assume(a>0);assume(a=0.3);assume(a:=[pi/4,0,pi/2]);assume(a:=[pi/4,0,pi/2,0.1]);assume(n,integer);;assume(n,integer);additionally(n>6);assume(a>-10 and a<10);assume((a>=2 and a<4) or a>6);assume(a>=2);additionally(a<6);assume(a)","purge,about,additionally"},
{"at",{"at(l,j) (ou at(m,[j,k])) désigne l'élément de la liste l (ou matrice m) d'indice j (ou d'indice j,k).","at(l,j) (or at(m,[j,k])) is the element of the list l (or matrix m) for index=j (or for index j,k).",0,0},"Lst(l)||Mtrx(m),Index(j)||Lst([j,k])","at([10,11,12],1);at([[1,2],[3,4]],[1,0])","of"},
{"atan",{"Arc tangente.","Arctangent.",0,0},"Expr","atan(0)","tan,atanh"},
{"atan2acos",{"Remplace arctan(x) par pi/2-arccos(x/sqrt(1+x^2)) dans l'argument.","Replaces arctan(x) by pi/2-arccos(x/sqrt(1+x^2)) in the argument.",0,0},"Expr",0,"atan2acos(atan(x))"},
{"atan2asin",{"Remplace arctan(x) par arcsin(x/sqrt(1+x^2)) dans l'argument.","Replaces arctan(x) by arcsin(x/sqrt(1+x^2))in the argument.",0,0},"Expr",0,"atan2asin(atan(x))"},
{"atanh",{"Arc tangente hyperbolique.","Hyperbolic arctangent.",0,0},"Expr","atanh(0)","atan,tanh"},
{"atrig2ln",{"Réécrit l'expression contenant des fonctions trigonométriques inverses avec des logarithmes.","Rewrites the expression containing inverse trigonometric functions with logarithmic functions.",0,0},"Expr","atrig2ln(atan(x));atrig2ln(asin(x));atrig2ln(acos(x))","trig2exp,exp2trig"},
{"augment",{"Concatène deux listes ou deux chaînes ou deux séquences ou 2 matrices (les 2 matrices doivent avoir le même nombre de lignes et seront concaténées ligne par ligne).","Concatenates two lists or two strings or two sequences or 2 matrix.",0,0},"Lst,Lst||Seq,Seq||Str,Str||Mtrx,Mtrx","concat([1,2],[3,4,5]);concat(\"bon\",\"jour\");concat([[1,2],[3,4]],[[4,5,6],[6,7,8]])","append,cat,semi_augment,border,+"},
{"autosimplify",{"A pou argument une commande que Xcas utilise pour réécrire les résultats dans Xcas (au lancement c'est regroup ou 1 et pour pas de simplification c'est nop ou 0).","The argument is a command that Xcas will use to rewrite answers (initial value is regroup and for no simplification it is nop or 0).",0,0},"Cmds","autosimplify(nop);autosimplify(0);autosimplify(regroup);autosimplify(1);autosimplify(factor);autosimplify(simplify)","simplify,factor,regroup"},
{"avance",{"La tortue avance de n pas (par défaut n=10).","The turtle takes n steps forward (by default n=10).",0,0},"NULL or Real(n)"," avance 30;avance(30)","recule,saute"},
{"avgRC",{"Calcule le taux d'accroissement de l'expression Xpr quand on passe de var à var+h : (Xpr(var+h)-Xpr(var))/h (par défaut h=0.001).","Returns (Xpr(var+h)-Xpr(var))/h (by default h=0.001).",0,0},"Expr(Xpr),Var(var),[Real(h)]","avgRC(f(x),x,h);avgRC(x^2,x,0.1);avgRC(x^2,x)","nDeriv"},
{"axes",{"Option globale (compatibilité Maple) d'une commande graphique pour mettre ou non les axes.","Global option (Maple compatibility) of a graphic command to put or not the axes.",0,0},"Opt"," axes=0;segment(0,point(1,1)); axes=1;segment(0,point(1,1),epaisseur=5)","line_width"},
{"back",{"Désigne le dernier élément d'un vecteur ou d'une suite d'éléments ou d'une chaîne.","Returns the last element of a vector or a sequence or a string.",0,0},"Vect or Seq or Str","back(1,2,3);back([1,2,3]);back(\"bonjour\")","inter,head,mid,left,right"},
{"backquote",{"``","``",0,0},"Expr",0,"quote"},
{"baisse_crayon",{"Baisse le crayon pour que la tortue bouge en laissant des traces.","Puts the pencil down so that the turtle move with traces.",0,0},"NULL","baisse_crayon()","leve_crayon,crayon"},
{"bar_plot",{"Trace un ou des diagrammes en bâtons d'une série statistique à 1 variable.","Draws barplot of a one variable statistical serie.",0,0},"Mtrx","bar_plot([[\"France\",6],[\"Allemagne\",12],[\"Suisse\",5]]);bar_plot([3/2,2/3,5/4,4/5,7/6,6/7,9/8,8/9,11/10]);bar_plot([[2,\"xyz\",\"abc\"],[\"A\",2,5],[\"B\",5,6],[\"C\",7,7]])","camembert,histogram,frequencies"},
{"barycenter",{"barycentre([point1,coeff1],...) trace le barycentre de point1 poids coeff1...","barycenter([point1,coeff1],...) draws the barycenter of point1 with weight coeff1...",0,0},"[Pnt,Real],[Pnt,Real],[Pnt,Real]","barycenter([point(-1),1],[point(1+i),2],[point(1-i),1]);barycenter([[point(-1),1],[point(1+i),2],[point(1-i),1]]);barycenter([point(-1),point(1+i),point(1-i)],[1,2,1])","isobarycenter,midpoint"},
{"base",{"Option de convert : convert(p,base,b)= [a0,a1,..an] ou convert([a0,a1,..an],base,b)=p avec p=a0+a1*b+....an*b^(n-1) et p écrit en base 10.","Option for convert : convert(p,base,b)= [a0,a1,..an] or convert([a0,a1,..an],base,b)=p with p=a0+a1*b+....an*b^(n-1).",0,0},"Opt"," convert(123,base,8); convert([3,7,1],base,8); horner(revlist([3,7,1]),8)","convert,horner,revlist"},
{"basis",{"Extrait une base d'une famille génératrice de vecteurs.","Extract a basis from a spanning set of vectors.",0,0},"Lst(vector1,..,vectorn)","basis([[1,2,3],[4,5,6],[7,8,9],[10,11,12]])","ker,ibasis"},
{"batons",{"Dessine pour k=0..nrows, les segments (xk,0)-(xk,yk) où xk=élément ligne k colonne 0 et yk=élément ligne k colonne j (j=1..ncols).","Draws for k=0..nrows, the segments (xk,0)-(xk,yk) where xk=element row k column 0 and yk=element row k column j (j=1..ncols).",0,0},"Mtrx","batons([1,3],[2,5],[3,2]);batons([[1,3],[2,5],[3,2]]);batons([1,2,3],[3,5,2])","polygonplot,scatterplot,listplot"},
{"begin",{"Début de bloc.","Bloc begin.",0,0},""," if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);end","end,bloc,{}"},
{"bernoulli",{"bernoulli(n) désigne le n-ième nombre de Bernoulli et bernoulli(n,x) désigne le n-ième polynôme de Bernoulli de variable le deuxième argument.","bernoulli(n) is the n-th number of Bernoulli and bernoulli(n,x) is the n-th polynomial of Bernoulli and the second argument is the variable.",0,0},"Intg||(Intg,Var)","bernoulli(6);bernoulli(6,x)",""},
{"besselJ",{"besselJ(x,p) renvoie la fonction de Bessel de première espèce Jp(x).","besselJ(x,p) returns the Bessel function of first kind Jp(x).",0,0},"Real(x),Int(p)","besselJ(sqrt(2),2);besselJ(sqrt(2),-2)","BesselJ,BesselY,besselY"},
{"besselY",{"besselY(x,p) renvoie la fonction de Bessel de deuxième espèce Yp(x).","besselY(x,p) returns the Bessel function of second kind Yp(x).",0,0},"Real(x),Int(p)","besselY(sqrt(2),2);besselY(sqrt(2),-2)","BesselY,BesselJ,besselJ"},
{"betad",{"Renvoie la densité de probabilité de la loi Beta (=Gamma(a+b)*x^(a-1)*(1-x)^(b-1)/(Gamma(a)*Gamma(b))).","Returns the density of probability of the Beta law (=Gamma(a+b)*x^(a-1)*(1-x)^(b-1)/(Gamma(a)*Gamma(b))).",0,0},"Real(a>0),Real(b>0),Real(0<=x<=1)","betad(2.2,1.5,0.8)","betad_cdf,betad_icdf"},
{"betad_cdf",{"Renvoie la probabilité qu'une variable aléatoire de type Beta ayant a et b comme paramètres soit inférieure à x0 ou comprise entre x0 et y0.","Returns the probability that a Beta random variable (with a and b as parameters) is lower than x0 or between x0 and y0.",0,0},"Real(a>0),Real(b>0),Real(0<=x0<=1),[Real(0<=y0<=1)]","betad_cdf(2,1,0.2);betad_cdf(2,1,0.1,0.3)","betad,betad_icdf"},
{"betad_icdf",{"Renvoie la valeur h telle que la probabilité qu'une variable aléatoire de type Beta ayant a et b comme paramètres soit inférieure à h soit égale à p( 0<=p<=1).","Returns h such that the probability that a Beta random variable is lower than h is p (0<=p<=1).",0,0},"Real(a>0),Real(b>0),Real(0<=p<=1)","betad_icdf(2,1,0.95);betad_icdf(2,1,0.5)","betad_cdf,betad"},
{"bezier",{"Courbe de Bezier définie par des points de contrôle.","Bezier curve defined by control points.",0,0},"Lst,[plot]","bezier(1,1+i,2+i,3-i,plot);bezier(point([0,0,0]),point([1,1,0]),point([0,1,1]),plot); parameq(bezier(1,1+i,2+i,3-i)); parameq(bezier(point([0,0,0]),point([1,1,0]),point([0,1,1])))","parameq"},
{"bezout_entiers",{"Identité de Bézout pour 2 entiers.","Extended greatest common divisor of 2 integers.",0,0},"Intg,Intg","iegcd(45,75);iegcd(21,28);iegcd(30,49)","gcd,iabcuv,egcd"},
{"binomial",{"Renvoie comb(n,k)*p^k*(1-p)^(n-k) ou comb(n,k) si pas de 3ème argument.","Returns comb(n,k)*p^k*(1-p)^(n-k) or comb(n,k) if no 3rd argument.",0,0},"Intg(n),Intg(k),[Real(p in 0..1)]","binomial(4,2);binomial(4,0,0.5);binomial(4,2,0.5); assume(p>=0 and p<=1);binomial(4,2,p); assume(p>=0 and p<=1);binomial(4,p,2); randvector(6,binomial,4,0.2); ranm(4,6,binomial,4,0.7)","binomial_cdf,binomial_icdf,multinomial,randvector,ranm"},
{"binomial_cdf",{"Renvoie Proba(X<=x) ou Proba(x<=X<=y) quand X suit la loi B(n,p).","Returns Proba(X<=x) or Proba(x<=X<=y) when X follows the B(n,p) law.",0,0},"Intg(n),Real(p),Real(x),[Real(y)]","binomial_cdf(4,0.5,2);binomial_cdf(4,0.1,2);binomial_cdf(4,0.5,2,3)","binomial,binomial_icdf"},
{"binomial_icdf",{"Renvoie h tel que Proba(X<=h)=t quand X suit la loi B(n,p).","Returns h such as Proba(X<=h)=t when X follows the B(n,p) law.",0,0},"Intg(n),Real(p),Real(t)","binomial_icdf(4,0.5,0.68);binomial_icdf(4,0.1,0.95)","binomial,binomial_cdf"},
{"bisection_solver",{"Argument de fsolve indiquant la méthode pour résoudre numériquement une équation.","Argument for fsolve giving the method for solving an numerical equation.",0,0},"Opt"," fsolve(cos(x)=x,x,0..1,bisection_solver); fsolve(cos(x)=x,x,0..1,brent_solver); fsolve(cos(x)=x,x,0..1,falsepos_solver); fsolve(cos(x)=x,x,0,newton_solver); fsolve(cos(x)=x,x,0,secant_solver); fsolve(cos(x)=x,x,0,steffenson_solver)","fsolve"},
{"bisector",{"Trace la bissectrice de l'angle (AB,AC) donné par 3 points A,B,C.","Draws the bisector of the angle (AB,AC) given by 3 points A,B,C.",0,0},"(Pnt(A) or Cplx),(Pnt(B) or Cplx),(Pnt(C) or Cplx)","bisector(0,1,i)","angle,exbisector"},
{"bitand",{"Et logique bit à bit.","Logical bit and.",0,0},"Intg,Intg","bitand(0x12,0x38)","bitxor,bitor"},
{"bitor",{"Ou logique inclusif bit à bit.","Inclusive logical bit or.",0,0},"Intg,Intg","bitor(0x12,0x38)","bitxor,bitand"},
{"bitxor",{"Ou logique exclusif bit à bit.","Exclusive logical bit or.",0,0},"Intg,Intg","bitxor(0x12,0x38)","bitor,bitand"},
{"black",{"Option de la commande affichage (ou display) pour afficher en couleur.","Option of the display command to display with color.",0,0},"Opt"," F:=display(point(2+1.5*i),red); F:=display(point(2+1.5*i),point_point+green)","display"},
{"bloc",{"Mot réservé.","Reserved word.",0,0},""," if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);end; if (2>1) {print(\"ifactor(154)=\",ifactor(154));ifactor(154);}","begin,end,{}"},
{"blockmatrix",{"Renvoie la matrice obtenue en scindant la liste selon n listes de longueur m.","Returns the matrix get from the list divided into n lists of dimension m.",0,0},"Intg(n),Intg(m),Lst","blockmatrix(2,3,[idn(2),idn(2),idn(2),idn(2),idn(2),idn(2)]);blockmatrix(2,2,[idn(2),newMat(2,3),newMat(3,2),idn(3)])","list2mat"},
{"blue",{"Option de la commande affichage (ou display) pour afficher en couleur.","Option of the display command to display with color.",0,0},"Opt"," F:=display(point(2+1.5*i),red); F:=display(point(2+1.5*i),point_point+green)","display"},
{"border",{"Renvoie la matrice formée par A bordée de b en dernière colonne, si nrows(A)=size(b), border(A,b)=tran(append(tran(A),b)).","Returns the matrix obtained by bording A with b as latest column, if nrows(A)=size(b), border(A,b)=tran(append(tran(A),b)).",0,0},"Mtrx(A),Lst(b)","border([[1,2,3,4],[4,5,6,8],[7,8,9,10]],[1,3,5]);border([[1,2,3],[4,5,6],[7,8,9]],[1,0,1])","tran,append,augment"},
{"boxwhisker",{"Boite à moustache pour une série statistique.","Box and Whisker plot for a statistical serie.",0,0},"Lst,[Lst],[x=a..b||y=a..b]","boxwhisker([-1,1,2,2.2,3,4,-2,5]);boxwhisker([1,2,3,5,10,4],x=1..2);boxwhisker([1,2,3,5,10,4],[1,2,3,1,2,3]);boxwhisker([[6,0,1,3,4,2,5],[0,1,3,4,2,5,6],[1,3,4,2,5,6,0],[3,4,2,5,6,0,1],[4,2,5,6,0,1,3],[2,5,6,0,1,3,4]])","quartiles"},
{"break",{"Pour interrompre une boucle: while (cond) {inst1; if (cond) {inst2;break;}}.","Interrupts a loop: while (cond) {inst1; if (cond) {inst2;break;}}.",0,0},"","  f(a,b):={local r;while (1==1){if (b==0){break;} r:=irem(a,b);a:=b;b:=r;}a;}","continue"},
{"breakpoint",{"Ajoute un point d'arrêt.","Adds a breakpoint.",0,0},"Intg","breakpoint(1)","rmbreakpoint"},
{"brent_solver",{"Argument de fsolve indiquant la méthode pour résoudre numériquement une équation.","Argument for fsolve giving the method for solving an numerical equation.",0,0},"Opt"," fsolve(cos(x)=x,x,0..1,bisection_solver); fsolve(cos(x)=x,x,0..1,brent_solver); fsolve(cos(x)=x,x,0..1,falsepos_solver); fsolve(cos(x)=x,x,0,newton_solver); fsolve(cos(x)=x,x,0,secant_solver); fsolve(cos(x)=x,x,0,steffenson_solver)","fsolve"},
{"by",{"Saut de la variable dans une itération (taille du saut).","Step in an iteration (step size of incrementation).",0,0},""," s:=0;for j from 1 to 10 step 2 do s:=s+j end_for; s:=0;for j from 1 step 2 to 10 do s:=s+j end_for; s:=0;for j from 1 to 10 by 2 do s:=s+j end_for; s:=0;for j from 1 by 2 to 10 do s:=s+j end_for; s:=0;pour j de 1 jusque 10 pas 2 do s:=s+j fpour; s:=0;pour j de 1 pas 2 jusque 10 do s:=s+j fpour","for,pour"},
{"c1oc2",{"Renvoie la permutation égale au produit des deux cycles.","Returns the permutation product of the two cycles.",0,0},"Cycle,Cycle","c1oc2([3,4,5],[0,3])","c1op2,p1oc2"},
{"c1op2",{"Renvoie la permutation égale au produit du cycle et de la permutation.","Returns the permutation product of the cycle and the permutation.",0,0},"Cycle,Permut","c1op2([3,4,5],[0,3,2,1,5,4])","c1oc2,p1oc2"},
{"cFactor",{"Factorisation de l'expression dans ℂ (sur les entiers de Gauss si on a plus de 2 variables).","Factorization of the expression in ℂ (on the Gauss integers if there are more than 2 variables).",0,0},"Expr","cFactor(x^2*y+y);cFactor(x^2*y^2+y^2+4*x^2+4);cFactor(x^2*y^2+y^2+2*x^2+2)","factor"},
{"cSolve",{"Renvoie la liste des solutions complexes d'une équation ou la matrice dont les lignes sont solutions dans ℂ d'un système d'équations polynomiales.","Returns the list of complex solutions of an equation or a matrix where the rows are ℂ-solutions of a system of polynomial equations.",0,0},"LstEq,LstVar","csolve(x^4-1,x);csolve(x^4-y^4 and x+y=2,[x,y]);csolve(x^4-y^4 and x+y=0 and x^2=2*x,[x,y]);csolve(u*v-u=v and v^2=u,[u,v])","cZeros,solve,fslove"},
{"cZeros",{"Renvoie la liste des éléments complexes qui annulent l'expression Xpr ou la matrice dont les lignes sont les solutions du système : Xpr1=0,Xpr2=0...","Returns the list of complex elements solution of Xpr=0 or the matrix where the lines are the solutions of the system : Xpr1=0,Xpr2=0...",0,0},"Expr(Xpr)||LstExpr, [Var||LstVar]","cZeros(x^2-1);cZeros([x^2-1,x^2-y^2],[x,y])","solve"},
{"cache_tortue",{"Cache la tortue.","Hides the turtle.",0,0},"NULL","cache_tortue()","montre_tortue"},
{"camembert",{"Trace un ou des diagramme(s) en camembert d'une série statistique à 1 variable.","Draws pie chart of a one variable statistical serie.",0,0},"Mtrx","camembert([[\"France\",6],[\"Allemagne\",12],[\"Suisse\",5]]);camembert([3/2,2/3,5/4,4/5,7/6,6/7,9/8,8/9,11/10]);camembert([[2,\"xyz\",\"abc\"],[\"A\",2,5],[\"B\",5,6],[\"C\",7,7]])","bar_plot"},
{"canonical_form",{"Forme canonique du trinôme de degré 2.","Canonical_form of a 2 degree polynomial.",0,0},"Trinom(a*x^2+b*x+c),[Var]","canonical_form(2*x^2-12*x+1);canonical_form(2*a^2-12*a+1,a)",""},
{"cap",{"Retourne le cap de la tortue en degrés ou tourne la tortue selon l'argument.","Returns the turtle cap in degrees or turns the turtle with the cap given by the argument.",0,0},"NULL or Real"," cap;cap();cap 90","position,initialise"},
{"cap_flat_line",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); d:=display(line(2+i,1),cap_round_line)","display"},
{"cap_round_line",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); d:=display(line(2+i,1),cap_round_line)","display"},
{"cap_square_line",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); d:=display(line(2+i,1),cap_round_line)","display"},
{"cas_setup",{"Permet d'initialiser le cas, arguments: Approx,Cplx_var,Cplx,Angle,Format,Epsilon,Digit","Is the command for initialized the cas, arguments: Approx,Cplx_var,Cplx,Angle,Format,Epsilon,Digit",0,0},"Int,Int,Int,Int,Int,Real,Int","cas_setup(0,0,0,1,0,1e-10,12)","complexe_mode,angle_radian"},
{"case",{"Test (choix multiple): switch(variable){case 1: {bloc1;} default: {bloc2;}};","Test (multiple choice): switch(variable){case 1: {bloc1;} default: {bloc2;}};",0,0},""," a:=1;switch(a){case 0:{b:=1;break;} case 1:{b:=3;break;} default:{b:=0;}};b;","if,switch,default"},
{"cat",{"Évalue les arguments, puis les concatène en une chaîne.","Evaluates the arguments, then concatenates them into a string.",0,0},"SeqObj","cat(\"aaa\",c,12*3)","concat"},
{"catch",{"Protection contre les erreurs: try {instructions} catch(variable) {error_instructions} (dans un programme).","Error protection: try {instructions} catch(variable) {error_instructions}(in a program).",0,0},"Var"," essai(x):={local y,err;try {y:=[[1,2]]*x;}catch(err){y:=\"erreur fatale :\"+err;} return y;};essai([1,2,3])","try"},
{"cauchy",{"Renvoie la densité de probabilité en x de la loi de Cauchy de paramètres x0 (position) et a>0 (par défaut x0=0 et a=1).","Returns the density of probability at x of the Cauchy law of parameters x0 and a (by default  x0=0 and a=1).",0,0},"Real(x0),Real(a),Real(x)","cauchy(0.0,2.0,1.0)","cauchy_cdf,cauchy_icdf"},
{"cauchy_cdf",{"Renvoie la probabilité qu'une variable aléatoire de Cauchy soit inférieure à x.","Returns the probability that a Cauchy random variable is lower than x.",0,0},"Real(x0),Real(a),Real(x),[Real(y)]","cauchy_cdf(0.0,2.0,2.1);cauchy_cdf(2,3,-1.9,1.4)","cauchyd,cauchy_icdf"},
{"cauchy_icdf",{"Renvoie la valeur h telle que, la probabilité qu'une variable aléatoire de Cauchy soit inférieure à h soit p (0<=p<=1).","Returns h such that the probability that a Cauchy random variable is lower than h is p (0<=p<=1).",0,0},"Real(x0),Real(a),Real(p)","cauchy_icdf(0.0,2.0,0.95)","cauchy_cdf,cauchy"},
{"cauchyd",{"Renvoie la densité de probabilité en x de la loi de Cauchy de paramètres x0 (position) et a>0 (par défaut x0=0 et a=1).","Returns the density of probability at x of the Cauchy law of parameters x0 and a (by default  x0=0 and a=1).",0,0},"Real(x0),Real(a),Real(x)","cauchy(0.0,2.0,1.0)","cauchy_cdf,cauchy_icdf"},
{"cauchyd_cdf",{"Renvoie la probabilité qu'une variable aléatoire de Cauchy soit inférieure à x.","Returns the probability that a Cauchy random variable is lower than x.",0,0},"Real(x0),Real(a),Real(x),[Real(y)]","cauchy_cdf(0.0,2.0,2.1);cauchy_cdf(2,3,-1.9,1.4)","cauchyd,cauchy_icdf"},
{"cauchyd_icdf",{"Renvoie la valeur h telle que, la probabilité qu'une variable aléatoire de Cauchy soit inférieure à h soit p (0<=p<=1).","Returns h such that the probability that a Cauchy random variable is lower than h is p (0<=p<=1).",0,0},"Real(x0),Real(a),Real(p)","cauchy_icdf(0.0,2.0,0.95)","cauchy_cdf,cauchy"},
{"cd",{"Change de répertoire.","Change directory.",0,0},"Str","cd(\"toto\")","pwd"},
{"cdf",{"Distribution cumulée pour une loi de probabilité.","Cumulated distribution function.",0,0},"Func,FuncParams","cdf(binomial,10,0.5,4);cdf(normald,0.0,1.0,2.0);cdf([1,3,4,3,5,6],4);cdf([1,3,4,3,5,6],plot)","icdf,binomial_cdf,normald_cdf,plotcdf"},
{"ceil",{"Renvoie le plus petit entier >= à l'argument.","Returns the smallest integer >= to the argument.",0,0},"Real or Cplx","ceil(-4.2);ceil(4.3+2.4*i)","floor,round"},
{"ceiling",{"Renvoie le plus petit entier >= à l'argument.","Returns the smallest integer >= to the argument.",0,0},"Real or Cplx","ceil(-4.2);ceil(4.3+2.4*i)","floor,round"},
{"center",{"Désigne le centre d'un cercle.","Shows the center of a circle.",0,0},"Crcle","center(circle(1+i,2));center(circumcircle(0,1,1+i))","circle,radius"},
{"center2interval",{"Renvoie la liste des intervalles commençant par a0 et ayant pour centres la liste l.","Returns the list of intervals beginning with a0 and with l as centers.",0,0},"LstVal(l),[Real(a0)]","center2interval([2,5,9],1);center2interval([2,5,8])","interval2center"},
{"centered_cube",{"Dessine le cube direct de centre A de sommet B tel que le plan ABC contient un axe de symétrie du cube.","Draws the direct cube with center A, vertex B and such that the plane ABC contains a symmetry axis of the cube.",0,0},"Pnt(A),Pnt(B),Pnt(C)","centered_cube([0,0,0],[3,0,0],[0,0,1]);centered_cube(evalf([0,0,0],[3,2,4],[1,1,0]))","parallelepiped,cube,icosahedron,dodecahedron,octahedron,centered_tetrahedron"},
{"centered_tetrahedron",{"Dessine le tétraèdre régulier direct de centre A de sommet B dont un sommet est dans le plan (A,B,C).","Draws the regular direct pyramid with center A, vertex B and a vertex in the plan (A,B,C).",0,0},"Pnt(A),Pnt(B),Pnt(C)","centered_tetrahedron([0,0,0],[3,0,0],[0,1,0]);centered_tetrahedron(evalf([0,0,0],[3,2,4],[1,1,0]))","cube,tetrahedron,icosahedron,dodecahedron,octahedron"},
{"cfactor",{"Factorisation de l'expression dans ℂ (sur les entiers de Gauss si on a plus de 2 variables).","Factorization of the expression in ℂ (on the Gauss integers if there are more than 2 variables).",0,0},"Expr","cFactor(x^2*y+y);cFactor(x^2*y^2+y^2+4*x^2+4);cFactor(x^2*y^2+y^2+2*x^2+2)","factor"},
{"cfsolve",{"Résolution numérique sur ℂ d'une équation ou d'un système.","Numerical solution of an equation or a system of equation on ℂ.",0,0},"Expr,Var,[Guess or Interval],[Method]","cfsolve(cos(x)=2);cfsolve([x^2+y+2,x+y^2+2],[x,y])","fsolve,nSolve,csolve,solve"},
{"changebase",{"Renvoie la matrice B=inv(P)*A*P.","Returns the matrix B=inv(P)*A*P.",0,0},"Mtrx(A),Mtrx(P)","changebase([[1,2],[1,3]],[[1,1],[0,1]]);changebase([[1,2],[1,3]],[[1,0],[1,1]])",""},
{"char",{"Renvoie la chaîne correspondant aux codes des caractères contenus dans l'argument.","Returns the string corresponding to the character code of the argument.",0,0},"Intg or Lst(Intg)","char(65);char([65,66,67])","asc,ord"},
{"charpoly",{"Liste des coefficients du polynôme caractéristique d'une matrice ou polynôme caractéristique d'une matrice de variable le second argument.","List of the coefficients of the characteristic polynomial of a matrix or characteristic polynomial of a matrix with the second argument as variable.",0,0},"Mtrx,[Var]","pcar([[1,2],[3,4]]);pcar([[1,2],[3,4]],x);pcar([[1,2,3],[1,3,6],[2,5,7]]);pcar([[1,2,3],[1,3,6],[2,5,7]],z)","jordan,egv,egvl,companion,rat_jordan,pmin,adjoint_matrix "},
{"chinrem",{"Reste chinois pour des polynômes écrits sous forme symbolique ou de listes.","Chinese remainder for polynomials written as lists or no.",0,0},"[Lst||Expr,Lst||Expr],[Lst||Expr,Lst||Expr]","chinrem([x+2,x^2+1],[x+1,x^2+x+1]);chinrem([[1,2],[1,0,1]],[[1,1],[1,1,1]])","ichinrem"},
{"chisquare",{"Renvoie la densité de probabilité de la loi de Chi^2 en x0 (n est le nombre de degrés de liberté).","Returns the density of probability of the Chi^2 law at x0 (n is the number of degrees of freedom).",0,0},"Intg(n),Real(x0)","chisquare(2,3.2);chisquare(4,10.5); randvector(3,chisquare,2); ranm(4,3,chisquare,2)","chisquare_cdf,chisquare_icdf,randvector,ranm"},
{"chisquare_cdf",{"Renvoie la probabilité qu'une variable aléatoire Chi^2 soit inférieure à x0 (n est le nombre de degrés de liberté).","Returns the probability that a Chi^2 random variable is lower than x0 (n is the number of degrees of freedom).",0,0},"Intg(n),Real(x0)","chisquare_cdf(2,6.1);chisquare_cdf(4,6.1)","UTPC,chisquare_icdf,chisquared"},
{"chisquare_icdf",{"Renvoie la valeur h telle que la probabilité qu'une variable aléatoire Chi^2 soit inférieure à h est p (n est le nombre de degrés de liberté et 0<=p<=1).","Returns h such as the probability that a Chi^2 random variable is lower than h is p (n is the number of degrees of freedom and 0<=p<=1).",0,0},"Intg(n),Real(p)","chisquare_icdf(2,0.95);chisquare_icdf(4,0.05)","chisquare_cdf,chisquared"},
{"chisquared",{"Renvoie la densité de probabilité de la loi de Chi^2 en x0 (n est le nombre de degrés de liberté).","Returns the density of probability of the Chi^2 law at x0 (n is the number of degrees of freedom).",0,0},"Intg(n),Real(x0)","chisquare(2,3.2);chisquare(4,10.5); randvector(3,chisquare,2); ranm(4,3,chisquare,2)","chisquare_cdf,chisquare_icdf,randvector,ranm"},
{"chisquared_cdf",{"Renvoie la probabilité qu'une variable aléatoire Chi^2 soit inférieure à x0 (n est le nombre de degrés de liberté).","Returns the probability that a Chi^2 random variable is lower than x0 (n is the number of degrees of freedom).",0,0},"Intg(n),Real(x0)","chisquare_cdf(2,6.1);chisquare_cdf(4,6.1)","UTPC,chisquare_icdf,chisquared"},
{"chisquared_icdf",{"Renvoie la valeur h telle que la probabilité qu'une variable aléatoire Chi^2 soit inférieure à h est p (n est le nombre de degrés de liberté et 0<=p<=1).","Returns h such as the probability that a Chi^2 random variable is lower than h is p (n is the number of degrees of freedom and 0<=p<=1).",0,0},"Intg(n),Real(p)","chisquare_icdf(2,0.95);chisquare_icdf(4,0.05)","chisquare_cdf,chisquared"},
{"chisquaret",{"Test du Chi^2 d'adéquation entre 2 (or n) échantillons ou entre 1 échantillon et une loi de distribution (multinomiale ou donnée par une fonction).","Chi^2 test : adequation between 2 (or n) samples or between 1 sample and a distribution law (multinomial or given by a law).",0,0},"Data,[Func],[FuncParams]","chisquaret([57,54]);chisquaret([1,1,1,1,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,0,0,0,0],[.4,.6]);chisquaret([57,30],[.6,.4]);chisquaret([17,15,12,15],[15,13,13,14]);chisquaret(ranv(1000,binomial,10,.5),binomial);chisquaret(ranv(1000,binomial,10,.5),binomial,11,.5);chisquaret(ranv(1000,normald,0,.2),normald);chisquaret([11,16,17,22,14,10],[1/6,1/6,1/6,1/6,1/6,1/6]);chisquaret([11,16,17,22,14,10],[(1/6)$6])","normalt,studentt,kolmogorovt"},
{"cholesky",{"Pour A matrice symétrique numérique, renvoie L, matrice telle que A=L*tran(L).","For a numerical symmetric matrix A, returns L matrix such that A=L*tran(L).",0,0},"Mtrx","cholesky([[3,1],[1,4]])","lu,qr,gauss"},
{"choosebox",{"Dans un programme, fait une entrée avec affichage d'une liste de choix.","In a program, do an input with a display of a choose list.",0,0},"Str(titel),LstVal,Var","choosebox(\"titre\",[\"un\",\"deux\",\"trois\"],a);choosebox(\"valeur de a\",[-1,0,1],a)","Dialog"},
{"chrem",{"Restes chinois pour des entiers ou pour des polynômes écrits sous forme ","Chinese remainders for integers or for polynomials.",0,0},"LstIntg(a,b,c....),LstIntg(p,q,r,....)","symbolique.;chrem([2,3],[7,5]);chrem([2,4,6],[3,5,7]);chrem([2,4,6,7],[3,5,7,11]);chrem([2*x+1,4*x+2,6*x-1,x+1],[3,5,7,11])","gcd,fracmod,chinrem,ichinrem"},
{"circle",{"Définit en 2-d un cercle par un diamètre (arg2=Point) ou par centre et rayon (arg2=Complex, abs(arg2)=rayon) [ou l'arc AB, A d'angle a, B d'angle b, (arg1+arg2=angle 0)] ou par son équation et en 3-d par son diamètre et un 3ème point.","Define for 2-d a circle with a diameter (arg2=Point) or with center and radius (arg2=Complex, abs(arg2)=radius) [or the arc AB, A angle a, B angle b (arg1+arg2=angle 0)] or by its equation and for 3-d with a diameter and a third point",0,0},"(Pnt or Cplx),(Pnt(arg2) or Cplx(arg2)),[Real(a)],[Real(b)],[Var(A)],[Var(B)]","circle(0,point(2*i));circle(i,i);circle(i,1);circle(0,i,pi/4,pi/2);circle(0,i,pi/4,pi/2,A,B);circle(x^2+y^2-x-y);cercle(point([-1,0,0]),point([1,0,0]),point([0,2,0]));cercle([-1,0,0],point([1,0,0]),[0,2,0])","circumcircle,incircle,excircle,center,radius,sphere,Circle"},
{"circumcircle",{"circonscrit(A,B,C)=cercle circonscrit au triangle ABC.","circumcircle(A,B,C)=circumcircle of the triangle ABC.",0,0},"(Pnt or Cplx),(Pnt or Cplx),((Pnt or Cplx)","circumcircle(0,1,1+i)","circle,incircle,excircle"},
{"classes",{"Renvoie la matrice [[classe,effectif],..,] obtenue avec class_min et class_size: voir config de geo ou argument 2 et 3 ou avec la liste des centres des classes.","Returns the matrix [[class,number],...] get with class_min and class_size: see init of geo or argument 2 and 3 or with the list of centers.",0,0},"Lst(l),[ClassMin],[ClassSize||Lst(Center)]","classes([1,1.2,1.4,1.6,1.8,2,2.5]);classes([1,1.2,1.4,1.6,1.8,2,2.5],1.2,0.5);classes([1,1.2,1.4,1.6,1.8,2,2.5],1,[1.2,1.6,2,2.4]);classes([1,1.2,1.4,1.6,1.8,2,2.5],1,[1.2,1.6,2.2]);classes([0,0.5,1,1.5,2,2.5,3,3.5,4],[0..2,2..4,4..6])","histogram,cumulated_frequencies,bar_plot,frequencies"},
{"click",{"Entrée interactive d'un nombre complexe en cliquant dans un écran géométrique.","Interactive input of a complex number with a click on a geometric screen.",0,0},"NULL","click(); A:=point(click()); a:=click()",""},
{"close",{"Ferme le fichier f.","Closes the file f.",0,0},"File(f)","fclose(f)","fprint,fopen"},
{"coeff",{"Renvoie la liste des coefficients d'un polynôme P par rapport au 2ème argument ou le coefficient de degré le 3ème argument.","Returns the list of coefficients of a polynomial with respect to the 2nd argument or the coefficient of degree the 3rd argument.",0,0},"Expr(P),[Var]","coeff(x*3+2);coeff(5*y^2-3,y);coeff(5*y^2-3,y,2)","pcoeff,fcoeff"},
{"coeffs",{"Renvoie la liste des coefficients d'un polynôme P par rapport au 2ème argument ou le coefficient de degré le 3ème argument.","Returns the list of coefficients of a polynomial with respect to the 2nd argument or the coefficient of degree the 3rd argument.",0,0},"Expr(P),[Var]","coeff(x*3+2);coeff(5*y^2-3,y);coeff(5*y^2-3,y,2)","pcoeff,fcoeff"},
{"col",{"Renvoie la colonne n ou la suite des colonnes n1..n2 de la matrice A, ou argument optionnel de count,count_eq,count_inf,count_sup.","Returns the column n or the sequence of the columns n1..n2 of the matrix A, or optional argument of count,count_eq,count_inf,count_sup.",0,0},"Mtrx(A),Intg(n)||Interval(n1..n2)","col([[1,2,3],[4,5,6],[7,8,9]],1);col([[1,2,3],[4,5,6],[7,8,9]],0..1); count_eq(3,[[3,2,3],[4,3,2],[3,2,1]],col)","row,count,count_eq,count_inf,count_sup"},
{"colDim",{"Nombre de colonnes d'une matrice.","Number of columns of a matrix.",0,0},"Mtrx","coldim([[1,2,3],[4,5,6]]);coldim([[1,2],[3,4],[5,6]])","rowdim"},
{"colNorm",{"Renvoie le maximum des sommes des valeurs absolues des éléments situés sur les colonnes de la matrice: colNorm(a_{j,k})=max_k(sum_j(|a_{j,k}|)).","Returns the max of the l1_norm fo the columns of a matrix: colNorm(a_{j,k})=max_k(sum_j(|a_{j,k}|)).",0,0},"Vect or Mtrx","colNorm([[1,2],[3,-4]]);colNorm([[1,2,3,-4],[-5,3,2,1]])","norm"},
{"colSwap",{"Renvoie la matrice obtenue en échangeant dans A la colonne n1 et la colonne n2.","Returns the matrix get from A by swapping the n1-th column and the n2-th column.",0,0},"Mtrx(A),Intg(n1),Intg(n2)","colSwap([[1,2],[3,4],[5,6]],0,1)","rowSwap"},
{"coldim",{"Nombre de colonnes d'une matrice.","Number of columns of a matrix.",0,0},"Mtrx","coldim([[1,2,3],[4,5,6]]);coldim([[1,2],[3,4],[5,6]])","rowdim"},
{"collect",{"Factorisation d'un polynôme (ou d'une liste de poly) sur les entiers.","Integer factorization of a polynomial (or of a list of poly).",0,0},"Poly or LstPoly","collect(x^2-4);collect(x^2-2);collect([x^2-2,x^2-4])","factor,factors"},
{"colnorm",{"Renvoie le maximum des sommes des valeurs absolues des éléments situés sur les colonnes de la matrice: colNorm(a_{j,k})=max_k(sum_j(|a_{j,k}|)).","Returns the max of the l1_norm fo the columns of a matrix: colNorm(a_{j,k})=max_k(sum_j(|a_{j,k}|)).",0,0},"Vect or Mtrx","colNorm([[1,2],[3,-4]]);colNorm([[1,2,3,-4],[-5,3,2,1]])","norm"},
{"color",{"Trace un objet géométrique en couleur (noir=0 rouge=1 vert=2 jaune=3 bleu=4), en trait +/- épais (line_width_n 0<n<8) et peut l'afficher selon une ligne pointillée (dash_line), rempli permet de remplir un polygone ou une courbe fermée.","Draws an geometrical object with colors black=0 red=1 green=2 yellow=3 blue=4, filled put the color in the interior of a closed curve,line_width_n (0<n<8) is for the width of the line and dash_line is for dotted line.",0,0},"[GeoObj or legende],Intg","display(A,1);display(F:=point(2+1.5*i),2);display(point(2+1.5*i),2);display(legende(1+i,\"abc\"),4);display(square(0,1),filled+red);display(carre(0,1),rempli+rouge);display(circle(0,1),filled);display(line(y=x),green+dash_line+line_width_2);display(red);square(0,1);;display(red+filled);square(0,1);","-<,legende"},
{"colspace",{"Renvoie une matrice dont les colonnes forment une base de l'espace vectoriel engendré par les colonnes de la matrice A [d est la dimension de cet espace].","Returns a matrix where the columns are a basis of the vector space generated by the columns of the matrix A [d is the dimension of this space].",0,0},"Mtrx(A), [Var(d)]","colspace([[1,2,3],[1,2,3],[1,2,4],[1,2,5]]);colspace([[1,2,3],[1,3,6],[2,5,9]],d)","rowspace"},
{"colswap",{"Renvoie la matrice obtenue en échangeant dans A la colonne n1 et la colonne n2.","Returns the matrix get from A by swapping the n1-th column and the n2-th column.",0,0},"Mtrx(A),Intg(n1),Intg(n2)","colSwap([[1,2],[3,4],[5,6]],0,1)","rowSwap"},
{"comDenom",{"Renvoie l'expression après réduction au même dénominateur : le numérateur et le dénominateur sont développés [selon les puissances de la variable var].","Returns the expression after reduction at the same denominator : the numerator and the denominator are developed [according to the powers of the variable var].",0,0},"Expr,[Var(var)]","comDenom(1/x+1/y^2+1);comDenom(1/x+1/y^2+1,y);comDenom(1/x+1/y^2+1,x)","normal"},
{"comb",{"comb(n,r)=nombre de combinaisons de r objets pris parmi n : n!/(r!(n-r)!) (Si n<0 comb(n,r)=n(n-1)..(n-r+1)/r!).","comb(n,r)=number of combinations of r objects taken among n : n!/(r!(n-r)!) (If n<0 comb(n,r)=n(n-1)..(n-r+1)/r!).",0,0},"Intg(n),Intg(r)","comb(4,2)","factorial,perm"},
{"combine",{"Rassemble des termes de Xpr selon une [classe de] fonction f passée en 2ème argument.","Combines terms in Xpr according to a [class of] function f (2nd argument).",0,0},"Expr(Xpr),Fnc(f).","combine(exp(x)*exp(y),exp);combine(sin(x)*cos(x),trig);combine(ln(x)+ln(y),ln)","lncollect,lin,tlin,tcollect"},
{"comment",{"Commentaire dans un programme.","Comment in a program.",0,0},"Expr","comment(\"my_comment\")",""},
{"common_perpendicular",{"Dessine la perpendiculaire commune aux droites D1 et D2.","Draws the common perpendicular of the lines D1 and D2.",0,0},"Line(D1),Line(D2)","common_perpendicular(line([0,0,0],[0,5,5]),line([5,0,0],[0,0,5]))","altitude,perpendicular"},
{"companion",{"Matrice compagnon d'un polynôme unitaire (an=1).","Companion matrix of a polynomial (an=1).",0,0},"Poly,Var","companion(x^2+5x-7,x);companion(-pcar([[1,0,1],[0,2,-1],[1,-1,1]],x),x)","pcar,rat_jordan"},
{"compare",{"Renvoie 1 si type(arg1)<type(arg2) ou si type(arg1)=type(arg2) et arg1<arg2, sinon renvoie 0.","Returns 1 if type(arg1)<type(arg2) or if type(arg1)=type(arg2) and arg1<arg2, else returns 0.",0,0},"Obj(arg1),Obj(arg2)","compare(1,2);compare(1.0,2);compare(\"ab\",\"cd\")","type"},
{"complex",{"DOM_COMPLEX ou complex représente le type d'un complexe ou d'une variable complexe, valeur de la commande type. C'est aussi une option de assume.","DOM_COMPLEX or complex is the type of a complex or of a complex variable, as returned by the type command. It is also an option of the assume command.",0,0},"Opt"," assume(a,complex); assume(a,DOM_COMPLEX); a:=1+i;type(a)","type,assume,DOM_INT,DOM_FLOAT"},
{"complex_mode",{"Pseudo-variable pour travailler en mode complexe (complex_mode:=1) ou en mode réel (complex_mode:=0).","Pseudo-variable to work in complex mode (complex_mode:=1) or in real mode (complex_mode:=0).",0,0},":=Intg(0 or 1)"," complex_mode:=1; complex_mode:=0","cas_setup"},
{"complex_variables",{"Pseudo-variable pour travailler avec des variables complexes (complex_variables:=1) ou avec des variables réelles (complex_variables:=0).","Pseudo-variable to work with complex variables (complex_variables:=1) or with real variables (complex_variables:=0).",0,0},":=Intg(0 or 1)"," complex_variables:=1; complex_variables:=0","cas_setup"},
{"complexroot",{"Renvoie la liste d'intervalles complexes de taille <=l où se trouvent les racines de P (par ex i[1.1,1.2]+i[2,2.4]*i pour [1.1,1.2]x[2,2.4] avec en option a=1+2*i,b=2+3*i) avec leur multiplicité.","Returns the list of complex intervals of size<=l containing roots of P (for example i[1.1,1.2]+i[2,2.4]*i pour [1.1,1.2]x[2,2.4] with optionally a=1+2*i,b=2+3*i) with multiplicities.",0,0},"Poly(P),Real(l),[Cplx(a)],[Cplx(b)]","complexroot(x^4+1,1e-50,0.7+i*0.7,0.8+i*0.8);complexroot(x^5-2*x^4+x^3+i,0.1);complexroot(x^3+8,1e-5,0,2+2*i);complexroot(x^5-2*x^4+x^3+i,0.1,1+0.5*i,1.1+0.7*i)","proot,froot,realroot,rationalroot,crationalroot"},
{"concat",{"Concatène deux listes ou deux chaînes ou deux séquences ou 2 matrices (les 2 matrices doivent avoir le même nombre de lignes et seront concaténées ligne par ligne).","Concatenates two lists or two strings or two sequences or 2 matrix.",0,0},"Lst,Lst||Seq,Seq||Str,Str||Mtrx,Mtrx","concat([1,2],[3,4,5]);concat(\"bon\",\"jour\");concat([[1,2],[3,4]],[[4,5,6],[6,7,8]])","append,cat,semi_augment,border,+"},
{"cond",{"Nombre de condition d'une matrice, utiliser COND(.,1) pour la norme l1, COND(.,2) pour l2 et COND(.,inf) pour linfini (1 est mis par défaut).","Condition number of a matrix, use COND(.,1) for l1, COND(.,2) for l2 norm and COND(.,inf) for linf (1 by default).",0,0},"Mtrx,[2]||[inf]","COND([[1,2],[1,4]]);COND([[1,2],[1,4]],1);COND([[1,2],[1,4]],2);COND([[1,2],[1,4]],inf)","SVL"},
{"cone",{"Dessine un cône de sommet A, direction v, de demi_angle au sommet t, [et de hauteur h et -h].","Draws a cone with vertex A, direction v, and with half_angle t [and with altitude h and -h].",0,0},"Pnt(A),Vect(v),Real(t),[Real(h)]","cone([0,0,0],[0,0,1],pi/6);cone([0,0,0],[0,1,1],pi/6,4)","half_cone,cylinder"},
{"confrac",{"Option de la commande convert ou convertir (ex id L:=dfc(sqrt(2),1e-10)).","Option of the convert or convertir command (ex id L:=dfc(sqrt(2),1e-10)).",0,0},"Opt"," convert(sqrt(2),confrac,'L'),L","convert"},
{"conic",{"Définit une conique par son équation de variables x,y par défaut et la trace.","Defines a conic by its equation with x,y as default variables and draws it.",0,0},"Expr,[LstVar]","conic(x^2+y^2-x*y-3);conic(x^2+2*y^2-x*y-3,x,y);conic(u^2-2*v^2-2*u*v-1,[u,v]);conic(y^2-x*y+3,[x,y])","circle,ellipse,hyperbola,parabola,reduced_conic"},
{"conj",{"Conjugué d'un nombre complexe.","Returns the conjugate of a complex number.",0,0},"Cplx","conj(1+i);conj(1+2*i);conj((1+2*i)^2);conj([[1+i,2,3],[1,3,6],[2,5,9-i]])","re,im,tran"},
{"conjugate_gradient",{"Algorithme du gradient conjugué pour résoudre A*x=y à eps près où A est une matrice symétrique définie positive, x0 solution initiale approchée optionnelle.","Conjuagte gradient algorithm to solve A*x=y approximately (precision eps) where A is a symmetric positive definite matrix, x0 an optional initial guess.",0,0},"Mtrx(A),Vect(y),[Vect(x0),Real(eps)]","conjugate_gradient([[2,1],[1,5]],[1,0]);conjugate_gradient([[4,1+i],[1-i,5]],[1,0]);conjugate_gradient([[2,1],[1,5]],[1,0],[0.55,-0.11],1e-2);conjugate_gradient([[2,1],[1,5]],[1,0],[0.55,-0.11],1e-10)","linsolve"},
{"cont",{"Continue un programme arrêté.","Continues execution of a stopped program.",0,0},"NULL","cont()","continue"},
{"contains",{"Test d'appartenance (renvoie l'indice+1 ou 0).","Tests if a set contains an expression (returns the index+1 or 0).",0,0},"(Lst(l) or Set(l)),Elem(e)","contains(%{0,1,2,3%},2);contains([0,1,2,3],4)","inString,member,est_element"},
{"content",{"Renvoie le pgcd des coefficients du polynôme P donné en argument.","Returns the gcd of the coefficients of the polynomial P given as argument.",0,0},"Poly(P),[Var]","content(2*x^2+10*x+6);content([2,10,6]);content(2*t^2+10*t+6,t)","primpart,lgcd"},
{"continue",{"Dans un programme, ne fait pas la fin de l'itération et passe à l'itération suivante: while (cond) {i1; if(cond) continue; i2;}.","In a program, don't do the end of the iteration but do the next iteration: while (cond) {i1; if(cond) continue; i2;}.",0,0},""," a:=10;while (a>0) {a:=a-3; if (a>0) {continue;} print(a);}","break,cont"},
{"contourplot",{"Dessine soit 11 lignes de niveaux équiréparties entre z=z_min,,...z=z_max de la surface z=Xpr, soit les lignes de niveaux définies par le 3ème argument.","Draws whether 11 equirepartited contour-lines z=z_min,,...z=z_max of the surface z=Xpr, whether the contour-lines defined by the 3-rd argument.",0,0},"Expr(Xpr),[LstVar],[LstVal]","plotcontour(x^2+y^2);plotcontour(x^2+y^2,[x,y]);plotcontour(x^2+2*y^2-2,[x,y],[1.0,2.0,3.0]);plotcontour(x^2-y^2,[x=-4..4,y=-4..4],seq(k,k,-11,11,3),xstep=0.1,ystep=0.1)","plotdensity,plotimplicit"},
{"convert",{"Renvoie la valeur de cmd(Xpr) si cmd est le nom d'une commande spécifiée par le 2ème argument ou réécrit Xpr selon l'option cmd (par ex option sin=commande trigsin).","Returns the value of cmd(Xpr) cmd is the name of a command specified by the 2nd argument (for ex option sin=command trigsin).",0,0},"Expr(Xpr),Cmd(cmd)","convert(cos(x)^2,sin);convert(exp(i*x),sincos);convert(1/(x^4-1),parfrac);convert(series(sin(x),x=0,6),polynom);convert([[1,[2,0]],[2,[1,1]],[1,[0,2]]],polynom);convert(%%%{1,[2,0]%%%}+%%%{2,[1,1]%%%}+%%%{1,[0,2]%%%},list);convert(cos(x)^2+1,sin);convert(3e10 _m,_au);convert(pi _rad,_deg);convert(9976/6961,confrac,'l');l;convert(sqrt(2),confrac,'dev');dev;convert(123,base,8);convert([3,7,1],base,8);convert([1,2,3],set[]); A[2,1]:=1;convert(A,array); B[0..1,1..2]:=1;B[2,2]:=2;convert(B,array)","mksa,list,polynom,table"},
{"convertir",{"Renvoie la valeur de cmd(Xpr) si cmd est le nom d'une commande spécifiée par le 2ème argument ou réécrit Xpr selon l'option cmd (par ex option sin=commande trigsin).","Returns the value of cmd(Xpr) cmd is the name of a command specified by the 2nd argument (for ex option sin=command trigsin).",0,0},"Expr(Xpr),Cmd(cmd)","convert(cos(x)^2,sin);convert(exp(i*x),sincos);convert(1/(x^4-1),parfrac);convert(series(sin(x),x=0,6),polynom);convert([[1,[2,0]],[2,[1,1]],[1,[0,2]]],polynom);convert(%%%{1,[2,0]%%%}+%%%{2,[1,1]%%%}+%%%{1,[0,2]%%%},list);convert(cos(x)^2+1,sin);convert(3e10 _m,_au);convert(pi _rad,_deg);convert(9976/6961,confrac,'l');l;convert(sqrt(2),confrac,'dev');dev;convert(123,base,8);convert([3,7,1],base,8);convert([1,2,3],set[]); A[2,1]:=1;convert(A,array); B[0..1,1..2]:=1;B[2,2]:=2;convert(B,array)","mksa,list,polynom,table"},
{"convexhull",{"Enveloppe convexe d'un ensemble de points du plan.","Convex hull of a list of 2-d points.",0,0},"Lst","convexhull(0,1,1+i,1+2i,-1-i,1-3i,-2+i);convexhull([0,1,1+i,1+2i,-1-i,1-3i,-2+i]); polygon(convexhull(0,1,1+i,1+2i,-1-i,1-3i,-2+i))","polygon"},
{"coordinates",{"Renvoie la liste (resp matrice) de l'abscisse et de l'ordonnée du point ou du vecteur (resp des points ou des vecteurs).","Returns the list (resp matrix) of the abscissa and of the ordinate of a point or a vector (resp of points or vectors).",0,0},"Pnt or Cplx or Vect","coordinates(point(1+2*i));coordinates(1+2*i);coordinates(point(i),point(1+2*i));coordinates(vecteur(point(i),point(1+2*i)));coordinates(point(1+2*i)-point(i));coordinates(-1-i);coordinates(point(1,2,3));coordinates(vecteur([1,2,3],[4,5,6]))","abscissa,ordinate,cote,vecteur"},
{"copy",{"A:=copy(B) clone la liste ou matrice B dans A.","A:=copy(B) clones the list or matrix B in A.",0,0},"Mtrx,Var"," A:=copy(B)","=<"},
{"correlation",{"Renvoie la corrélation des éléments de l'argument.","Returns the correlation of the elements of its argument.",0,0},"Lst||Mtrx,[Lst]","correlation([[1,2],[1,1],[4,7]])","covariance,covariance_correlation"},
{"cos",{"Cosinus ou Option de la commande convert ou convertir (id trigcos).","Cosine or Option of the convert or convertir command (id trigcos).",0,0},"Expr or Opt","cos(0); convert(cos(x)^4+sin(x)^2,cos)","acos,convert,trigsin"},
{"cos2sintan",{"Remplace cos(x) par sin(x)/tan(x) dans l'argument.","Replaces cos(x) by sin(x)/tan(x) in the argument.",0,0},"Expr","cos2sintan(cos(x))","tan2sincos,sin2costan,tan2sincos2,tan2cossin2"},
{"cosh",{"Cosinus hyperbolique.","Hyperbolic cosine.",0,0},"Expr","cosh(0)","acosh"},
{"cot",{"Cotangente.","Cotangent.",0,0},"Expr","cot(pi/2)","acot,tan"},
{"cote",{"Troisième coordonnée (z) d'un point 3-d.","Third coordinate (z) of a 3-d point.",0,0},"Vect","cote(point[1,2,3]);cote(point(1,2,3))","abscissa,ordinate,coordinates"},
{"count",{"Renvoie f(l[0])+f(l[1])+...+f(l[size(l)-1]) ou compte le nombre d'occurrences si l'argument est une liste d'entiers en renvoyant une matrice de 1ère col les éléments de la liste triée et 2ème col l'effectif de cet élément dans la liste.","Returns f(l[0])+f(l[1])+...+f(l[size(l)-1]) or count number of occurrences if the argument is a vector of integers.",0,0},"Fnc(f)||LstIntg,(Lst||Mtrx)(l),[Opt(row||col)]","count(id,[-2/5,-1,0,1,2,3/5]);count(1,[-2,-1,0,1,2,3]);count([1,3,1,1,2,10,3]);count((x)->x>2,[3/2,5/2,8/3]);count((x)->x==1,[-2,1,0,1,2,3]);count((x)->x>2,[[3,5/2],[4,1]]);count((x)->x>2,[[3,5/2],[4,1]],row);count((x)->x>2,[[3,5/2],[4,1]],col);count((x)->x>2 && x<4,[[3,9/2],[4,1]]);count((x)->x<2 || x>4,[[3,9/2],[4,1]])","count_eq,count_inf,count_sup"},
{"count_eq",{"Renvoie le nombre d'éléments de L égaux à a.","Returns the number of elements of L equal to a.",0,0},"Real(a),(Lst||Mtrx)(L),[Opt(row||col)]","count_eq(1,[-2,1,0,1,2,-3]);count_eq(4,[[3,4],[4,1]]);count_eq(4,[[3,4],[4,1]],row);count_eq(4,[[3,4],[4,1]],col)","count,count_inf,count_sup"},
{"count_inf",{"Renvoie le nombre d'éléments de L strictement inférieur à a.","Returns the number of elements of L strictly lower than a.",0,0},"Real(a),(Lst||Mtrx)(L),[Opt(row||col)]","count_inf(1,[-2,-1,0,1,2,3]);count_inf(4,[[3,5],[4,1]]);count_inf(4,[[3,5],[4,1]],row);count_inf(4,[[3,5],[4,1]],col)","count,count_eq,count_sup"},
{"count_sup",{"Renvoie le nombre d'éléments de L strictement supérieur à a.","Returns the number of elements of L strictly greater than a.",0,0},"Real(a),(Lst||Mtrx)(L),[Opt(row||col)]","count_sup(1,[-2,-1,0,1,2,3]);count_sup(3,[[3,5],[4,1]]);count_sup(3,[[3,5],[4,1]],row);count_sup(3,[[3,5],[4,1]],col)","count,count_inf,count_eq"},
{"courbe_parametrique",{"plotparam(a(x)+i*b(x),x=x0..x1) trace la courbe X=a(x),Y=b(x) x=x0..x1 ou plotparam([a(u,v),b(u,v),c(u,v)],[u=u0..u1,v=v0..v1]) trace la surface X=a(u,v),Y=b(u,v),Z=c(u,v) u=u0..u1 et v=v0..v1.","plotparam(a(x)+i*b(x),x=x0..x1) draws the curve X=a(x),Y=b(x) x=x0..x1 or plotparam([a(u,v),b(u,v),c(u,v)],[u=u0..u1,v=v0..v1]) draws the surface X=a(u,v),Y=b(u,v),Z=c(u,v) u=u0..u1 and v=v0..v1.",0,0},"Cplx||Lst,Var||Lst(Var)","plotparam(sin(t)+i*cos(t),t);plotparam([sin(x),cos(x)],x=0..1);plotparam([sin(x),cos(x)],x=0..1,affichage=rouge);plotparam(sin(x)+i*cos(x),x=0..1,tstep=0.01);plotparam([v*cos(u),v*sin(u),v],[u,v]);plotparam([v*cos(u),v*sin(u),v],[u=0..pi,v=0..3],ustep=0.1,vstep=0.2)","plotfunc,plotpolar"},
{"courbe_polaire",{"plotpolar(f(x),x,a,b) trace la courbe en polaire r=f(x) pour x dans [a,b].","plotpolar(f(x),x,a,b) draws the polar curve r=fx) for x in [a,b].",0,0},"Expr,Var,VarMin,VarMax","plotpolar(sin(2*x),x,0,pi);plotpolar(sin(2*x),x,0,pi,tstep=0.1)","plotparam,plotfunc,plotpolar"},
{"covariance",{"Renvoie la covariance des éléments de l'argument","Returns the covariance of the elements of its argument",0,0},"Lst||Mtrx,[Lst]","covariance([[1,2],[1,1],[4,7]])","correlation,covariance_correlation"},
{"covariance_correlation",{"Renvoie la liste formée de la covariance et de la corrélation des éléments de l'argument.","Returns the list of the covariance and the correlation of the elements of its argument.",0,0},"Lst||Mtrx,[Lst]","covariance_correlation([[1,2],[1,1],[4,7]])","covariance,correlation"},
{"cpartfrac",{"Décomposition en éléments simples dans ℂ d'une fraction rationnelle.","Performs partial fraction decomposition in ℂ of a fraction.",0,0},"RatFrac","cpartfrac((x)/(4-x^2));cpartfrac((x^2-2*x+3)/(x^2-3*x+2));cpartfrac(a/(z*(z-b)),z)","factor,normal"},
{"crationalroot",{"Renvoie la liste des racines complexes rationnelles de P sans indiquer la multiplicité.","Returns the list of complex rational roots of P without indicating the multiplicity.",0,0},"Poly(P)","crationalroot(2*x^3+(-5-7*i)*x^2+(-4+14*i)*x+8-4*i)","proot,froot,complexroot,rationalroot,realroot"},
{"crayon",{"Change la couleur du crayon (sans paramètre, renvoie la couleur courante).","Changes the color of the pencil (without parameter,returns the current color).",0,0},"Color"," crayon vert;crayon(rouge);crayon(5);crayon(gomme)","leve_crayon,baisse_crayon"},
{"cross",{"Produit vectoriel.","Wedge product.",0,0},"Vect(v1),Vect(v2)","cross([1,2],[3,4]);cross([1,2,3],[4,5,6])","dot"},
{"crossP",{"Produit vectoriel.","Wedge product.",0,0},"Vect(v1),Vect(v2)","cross([1,2],[3,4]);cross([1,2,3],[4,5,6])","dot"},
{"cross_point",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," F:=display(point(2+1.5*i),point_point); F:=display(point(2+1.5*i),rhombus_point)","display"},
{"cross_ratio",{"Renvoie le nombre complexe égal à ((c-a)/(c-b))/((d-a)/(d-b)).","Returns the complex number equal to ((c-a)/(c-b))/((d-a)/(d-b)).",0,0},"Pnt or Cplx(a),Pnt or Cplx(b),Pnt or Cplx(c),Pnt or Cplx(d)","cross_ratio(i,2+i,3/2+i,3+i);cross_ratio(0,1+i,1,i);cross_ratio(0,1,2,3)","harmonic_conjugate,is_conjugate"},
{"crossproduct",{"Produit vectoriel.","Wedge product.",0,0},"Vect(v1),Vect(v2)","cross([1,2],[3,4]);cross([1,2,3],[4,5,6])","dot"},
{"csc",{"Cosécante: csc(x)=1/sin(x).","Cosecant: csc(x)=1/sin(x).",0,0},"Expr","csc(pi/2)","sin,acsc"},
{"csolve",{"Renvoie la liste des solutions complexes d'une équation ou la matrice dont les lignes sont solutions dans ℂ d'un système d'équations polynomiales.","Returns the list of complex solutions of an equation or a matrix where the rows are ℂ-solutions of a system of polynomial equations.",0,0},"LstEq,LstVar","csolve(x^4-1,x);csolve(x^4-y^4 and x+y=2,[x,y]);csolve(x^4-y^4 and x+y=0 and x^2=2*x,[x,y]);csolve(u*v-u=v and v^2=u,[u,v])","cZeros,solve,fslove"},
{"cube",{"Dessine le cube direct de coté AB dont une face est dans le plan (A,B,C).","Draws the direct cube with vertices A,B with a face in the plan (A,B,C).",0,0},"Pnt(A),Pnt(B),Pnt(C)","cube([0,0,0],[3,0,0],[0,0,1]) ; A,B,C:=point(1,0,0),point(1,1,0),point(0,1,0);c:=cube(A,B,C);A,B,C,D,E,F,G,H:=sommets(c); ; A,B,K:=point(1,0,0),point(1,1,0),point(0,2,0);c:=cube(A,B,C);A,B,C,D,E,F,G,H:=sommets(c); ; c:=cube([0,0,0],[1,0,0],[0,1,0]);c1,c2,c4,c3,c5,c6,c7,c8:=sommets(c); ; c:=cube([0,0,0],[0,2,0],[0,0,1]);c1,c2,c4,c3,c5,c6,c7,c8:=sommets(c); ","parallelepiped,cylinder,icosahedron,dodecahedron,octahedron,tetrahedron,centered_cube"},
{"cumSum",{"Retourne la liste (ou la séquence ou la chaîne) lr formée par les sommes cumulées des éléments de la liste l : lr[k]=sum(l[j],j=0..k) (ou lr=sum(l[j],j=0..k)$(k=0..size(l)-1)).","Returns the list (or the sequence or the string) lr where the elements are the cumulative sum of the list l: lr[k]=sum(l[j],j=0..k) (or lr=sum(l[j],j=0..k)$(k=0..size(l)-1)).",0,0},"Lst(l)||Seq||Str","cumSum([0,1,2,3,4]);cumSum(1.2,3,4.5,6);cumSum(\"a\",\"b\",\"c\",\"d\")","sum"},
{"cumsum",{"Retourne la liste (ou la séquence ou la chaîne) lr formée par les sommes cumulées des éléments de la liste l : lr[k]=sum(l[j],j=0..k) (ou lr=sum(l[j],j=0..k)$(k=0..size(l)-1)).","Returns the list (or the sequence or the string) lr where the elements are the cumulative sum of the list l: lr[k]=sum(l[j],j=0..k) (or lr=sum(l[j],j=0..k)$(k=0..size(l)-1)).",0,0},"Lst(l)||Seq||Str","cumSum([0,1,2,3,4]);cumSum(1.2,3,4.5,6);cumSum(\"a\",\"b\",\"c\",\"d\")","sum"},
{"cumulated_frequencies",{"Trace le diagramme cumulatif des fréquences (lignes=[valeur,fréquences])","Draws the diagram of the cumulated frequencies (rows=[value,frequencies])",0,0},"Lst || Mtrx","cumulated_frequencies([1,2,1,1,2,1,2,4,3,3]);cumulated_frequencies([(rand(6)+1)$(k=1..100)]);cumulated_frequencies([[1,0.3],[2,0.5],[3,0.2]]);cumulated_frequencies([[1..2,0.3],[2..3,0.5],[3..4,0.2]]);cumulated_frequencies([[1..2,0.3,0.5],[2..3,0.5,0.2],[3..4,0.2,0.3]])","histogram,classes,bar_plot"},
{"curl",{"Rotationnel=[dC/dy-dB/dz,dA/dz-dC/dx,dB/dx-dA/dy].","curl([A,B,C],[x,y,z])=[dC/dy-dB/dz,dA/dz-dC/dx,dB/dx-dA/dy].",0,0},"Lst(A,B,C),Lst(x,y,z)","curl([2*x*y,x*z,y*z],[x,y,z])","derive,divergence"},
{"current_sheet",{"Contenu de l'éditeur de matrice/du tableur.","Content of the matrix editor or spreadsheet.",0,0},"[Intg||Inter],[Intg||Letter],[Letter]","current_sheet(1,2);current_sheet(A1..A5,B,G)",0},
{"curvature",{"Courbure de la courbe C au point M.","Curvature of curve C at point M.",0,0},"Curve,Point","curvature(plot(x^2),point(1,1));curvature([5*cos(t),5*sin(t)],t);curvature([t,t^2],t);curvature([t,t^2],t,1);curvature([3*exp(t/2)*cos(t),3*exp(t/2)*sin(t)],t);curvature([3*exp(t/2)*cos(t),3*exp(t/2)*sin(t)],t,7); trigcos(curvature([2*cos(t),2*sin(t),3*t],t))","osculating_circle,evolute"},
{"curve",{"Mot réservé.","Reserved word.",0,0},"Expr",0,""},
{"cyan",{"Option de la commande affichage (ou display) pour afficher en couleur.","Option of the display command to display with color.",0,0},"Opt"," F:=display(point(2+1.5*i),red); F:=display(point(2+1.5*i),point_point+green)","display"},
{"cycle2perm",{"Convertit le cycle c en une permutation.","Converts the cycle c to a permutation.",0,0},"Cycle","cycle2perm([1,3,5])","cycles2permu,permu2cycles"},
{"cycleinv",{"Renvoie le cycle inverse du cycle c.","Returns the inverse cycle of the cycle c.",0,0},"Cycle(c)","cycleinv([1,3,5])","perminv"},
{"cycles2permu",{"Convertit un produit de cycles en une permutation.","Converts a product of cycles into a permutation.",0,0},"Lst(Cycle)","cycles2permu([[1,3,5],[3,4]])","permu2cycles,cycle2perm"},
{"cyclotomic",{"N-ième polynôme cyclotomique.","N-th cyclotomic polynomial.",0,0},"Expr","cyclotomic(20)","none"},
{"cylinder",{"Dessine un cylindre d'axe (A,v), de rayon r [et de hauteur h].","Draws a cylinder with axis (A,v), with radius r [and with altitude h].",0,0},"Pnt(A),Vect(v),Real(r),[Real(h)]","cylinder([0,0,0],[0,1,0],2);cylinder([0,0,0],[0,1,0],2,-3)","half_cone,cone"},
{"dash_line",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); d:=display(line(2+i,1),cap_round_line)","display"},
{"dashdot_line",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); d:=display(line(2+i,1),cap_round_line)","display"},
{"dashdotdot_line",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); d:=display(line(2+i,1),cap_round_line)","display"},
{"dayofweek",{"dayofweek(j,m,a) renvoie le jour de la date donnée (jour,mois,année) : 0 pour dimanche, 1 pour lundi ...6 pour samedi.","dayofweek(d,m,y) returns the day of the given date (day,month,year) : 0 for sunday, 1 for monday ...6 for saturday.",0,0},"Int,Int,Int","dayofweek(21,4,2014);dayofweek(15,10,1582)",0},
{"de",{"Utilisé dans une boucle pour (pour...de ...jusque... [pas...] faire...fpour;).","Used in a loop for (for...from ...to... [step...] do...od;).",0,0},""," pour de jusque [pas] faire fpour;; S:=0;pour n de 1jusque 4 faire S:=S+n;fpour;; S:=0;for n from 1 to 4 do S:=S+n;end;; S:=0;pour n de 4 jusque 1 pas -1 faire S:=S+n;fpour ;","for,pour,jusque,to"},
{"deSolve",{"Résout une équation différentielle ou un système différentiel linéaire à coefficients constants.","Solves a differential equation or a differential linear system with constant coefficients.",0,0},"Eq,[TimeVar],FncVar","desolve(y'+x*y=0);desolve(y'+x*y=0,y);desolve(y'+x*y=0,[0,1]);desolve([y'+x*y=0,y(0)=1],y);desolve([y'=[[1,2],[2,1]]*y+[x,x+1],y(0)=[1,2]]) ;desolve(y''+y=0,y);desolve([y''+y=sin(x),y(0)=1,y'(0)=2],y);desolve([y''+y=sin(x),y(0)=1,y'(0)=2],x,y);desolve([y''+y=sin(x),y(0)=1,y'(0)=2],[x,y]);desolve(diff(y(t),t)+t*y(t)=0,t,y);desolve(diff(y(t),t)+t*y(t)=0,[t,y]);desolve((y''+y=sin(x)) and (y(0)=1) and (y'(0)=2),y);desolve([z''+2*z'+z,z(0)=1,z'(0)=0],u,z);desolve([z''+2*z'+z,z(0)=1,z'(0)=0],z(u));desolve([z'=[[1,2],[2,1]]*z+[t,t+1],z(0)=[1,2]],t,z);desolve([z'=[[1,2],[2,1]]*z+[t,t+1],z(0)=[1,2]],z(t))","integrate,diff,odesolve,plotode,plotfiefd"},
{"debug",{"Lance le débogueur.","Launch a debugging session.",0,0},"Expr","debug(pgcd(25,15))",""},
{"debut_enregistrement",{"Marque le début de l'enregistrement des commandes composant le dessin de nom donné en argument.","Marks the beginning of the recording of the commands making up the drawing whose name is the argument.",0,0},"Var(nom_du_dessin)","debut_enregistrement(maison);debut_enregistrement(arbre)","fin_enregistrement"},
{"default",{"Cas par défaut dans une instruction switch.","Default case in a switch instruction.",0,0},""," default: print(\"Default case!\"); a:=1;switch(a){case 0:{b:=1;break;} case 1:{b:=3;break;} default:{b:=0;}};","switch,case,if"},
{"degree",{"Degré du polynôme P par rapport à la variable var.","Degree of the polynomial P with respect to the second argument.",0,0},"Poly(P),Var(var)","degree(x^3+x);degree([1,0,1,0]);degree(x^3+x*y,y)","valuation,size"},
{"delcols",{"Renvoie la matrice obtenue en supprimant les colonnes n1..n2 (ou n1) de la matrice A.","Returns the matrix where the columns n1..n2 (or n1) of the matrix A are deleted.",0,0},"Mtrx(A),Interval(n1..n2)||n1","delcols([[1,2,3],[4,5,6],[7,8,9]],1..1);delcols([[1,2,3],[4,5,6],[7,8,9]],0..1);delcols([[1,2,3],[4,5,6],[7,8,9]],1)","delrows"},
{"delrows",{"Renvoie la matrice obtenue en supprimant les lignes n1..n2 (ou n1) de la matrice A.","Returns the matrix where the rows n1..n2 (or n1) of the matrix A are deleted.",0,0},"Mtrx(A),Interval(n1..n2)||n1","delrows([[1,2,3],[4,5,6],[7,8,9]],1..1);delrows([[1,2,3],[4,5,6],[7,8,9]],0..1);delrows([[1,2,3],[4,5,6],[7,8,9]],1)","delcols"},
{"deltalist",{"Renvoie la liste obtenue en faisant la différence de deux termes consécutifs.","Returns the list of the difference of two terms in succession.",0,0},"Lst","deltalist([1,4,8,9]);deltalist([1,8,4,9])",""},
{"denom",{"Renvoie le dénominateur de la fraction simplifiée.","Returns the denominator of the simplified fraction.",0,0},"Frac(a/b) or RatFrac","denom(25/15);denom((x^3-1)/(x^2-1));denom(1+(x^3-1)/x^2)","getDenom,getNum,numer,f2nd"},
{"densityplot",{"Affiche en couleur le graphe d'une expression de 2 variables dans le plan.","Shows in the plan with colors the graph of a expression of 2 variables.",0,0},"Expr,[x=xrange,y=yrange],[z],[xstep],[ystep]","plotdensity(x^2-y^2,[x=-2..2,y=-2..2],xstep=0.1,ystep=0.1);plotdensity(x^2-y^2,[x=-2..2,y=-2..2],z=-2..2,xstep=0.1,ystep=0.1)","plotfunc,plotcontour"},
{"derive",{"Dérivée par rapport au second argument.","Returns the derivative with respect to the 2nd argument.",0,0},"Expr or Fnc,[SeqVar or LstVar]","diff(x^3-x);diff(x^3-x,x$3);diff(x*y+z*y,y);diff(x*y+z*y,y,z);diff(x*y+z*y,[y,z]); f(x):=sin(2x);g:=diff(f);h:=diff(diff(f))","',function_diff,integrate,taux_accroissement"},
{"deriver",{"Dérivée par rapport au second argument.","Returns the derivative with respect to the 2nd argument.",0,0},"Expr or Fnc,[SeqVar or LstVar]","diff(x^3-x);diff(x^3-x,x$3);diff(x*y+z*y,y);diff(x*y+z*y,y,z);diff(x*y+z*y,[y,z]); f(x):=sin(2x);g:=diff(f);h:=diff(diff(f))","',function_diff,integrate,taux_accroissement"},
{"desolve",{"Résout une équation différentielle ou un système différentiel linéaire à coefficients constants.","Solves a differential equation or a differential linear system with constant coefficients.",0,0},"Eq,[TimeVar],FncVar","desolve(y'+x*y=0);desolve(y'+x*y=0,y);desolve(y'+x*y=0,[0,1]);desolve([y'+x*y=0,y(0)=1],y);desolve([y'=[[1,2],[2,1]]*y+[x,x+1],y(0)=[1,2]]) ;desolve(y''+y=0,y);desolve([y''+y=sin(x),y(0)=1,y'(0)=2],y);desolve([y''+y=sin(x),y(0)=1,y'(0)=2],x,y);desolve([y''+y=sin(x),y(0)=1,y'(0)=2],[x,y]);desolve(diff(y(t),t)+t*y(t)=0,t,y);desolve(diff(y(t),t)+t*y(t)=0,[t,y]);desolve((y''+y=sin(x)) and (y(0)=1) and (y'(0)=2),y);desolve([z''+2*z'+z,z(0)=1,z'(0)=0],u,z);desolve([z''+2*z'+z,z(0)=1,z'(0)=0],z(u));desolve([z'=[[1,2],[2,1]]*z+[t,t+1],z(0)=[1,2]],t,z);desolve([z'=[[1,2],[2,1]]*z+[t,t+1],z(0)=[1,2]],z(t))","integrate,diff,odesolve,plotode,plotfiefd"},
{"dessine_tortue",{"Fait le dessin du triangle rempli (ou non si n=1) représentant la tortue.","Draws the full (or not full if n=1) triangle representing the turtle.",0,0},"[Intg(n)]","dessine_tortue();dessine_tortue(0);dessine_tortue(1)","crayon"},
{"det",{"Déterminant d'une matrice carrée M.","Determinant of a square matrix M.",0,0},"Mtrx","det([[1,2],[3,4]]);det([[1,2,3],[1,3,6],[2,5,7]])","rref,det_minor,Det"},
{"det_minor",{"Renvoie le déterminant calculé par le calcul des mineurs.","Returns the determinant calculated with the calculus of minors.",0,0},"Mtrx(A)","det_minor([[1,2],[3,4]])","det"},
{"developper",{"Distribue totalement * et / par rapport à + et -","Full distribution of * and / over + and -",0,0},"Expr","expand((x+y)*(z+1));expand((a+b+c)/d);expand((y+x)*(z+y)*(x+z));expand((x+3)^4);expand((2*x-2*1)*(x^2-3*x+2)+(x^2-2*x+3)*(2*x-3*1))","texpand,normal,simplify,ratnormal"},
{"developper_transcendant",{"Développe des expressions transcendantes.","Expand transcendental expressions.",0,0},"Expr","texpand(sin(2*x)+exp(x+y));texpand(cos(x+y));texpand(cos(3*x))","tcollect,tlin,lin,trigexpand"},
{"dfc",{"Renvoie le développement en fraction continue de x0 d'ordre n ou de précision eps.","Returns the continue fraction development of x0 of order n or with precision eps.",0,0},"Real(x0),Int(n)||Real(eps)","dfc(sqrt(2),5);dfc(pi,4);dfc(evalf(pi),1e-09); convert(sqrt(2),confrac,'dev');dev; convert(9976/6961,confrac,'l');l","dfc2f,convert"},
{"dfc2f",{"Transforme une fraction continue en un réel.","Converts a continue fraction into a real.",0,0},"LstFrac_Cont)","dfc2f([1,1,1]);dfc2f([1,2,[2]])","dfc,convert"},
{"diag",{"Avec 1 argument renvoie soit la matrice diagonale de diagonale l soit la diagonale de A, avec 2 arguments renvoie la partie gauche large de A ou la partie droite large de A ou découpe A en 3 parties : gauche stricte, diagonale, droite stricte, et avec 3 arguments renvoie la matrice tridiagonale de diagonales l,d,u.","With 1 argument returns either the diagonal matrix with diagonal l or the diagonal of A, with 2 arguments returns the large left part of A or the large right part of A or cuts A into 3 parts : strict left,diagonal,strict right  and with 3 arguments returns the tridiagonale matrix with diagonals l,d,u.",0,0},"Lst(l)||(Mtrx(A),[left||right||lu])||Lst(l),Lst(d),Lst(u)","diag([[1,2],[3,4]]);diag([1,2,3]);diag([[1,2],[3,4]],left);diag([[1,2],[3,4]],right);diag([[1,2],[3,4]],lu);diag([1,2],[3,4,5],[6,7])","identity,lu,BlockDiagonal"},
{"diff",{"Dérivée par rapport au second argument.","Returns the derivative with respect to the 2nd argument.",0,0},"Expr or Fnc,[SeqVar or LstVar]","diff(x^3-x);diff(x^3-x,x$3);diff(x*y+z*y,y);diff(x*y+z*y,y,z);diff(x*y+z*y,[y,z]); f(x):=sin(2x);g:=diff(f);h:=diff(diff(f))","',function_diff,integrate,taux_accroissement"},
{"dim",{"Retourne la liste donnant la dimension de la matrice donnée en argument.","Returns the list which gives the dimension of the matrix specified as argument.",0,0},"Mtrx","dim([[1,2,3],[4,5,6]])","rowdim,coldim,sizes,size"},
{"display",{"Trace un objet géométrique en couleur (noir=0 rouge=1 vert=2 jaune=3 bleu=4), en trait +/- épais (line_width_n 0<n<8) et peut l'afficher selon une ligne pointillée (dash_line), rempli permet de remplir un polygone ou une courbe fermée.","Draws an geometrical object with colors black=0 red=1 green=2 yellow=3 blue=4, filled put the color in the interior of a closed curve,line_width_n (0<n<8) is for the width of the line and dash_line is for dotted line.",0,0},"[GeoObj or legende],Intg","display(A,1);display(F:=point(2+1.5*i),2);display(point(2+1.5*i),2);display(legende(1+i,\"abc\"),4);display(square(0,1),filled+red);display(carre(0,1),rempli+rouge);display(circle(0,1),filled);display(line(y=x),green+dash_line+line_width_2);display(red);square(0,1);;display(red+filled);square(0,1);","-<,legende"},
{"disque",{"Dessine un disque de rayon r (resp un secteur d'angle (0,a) ou (a,b)), tangent à la position de la tortue.","Draws a disk with radius r (resp a sector of angle (0,a) or (a,b)), tangent at the turtle position.",0,0},"Real(r),[Real(a)],[Real(b)]"," disque 30;disque(40);disque(40,90);disque(40,10,100)","rond"},
{"disque_centre",{"Dessine un disque de rayon r (resp un secteur d'angle (0,a) ou (a,b)) de centre la position de la tortue.","Draws a disk with radius r (resp a sector of angle (0,a) or (a,b)) with center the turtle position.",0,0},"Real(r),[Real(a)],[Real(b)]"," disque_centre 30;disque_centre(40);disque_centre(40,90);disque_centre(40,10,100)","rond"},
{"distance",{"Calcule la distance entre 2 points ou un point et une courbe.","Calculates the distance between 2 points or a point and a curve.",0,0},"(Pnt or Cplx),(Pnt or Cplx or Curve)","distance(point(0),point(1+i));distance(1+i,segment(1-i,i));distance(0,1+i)","distance2,distanceat,distanceatraw"},
{"distance2",{"Calcule le carré de la distance entre 2 points ou un point et une courbe.","Calculates the square of the distance between 2 points or a point and a curve.",0,0},"(Pnt or Cplx),(Pnt or Cplx or Curve)","distance2(point(0),point(1+i));distance2(1+i,segment(1-i,i));distance2(0,1+i)","distance"},
{"distanceat",{"distanceat(A,B,z0) affiche au point(z0), avec une légende, la distance entre 2 objets géométriques.","distanceat(A,B,z0) displays at point(z0), with a legend, the distance between 2 geometrical objects",0,0},"GeoObj(A),GeoObj(B),(Pnt or Cplx)"," A:=point(0);B:=point(1+i);distanceat(A,B,(1+i)/2); A:=point(0);s:=segment(1-i,i);distanceat(A,s,1)","distance,distanceatraw"},
{"distanceatraw",{"distanceatraw(A,B,point(z0)) affiche au point(z0), la distance entre 2 objets géométriques.","distanceatraw(A,B,z0) displays at the point(z0), the distance between 2 geometrical objects.",0,0},"GeoObj(A),GeoObj(B),(Pnt or Cplx(z0))"," A:=point(0);B:=point(1+i);distanceatraw(A,B,(1+i)/2); A:=point(0);s:=segment(1-i,i);distanceatraw(A,s,1)","distance,distanceat"},
{"div",{"Quotient euclidien de 2 entiers ou de 2 entiers de Gauss (opérateur infixé)","Euclidean quotient of 2 integers (infixed operator).",0,0},"Intg,Intg"," 125 div 15; 125 div 41; -7 div 3; (25+12*i) div (5+7*i)","iquo,mod"},
{"divergence",{"divergence([A,B,C],[x,y,z])=dA/dx+dB/dy+dC/dz.","divergence([A,B,C],[x,y,z])=dA/dx+dB/dy+dC/dz.",0,0},"Lst(A,B,C),Lst(x,y,z)","divergence([x^2+y,x+z+y,z^3+x^2],[x,y,z])","derive,curl"},
{"divide",{"Quotient et reste euclidien de 2 polynômes.","Euclidean quotient and remainder of 2 polynomials.",0,0},"(Vect or Poly),(Vect or Poly),[Var]","quorem([1,2,3,4],[-1,2]);quorem(x^3+2x^2+3x+4,-x+2);quorem(t^3+2t^2+3t+4,-t+2,t);quorem(t^4-1,(t+1)^2,t)","rem,quo,iquorem"},
{"divis",{"Renvoie la liste des diviseurs d'un polynôme.","Returns the list of divisors of a polynomial.",0,0},"Poly(P) or LstPoly","divis(x^2-1);divis(x^4-1);divis(t^4-1);divis([x^4-1,x^2-1]);divis([x^4-1,t^2-1]);divis(poly2symb([1,0,0,0,-1],x))","idivis,factors,poly2symb"},
{"division_point",{"Renvoie le point M d'affixe z tel que (z-a)=k*(z-b) (MA=k*MB).","Returns the point M such that (z-a)=k*(z-b) and z=affix of M (MA=k*MB).",0,0},"Pnt or Cplx(a),Pnt or Cplx(b),Cplx(k)","division_point(i,2+i,3+i);division_point(i,2+i,3)","harmonic_conjugate,is_conjugate"},
{"divisors",{"Renvoie la liste des diviseurs d'un entier a.","Returns the list of divisors of an integer.",0,0},"Intg(a) or LstIntg","idivis(36);idivis([36,49])","divis,ifactors"},
{"divpc",{"Division d'ordre n de 2 polynômes selon les puissances croissantes.","n-degree Taylor-poly for the quotient of 2 polynomials.",0,0},"Poly,Poly,Intg(n)","divpc(x^4+x+2,x^2+1,5)","series,quorem"},
{"dnewton_solver",{"Argument de fsolve indiquant la méthode pour résoudre numériquement un système d'équations.","Argument for fsolve giving the method for solving a system of numerical equations.",0,0},"Opt"," fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],dnewton_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybrid_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybrids_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybridj_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybridsj_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],newtonj_solver)","fsolve"},
{"do",{"Mot clé utilisé dans une boucle.","Key word used in a loop.",0,0},""," faire ffaire; n:=1;do n:=n+1; if (n>15) break; n:=2*n;od;; n:=1;tantque n<5 faire triangle_plein(10*n);saute(10*n);n:=n+1;ftantque; pour n de 1 jusque 4 faire triangle_plein(10*n);saute(10*n);fpour","tantque,pour,repeat"},
{"dodecahedron",{"Dessine un dodécaèdre de centre A, de sommet B où le plan ABC contient un axe de symétrie du dodécaèdre.","Draws a dodecahedron with center A, vertex B and such that the plane ABC contains a symmetry axis of the dodecahedron.",0,0},"Pnt(A),Pnt(B),Pnt(C)","dodecahedron([0,0,0],[0,2,sqrt(5)/2+3/2],[0,0,1]);dodecahedron(evalf([0,0,0],[3,2,4],[1,1,0]))","icosahedron,octahedron,cube,tetrahedron"},
{"dot",{"Produit scalaire de v1 et de v2 ou de 2 matrices aplaties selon 2 vecteurs.","Scalar product.",0,0},"Vect(v1),Vect(v2)","dot([1,2],[3,4]);dot([3,2,4],[3,2,4]);dot([[1,2],[3,4]],[[3,2],[4,5]])","*,cross,.*,hadamard"},
{"dotP",{"Produit scalaire de v1 et de v2 ou de 2 matrices aplaties selon 2 vecteurs.","Scalar product.",0,0},"Vect(v1),Vect(v2)","dot([1,2],[3,4]);dot([3,2,4],[3,2,4]);dot([[1,2],[3,4]],[[3,2],[4,5]])","*,cross,.*,hadamard"},
{"dot_paper",{"Trace dans le rectangle [xmin..xmax]*[ymin..ymax], les sommets du réseau formé des droites y=n*uy et dans le repère OxY d'angle t!=0 des droites x=n*ux.","Draws in the rectangle [xmin..xmax]*[ymin..ymax], the apex of the network built with the lines y=n*uy and in the axes OxY of angle t!=0 with the lines x=n*ux.",0,0},"Real(ux),Real(uy),Real(t)","dot_paper(1,pi/3,sqrt(3)/2);dot_paper(1,pi/3,sqrt(3)/2,x=-1..4,y=-2..2);dot_paper(0.5,3*pi/4,0.5)",0},
{"dotprod",{"Produit scalaire de v1 et de v2 ou de 2 matrices aplaties selon 2 vecteurs.","Scalar product.",0,0},"Vect(v1),Vect(v2)","dot([1,2],[3,4]);dot([3,2,4],[3,2,4]);dot([[1,2],[3,4]],[[3,2],[4,5]])","*,cross,.*,hadamard"},
{"double",{"DOM_FLOAT ou float est un entier qui représente le type d'une variable flottante, valeur de la commande type. C'est aussi une option de assume.","DOM_FLOAT or float is an integer representing the type of a floating point variable, returned by the type command. It is also an option of the assume command.",0,0},"Opt"," type(2.3); DOM_FLOAT+0; assume(a,DOM_FLOAT); assume(a,real); type(1.2)","type,assume,DOM_INT,DOM_SYMBOLIC"},
{"droit",{"Renvoie la partie droite d'une égalité, d'un intervalle, d'une liste ou d'une chaîne.","Returns the right part of an equality, of an interval, of a list or of a string.",0,0},"Equal(a=b) or Interval(a..b) or Str,Intg","right(a=b);right(x^2+1=5);right(1..5);right(\"abcdefg\",3)","left,mid,tail,head"},
{"droite_tangente",{"Trace la tangente au graphe de y=f(x) en x=a.","Draws the tangent to y=f(x) at x=a.",0,0},"Expr(f(x)),[Var],Expr(a)","droite_tangente(sin(x),pi/4);droite_tangente(sin(t),t=pi/4);droite_tangente(sin(t),t,pi/4);droite_tangente(x^2-x,1)","tangent,LineTan"},
{"dsolve",{"Résout une équation différentielle ou un système différentiel linéaire à coefficients constants.","Solves a differential equation or a differential linear system with constant coefficients.",0,0},"Eq,[TimeVar],FncVar","desolve(y'+x*y=0);desolve(y'+x*y=0,y);desolve(y'+x*y=0,[0,1]);desolve([y'+x*y=0,y(0)=1],y);desolve([y'=[[1,2],[2,1]]*y+[x,x+1],y(0)=[1,2]]) ;desolve(y''+y=0,y);desolve([y''+y=sin(x),y(0)=1,y'(0)=2],y);desolve([y''+y=sin(x),y(0)=1,y'(0)=2],x,y);desolve([y''+y=sin(x),y(0)=1,y'(0)=2],[x,y]);desolve(diff(y(t),t)+t*y(t)=0,t,y);desolve(diff(y(t),t)+t*y(t)=0,[t,y]);desolve((y''+y=sin(x)) and (y(0)=1) and (y'(0)=2),y);desolve([z''+2*z'+z,z(0)=1,z'(0)=0],u,z);desolve([z''+2*z'+z,z(0)=1,z'(0)=0],z(u));desolve([z'=[[1,2],[2,1]]*z+[t,t+1],z(0)=[1,2]],t,z);desolve([z'=[[1,2],[2,1]]*z+[t,t+1],z(0)=[1,2]],z(t))","integrate,diff,odesolve,plotode,plotfiefd"},
{"e",{"exp(1)","exp(1)",0,0},""," evalf(e)","i,pi"},
{"e2r",{"Renvoie la liste des coefficients d'un polynôme par rapport au 2ème argument ou si le 2ème argument est une liste renvoie le format interne du polynôme.","Returns the coefficients of a polynomial with respect to the 2nd argument or if the second argument is a list the internal format of the polynomial.",0,0},"Expr, LstVar or [Var]","symb2poly(x*3+2.1);symb2poly(3*x*y+2*y+1,y);symb2poly(3*x*y+2*y+1,x,y);symb2poly(3*x*y+2*y+1,[x,y]);symb2poly(-x^4+x*3*y+2+y^2*z,[x,y,z]);symb2poly(-x^4+x*3*y+2+y^2*z,[x,y,z])","poly2symb,r2e"},
{"ecart_type",{"Renvoie l'écart-type d'une liste pondérée par le deuxième argument ou la liste des écarts-types des colonnes d'une matrice.","Returns the standard deviation of the elements of its argument with an optionnal second argument as pound or the list of standard deviation of the columns of a matrix.",0,0},"Lst||Mtrx,[Lst]","stddev([1,2,3]);stddev([1,2,3],[1,2,1]);stddev([[1,2,3],[5,6,7]])","mean,variance,stddevp"},
{"ecart_type_population",{"Renvoie un estimateur non biaise de l'écart-type de la population dont est issu l'échantillon décrit par les éléments d'une liste pondérée par le deuxième argument.","Returns an unbiaised estimate of the population standard deviation of the sample (first argument) with an optionnal list of pounds as second argument.",0,0},"Lst||Mtrx,[Lst]","stddevp([1,2,3]);stddevp([1,2,3],[1,2,1]);stddevp([[1,2,3],[5,6,7]])","mean,stddev"},
{"ecris",{"Écris la chaîne s avec la fonte n (par défaut n=14) au point [x,y] (par défaut à la place de la tortue).","Write the string s with the fount n (by default n=14) at the point [x,y] (by default at the point where the turtle is).",0,0},"Str(s),[Intg(n)],[Real(x)],[Real(y)]","ecris(\"bonjour\");ecris(\"bonjour\",20);ecris(\"bonjour\",20,30,10);ecris(bonjour,20,30,10)","signe"},
{"efface",{"Efface l'écran de la tortue ou recule de n pas en effaçant.","Erases the turtle screen or the turtle takes n steps back and erases.",0,0},"NULL or Real(n)","efface()","initialise"},
{"egcd",{"Identité de Bézout pour 2 polynômes.","Extended greatest common divisor of 2 polynomials.",0,0},"(Poly or Lst),(Poly or Lst),[Var]","egcd((x-1)^2,x^3-1);egcd((X-1)^2,X^3-1,X);egcd([1,-2,1],[1,0,0,-1]);egcd([1,-2,1],[1,-1,2])","gcd,iegcd"},
{"egv",{"Calcule les vecteurs propres d'une matrice diagonalisable.","Computes the eigenvectors of a diagonalizable matrix.",0,0},"Mtrx","egv([[-2,-2,1],[-2,1,-2],[1,-2,-2]]);egv([[1,1,3],[1,3,1],[3,1,1]])","egvl,jordan"},
{"egvl",{"Renvoie la matrice de Jordan associée à A si les valeurs propres sont calculables.","Returns the Jordan matrix associated to A when the eigenvalues are calculable.",0,0},"Mtrx(A)","egvl([[4,1],[-4,0]]);egvl([[-2,-2,1],[-2,1,-2],[1,-2,-2]]);egvl([[1,1,3],[1,3,1],[3,1,1]])","egv,jordan"},
{"eigVc",{"Calcule les vecteurs propres d'une matrice diagonalisable.","Computes the eigenvectors of a diagonalizable matrix.",0,0},"Mtrx","egv([[-2,-2,1],[-2,1,-2],[1,-2,-2]]);egv([[1,1,3],[1,3,1],[3,1,1]])","egvl,jordan"},
{"eigVl",{"Renvoie la matrice de Jordan associée à A si les valeurs propres sont calculables.","Returns the Jordan matrix associated to A when the eigenvalues are calculable.",0,0},"Mtrx(A)","egvl([[4,1],[-4,0]]);egvl([[-2,-2,1],[-2,1,-2],[1,-2,-2]]);egvl([[1,1,3],[1,3,1],[3,1,1]])","egv,jordan"},
{"eigenvals",{"Renvoie la séquence des valeurs propres (calculables) d'une matrice.","Returns the sequence of the (calculable) eigenvalues of a matrix.",0,0},"Mtrx","eigenvals([[-2,-2,1],[-2,1,-2],[1,-2,-2]]);eigenvals([[1,1,3],[1,3,1],[3,1,1]]);eigenvals([[4,1],[-4,0]])","egv,jordan"},
{"eigenvalues",{"Renvoie la séquence des valeurs propres (calculables) d'une matrice.","Returns the sequence of the (calculable) eigenvalues of a matrix.",0,0},"Mtrx","eigenvals([[-2,-2,1],[-2,1,-2],[1,-2,-2]]);eigenvals([[1,1,3],[1,3,1],[3,1,1]]);eigenvals([[4,1],[-4,0]])","egv,jordan"},
{"eigenvectors",{"Calcule les vecteurs propres d'une matrice diagonalisable.","Computes the eigenvectors of a diagonalizable matrix.",0,0},"Mtrx","egv([[-2,-2,1],[-2,1,-2],[1,-2,-2]]);egv([[1,1,3],[1,3,1],[3,1,1]])","egvl,jordan"},
{"eigenvects",{"Calcule les vecteurs propres d'une matrice diagonalisable.","Computes the eigenvectors of a diagonalizable matrix.",0,0},"Mtrx","egv([[-2,-2,1],[-2,1,-2],[1,-2,-2]]);egv([[1,1,3],[1,3,1],[3,1,1]])","egvl,jordan"},
{"element",{"Désigne un point pris sur une courbe ou un réel pris dans un intervalle","Shows a point chosen on a curve or a real chosen in an interval",0,0},"(Curve or Real_interval),[Val]"," t:=element(0..1); t:=element(0..1,0.3); t:=element(0..1,0.3,0.02); P:=element(circle(i,1),t); M:=element(circle(i,1)); N:=element(circle(i,1),pi/2)","is_element"},
{"elif",{"Écriture condensée de else if qui est utilisée lorsqu'il y a plusieurs if...else if... à la suite: if condition1 then instruction1; elif condition2 then instruction2;...[else instruction;] end","Uses elif when you execute a series of tests (elif=else if). if condition1 then instruction1; elif condition2 then instruction2;...[else instruction;] end",0,0},""," if a>4 then [4,inf]; elif a>2 then [2,4]; elif a>0 then [0,2]; else [-inf,0];end;","if,else"},
{"eliminate",{"Élimine les variables vars dans une liste d'équations algébriques.","Eliminates the variables vars in a list of algebraic equations",0,0},"LstEq(eqs),LstVar(vars)","eliminate([x=v0*t,y=y0-g*t^2],t);eliminate([x+y+z+t-2,x*y*t=1,x^2+t^2=z^2],[x,z])",0},
{"ellipse",{"ellipse(F1,F2,M)=ellipse de foyers F1,F2 passant par M ou tel que MF1+MF2=2*a (geo2d) et ellipse(p(x,y)) dessine la conique si deg(p)=2.","ellipse(F1,F2,M)=ellipse focus F1,F2 through M or such as MF1+MF2=2*a (geo2d) and ellipse(p(x,y)) draws the conic if deg(p)=2.",0,0},"Pnt(F1),Pnt(F2),(Pnt(M) or Real(a)) y ellipse(p(x,y))=conic si deg(p)=2.","ellipse(-1,1,point(1+i));ellipse(-1,1,1+sqrt(5));ellipse(2x^2+3y^2-x*y-10);ellipse(point(-1,0,0),point(1,0,0),point(1,1,1));ellipse(x^2+2y^2-y-2)","hyperbola,parabola"},
{"else",{"Marque le début des instructions quand la condition d'un \"if\" est fausse; if (condition){instruction1;} else {instruction2;}","Starts false clause of an \"if\" statement: if (condition){instruction1;} else {instruction2;}",0,0},""," if (a>b) {a;} else {b;}","if"},
{"end",{"Fin de bloc.","Bloc end.",0,0},""," if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);end;; if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);fi;; f:=function(a,b) local c;c:=a+b;c+gcd(a,b);end;f(28,21);; f:=fonction(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;; fonction f(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;","begin,bloc,{}"},
{"end_for",{"Fin de bloc.","Bloc end.",0,0},""," if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);end;; if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);fi;; f:=function(a,b) local c;c:=a+b;c+gcd(a,b);end;f(28,21);; f:=fonction(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;; fonction f(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;","begin,bloc,{}"},
{"end_if",{"Fin de bloc.","Bloc end.",0,0},""," if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);end;; if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);fi;; f:=function(a,b) local c;c:=a+b;c+gcd(a,b);end;f(28,21);; f:=fonction(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;; fonction f(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;","begin,bloc,{}"},
{"end_while",{"Fin de bloc.","Bloc end.",0,0},""," if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);end;; if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);fi;; f:=function(a,b) local c;c:=a+b;c+gcd(a,b);end;f(28,21);; f:=fonction(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;; fonction f(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;","begin,bloc,{}"},
{"entry",{"Renvoie la (n+1)-ième question de l'historique des commandes si n>=0 ou, la (-n)-ième question précédente si n<0 (par défaut n=-1 pour la question précédente).","Returns the n+1-th question of the command history if n>=0 or, the (-n)th previous question if n<0 (by defaults n=-1 for the previous question).",0,0},"Intg(n)","quest();quest(2);quest(-2)","ans"},
{"envelope",{"Renvoie l'enveloppe des courbes d'équation Xpr=0, lorsque t varie.","Returns the envelope of the curves with equation Xpr=0, when t move.",0,0},"Expr(Xpr),Var(t)||[x,y,t]","envelope(y+x*tan(t)-2*sin(t),t);envelope(v+u*tan(t)-3*sin(t),[u,v,t])","tangent,locus"},
{"epaisseur",{"Option (compatibilité Maple) d'une commande graphique pour définir l'épaisseur des traits.","Option (Maple compatibility) of a graphic command to define the thickness of lines.",0,0},"Opt"," segment(0,point(1,1),thickness=5); segment(0,point(1,1),epaisseur=5)","line_width"},
{"epaisseur_ligne_1",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); display(segment(0,1+i),line_width_5); segment(1,i,affichage=epaisseur_ligne_4)","display,thickness"},
{"epaisseur_ligne_2",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); display(segment(0,1+i),line_width_5); segment(1,i,affichage=epaisseur_ligne_4)","display,thickness"},
{"epaisseur_ligne_3",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); display(segment(0,1+i),line_width_5); segment(1,i,affichage=epaisseur_ligne_4)","display,thickness"},
{"epaisseur_ligne_4",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); display(segment(0,1+i),line_width_5); segment(1,i,affichage=epaisseur_ligne_4)","display,thickness"},
{"epaisseur_ligne_5",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); display(segment(0,1+i),line_width_5); segment(1,i,affichage=epaisseur_ligne_4)","display,thickness"},
{"epaisseur_ligne_6",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); display(segment(0,1+i),line_width_5); segment(1,i,affichage=epaisseur_ligne_4)","display,thickness"},
{"epaisseur_ligne_7",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); display(segment(0,1+i),line_width_5); segment(1,i,affichage=epaisseur_ligne_4)","display,thickness"},
{"epaisseur_point_1",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," display(point(1+i),green+point_triangle+point_width_2); display(milieu(segment(0,1+i)),point_width_5); point(i,affichage=epaisseur_point_3)","display,thickness"},
{"epaisseur_point_2",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," display(point(1+i),green+point_triangle+point_width_2); display(milieu(segment(0,1+i)),point_width_5); point(i,affichage=epaisseur_point_3)","display,thickness"},
{"epaisseur_point_3",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," display(point(1+i),green+point_triangle+point_width_2); display(milieu(segment(0,1+i)),point_width_5); point(i,affichage=epaisseur_point_3)","display,thickness"},
{"epaisseur_point_4",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," display(point(1+i),green+point_triangle+point_width_2); display(milieu(segment(0,1+i)),point_width_5); point(i,affichage=epaisseur_point_3)","display,thickness"},
{"epaisseur_point_5",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," display(point(1+i),green+point_triangle+point_width_2); display(milieu(segment(0,1+i)),point_width_5); point(i,affichage=epaisseur_point_3)","display,thickness"},
{"epaisseur_point_6",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," display(point(1+i),green+point_triangle+point_width_2); display(milieu(segment(0,1+i)),point_width_5); point(i,affichage=epaisseur_point_3)","display,thickness"},
{"epaisseur_point_7",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," display(point(1+i),green+point_triangle+point_width_2); display(milieu(segment(0,1+i)),point_width_5); point(i,affichage=epaisseur_point_3)","display,thickness"},
{"epsilon",{"Renvoie la valeur de epsilon de la configuration du CAS.","Returns the value of epsilon of the CAS configuration.",0,0},"NULL","epsilon()"," epsilon2zero"},
{"epsilon2zero",{"Remplace par zéro les valeurs < epsilon","Values < epsilon are replaced by zero",0,0},"Expr","epsilon2zero(1e-13+x+5)","evalf"},
{"equal",{"Version préfixé de =","Prefixed version of =",0,0},"Expr,Expr"," 2*x=4;equal(2*x,4);equal(x^2-3x+2,0)","=,equal2diff,equal2list,left,right"},
{"equal2diff",{"Transforme l'égalité A=B ou equal(A,B) en la différence A-B","A=B or equal(A,B) is converted into the difference A-B",0,0},"Equal","equal2diff(x=2);equal2diff(equal(x,2))","left,right,equal2list,equal,="},
{"equal2list",{"Transforme l'égalité A=B ou equal(A,B) en la liste [A,B]","A=B or equal(A,B)is converted into the list [A,B]",0,0},"Equal","equal2list(x=2);equal2list(equal(x,2))","left,right,equal2diff,equal,="},
{"equation",{"equation renvoie l'équation cartésienne d'une courbe","equation returns the cartesian equation of a curve",0,0},"GeoObj, VectParam","equation(line(1-i,i),[x,y])","parameq"},
{"equilateral_triangle",{"triangle_equilateral(A,B) (resp triangle_equilateral(A,B,P)) trace le triangle équilatéral ABC direct de coté AB (resp dans le demi-plan ABP).","equilateral_triangle(A,B) (resp equilateral_triangle(A,B,P)) draws the direct equilateral triangle ABC of side AB (resp in the half-plane ABP).",0,0},"(Pnt(A) or Cplx),(Pnt(B) or Cplx),[Pnt(P)],[Var(C)]","equilateral_triangle(point(1+i),0);equilateral_triangle(0,1+i,C);equilateral_triangle(point(0,0,0),point(3,3,3),point(0,0,3));equilateral_triangle(point(0,0,0),point(3,3,3),point(0,0,3),C)","triangle"},
{"erase",{"Efface l'écran graphique","Erase the graphic screen",0,0},"NULL","erase()","ClrGraph,erase3d"},
{"erase3d",{"Efface l'écran graphique 3d","Erase the graphic screen 3d",0,0},"NULL","erase3d()","ClrGraph,erase"},
{"erf",{"Renvoie la valeur approchée de 2/sqrt(pi)*int(exp(-t^2),t,0,x0).","Returns the approximate value of 2/sqrt(pi)*int(exp(-t^2),t,0,x0).",0,0},"Real(x0)","erf(1);erf(1/(sqrt(2)))*1/2","erfc"},
{"erfc",{"Renvoie la valeur approchée de 2/sqrt(pi)*int(exp(-t^2),t,x0,+infinity).","Returns the approximate value of 2/sqrt(pi)*int(exp(-t^2),t,x0,+infinity).",0,0},"Real(x0)","erfc(1);erfc(1/(sqrt(2)))*1/2","erf"},
{"error",{"Génère l'affichage d'une erreur dans un programme","Generates the display of an error in a program",0,0},"Str","error(\"Argument should be integer\");error(\"je provoque une erreur\")","try,catch"},
{"et",{"opérateur booléen infixé (et).","infixed boolean operator (and).",0,0},"Expr, Expr"," 1==2 and 2>1; 1!=2 and 2>0","or,not,xor"},
{"euler",{"Indicatrice d'Euler (euler(n)=card({p<n,gcd(n,p)=1})).","Euler's function (euler(n)=card({p<n,gcd(n,p)=1})).",0,0},"Intg(n)","euler(11);euler(6)","gcd"},
{"euler_gamma",{"Constante d'Euler=euler_gamma=limit(sum(1/k,k,1,n)-ln(n),n,+infinity).","Euler's constant=euler_gamma=limit(sum(1/k,k,1,n)-ln(n),n,+infinity).",0,0},""," evalf(euler_gamma)",0},
{"eval",{"Évaluation de l'argument.","Evaluates its argument.",0,0},"Expr","eval(2*sin(pi))","evalf"},
{"eval_level",{"Niveau d'évaluation en mode interactif (n dit combien de fois on remplace une variable par sa valeur récursivement par défaut c'est la valeur de eval de la configuration du CAS)","Evaluation level in interactive mode",0,0},"[Intg(n)]","eval_level();eval_level(1); purge(a,b,c);eval_level(1);a:=b+1; b:=c+1;c:=3;; purge(a,b,c);eval_level(2);a:=b+1; b:=c+1;c:=3;; purge(a,b,c);eval_level(3);a:=b+1; b:=c+1;c:=3;",0},
{"evala",{"Simplifie l'expression.","Simplify the expression.",0,0},"Expr","normal(2*x+y=1);normal(2*x*2);normal((2*x+1)^2)","simplify"},
{"evalb",{"Évaluation booléenne de l'argument","Boolean evaluation of the argument",0,0},"Expr","evalb(a==2);evalb(sqrt(2)+pi>a)","evalf,eval"},
{"evalc",{"Renvoie une expression complexe simplifiée sous la forme real+i*imag.","Returns an complex expression simplified with the format real+i*imag.",0,0},"Expr","evalc(-3+4*i+exp(i));evalc(1/(x+y*i))","normal"},
{"evalf",{"Évaluation numérique du premier argument (le nombre de digits peut être donné comme second argument)","Numerical evaluation of the first argument (we can give the number of digits as second argument)",0,0},"Expr,[Int]","evalf(2/3);evalf(2/3,2);evalf(2*sin(1));evalf(2*sin(1),40);evalf(sqrt(2)+pi);evalf(sqrt(2)+pi,30)","evalb,eval"},
{"evalm",{"Évaluation de l'argument.","Evaluates its argument.",0,0},"Expr","eval(2*sin(pi))","evalf"},
{"even",{"Retourne 1 si l'entier est pair, sinon retourne 0.","Returns 1 if the integer is even, else returns 0.",0,0},"Intg(n)","even(6);even(1251)","odd"},
{"evolute",{"Courbe développée d'une courbe C.","Evolute of a curve C.",0,0},"Curve","evolute(plot(x^2));evolute([t,t^2],t);evolute([3*exp(t/2)*cos(t),3*exp(t/2)*sin(t)],t)","curvature,osculating_circle"},
{"exact",{"Convertit l'expression en une expression rationnelle ou réelle.","Converts the expression to a rational or real expression.",0,0},"Expr","-2;float2rational(1.5);float2rational(1.4141);float2rational(0.156381102937)",""},
{"exbisector",{"Trace la bissectrice extérieure de l'angle (AB,AC) donné par 3 points A,B,C.","Draws the exterior bisector of the angle (AB,AC) given by 3 points A,B,C.",0,0},"(Pnt(A) or Cplx),(Pnt(B) or Cplx),(Pnt(C) or Cplx)","exbisector(0,1,i)","angle,bisector"},
{"excircle",{"exinscrit(A,B,C) trace le cercle exinscrit au triangle ABC relatif à A.","excircle(A,B,C) draws the A-excircle of the ABC triangle.",0,0},"(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)","excircle(0,1,1+i)","incircle,circumcircle"},
{"execute",{"Instruction transformant une chaîne en une commande ou en un nombre.","Instruction transforming a string into a command or into a number.",0,0},"Str","expr(\"ifactor(54)\");expr(\"123\");expr(\"0123\")","string"},
{"exp",{"Exponentielle ou Option de la commande convert ou convertir (id trig2exp).","Exponential or Option of the convert or convertir command (id trig2exp).",0,0},"Expr or Opt","exp(0); convert(cos(x),exp)","ln,convert,trig2exp"},
{"exp2list",{"Renvoie la liste formée par les membres de droite de (var=expr0 or var=expr1), utile après solve en mode TI.","Returns the list made with the right member of (var=expr0 or var=expr1), to be used after solve in TI mode.",0,0},"Expr","exp2list((x=2) or (x=0));exp2list(solve(x^2-1))","list2exp"},
{"exp2pow",{"Transforme exp(n*ln(x)) en x^n.","Transforms exp(n*ln(x)) in x^n.",0,0},"Expr","exp2pow(exp(3*ln(x)));exp2pow(exp(x*ln(x)))","pow2exp"},
{"exp2trig",{"Transforme les exponentielles complexes en sinus et cosinus.","Transforms the complex exponential into sine and cosine.",0,0},"Expr","exp2trig(exp(i*x));exp2trig(exp(-i*x))","trig2exp,atrig2ln"},
{"expand",{"Distribue totalement * et / par rapport à + et -","Full distribution of * and / over + and -",0,0},"Expr","expand((x+y)*(z+1));expand((a+b+c)/d);expand((y+x)*(z+y)*(x+z));expand((x+3)^4);expand((2*x-2*1)*(x^2-3*x+2)+(x^2-2*x+3)*(2*x-3*1))","texpand,normal,simplify,ratnormal"},
{"expexpand",{"Développe les exponentielles.","Expands exponentials.",0,0},"Expr","expexpand(exp(3*x))","texpand,lnexpand,trigexpand"},
{"expln",{"Option de la commande convert ou convertir (id trig2exp).","Option of the convert or convertir command (id trig2exp).",0,0},"Opt"," convert(cos(x),expln)","exp,ln,convert,trig2exp"},
{"exponential",{"Renvoie la densité de probabilité en x de la loi exponentielle de paramètre lambda.","Returns the density of probability at x of the exponential law of parameter lambda.",0,0},"Real(lambda),Real(x)","exponential(2.1,3.5);exponential(2.1,0.5); randvector(3,exponential,1.2); ranm(4,3,exponential,1.2)","exponential_cdf,exponential_icdf,randvector,ranm"},
{"exponential_cdf",{"Renvoie la probabilité qu'une variable aléatoire exponentielle de paramètre lambda soit inférieure à x0 (ou entre x0 et y0). ","Returns the probability that a exponential random variable of parameter lambda is lower than x0 (or between x0 and y0).",0,0},"Real(lambda),Real(x0),[Real(y0)]","exponential_cdf(4.2,2.1);exponential_cdf(4.2,2.1,3.2)","exponentiald,exponential_icdf"},
{"exponential_icdf",{"Renvoie la valeur h telle que, la probabilité qu'une variable aléatoire exponentielle de paramètre lambda soit inférieure à h soit p (0<=p<=1).","Returns h such that the probability that a exponential random variable of parameter lambda is lower than h is p (0<=p<=1).",0,0},"Real(lambda),Real(x0),Real(p)","exponential_icdf(4.2,0.95);exponential_icdf(4.2,0.6)","exponential_cdf,exponentiald"},
{"exponential_regression",{"Renvoie les coefficients (a,b) de y=b*a^x : c'est l'exponentielle qui approche le mieux les points ayant pour coordonnées les lignes de A (ou les 2 listes).","Returns the coefficients (a,b) of y=b*a^x : it is the best exponential which approx the points where the coordinates are the rows of A (or the 2 lists).",0,0},"Lst||Mtrx(A),[Lst]","exponential_regression([[1.0,2.0],[0.0,1.0],[4.0,7.0]]);exponential_regression([1.0,0.0,4.0],[2.0,1.0,7.0])","logarithmic_regression"},
{"exponential_regression_plot",{"Renvoie le graphe de y=b*a^x : c'est l'exponentielle qui approche le mieux les points ayant pour coordonnées les lignes de A (ou les 2 listes).","Returns the plot of y=b*a^x : it is the best exponential which approx the points where the coordinates are the rows of A (or the 2 lists).",0,0},"Lst||Mtrx(A),[Lst]","exponential_regression_plot([[1.0,2.0],[0.0,1.0],[4.0,7.0]]);exponential_regression_plot([1.0,0.0,4.0],[2.0,1.0,7.0])","logarithmic_regression_plot"},
{"exponentiald",{"Renvoie la densité de probabilité en x de la loi exponentielle de paramètre lambda.","Returns the density of probability at x of the exponential law of parameter lambda.",0,0},"Real(lambda),Real(x)","exponential(2.1,3.5);exponential(2.1,0.5); randvector(3,exponential,1.2); ranm(4,3,exponential,1.2)","exponential_cdf,exponential_icdf,randvector,ranm"},
{"exponentiald_cdf",{"Renvoie la probabilité qu'une variable aléatoire exponentielle de paramètre lambda soit inférieure à x0 (ou entre x0 et y0). ","Returns the probability that a exponential random variable of parameter lambda is lower than x0 (or between x0 and y0).",0,0},"Real(lambda),Real(x0),[Real(y0)]","exponential_cdf(4.2,2.1);exponential_cdf(4.2,2.1,3.2)","exponentiald,exponential_icdf"},
{"exponentiald_icdf",{"Renvoie la valeur h telle que, la probabilité qu'une variable aléatoire exponentielle de paramètre lambda soit inférieure à h soit p (0<=p<=1).","Returns h such that the probability that a exponential random variable of parameter lambda is lower than h is p (0<=p<=1).",0,0},"Real(lambda),Real(x0),Real(p)","exponential_icdf(4.2,0.95);exponential_icdf(4.2,0.6)","exponential_cdf,exponentiald"},
{"expr",{"Instruction transformant une chaîne en une commande ou en un nombre.","Instruction transforming a string into a command or into a number.",0,0},"Str","expr(\"ifactor(54)\");expr(\"123\");expr(\"0123\")","string"},
{"expression",{"DOM_SYMBOLIC ou symbol représente le type d'une variable symbolique, valeur de la commande type. C'est aussi une option de assume.","DOM_SYMBOLIC or symbol is the type of a symbolic variable, as returned by the type command. It is also an option of the assume command.",0,0},"Opt"," assume(a,symbol); assume(a,DOM_SYMBOLIC); a:=sqrt(2);type(a); type(2x+1)","type,assume,DOM_INT,DOM_FLOAT"},
{"extract_measure",{"extract_measure donne comme réponse la valeur calculée par l'argument.","extract_measure gives as answer the value calculated by the argument.",0,0},"Var","extract_measure(distanceatraw(0,1+i,(1+i)/2));extract_measure(angleatraw(0,1,1+i,1)); A:=point(0);B:=point(1+i);a:=distanceatraw(A,B,(1+i)/2);extract_measure(a)","angleatraw,distanceatraw,angleat,distanceat,slopeatraw,areaatraw,perimeteratraw,slopeat,areaat,perimeterat"},
{"extrema",{"Recherche des extremas d'une expression","Search extrema of an expression",0,0},"Expr,Var,a,b","extrema(-2*cos(x)-cos(x)^2,x);extrema((x^3-1)^4/(2x^3+1)^4,x=0..inf);extrema(x/2-2*sin(x/2),x=-12..12);extrema(x-ln(abs(x)),x); assume(a>=0);extrema(x^2+a*x,x);extrema(x^7+3x^6+3x^5+x^4+2x^2-x,x);extrema((x^2+x+1)/(x^4+1),x);extrema(x^2+exp(-x),x);extrema(exp(-x)*ln(x),x);extrema(tan(x)*(x^3-5x^2+1),x=-0.5);extrema(tan(x)*(x^3-5x^2+1),x=0.5);extrema(exp(x^2-2x)*ln(x)*ln(1-x),x=0.5);extrema(ln(2+x-sin(x)^2),x=0..2*pi);extrema(x^3-2x*y+3y^4,[x,y]);extrema((2x^2-y)*(y-x^2),[x,y])  //Peano surface;extrema(5x^2+3y^2+x*z^2-z*y^2,[x,y,z]);extrema(3*atan(x)-2*ln(x^2+y^2+1),[x,y]);extrema(x*y,x+y=1,[x,y]);extrema(sqrt(x*y),x+y=2,[x,y]);extrema(x*y,x^3+y^3=16,[x,y]);extrema(x^2+y^2,x*y=1,[x=0..inf,y=0..inf]);extrema(ln(x*y^2),2x^2+3y^2=8,[x,y]);extrema(y^2+4y+2x-x^2,x+2y=2,[x,y]); assume(a>0);extrema(x/a^2+a*y^2,x+y=a,[x,y]);extrema(6x+3y+2z,4x^2+2y^2+z^2=70,[x,y,z]);extrema(x*y*z,x+y+z=1,[x,y,z]);extrema(x*y^2*z^2,x+y+z=5,[x,y,z]);extrema(4y-2z,[2x-y-z=2,x^2+y^2=1],[x,y,z]);extrema((x-3)^2+(y-1)^2+(z-1)^2,x^2+y^2+z^2=4,[x,y,z]);extrema(x+3y-z,2x^2+y^2=z,[x,y,z]);extrema(2x*y+2y*z+x*z,x*y*z=4,[x,y,z]);extrema(x+y+z,[x^2+y^2=1,2x+z=1],[x,y,z]); assume(a>0);extrema(x+y+z,[y^2-x^2=a,x+2z=1],[x,y,z]);extrema((x-u)^2+(y-v)^2,[x^2/4+y^2/9=1,(u-3)^2+(v+5)^2=1],[u,v,x,y]);extrema(x2^6+x1^3+4x1+4x2,x1^5+x2^4+x1+x2=0,[x1,x2]);extrema(x*y,-2x^3+15x^2*y+11y^3-24y=0,[x,y]);extrema(x2^4-x1^4-x2^8+x1^10,[x1,x2],order_size=1);extrema(x2^4-x1^4-x2^8+x1^10,[x1,x2]);extrema(x2^6+x1^3+4x1+4x2,x1^5+x2^4+x1+x2=0,[x1,x2]);extrema(x2^6+x1^3+2x1^2-x2^2+4x1+4x2,x1^5+x2^4+x1+x2=0,[x1,x2]);extrema(3x^2-2x*y+y^2-8y,[x,y]);extrema(x^3+3x*y^2-15x-12y,[x,y]);extrema(4x*y-x^4-y^4,[x,y]);extrema(x*sin(y),[x,y]);extrema(x^4+y^4,[x,y]);extrema(x^3*y-x*y^3,[x,y])  ;extrema(x^2+y^2+z^2,x^4+y^4+z^4=1,[x,y,z]);extrema(3x+3y+8z,[x^2+z^2=1,y^2+z^2=1],[x,y,z]);extrema(2x^2+y^2,x^4-x^2+y^2=5,[x,y]);extrema((3x^4-4x^3-12x^2+18)/(12*(1+4y^2)),[x,y]);extrema(x-y+z,[x^2+y^2+z^2=1,x+y+2z=1],[x,y,z]);extrema(ln(x)+2*ln(y)+3*ln(z)+4*ln(u)+5*ln(v),x+y+z+u+v=1,[x,y,z,u,v]);extrema(x*y*z,-2x^3+15x^2*y+11y^3-24y=0,[x,y,z]);extrema(x+y-exp(x)-exp(y)-exp(x+y),[x,y]);extrema(x^2*sin(y)-4*x,[x,y])    ;extrema((1+y*sinh(x))/(1+y^2+tanh(x)^2),[x,y]);extrema((1+y*sinh(x))/(1+y^2+tanh(x)^2),y=x^2,[x,y])",0},
{"ezgcd",{"PGCD de 2 polynômes ayant au moins 2 variables, avec l'algorithme ezgcd.","GCD of 2 polynomials with at least 2 variables, with the ezgcd algorithm.",0,0},"Poly,Poly","ezgcd(x^2-2*xy+y^2-1,x-y);ezgcd((x+1)^4-y^4,(x+1-y)^2);ezgcd((x+y-1)*(x+y+1),(x+y+1)^2)","gcd,modgcd,heugcd,psrgcd"},
{"f2nd",{"Renvoie la liste formée par le numérateur et le dénominateur de la fraction simplifiée.","Returns the list built with the numerator and the denominator of the simplified fraction .",0,0},"Frac or RatFrac","f2nd(42/12);f2nd((x^2+2*x+1)/(x^2-1))","simp2,numer,denom,getNum,getDenom"},
{"fMax",{"Retourne l'abscisse du maximum de l'expression.","Returns the abscissa of the maximum of the expression.",0,0},"Expr,[Var]","fMax(-x^2+2*x+1,x);fMax(-x^2+2*x+1,x=1..2)","fMin"},
{"fMin",{"Retourne l'abscisse du minimum de l'expression.","Returns the abscissa of the minimum of the expression.",0,0},"Expr,[Var]","fMin(x^2-2*x+1,x);fMin(x^2-2*x+1,x=1..2);fMin((x-3)^2+(y-5)^2+1,[],[x,y],[1,1]);fMin((x-3)^2+(y-5)^2+1,[x+y^2=1],[x,y],[1,1])","fMax"},
{"fPart",{"Renvoie la partie fractionnaire.","Returns the fractional part.",0,0},"Real||LstReal","fPart(1/2);fPart(1.2);fPart([3.4,sqrt(2)])","floor,iPart,trunc"},
{"faces",{"Renvoie la liste des faces (1 face=matrice(n,3) dont les n lignes sont les n sommets de la face) du polyèdre P.","Returns the list of the faces (1 face=matrix(n,3) where the n rows are the n vertices of the face) of the polyhedron P.",0,0},"Polygon or Polyedr(P)","faces(polyhedron([0,0,0],[0,5,0],[0,0,5],[1,2,6]));faces(polyhedron([0,0,0],[0,5,0],[0,0,5],[1,2,6]))[2]","polyhedron"},
{"facteurs_premiers",{"Renvoie la liste des facteurs premiers d'un entier avec leur multiplicité.","Returns the list of prime factors of an integer (each factor is followed by its multiplicity).",0,0},"Intg(a) or LstIntg","ifactors(36);ifactors([36,52])","ifactor,factors"},
{"factor",{"Factorisation d'un polynôme.","Factorizes a polynomial.",0,0},"Expr","factor(x^4-1);factor(x^4-4,sqrt(2));factor(x^4+12*x^3+54*x^2+108*x+81)","ifactor,partfrac,normal"},
{"factor_xn",{"Mise en facteur dans P de x^n (n=degré du polynôme P).","Factorizes x^n in P (n=degree of polynomial P).",0,0},"Poly(P)","factor_xn(x^4-1);factor_xn(x^4+12*x^3+54*x^2+108*x+81)","ifactor,partfrac,normal"},
{"factorial",{"factorial(n)=n! et factorial(a)=a!= valeur de la fonction Gamma en a+1.","factorial(n)=n!. For non-integers,factorial(a)=a! = G(a + 1). This calculates the Gamma function.",0,0},"Intg(n)|| Real(a)","factorial(4);factorial(1.2)","comb,perm"},
{"factoriser",{"Factorisation d'un polynôme.","Factorizes a polynomial.",0,0},"Expr","factor(x^4-1);factor(x^4-4,sqrt(2));factor(x^4+12*x^3+54*x^2+108*x+81)","ifactor,partfrac,normal"},
{"factoriser_entier",{"Factorisation d'un entier en facteurs premiers.","Factorization of an integer into prime factors.",0,0},"Intg(a)","ifactor(50);ifactor(123456789)","factor"},
{"factoriser_sur_C",{"Factorisation de l'expression dans ℂ (sur les entiers de Gauss si on a plus de 2 variables).","Factorization of the expression in ℂ (on the Gauss integers if there are more than 2 variables).",0,0},"Expr","cFactor(x^2*y+y);cFactor(x^2*y^2+y^2+4*x^2+4);cFactor(x^2*y^2+y^2+2*x^2+2)","factor"},
{"factors",{"Renvoie la liste des facteurs premiers d'un polynôme avec leur multiplicité.","Returns the list of prime factors of a polynomial (each factor is followed by its multiplicity).",0,0},"Poly or LstPoly","factors(x^4-1);factors([x^2,x^2-1])","factor,ifactors"},
{"fadeev",{"Option de la commande pcar ou charpoly pour spécifier l'algorithme utilisé.","Option of the pcar or charpoly command to specify the algorithm.",0,0},"Opt"," pcar([[4,1,-2],[1,2,-1],[2,1,0]],fadeev)","pcar"},
{"faire",{"Mot clé utilisé dans une boucle.","Key word used in a loop.",0,0},""," faire ffaire; n:=1;do n:=n+1; if (n>15) break; n:=2*n;od;; n:=1;tantque n<5 faire triangle_plein(10*n);saute(10*n);n:=n+1;ftantque; pour n de 1 jusque 4 faire triangle_plein(10*n);saute(10*n);fpour","tantque,pour,repeat"},
{"false",{"booléen valant faux ou 0.","boolean equal to false or 0.",0,0},""," a:=false","true"},
{"falsepos_solver",{"Argument de fsolve indiquant la méthode pour résoudre numériquement une équation.","Argument for fsolve giving the method for solving an numerical equation.",0,0},"Opt"," fsolve(cos(x)=x,x,0..1,bisection_solver); fsolve(cos(x)=x,x,0..1,brent_solver); fsolve(cos(x)=x,x,0..1,falsepos_solver); fsolve(cos(x)=x,x,0,newton_solver); fsolve(cos(x)=x,x,0,secant_solver); fsolve(cos(x)=x,x,0,steffenson_solver)","fsolve"},
{"fclose",{"Ferme le fichier f.","Closes the file f.",0,0},"File(f)","fclose(f)","fprint,fopen"},
{"fcoeff",{"Renvoie le polynôme décrit par la liste (racine ou pôle, multiplicité).","Returns the polynomial describe by the list (root or pole, order).",0,0},"Lst(root||pole,order)","fcoeff([1,2,0,1,3,-1])","pcoeff,froot,proot"},
{"fdistrib",{"Distribue totalement * et / par rapport à + et -","Full distribution of * and / over + and -",0,0},"Expr","expand((x+y)*(z+1));expand((a+b+c)/d);expand((y+x)*(z+y)*(x+z));expand((x+3)^4);expand((2*x-2*1)*(x^2-3*x+2)+(x^2-2*x+3)*(2*x-3*1))","texpand,normal,simplify,ratnormal"},
{"feuille",{"Renvoie les arguments d'un opérateur sous forme d'une suite.","Returns the arguments of an operator as a sequence.",0,0},"Op or Fnc","feuille(quote(gcd(45,126)));feuille('gcd(45,126)');feuille('1+2')[1];feuille([1,2,3]);feuille(set[1,2,3])","sommet,quote,makesuite"},
{"ffaire",{"Fin de bloc.","Bloc end.",0,0},""," if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);end;; if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);fi;; f:=function(a,b) local c;c:=a+b;c+gcd(a,b);end;f(28,21);; f:=fonction(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;; fonction f(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;","begin,bloc,{}"},
{"ffonction",{"Fin de bloc.","Bloc end.",0,0},""," if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);end;; if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);fi;; f:=function(a,b) local c;c:=a+b;c+gcd(a,b);end;f(28,21);; f:=fonction(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;; fonction f(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;","begin,bloc,{}"},
{"fft",{"Fast Fourier Transform dans ℝ, ou dans le corps fini ℤ/pℤ, avec a comme racine n-ième primitive de l'unité (n=size(L)).","Fast Fourier Transform in ℝ or in the field ℤ/pℤ, with a as primitive n-th root of 1 (n=size(L)).",0,0},"Vect or (Vect(L),Intg(a),Intg(p)","fft([1,2,3,4,0,0,0,0]);fft(ranm(128),22798,35969)","ifft"},
{"fi",{"Fin de bloc.","Bloc end.",0,0},""," if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);end;; if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);fi;; f:=function(a,b) local c;c:=a+b;c+gcd(a,b);end;f(28,21);; f:=fonction(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;; fonction f(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;","begin,bloc,{}"},
{"fieldplot",{"fieldplot(f(t,y),[t,y]) trace le champ des tangentes (normalisé ou non selon l'option) de l'equa diff y'=f(t,y).","fieldplot(f(t,y),[t,y]) draws the plotfield of the diff equation y'=f(t,y).",0,0},"Expr,VectVar,[Opt]","fieldplot(sin(t*y),[t=-5..5,y=-3..3],xstep=0.5,ystep=0.5);fieldplot(-t*y,[t,y]);fieldplot(-t*y,[t,y],normalize);fieldplot(-t*y,[t,y],normalize,xstep=0.5,ystep=0.5);fieldplot(-t*y,[t=-6.868..6.868,y=-6.868..6.868],normalize)","interactive_plotode,odeplot,odesolve,desolve"},
{"filled",{"Option de la commande affichage (ou display) pour faire des figures pleines.","Option of the display command to fill figures.",0,0},"Opt"," F:=display(square(0,2+i),filled); C:=display(square(2,2+i),red+filled)","display"},
{"fin_enregistrement",{"Marque la fin de l'enregistrement des commandes et sauve ces commandes dans le fichier de nom donné en argument.","Marks the end of the recording of the commands and save these commands in the file whose name is the argument.",0,0},"Str(nom_de_fichier)","fin_enregistrement(\"maison.tor\");fin_enregistrement(\"arbre.tor\")","debut_enregistrement"},
{"find",{"Liste des positions d'un objet dans une liste","List of positions of an object in a list",0,0},"Expr,Vect","find(1,[3,x,1,2,1,3])",0},
{"findhelp",{"Renvoie l'aide de la commande (si ? est infixé voir when).","Returns the help about the command (if ? is infixed see when) .",0,0},"Cmd","findhelp(ifactor)","ifte,when"},
{"fisher",{"Renvoie la densité de probabilité de la loi de Fisher-Snedecor (n et m sont les nombres de degrés de liberté).","Returns the density of probability of the Fisher-Snedecor law (n and m are the numbers of degrees of freedom).",0,0},"Intg(n),Intg(m),Real(x0)","fisher(4,10,2.1);fisher(4,4,2.1); randvector(5,fisher,4,6); ranm(2,3,fisher,4,6)","fisher_cdf,fisher_icdf,randvector,ranm"},
{"fisher_cdf",{"Renvoie la probabilité qu'une variable aléatoire Fisher-Snedecor soit inférieure à x0 (n et m sont les nombres de degrés de liberté).","Returns the probability that a Fisher-Snedecor random variable is lower than x0 (n and m are the numbers of degrees of freedom).",0,0},"Intg(n),Intg(m),Real(x0)","fisher_cdf(4,4,2.1);fisher_cdf(4,10,3.5)","UTPF,fisher_icdf,fisherd"},
{"fisher_icdf",{"Renvoie la valeur h telle que, la probabilité qu'une variable aléatoire Fisher-Snedecor soit inférieure à h soit p (n et m sont les nombres de degrés de liberté et 0<=p<=1).","Returns h such as the probability that a Fisher-Snedecor random variable is lower than h is p (n and m are the numbers of degrees of freedom and 0<=p<=1).",0,0},"Intg(n),Intg(m),Real(p)","fisher_icdf(4,10,0.95);fisher_icdf(4,10,0.05)","fisher_cdf,fisherd"},
{"fisherd",{"Renvoie la densité de probabilité de la loi de Fisher-Snedecor (n et m sont les nombres de degrés de liberté).","Returns the density of probability of the Fisher-Snedecor law (n and m are the numbers of degrees of freedom).",0,0},"Intg(n),Intg(m),Real(x0)","fisher(4,10,2.1);fisher(4,4,2.1); randvector(5,fisher,4,6); ranm(2,3,fisher,4,6)","fisher_cdf,fisher_icdf,randvector,ranm"},
{"fisherd_cdf",{"Renvoie la probabilité qu'une variable aléatoire Fisher-Snedecor soit inférieure à x0 (n et m sont les nombres de degrés de liberté).","Returns the probability that a Fisher-Snedecor random variable is lower than x0 (n and m are the numbers of degrees of freedom).",0,0},"Intg(n),Intg(m),Real(x0)","fisher_cdf(4,4,2.1);fisher_cdf(4,10,3.5)","UTPF,fisher_icdf,fisherd"},
{"fisherd_icdf",{"Renvoie la valeur h telle que, la probabilité qu'une variable aléatoire Fisher-Snedecor soit inférieure à h soit p (n et m sont les nombres de degrés de liberté et 0<=p<=1).","Returns h such as the probability that a Fisher-Snedecor random variable is lower than h is p (n and m are the numbers of degrees of freedom and 0<=p<=1).",0,0},"Intg(n),Intg(m),Real(p)","fisher_icdf(4,10,0.95);fisher_icdf(4,10,0.05)","fisher_cdf,fisherd"},
{"flatten",{"Aplatit récursivement une liste contenant des listes.","Recursively flatten a list containing lists.",0,0},"Lst","flatten([[1,[2,3],4],[5,6]])","mat2list"},
{"float",{"DOM_FLOAT ou float est un entier qui représente le type d'une variable flottante, valeur de la commande type. C'est aussi une option de assume.","DOM_FLOAT or float is an integer representing the type of a floating point variable, returned by the type command. It is also an option of the assume command.",0,0},"Opt"," type(2.3); DOM_FLOAT+0; assume(a,DOM_FLOAT); assume(a,real); type(1.2)","type,assume,DOM_INT,DOM_SYMBOLIC"},
{"float2rational",{"Convertit l'expression en une expression rationnelle ou réelle.","Converts the expression to a rational or real expression.",0,0},"Expr","-2;float2rational(1.5);float2rational(1.4141);float2rational(0.156381102937)",""},
{"floor",{"Renvoie le plus grand entier <= à l'argument (partie entière)","Returns the greatest integer <= to the argument",0,0},"Real or Cplx","floor(-2.5);floor(2.5-4.2*i)","round,ceil,iPart,trunc"},
{"fonction	",{"Instruction qui définit une fonction utilisateur.","Instruction which define an user function.",0,0},"Fnc(f)","fonction f(a,b) local c;c=a+b;c+gcd(a,b);ffonction;; f:=function(a,b) local c;c=a+b;c+gcd(a,b);end;; f:=fonction(a,b) local c;c=a+b;c+gcd(a,b);ffonction;","->,:=,end,ffonction"},
{"fonction_derivee",{"Renvoie la fonction dérivée de la fonction f.","Returns the derivative function of the function f.",0,0},"Fnc(f)","function_diff(sin+id);function_diff(sq@sin+id)","diff,',@"},
{"fopen",{"Ouvre un fichier de nom s, renvoie une variable de type fichier.","Opens a file named s, returns a variable of type file.",0,0},"Str(s)"," f:=fopen(\"glouglou\")","fprint,fclose"},
{"for",{"Boucle: for (init;do_if_true;increment) {action;}","Loop: for (init;do_if_true;increment) {action;}",0,0},"","  fact10():={local j,n:=1; for(j:=0;j<=10;j++) n:=n*j;};  g():={local j,s:=0; for(j:=1;j<=10;j:=j+2) s:=s*j;};  s:=0;for j from 1 to 10 by 2 do s:=s+j end_for;","from,to,pour,by,{}"},
{"format",{"Transforme un nombre réel en une chaîne du format indiqué (f=flottant,s=scientifique,e=ingénieur).","Transforms the real into a string with the indicated format (f=float,s=scientific,e=engineering).",0,0},"Real,Str(\"f4\"||\"s5\"||\"e6\")","format(9.3456,\"f3\");format(9.3456,\"s3\");format(9.3456,\"e3\")","string"},
{"fourier_an",{"Renvoie le coefficient de Fourier an=2/T*integrate(f(x)*cos(2*pi*n*x/T),a,a+T).","Returns the n-th Fourier coefficient an=2/T*integrate(f(x)*cos(2*pi*n*x/T),a,a+T).",0,0},"Expr(f(x)),Var(x),Period(T),Intg(n),Real(a)","fourier_an(x^2,x,2,0,-1);fourier_an(x^2,x,2,n,-1)","fourier_cn,fourier_bn,assume"},
{"fourier_bn",{"Renvoie le coefficient de Fourier bn=2/T*integrate(f(x)*sin(2*pi*n*x/T),a,a+T).","Returns the n-th Fourier coefficient bn=2/T*integrate(f(x)*sin(2*pi*n*x/T),a,a+T).",0,0},"Expr(f(x)),Var(x),Period(T),Intg(n),Real(a)","fourier_bn(x^2,x,2,0,-1);fourier_bn(x^2,x,2,n,-1)","fourier_cn,fourier_an,assume"},
{"fourier_cn",{"Renvoie le coefficient de Fourier cn=1/T*integrate(f(x)*exp(-2*i*pi*n*x/T),a,a+T).","Returns the n-th Fourier coefficient cn=1/T*integrate(f(x)*exp(-2*i*pi*n*x/T),a,a+T).",0,0},"Expr(f(x)),Var(x),Period(T),Intg(n),Real(a)","fourier_cn(x^2,x,2,0,-1);fourier_cn(x^2,x,2,n,-1)","fourier_an,fourier_bn,assume"},
{"fpour",{"Fin de bloc.","Bloc end.",0,0},""," if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);end;; if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);fi;; f:=function(a,b) local c;c:=a+b;c+gcd(a,b);end;f(28,21);; f:=fonction(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;; fonction f(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;","begin,bloc,{}"},
{"fprint",{"Écrit dans le fichier f des données.","Writes in the file f some data.",0,0},"File(f),Var,[Var,Var...]","fprint(f,x+1,\"2\");fprint(f,\"blabla\");fprint(f,Unquoted,\"blabla\")","fopen,fclose"},
{"frac",{"Renvoie la partie fractionnaire.","Returns the fractional part.",0,0},"Real||LstReal","fPart(1/2);fPart(1.2);fPart([3.4,sqrt(2)])","floor,iPart,trunc"},
{"fracmod",{"Retourne la fraction a/b tel que b*Xpr=a mod n, -sqrt(n)/2<a<=sqrt(n)/2 et 0<=b<sqrt(n)/2.","Returns the fraction a/b such as b*Xpr=a mod n, -sqrt(n)/2<a<=sqrt(n)/2 and 0<=b<sqrt(n)/2.",0,0},"Expr(Xpr),Intg(n)","fracmod(41,121)","mod,smod"},
{"frame_2d",{"frame_2d() dessine le repère de l'écran de géométrie 2-d.","frame_2d() draws the axes of the graphic-screen 2-d.",0,0},"NULL","frame_2d()","frame_3d,Ox_2d_unit_vector,Oy_2d_unit_vector"},
{"frame_3d",{"frame_3d() dessine le repère de l'écran de géométrie 3-d.","frame_3d() draws the axes of the graphic-screen 3-d.",0,0},"NULL","frame_3d()","frame_2d,Ox_3d_unit_vector,Oy_3d_unit_vector,Oz_3d_unit_vector"},
{"frames",{"Option des commandes animate et animate3d pour donner le nombre d'images.","Option of animate and animate3d commands to give the number of pictures.",0,0},"Opt"," animate(sin(x*t),x=-pi..pi,t=-3..3,frames=30); animate3d(x^2+t*y^2,[x=-2..2,y=-2..2],t=-3..3,frames=10)","animate,animate3d"},
{"frequencies",{"Renvoie les fréquences des valeurs d'une liste.","Returns the frequencies of a list values.",0,0},"Lst","frequencies([1,2,1,1,2,1,2,4,3,3]);frequencies([(rand(6)+1)$(k=1..100)])","histogram,cumulated_frequencies,bar_plot,classes"},
{"frobenius_norm",{"Norme de Frobenius d'une matrice A (=sqrt(sum |aij|^2)).","Frobenius norm of a matrix A (=sqrt(sum |aij|^2)).",0,0},"Mtrx","frobenius_norm([[1,2,3],[3,-9,6],[4,5,6]])","l1norm,l2 norm,linfnorm,matrix_norm"},
{"from",{"Utilisé dans une boucle pour (pour...de ...jusque... [pas...] faire...fpour;).","Used in a loop for (for...from ...to... [step...] do...od;).",0,0},""," pour de jusque [pas] faire fpour;; S:=0;pour n de 1jusque 4 faire S:=S+n;fpour;; S:=0;for n from 1 to 4 do S:=S+n;end;; S:=0;pour n de 4 jusque 1 pas -1 faire S:=S+n;fpour ;","for,pour,jusque,to"},
{"froot",{"Renvoie la liste des racines et des pôles de F avec leur multiplicité.","Returns the list of roots and poles of F with their multiplicity.",0,0},"RatPoly(F)","froot((x^5-2*x^4+x^3)/(x-3));froot((x^5-2*x^4+x^3)/(x-1))","proot,fcoeff,pcoeff,realroot,complexroot,rationalroot,crationalroot"},
{"fsi",{"Fin de bloc.","Bloc end.",0,0},""," if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);end;; if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);fi;; f:=function(a,b) local c;c:=a+b;c+gcd(a,b);end;f(28,21);; f:=fonction(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;; fonction f(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;","begin,bloc,{}"},
{"fsi",{"Instruction conditionnelle : (si...alors...sinon...fsi).","Conditional instruction : (si...alors...sinon...fsi).",0,0},""," si alors sinon fsi; n:=1; si n>0 alors triangle_plein(20*n); sinon disque(20*n);fsi;; n:=-1; si n>0 alors triangle_plein(20*n); sinon disque(20*n);fsi;; si x>0 alors x:=x+1; print(\"x est strictement plus grand que 1\");fsi;; si x>0 alors x:=x+1; print(\"x est strictement plus grand que 1\"); sinon x:=x-1;print(\"x est plus petit ou égal à -1\");fsi;","if"},
{"fsolve",{"Résolution numérique d'une équation ou d'un système.","Numerical solution of an equation or a system of equation.",0,0},"Expr,Var,[Guess or Interval],[Method]","fsolve(cos(x)=x,x,-1..1,bisection_solver);fsolve(cos(x)=x,x,0,newton_solver);fsolve([x^2+y-2,x+y^2-2],[x,y],[0,0],newtonj_solver);fsolve([x^2+y-2,x+y^2-2],[x,y])","cfsolve,nSolve,solve,csolve"},
{"ftantque",{"Fin de bloc.","Bloc end.",0,0},""," if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);end;; if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);fi;; f:=function(a,b) local c;c:=a+b;c+gcd(a,b);end;f(28,21);; f:=fonction(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;; fonction f(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;","begin,bloc,{}"},
{"fullparfrac",{"Option de la commande convert ou convertir (id à l'option partfrac).","Option of the convert or convertir command (id at the option partfrac).",0,0},"Opt"," convert(1/(x^2-1),parfrac); convert(1/(x^2-1),fullparfrac)","convert"},
{"func",{"DOM_FUNC ou func représente le type d'une fonction, valeur de la commande type. C'est aussi une option de assume.","DOM_FUNC or func is the type of a function, as returned by the type command. It is also an option of the assume command.",0,0},"Opt"," assume(a,DOM_FUNC); a(x):=1+x;type(a); type(sin); type(factor)","type,assume,DOM_INT,DOM_FLOAT"},
{"funcplot",{"Trace le graphe d'une expression d'1 ou 2 variables avec superposition.","Plot a 1 variable or 2 variables expression with superposition.",0,0},"Expr,[Var(x) or VectVar] ,[Intg(color)]","plotfunc(-2*x+1,x=1..2,color=red);plotfunc([-2*x+1,x^2-2],x=-2..2,color=[red,yellow],xstep=0.2);plotfunc(x^2-y^2,[x,y],xstep=0.5,ystep=0.3);plotfunc(x^2+y^2,[x=-1..1,y=-2..2],nstep=900);plotfunc((x+i*y)^2,[x=-1..1,y=-2..2],nstep=900,affichage=rempli)","plot,plot3d,plotparam,animate,animate3d,plotdensity"},
{"function",{"Instruction qui définit une fonction utilisateur.","Instruction which define an user function.",0,0},"Fnc(f)","fonction f(a,b) local c;c=a+b;c+gcd(a,b);ffonction;; f:=function(a,b) local c;c=a+b;c+gcd(a,b);end;; f:=fonction(a,b) local c;c=a+b;c+gcd(a,b);ffonction;","->,:=,end,ffonction"},
{"function_diff",{"Renvoie la fonction dérivée de la fonction f.","Returns the derivative function of the function f.",0,0},"Fnc(f)","function_diff(sin+id);function_diff(sq@sin+id)","diff,',@"},
{"fxnd",{"Renvoie la liste formée par le numérateur et le dénominateur de la fraction simplifiée.","Returns the list built with the numerator and the denominator of the simplified fraction .",0,0},"Frac or RatFrac","f2nd(42/12);f2nd((x^2+2*x+1)/(x^2-1))","simp2,numer,denom,getNum,getDenom"},
{"gammad",{"Renvoie la densité de probabilité de la loi Gamma (=x^(a-1)*exp(-b*x)*b^a/Gamma(a)).","Returns the density of probability of the Gamma law (=x^(a-1)*exp(-b*x)*b^a/Gamma(a)).",0,0},"Real(a>0),Real(b>0),Real(x>=0)","gammad(2.2,1.5,0.8)","gammad_cdf;,gammad_icdf"},
{"gammad_cdf",{"Renvoie la probabilité qu'une variable aléatoire de loi Gamma ayant a et b comme paramètres soit inférieure à x0 ou comprise entre x0 et y0.","Returns the probability that a Gamma random variable (with a and b as parameters) is lower than x0 or between x0 and y0.",0,0},"Real(a>0),Real(b>0),Real(x0>=0),[Real(y0>=0)]","gammad_cdf(2,1,2.96);gammad_cdf(2,1,1.4,2.96)","gammad,gammad_icdf"},
{"gammad_icdf",{"Renvoie la valeur h telle que la probabilité qu'une variable aléatoire de loi Gamma ayant a et b comme paramètres soit inférieure à h, soit égale à p (0<=p<=1).","Returns h such that the probability that a Gamma random variable is lower than h is p (0<=p<=1).",0,0},"Real(a>0),Real(b>0),Real(0<=p<=1)","gammad_icdf(2,1,0.95);gammad_icdf(2,1,0.5)","gammad_cdf,gammad"},
{"gauche",{"Renvoie la partie gauche d'une égalité, d'un intervalle, d'une liste ou d'une chaîne.","Returns the left part of an equality, of an interval, of a list or of a string.",0,0},"Equal(a=b) or Interval(a..b) or Str,Intg","left(a=b);left(x^2+1=5);left(1..5);left(\"abcdefg\",3)","right,mid,tail,head"},
{"gauss",{"Décompose une forme quadratique en somme/différence de carrés","Split a quadratic form as a sum/difference of square",0,0},"Expr,VectVar","gauss(x^2+2*a*x*y,[x,y])","cholesky"},
{"gauss15",{"Option de la commande area","Option of the area command",0,0},"Opt"," area(x^2,x=0..1,5,simpson); area(x^2,x=0..1,5,rombergt); area(x^2,x=0..1,5,rombergm);area(x^2,x=0..1,5,gauss15)","area"},
{"gauss_seidel_linsolve",{"Résolution d'un système linéaire de matrice A et de second membre b, par la méthode itérative de Gauss-Seidel (par défaut omega=1) ou de relaxation avec une tolérance de eps et un nombre maximal d'itérations de maxiter. ","Resolution of a linear system A*X=b  by the iterative Gauss-Seidel method (by defaut omega=1) or by relaxation method, with eps as error margin and a number of iterations inferior to maxiter.",0,0},"[Real(omega)],Mtrx(A),Vect(b),Real(eps),[Int(maxiter)]"," a:=[[100,2],[2,100]];gauss_seidel_linsolve(a,[0,1],1e-12);; a:=[[100,2],[2,100]];gauss_seidel_linsolve(table(a),[0,1],1e-12); ; a:=[[100,2],[2,100]];gauss_seidel_linsolve(1.5,a,[0,1],1e-12);; a:=[[100,2],[2,100]];gauss_seidel_linsolve(1.5,table(a),[0,1],1e-12); ","jacobi_linsolve,linsolve"},
{"gaussjord",{"Réduction sous forme échelonnée de AX=b (M=A|(-b)) [Réduction sur les k premières colonnes].","Row reduction to echelon form of AX=b (M=A|(-b)) [Reduction on columns 0..k-1]",0,0},"Mtrx(M),[Intg(k)]||Opt","rref([[3,1,-2],[3,2,2]]);rref([[2,1,1,-1],[1,1,2,-1],[1,2,1,-4]]);rref([[2,1,1,-1],[1,1,2,-1],[1,2,1,-4]],2);rref([[1,1,0,0,-a1],[0,1,1,0,-a2],[0,0,1,1,-a3],[1,0,0,1,-a4]],keep_pivot)","ker,image,det,Rref,pivot,ref,keep_pivot"},
{"gaussquad",{"Renvoie la valeur approchée de integrate(f(x),x,a,b) par une quadrature de Gauss adaptative à 15 points.","Returns the approximate value of integrate(f(x),x,a,b) by adaptive Gaussian quadratures with 15 points.",0,0},"Expr(f(x)),Var(x),Real(a),Real(b)","gaussquad(exp(x^2),x,0,1);gaussquad(x^2,x,0,1);gaussquad(exp(-x^2),x,-1,1)","integrate,romberg"},
{"gbasis",{"Base de Groebner de l'idéal engendré par la liste de polynômes.","Groebner basis of the ideal spanned by the list of polynomials.",0,0},"LstPoly,LstVar,[order]","gbasis([x^2-y^3,x+y^2],[x,y]);gbasis([x1+x2+x3,x1*x2+x1*x3+x2*x3,x1*x2*x3-1],[x1,x2,x3]);gbasis([x1+x2+x3,x1*x2+x1*x3+x2*x3,x1*x2*x3-1],[x1,x2,x3],tdeg,with_cocoa=false);gbasis([x1+x2+x3,x1*x2+x1*x3+x2*x3,x1*x2*x3-1],[x1,x2,x3],revlex,with_cocoa=true)","greduce"},
{"gcd",{"PGCD de 2 polynômes de plusieurs variables ou de 2 entiers ou de 2 rationnels.","Returns the greatest common divisor of 2 polynomials of several variables or of 2 integers or of 2 rationals.",0,0},"(Intg(a) or Poly),(Intg(b) or Poly)","gcd(45,75);gcd(15/7,50/9);gcd(x^2-2*x+1,x^3-1);gcd(t^2-2*t+1,t^2+t-2);gcd((x^2-1)*(y^2-1)*z^2,x^3*y^3*z+(-(y^3))*z+x^3*z-z)","lcm,euler,modgcd,ezgcd,psrgcd,heugcd,Gcd"},
{"gcdex",{"Identité de Bézout pour 2 polynômes.","Extended greatest common divisor of 2 polynomials.",0,0},"(Poly or Lst),(Poly or Lst),[Var]","egcd((x-1)^2,x^3-1);egcd((X-1)^2,X^3-1,X);egcd([1,-2,1],[1,0,0,-1]);egcd([1,-2,1],[1,-1,2])","gcd,iegcd"},
{"genpoly",{"Renvoie la reconstruction d'un polynôme Q de n variables (-b/2<=coef(Q)<=b/2) à partir d'un polynôme P de n-1 variables et d'une base b (subst(Q,var=b)=P).","Returns the reconstruction of a n-variables polynomial Q(-b/2<=coef<=b/2) from a (n-1)-variable polynomial P and a base b (subst(Q,var=b)=P).",0,0},"Poly(P),Intg(b),Var","genpoly(15,4,x);genpoly(7*y+5,6,x);genpoly(7*y-5*z,10,x)",""},
{"geometric",{"Renvoie la valeur en k de la loi géométrique de paramètre p (0<p<1).","Returns the value at k of the geometric law of parameter p (0<p<1).",0,0},"Real(p),Intg(k)","geometric(0.3,4);geometric(0.5,5); randvector(3,geometric,0.3); ranm(4,3,geometric,0.3)","geometric_cdf,geometric_icdf,randvector,ranm"},
{"geometric_cdf",{"Renvoie la probabilité qu'une variable aléatoire géométrique de paramètre p (0<p<1) soit inférieure à k (ou entre k et m). ","Returns the probability that a geometric random variable of parameter p (0<p<1) is lower than k (or between k and m).",0,0},"Real(p),Intg(k),[Intg(m)]","geometric_cdf(0.3,4);geometric_cdf(0.3,4,5)","geometric,geometric_icdf"},
{"geometric_icdf",{"Renvoie la valeur h telle que, la probabilité qu'une variable aléatoire géométrique de paramètre p (0<p<1) soit inférieure à h soit x (0<=x<=1).","Returns h such that the probability that a geometric random variable of parameter p (0<p<1) is lower than h is x (0<=x<=1).",0,0},"Real(p),Real(x)","geometric_icdf(0.3,0.95)","geometric_cdf,geometric"},
{"getDenom",{"Renvoie le dénominateur de l'expression non simplifiée (sauf pour les rationnels).","Returns the denominator of the unsimplified expression (except for rational number).",0,0},"Expr","getDenom(25/15);getDenom((x^3-1)/(x^2-1));getDenom(1+(x^3-1)/x^2)","denom,getNum,numer,f2nd"},
{"getKey",{"Instruction dans un programme qui renvoie 0 si aucune touche est pressée et sinon renvoie le code ascii de la touche pressée.","Instruction in a program, returns 0 if no key is pressed and else returns the ascii code of the pressed key.",0,0},"NULL","getKey()","getType"},
{"getNum",{"Renvoie le numérateur de l'expression non simplifiée (sauf pour les rationnels).","Returns the numerator of the unsimplified expression (except for rational number).",0,0},"Expr","getNum(25/15);getNum((x^3-1)/(x^2-1));getNum(1+(x^3-1)/x^2)","numer,denom,getDenom,f2nd"},
{"getType",{"Retourne le type de l'argument (STR,EXPR,FUNC,NUM,LIST,MAT,VAR,NONE,PIC...).","Returns the type of the argument (STR,EXPR,FUNC,NUM,LIST,MAT,VAR,NONE,PIC...).",0,0},"Expr","getType(\"aze\");getType(2+i);getType(x->cos(2*x));getType(1.414)","getKey"},
{"gl_ortho",{"Option globale permettant de définir une configuration graphique orthonormée.","Global option that sets a orthonormal graphic configuration.",0,0},"Opt=Interval"," gl_ortho=1; cercle(i,1+i)",0},
{"gl_quaternion",{"Option permettant de définir le quaternion pour la visualisation des scènes 3-d (pas compatible avec l'interactivité).","Option that defines the quaternion for the visualization in 3-d scenes (do not use for interactive scenes).",0,0},"Opt=Lst"," gl_quaternion=[-0.35752,-0.50198,-0.64393,0.45338]",0},
{"gl_rotation",{"Option globale permettant de définir l'axe de rotation pour les animations par rotation des scènes 3-d.","Global option that defines the rotation axis for the animation rotation of 3-d scene.",0,0},"Opt=NameFich"," gl_rotation=[1,1,1];cube([0,0,0],[3,0,0],[0,0,1])",0},
{"gl_shownames",{"Option permettant de montrer ou de cacher le nom des objets géométriques.","Option that shows or hides objects names.",0,0},"Opt=Boolean"," gl_shownames=true;K:=carre(i,1+i); gl_shownames=false;K:=carre(i,1+i)",0},
{"gl_texture",{"Option permettant de mettre une image sur les rectangles de côtés parallèles aux axes en 2-d et sur les surfaces en 3-d ou permettant de mettre un fond sur un graphique 2-d.","Option that puts a picture in a rectangle of sides parallel to the axis (2-d) or on a 3-d surface or to fill the background (2-d).",0,0},"Opt=NameFich"," carre(i,1+i,gl_texture=\"image.jpg\"); gl_texture=\"image.jpg\"; carre(i,1+i)",0},
{"gl_x",{"Option globale permettant de définir le cadrage du graphique.","Global option that sets the graphic configuration.",0,0},"Opt=Interval"," gl_x=0..2; carre(i,1+i)",0},
{"gl_x_axis_color",{"Option globale permettant de définir individuellement les couleurs des axes des x (resp y,z).","Global option that is an individual definition of the colors of the x, (or y or z) axis.",0,0},"Opt=Intg"," gl_x_axis_color=123;; gl_y_axis_color=216;; gl_z_axis_color=3;",0},
{"gl_x_axis_name",{"Option globale permettant de définir individuellement les noms des axes x (resp y,z).","Global option that is an individual definition of the names of the x (or y or z) axis.",0,0},"Opt=Str"," gl_x_axis_name=\"s\";; gl_y_axis_name=\"m/s\";",0},
{"gl_x_axis_unit",{"Option globale permettant de définir individuellement les noms des unités sur les axes des x (resp y,z).","Global option that is an individual definition of the units of the x, (or y or z) axis.",0,0},"Opt=Str"," gl_x_axis_unit=\"s\";; gl_y_axis_unit=\"m/s\";",0},
{"gl_xtick",{"Option globale permettant de définir l'espacement des marques sur l'axe des x (resp y, z).","Global option that defines the interval between tick marks on the x (resp. y, z) axis.",0,0},"Opt=Real"," gl_xtick=0.5; gl_ytick=1",0},
{"gl_y",{"Option globale permettant de définir le cadrage du graphique.","Global option that sets the graphic configuration.",0,0},"Opt=Interval"," gl_x=0..2; carre(i,1+i)",0},
{"gl_y_axis_color",{"Option globale permettant de définir individuellement les couleurs des axes des x (resp y,z).","Global option that is an individual definition of the colors of the x, (or y or z) axis.",0,0},"Opt=Intg"," gl_x_axis_color=123;; gl_y_axis_color=216;; gl_z_axis_color=3;",0},
{"gl_y_axis_name",{"Option globale permettant de définir individuellement les noms des axes x (resp y,z).","Global option that is an individual definition of the names of the x (or y or z) axis.",0,0},"Opt=Str"," gl_x_axis_name=\"s\";; gl_y_axis_name=\"m/s\";",0},
{"gl_y_axis_unit",{"Option globale permettant de définir individuellement les noms des unités sur les axes des x (resp y,z).","Global option that is an individual definition of the units of the x, (or y or z) axis.",0,0},"Opt=Str"," gl_x_axis_unit=\"s\";; gl_y_axis_unit=\"m/s\";",0},
{"gl_ytick",{"Option globale permettant de définir l'espacement des marques sur l'axe des x (resp y, z).","Global option that defines the interval between tick marks on the x (resp. y, z) axis.",0,0},"Opt=Real"," gl_xtick=0.5; gl_ytick=1",0},
{"gl_z",{"Option globale permettant de définir le cadrage du graphique.","Global option that sets the graphic configuration.",0,0},"Opt=Interval"," gl_x=0..2; carre(i,1+i)",0},
{"gl_z_axis_color",{"Option globale permettant de définir individuellement les couleurs des axes des x (resp y,z).","Global option that is an individual definition of the colors of the x, (or y or z) axis.",0,0},"Opt=Intg"," gl_x_axis_color=123;; gl_y_axis_color=216;; gl_z_axis_color=3;",0},
{"gl_z_axis_name",{"Option globale permettant de définir individuellement les noms des axes x (resp y,z).","Global option that is an individual definition of the names of the x (or y or z) axis.",0,0},"Opt=Str"," gl_x_axis_name=\"s\";; gl_y_axis_name=\"m/s\";",0},
{"gl_z_axis_unit",{"Option globale permettant de définir individuellement les noms des unités sur les axes des x (resp y,z).","Global option that is an individual definition of the units of the x, (or y or z) axis.",0,0},"Opt=Str"," gl_x_axis_unit=\"s\";; gl_y_axis_unit=\"m/s\";",0},
{"gl_ztick",{"Option globale permettant de définir l'espacement des marques sur l'axe des x (resp y, z).","Global option that defines the interval between tick marks on the x (resp. y, z) axis.",0,0},"Opt=Real"," gl_xtick=0.5; gl_ytick=1",0},
{"gnuplot",{"Exécute une instruction dans le processus gnuplot (fenêtre 3-d).","Run a gnuplot command (in the 3-d screen).",0,0},"Str","gnuplot(\"splot u,v,u+v\")",0},
{"goto",{"Dans un programme, permet de sauter à l'instruction repérée par le label nom.","In a program, is used to jump to an instruction with the label nom.",0,0},"Var(nom)"," essai(a):={label truc;a:=a+2;if (a<10) goto truc;print(a);}","label"},
{"grad",{"Renvoie le gradient de l'expression Xpr","Returns the gradient of the expression Xpr",0,0},"Expr(Xpr),LstVar","grad(2*x^2*y-x*z^3,[x,y,z])","hessian"},
{"gramschmidt",{"Renvoie une base orthonormale de E de base B pour le produit scalaire Sp","Returns an orthonormal base of E of base B for the scalar product Sp",0,0},"Basis(B),ScalarProd(Sp)","-2;gramschmidt([1,1+x],(p,q)->integrate(p*q,x,-1,1))",""},
{"graph2tex",{"Convertit le graphique en fichier LaTeX","Converts the graph screen to a LaTeX file",0,0},"[Str(\"filename\")]","graph2tex(\"graph.tex\");graph2tex()","graph3d2tex"},
{"graph3d2tex",{"Convertit le graphe 3D en fichier LaTeX","Converts the 3d graph screen to a LaTeX file",0,0},"[Str\"filename\")]","graph3d2tex(\"graph.tex\");graph3d2tex()","graph2tex"},
{"graphe",{"Trace le graphe d'une expression (ou d'une liste d'expressions) d'1 variable ou d'une densité de loi de probabilité.","Plot a one-variable expression (or list of expressions).",0,0},"(Expr or LstExpr),Var[=VarMin..VarMax],[color=LstColor]","plot(x-1/6*x^3,x);plot([2*x-1,sin(x)],x=1..2);plot(sin(x),x=-2..2,color=green,xstep=0.1);plot([2*x-2,2*sin(x)],x=1..2,color=[green,red],legende=[\"2x-2\",\"sin\"]);plot(exponentiald(2));plot(normald);plot(normald(-1,2))","plotfunc,plotparam,animate,animate3d,plotarea"},
{"graphe3d",{"Efface et trace le graphe d'une fonction ou d'une expression de 2 variables ou d'une surface paramétrée par une liste de 3 fonctions ou de 3 expressions de 2 variables.","Erase and plot a 2 variable expression or of a surface defined with a list of the 3 functions or of 3 expression of 2 variables.",0,0},"Expr||Lst(3*Expr),Var,Var","plot3d(x^2+y^2+1,x,y);plot3d(x^2+y^2,x=-1..1,y=-2..2);plot3d([u+1,2*v,u^2+v^2],u=-1..1,v=-2..2);plot3d(f,-1..1,-2..2);plot3d([f,g,h],-1..1,-2..2)","plotfunc,animate3d"},
{"graphe_suite",{"Permet de visualiser les p premiers termes de la suite u(0)=a,u(n)=f(u(n-1)).","For seeing the pth terms of the sequence u(0)=a,u(n)=f(u(n-1)).",0,0},"Expr(f(Var)),Var=[a,xm,xM],Intg(p)","plotseq(sqrt(2+x),6,5);plotseq(sqrt(2+t),t=6,5);plotseq(sqrt(2+x),x=[6,1,7],5,affichage=epaisseur_ligne_2)","seqsolve,rsolve"},
{"greduce",{"Renvoie le reste de la division d'un polynôme par une base de Groebner.","Returns the remainder of the division of a polynomial by a Groebner basis.",0,0},"Poly,LstPoly,LstVar,[order]","greduce(x*y-1,[x^2-y^2,2*x*y-y^2,y^3],[x,y]);greduce(x1^2*x3^2,[x3^3-1,-x2^2-x2*x3-x3^2,x1+x2+x3],[x1,x2,x3],tdeg);greduce(x1^2*x3^2-x2,[x3^3-1,-x2^2-x2*x3-x3^2,x1+x2+x3],[x1,x2,x3])","gbasis"},
{"green",{"Option de la commande affichage (ou display) pour afficher en couleur.","Option of the display command to display with color.",0,0},"Opt"," F:=display(point(2+1.5*i),red); F:=display(point(2+1.5*i),point_point+green)","display"},
{"grid_paper",{"Trace dans le rectangle [xmin..xmax]*[ymin..ymax], les lignes du réseau formé des droites y=n*uy et dans le repère OxY d'angle t!=0 des droites x=n*ux.","Draws in the rectangle [xmin..xmax]*[ymin..ymax], the lines of the network built with the lines y=n*uy and in the axes OxY of angle t!=0 with the lines x=n*ux.",0,0},"Real(ux),Real(t),Real(uy),[x=xmin..xmax,y=ymin..ymax]","grid_paper(1,pi/3,sqrt(3)/2);grid_paper(1,pi/3,sqrt(3)/2,x=-1..4,y=-2..2);grid_paper(0.5,3*pi/4,0.5)",0},
{"groupermu",{"Renvoie le groupe de permutations engendré par a et b.","Returns the group of permutations generated by a and b.",0,0},"Permut(a),Permut(b)","groupermu([1,2,0],[3,1,2,0])",""},
{"hadamard",{"Borne de Hadamard d'une matrice ou produit terme à terme de 2 matrices","Hadamard bound of a matrix or element by element multiplication of 2 matrix",0,0},"Mtrx,Mtrx","hadamard([[1,2],[3,4]]);hadamard([[1,2],[3,4]],[[3,4],[5,6]])",".*,*"},
{"half_cone",{"Dessine un demi-cône de sommet A, direction v, de demi_angle au sommet t, [et de hauteur h].","Draws an half-cone with vertex A, direction v and with half_angle=t [and with altitude h].",0,0},"Pnt(A),Vect(v),Real(t),[Real(h)]","half_cone([0,0,0],[0,0,1],pi/6);half_cone([0,0,0],[0,1,1],pi/6,-4)","cone,cylinder"},
{"half_line",{"demi_droite(A,B) trace la demi-droite AB d'origine A.","half_line(A,B) draws the half-line AB with A as origin.",0,0},"(Pnt or Cplx),(Pnt or Cplx)","half_line(i,1+i);half_line(point(i),point(1+i))","line"},
{"halftan",{"Transforme sin(x),cos(x) et tan(x) en fonction de tan(x/2).","Transforms sin(x),cos(x) and tan(x) as function of tan(x/2).",0,0},"Expr","halftan(sin(x));halftan(cos(x));halftan(tan(x))",0},
{"halftan_hyp2exp",{"Transforme les fonctions trigonométriques en tan(x/2) et les fonctions hyperboliques en exp","Transforms the trigonometric functions in tan(x/2) and hyperbolic functions in exp",0,0},"ExprTrig","halftan_hyp2exp(sin(x)+sinh(x))","hyp2exp,halftan"},
{"halt",{"Place un programme en exécution pas-à-pas","Put a program in step-by-step debug mode",0,0},"NULL","halt()",""},
{"hamdist",{"Distance de Hamming bit à bit.","Bit Hamming distance.",0,0},"Intg,Intg","hamdist(0x12,0x38)",0},
{"harmonic_conjugate",{"Renvoie le conjugué harmonique C par rapport à A et B des 3 points alignés ou des 3 droites parallèles ou concourantes, ou la polaire d'un point par rapport à 2 droites.","Returns the harmonic conjugate C  toward A and B of 3 points or of 3 parallel or concurrent lines or the line of conjugates of a point in respect to 2 lines.",0,0},"Line or Pnt(A),Line or Pnt(B),Line or Pnt(C)","harmonic_conjugate(0,2,3/2);harmonic_conjugate(0,1+i,2+2*i);harmonic_conjugate(line(0,1+i),line(0,3+i),line(0,i));harmonic_conjugate(line(0,1+i),line(0,3+i),point(3/2+i))","is_harmonic,harmonic_division"},
{"harmonic_division",{"Renvoie les 4 points (resp droites) et affecte le dernier argument, pour que les 4 points (resp droites) forment une division harmonique.","Returns the 4 points (resp lines) and affects the last argument, such as the 4 points (resp lines) are in a harmonic division.",0,0},"Pnt or Line,Pnt or Line,Pnt or Line,Var","harmonic_division(0,2,3/2,D);harmonic_division(0,1+i,2+2*i,D);harmonic_division(line(i,0),line(i,1+i),line(i,3+2*i),D);harmonic_division(line(0,1+i),line(0,3+i),line(0,i),D)","harmonic_conjugate,is_harmonic"},
{"has",{"Teste la présence d'une variable dans une expression","Checks if a variable is in an expression",0,0},"Expr,Var","has(x+y,x);has(x+y,n)","lname,lvar"},
{"hasard",{"(hasard n)=un entier (resp (hasard p,n)=un réel ou hasard(p..n)=une fonction réelle) aléatoire uniformément distribué dans 0.. n-1 (resp dans [p; n]) (hasard ou (hasard 0,1)=un réel aléatoire de [0,1[) ou hasard(n,b1,b2)=n entiers de [b1;b2] ou hasard(n,L)=n éléments de L. Si hasard a un seul argument il peut se passer de () (compatibilité langage tortue).","(hasard n)=a random integer (resp (hasard p,n)=a real or hasard(p..n)=a real function) with uniform distribution in 0..n-1 (resp in [p;n])(hasard= (hasard 0,1)=a random real in [0,1[) or hasard(n,b1,b2)=n integers between b1 and b2 or hasard(n,L)=n elements of L. If hasard has only one argument, () are not necessary (compatibility with turtle language).",0,0},"Intg(n) or Interval(p..n) or NULL,[Intg(b1) or Lst(L)],[Intg(b2)]"," hasard 4; hasard(4);hasard(0,2); hasard 0..2; f:=hasard 0..2;hasard(3,1,10);hasard(3,[\"r\",\"r\",\"r\",\"b\",\"n\"])","rand,randpoly,ranm,randvector,srand"},
{"head",{"Désigne le premier élément d'un vecteur ou d'une suite d'éléments ou d'une chaîne.","Shows the first element of a vector or a sequence or a string.",0,0},"Vect or Seq or Str","head(1,2,3);head([1,2,3]);head(\"bonjour\")","back,tail,mid,left,right"},
{"hermite",{"Renvoie le polynôme de Hermite de degré n ou la forme normale de Hermite d'une matrice a coefficients polynomiaux (I,U tels que I*A=U)","Returns the Hermite polynomial of degree n or the Hermite normal form for a polynomial coefficients matrix (I,U such that I*A=U)",0,0},"Intg(n)||Matr(A)","hermite(3); n:=5; a:=ranm(n,n) % 17; l,u:=hermite(x-a);normal(l*(x-a)-u);","legendre,laguerre,smith,ihermite,ismith"},
{"hessenberg",{"Réduction matricielle sous forme de Hessenberg. Renvoie [P,B] tel que B=inv(P)*A*P, par défaut n=0 les calculs sont exacts, sinon ils sont numériques et pour n=-1 B est triangulaire sup, pour n=-2 P est orthogonale et B a ses coefficients sous-sous-diagonaux nuls et pour n premier les calculs sont modulo n.","Matrix reduction to Hessenberg form. Returns [P,B] such that B=inv(P)*A*P, by default n=0 the result is exact else the result is numeric. For n=-1 B is triangular, n=-2 P is orthogonal and if n is prime the result is mod n.",0,0},"Mtrx(A),[Intg(n)]","hessenberg([[1,2,3],[4,5,6],[7,8,1]]);hessenberg([[1,2,3,4],[4,5,6,7],[7,8,9,0],[0,1,2,3]]);hessenberg([[1,2,3],[4,5,6],[7,8,1]],-1);hessenberg([[1,2,3],[4,5,6],[7,8,1]],-2);hessenberg([[1,2,3],[4,5,6],[7,8,1]],3)","SCHUR"},
{"hessian",{"Renvoie la hessienne de l'expression Xpr","Returns the hessian of the expression Xpr",0,0},"Expr(Xpr),LstVar","hessian(2*x^2*y-x*z,[x,y,z])","grad"},
{"heugcd",{"PGCD de 2 polynômes avec l'algorithme dit du pgcd heuristique.","GCD of 2 polynomials, with the algorithm called heuristic pgcd.",0,0},"Poly,Poly","heugcd(x^4-1,(x-1)^2)","gcd,modgcd,ezgcd,psrgcd"},
{"hexagon",{"Renvoie et dessine l'hexagone de coté AB (ABCDEF est direct) (dans le plan ABP).","Returns and draws the hexagon of side AB (ABCDEF is direct) (in the plane ABP.",0,0},"Pnt(A)||Cplx,Pnt(B)||Cplx,[Pnt(P)],[Var(C)],[Var(D)],[Var(E)],[Var(F)]","hexagon(i,1+i);hexagon(i,1+i,C,D,E,F);hexagon(point(0,0,0),point(3,3,3),point(0,0,3));hexagon(point(0,0,0),point(3,3,3),point(0,0,3),C,D,E,F)","isopolygon,polygon"},
{"hidden_name",{"Option de la commande affichage (ou display) pour ne pas afficher le nom.","Option of the display command to hide the name.",0,0},"Opt"," F:=display(point(2+1.5*i),hidden_name); F:=display(point(2+1.5*i),point_point+hidden_name)","display"},
{"hilbert",{"Renvoie la n-ième matrice de Hilbert : Hjk=1/(j+k+1) j,k=1..n","Returns the order n Hilbert matrix : Hjk=1/(j+k+1) j,k=1..n",0,0},"Intg(n)","hilbert(4)",""},
{"histogram",{"Trace l'histogramme des données de data, on peut préciser une liste d'effectifs, ou un nombre nc de classes ou le mimimum classmin des classes et la largeur classsize des classes.","Draws the histogram of data, optional arguments are eff (number of data for each data element) or nc the number of classes or the classes minimum and size",0,0},"Lst(data),[Lst(eff) || Intg(nc) || Real(classmin)],[Real(classsize)]","histogram([1,2,1,1,2,1,2,4,3,3]);histogram([1,2,1,1,2,1,2,4,3,3],0.5,1);histogram(seq(rand(1000),k,0,100),0,100);histogram(binomial,10,.5);histogram([[0,1],[1,4],[2,3],[3,2],[4,1]]);histogram([[1.5..1.65,50],[1.65..1.7,20],[1.7..1.8,30]]);histogram(seq(rand(1000),k,0,100),0,100);histogram(seq(rand(1000),k,0,100),10)","cumulated_frequencies,classes,bar_plot,frequencies"},
{"hold",{"Retourne son argument sans l'évaluer (et aussi a:=quote(a) qui purge a).","Returns its argument unevaluated (and also a:=quote(a) that purge a).",0,0},"Expr","quote(1+2);quote(1/x+1/(x-1));quote((x+1)*(x-1))",""},
{"homothety",{"homothetie(C,k,A)=point A1 tel que vect(C,A1)=k*vect(C,A) i.e en 2d est la similitude de centre C, de rapport abs(k) et d'angle arg(k).","homothety(C,k,A)=point A1 such as vect(C,A1)=k*vect(C,A) i.e in 2d it is the similarity center C, coeff abs(k) and angle arg(k).",0,0},"Pnt(C),Real(k),Pnt(A)","homothety(1+i,1/3,i);homothety(point(1,1,1),1/3,point(0,1,0)); h:=homothety(1+i,1/3);h(i); h:=homothety(point(1,1,1),1/3);h(point(0,1,0))","similarity,inversion"},
{"horner",{"Renvoie la valeur P(a) calculée selon la méthode de Hörner. La syntaxe horner(liste_alpha_i,liste_x_i,x) permet d'utiliser les differences divisees pour evaluer un polynome d'interpolation en x.","Returns the value of P(a) calculated with Horner's method. With horner(liste_alpha_i,liste_x_i,x), evals an interpolation polynomial from the divided differences at x.",0,0},"Poly(P),Real(a)","horner(x^2+1,2);horner([1,0,1],2);horner(x^2+y*x+y^3-1,2,y); X:=[0.0,1.0,2.0]; A:=lagrange(X,exp,lagrange); horner(A,X,1.5);","convert,base,revlist"},
{"hybrid_solver",{"Argument de fsolve indiquant la méthode pour résoudre numériquement un système d'équations.","Argument for fsolve giving the method for solving a system of numerical equations.",0,0},"Opt"," fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],dnewton_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybrid_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybrids_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybridj_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybridsj_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],newtonj_solver)","fsolve"},
{"hybridj_solver",{"Argument de fsolve indiquant la méthode pour résoudre numériquement un système d'équations.","Argument for fsolve giving the method for solving a system of numerical equations.",0,0},"Opt"," fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],dnewton_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybrid_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybrids_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybridj_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybridsj_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],newtonj_solver)","fsolve"},
{"hybrids_solver",{"Argument de fsolve indiquant la méthode pour résoudre numériquement un système d'équations.","Argument for fsolve giving the method for solving a system of numerical equations.",0,0},"Opt"," fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],dnewton_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybrid_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybrids_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybridj_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybridsj_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],newtonj_solver)","fsolve"},
{"hybridsj_solver",{"Argument de fsolve indiquant la méthode pour résoudre numériquement un système d'équations.","Argument for fsolve giving the method for solving a system of numerical equations.",0,0},"Opt"," fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],dnewton_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybrid_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybrids_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybridj_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybridsj_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],newtonj_solver)","fsolve"},
{"hyp2exp",{"Transforme les fonctions hyperboliques en exponentielle","Transforms the hyperbolic functions with the exponential function",0,0},"ExprHyperb","hyp2exp(cosh(x))","halftan_hyp2exp"},
{"hyperbola",{"hyperbole(F1,F2,M)=hyperbole de foyers F1,F2 passant par M ou (|MF1-MF2|=2*a geo2d) et hyperbole(p(x,y)) dessine la conique si deg(p)=2.","hyperbola(F1,F2,M)=hyperbole focus F1,F2 through M or (|MF1-MF2|=2*a geo2d) and hyperbola(p(x,y)) draws the conic if deg(p)=2.",0,0},"Focus(F1),Focus(F2),(Pnt(M) or Real(a))","hyperbola(-1,1,point(1+i));hyperbola(-1,1,sqrt(5)-1);hyperbola(point(-1,0,0),point(1,0,0),point(1,1,1));hyperbola(x^2-y^2+y+2)","ellipse,parabola"},
{"i",{"Racine carrée de -1","Square root of -1",0,0},""," i*i","pi,e"},
{"iPart",{"Renvoie l'argument sans sa partie fractionnaire (type=DOM_FLOAT).","Returns the argument without its fractional part (type=DOM_FLOAT).",0,0},"Real||LstReal","iPart(4.3);iPart(sqrt(2));iPart(4.3,sqrt(2))","fPart,floor,trunc"},
{"i[]",{"i[] est utilisé pour définir un intervalle réel.","i[] is used to define a real interval.",0,0},"Seq","i[1,3]; i[1,3]+i[2,4]*i","op"},
{"iabcuv",{"Renvoie [u,v] vérifiant au+bv=c pour 3 entiers a,b,c.","Returns [u,v] such as au+bv=c for 3 integers a,b,c.",0,0},"Intg(a),Intg(b),Intg(c)","iabcuv(21,28,7);iabcuv(21,28,14);iabcuv(21,28,1)","iegcd,abcuv"},
{"ibasis",{"Base d'une intersection de deux espaces vectoriels","Basis of the intersection of two vector spaces",0,0},"Lst(Vect,..,Vect),Lst(Vect,..,Vect)","ibasis([[1,0,0],[0,1,0]],[[1,1,1],[0,0,1]])","basis"},
{"ibpdv",{"Intégration par parties de f(x)=u(x)*v'(x) avec f(x) comme 1er argument et v(x) (ou 0 pour intégrer directement) comme 2ème argument. On peut rajouter comme argument la variable et aussi les bornes a et b pour une intégrale définie.","Integration by parts of f(x)=u(x)*v'(x) with f(x) as 1st argument and v(x) (or 0) as 2nd argument. You can specify a variable of integration and also the calculus of the integrate (bounds a and b).",0,0},"Expr(f(x)),Expr(v(x)),[Var(x)],[Real(a)],[Real(b)]","ibpdv(ln(x),x);ibpdv(ln(x),x,x,1,3);ibpdv(x*ln(x),x^2/2);ibpdv([x*ln(x),-1],0);ibpdv(ibpdv(ln(x),x,x,2,3),0,x,2,3)","ibpu,int"},
{"ibpu",{"Intégration par parties de f(x)=u(x)*v'(x) avec f(x) comme 1er argument et u(x) (ou 0 pour intégrer directement) comme 2ème argument. On peut rajouter comme argument la variable et aussi les bornes a et b pour une intégrale définie.","Integration by parts of f(x)=u(x)*v'(x) with f(x) as 1st argument and u(x) (or 0) as 2nd argument. You can specify a variable of integration and also the calculus of the integrate (bounds a and b).",0,0},"Expr(f(x)),Expr(u(x)),[Var(x)],[Real(a)],[Real(b)]","ibpu(ln(x),ln(x));ibpu(ln(x),ln(x),x,1,3);ibpu(x*ln(x),ln(x));ibpu([x*ln(x),-1],0);ibpu(ibpu(ln(x),ln(x),x,2,3),0,x,2,3)","ibpdv,int"},
{"icdf",{"Distribution cumulée inverse pour une loi de probabilité.","Inverse cumulated distribution function.",0,0},"Func,FuncParams","icdf(binomial,10,0.5,0.6);icdf(normald,0.0,1.0,0.975)","cdf,binomial_icdf,normald_icdf"},
{"ichinrem",{"Restes chinois pour des entiers.","Chinese remainders for integers.",0,0},"LstIntg(a,p),LstIntg(b,q)","ichinrem([2,7],[3,5]);ichinrem([2%7,3%5]);ichinrem([2%7,3%5,1%9]);ichinrem([(x+1)%2,(x+2)%3,(3*x-1)%5])","gcd,fracmod,chinrem,chrem"},
{"ichrem",{"Restes chinois pour des entiers.","Chinese remainders for integers.",0,0},"LstIntg(a,p),LstIntg(b,q)","ichinrem([2,7],[3,5]);ichinrem([2%7,3%5]);ichinrem([2%7,3%5,1%9]);ichinrem([(x+1)%2,(x+2)%3,(3*x-1)%5])","gcd,fracmod,chinrem,chrem"},
{"icontent",{"PGCD des coefficients entiers d'un polynôme.","GCD of the integer coefficients of a polynomial.",0,0},"Poly,[Var]","icontent(24x^3+6x^2-12x+18);icontent(24t^3+6t^2-12t+18,t)",""},
{"icosahedron",{"Dessine un icosaèdre de centre A, de sommet B où le plan ABC contient le sommet le plus proche (parmi les 5) de B.","Draws an icosahedron with center A, vertex B and such that the plane ABC contains one vertex among the 5 nearest vertices from B.",0,0},"Pnt(A),Pnt(B),Pnt(C)","icosahedron([0,0,0],[sqrt(5),0,0],[1,2,0]);icosahedron(evalf([0,0,0],[3,2,4],[1,1,0]))","octahedron,dodecahedron,cube,tetrahedron"},
{"id",{"Désigne la fonction identité (ℝ^n -> ℝ^n).","Is the name of the identity function (ℝ^n -> ℝ^n).",0,0},"Seq","id(1,2,3)","sq,sqrt"},
{"identifier",{"DOM_IDENT ou identifier représente le type d'un identificateur, valeur de la commande type. C'est aussi une option de assume.","DOM_IDENT or identifier is the type of an identifier, as returned by the type command. It is also an option of the assume command.",0,0},"Opt"," purge(a);type(a)","type,assume,DOM_INT,DOM_FLOAT"},
{"identity",{"Retourne la matrice identité de dimension n.","Returns the identity matrix of specified dimension n.",0,0},"Intg(n)","identity(3);identity(5)","ranm"},
{"idivis",{"Renvoie la liste des diviseurs d'un entier a.","Returns the list of divisors of an integer.",0,0},"Intg(a) or LstIntg","idivis(36);idivis([36,49])","divis,ifactors"},
{"idn",{"Retourne la matrice identité de dimension n.","Returns the identity matrix of specified dimension n.",0,0},"Intg(n)","identity(3);identity(5)","ranm"},
{"iegcd",{"Identité de Bézout pour 2 entiers.","Extended greatest common divisor of 2 integers.",0,0},"Intg,Intg","iegcd(45,75);iegcd(21,28);iegcd(30,49)","gcd,iabcuv,egcd"},
{"if",{"Test: if (condition) true_action; else false_action;","Test: if (condition) true_action; else false_action;",0,0},""," if (x<0) print(\"x negatif\");; x:=1;if (x>0) {x:=x+1; print(\"x est strictement plus grand que 1\");x}; if x<0 then print(\"x negatif\"); end_if;; x:=1;if x<0 then print(\"x negatif\"); else print(\"x positif\"); end_if;; if (j<0) cos(j); else cosh(j);; x:=0.1;if (x>0) {x:=x+1; print(\"x est strictement plus grand que 1\");} else {x:=x-1;print(\"x est plus petit ou égal à -1\");};x","switch,for,local,si,{},->"},
{"ifactor",{"Factorisation d'un entier en facteurs premiers.","Factorization of an integer into prime factors.",0,0},"Intg(a)","ifactor(50);ifactor(123456789)","factor"},
{"ifactors",{"Renvoie la liste des facteurs premiers d'un entier avec leur multiplicité.","Returns the list of prime factors of an integer (each factor is followed by its multiplicity).",0,0},"Intg(a) or LstIntg","ifactors(36);ifactors([36,52])","ifactor,factors"},
{"ifft",{"Inverse Fast Fourier Transform.","Inverse Fast Fourier Transform.",0,0},"Vect","ifft([100.0,-52.2842712475+6*i,-8.0*i,4.28427124746-6*i,4.0,4.28427124746+6*i,8*i,-52.2842712475-6*i])","fft"},
{"ifte",{"Si condition renvoie Expr1 sinon renvoie Expr2.","If condition returns Expr1 else returns Expr2.",0,0},"Cond,Expr1,Expr2"," x:=3;ifte(x>0,x+1,x-1); a:=2;ifte(a>1,a+1,0)","if,then,else,when"},
{"igamma",{"Calcule les valeurs de la fonction gamma au point (a,x) : c'est la fonction Gamma incomplète. Si a et x>0, igamma(a,x)=int(e^{-t}*t^{a-1},t=0..x), (igamma(a,x,1)=igamma(a,x)/Gamma(a))","Calculus of gamma at a point (a,x). If a and x>0, igamma(a,x)=int(e^{-t}*t^{a-1},t=0..x), (igamma(a,x,1)=igamma(a,x)/Gamma(a)).",0,0},"Real(a),Real(x),[1]","igamma(5.0,2.0);igamma(-5.1,2.1);igamma(5.0,2.0,1)","Psi,Beta,Gamma,ugamma"},
{"igcd",{"PGCD de 2 polynômes de plusieurs variables ou de 2 entiers ou de 2 rationnels.","Returns the greatest common divisor of 2 polynomials of several variables or of 2 integers or of 2 rationals.",0,0},"(Intg(a) or Poly),(Intg(b) or Poly)","gcd(45,75);gcd(15/7,50/9);gcd(x^2-2*x+1,x^3-1);gcd(t^2-2*t+1,t^2+t-2);gcd((x^2-1)*(y^2-1)*z^2,x^3*y^3*z+(-(y^3))*z+x^3*z-z)","lcm,euler,modgcd,ezgcd,psrgcd,heugcd,Gcd"},
{"igcdex",{"Identité de Bézout pour 2 entiers.","Extended greatest common divisor of 2 integers.",0,0},"Intg,Intg","iegcd(45,75);iegcd(21,28);iegcd(30,49)","gcd,iabcuv,egcd"},
{"ihermite",{"Calcule la forme normale de Hermite pour une matrice A à coefficients entiers : renvoie L,U tels que L inversible dans ℤ, U triangulaire supérieure et U=L*A.","Hermite normal form of a matrix with coefficients in ℤ : returns L,U such that L is invertible in ℤ, U upper triangular and U=L*A.",0,0},"Mtrx(A)","ihermite([[9,-36,30], [-36,192,-180], [30,-180,180]]);ihermite([[1,2,3],[4,5,6],[7,8,9]])","ismith"},
{"ilaplace",{"Transformée de Laplace inverse d'une fraction rationnelle","Inverse Laplace transform of a rational fraction",0,0},"Expr,[Var],[IlapVar]","ilaplace(1/(x^2+1)^2);ilaplace(s/(s^4-1),s,x);ilaplace(exp(-s)/s,s,x)","laplace,ztrans,invztrans,Heaviside"},
{"im",{"Partie imaginaire d'un nombre complexe","Returns the imaginary part of a complex number",0,0},"Cplx","im(1+2*i);im((1+2*i)^2);im([1+2*i,(1+2*i)^2])","re,conj"},
{"imag",{"Partie imaginaire d'un nombre complexe","Returns the imaginary part of a complex number",0,0},"Cplx","im(1+2*i);im((1+2*i)^2);im([1+2*i,(1+2*i)^2])","re,conj"},
{"image",{"Image d'une application linéaire de matrice M","Image of a linear application of matrix M",0,0},"Mtrx(M)","image([[1,2],[3,6]]);image([[1,2,3],[1,3,6],[2,5,9]])","ker,rref"},
{"implicitdiff",{"Derivee implicite","Implicit differentiation",0,0},"constr,[depvars],y,diffvars","implicitdiff(x^2*y+y^2=1,y,x);implicitdiff(R=P*V/T,P,T);implicitdiff([x^2+y=z,x+y*z=1],[y(x),z(x)],y,x);implicitdiff([x^2+y=z,x+y*z=1],[y(x),z(x)],[y,z],x);implicitdiff(y=x^2/z,y,x);implicitdiff(y=x^2/z,y,z);implicitdiff(y^3+x^2=1,y,x);implicitdiff(y^3+x^2=1,y,x,x);implicitdiff(a*x^3*y-2y/z=z^2,y(x,z),x);implicitdiff(a*x^3*y-2y/z=z^2,y(x,z),x,z);implicitdiff([-2x*z+y^2=1,x^2-exp(x*z)=y],[y(x),z(x)],y,x);implicitdiff([-2x*z+y^2=1,x^2-exp(x*z)=y],[y(x),z(x)],[y,z],x);implicitdiff([a*sin(u*v)+b*cos(w*x)=c,u+v+w+x=z,u*v+w*x=z],[u(x,z),v(x,z),w(x,z)],u,z);implicitdiff(x*y,-2x^3+15x^2*y+11y^3-24y=0,y(x),x$2);implicitdiff((x-u)^2+(y-v)^2,[x^2/4+y^2/9=1,(u-3)^2+(v+5)^2=1],[v(u,x),y(u,x)],u,x);implicitdiff(x*y*z,-2x^3+15x^2*y+11y^3-24y=0,[x,z,y],order_size=1);implicitdiff(x*y*z,-2x^3+15x^2*y+11y^3-24y=0,[x,z,y],order_size=2,[1,-1,0]); pd:=implicitdiff(x*y*z,-2x^3+15x^2*y+11y^3-24y=0,[x,z,y],order_size=4,[0,z,0]);pd[4,0,0]",0},
{"implicitplot",{"plotimplicit(f(x,y),x,y) ou plotimplicit(f(x,y),[x,y]) graphe de f(x,y)=0.","plotimplicit(f(x,y),x,y) or plotimplicit(f(x,y),[x,y]) graph of f(x,y)=0.",0,0},"Expr,Var1,Var2","plotimplicit(x^2+y^2-1,x,y);plotimplicit(x^4+y^4=x^2-y^2);plotimplicit(x^2+y^2-1,x,y,unfactored);plotimplicit(x^2+4*y^3-1);plotimplicit(x^2+4*y^3-k)$(k=-5..5);plotimplicit(y^3=x^3-x^2,x,y,xstep=0.1,ystep=0.1);plotimplicit(y^3=x^3-x^2,[x,y],xstep=0.1,ystep=0.1);plotimplicit((x+5)^2+(y+4)^2-1,x=-6..-4,y=-5..-3);plotimplicit((x+5)^2+(y+4)^2-1,[x=-6..-4,y=-5..-3])","plotcontour,unfactored,plotinequation"},
{"in",{"Itération for...end_for dans un ensemble ou une liste ou une plage de valeurs","Iteration for ...end_for in a set or a list",0,0},""," s:=0;for k in 1..5 do s:=s+k; end_for;; s:=0;for k in %{ 1,5,7 %} do s:=s+k; end_for;; for k in %{2,1,3%} do print(k); end_for;; pour k in  %{2,1,3%} faire print(k);fpour;; P:=[1,3,7];L:=NULL;for k in P do L:=L,k^2 end_for; ; P:=[1,3,7];L:=NULL;pour k in P faire L:=L,k^2; fpour;","for,set[]"},
{"inString",{"Teste si e est dans la chaîne l (renvoie -1 ou k si l[k]=e).","Tests if e is in the string l (returns -1 or k if l[k]=e).",0,0},"Str(l),Elem(e)","inString(\"abcd\",\"b\");inString(\"abcd\",\"e\")","contains"},
{"in_ideal",{"Test d'appartenance d'un polynôme ou d'une liste de polynômes à un idéal donné par une base de Groebner (2ème argument) par rapport à une liste de variables.","Checks whether a polynomial or list of polynomials belongs to an ideal given by a Grobner basis (2nd argument) with respect to a variable list.",0,0},"Poly,Lst,LstVar,[order]","in_ideal((x+y)^2,[y^2,x^2+2*x*y],[x,y]);in_ideal(x+y,[y^2,x^2+2*x*y],[x,y])","gbasis,greduce"},
{"incircle",{"inscrit(A,B,C) trace le cercle inscrit au triangle ABC.","incircle(A,B,C) draws the incircle of the ABC triangle.",0,0},"(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)","incircle(0,1,1+i)","excircle,circumcircle"},
{"indets",{"Liste des variables de l'expression.","List of variables in the expression.",0,0},"Expr","lname(exp(x)*2*sin(y))","has,lvar"},
{"inequationplot",{"Affiche le graphe de la solution d'inéquations de 2 variables.","Shows the graph of the solution of inequations with 2 variables.",0,0},"Expr,[x=xrange,y=yrange],[xstep],[ystep]","plotinequation(x^2-y^2<3);plotinequation(x^2-y^2<3,[x=-2..2,y=-2..2],xstep=0.1,ystep=0.1);plotinequation(3-(x^2-y^2),[x=-2..2,y=-2..2],xstep=0.1,ystep=0.1);plotinequation([x+y>3,x^2<y],[x,y],xstep=0.2,ystep=0.2)","plotfunc,plotcontour,plotdensity,plotimplicit"},
{"inf",{"Plus infini","Plus infinity",0,0},"",0,"infinity,-infinity"},
{"infinity",{"Infini non signé","Unsigned infinity",0,0},"",0,"+infinity,-infinity"},
{"infnorm",{"Triple norme d'une matrice subordonnée soit à la norme linfini.","Matrix norm induced by linfinty norm.",0,0},"Mtrx","infnorm([[1,2,3],[3,-9,6],[4,5,6]])","l1norm,l2norm,matrix_norm,frobenius_norm"},
{"input",{"Instruction dans un programme permettant l'entrée d'une expression qui sera stockée dans var.","Instruction in a program so that you can input an expression and store it in var.",0,0},"[Str],Var(var)","input(\"age\",a)","InputStr,output"},
{"inputform",{"Dans un programme, est utilisé pour faire des entrées.","In a program, is used to do inputs.",0,0},"[Str],Var,[Str],[Var],[Str],[Var]","inputform(\"a=?\",a,\"b=?\",b);inputform(a,b)",""},
{"insert",{"Renvoie l dans laquelle l'élément b a été insérer à l'indice n.","Returns l where the element b is of index n.",0,0},"Vect(l)||Str(l),Intg(n),Val(b)","insert([0,1,2,3],2,5);insert(\"0123\",2,\"5\")","tail,mid,remove,suppress"},
{"insmod",{"Installe un module dynamique en créant les commandes qui sont, par exemple, dans le fichier libprogfr.so en mettant le chemin d'accès à ce fichier.","Installs a dynamic module creates the commands that are, for example, in the file libprogfr.so putting the pwd of this file.",0,0},"Str(pwd)","insmod(\"/home/parisse/giac/src/libprogfr.so\")","rmmod,lsmod"},
{"int",{"Primitive (la variable d'intégration est le 2ème argument) ou valeur de l'intégrale (bornes a et b).","Indefinite integral, you can specify a variable of integration or the calculus of the integrate (bounds a and b).",0,0},"Expr,[Var(x)],[Real(a)],[Real(b)]","int(1/x);int(1/(4+t^2),t);int(1/(1-x^4),x,2,3)","Int,diff,plotarea,romberg,gaussquad"},
{"intDiv",{"Quotient euclidien de 2 entiers ou de 2 entiers de Gauss.","Euclidean quotient of 2 integers.",0,0},"Intg(a),Intg(b)","iquo(125,15);iquo(125,41);iquo(-7,3);iquo(25+12*i,5+7*i)","irem,smod,quo"},
{"integer",{"DOM_INT ou integer ou DOM_int est un entier qui représente le type d'une variable entière, valeur de la commande type. DOM_INT est utilisé si l'entier est < 2^31. C'est aussi une option de assume.","DOM_INT or integer or DOM_int is an integer which is the type of an integer variable, it is the value of the type command. DOM_INT is used for integers < 2^31. It is also an option of the assume command.",0,0},"Opt"," type(2^31); DOM_INT+0; assume(a,DOM_INT); assume(a,integer); a:=2;type(a)","type,assume,DOM_FLOAT,DOM_SYMBOLIC"},
{"integrate",{"Primitive (la variable d'intégration est le 2ème argument) ou valeur de l'intégrale (bornes a et b).","Indefinite integral, you can specify a variable of integration or the calculus of the integrate (bounds a and b).",0,0},"Expr,[Var(x)],[Real(a)],[Real(b)]","int(1/x);int(1/(4+t^2),t);int(1/(1-x^4),x,2,3)","Int,diff,plotarea,romberg,gaussquad"},
{"integrer",{"Primitive (la variable d'intégration est le 2ème argument) ou valeur de l'intégrale (bornes a et b).","Indefinite integral, you can specify a variable of integration or the calculus of the integrate (bounds a and b).",0,0},"Expr,[Var(x)],[Real(a)],[Real(b)]","int(1/x);int(1/(4+t^2),t);int(1/(1-x^4),x,2,3)","Int,diff,plotarea,romberg,gaussquad"},
{"inter",{"Avec 2 arguments (resp 3 arguments) donne l'intersection de 2 courbes ou surfaces sous la forme d'un vecteur (resp d'un point proche du point donné en 3iéme argument).","With 2 arguments (resp 3 arguments) gives the intersection of 2 curves or surfaces as a vector (resp a point close to the point given as third argument).",0,0},"Curve,Curve,[Pnt]","inter(line(i,1-i),circle(0,1));inter(line(i,1-i),circle(0,1),point(-i));inter(plane(x=y+3),cone([0,0,0],[0,0,1],pi/6));inter(plane(x=y+3),cone([0,0,0],[0,0,1],pi/6));inter(line(i,1-i),circle(0,1))[0]","intersect,head"},
{"interactive_odeplot",{"Trace (dans DispG) une solution pour chaque point t0+i*y0 désigné par la souris (Esc=arrêt).","Draws (in DispG) a solution for each point t0+i*y0 clicked with the mouse (Esc=halt).",0,0},"Expr,VectVar","interactive_plotode(sin(t*y),[t,y]);interactive_plotode(-t*y,[t,y])","odeplot,plotfield,odesolve,desolve"},
{"interactive_plotode",{"Trace (dans DispG) une solution pour chaque point t0+i*y0 désigné par la souris (Esc=arrêt).","Draws (in DispG) a solution for each point t0+i*y0 clicked with the mouse (Esc=halt).",0,0},"Expr,VectVar","interactive_plotode(sin(t*y),[t,y]);interactive_plotode(-t*y,[t,y])","odeplot,plotfield,odesolve,desolve"},
{"interp",{"Renvoie le polynôme de degré n-1 tel que P(xk)=yk=f(x_k) k=0..n-1 ou la liste des differences divisees si le dernier argument est lagrange","Returns the polynomial of degree n-1 such that P(xk)=yk=f(x_k) k=0..n-1 or the list of divided differences if the last argument is lagrange",0,0},"(Lst_xk,Lst_yk)||Mtrx_2*n||(Lst_xk,Fnc(f)),[Var||[]||lagrange]","lagrange([1,3,4],[0,1,2]);lagrange([1,3,4],[0,1,2],t); f(x):=exp(-x); lagrange([1,3,4],f);lagrange([[1,3,4],[0,1,2]]);lagrange([1,3,4],[0,1,2],[]); X:=[1,3,4]; divdiff:=lagrange(X,[0,1,2],lagrange); horner(divdiff,X,5);;lagrange([[1,3,4],[0,1,2]],y);lagrange([-1,0,1],[1/e-1,0,e-1]); f(x):=exp(x)-1;lagrange([-1,0,1],f);lagrange([0,1,2],[1,exp(1),exp(2)],lagrange);lagrange([0,1,2],exp,lagrange)","spline"},
{"intersect",{"intersect est un opérateur infixé pour avoir l'intersection de 2 ensembles.","intersect is a infixed operator to get the intersection of 2 sets.",0,0},"(Vect or Set),(Vect or Set)"," [1,2,3] intersect [2,5,6]; %{1,2,3%} intersect %{2,5,6%}","union,minus"},
{"interval",{"Option de la commande convert ou convertir.","Option of the convert or convertir command.",0,0},"Opt"," convert(sqrt(2),interval); convert(sqrt(2),interval,20); convert(sqrt(2)*sin(2)+sqrt(2)*cos(2),interval,20)","interval"},
{"interval2center",{"Renvoie le centre de l'intervalle ou l'objet.","Returns the center of the interval or the object.",0,0},"Interval or Real","interval2center(2..5);interval2center(3)","center2interval"},
{"inv",{"Inverse d'une expression ou d'une matrice.","Returns the inverse of an expression or matrix.",0,0},"Expr||Mtrx","inv(9/5);inv([[1,2],[3,4]])","Inv"},
{"inverse",{"Inverse d'une expression ou d'une matrice.","Returns the inverse of an expression or matrix.",0,0},"Expr||Mtrx","inv(9/5);inv([[1,2],[3,4]])","Inv"},
{"inversion",{"inversion(C,k,A)=point(A1) avec A1 sur la droite(C,A) et mes_alg(CA1*CA)=k","inversion(C,k,A)=point A1 such as A1 on line(C,A) and mes_alg(CA1*CA)=k",0,0},"Pnt(C),Real(k),Pnt(A)","inversion(i,1/2,1+i);inversion([1,1,1],-1/2,point(-1,-1,-1)); inver:=inversion(i,1/2);inver(i); inver:=inversion([1,1,1],-1/2);inver(point(-1,-1,-1))","homothety"},
{"invisible_point",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," F:=display(point(2+1.5*i),point_point); F:=display(point(2+1.5*i),rhombus_point)","display"},
{"invlaplace",{"Transformée de Laplace inverse d'une fraction rationnelle","Inverse Laplace transform of a rational fraction",0,0},"Expr,[Var],[IlapVar]","ilaplace(1/(x^2+1)^2);ilaplace(s/(s^4-1),s,x);ilaplace(exp(-s)/s,s,x)","laplace,ztrans,invztrans,Heaviside"},
{"invztrans",{"Transformée en z inverse d'une fraction rationnelle","Inverse z transform of a rational fraction",0,0},"Expr,[Var],[InvZtransVar]","invztrans(1/(x^2+1)^2);invztrans(z/(z^4-1),z,n)","ztrans,laplace,invlaplace"},
{"iquo",{"Quotient euclidien de 2 entiers ou de 2 entiers de Gauss.","Euclidean quotient of 2 integers.",0,0},"Intg(a),Intg(b)","iquo(125,15);iquo(125,41);iquo(-7,3);iquo(25+12*i,5+7*i)","irem,smod,quo"},
{"iquorem",{"Quotient et reste euclidien de 2 entiers ou de 2 entiers de Gauss.","Euclidean quotient and remainder of 2 integers.",0,0},"Intg(a),Intg(b)","iquorem(125,15);iquorem(125,41);iquorem(25+12*i,5+7*i)","irem,iquo,quorem"},
{"iratrecon",{"Retourne la fraction a/b tel que b*Xpr=a mod n, -sqrt(n)/2<a<=sqrt(n)/2 et 0<=b<sqrt(n)/2.","Returns the fraction a/b such as b*Xpr=a mod n, -sqrt(n)/2<a<=sqrt(n)/2 and 0<=b<sqrt(n)/2.",0,0},"Expr(Xpr),Intg(n)","fracmod(41,121)","mod,smod"},
{"irem",{"Reste euclidien de 2 entiers ou de 2 entiers de Gauss.","Euclidean remainder of 2 integers.",0,0},"Intg(a),Intg(b)","irem(125,15);irem(125,41);irem(-7,3);irem(25+12*i,5+7*i)","iquo,smod,rem,mod"},
{"isPrime",{"Test de primalité (=true ou false).","Primality testing (=true or false).",0,0},"Intg(a)","isprime(1999);isprime(9856989898997);isprime(9856989898997789789)","prevprime,nextprime,is_prime,is_pseudoprime"},
{"is_collinear",{"Renvoie 1 si les points sont alignés, 2 si les points sont confondus et 0 sinon.","Returns 1 if the points are aligned,2 if the points are the same and 0 otherwise.",0,0},"LstPnt","is_collinear(0,i,1+i,2*i);is_collinear(point(0),point(1+i),point(2,2),point(-1-i));is_collinear(point(0,0,0),point(1,1,0),point(2,2,0),point(-1,-1,1))","is_concyclic"},
{"is_concyclic",{"Renvoie 1 si les points sont cocycliques et 0 sinon.","Returns 1 if the points are on a circle and 0 otherwise.",0,0},"LstPnt","is_concyclic(0,i,1+i,1,1/2+i*(1/2+sqrt(2)/2));is_concyclic(1,-1,i,-i,1+i,-1-i)","is_collinear"},
{"is_conjugate",{"Renvoie 1 si les 3 (resp 4) arguments sont un conjugués par rapport à un cercle (resp 2 droites) et 0 sinon.","Returns 1 if the 3 (resp 4) arguments are conjugated toward a circle (resp 2 lines) and 0 otherwise.",0,0},"Crcle||Line,Pnt||Line,Pnt||Line,[Pnt||Line]","is_conjugate(circle(0,1+i),point(1-i),point(3+i));is_conjugate(circle(0,1),point((1+i)/2),line(1+i,2));is_conjugate(circle(0,1),line(1+i,2),point((1+i)/2));is_conjugate(circle(0,1),line(1+i,2),line((1+i)/2,0));is_conjugate(point(1+i),point(3+i),point(i),point(3/2+i));is_conjugate(line(0,1+i),line(2,3+i),line(3,4+i),line(3/2,5/2+i));is_conjugate(line(0,1+i),line(0,3+i),line(0,i),line(0,3/2+i));is_conjugate(line(0,1+i),line(0,3+i),line(0,i),point(3/2+i));is_conjugate(line(0,1+i),line(0,3+i),point(3/2+i),line(0,i));is_conjugate(line(0,1+i),line(0,3+i),point(i),point(3/2+i))","harmonic_conjugate,pole,polar"},
{"is_coplanar",{"Teste si 4 points sont coplanaires.","Test if 4 points are in the same plan.",0,0},"Pnt,Pnt,Pnt,Pnt","is_coplanar([0,0,0],[1,2,-3],[1,1,-2],[2,1,-3])",0},
{"is_cospheric",{"Teste si 5 points sont cosphériques.","Test if 5 points are on the same sphere.",0,0},"Pnt,Pnt,Pnt,Pnt","is_cospheric([-1,0,0],[1,0,0],[0,1,0],[0,-1,0],[0,0,1])",0},
{"is_cycle",{"Renvoie 1 si l'argument est un cycle et 0 sinon.","Returns 1 if the argument is a cycle and 0 otherwise.",0,0},"Lst","is_cycle([1,0,5]);is_cycle([1,0,5,1])","is_permu,cycle2perm,cycles2permu"},
{"is_element",{"Renvoie 1 si le point est sur l'objet géométrique et 0 sinon.","Returns 1 if the point is on the geometric object and 0 otherwise.",0,0},"Pnt,GeoObj","is_element(point(i),square(0,1));is_element(point(i),circle(point(0),point(2)))","element,member,contains"},
{"is_equilateral",{"Renvoie 1 si les 3 points (ou l'objet) forment un triangle équilatéral et 0 sinon.","Returns 1 if the 3 points (or the object) built an equilateral triangle and 0 otherwise.",0,0},"Pnt||Cplx,Pnt||Cplx,Pnt||Cplx","is_equilateral(0,2,1+i*sqrt(3));is_equilateral(point(0),point(1+i),point(2,2));is_equilateral(triangle(0,2,1+i*sqrt(3)))","is_isosceles,is_rectangle"},
{"is_harmonic",{"Renvoie 1 si les 4 points forment un division harmonique et 0 sinon.","Returns 1 if the 4 points are in a harmonic division and 0 otherwise.",0,0},"Pnt or Cplx,Pnt or Cplx,Pnt or Cplx,Pnt or Cplx","is_harmonic(0,2,3/2,3);is_harmonic(0,1+i,1,i)","is_conjugate"},
{"is_harmonic_circle_bundle",{"Renvoie 1 si les cercles forment un faisceau, 2 si ils sont concentriques, 3 si ils sont confondus et 0 sinon.","Returns 1 if the circles built a beam, 2 if they have the same center, 3 if they are the same and 0 otherwise.",0,0},"Lst(Crcle)","is_harmonic_circle_bundle([circle(0,i),circle(4,i),circle(0,point(1/2))]);is_harmonic_circle_bundle([circle(0,1+i),circle(2,1+i),circle(1+i,point(1-i))])","is_harmonic_line_bundle"},
{"is_harmonic_line_bundle",{"Renvoie 1 si les droites ont un point commun, 2 si elles sont parallèles, 3 si elles sont confondues et 0 sinon.","Returns 1 if the lines have a common point, 2 if they are parallels, 3 if they are the same and 0 otherwise.",0,0},"Lst(Line)","is_harmonic_line_bundle([line(0,1+i),line(0,2+i),line(0,1),line(0,3+i)]);is_harmonic_line_bundle([line(0,1+i),line(2,3+i),line(3,4+i),line(-1,i)])","is_harmonic_circle_bundle"},
{"is_included",{"Teste l'inclusion de 2 ensembles ou de 2 listes.","Test if a set or a list is included in another set or list.",0,0},"Lst||Ens,Lst||Ens","is_included([1,2,-3],[-1,-2,2,1,-3]);is_included(%{1,2,-3%},%{-1,3,-2,2,1,-3%})",0},
{"is_inside",{"Teste si un point est à l'intérieur d'un polygone ou d'un cercle.","Checks whether a point is inside a polygon or a circle.",0,0},"Pnt,Polygon or Circle","is_inside(point(0),circle(-1,1));is_inside(point(1-i),triangle([1,2-i,3+i]))","is_element"},
{"is_isosceles",{"Renvoie 1, 2 ou 3 si les 3 points (ou l'objet) forment un triangle isocèle de sommet 1, 2 ou 3, renvoie 4 si les 3 points (ou l'objet) forment un triangle équilatéral et 0 sinon.","Returns 1, 2 or 3 if the 3 points (or the object) built an isosceles triangle with vertices 1, 2, or 3, returns 4 if the 3 points (or the object) built an equilateral triangle and 0 otherwise.",0,0},"Pnt or Cplx,Pnt or Cplx,Pnt or Cplx","is_isosceles(0,i,1+i);is_isosceles(point(0),point(1+i),point(2,2));is_isosceles(triangle(0,i,1+i))","is_equilateral,is_right_triangle"},
{"is_orthogonal",{"Renvoie 1 si les 2 cercles sont orthogonaux (tangentes orthogonales en un point d'intersection) ou si les 2 droites sont orthogonales et 0 sinon.","Returns 1 if the 2 circles are orthogonal (orthogonal tangents at a point of intersection) or if the 2 lines are orthogonal and 0 otherwise.",0,0},"Line||Crcle,Line||Crcle","is_orthogonal(line(0,1+i),line(1,i));is_orthogonal(circle(0,1+i),circle(2,1+i));is_orthogonal(line([2,3,-2],[-1,-1,-1]),line([1,0,0],[1,2,8]))","is_parallel,is_perpendicular"},
{"is_parallel",{"Renvoie 1 si 2 droites sont parallèles et 0 sinon.","Returns 1 if 2 lines are parallel and 0 otherwise.",0,0},"Line or Plan ,Line or Plan","is_parallel(line(0,i),line(1,1+i));is_parallel(line([2,3,-2],[-1,-1,-1]),plane([-1,-1,-1],[1,2,-3],[0,0,0]));is_parallel(line([0,0,0],[-1,-1,-1]),line([2,3,-2],[-1,-1,-1]))","is_perpendicular"},
{"is_parallelogram",{"Renvoie 1,2,3 ou 4 si les 4 points (ou l'objet) forment un parallélogramme, (2 pour un losange, 3 pour un rectangle et 4 pour un carré) et 0 sinon.","Returns 1,2,3 or 4 if the 4 points (or the object) built a parallelogram, (2 for a rhombus, 3 for a rectangle, 4 for a square) and 0 otherwise.",0,0},"Pnt or Cplx,Pnt or Cplx,Pnt or Cplx,Pnt or Cplx","is_parallelogram(0,i,1+i,1);is_parallelogram(1,-1,i,-i);is_parallelogram(sommets(parallelogram(1,-1,-i,C)))","est_rectangle,is_square,is_rhombus"},
{"is_permu",{"Renvoie 1 si l'argument est une permutation de [0,1..s-1] et 0 sinon","Returns 1 if the argument is a permutation and 0 otherwise",0,0},"Lst","is_permu([4,2,3,1]);is_permu([4,2,3,1,0])","is_cycle,permu2cycles"},
{"is_perpendicular",{"Renvoie 1 si 2 droites sont perpendiculaires","Returns 1 if 2 lines are perpendicular",0,0},"Line or Plan,Line or Plan","is_perpendicular(line(0,i),line(1,1+i));is_perpendicular(line([2,3,-2],[-1,-1,-1]),line([1,0,0],[1,2,8]));is_perpendicular(plane([0,0,0],[1,2,-3],[1,1,-2]),plane([-1,-1,-1],[1,2,-3],[0,0,0]));is_perpendicular(line([2,3,-2],[-1,-1,-1]),plane([0,0,0],[1,2,-3],[1,1,-2]))","is_parallel,is_orthogonal"},
{"is_prime",{"Test mixte, \"p-1\" de Pocklington [1] ou APRCL [2] (renvoie les coefficients prouvant la primalité, 1 ou 0)","Mixed or \"p-1\" Pocklington [1] or APRCL test [2] (returns the coefficients for a proof of primality, 1 or 0)",0,0},"Intg,[1 || 2]","is_prime(1999);is_prime(9856989898997);is_prime(9856989898997789789);is_prime(9856989898997789789,1)","prevprime,nextprime,is_pseudoprime,isprime"},
{"is_pseudoprime",{"Test de pseudo-primalité (0 non premier, 1 probablement premier, 2 premier)","Pseudo-prime test (0 not prime, 1 probably prime, 2 prime)",0,0},"Intg","is_pseudoprime(1999);is_pseudoprime(9856989898997);is_pseudoprime(9856989898997789789)","prevprime,nextprime,is_prime"},
{"is_rectangle",{"Renvoie 1, 2 ou 3 si les 3 points (ou l'objet) forment un triangle rectangle de sommet 1, 2 ou 3 et 0 sinon [ou 1 si les 4 points (ou l'objet) forment un rectangle, 2 si les 4 points (ou l'objet) forment un carré et 0 sinon].","Returns 1, 2 or 3 if the 3 points (or the object) built an rectangular triangle with vertex 1, 2 or 3 and 0 otherwise [or 1 if the 4 points (or the object) built a rectangle, 2 if the 4 points (or the object) built a square and 0 otherwise].",0,0},"Pnt||Cplx,Pnt||Cplx,Pnt||Cplx,[Pnt||Cplx]","is_rectangle(0,i,1+i);is_rectangle(point(0),point(1+i),point(2,2));is_rectangle(triangle(0,i,1+i));is_rectangle(point(0),point(2,2),point(1,3),point(-1,1));is_rectangle(rectangle(point(0),point(2,2),1/2));is_rectangle(sommets(rectangle(point(0),point(2,2),1/2)))","is_equilateral,is_isosceles,is_parallelogram,is_rhombus,is_square"},
{"is_rhombus",{"Renvoie 1 ou 2 si les 4 points (ou l'objet) forment un losange (2 pour un carré) et 0 sinon.","Returns 1 or 2 if the 4 points (or the object) built a rhombus (2 for a square) and 0 otherwise.",0,0},"Pnt or Cplx,Pnt or Cplx,Pnt or Cplx,Pnt or Cplx","is_rhombus(0,i,1+i,1);is_rhombus(1,-1,i,-i);is_rhombus(sommets(rhombus(1,-1,pi/4,C,D)))","est_rectangle,is_parallelogram,is_square"},
{"is_square",{"Renvoie 1 si les 4 points (ou l'objet) forment un carré et 0 sinon.","Returns 1 if the 4 points built a square and 0 otherwise.",0,0},"Pnt,Pnt,Pnt,Pnt","is_square(0,i,1+i,1);is_square(1,-1,i,-i);is_square(sommets(square(0,i,C,D)))","est_rectangle,is_parallelogram,is_rhombus"},
{"ismith",{"Calcule la forme normale de Smith d'une matrice A à coefficients entiers : renvoie U,B,V tels que U et V inversibles dans ℤ, B diagonale, B[j,j] divise B[j+1,j+1] et B=U*A*V.","Smith normal form of a matrix with coefficients in ℤ : returns U,B,V such that U and V invertible in ℤ, B diagonal, B[j,j] divide B[j+1,j+1] and B=U*A*V.",0,0},"Mtrx(A)","ismith([[9,-36,30],[-36,192,-180],[30,-180,180]]);ismith([[1,2,3],[4,5,6],[7,8,9]])","ihermite,smith"},
{"isobarycenter",{"isobarycentre(A,B,C,...) trace l'isobarycentre des n points A,B,C,...","isobarycenter(A,B,C,...) draws the isobarycenter of the n points A,B,C,...",0,0},"(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)","isobarycenter(-1,1-i,i)","barycenter,midpoint"},
{"isom",{"Recherche des éléments propres d'une isométrie 2-d ou 3-d","Find elements of a 2-d or 3-d isometry",0,0},"Mtrx","isom([[0,1],[1,0]])","mkisom"},
{"isopolygon",{"Trace un polygone régulier ayant abs(n) sommets, donné par 2 sommets (ou 2 sommets et 1 point du plan) si n>0 et par son centre et 1 sommet (ou son centre, 1 sommets et 1 point du plan) si n<0.","Draws a regular polygon having abs(n) vertices, given by 2 vertices (or 2 vertices and 1 point of the plane) if n>0 and by its center and 1 vertex (or its center, 1 vertex and 1 point of the plane) if n<0.",0,0},"Pnt,Pnt,[Pnt],Intg(n)","isopolygon(0,1,5);isopolygon(0,1,-5);isopolygon(point(0,0,0),point(3,3,3),point(0,0,3),5);isopolygon(point(0,0,0),point(3,3,3),point(0,0,3),-5)","polygon,hexagon"},
{"isosceles_triangle",{"Trace le triangle isocèle ABC AB=AC et angle(AB,AC)=t (ou dans le plan ABP angle(AB,AC)=angle(AB,AP) ou angle(AB,AC)=t).","Draws the isosceles triangle ABC AB=AC et angle(AB,AC)=t (or in the plane ABP angle(AB,AC)=angle(AB,AP) or angle(AB,AC)=t).",0,0},"(Pnt(A) or Cplx),(Pnt(B) or Cplx),(Angle(t) or Pnt(P) or Lst(P,t)),[Var(C)]","isosceles_triangle(i,1,pi/4);isosceles_triangle(1,i,pi/4,C);isosceles_triangle(point(0,0,0),point(3,3,3),point(0,0,3));isosceles_triangle(point(0,0,0),point(3,3,3),[point(0,0,3),pi/4],C)","triangle"},
{"isprime",{"Test de primalité (=true ou false).","Primality testing (=true or false).",0,0},"Intg(a)","isprime(1999);isprime(9856989898997);isprime(9856989898997789789)","prevprime,nextprime,is_prime,is_pseudoprime"},
{"ithprime",{"Renvoie le n-ième nombre premier (inférieur à 2.10^8).","Returns the n-th prime number less than 2.10^8.",0,0},"Intg(n)","ithprime(1229);ithprime(1000)","nextprime,prevprime"},
{"jacobi_linsolve",{"Résolution d'un système linéaire de matrice A et de second membre b, par la méthode itérative de Jacobi avec une tolérance de eps et un nombre maximal d'itérations de maxiter. ","Resolution of a linear system  A*X=b  by the iterative Jacobi method with eps as error margin  and a number of iterations inferior to maxiter.",0,0},"Mtrx(A),Vect(b),Real(eps),[Int(maxiter)]"," a:=[[100,2],[2,100]];jacobi_linsolve(a,[0,1],1e-12);; a:=[[100,2],[2,100]];jacobi_linsolve(table(a),[0,1],1e-12); ","gauss_seidel_linsolve,linsolve"},
{"jacobi_symbol",{"Symbole de Jacobi","Jacobi symbol",0,0},"Intg,Intg","jacobi_symbol(132,5);jacobi_symbol(132,25)","legendre_symbol"},
{"jordan",{"Renvoie la liste formée par la matrice de passage et la forme de Jordan d'une matrice.","Returns the list made by the matrix of passage and the Jordan form of a matrix.",0,0},"Mtrx","jordan([[0,2],[1,0]]);jordan([[-2,-2,1],[-2,1,-2],[1,-2,-2]]);jordan([[1,1,-1,2,-1],[2,0,1,-4,-1],[0,1,1,1,1],[0,1,2,0,1],[0,0,-3,3,-1]])","egv,egvl,rat_jordan"},
{"jusqu_a",{"Boucle repeter (effectue les instructions jusqu'à cond==true): repeter i1;i2;jusqua cond; ou repeat i1;i2; until cond;","Loop repeat (repeat the instructions until cond==true): repeat i1;i2; until cond; or repeter i1;i2;jusqua cond;",0,0},""," repeter jusqu_a ;; repeat x:=x-5 until x<5 ;; quoreste(a,b):={local q:=0;repeat a:=a-b;q:=q+1 until a<0;return q-1,a+b;};; x:=32;repeat x:=x-5 until x<5;; quoreste(a,b):={local q:=0;repeter a:=a-b;q:=q+1; jusqua a<0;return q-1,a+b;};; x:=32;repeter x:=x-5; jusqua x<5;; n:=1;repeter triangle_plein(10*n);saute(10*n);n:=n+1; jusqua n==5;; n:=4;repeter triangle_plein(10*n);saute(10*n);n:=n-1; jusqua n==0;","for,tantque"},
{"jusqua",{"Boucle repeter (effectue les instructions jusqu'à cond==true): repeter i1;i2;jusqua cond; ou repeat i1;i2; until cond;","Loop repeat (repeat the instructions until cond==true): repeat i1;i2; until cond; or repeter i1;i2;jusqua cond;",0,0},""," repeter jusqu_a ;; repeat x:=x-5 until x<5 ;; quoreste(a,b):={local q:=0;repeat a:=a-b;q:=q+1 until a<0;return q-1,a+b;};; x:=32;repeat x:=x-5 until x<5;; quoreste(a,b):={local q:=0;repeter a:=a-b;q:=q+1; jusqua a<0;return q-1,a+b;};; x:=32;repeter x:=x-5; jusqua x<5;; n:=1;repeter triangle_plein(10*n);saute(10*n);n:=n+1; jusqua n==5;; n:=4;repeter triangle_plein(10*n);saute(10*n);n:=n-1; jusqua n==0;","for,tantque"},
{"jusque",{"Utilisé dans une boucle pour (pour...de ...jusque... [pas...] faire...fpour;).","Used in a loop for (for...from ...to... [step...] do...od;).",0,0},""," pour de jusque [pas] faire fpour;; S:=0;pour n de 1 jusque 4 faire S:=S+n;fpour;; S:=0;for n from 1 to 4 do S:=S+n;end;; S:=0;pour n de 4 jusque 1 pas -1 faire S:=S+n;fpour;","for,pour,de,from"},
{"keep_algext",{"Laisse les extensions algébriques telles quelles (keep_algext:=1) ou tente de les réécrire (keep_algext:=0).","Pseudo-variable to keep algebraic extensions (keep_algext:=1) or try to rewrite them (keep_algext:=0).",0,0},":=Intg(0 or 1)"," keep_algext:=1",0},
{"keep_pivot",{"Option de la commande rref.","Option of the rref command.",0,0},"Opt"," rref([[1,1,0,0,-a1],[0,1,1,0,-a2],[0,0,1,1,-a3],[1,0,0,1,-a4]],keep_pivot)","rref"},
{"ker",{"Noyau d'une application linéaire de matrice M","Kernel of a linear application of matrix M",0,0},"Mtrx","ker([[1,2],[3,6]]);ker([[1,2,3],[1,3,6],[2,5,9]])","image,rref,Nullspace"},
{"kernel",{"Noyau d'une application linéaire de matrice M","Kernel of a linear application of matrix M",0,0},"Mtrx","ker([[1,2],[3,6]]);ker([[1,2,3],[1,3,6],[2,5,9]])","image,rref,Nullspace"},
{"kill",{"Arrête l'exécution d'un programme en mode pas-à-pas (avec debug)","Stop step-by-step execution of a program (with debug)",0,0},"NULL","kill()",""},
{"kolmogorovd",{"Distribution de Kolmogorov-Smirnov, 1-2*sum((-1)^(k-1)*exp(-k^2*x^2),k,1,inf)","Kolmogorov-Smirnov distribution, 1-2*sum((-1)^(k-1)*exp(-k^2*x^2),k,1,inf)",0,0},"Real(x)","kolmogorovd(1.36)",0},
{"kolmogorovt",{"Test de Kolmogorov-Smirnov d'adéquation à une loi de distribution continue, entre 2 échantillons l1 l2 (loi inconnue) ou entre 1 échantillon l1 et une loi s.","Kolmogorov-Smirnov adequation test to a continuous distribution law, between 2 samples l1 l2 (unknown law) or between a sample l1 and a distribution law s.",0,0},"Lst(l1),Lst(l2) || DistribLaw(s)","kolmogorovt(randvector(100,normald,0,1),randvector(100,normald,0,1));kolmogorovt(randvector(100,normald,0,1),randvector(100,normald,3,1));kolmogorovt(randvector(100,normald,0,1),normald(0,1));kolmogorovt(randvector(100,normald,0,1),student(2))","chisquaret,normalt,studentt"},
{"l1norm",{"Renvoie la norme l1 du vecteur=somme des valeurs absolues de ses coordonnées","Returns the l1 norm of the vector=sum of the absolute values of its coordinates or matrix norm according to l1.",0,0},"Vect","ou triple norme d'une matrice selon l1.;l1norm([3,-4,2]);l1norm([[1,2,3],[3,-9,6],[4,5,6]])","l2norm,maxnorm,matrixnorm"},
{"l2norm",{"Norme l2 d'un vecteur = sqrt(x1^2+x2^2+...xn^2) ou norme de matrice subordonnée à la norme l2.","Returns the l2 norm of a vector = sqrt(x1^2+x2^2+...xn^2) or matrix norm induced by l2 norm.",0,0},"Vect or Mtrx","norm([1,2]);norm([1,2,3,-4]);norm([[1,2],[3,-4]]);norm([[1,2,3],[3,-9,6],[4,5,6]])","maxnorm,l1norm"},
{"label",{"Dans un programme, permet de repérer une instruction par le label nom.","In a program, is used to mark an instruction with the label nom.",0,0},"Var(nom)"," essai(a):={label truc;a:=a+2;if (a<10) goto truc;print(a);}","goto"},
{"labels",{"labels=[\"u\",\"v\"] renomme les axes en \"u\" et \"v\".","labels=[\"u\",\"v\"] renames the axis with \"u\" and \"v\".",0,0},"Cplx or Lst,Str","legend(1+i,\"Hello\");legend([30,20],\"bonjour\"); legende=[\"m\",\"s\"];point(1,1);; display(legend(1+i,\"A\"),red)","legend,angle"},
{"lagrange",{"Renvoie le polynôme de degré n-1 tel que P(xk)=yk=f(x_k) k=0..n-1 ou la liste des differences divisees si le dernier argument est lagrange","Returns the polynomial of degree n-1 such that P(xk)=yk=f(x_k) k=0..n-1 or the list of divided differences if the last argument is lagrange",0,0},"(Lst_xk,Lst_yk)||Mtrx_2*n||(Lst_xk,Fnc(f)),[Var||[]||lagrange]","lagrange([1,3,4],[0,1,2]);lagrange([1,3,4],[0,1,2],t); f(x):=exp(-x); lagrange([1,3,4],f);lagrange([[1,3,4],[0,1,2]]);lagrange([1,3,4],[0,1,2],[]); X:=[1,3,4]; divdiff:=lagrange(X,[0,1,2],lagrange); horner(divdiff,X,5);;lagrange([[1,3,4],[0,1,2]],y);lagrange([-1,0,1],[1/e-1,0,e-1]); f(x):=exp(x)-1;lagrange([-1,0,1],f);lagrange([0,1,2],[1,exp(1),exp(2)],lagrange);lagrange([0,1,2],exp,lagrange)","spline"},
{"laguerre",{"Renvoie le n-ième polynôme de Laguerre","Returns the n-th Laguerre polynomial",0,0},"Intg(n)","laguerre(4)","legendre,hermite"},
{"laplace",{"Transformée de Laplace","Laplace transform",0,0},"Expr,[Var],[LapVar]","laplace(exp(x)*sin(x));laplace(sin(x)^2,x,s);laplace(Heaviside(x-1),x,s)","invlaplace,ztrans,invztrans,Heaviside"},
{"laplacian",{"Calcule le laplacien de l'expression Xpr par rapport à la liste de variables et laplacian(n) pour n entier ou flottant entier renvoie la matrice de taille n du laplacien discret en dimension 1. ","Returns the Laplacian of the expression Xpr with respect to the list of variables and laplacian(n) for n  integer or float integer returns the matrix of size n of the discret laplacian en dimension 1.",0,0},"Expr(Xpr),LstVar","-2;laplacian(exp(z)*cos(x*y),[x,y,z]);laplacian(3);laplacian(3.0)",""},
{"latex",{"L'expression évaluée est écrite en latex dans la réponse.","Returns the evaluated expression written in latex.",0,0},"Expr","latex(1/2);latex((x^4-1)/(x^2+3))","mathml"},
{"lcm",{"PPCM de 2 polynômes de plusieurs variables ou de 2 entiers ou de 2 rationnels.","Returns the lowest common multiple of 2 polynomials of several variables or of 2 integers or of 2 rationals.",0,0},"(Intg or Poly),(Intg or Poly)","lcm(6,4);lcm(1251,123);lcm(5/7,50/9);lcm(x^2-2*x+1,x^3-1);lcm(t^2-2*t+1,t^2+t-2);lcm((x^2-1)*(y^2-1)*z^2,x^3*y^3*z+(-(y^3))*z+x^3*z-z)","gcd"},
{"lcoeff",{"Renvoie le coefficient du terme de plus haut degré d'un polynôme (l=leading=dominant).","Returns the coefficient of the term of highest degree of a polynomial (l=leading).",0,0},"Poly||Lst","lcoeff(-2*x^3+x^2+7*x);lcoeff([-2,1,7,0])","tcoeff"},
{"ldegree",{"Renvoie la valuation (degré du terme de plus bas degré) du polynôme P.","Returns the valuation (degree of the term of lowest degree) of the polynomial P.",0,0},"Poly(P)","valuation(x^4+x^3);valuation([1,1,0,0,0]);valuation(x^5+3*x^2);valuation([5,0,0,3,0,0])","degree,tcoeff"},
{"left",{"Renvoie la partie gauche d'une égalité, d'un intervalle, d'une liste ou d'une chaîne.","Returns the left part of an equality, of an interval, of a list or of a string.",0,0},"Equal(a=b) or Interval(a..b) or Str,Intg","left(a=b);left(x^2+1=5);left(1..5);left(\"abcdefg\",3)","right,mid,tail,head"},
{"left_rectangle",{"Option de la commande plotarea et de la commande area.","Option of the plotarea command and of the area command.",0,0},"Opt"," plotarea(x^2,x=0..1,5,trapezoid); plotarea(x^2,x=0..1,5,middle_point); plotarea(x^2,x=0..1,5,right_rectangle); plotarea(x^2,x=0..1,5,left_rectangle); area(x^2,x=0..1,5,middle_point); area(x^2,x=0..1,5,trapezoid)","plotarea,area"},
{"legend",{"legende(za,\"ici\") (ou legende([20,60],\"ici\")) \"ici\" est écrit au point d'affixe za (ou à la position [20,60] en pixel) et legende=[\"m\",\"s\"] écrit \"m\",\"s\" comme unités sur les axes.","legend(za,\"here\") (or legend([20,60],\"here\")) \"here\" is written at the point of affix za (or at the pixel position [20,60]) and legend=[\"m\",\"s\"] write \"m\",\"s\" as units on the axis.",0,0},"Cplx or Lst,Str","legend(1+i,\"Hello\");legend(point([0,2,3],\"Hello\");legend(point(0,1),\"Hello\",vert);legend(point(0,1,0),\"Hello\",vert);legend(1+i,\"Hello\",quadrant4,red);legend([30,20],\"bonjour\"); r:=evalf(sqrt(2));legend([30,20],string(r)); r:=evalf(sqrt(2));legend([30,20],r); legende=[\"m\",\"s\"];point(1,1);; display(legend(1+i,\"A\"),red); point(2+i,legend=\"2+i\",display=quadrant2+red); point([2,2*i],legend=\"1+i\",display=quadrant2+red); polygon(2,1,i,2*i,legend=\"1+i\",display=quadrant2+red)","labels,angle"},
{"legendre",{"Renvoie le n-ième polynôme de Legendre","Returns the n-th Legendre polynomial",0,0},"Intg(n)","legendre(4)",""},
{"legendre_symbol",{"Symbole de Legendre.","Legendre symbol.",0,0},"Intg,Intg","legendre_symbol(132,5);legendre_symbol(132,25)","jacobi_symbol"},
{"len",{"Renvoie la longueur d'une liste, d'une chaîne de caractères ou d'une suite.","Returns the size of a list, a string or a sequence.",0,0},"Lst or Str or Seq","size([1,2,3]);size(\"bonjour\");size(1,2,3)","sizes,dim,degree"},
{"length",{"Renvoie la longueur d'une liste, d'une chaîne de caractères ou d'une suite.","Returns the size of a list, a string or a sequence.",0,0},"Lst or Str or Seq","size([1,2,3]);size(\"bonjour\");size(1,2,3)","sizes,dim,degree"},
{"leve_crayon",{"Lève le crayon pour que la tortue bouge sans laisser de traces.","Puts the pencil up so that the turtle moves without traces.",0,0},"NULL","leve_crayon()","baisse_crayon,crayon"},
{"lgcd",{"PGCD d'une liste de polynômes ou d'entiers","Returns the greatest common divisor of a list of polynomials or of integers",0,0},"Seq or Lst","lgcd([45,75,20,15]);lgcd([x^2-2*x+1,x^3-1,x-1]);lgcd(x^2-2*x+1,x^3-1,x-1)","gcd,lcm,euler,content"},
{"lhs",{"Renvoie la partie gauche d'une égalité, d'un intervalle, d'une liste ou d'une chaîne.","Returns the left part of an equality, of an interval, of a list or of a string.",0,0},"Equal(a=b) or Interval(a..b) or Str,Intg","left(a=b);left(x^2+1=5);left(1..5);left(\"abcdefg\",3)","right,mid,tail,head"},
{"ligne_chapeau_carre",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); d:=display(line(2+i,1),cap_round_line)","display"},
{"ligne_chapeau_plat",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); d:=display(line(2+i,1),cap_round_line)","display"},
{"ligne_chapeau_rond",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); d:=display(line(2+i,1),cap_round_line)","display"},
{"ligne_polygonale",{"Dessine les polygones joignant pour j fixé et pour k=0..nrows, les points (xk,yk) où xk=élément ligne k colonne 0 et yk=élément ligne k colonne j en ordonnant les xk (on obtient ncols-1 polygones).","Draws the polygons joining for j fixed and for k=0..nrows, the points (xk,yk) where xk=element row k column 0 et yk=element row k column j ,when the xk are sorted (we obtain ncols-1 polygons).",0,0},"Mtrx","polygonplot([[1,2,3],[2,0,1],[-1,2,3]])","scatterplot,listplot,polygonscatterplot"},
{"ligne_polygonale_pointee",{"Dessine les points (xk,yk) et les polygones joignant pour j fixé et pour k=0..nrows, les points (xk,yk) où xk=élément ligne k colonne 0 et yk=élément ligne k colonne j en ordonnant les xk (on obtient ncols-1 polygones).","Draws the points (xk,yk) and the polygons joining for j fixed and for k=0..nrows, the points (xk,yk) where xk=element row k column 0 et yk=element row k column j ,when the xk are sorted (we obtain ncols-1 polygons).",0,0},"Mtrx","polygonscatterplot([[1,2,3],[2,0,1],[-1,2,3]])","scatterplot,polygonplot,listplot"},
{"ligne_tiret",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); d:=display(line(2+i,1),cap_round_line)","display"},
{"ligne_tiret_point",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); d:=display(line(2+i,1),cap_round_line)","display"},
{"ligne_tiret_pointpoint",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); d:=display(line(2+i,1),cap_round_line)","display"},
{"ligne_trait_plein",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); d:=display(line(2+i,1),cap_round_line)","display"},
{"limit",{"Limite d'une expression en un point (a or +/-infinity)(d=-1 pour limite inf et +1 pour limite sup).","Limit of an expression at a limit point (a or +/-infinity)(d=-1 for limit inf and +1 for limit sup).",0,0},"Expr,Var,Val,[Dir(d)]","limit((n*tan(x)-tan(n*x))/(sin(n*x)-n*sin(x)),x,0);limit(sin(x)/(x^2-3*x),x,0);limit((2*x-1)/exp(1/(x-1)),x,+infinity);limit(exp(1/x),x,0,1);limit(exp(1/x),x,0,-1);limit(taux_accroissement(x^n,1,1+h),h,0)","series,taylor,taux_accroissement"},
{"limite",{"Limite d'une expression en un point (a or +/-infinity)(d=-1 pour limite inf et +1 pour limite sup).","Limit of an expression at a limit point (a or +/-infinity)(d=-1 for limit inf and +1 for limit sup).",0,0},"Expr,Var,Val,[Dir(d)]","limit((n*tan(x)-tan(n*x))/(sin(n*x)-n*sin(x)),x,0);limit(sin(x)/(x^2-3*x),x,0);limit((2*x-1)/exp(1/(x-1)),x,+infinity);limit(exp(1/x),x,0,1);limit(exp(1/x),x,0,-1);limit(taux_accroissement(x^n,1,1+h),h,0)","series,taylor,taux_accroissement"},
{"lin",{"Linéarisation des exponentielles","Linearization of exponentials",0,0},"Expr","lin(exp(x)^n);lin((exp(x)^3+exp(x))^2)","tlin,texpand"},
{"line",{"droite(A,B) (resp droite(A,pente=m) ou droite(A,[1,m]) ou droite(a*x+b*y+c=0) ou droite(a*x+b*y+c*z+d=0,aa*x+bb*y+cc*z+dd=0) ou droite(A,u)) trace la droite AB (resp la droite passant par A et de pente m ou de vecteur directeur u ou d'équation l'argument) dans le plan ou dans l'espace 3D.","line(A,B) (resp line(A,slope=m) or line(A,[1,m]) or line(a*x+b*y+c=0) or line(a*x+b*y+c*z+d=0,aa*x+bb*y+cc*z+dd=0) or line(A,u)) draws the line AB (resp the line going through A with slope m or with direction vector u or of equation the argument) in the plane or in the 3D space.",0,0},"Pnt||Cplx||Eq,[Pnt||slope||Var]","line(i,1+i);line(point(-i),point(1+i));line(1+i,slope=2);line([0,0,0],[1,1,1]);line(x+y=1);line(x+y+z=0,x+y=0);line([1+t,-1+t],t);line([1+t,2-t,-1+3*t],t);line(1-i,slope=slope(line(1,2i)))","point,plane,slope"},
{"line_inter",{"Donne l'une des intersections de 2 courbes ou surfaces (ou l'intersection le plus près de A ou qui n'est pas dans L).","Gives one of the intersections of 2 curves or surfaces (or the intersection near A or not in L).",0,0},"Curve,Curve,[Pnt(A)||LstPnt(L)]","single_inter(line(i,1-i),line(0,1));single_inter(line(i,1-i),circle(0,1));single_inter(line(i,1+2*i),circle(0,1),[point(i)]);single_inter(line(-1-i,1+2*i),circle(0,1),point(-1));single_inter(circle(1,sqrt(2)),circle(0,1));single_inter(plane(x=y),plane(y=z));single_inter(line(x=y+1,y=2*z),plane(y=z))","intersect,head"},
{"line_paper",{"Trace dans le rectangle [xmin..xmax]*[ymin..ymax], les droites x=n*ux dans le repère OxY d'angle t!=0.","Draws in the rectangle [xmin..xmax]*[ymin..ymax], the lines x=n*ux in the axes OxY of angle t!=0.",0,0},"Real(ux),Real(t),[x=xmin..xmax,y=ymin..ymax]","line_paper(0.4,pi/3);line_paper(0.4,pi/3,x=-1..4,y=-2..2);line_paper(0.5,3*pi/4)",0},
{"line_segments",{"Renvoie la liste des arêtes (1 arête=segment) du polyèdre P.","Returns the list of the line_segments (1 line=segment) of the polyhedron P.",0,0},"Polygon or Polyedr(P)","line_segments(polyhedron([0,0,0],[0,5,0],[0,0,5],[1,2,6]));line_segments(polyhedron([0,0,0],[0,5,0],[0,0,5],[1,2,6]))[2]","polyhedron"},
{"line_width_1",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); display(segment(0,1+i),line_width_5); segment(1,i,affichage=epaisseur_ligne_4)","display,thickness"},
{"line_width_2",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); display(segment(0,1+i),line_width_5); segment(1,i,affichage=epaisseur_ligne_4)","display,thickness"},
{"line_width_3",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); display(segment(0,1+i),line_width_5); segment(1,i,affichage=epaisseur_ligne_4)","display,thickness"},
{"line_width_4",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); display(segment(0,1+i),line_width_5); segment(1,i,affichage=epaisseur_ligne_4)","display,thickness"},
{"line_width_5",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); display(segment(0,1+i),line_width_5); segment(1,i,affichage=epaisseur_ligne_4)","display,thickness"},
{"line_width_6",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); display(segment(0,1+i),line_width_5); segment(1,i,affichage=epaisseur_ligne_4)","display,thickness"},
{"line_width_7",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); display(segment(0,1+i),line_width_5); segment(1,i,affichage=epaisseur_ligne_4)","display,thickness"},
{"linear_interpolate",{"Échantillonne de manière régulière une ligne polygonale définie par une matrice à 2 lignes","Make a regular sample from a polygonal line defined by a 2 rows matrix",0,0},"Mtrx,xmin,xmax,xstep","linear_interpolate([[1,2,6,9],[3,4,6,7]],1,9,1)","polygonplot"},
{"linear_regression",{"Renvoie les coefficients a et b de y=a*x+b : c'est la droite qui approche le mieux les points ayant pour coordonnées les lignes de A (ou les 2 listes).","Returns the coefficients a and b of y=a*x+b ;it is the best line approx the points where the coordinates are the rows of A (or the 2 lists).",0,0},"Lst||Mtrx(A),[Lst]","linear_regression([[0.0,0.0],[1.0,1.0],[2.0,4.0],[3.0,9.0],[4.0,16.0]]);linear_regression([0.0,1.0,2.0,3.0,4.0],[0.0,1.0,4.0,9.0,16.0])","polynomial_regression,power_regression,logistic_regression"},
{"linear_regression_plot",{"Renvoie le graphe de y=a*x+b : c'est la droite qui approche le mieux les points ayant pour coordonnées les lignes de A (ou les 2 listes).","Returns the plot of y=a*x+b ;it is the best line approx the points where the coordinates are the rows of A (or the 2 lists).",0,0},"Lst||Mtrx(A),[Lst]","linear_regression_plot([[0.0,0.0],[1.0,1.0],[2.0,4.0],[3.0,9.0],[4.0,16.0]]);linear_regression_plot([0.0,1.0,2.0,3.0,4.0],[0.0,1.0,4.0,9.0,16.0])","polynomial_regression_plot,power_regression_plot"},
{"lineariser",{"Linéarisation des exponentielles","Linearization of exponentials",0,0},"Expr","lin(exp(x)^n);lin((exp(x)^3+exp(x))^2)","tlin,texpand"},
{"lineariser_trigo",{"Linéarisation trigonométrique","Trigonometric linearization",0,0},"ExprTrig","tlin(sin(x)^3);tlin(cos(x)*cos(y))","texpand,lin"},
{"linsolve",{"Résolution d'un système d'équations linéaires.","Linear equations system solver.",0,0},"LstLinEq,LstVar","linsolve([x+y+z=1,x-y=2,2*x-z=3],[x,y,z]);linsolve([m*x+y=a,x+m*y=b],[x,y]);linsolve([x+y-z-1,x-y+1,x-y-z-1]%2,[x,y,z]);linsolve([[3,4],[1,2]],[0,1]); p,l,u:=lu([[3,4],[1,2]]); linsolve(p,l,u,[0,1]) ;linsolve([2*x+y+z=1,x+y+2*z=1,x+2*y+z=4],[x,y,z]);linsolve([[2,1,1],[1,1,2],[1,2,1]],[1,1,4]); p,l,u:=lu([[2,1,1],[1,1,2],[1,2,1]]);linsolve(p,l,u,[1,1,4]); a:=[[100,2],[2,100]];linsolve(evalf(a),[0,1]);","solve,proot,simult,gaussjord,pivot,ref,conjugate_gradient"},
{"linspace",{"linspace(a,b,n) génère une liste de n éléments régulièrement espacés entre a et b, par défaut n=100 (commande compatible scilab).","linspace(a,b,n) creates a list of n elements at regular intervals between a and b, by defaut n=100 (compatibility with scilab).",0,0},"Real(a),Real(b),[Int(n)]","linspace(0,1,11)",0},
{"lis",{"Instruction dans un programme permettant l'entrée d'une expression qui sera stockée dans var.","Instruction in a program so that you can input an expression and store it in var.",0,0},"[Str],Var(var)","input(\"age\",a)","InputStr,output"},
{"lis_phrase",{"Instruction dans un programme permettant l'entrée d'une chaîne de caractères qui sera stockée dans var.","Instruction in a program so that you can input a string and store it in var.",0,0},"[Str],Var(var)","InputStr(\"nom?\",N)","input"},
{"list",{"Option de la commande convert ou convertir (n-poly=>list).","Option of the convert or convertir command (n-poly=>list).",0,0},"Opt"," convert(symb2poly(10x^3*y+12x^2*y^2,[x,y]),list)","symb2poly,convert"},
{"list2exp",{"Fonction inverse de exp2list","Invert exp2list",0,0},"List","list2exp([[3,9],[- 1,1]],[x, y])","exp2list"},
{"list2mat",{"Renvoie la matrice ayant n colonnes dont les termes sont donnés par l complétée éventuellement par 0.","Returns the matrix with n columns and where terms are the list l completed eventually by 0.",0,0},"Lst(l),Intg(n)","list2mat([1,8,4,9],1);list2mat([1,8,4,9],2)","mat2list"},
{"listplot",{"Trace la ligne polygonale reliant les points d'abscisse 0,...,n et d'ordonnée l=[y0,...,yn] ou la ligne reliant les points d'abscisse la première colonne de M et d'ordonnée sa deuxième colonne.","Draws the polygonal line through the points of abscissa 0,...,n and ordinate l=[y0,...,yn] or the line through the points of abscissa the first M column and ordinate the second column.",0,0},"Lst(l)||Mtrx(M)","listplot([13,10,15,16]);listplot([1,13],[2,10],[3,15],[4,16]);listplot([[0,13],[2,10],[4,15]])","polygonplot,scatterplot,polygonscatterplot"},
{"lll",{"(S,A,L,O):=lll(M), base courte du réseau engendré (L*O=A*M=S).","(S,A,L,O):=lll(M), short basis of a lattice (L*O=A*M=S).",0,0},"Mtrx","lll([[1234,3452,4521],[3425,2241,1543],[5643,3425,8721]])",0},
{"ln",{"Logarithme népérien ou Option de la commande convert ou convertir (id trig2exp).","Natural logarithm or Option of the convert or convertir command (id trig2exp).",0,0},"Expr or Opt","ln(1);ln(e); convert(cos(x),ln)","exp,convert,trig2exp,log10"},
{"lname",{"Liste des variables de l'expression.","List of variables in the expression.",0,0},"Expr","lname(exp(x)*2*sin(y))","has,lvar"},
{"lncollect",{"Rassemble les logarithmes. Applique ln(a)+n*ln(b)->ln(a*b^n) pour n entier.","Collect logarithms. Applies ln(a)+n*ln(b)->ln(a*b^n) for integers n.",0,0},"Expr","lncollect(ln(x)+2*ln(y))","texpand"},
{"lnexpand",{"Développe les logarithmes.","Expands logarithms.",0,0},"Expr","lnexpand(ln(3*x))","texpand,expexpand,trigexpand"},
{"local",{"Définit des variables locales: f(x):={local (var1:=x),var2; instruction;};","Local variables definition: f(x):={local (var1:=x),var2; instruction;};",0,0},""," f2(x):={local (a:=2),b; b:=a*x; return b;}; f2(x):={var (a:=2),b; b:=a*x; return b;}","for,if,->,{}"},
{"locus",{"lieu(M,A) trace le lieu de M (ou lieu(d,A) trace l'enveloppe de d) quand A:=element(C) (C est une courbe). Les instructions des exemples ci-après, doivent être écrites dans un niveau de géométrie sur des lignes différentes.","locus(M,A) draws the locus of M (or locus(d,A) draws the envelope of d) when A:=element(C) (C is a curve). The example instructions below, must be written in a geometric level on different lines.",0,0},"Pnt,Elem"," A:=element(circle(i,1+i));M:=homothety(0,2,A);locus(M,A); A:=element(line(x=0));d:=perpen_bisector(1,A);locus(d,A)","envelope,trace"},
{"log",{"Logarithme népérien ou Option de la commande convert ou convertir (id trig2exp).","Natural logarithm or Option of the convert or convertir command (id trig2exp).",0,0},"Expr or Opt","ln(1);ln(e); convert(cos(x),ln)","exp,convert,trig2exp,log10"},
{"log10",{"Logarithme à base 10.","Common logarithm (base 10).",0,0},"Expr","log10(10)","alog10,ln"},
{"logarithmic_regression",{"Renvoie les coefficients (m, b) de y=m*ln(x)+b : c'est le logarithme qui approche le mieux les points ayant pour coordonnées les lignes de A (ou les 2 listes).","Returns the coefficients a and b of y=a*ln(x)+b : it is the best logarithm which approx the points where the coordinates are the rows of A (or the 2 lists).",0,0},"Lst||Mtrx(A),[Lst]","logarithmic_regression([[1.0,1.0],[2.0,4.0],[3.0,9.0],[4.0,16.0]]);logarithmic_regression([1.0,2.0,3.0,4.0],[1.0,4.0,9.0,16.0])","exponential_regression"},
{"logarithmic_regression_plot",{"Renvoie le graphe de y=m*ln(x)+b : c'est le logarithme qui approche le mieux les points ayant pour coordonnées les lignes de A (ou les 2 listes).","Returns the plot of y=a*ln(x)+b : it is the best logarithm which approx the points where the coordinates are the rows of A (or the 2 lists).",0,0},"Lst||Mtrx(A),[Lst]","logarithmic_regression_plot([[1.0,1.0],[2.0,4.0],[3.0,9.0],[4.0,16.0]]);logarithmic_regression_plot([1.0,2.0,3.0,4.0],[1.0,4.0,9.0,16.0])","exponential_regression_plot"},
{"logb",{"Logarithme à base b.","Logarithm of base b.",0,0},"Real","logb(5,2);logb(7,10)","log,log10"},
{"logistic_regression",{"Renvoie y,y',C,y'max,xmax,R : y est une fonction logistique (sol de y'/y=a*y+b) telle que y(x0)=y0 et dont le y' approche au mieux les valeurs de L pour x=x0, x0+1...x0+k.","Returns y,y',C,y'max,xmax,R : y is a logistic function (sol of y'/y=a*y+b), such that y(x0)=y0 and where [y'(x0),y'(x0+1)...] is the best approximation of L.",0,0},"Lst(L),Real(x0),Real(y0)","logistic_regression(evalf([1,2,4,6,8,7,5]),1,2);logistic_regression([0.0,1.0,2.0,3.0,4.0],0.0,1.0)","polynomial_regression,power_regression,linear_regression"},
{"logistic_regression_plot",{"Renvoie le graphe de la fonction logistique y telle que y(x0)=y0 et dont le y' approche au mieux les valeurs de L pour x=x0, x0+1...x0+k.","Returns the plot of a logistic function y such that y(x0)=y0 and where [y'(x0),y'(x0+1)...] is the best approximation of L.",0,0},"Lst(L),Real(x0),Real(y0)","logistic_regression_plot(evalf([1,2,4,6,8,7,5]),1,2);logistic_regression_plot([0.0,1.0,2.0,3.0,4.0],0.0,1.0)","polynomial_regression_plot,power_regression_plot,linear_regression_plot"},
{"lp_assume",{"Options de la commande lpsolve","Options for lpsolve command",0,0},"Opt",0,"lpsolve"},
{"lp_binary",{"Options de la commande lpsolve","Options for lpsolve command",0,0},"Opt",0,"lpsolve"},
{"lp_binaryvariables",{"Options de la commande lpsolve","Options for lpsolve command",0,0},"Opt",0,"lpsolve"},
{"lp_depthlimit",{"Options de la commande lpsolve","Options for lpsolve command",0,0},"Opt",0,"lpsolve"},
{"lp_integer",{"Options de la commande lpsolve","Options for lpsolve command",0,0},"Opt",0,"lpsolve"},
{"lp_integervariables",{"Options de la commande lpsolve","Options for lpsolve command",0,0},"Opt",0,"lpsolve"},
{"lp_maximize",{"Options de la commande lpsolve","Options for lpsolve command",0,0},"Opt",0,"lpsolve"},
{"lp_nonnegative",{"Options de la commande lpsolve","Options for lpsolve command",0,0},"Opt",0,"lpsolve"},
{"lp_nonnegint",{"Options de la commande lpsolve","Options for lpsolve command",0,0},"Opt",0,"lpsolve"},
{"lp_variables",{"Options de la commande lpsolve","Options for lpsolve command",0,0},"Opt",0,"lpsolve"},
{"lpsolve",{"Resoud un probleme d'optimisation lineaire de fonction objectif o sous contraintes optionnelles c","solves a (mixed integer/binary) LP problem in general form",0,0},"Expr(o),[List(c)],[bounds],[options]","lpsolve(2x+y-z+4,[x<=1,y>=2,x+3y-z=2,2x-y+z<=8,-x+y<=5]);lpsolve(-4x-5y,[x+2y<=6,5x+4y<=20,0<=x,0<=y]);lpsolve(-7x+2y,[4x-12y<=20,-x+3y<=3],x=-5..5,y=0..inf,lp_maximize=true);lpsolve(x-y-2z+3,[-3x-y+z<=3,2x-3y>=4z,x-z=y,x>=0,y<=0],lp_maximize);lpsolve(-x-y,[y<=3x+1/2,y<=-5x+2],assume=lp_nonnegative);lpsolve(x+y,[x<=8,-x+y<=4,-x+2y>=6,2x+y<=25,3x+y>=18,-x+2y>=6],assume=lp_nonnegative);lpsolve(45.55x1+21.87x2,[1.64x1+2.67x2<=31.2,2.11x1+2.3x2>=13.9],assume=lp_nonnegative);lpsolve(3x+4y,[x<=4,x+3y<=15,-x+2y>=5,x-y>=9,x+y=6],assume=lp_nonnegative,lp_maximize=true);lpsolve(-6x+4y+z,[5x-10y<=20,2z-3y=6,-x+3y<=3],x=1..20,y=0..inf);lpsolve(-5x-7y,[7x+y<=35,-x+3y<=6],assume=integer);lpsolve(x+3y+3z,[x+3y+2z<=7,2x+2y+z<=11],assume=lp_nonnegative,lp_integervariables=[x,z],lp_maximize);lpsolve(2x+5y,[3x-y=1,x-y<=5],assume=nonnegint);lpsolve(x1+x2,[2x1+5x2<=16,6x1+5x2<=30],assume=nonnegint,lp_maximize);lpsolve(8x1+11x2+6x3+4x4,[5x1+7x2+4x3+3x4<=14],assume=lp_binary,lp_maximize)",0},
{"lsmod",{"Affiche les librairies dynamiques installées.","Displays the installed dynamic libraries.",0,0},"NULL","lsmod()","insmod,rmmod"},
{"lsq",{"Renvoie le vecteur (resp la matrice) X qui minimise la norme euclidienne (resp de Frobenius) de A*X-B correspondant au(x) système(s) linéaire(s) A*X=B lorsque B est un vecteur (resp une matrice).","Returns the vector (resp matrix) X which is the minimum of the euclidean (resp Frobenius) norm of A*X-B corresponding to the linear system A*X=B when B is a vector (resp matrix).",0,0},"Mtrx(A),(Mtrx || Vect)(B)","LSQ([[1,2],[3,4]],[5,11]);LSQ([[1,2],[3,4]],[[5,-1],[11,-1]])","lu,QR"},
{"lu",{"Pour A une matrice numérique, renvoie p permutation, L et U tels que PA=LU (P=permu2mat(p)).","For a numerical matrix A, returns p permutation, L and U such that PA=LU (P=permu2mat(p)).",0,0},"Mtrx","lu([[1,2],[3,4]]);lu([[6,12,18],[5,14,31],[3,8,18]])","qr,cholesky,LU"},
{"lvar",{"Liste des variables d'un objet (avec dépendance rationnelle).","List of variables of an object (with rational dependence).",0,0},"Expr","lvar(exp(x)*2*sin(y));lvar(exp(x)*2*sin(y)+ln(x))","lname,has"},
{"mRow",{"Multiplie la ligne n1 de la matrice A par Xpr.","Multiplies the row n1 of the matrix A by Xpr.",0,0},"Expr(Xpr),Mtrx(A),Intg(n1)","mRow(12,[[1,2],[3,4],[5,6]],0)","rowAdd,mRowAdd"},
{"mRowAdd",{"Multiplie la ligne n1 de la matrice A par Xpr, puis l'ajoute à la ligne n2.","Multiplies the row n1 of the matrix A by Xpr, then adds it to the row n2.",0,0},"Expr(Xpr),Mtrx(A),Intg(n1),Intg(n2)","mRowAdd(12,[[1,2],[3,4],[5,6]],0,2)","rowAdd,mRow"},
{"magenta",{"Option de la commande affichage (ou display) pour afficher en couleur.","Option of the display command to display with color.",0,0},"Opt"," F:=display(point(2+1.5*i),red); F:=display(point(2+1.5*i),point_point+green)","display"},
{"makelist",{"Renvoie une liste faite à partir d'une fonction ou d'une constante.","Returns a list made with a function or with a constant.",0,0},"Fnc,InitVal,FinalVal,StepVal","makelist(x->x^2,1,10,2);makelist(4,1,10);makelist(4,5,10);makelist(x->ifte(x<5,\"A\",\"B\"),1,10)","seq,range,makemat,$"},
{"makemat",{"Crée une matrice à partir de la fonction f.","Create a matrix.",0,0},"Fnct(f),RowsNumb,ColsNumb","makemat((j,k)->j+k,3,2);makemat((j,k)->1/(j+k+1),2,3);makemat(sqrt(2),2,3)","matrix"},
{"makesuite",{"Renvoie une séquence faite à partir d'un vecteur.","Returns a sequence made with a vector.",0,0},"Vect||Lst","makesuite([1,2,3])","makevector,op"},
{"makevector",{"Renvoie un vecteur fait à partir d'une séquence.","Returns a vector made with a sequence.",0,0},"Seq","makevector(1,2,3)","makesuite"},
{"map",{"Applique la fonction f à tous les éléments de la liste l ou à un polynôme donné au format interne.","Apply the function f at the elements of the list l or at a polynomial of internal format.",0,0},"Lst(l),Fnc(f)","map([1,2,3],x->x^3);map([1,2,3],unapply(x^3,x));map(%%%{1,[2,0]%%%}+%%%{2,[1,1]%%%},(a,b,c)->a*(b+2*c))","apply,set,unapply"},
{"maple2mupad",{"maple2mupad(\"fichier1\",\"fichier2\") traduit fichier1(Maple) en fichier2(MuPAD).","maple2mupad(\"file1\",\"file2\") translate file1(Maple) to file2(MuPAD).",0,0},"Str(\"Name_Maplefile\"),Str(\"Name_Mupadfile\")",0,"maple2xcas"},
{"maple2xcas",{"maple2xcas(\"fichier1\",\"fichier2\") traduit fichier1(Maple) en fichier2(Xcas).","maple2xcas(\"file1\",\"file2\") translate file1(Maple) to file2(Xcas).",0,0},"Str(\"NameMapleFile\"),Str(\"NameXcasFile\")",0,"maple2mupad"},
{"maple_ifactors",{"Renvoie 1 ou -1 pour le signe et les facteurs premiers avec leur ordre de multiplicité de n sous la forme d'une matrice comme ifactors en Maple.","Returns 1 or -1 for the sign and the prime factors with their multiplicity of n in a matrix such as ifactors in Maple.",0,0},"Intg(n)","maple_ifactors(120)","ifactors"},
{"maple_mode",{"Passe en mode Xcas (0), Maple (1), Mupad (2), TI89 (3).","Switches to mode Xcas (0), Maple (1), Mupad (2), TI89 (3).",0,0},"Intg(0) or 1 or 2 or 3","maple_mode(1);maple_mode(0)",0},
{"markov",{"Calcul des éléments propres d'une matrice de transition d'une chaîne de Markov M, renvoie la liste des suites d'états récurrents positifs, la liste des probabilités stationnaires correspondants, la liste des autres composantes fortement connexes, la liste des probabilités de finir sur les états récurrents positifs.","Computation of the proper elements of a Markov chain transition matrix M, returns the list of sequence of positive recurrent states, the list of corresponding invariant probabilities, the list of other strong connected components, the list of probability to end up in the sequence of recurrent states.",0,0},"Mtrx(M),[Real(eps)]","markov([[0,0,1/2,0,1/2],[0,0,1,0,0],[1/4,1/4,0,1/4,1/4],[0,0,1/2,0,1/2],[0,0,0,0,1]])","randmarkov,plotproba"},
{"mat2list",{"Renvoie la liste contenant les termes de la matrice.","Returns the list of the terms of the matrix.",0,0},"Mtrx","mat2list([[1,8],[4,9]])","list2mat,flatten"},
{"mathml",{"Convertit l'expression en une chaîne qui permet d'afficher des maths pour le web.","Converts the expression into a string so that we can display maths for the web.",0,0},"Expr","mathml(1/2)","latex"},
{"matpow",{"Élève une matrice carrée à la puissance n en la jordanisant","Calculates the n power of a matrix by jordanization",0,0},"Mtrx,Intg(n)","matpow([[1,2],[3,4]],n)","&^,^"},
{"matrix",{"Crée une matrice m(j,k) de p lignes et q colonnes, m(j,k)=f(j,k) ou m(j,k)=a avec des indices qui commencent à 0 ou 1 selon le mode Xcas ou Maple (ou option de apply) ou crée une matrice à partir d'une table.","Make a matrix m(j,k) with p rows and q cols, m(j,k)=f(j,k) or m(j,k)=a : the index start at 0 or 1 according to the mode (Xcas or Maple) (or option of apply) or make a maytice with a table.",0,0},"Intg(p),Intg(q),(Fnc(f) or Val(a))","matrix(2,3,(j,k)->1/(j+k+1));matrix(3,2,(j,k)->j+k);matrix(2,3,4);  A[0..2,0..2]:=1;A[0..1,1..2]:=2;a:=matrix(A) ","makemat,makelist,apply"},
{"matrix_norm",{"Triple norme d'une matrice subordonnée soit à la norme l1, soit à la norme l2, soit à la norme linfini.","Matrix norm   induced by l1norm or by l2norm or by linfinty norm.",0,0},"Mtrx,[2]||[inf]","matrix_norm([[1,2,3],[3,-9,6],[4,5,6]]);matrix_norm([[1,2,3],[3,-9,6],[4,5,6]],1);matrix_norm([[1,2,3],[3,-9,6],[4,5,6]],2);matrix_norm([[1,2,3],[3,-9,6],[4,5,6]],inf)","l1norm,l2 norm,linfnorm,frobenius_norm"},
{"max",{"Maximum des éléments d'une séquence ou d'une liste de réels.","Maximum of elements of a sequence or a list of reals.",0,0},"Seq||Lst","max(25,35)","min"},
{"maximize",{"Recherche du minimum ou maximum d'une fonction","Minimize a function",0,0},"Expr,[Constr],Vars,[Options]","minimize(sin(x),[x=0..4]);minimize(x^4-x^2,x=-3..3,locus);minimize(piecewise(x<=-2,x+6,x<=1,x^2,3/2-x/2),x=-3..2);minimize(x^2-3x+y^2+3y+3,[x=2..4,y=-4..-2],point);minimize(2x^2-y^2+6y,x^2+y^2<=16,[x,y]);minimize(sqrt(x^2+y^2)-z,[x^2+y^2<=16,x+y+z=10],[x,y,z]);minimize((1+x^2+3y+5x-4*x*y)/(1+x^2+y^2),x^2/4+y^2/3=9,[x,y]);minimize(cos(x)^2+cos(y)^2,x+y=pi/4,[x,y],locus)",0},
{"maxnorm",{"Norme du max d'un vecteur (ou d'une matrice): maxnorm([x1,x2,..,xn])=max(|x1|,..,|xn|).","Norm with the max of a vector (or of a matrix): maxnorm([x1,x2,..,xn])=max(|x1|,..,|xn|).",0,0},"Vect or Mtrx","maxnorm([1,2]);maxnorm([1,2,3,-4]);maxnorm([[1,2],[3,-4]])","l2norm,l1norm"},
{"mean",{"Moyenne d'une liste pondérée par le deuxième argument ou des colonnes d'une matrice.","Mean of a list with the second argument as pound or of the columns of a matrix.",0,0},"Lst||Mtrx,[Lst]","mean([1,2,3]);mean([1,2,3],[1,2,3]);mean([[1,2,3],[1,2,3]])","stddev"},
{"median",{"Renvoie la médiane d'une liste pondérée par le deuxième argument ou des colonnes d'une matrice.","Returns the median of a list with the second argument as pound or of the columns of a matrix.",0,0},"Lst||Mtrx,[Lst]","median([1,2,3,5,10,4]);median([1,2,3,5,10,4],[1,2,3,1,2,3])","quartiles"},
{"median_line",{"mediane(A,B,C) trace la médiane issue de A du triangle ABC","median_line(A,B,C) draws the median-line through A of the triangle ABC",0,0},"(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)","median_line(-1,1-i,i)","midpoint,perpen_bisector"},
{"member",{"Teste si e est dans la liste ou ensemble l (=0 ou k+1 avec l[k]=e).","Tests if e is in the list or set l (=0 or k+1 with l[k]=e).",0,0},"Elem(e),(Lst(l) or Set(l))","member(1,[4,3,1,2]);member(1,%{4,3,1,2%})","contains,est_element"},
{"mgf",{"Renvoie la fonction génératrice des moments d'une loi de probabilité parmi les lois normales, binomiales, Poisson, beta, gamma","Returns the moment generating function of a probability distribution from normal, binomial, Poisson, beta, gamma distribution",0,0},"Func,[Real(Param_1),Real(Param_2)]","mgf(normald,1,0);mgf(poisson,5);mgf(binomial,n,p)",0},
{"mid",{"Renvoie la liste de n éléments (par défaut n=size(l)-d) extraite de l en commençant par l'indice d.","Returns the extracted list of l with n elements (by default n=size(l)-d) and beginning at index d.",0,0},"Lst(l) or Str(l),Intg(d),Intg(n)","mid([0,1,2,3,4,5,6],2,3);mid([0,1,2,3,4,5,6],2);mid(\"azertyuiop\",2,4);mid(\"azertyuiop\",2);mid([[1,2],[3,4],[5,6]],1)","head,tail,left,right,subMat"},
{"middle_point",{"Option de la commande plotarea et de la commande area.","Option of the plotarea command and of the area command.",0,0},"Opt"," plotarea(x^2,x=0..1,5,trapezoid); plotarea(x^2,x=0..1,5,middle_point); plotarea(x^2,x=0..1,5,right_rectangle); plotarea(x^2,x=0..1,5,left_rectangle); area(x^2,x=0..1,5,middle_point); area(x^2,x=0..1,5,trapezoid)","plotarea,area"},
{"midpoint",{"milieu(A,B) trace le milieu du segment AB","midpoint(A,B) draws the midpoint of the segment AB",0,0},"(Pnt or Cplx),(Pnt or Cplx)","midpoint(-2,2i)","median_line,perpen_bisector"},
{"min",{"Minimum des éléments d'une séquence ou d'une liste de réels.","Minimum of elements of a sequence or a list of reals.",0,0},"Seq||Lst","min(25,35)","max"},
{"minimax",{"Approximation polynomiale de degre n d'une fonction continue bornee sur [a,b] par la methode de Remez","Implementation of Remez method for minimax polynomial approximation of degree n of a continuous bounded function on a..b",0,0},"Expr,Var=a..b,n,[Options]","minimax(x*exp(-x),x=0..10,24);minimax(x*sin(x),x=0..10,25);minimax(ln(2+x-sin(x)^2),x=0..2*pi,20);minimax(cos(x^2-x+1),x=-2..2,40);minimax(atan(x),x=-5..5,25);minimax(tanh(sin(9x)),x=-1/2..1/2,40);minimax(abs(x),x=-1..1,20);minimax(abs(x)*sqrt(abs(x)),x=-2..2,15);minimax(min(1/cosh(3*sin(10x)),sin(9x)),x=-0.3..0.4,25);minimax(when(x==0,0,exp(-1/x^2)),x=-1..1,30)",0},
{"minimize",{"Recherche du minimum ou maximum d'une fonction","Minimize a function",0,0},"Expr,[Constr],Vars,[Options]","minimize(sin(x),[x=0..4]);minimize(x^4-x^2,x=-3..3,locus);minimize(piecewise(x<=-2,x+6,x<=1,x^2,3/2-x/2),x=-3..2);minimize(x^2-3x+y^2+3y+3,[x=2..4,y=-4..-2],point);minimize(2x^2-y^2+6y,x^2+y^2<=16,[x,y]);minimize(sqrt(x^2+y^2)-z,[x^2+y^2<=16,x+y+z=10],[x,y,z]);minimize((1+x^2+3y+5x-4*x*y)/(1+x^2+y^2),x^2/4+y^2/3=9,[x,y]);minimize(cos(x)^2+cos(y)^2,x+y=pi/4,[x,y],locus)",0},
{"minus",{"minus est un opérateur infixé pour avoir la différence de 2 ensembles.","minus is a infixed operator to get the difference of 2 sets.",0,0},"(Vect or Set),(Vect or Set)"," [1,2,3] minus [2,5,6]; %{1,2,3%} minus %{2,5,6%}","union,intersect"},
{"mkisom",{"Matrice d'une isométrie donnée par ses éléments propres.","Matrix of an isometry given by its proper elements.",0,0},"Vect,(Sign(1) or -1)","mkisom([1,2],1);mkisom([[1,0,0],pi/3],-1);mkisom(pi,1)","isom"},
{"mksa",{"Convertit les unités en unités du système international MKSA","Convert units in MKSA international unit system",0,0},"Unit","mksa(1_N)","convert,ufactor"},
{"mod",{"Opérateur infixé qui renvoie n mod p un nombre de ℤ/pℤ.","Infixed operator which returns n mod p a number of ℤ/pℤ.",0,0},"Intg(n),Intg(p)"," 15 mod 6; (2 mod 10)^50; (72 mod 7) mod 0; (2%10)^50; (72%7)%0","smod,irem,fracmod"},
{"modgcd",{"PGCD de 2 polynômes avec l'algorithme modulaire.","GCD of 2 polynomials, with the modular algorithm.",0,0},"Poly,Poly","modgcd(x^4-1,(x-1)^2)","gcd,heugcd,ezgcd,psrgcd"},
{"mods",{"Retourne le reste symétrique de la division euclidienne de 2 entiers.","Returns the Euclidean symmetric remainder of two integers.",0,0},"Intg,Intg","smod(8,3);smod(10,4);smod(11,7)","irem,iquo,mod,fracmod"},
{"montre_tortue",{"Montre la tortue.","Shows the turtle.",0,0},"NULL","montre_tortue()","cache_tortue"},
{"moustache",{"Boite à moustache pour une série statistique.","Box and Whisker plot for a statistical serie.",0,0},"Lst,[Lst],[x=a..b||y=a..b]","boxwhisker([-1,1,2,2.2,3,4,-2,5]);boxwhisker([1,2,3,5,10,4],x=1..2);boxwhisker([1,2,3,5,10,4],[1,2,3,1,2,3]);boxwhisker([[6,0,1,3,4,2,5],[0,1,3,4,2,5,6],[1,3,4,2,5,6,0],[3,4,2,5,6,0,1],[4,2,5,6,0,1,3],[2,5,6,0,1,3,4]])","quartiles"},
{"moyal",{"Produit de Moyal de 2 symboles.","Moyal product of 2 symbols.",0,0},"Expr,Expr,VectVar","moyal(x^2+y^4,x^4-y^2,[x,y],5)",""},
{"moyenne",{"Moyenne d'une liste pondérée par le deuxième argument ou des colonnes d'une matrice.","Mean of a list with the second argument as pound or of the columns of a matrix.",0,0},"Lst||Mtrx,[Lst]","mean([1,2,3]);mean([1,2,3],[1,2,3]);mean([[1,2,3],[1,2,3]])","stddev"},
{"mul",{"Produit des valeurs de l'expression quand la variable va de a à b avec un pas p (product(expression,var,debut,fin,pas) par défaut p=1) ou produit des éléments d'une liste ou produit terme à terme des éléments de 2 listes ou matrices.","Multiplicates the values of the expression when the variable go from a to b with a step p (product(expression,var,begin,end,step) by default p=1) or product of the elements of a list or product element by element of 2 lists or matrix.",0,0},"Expr||Lst,[Var||Lst],[Intg(a)],[Intg(b)],[Intg(p)]","product(n,n,1,10,2);product(1/n,n,1,10);product(1/n,n,11,1);product(1/n,n,10,1,1);product([2,3,4,5]);product([2,3,4],[5,6,7]);product([[2,3,4],[5,6,7]],[[2,3,4],[5,6,7]])","sum"},
{"mult_c_conjugate",{"Renvoie l'expression après multiplication par la quantité complexe conjuguée du dénominateur (ou du numérateur si pas de dénominateur).","Returns the expression after multiplication by the complex conjugated quantity of the denominator (or of the numerator if no denominator).",0,0},"Expr","mult_c_conjugate(1/(3+i*2));mult_c_conjugate(3+i*2)","mult_conjugate"},
{"mult_conjugate",{"Renvoie l'expression après multiplication par la quantité conjuguée du dénominateur (ou du numérateur si pas de dénominateur).","Returns the expression after multiplication by the conjugated quantity of the denominator (or of the numerator if no denominator).",0,0},"Expr","mult_conjugate(sqrt(3)-sqrt(2));mult_conjugate(1/(sqrt(3)-sqrt(2)))","mult_c_conjugate"},
{"multinomial",{"Renvoie n!/(k0!*k1!*..;kj!)*(p0^k0*p1^k1..*pj^kj) (sum(p)=1 et sum(k)=n).","Returns n!/(k0!*k1!*..;kj!)*(p0^k0*p1^k1..*pj^kj) (sum(p)=1 et sum(k)=n).",0,0},"Intg(n),Vect(p),Vect(k)","multinomial(10,[0.5,0.5],[3,7]);multinomial(10,[0.2,0.3,0.5],[1,3,6]); randvector(3,multinomial,[1/2,1/3,1/6]); ranm(4,3,multinomial,[1/2,1/3,1/6])","binomial,randvector,ranm"},
{"multiplier_conjugue",{"Renvoie l'expression après multiplication par la quantité conjuguée du dénominateur (ou du numérateur si pas de dénominateur).","Returns the expression after multiplication by the conjugated quantity of the denominator (or of the numerator if no denominator).",0,0},"Expr","mult_conjugate(sqrt(3)-sqrt(2));mult_conjugate(1/(sqrt(3)-sqrt(2)))","mult_c_conjugate"},
{"multiplier_conjugue_complexe",{"Renvoie l'expression après multiplication par la quantité complexe conjuguée du dénominateur (ou du numérateur si pas de dénominateur).","Returns the expression after multiplication by the complex conjugated quantity of the denominator (or of the numerator if no denominator).",0,0},"Expr","mult_c_conjugate(1/(3+i*2));mult_c_conjugate(3+i*2)","mult_conjugate"},
{"multiply",{"Renvoie le produit des 2 arguments.","Returns the product of the 2 arguments.",0,0},"Intg or Lst, Intg or Lst","multiply(41,-4);multiply([4,1],[-4,2]);multiply([[4,1],[-4,1]],[[4,1],[-4,1]])","*"},
{"mupad2maple",{"mupad2maple(\"fichier1\",\"fichier2\") traduit fichier1(MuPAD) en fichier2(Maple).","mupad2maple(\"file1\",\"file2\") translate file1(MuPAD) to file2(Maple).",0,0},"Str(\"NameMupadFile\"),Str(\"NameMapleFile\")",0,"mupad2xcas"},
{"mupad2xcas",{"mupad2xcas(\"fichier1\",\"fichier2\") traduit fichier1(MuPAD) en fichier2(Xcas).","mupad2xcas(\"file1\",\"file2\") translate file1(MuPAD) to file2(Xcas).",0,0},"Str(\"NameMupadFile\"),Str(\"NameXcasFile\")",0,"mupad2maple"},
{"nCr",{"comb(n,r)=nombre de combinaisons de r objets pris parmi n : n!/(r!(n-r)!) (Si n<0 comb(n,r)=n(n-1)..(n-r+1)/r!).","comb(n,r)=number of combinations of r objects taken among n : n!/(r!(n-r)!) (If n<0 comb(n,r)=n(n-1)..(n-r+1)/r!).",0,0},"Intg(n),Intg(r)","comb(4,2)","factorial,perm"},
{"nDeriv",{"Renvoie une approximation du nombre dérivé d'une expression Xpr en un point : (Xpr(var+h)-Xpr(var-h))/(2*h) (par défaut h=0.001).","Returns an approximation of the derivative number at a point: (Xpr(var+h)-Xpr(var-h))/(2*h) (by default h=0.001).",0,0},"Expr(Xpr),Var(var),[Real(h)]","nDeriv(f(x),x,h);nDeriv(x^2,x,0.1);nDeriv(x^2,x)","avgRC"},
{"nInt",{"Renvoie la valeur approchée de integrate(f(x),x,a,b) par la méthode de Romberg.","Returns the approximate value of integrate(f(x),x,a,b) by Romberg's method.",0,0},"Expr(f(x)),Var(x),Real(a),Real(b)","romberg(exp(x^2),x,0,1);romberg(x^2,x,0,1);romberg(exp(-x^2),x,-1,1)","integrate,gaussquad"},
{"nPr",{"perm(n,p)=nombre d'arrangements de p objets pris parmi n : n!/(n-p)!","perm(n,p)=number of arrangements of p objects taken among n : n!/(n-p)!",0,0},"Intg(n),Intg(p)","perm(4,2)","comb,factorial"},
{"nSolve",{"Résolution numérique d'une équation ou d'un système","Numerical solution of an equation or a system of equation",0,0},"Expr,Var,[Guess or Interval],[Method]","nSolve(cos(x)=x,x);nSolve(cos(x)=x,x=1.3)","solve,fsolve,csolve"},
{"ncols",{"Nombre de colonnes d'une matrice.","Number of columns of a matrix.",0,0},"Mtrx","coldim([[1,2,3],[4,5,6]]);coldim([[1,2],[3,4],[5,6]])","rowdim"},
{"negbinomial",{"Renvoie comb(n+k-1,k)*p^k*(1-p)^n.","Returns comb(n+k-1,k)*p^k*(1-p)^n.",0,0},"Intg(n),Intg(k),Real(p in 0..1)","negbinomial(4,0,0.5);negbinomial(4,2,0.6);negbinomial(4,6,0.3)","negbinomial_cdf,negbinomial_icdf,binomial"},
{"negbinomial_cdf",{"Renvoie Proba(X<=x) ou Proba(x<=X<=y) quand X suit la loi negbinomial(n,p).","Returns Proba(X<=x) or Proba(x<=X<=y) when X follows the negbinomial(n,p) law.",0,0},"Intg(n),Real(p),Real(x),[Real(y)]","negbinomial_cdf(4,0.5,2);negbinomial_cdf(4,0.1,2);negbinomial_cdf(4,0.5,2,3)","negbinomial,negbinomial_icdf"},
{"negbinomial_icdf",{"Renvoie h tel que Proba(X<=h)=t quand X suit la loi negbinomial(n,p).","Returns h such as Proba(X<=h)=t when X follows the negbinomial(n,p) law.",0,0},"Intg(n),Real(p),Real(t)","negbinomial_icdf(4,0.5,0.68);negbinomial_icdf(4,0.1,0.95)","negbinomial,negbinomial_cdf"},
{"newList",{"Retourne la liste formée de n zéros.","Returns the list made with n zeros.",0,0},"Intg(n)","newList(4)","newMat,makelist"},
{"newMat",{"Retourne la matrice de n lignes et p colonnes, formée de zéros.","Returns the list with n rows and p columns, made with zeros.",0,0},"Intg(n),Intg(p)","newMat(2,3)","newList,makemat"},
{"newton",{"newton(f(x),x,a,p) calcule une racine de f(x) par la méthode de Newton en partant de a avec p itérations (par défaut p=20).","newton(f(x),x,a,p)=one root of f(x) by Newton method beginning with a and p iterations (by default p=20).",0,0},"Expr(f(x)),Var(x),[ApproxVal(a),NumIter(p)]","newton(x^2-2,x);newton(x^2-2,x,2);newton(x^2-2,x,-2);newton(x^2-2,x,2,5,1e-7)","rootof"},
{"newton_solver",{"Argument de fsolve indiquant la méthode pour résoudre numériquement une équation.","Argument for fsolve giving the method for solving an numerical equation.",0,0},"Opt"," fsolve(cos(x)=x,x,0..1,bisection_solver); fsolve(cos(x)=x,x,0..1,brent_solver); fsolve(cos(x)=x,x,0..1,falsepos_solver); fsolve(cos(x)=x,x,0,newton_solver); fsolve(cos(x)=x,x,0,secant_solver); fsolve(cos(x)=x,x,0,steffenson_solver)","fsolve"},
{"newtonj_solver",{"Argument de fsolve indiquant la méthode pour résoudre numériquement un système d'équations.","Argument for fsolve giving the method for solving a system of numerical equations.",0,0},"Opt"," fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],dnewton_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybrid_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybrids_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybridj_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],hybridsj_solver); fsolve([x^2+y-2,x+y^2-2],[x,y],[2,2],newtonj_solver)","fsolve"},
{"nextperm",{"Renvoie la permutation suivante dans l'ordre lexicographique.","Returns the next permutation with the lexicographic order.",0,0},"Intg(n)","nextperm([0,2,1,3]);nextperm([0,3,2,1])","prevperm,is_permu"},
{"nextprime",{"Prochain nombre premier ou pseudo premier après un entier donné.","Next prime or pseudo-prime after a given integer.",0,0},"Intg(a)","nextprime(9856989898990);nextprime(97160249868928888261606009)","prevprime,is_prime,ithprime"},
{"nodisp",{"Pour afficher Done au lieu d'une valeur.","To display Done in place of a value.",0,0},"Expr","nodisp(A:=ranm(50,50))",0},
{"nom_cache",{"Option de la commande affichage (ou display) pour ne pas afficher le nom.","Option of the display command to hide the name.",0,0},"Opt"," F:=display(point(2+1.5*i),hidden_name); F:=display(point(2+1.5*i),point_point+hidden_name)","display"},
{"non",{"Renvoie l'inverse logique de l'argument.","Returns the logical inverse of the argument.",0,0},"Boolean","not(b==0);not(b>0)","or,and,xor"},
{"non_recursive_normal",{"Simplifie les expressions, sans simplification à l'intérieur des expressions non rationnelles.","Simplifies the expressions, but without simplification into no-rational expressions.",0,0},"Expr","non_recursive_normal(sin(x+x)+sin(2*x)+x+x);non_recursive_normal(sin(2*x)+sin(2*x)+x+x)","normal"},
{"nop",{"Instruction ne rien faire.","No OPeration instruction.",0,0},"NULL","nop()",""},
{"nops",{"Renvoie la longueur d'une liste, d'une chaîne de caractères ou d'une suite.","Returns the size of a list, a string or a sequence.",0,0},"Lst or Str or Seq","size([1,2,3]);size(\"bonjour\");size(1,2,3)","sizes,dim,degree"},
{"norm",{"Norme l2 d'un vecteur = sqrt(x1^2+x2^2+...xn^2) ou norme de matrice subordonnée à la norme l2.","Returns the l2 norm of a vector = sqrt(x1^2+x2^2+...xn^2) or matrix norm induced by l2 norm.",0,0},"Vect or Mtrx","norm([1,2]);norm([1,2,3,-4]);norm([[1,2],[3,-4]]);norm([[1,2,3],[3,-9,6],[4,5,6]])","maxnorm,l1norm"},
{"normal",{"Simplifie l'expression.","Simplify the expression.",0,0},"Expr","normal(2*x+y=1);normal(2*x*2);normal((2*x+1)^2)","simplify"},
{"normal_cdf",{"Renvoie la probabilité qu'une variable aléatoire Normale soit inférieure à x0 ou comprise entre x0 et y0 (mu est la moyenne et sigma l'écart-type).","Returns the probability that a Normal random variable is lower than x0 or between x0 and y0 (mu is the mean and sigma the standard deviation).",0,0},"Real(mu),Real(sigma),Real(x0),[Real(y0)]","normal_cdf(1.96);normal_cdf(1,2,2.96*sqrt(2));normal_cdf(1,2,1.4*sqrt(2),2.96*sqrt(2))","UTPN,normal_icdf,normald"},
{"normal_icdf",{"Renvoie la valeur h telle que la probabilité qu'une variable aléatoire Normale soit inférieure à h soit p (mu est la moyenne, sigma l'écart-type et 0<=p<=1).","Returns h such as the probability that a Normal random variable is lower than h is p (mu is the mean and sigma the standard deviation and 0<=p<=1).",0,0},"Real(mu),Real(sigma),Real(p)","normal_icdf(0.95);normal_icdf(1,2,0.95)","normal_cdf,normald"},
{"normald",{"Renvoie la densité de probabilité de la loi normale (mu est la moyenne et sigma l'écart-type).","Returns the density of probability of the Normal law (mu is the mean and sigma the standard deviation).",0,0},"Real(mu),Real(sigma),Real(x0)","normald(1);normald(1,2,3.5); randvector(3,normald,1,0.5); ranm(4,3,normald,1,0.5)","normal_cdf,normal_icdf,randvector,ranm"},
{"normald_cdf",{"Renvoie la probabilité qu'une variable aléatoire Normale soit inférieure à x0 ou comprise entre x0 et y0 (mu est la moyenne et sigma l'écart-type).","Returns the probability that a Normal random variable is lower than x0 or between x0 and y0 (mu is the mean and sigma the standard deviation).",0,0},"Real(mu),Real(sigma),Real(x0),[Real(y0)]","normal_cdf(1.96);normal_cdf(1,2,2.96*sqrt(2));normal_cdf(1,2,1.4*sqrt(2),2.96*sqrt(2))","UTPN,normal_icdf,normald"},
{"normald_icdf",{"Renvoie la valeur h telle que la probabilité qu'une variable aléatoire Normale soit inférieure à h soit p (mu est la moyenne, sigma l'écart-type et 0<=p<=1).","Returns h such as the probability that a Normal random variable is lower than h is p (mu is the mean and sigma the standard deviation and 0<=p<=1).",0,0},"Real(mu),Real(sigma),Real(p)","normal_icdf(0.95);normal_icdf(1,2,0.95)","normal_cdf,normald"},
{"normalize",{"Renvoie le vecteur divisé par sa norme l2. C'est aussi une option de plotfiefd.","Returns the vector divided by its l2norm. It is also an option for plotfiefd.",0,0},"Lst||Cplx","normalize(3+4*i);normalize([3,4]); fieldplot(-t*y,[t,y],normalize); fieldplot(-t*y,[t,y],normalize,xstep=0.5,ystep=0.5)","l2norm"},
{"normalt",{"Test Z d'hypothèses /loi normale : arg1=[succes,essais] ou [moyenne, taille] ou données, arg2=proportion ou moyenne population ou données, arg3 optionnel si données=sigma, arg4 alternative '!=' ou '>' ou '<', arg5 optionnel confiance alpha.","Z-Test/normal law: arg1=[success,trial] or [mean,sample size] or data, arg2=proportion or data, arg3 optional if data=sigma, arg4 alternative '!=' or '>' or '<', arg5 optional alpha confidence level.",0,0},"Lst,Real,[Real],Fnc,[Real]","normalt([10,30],.5,.02,'!=',0.1);normalt([0.48,50],0.5,0.1,'<')","studentt,chisquaret,kolmogorovt"},
{"not",{"Renvoie l'inverse logique de l'argument.","Returns the logical inverse of the argument.",0,0},"Boolean","not(b==0);not(b>0)","or,and,xor"},
{"nprimes",{"Nombre de nombres premiers inférieurs ou égals à n.","Count the number of primes less than n.",0,0},"Intg(n)","nprimes(20)","ithprime,prevprime,nextprime,isprime"},
{"nrows",{"Nombre de lignes d'une matrice.","Number of rows of a matrix.",0,0},"Mtrx","rowdim([[1,2,3],[4,5,6]]);rowdim([[1,2],[3,4],[5,6]])","ncols"},
{"nuage_points",{"Dessine pour k=0..nrows, les points (xk,yk) où xk=élément ligne k colonne 0 et yk=élément ligne k colonne j (j=1..ncols).","Draws for k=0..nrows, the points (xk,yk) where xk=element row k column 0 and yk=element row k column j (j=1..ncols).",0,0},"Mtrx","scatterplot([[1,2,3],[2,0,1],[-1,2,3]])","polygonplot,polygonscatterplot,listplot"},
{"nullspace",{"Noyau d'une application linéaire de matrice M","Kernel of a linear application of matrix M",0,0},"Mtrx","ker([[1,2],[3,6]]);ker([[1,2,3],[1,3,6],[2,5,9]])","image,rref,Nullspace"},
{"numer",{"Renvoie le numérateur de la fraction simplifiée.","Returns the numerator of the simplified fraction.",0,0},"Frac(a/b) or RatFrac","numer(25/15);numer((x^3-1)/(x^2-1));numer(1+(x^3-1)/x^2)","getNum,getDenom,denom,f2nd"},
{"octahedron",{"Dessine un octaèdre de centre A, de sommet B où le plan ABC contient 4 sommets.","Draws an octahedron with center A, vertex B and such that the plane ABC contains 4 vertices.",0,0},"Pnt(A),Pnt(B),Pnt(C)","octahedron([0,0,0],[0,0,5],[0,5,0]);octahedron(evalf([0,0,0],[3,2,4],[1,1,0]))","icosahedron,dodecahedron,cube,tetrahedron"},
{"od",{"Fin de bloc.","Bloc end.",0,0},""," if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);end;; if (2>1) begin print(\"ifactor(154)=\",ifactor(154));ifactor(154);fi;; f:=function(a,b) local c;c:=a+b;c+gcd(a,b);end;f(28,21);; f:=fonction(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;; fonction f(a,b) local c;c:=a+b;c+gcd(a,b);ffonction;","begin,bloc,{}"},
{"odd",{"Retourne 1 si l'entier est impair, sinon retourne 0.","Returns 1 if the integer is odd, else returns 0.",0,0},"Intg(n)","odd(6);odd(1251)","even"},
{"odeplot",{"odeplot(f(t,y),[t,y],[t0,y0]) trace la solution de y'=f(t,y) et y(t0)=y0 ou du système [x'=g(t,x,y),y'=h(t,x,y)] avec x(t0)=x0 et y(t0)=y0.","odeplot(f(t,y),[t,y],[t0,y0]) draws the solution of y'=f(t,y) and y(t0)=y0 or of the system [x'=g(t,x,y),y'=h(t,x,y)] with x(t0)=x0 and y(t0)=y0.",0,0},"Expr,VectVar,VectInitCond","odeplot(sin(t*y),[t,y],[0,1]);odeplot(sin(t*y),[t=-10..10,y],[0,1]);odeplot(sin(t*y),[t=-3..3,y],[0,1],tstep=0.1,color=vert);odeplot([x-0.3*x*y, 0.3*x*y-y], [t,x,y],[0,0.3,0.7]);odeplot([x-0.3*x*y, 0.3*x*y-y], [t,x,y],[0,0.3,0.7],plan);odeplot([-y+b,-1+(x-a)^2+(y-b)^2],[t=-3..3,x,y],[0,a+1,b+0.5],plan);odeplot(5*[-y,x],[t=0..1,x,y],[0,0.3,0.7],tstep=0.05,plan)","interactive_plotode,fieldplot,odesolve,desolve"},
{"odesolve",{"odesolve(f(t,y),[t,y],[t0,y0],t1)=odesolve(t0..t1,f,y0)=y(t1) pour y sol approx de y'=f(t,y) et y(t0)=y0 avec y=vecteur pour les systèmes.","odesolve(f(t,y),[t,y],[t0,y0],t1)=odesolve(t0..t1,f,y0)=y(t1) for y approx sol of y'=f(t,y) and y(t0)=y0 with y=vector for systems.",0,0},"Expr,VectVar,VectInitCond,FinalVal,[tstep=Val,curve]","odesolve(sin(t*y),[t,y],[0,1],2);odesolve(0..2,(t,y)->sin(t*y),1);odesolve(0..pi,(t,v)->{[-v[1],v[0]]},[0,1]);odesolve(sin(t*y),t=0..2,y,1,tstep=0.5);odesolve(sin(t*y),t=0..2,y,1,tstep=0.5,curve)","plotode,plotfield,interactive_plotode,desolve"},
{"of",{"Renvoie la valeur f(a).","Returns the value : f(a).",0,0},"Fnc(f),Real(a)","of(x->x^2,4)","at"},
{"op",{"Renvoie les arguments d'un opérateur sous forme d'une suite.","Returns the arguments of an operator as a sequence.",0,0},"Op or Fnc","feuille(quote(gcd(45,126)));feuille('gcd(45,126)');feuille('1+2')[1];feuille([1,2,3]);feuille(set[1,2,3])","sommet,quote,makesuite"},
{"open",{"Ouvre un fichier de nom s, renvoie le numéro de handle du fichier.","Opens a file named s, returns the file handle.",0,0},"Str(s)"," f:=open(\"filename\")","fopen,close"},
{"open_polygon",{"Renvoie et dessine la ligne polygonale de sommets les éléments de l.","Returns and draws the polygonal line where its vertices are the element of l.",0,0},"LstPnt||LstCplx","open_polygon(i,1+i,2-i,-1,-1+i/2);open_polygon(point(0,0,0),point(3,3,3),point(0,0,3),point(3,0,0))","isopolygon,quadrilateral"},
{"option",{"Mot réservé pour compatibilité.","Reserved word for compatibility.",0,0},"",0,""},
{"or",{"opérateur booléen infixé (ou).","infixed boolean operator (or).",0,0},"Expr, Expr"," (1==2) or (2>1)","and,not,xor"},
{"ord",{"Renvoie le code ASCII d'un caractère ou du premier caractère d'une chaîne.","Returns the ASCII code of a character or of the first character of a string.",0,0},"Char||LstChar","ord(\"A\");ord(\"ABC\");ord([\"a\",\"b\",\"c\"])","asc,char"},
{"order_size",{"Reste (terme en O) d'un développement en séries: limit(x^a*order_size(x),x=0)=0 si a>0.","Remainder (O term) of a series expansion: limit(x^a*order_size(x),x=0)=0 if a>0.",0,0},"Expr","order_size(x); limit(sqrt(x)*order_size(x),x=0)","series"},
{"ordinate",{"Renvoie l'ordonnée du point ou du vecteur.","Returns the ordinate of a point or a vector.",0,0},"Pnt or Vect","ordinate(point(1+2*i));ordinate(point(i)-point(1+2*i));ordinate(-1-i);ordinate(point(1,2,3))","abscissa,affix,cote,coordinates"},
{"orthocenter",{"Désigne l'orthocentre d'un triangle ou du triangle formé par 3 points.","Shows the orthocenter of a triangle or of the triangle made with 3 points.",0,0},"(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)","orthocenter(1+i,2,i);orthocenter(point(1+i),point(2),point(i));orthocenter(triangle(0,1,1+i))","altitude,triangle"},
{"orthogonal",{"orthogonal(A,droite(B,C)) trace le plan orthogonal à la droite BC passant par A et orthogonal(A,plan(B,C,D)) trace la droite orthogonale au plan(B,C,D)) passant par A.","orthogonal(A,line(B,C)) draws the orthogonal plane of line BC through A and orthogonal(A,plane(B,C,D)) draws the orthogonal line of plan(B,C,D) through A.",0,0},"(Pnt),(Line or Plan)","orthogonal(point(0,0,0),line(point(1,0,0),point(0,1,0)));orthogonal(point(0,0,0),plane(point(1,0,0),point(0,1,0),point(0,0,1)))","altitude,perpendicular"},
{"osculating_circle",{"Cercle osculateur à la courbe plane C au point M.","Osculating circle at point M to the curve C.",0,0},"Curve,Point","osculating_circle(plot(x^2),point(1,1));osculating_circle([5*cos(t),5*sin(t)],t,0);osculating_circle([t,t^2],t);osculating_circle([t,t^2],t,1);osculating_circle([3*exp(t/2)*cos(t),3*exp(t/2)*sin(t)],t);osculating_circle([3*exp(t/2)*cos(t),3*exp(t/2)*sin(t)],t,7)","curvature,evolute"},
{"otherwise",{"Cas par défaut dans une instruction switch.","Default case in a switch instruction.",0,0},""," default: print(\"Default case!\"); a:=1;switch(a){case 0:{b:=1;break;} case 1:{b:=3;break;} default:{b:=0;}};","switch,case,if"},
{"ou",{"opérateur booléen infixé (ou).","infixed boolean operator (or).",0,0},"Expr, Expr"," (1==2) or (2>1)","and,not,xor"},
{"output",{"Instruction dans un programme permettant la sortie d'une expression stockée dans var.","Instruction in a program so that you can output an expression stored in var.",0,0},"[Str],Var(var)","output(\"age\",a)","input"},
{"p1oc2",{"Renvoie la permutation produit de p1 et de c2.","Returns the permutation product of p1 and c2.",0,0},"Permut,Cycle","p1oc2([0,2,1],[2,1,3])","c1op2,p1op2"},
{"p1op2",{"Renvoie la permutation produit de p1 et de p2.","Returns the permutation product of p1 and p2.",0,0},"Permut,Permut","p1op2([0,2,1],[1,0,3,2])","c1op2,p1oc2"},
{"pa2b2",{"Renvoie [a,b] tels que a^2+b^2=n (pour n premier et n=1 (mod 4)).","Returns [a,b] such as a^2+b^2=n (for n prime and n=1 (mod 4)).",0,0},"Intg(n)","pa2b2(17);pa2b2(209);pa2b2(229)",0},
{"pade",{"Approximant de Padé P/Q=Xpr mod x^(n+1) ou mod N avec degré(P)<p.","Pade approximation P/Q=Xpr mod x^(n+1) or mod N with degree(P)<p.",0,0},"Expr(Xpr), Var(x), (Intg(n) || Poly(N)), Intg(p)","pade(exp(x),x,10,6)","taylor,series"},
{"parabola",{"parabole(F,A)=foyer F, sommet A (dans le plan ABP) ou (parabole(A,c) d'équa. y=yA+c*(x-xA)^2 c=1/(2*p) et FA=p/2 geo2d) et parabole(P(x,y)) dessine la conique si deg(P)=2.","parabola(F,A)=focus F, top A (in the plane ABP) or (parabola(A,c) of equa. y=yA+c*(x-xA)^2 c=1/(2*p) and FA=p/2 geo2d) and parabola(P(x,y)) draws the conic if deg(P)=2.",0,0},"Pnt(F)||Pnt(xA+i*yA),Pnt(A)||Real(c),[Pnt(P)]","parabola(point(0),point(2));parabola(0,2);parabola(point(0,0,0),point(1,0,0),point(1,1,1));parabola(x-y^2+y-2)","ellipse,hyperbola"},
{"parallel",{"parallele(A,D) (resp parallele(A,P) ou parallele(A,D,DD)) trace la droite (resp le plan) passant par le point A parallèle à la droite D (resp parallèle au plan P ou aux droites D et DD) et, parallele(d,D) trace le plan parallèle à la droite D passant par d.","parallel(A,D) (resp parallel(A,P) or parallel(A,D,DD)) draws the line (resp plane) through A parallel to the line D (resp parallel to the plane P or to the lines D,DD) and, parallel(d,D) draws the plane through d parallel to the line D.",0,0},"Pnt or Line,Line or Plan,[Line]","parallel(1+i,line(1-i,i));parallel(1+i,segment(1-i,i));parallel(point([1,1,1]),line(x=0,y=0));parallel([1,1,1],line(x=0,y=0));parallel([1,1,1],plane(x=0));parallel([1,0,0],line(x=0,y=0),line(x=y,y=z));parallel(line(x=y,y=z),line(x=0,y=0))",""},
{"parallelepiped",{"Dessine un parallélépipède de côtés AB,AC,AD (les faces sont des parallélogrammes).","Draws a parallelepiped with sides AB,AC,AD (the faces are parallelograms).",0,0},"Pnt(A),Pnt(B),Pnt(C),Pnt(D)","parallelepiped([0,0,0],[2,0,0],[0,1,0],[0,0,3]); p:=parallelepiped([0,0,0],[5,0,0],[0,3,0],[0,0,2]);c1,c2,c3,c4,c5,c6,c7,c8:=sommets(p);","cube,polyhedron"},
{"parallelogram",{"Renvoie et dessine le parallélogramme ABCD tel que vecteur(AB)+vecteur(AD)=vecteur(AC).","Returns and draws the parallelogram ABCD such as vector(AB)+vector(AD)=vector(AC).",0,0},"Pnt(A)||Cplx,Pnt(B)||Cplx,Pnt(C)||Cplx,[Var(D)]","parallelogram(0,1,2+i);parallelogram(1,0,2+i,D);parallelogram(point(0,0,0),point(3,3,3),point(0,0,3));parallelogram(point(0,0,0),point(3,3,3),point(0,0,3),D)","quadrilateral,rhombus"},
{"parameq",{"parameq(C) renvoie le nombre complexe = équation paramétrique de la courbe C.","parameq(C) returns the complex number=parametric equation of the curve C.",0,0},"GeoObj","parameq(circle(0,1));parameq(line(i,1-i))","equation"},
{"parameter",{"Mot réservé.","Reserved word.",0,0},"",0,""},
{"paramplot",{"plotparam(a(x)+i*b(x),x=x0..x1) trace la courbe X=a(x),Y=b(x) x=x0..x1 ou plotparam([a(u,v),b(u,v),c(u,v)],[u=u0..u1,v=v0..v1]) trace la surface X=a(u,v),Y=b(u,v),Z=c(u,v) u=u0..u1 et v=v0..v1.","plotparam(a(x)+i*b(x),x=x0..x1) draws the curve X=a(x),Y=b(x) x=x0..x1 or plotparam([a(u,v),b(u,v),c(u,v)],[u=u0..u1,v=v0..v1]) draws the surface X=a(u,v),Y=b(u,v),Z=c(u,v) u=u0..u1 and v=v0..v1.",0,0},"Cplx||Lst,Var||Lst(Var)","plotparam(sin(t)+i*cos(t),t);plotparam([sin(x),cos(x)],x=0..1);plotparam([sin(x),cos(x)],x=0..1,affichage=rouge);plotparam(sin(x)+i*cos(x),x=0..1,tstep=0.01);plotparam([v*cos(u),v*sin(u),v],[u,v]);plotparam([v*cos(u),v*sin(u),v],[u=0..pi,v=0..3],ustep=0.1,vstep=0.2)","plotfunc,plotpolar"},
{"parfrac",{"Option de la commande convert ou convertir (id à l'option partfrac).","Option of the convert or convertir command (id at the option partfrac).",0,0},"Opt"," convert(1/(x^2-1),parfrac); convert(1/(x^2-1),fullparfrac)","convert"},
{"pari",{"Exécute une commande de PARI/GP ou exporte les commandes de PARI/GP.","Execute a PARI/GP command or exports all PARI/GP commands.",0,0},"Str,arguments","pari();pari(\"gcd\",15,50);pari(\"gcd\",5/7,50/9);pari(\"gcd\", 3,[25,15,50,75]);pari(\"gcd\", [2,3],[25,15,50,75]);pari(\"content\",[25,15,50,75]);pari(\"isprime\",9856989898997789789,1);pari(\"isprime\",9856989898997789789,2)","gcd,lgcd,is_prime"},
{"part",{"Renvoie la n-ième sous-expression de l'expression.","Returns the n-th subexpression of the expression.",0,0},"Expr, Intg(n)","part(sin(x)+cos(x),1);part(sin(x)+cos(x),2);part(exp(x)*sin(x),1);part(part(exp(x)*sin(x)+cos(x),1),1)",""},
{"partfrac",{"Décomposition en éléments simples d'une fraction rationnelle ou Option de la commande convert ou convertir (id à l'option parfrac).","Performs partial fraction decomposition on a fraction or Option of the convert or convertir command (id at the option parfrac).",0,0},"RatFrac or Opt","partfrac(x/(4-x^2));partfrac((x^2-2*x+3)/(x^2-3*x+2));partfrac(a/(z*(z-b)),z); convert(x/(4-x^2),partfrac)","factor,normal,convert,propfrac"},
{"pas",{"Saut de la variable dans une itération (taille du saut).","Step in an iteration (step size of incrementation).",0,0},""," s:=0;for j from 1 to 10 step 2 do s:=s+j end_for; s:=0;for j from 1 step 2 to 10 do s:=s+j end_for; s:=0;for j from 1 to 10 by 2 do s:=s+j end_for; s:=0;for j from 1 by 2 to 10 do s:=s+j end_for; s:=0;pour j de 1 jusque 10 pas 2 do s:=s+j fpour; s:=0;pour j de 1 pas 2 jusque 10 do s:=s+j fpour","for,pour"},
{"pas_de_cote",{"La tortue fait n pas de coté à gauche (-n pas à droite si négatif) sans laisser de traces (par défaut n=10).","The turtle does n side-steps on the left (-n steps on the right if n negative) without trace (by default n=10).",0,0},"NULL or Real(n)"," pas_de_cote 30;pas_de_cote(30)","saute,tourne_droite,tourne_gauche"},
{"pcar",{"Liste des coefficients du polynôme caractéristique d'une matrice ou polynôme caractéristique d'une matrice de variable le second argument.","List of the coefficients of the characteristic polynomial of a matrix or characteristic polynomial of a matrix with the second argument as variable.",0,0},"Mtrx,[Var]","pcar([[1,2],[3,4]]);pcar([[1,2],[3,4]],x);pcar([[1,2,3],[1,3,6],[2,5,7]]);pcar([[1,2,3],[1,3,6],[2,5,7]],z)","jordan,egv,egvl,companion,rat_jordan,pmin,adjoint_matrix "},
{"pcar_hessenberg",{"Polynôme caractéristique d'une matrice par la méthode de Hessenberg (si les coefficients sont dans un corps fini).","Characteristic polynomial of a matrix by the Hessenberg method (if the coefficients are in a finite field).",0,0},"Mtrx,[Var]","pcar_hessenberg([[1,2],[3,4]]);pcar_hessenberg([[1,2],[3,4]],x);pcar_hessenberg([[1,2,3],[1,3,6],[2,5,7]])","jordan,pcar,egvl"},
{"pcoef",{"Retourne les coefficients du polynôme dont les racines sont données en argument avec 1 comme coefficient dominant.","Returns the polynomial coefficients having the roots specified as argument.",0,0},"Vect","pcoeff([1,0,0,0,1]);pcoeff([1,0,-2])","proot,peval"},
{"pcoeff",{"Retourne les coefficients du polynôme dont les racines sont données en argument avec 1 comme coefficient dominant.","Returns the polynomial coefficients having the roots specified as argument.",0,0},"Vect","pcoeff([1,0,0,0,1]);pcoeff([1,0,-2])","proot,peval"},
{"perimeter",{"Périmètre d'un polygone (par exemple triangle, carré, ...)","Perimeter of a polygon (e.g. triangle, square, ...)",0,0},"Polygone","perimeter(triangle(0,1,i));perimeter(square(0,2));perimeter(circle(0,2));perimeter(0,1,i)","polygon,area,perimeteratraw,perimeterat"},
{"perimeterat",{"Affiche au point(z0), avec une légende, le périmètre d'un cercle ou d'un polygone (exemple triangle, carré,...)","Displays at point(z0), with a legend, the perimeter of a circle or of a polygon (e.g. triangle, square, ...)",0,0},"Polygone, Pnt||Cplx(z0)"," t:=triangle(0,1,i);perimeterat(t,1+i); c:=square(0,2);perimeterat(c,1+i); c2:=circle(0,2);perimeterat(c2,1+i); p:=polygon(0,1,i);perimeterat(p,1+i); A:=point(0);B:=point(1+i);c:=carre(A,B);perimeterat(c,i)","perimeter,perimeteratraw,polygon,areaatraw"},
{"perimeteratraw",{"Affiche au point(z0), le périmètre d'un cercle ou d'un polygone (exemple triangle, carré,...)","Displays at point(z0), the perimeter of a circle or of a polygon (e.g. triangle, square, ...)",0,0},"Polygone, Pnt||Cplx(z0)","perimeteratraw(triangle(0,1,i),1+i);perimeteratraw(square(0,2),1+i);perimeteratraw(circle(0,2),1+i);perimeteratraw(polygon(0,1,i),1+i); A:=point(0);B:=point(1+i);c:=carre(A,B);perimeteratraw(c,i)","perimeter,perimeterat,polygon,areaatraw"},
{"periodic",{"Cree une expression periodique egale a Expr sur [a,b], periode b-a","Make a periodic expression equal to Expr on a..b, period b-a",0,0},"Expr,Var,a,b","periodic(x^2,x,0,1)",0},
{"perm",{"perm(n,p)=nombre d'arrangements de p objets pris parmi n : n!/(n-p)!","perm(n,p)=number of arrangements of p objects taken among n : n!/(n-p)!",0,0},"Intg(n),Intg(p)","perm(4,2)","comb,factorial"},
{"perminv",{"Renvoie la permutation inverse de la permutation a.","Returns the inverse permutation of the permutation a.",0,0},"Permut(a)","perminv([1,3,2,4,0])","cycleinv"},
{"permu2cycles",{"Convertit une permutation en un produit de cycles disjoints.","Converts a permutation to a product of disjoined cycles.",0,0},"Permut","permu2cycles([0,2,1,3,5,4]);permu2cycles([0,2,1,4,3,5])"," cycles2permu,cycle2perm"},
{"permu2mat",{"Renvoie la matrice obtenue en permutant les lignes de la matrice identité avec la permutation p.","Returns the matrix where the lines of the identity matrix are permuted with the permutation p.",0,0},"Permut(p)","permu2mat([1,3,2,4,0])",""},
{"permuorder",{"Renvoie l'ordre de la permutation a.","Returns the order of the permutation a.",0,0},"Permut(a)","permuorder([1,3,2,4,0])","cycles2permu"},
{"perpen_bisector",{"mediatrice(A,B) trace la médiatrice (droite ou plan) du segment AB.","perpen_bisector(A,B) draws the bisection (line or plane) of the segment AB.",0,0},"(Pnt or Cplx),(Pnt or Cplx)","perpen_bisector(1-i,i);perpen_bisector([0,0,0],[5,5,0])","midpoint,median_line"},
{"perpendicular",{"perpendiculaire(A,droite(B,C)) ou perpendiculaire(A,B,C) trace la droite perpendiculaire à la droite BC, passant par le point A et perpendiculaire(d,plan(B,C,D)) trace le plan perpendiculaire au plan(B,C,D)) passant par la droite d.","perpendicular(A,line(B,C)) or perpendicular(A,B,C) draws the orthogonal line of line BC through A and perpendicular(d,plane(B,C,D)) draws the orthogonal plane of plane(B,C,D) through the line d.",0,0},"(Pnt or Line),(Line or Plan)","perpendicular(1,line(1,i));perpendicular(1,0,1+i);perpendicular([0,0,0],line(x=y,y=z));perpendicular(line([0,0,0],[1,1,0]),plane(x+y+z=1))","altitude,orthogonal"},
{"peval",{"Évalue en un point x0, un polynôme donné par ses coefficients.","Evaluates at a point x0, a polynomial given by its coefficients.",0,0},"Vect,Real(x0)","peval([1,0,-2],1);peval([1,2,-25,-26,120],8)","proot,pcoeff"},
{"pi",{"Le nombre pi","pi",0,0},""," pi/4; Pi/4; evalf(pi); evalf(Pi)","e,i"},
{"piecewise",{"Si condition1 renvoie expr1 sinon...si condition2p renvoie expr2p sinon renvoie expr2p+1.","If condition1 returns expr1 else...if condition2p returns expr2p else returns expr2p+1.",0,0},"Cond1,Expr1,..,Cond2p,Expr2p,[Expr2p+1]","piecewise(x<=-pi,x+2*pi,x<=pi,x,x+2*pi);piecewise(x<-2,-2,x<-1,3x+4,x<0,1,x+1)","if,then,else,ifte,switch"},
{"pivot",{"Renvoie la matrice obtenue en créant des zéros dans la colonne nc de A, avec la méthode de Gauss-Jordan, en utilisant l'élément A[nl,nc] comme pivot.","Returns the matrix get from A creating zeros in the column nc, by the method of Gauss-Jordan with the element A[nl,nc] as pivot.",0,0},"Mtrx(A),Intg(nl),Intg(nc)","pivot([[1,2],[3,4],[5,6]],0,1);pivot([[1,2],[3,4],[5,6]],1,1)","gaussjord,linsolve"},
{"pixoff",{"Éteint un pixel.","Pixel off.",0,0},"Real(x),Real(y)","pixoff(1,2)","pixon"},
{"pixon",{"Allume un pixel","Pixel on",0,0},"Real(x),Real(y)","pixon(1,2)","pixoff"},
{"plane",{"plan(A,B,C) ou plan(A,droite(B,C)) (resp plan(a*x+b*y+c*z+d=0)) trace le plan ABC (resp d'équation a*x+b*y+c*z+d=0) dans l'espace 3D.","plane(A,B,C) or plane(A,line(B,C)) (resp plane(a*x+b*y+c*z+d=0)) draws the plane ABC (resp of equation a*x+b*y+c*z+d=0) in the 3D space.",0,0},"Pnt or Eq, [Pnt or Line],[Pnt]","plane([0,0,0],[1,1,1],[1,0,0]);plane([0,0,0],line([1,0,0],[1,1,1]));plane(x+y+z=0);plane(2*x+y-2*z-1)","line"},
{"playsnd",{"Joue une donnée de type son.","Plays a sound data.",0,0},"Vect","playsnd(2^14*(sin(2*pi*440*soundsec(1)))","readwav,writewav,soundsec"},
{"plex",{"Option de la commande gbasis ou greduce pour spécifier un ordre sur les monômes (=ordre par défaut=lexicographique pur).","Option of the gbasis or greduce command to specify an order for monomials (=default order=pure lexicographic).",0,0},"Opt",0,"gbasis,greduce"},
{"plot",{"Trace le graphe d'une expression (ou d'une liste d'expressions) d'1 variable ou d'une densité de loi de probabilité.","Plot a one-variable expression (or list of expressions).",0,0},"(Expr or LstExpr),Var[=VarMin..VarMax],[color=LstColor]","plot(x-1/6*x^3,x);plot([2*x-1,sin(x)],x=1..2);plot(sin(x),x=-2..2,color=green,xstep=0.1);plot([2*x-2,2*sin(x)],x=1..2,color=[green,red],legende=[\"2x-2\",\"sin\"]);plot(exponentiald(2));plot(normald);plot(normald(-1,2))","plotfunc,plotparam,animate,animate3d,plotarea"},
{"plot3d",{"Efface et trace le graphe d'une fonction ou d'une expression de 2 variables ou d'une surface paramétrée par une liste de 3 fonctions ou de 3 expressions de 2 variables.","Erase and plot a 2 variable expression or of a surface defined with a list of the 3 functions or of 3 expression of 2 variables.",0,0},"Expr||Lst(3*Expr),Var,Var","plot3d(x^2+y^2+1,x,y);plot3d(x^2+y^2,x=-1..1,y=-2..2);plot3d([u+1,2*v,u^2+v^2],u=-1..1,v=-2..2);plot3d(f,-1..1,-2..2);plot3d([f,g,h],-1..1,-2..2)","plotfunc,animate3d"},
{"plotarea",{"Affiche l'aire sous une courbe, en option la méthode de quadrature (trapeze,rectangle_gauche,rectangle_droit,point_milieu).","Displays the area below a curve, optionally with a quadrature method (trapezoid,left_rectangle,right_rectangle,middle_point).",0,0},"Expr,x=a..b,[n],[Method]","plotarea(sin(x),x=0..pi);plotarea(x^2,x=0..1,5,trapezoid);plotarea(x^2,x=0..1,5,middle_point)","integrate,plot,area,areaat,areaatraw"},
{"plotcdf",{"Representation graphique d'une distribution cumulée pour une loi de probabilité.","Graphic representation of a cumulated distribution function.",0,0},"Func,FuncParams","plotcdf(binomial,10,0.5);plotcdf(normald,0.0,1.0);plotcdf([1,3,4,3,5,6])","icdf,binomial_cdf,normald_cdf,cdf"},
{"plotcontour",{"Dessine soit 11 lignes de niveaux équiréparties entre z=z_min,,...z=z_max de la surface z=Xpr, soit les lignes de niveaux définies par le 3ème argument.","Draws whether 11 equirepartited contour-lines z=z_min,,...z=z_max of the surface z=Xpr, whether the contour-lines defined by the 3-rd argument.",0,0},"Expr(Xpr),[LstVar],[LstVal]","plotcontour(x^2+y^2);plotcontour(x^2+y^2,[x,y]);plotcontour(x^2+2*y^2-2,[x,y],[1.0,2.0,3.0]);plotcontour(x^2-y^2,[x=-4..4,y=-4..4],seq(k,k,-11,11,3),xstep=0.1,ystep=0.1)","plotdensity,plotimplicit"},
{"plotdensity",{"Affiche en couleur le graphe d'une expression de 2 variables dans le plan.","Shows in the plan with colors the graph of a expression of 2 variables.",0,0},"Expr,[x=xrange,y=yrange],[z],[xstep],[ystep]","plotdensity(x^2-y^2,[x=-2..2,y=-2..2],xstep=0.1,ystep=0.1);plotdensity(x^2-y^2,[x=-2..2,y=-2..2],z=-2..2,xstep=0.1,ystep=0.1)","plotfunc,plotcontour"},
{"plotfield",{"fieldplot(f(t,y),[t,y]) trace le champ des tangentes (normalisé ou non selon l'option) de l'equa diff y'=f(t,y).","fieldplot(f(t,y),[t,y]) draws the plotfield of the diff equation y'=f(t,y).",0,0},"Expr,VectVar,[Opt]","fieldplot(sin(t*y),[t=-5..5,y=-3..3],xstep=0.5,ystep=0.5);fieldplot(-t*y,[t,y]);fieldplot(-t*y,[t,y],normalize);fieldplot(-t*y,[t,y],normalize,xstep=0.5,ystep=0.5);fieldplot(-t*y,[t=-6.868..6.868,y=-6.868..6.868],normalize)","interactive_plotode,odeplot,odesolve,desolve"},
{"plotfunc",{"Trace le graphe d'une expression d'1 ou 2 variables avec superposition.","Plot a 1 variable or 2 variables expression with superposition.",0,0},"Expr,[Var(x) or VectVar] ,[Intg(color)]","plotfunc(-2*x+1,x=1..2,color=red);plotfunc([-2*x+1,x^2-2],x=-2..2,color=[red,yellow],xstep=0.2);plotfunc(x^2-y^2,[x,y],xstep=0.5,ystep=0.3);plotfunc(x^2+y^2,[x=-1..1,y=-2..2],nstep=900);plotfunc((x+i*y)^2,[x=-1..1,y=-2..2],nstep=900,affichage=rempli)","plot,plot3d,plotparam,animate,animate3d,plotdensity"},
{"plotimplicit",{"plotimplicit(f(x,y),x,y) ou plotimplicit(f(x,y),[x,y]) graphe de f(x,y)=0.","plotimplicit(f(x,y),x,y) or plotimplicit(f(x,y),[x,y]) graph of f(x,y)=0.",0,0},"Expr,Var1,Var2","plotimplicit(x^2+y^2-1,x,y);plotimplicit(x^4+y^4=x^2-y^2);plotimplicit(x^2+y^2-1,x,y,unfactored);plotimplicit(x^2+4*y^3-1);plotimplicit(x^2+4*y^3-k)$(k=-5..5);plotimplicit(y^3=x^3-x^2,x,y,xstep=0.1,ystep=0.1);plotimplicit(y^3=x^3-x^2,[x,y],xstep=0.1,ystep=0.1);plotimplicit((x+5)^2+(y+4)^2-1,x=-6..-4,y=-5..-3);plotimplicit((x+5)^2+(y+4)^2-1,[x=-6..-4,y=-5..-3])","plotcontour,unfactored,plotinequation"},
{"plotinequation",{"Affiche le graphe de la solution d'inéquations de 2 variables.","Shows the graph of the solution of inequations with 2 variables.",0,0},"Expr,[x=xrange,y=yrange],[xstep],[ystep]","plotinequation(x^2-y^2<3);plotinequation(x^2-y^2<3,[x=-2..2,y=-2..2],xstep=0.1,ystep=0.1);plotinequation(3-(x^2-y^2),[x=-2..2,y=-2..2],xstep=0.1,ystep=0.1);plotinequation([x+y>3,x^2<y],[x,y],xstep=0.2,ystep=0.2)","plotfunc,plotcontour,plotdensity,plotimplicit"},
{"plotlist",{"Trace la ligne polygonale reliant les points d'abscisse 0,...,n et d'ordonnée l=[y0,...,yn] ou la ligne reliant les points d'abscisse la première colonne de M et d'ordonnée sa deuxième colonne.","Draws the polygonal line through the points of abscissa 0,...,n and ordinate l=[y0,...,yn] or the line through the points of abscissa the first M column and ordinate the second column.",0,0},"Lst(l)||Mtrx(M)","listplot([13,10,15,16]);listplot([1,13],[2,10],[3,15],[4,16]);listplot([[0,13],[2,10],[4,15]])","polygonplot,scatterplot,polygonscatterplot"},
{"plotode",{"odeplot(f(t,y),[t,y],[t0,y0]) trace la solution de y'=f(t,y) et y(t0)=y0 ou du système [x'=g(t,x,y),y'=h(t,x,y)] avec x(t0)=x0 et y(t0)=y0.","odeplot(f(t,y),[t,y],[t0,y0]) draws the solution of y'=f(t,y) and y(t0)=y0 or of the system [x'=g(t,x,y),y'=h(t,x,y)] with x(t0)=x0 and y(t0)=y0.",0,0},"Expr,VectVar,VectInitCond","odeplot(sin(t*y),[t,y],[0,1]);odeplot(sin(t*y),[t=-10..10,y],[0,1]);odeplot(sin(t*y),[t=-3..3,y],[0,1],tstep=0.1,color=vert);odeplot([x-0.3*x*y, 0.3*x*y-y], [t,x,y],[0,0.3,0.7]);odeplot([x-0.3*x*y, 0.3*x*y-y], [t,x,y],[0,0.3,0.7],plan);odeplot([-y+b,-1+(x-a)^2+(y-b)^2],[t=-3..3,x,y],[0,a+1,b+0.5],plan);odeplot(5*[-y,x],[t=0..1,x,y],[0,0.3,0.7],tstep=0.05,plan)","interactive_plotode,fieldplot,odesolve,desolve"},
{"plotparam",{"plotparam(a(x)+i*b(x),x=x0..x1) trace la courbe X=a(x),Y=b(x) x=x0..x1 ou plotparam([a(u,v),b(u,v),c(u,v)],[u=u0..u1,v=v0..v1]) trace la surface X=a(u,v),Y=b(u,v),Z=c(u,v) u=u0..u1 et v=v0..v1.","plotparam(a(x)+i*b(x),x=x0..x1) draws the curve X=a(x),Y=b(x) x=x0..x1 or plotparam([a(u,v),b(u,v),c(u,v)],[u=u0..u1,v=v0..v1]) draws the surface X=a(u,v),Y=b(u,v),Z=c(u,v) u=u0..u1 and v=v0..v1.",0,0},"Cplx||Lst,Var||Lst(Var)","plotparam(sin(t)+i*cos(t),t);plotparam([sin(x),cos(x)],x=0..1);plotparam([sin(x),cos(x)],x=0..1,affichage=rouge);plotparam(sin(x)+i*cos(x),x=0..1,tstep=0.01);plotparam([v*cos(u),v*sin(u),v],[u,v]);plotparam([v*cos(u),v*sin(u),v],[u=0..pi,v=0..3],ustep=0.1,vstep=0.2)","plotfunc,plotpolar"},
{"plotpolar",{"plotpolar(f(x),x,a,b) trace la courbe en polaire r=f(x) pour x dans [a,b].","plotpolar(f(x),x,a,b) draws the polar curve r=fx) for x in [a,b].",0,0},"Expr,Var,VarMin,VarMax","plotpolar(sin(2*x),x,0,pi);plotpolar(sin(2*x),x,0,pi,tstep=0.1)","plotparam,plotfunc,plotpolar"},
{"plotproba",{"Graphe d'une matrice de transition probabiliste ayant au plus 7x7 entrées (en option la liste des positions des sommets)","Graph of a transition matrix with at most 7x7 entries (optionally with list of vertex positions)",0,0},"Matrix,[Vector]","plotproba([[1/2,1/3,1/12,1/12],[1/3,1/2,1/6,0],[0,0,1/2,1/2],[1/4,1/4,1/4,1/4],[\"xy\",b,\"state\",d]]);plotproba([[1/2,1/3,1/12,1/12],[1/3,1/2,1/6,0],[0,0,1/2,1/2],[1/4,1/4,1/4,1/4]],[0,1,i,1/3+2/3*i]); L:=point(1):;C:=point(0.5+0.3*i):;G:=point(0.5+0.8*i):;plotproba([[1/2,1/3,1/12],[1/3,1/2,1/6],[0,0,1/2]],[L,C,G])","markov,randmarkov"},
{"plotseq",{"Permet de visualiser les p premiers termes de la suite u(0)=a,u(n)=f(u(n-1)).","For seeing the pth terms of the sequence u(0)=a,u(n)=f(u(n-1)).",0,0},"Expr(f(Var)),Var=[a,xm,xM],Intg(p)","plotseq(sqrt(2+x),6,5);plotseq(sqrt(2+t),t=6,5);plotseq(sqrt(2+x),x=[6,1,7],5,affichage=epaisseur_ligne_2)","seqsolve,rsolve"},
{"plus_point",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," F:=display(point(2+1.5*i),point_point); F:=display(point(2+1.5*i),rhombus_point)","display"},
{"pmin",{"Renvoie le polynôme minimal de la matrice A ou le polynôme minimal du nombre algébrique a.","Returns the minimal polynomial of the matrix A or the minimal polynomial of the algebraic number a.",0,0},"Mtrx(A)||Real(a),[Var]","(αλγεβρική αριθμού).;pmin([[1,0],[0,1]]);pmin([[1,0],[0,1]],x);pmin(sqrt(2)+sqrt(3));pmin(sqrt(2)+sqrt(3),x)","pcar,jordan"},
{"point",{"A:=point(za) ou A:=point(a,b) (resp A:=point([a,b,c])) dessine le point d'affixe za=a+ib (resp de coordonnées (a,b,c)) et de légende A.","A:=point(za) or A:=point(a,b) (resp A:=point([a,b,c])) draws a point of affix za=a+ib (resp of coordinates (a,b,c)) with the legend A.",0,0},"Cplx(za)||Vect","point(1+2i);point(1,2);point(1,2,3);point([1,2,3]); B:=point(1-i); B:=point(1,-1); B:=point(1,0,0); B:=point([1,0,0])","pixon,line,point2d,point3d,polar_point"},
{"point2d",{"Définit au hasard, les coordonnées entières (entre -5 et +5) des points 2d donnés en argument.","Defines at random, the coordinates (between -5 and +5) of the 2d points given as argument.",0,0},"SeqVar(A,B,C...)","point2d(A,B,C,D)","point3d,point"},
{"point3d",{"Définit au hasard les coordonnées entières (entre -5 et +5) des points 3d donnés en argument.","Defines at random, the coordinates (between -5 and +5) of the 3d points given as argument.",0,0},"SeqVar(A,B,C...)","point3d(A,B,C,D)","point2d,point"},
{"point_carre",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," F:=display(point(2+1.5*i),point_point); F:=display(point(2+1.5*i),rhombus_point)","display"},
{"point_croix",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," F:=display(point(2+1.5*i),point_point); F:=display(point(2+1.5*i),rhombus_point)","display"},
{"point_etoile",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," F:=display(point(2+1.5*i),point_point); F:=display(point(2+1.5*i),rhombus_point)","display"},
{"point_invisible",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," F:=display(point(2+1.5*i),point_point); F:=display(point(2+1.5*i),rhombus_point)","display"},
{"point_losange",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," F:=display(point(2+1.5*i),point_point); F:=display(point(2+1.5*i),rhombus_point)","display"},
{"point_milieu",{"Option de la commande plotarea et de la commande area.","Option of the plotarea command and of the area command.",0,0},"Opt"," plotarea(x^2,x=0..1,5,trapezoid); plotarea(x^2,x=0..1,5,middle_point); plotarea(x^2,x=0..1,5,right_rectangle); plotarea(x^2,x=0..1,5,left_rectangle); area(x^2,x=0..1,5,middle_point); area(x^2,x=0..1,5,trapezoid)","plotarea,area"},
{"point_plus",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," F:=display(point(2+1.5*i),point_point); F:=display(point(2+1.5*i),rhombus_point)","display"},
{"point_point",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," F:=display(point(2+1.5*i),point_point); F:=display(point(2+1.5*i),rhombus_point)","display"},
{"point_triangle",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," F:=display(point(2+1.5*i),point_point); F:=display(point(2+1.5*i),rhombus_point)","display"},
{"point_width_1",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," display(point(1+i),green+point_triangle+point_width_2); display(milieu(segment(0,1+i)),point_width_5); point(i,affichage=epaisseur_point_3)","display,thickness"},
{"point_width_2",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," display(point(1+i),green+point_triangle+point_width_2); display(milieu(segment(0,1+i)),point_width_5); point(i,affichage=epaisseur_point_3)","display,thickness"},
{"point_width_3",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," display(point(1+i),green+point_triangle+point_width_2); display(milieu(segment(0,1+i)),point_width_5); point(i,affichage=epaisseur_point_3)","display,thickness"},
{"point_width_4",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," display(point(1+i),green+point_triangle+point_width_2); display(milieu(segment(0,1+i)),point_width_5); point(i,affichage=epaisseur_point_3)","display,thickness"},
{"point_width_5",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," display(point(1+i),green+point_triangle+point_width_2); display(milieu(segment(0,1+i)),point_width_5); point(i,affichage=epaisseur_point_3)","display,thickness"},
{"point_width_6",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," display(point(1+i),green+point_triangle+point_width_2); display(milieu(segment(0,1+i)),point_width_5); point(i,affichage=epaisseur_point_3)","display,thickness"},
{"point_width_7",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," display(point(1+i),green+point_triangle+point_width_2); display(milieu(segment(0,1+i)),point_width_5); point(i,affichage=epaisseur_point_3)","display,thickness"},
{"poisson",{"Renvoie exp(-mu)*mu^k/k!","Returns exp(-mu)*mu^k/k!",0,0},"Real(mu),Intg(k)","poisson(0.5,2);poisson(4.0,2); randvector(3,poisson,0.5); ranm(4,3,poisson,0.5)","poisson_cdf,poisson_icdf,randvector,ranm"},
{"poisson_cdf",{"Renvoie Proba(X<=x) quand X suit la loi de Poisson de moyenne mu.","Returns Proba(X<=x) when X follows the Poisson law with mu as mean.",0,0},"Real(mu),Real(x)","poisson_cdf(4.0,7);poisson_cpdf(2.5,4)","poisson,poisson_icdf"},
{"poisson_icdf",{"Renvoie h tel que Proba(X<=h)=p quand X suit la loi de Poisson de paramètre mu.","Returns h such as Proba(X<=h)=p when X follows the Poisson law with mu as parameter.",0,0},"Real(mu),Real(p)","poisson_icdf(4.0,0.95);poisson_icdf(2.5,0.9)","poisson,poisson_cdf"},
{"polar",{"Renvoie la droite des points conjugués de A par rapport au cercle.","Returns the line of the conjugated points of A with respect to the circle.",0,0},"Crcle,Pnt or Cplxe(A)","polar(circle(0,1),point(1+i)/2);polar(circle(0,1),point(1+i))","pole,is_conjugate"},
{"polar_coordinates",{"Renvoie la liste du module et de l'argument de l'affixe d'un point (en 2D) ou d'un nombre complexe ou de la liste des coordonnées rectangulaires.","Returns the list of the norm and of the argument of the affix of a point (for 2D) or of a complex number or of the the list of rectangular coordinates.",0,0},"Pnt or Cplx or LstRectCoord","polar_coordinates(point(1+2*i));polar_coordinates(-1-i);polar_coordinates([-1,2]);polar_coordinates(point(1+2*i)-point(-1+i))","abscissapoint,ordinate,rectangular_coordinates,polar_point"},
{"polar_point",{"Renvoie le point (en 2D) de coordonnées polaires les arguments r et t i.e. d'affixe r*exp(i*t).","Returns the point (for 2D) with the arguments r and t as polar coordinates (i.e. with  r*exp(i*t) as affix).",0,0},"Real(r),Real(t)","polar_point(1,pi/4);polar_point(2,-pi/3)","abscissa,ordinate,polar_coordinates,rectangular_coordinates,point"},
{"polarplot",{"plotpolar(f(x),x,a,b) trace la courbe en polaire r=f(x) pour x dans [a,b].","plotpolar(f(x),x,a,b) draws the polar curve r=fx) for x in [a,b].",0,0},"Expr,Var,VarMin,VarMax","plotpolar(sin(2*x),x,0,pi);plotpolar(sin(2*x),x,0,pi,tstep=0.1)","plotparam,plotfunc,plotpolar"},
{"pole",{"Renvoie le point ayant la droite comme polaire par rapport au cercle.","Returns the point having the line as polar with respect to the circle .",0,0},"Crcle,Line","pole(circle(0,1),line(i,1));pole(circle(0,1),line((1+i),2))","polar,is_conjugate"},
{"poly2symb",{"Renvoie le polynôme (ou sa valeur) de coefficients le premier argument et de variable le deuxième argument (par défaut x).","Gives the polynomial (or its value) : the first argument is the vector of coefficients and the second argument is the variable (by default x).",0,0},"Lst,Var","poly2symb([1,2,3]);poly2symb([1,2,3],x);poly2symb([1,2,3],-1);poly2symb([1,2,-1],y)","e2r,symb2poly"},
{"polyEval",{"Évalue en un point x0, un polynôme donné par ses coefficients.","Evaluates at a point x0, a polynomial given by its coefficients.",0,0},"Vect,Real(x0)","peval([1,0,-2],1);peval([1,2,-25,-26,120],8)","proot,pcoeff"},
{"polygon",{"Renvoie et dessine le polygone de sommets les éléments de l.","Returns and draws the polygon where its vertices are the element of l.",0,0},"LstPnt||LstCplx","polygon(i,1+i,2-i,-1,-1+i/2);polygon(point(0,0,0),point(3,3,3),point(0,0,3),point(3,0,0))","isopolygon,quadrilateral,convexhull,hexagon"},
{"polygone_rempli",{"L'argument est un entier <-1 qui indique le nombre de positions précédentes de la tortue qui forment un polygone et créé ce polygone rempli.","The argument is an integer <-1 which gives the number of previous turtle position drawing a polygon and created this full polygon.",0,0},"Intg(n)"," repete(4,avance 40,tourne_droite);polygone_rempli -8; repete(3,avance 40,tourne_droite 120);polygone_rempli -6; repete(3,avance 40,avance 40,tourne_droite 120);polygone_rempli -9",""},
{"polygonplot",{"Dessine les polygones joignant pour j fixé et pour k=0..nrows, les points (xk,yk) où xk=élément ligne k colonne 0 et yk=élément ligne k colonne j en ordonnant les xk (on obtient ncols-1 polygones).","Draws the polygons joining for j fixed and for k=0..nrows, the points (xk,yk) where xk=element row k column 0 et yk=element row k column j ,when the xk are sorted (we obtain ncols-1 polygons).",0,0},"Mtrx","polygonplot([[1,2,3],[2,0,1],[-1,2,3]])","scatterplot,listplot,polygonscatterplot"},
{"polygonscatterplot",{"Dessine les points (xk,yk) et les polygones joignant pour j fixé et pour k=0..nrows, les points (xk,yk) où xk=élément ligne k colonne 0 et yk=élément ligne k colonne j en ordonnant les xk (on obtient ncols-1 polygones).","Draws the points (xk,yk) and the polygons joining for j fixed and for k=0..nrows, the points (xk,yk) where xk=element row k column 0 et yk=element row k column j ,when the xk are sorted (we obtain ncols-1 polygons).",0,0},"Mtrx","polygonscatterplot([[1,2,3],[2,0,1],[-1,2,3]])","scatterplot,polygonplot,listplot"},
{"polyhedron",{"Dessine un polyèdre convexe dont les sommets sont parmi les arguments.","Draws a convex polyhedron with vertices among the arguments.",0,0},"SeqPnt(A,B,C...)","polyhedron([0,0,0],[0,5,0],[0,0,5],[1,2,6])","cube,parallelepiped"},
{"polynom",{"Option de la commande convert ou convertir et des commandes taylor et series (list=>n-poly ou series=>poly).","Option of the convert or convertir command and of the taylor and series commands (list=>n-poly ou series=>poly).",0,0},"Opt"," convert([[10,[3,1]],[12,[2,2]]],polynom); convert(taylor(sin(x)),polynom); convert(series(sin(x),x=0,6),polynom); taylor(sin(x),x=0,5,polynom); series(sin(x),x=0,6,,polynom)","poly2symb,taylor,series,convert"},
{"polynomial_regression",{"Renvoie les coefficients (an,...a1,a0) de y=an*x^n+..a1x+a0) : c'est le polynôme qui approche le mieux les points ayant pour coordonnées les lignes de A (ou les 2 listes) (n est le 2ème argument).","Returns the coefficients (an,...a1,a0) of y=an*x^n+..a1x+a0) : it is the best polynomial which approx the points where the coordinates are the rows of A (or the 2 lists) (n is the 2nd argument).",0,0},"Lst||Mtrx(A),[Lst],Intg(n)","polynomial_regression([[1.0,1.0],[2.0,4.0],[3.0,9.0],[4.0,16.0]],3);polynomial_regression([[0.0,1.0],[2.0,4.0],[3.0,9.0],[4.0,16.0]],3);polynomial_regression([0.0,2.0,3.0,4.0],[1.0,4.0,9.0,16.0],3)","linear_regression,power_regression"},
{"polynomial_regression_plot",{"Renvoie le graphe de y=an*x^n+..a1x+a0) : c'est le polynôme qui approche le mieux les points ayant pour coordonnées les lignes de A (ou les 2 listes) (n est le 2ème argument).","Returns the plot of y=an*x^n+..a1x+a0) : it is the best polynomial which approx the points where the coordinates are the rows of A (or the 2 lists) (n is the 2nd argument).",0,0},"Lst||Mtrx(A),[Lst],Intg(n)","polynomial_regression_plot([[1.0,1.0],[2.0,4.0],[3.0,9.0],[4.0,16.0]],3);polynomial_regression_plot([[0.0,1.0],[2.0,4.0],[3.0,9.0],[4.0,16.0]],3);polynomial_regression_plot([0.0,2.0,3.0,4.0],[1.0,4.0,9.0,16.0],3)","linear_regression_plot,power_regression_plot"},
{"position",{"Retourne la position de la tortue en pixels ou place la tortue selon l'argument sans changer son cap.","Returns the turtle position in pixels or puts the turtle at the position given by the argument with the same cap.",0,0},"NULL or LstCoord","position();position(50,70);position([50,70])","cap,initialise"},
{"poslbdLMQ",{"Renvoie une borne inférieure pour les racines positives de P par l'algorithme Akritas-Strzebonski-Vigklas' Local Max Quadratic (LMQ).","Returns a lower bound on the values of the positive roots of P. Akritas-Strzebonski-Vigklas' Local Max Quadratic (LMQ) method is used.",0,0},"Poly(P)","poslbdLMQ(x^3-7*x+7)","posubLMQ,VAS_positive,realroot"},
{"posubLMQ",{"Renvoie une borne supérieure pour les racines positives de P par l'algorithme Akritas-Strzebonski-Vigklas' Local Max Quadratic (LMQ).","Returns an upper bound on the values of the positive roots of P. Akritas-Strzebonski-Vigklas' Local Max Quadratic (LMQ) method is used.",0,0},"Poly(P)","posubLMQ(x^3-7*x+7)","poslbdLMQ,VAS_positive,realroot"},
{"potential",{"Renvoie U tel que gradient(U)=derive(U,Vector_of_variable)=V.","Returns U such as derive(U,Vector_of_variable)=V.",0,0},"Vect(V),VectVar","potential([2*x*y+3,x^2-4*z,-4*y],[x,y,z])","derive,vpotential"},
{"pour",{"Boucle pour (pour...de ...jusque... [pas...] faire...fpour;).","Loop pour (pour...de ...jusque... [pas...] faire...fpour;).",0,0},""," pour de jusque faire fpour;; S:=0;pour n de 1 jusque 4 faire S:=S+n;fpour;; S:=0;for n from 1 to 4 do S:=S+n;end;; pour n de 1 jusque 4 faire disque(10*n);saute(10*n);fpour;; pour n de 4 jusque 1 pas -1 faire disque(10*n);saute(10*n);fpour;; S:=0;pour n de 4 jusque 1 pas -1 faire S:=S+n;fpour;","for,de,jusque,pas"},
{"pow",{"Calcule a^n.(puissance rapide).","Computes a^n (fast algorithm).",0,0},"Intg(a),Intg(n)","pow(17,452);pow(x+1,452)","^,powmod"},
{"pow2exp",{"Convertit les puissances en exponentielles.","Converts powers to exponentials.",0,0},"Expr","pow2exp(a^b)","exp2pow"},
{"power_regression",{"Renvoie les coefficients (m,b) de y=b*x^m : c'est le monôme qui approche le mieux les points ayant pour coordonnées les lignes de A (ou les 2 listes).","Returns the coefficients (m,b) of y=b*x^m : it is the best monomial which approx the points where the coordinates are the rows of A (or the 2 lists).",0,0},"Lst|Mtrx(A),[Lst]","power_regression([[1.0,1.0],[2.0,4.0],[3.0,9.0],[4.0,16.0]]);power_regression([[1.0,2.0],[2.0,4.0],[3.0,9.0],[4.0,16.0]]);power_regression([1.0,2.0,3.0,4.0],[2.0,4.0,9.0,16.0])","polynomial_regression,linear_regressiont"},
{"power_regression_plot",{"Renvoie le graphe de y=b*x^m : c'est le monôme qui approche le mieux les points ayant pour coordonnées les lignes de A (ou les 2 listes).","Returns the plot of y=b*x^m : it is the best monomial which approx the points where the coordinates are the rows of A (or the 2 lists).",0,0},"Lst||Mtrx(A),[Lst]","power_regression_plot([[1.0,1.0],[2.0,4.0],[3.0,9.0],[4.0,16.0]]);power_regression_plot([[1.0,2.0],[2.0,4.0],[3.0,9.0],[4.0,16.0]]);power_regression_plot([1.0,2.0,3.0,4.0],[2.0,4.0,9.0,16.0])","polynomial_regression_plot,linear_regression_plot"},
{"powermod",{"Calcule a^n modulo p ou modulo p,P(x) (puissance rapide).","Computes a^n modulo p or modulo p,P(x) (fast algorithm).",0,0},"Intg(a),Intg(n),Intg(p),[Expr(P(x))],[Var]","powmod(17,452,19);powmod(x+1,452,19,x^4+x+1,x)","pow,^"},
{"powerpc",{"Renvoie le nombre réel d^2-R^2 (d=distance du point au centre, R=rayon).","Returns the real number d^2-R^2 (d=distance between point and center, R=radius) .",0,0},"Cercle,Pnt or Cplx","powerpc(circle(0,1+i),3+i);powerpc(circle(0,point(1+i)),3+i)","radical_axis"},
{"powexpand",{"Développe l'expression en fonction de l'exposant.","Expands the expression in function of the exponent.",0,0},"Expr","powexpand(2^(x+y));powexpand(3^(2*x))",""},
{"powmod",{"Calcule a^n modulo p ou modulo p,P(x) (puissance rapide).","Computes a^n modulo p or modulo p,P(x) (fast algorithm).",0,0},"Intg(a),Intg(n),Intg(p),[Expr(P(x))],[Var]","powmod(17,452,19);powmod(x+1,452,19,x^4+x+1,x)","pow,^"},
{"prepend",{"Met l'élément au début de la liste.","Puts the element at the beginning of the list.",0,0},"Lst,Elem","prepend([1,2],3)","append,concat"},
{"preval",{"Renvoie F(b)-F(a).","Returns F(b)-F(a).",0,0},"Expr(F(var)),Real(a),Real(b),[Var]","preval(x^2-2,2,3);preval(y^2-2,2,3,y);preval(int(x),0,1);preval(int(y,y),0,1,y)","subst,int"},
{"prevperm",{"Renvoie la permutation précédente dans l'ordre lexicographique.","Returns the previous permutation with the lexicographic order.",0,0},"Intg(n)","prevperm([0,1,3,2]);prevperm([0,1,2,3])","nextperm,is_permu"},
{"prevprime",{"Nombre premier ou pseudo-premier précédent un entier a donné.","Previous prime or pseudo-prime before a given integer a.",0,0},"Intg(a)","prevprime(9856989898999);prevprime(97160249868928888261606009)","nextprime,is_prime,ithprime"},
{"primpart",{"Renvoie le polynôme P divisé par le pgcd de ses coefficients.","Returns the polynomial P divided by the gcd of its coefficients.",0,0},"Poly(P),[Var]","primpart(2x^2+10x+6);primpart(2t^2+10t+6,t)","content"},
{"print",{"Permet d'afficher un résultat intermédiaire dans un programme.","Prints a result in a program.",0,0},"Expr or Str","print(\"salut\");print(a)",""},
{"prism",{"Dessine un prisme de base plane ABCD...et d'arêtes parallèles à AA1 (les faces sont des parallélogrammes).","Draws a prism with plane base ABCD...and with edges parallel to AA1 (the faces are parallelograms).",0,0},"LstPnt([A,B,C,D]),Pnt(A1)","prism([[0,0,0],[5,0,0],[0,5,0],[-5,5,0]],[0,0,5])","cube,polyhedron"},
{"proc",{"Début de procédure (comme en MuPAD).","Begin a procedure (like with MuPAD).",0,0},""," proc ... begin ... end_proc;",""},
{"product",{"Produit des valeurs de l'expression quand la variable va de a à b avec un pas p (product(expression,var,debut,fin,pas) par défaut p=1) ou produit des éléments d'une liste ou produit terme à terme des éléments de 2 listes ou matrices.","Multiplicates the values of the expression when the variable go from a to b with a step p (product(expression,var,begin,end,step) by default p=1) or product of the elements of a list or product element by element of 2 lists or matrix.",0,0},"Expr||Lst,[Var||Lst],[Intg(a)],[Intg(b)],[Intg(p)]","product(n,n,1,10,2);product(1/n,n,1,10);product(1/n,n,11,1);product(1/n,n,10,1,1);product([2,3,4,5]);product([2,3,4],[5,6,7]);product([[2,3,4],[5,6,7]],[[2,3,4],[5,6,7]])","sum"},
{"program",{"Mot réservé.","Reserved word.",0,0},"",0,""},
{"projection",{"projection(C,A) est la projection orthogonale de A sur la courbe C.","projection(C,A) is the orthogonal projection of A on the curve C.",0,0},"Curve,Pnt"," H:=projection(line(i,1-i),1+i); K:=projection(circle(0,1),1+i); J:=projection(circle(0,1),point(1+2*i))","perpendicular"},
{"proot",{"Retourne les racines approchées d'un polynôme donné par ses coefficients (ne marche pas en général pour les racines multiples). On peut en option préciser le nombre n de chiffres significatifs. ","Returns all computed roots of a polynomial given by its coefficients (may not work if roots are not simple).",0,0},"Vect||Poly,[Intg(n)]","proot([1,0,-2]);proot(x^2-2);proot([1,2,-25,-26,120]);proot(x^4+5x-3,30)","pcoeff,peval,realroot,complexroot,rationalroot,crationalroot"},
{"propFrac",{"Simplifie et écrit la fraction (ou fraction rationnelle) A/B sous la forme Q+R/B avec R<B (ou deg(R)<deg(B)).","Simplifies and writes the fraction (or rational fraction) A/B as Q+R/B with R<B (or deg(R)<deg(B)).",0,0},"Frac or RatFrac","propfrac(28/12);propfrac((x^2+2*x-1)/(x+1))","partfrac"},
{"propfrac",{"Simplifie et écrit la fraction (ou fraction rationnelle) A/B sous la forme Q+R/B avec R<B (ou deg(R)<deg(B)).","Simplifies and writes the fraction (or rational fraction) A/B as Q+R/B with R<B (or deg(R)<deg(B)).",0,0},"Frac or RatFrac","propfrac(28/12);propfrac((x^2+2*x-1)/(x+1))","partfrac"},
{"psrgcd",{"PGCD de 2 polynômes avec l'algorithme du sous résultant.","GCD of 2 polynomials, with the sub resultant algorithm.",0,0},"Poly,Poly","psrgcd(x^4-1,(x-1)^2)","gcd,modgcd,ezgcd,heugcd"},
{"ptayl",{"Renvoie le polynôme de Taylor de l'expression au point à l'ordre spécifié ou le polynôme Q tel que P(x)=Q(x-a).","Returns the Taylor polynomial of the expression at the given point and order or a polynomial Q such that P(x)=Q(x-a).",0,0},"Expr||Poly(P(var)),Var=Real || Real(a),[Order || Var]","ptayl(sin(x),x=0,5);ptayl(x^2+2*x+1,1);ptayl(x^2+2*x+1,-1);ptayl(y^2+2*y+1,1.1,y);ptayl(y^3+y^2+2*y+1,2,y); subst(ptayl(y^3+y^2+2*y+1,2,y),y,y-2)","series,taylor"},
{"purge",{"purge(nomvar) enlève la valeur stockée dans la variable nomvar.","purge(varname) unassign the variable varname.",0,0},"Var","purge(t);purge(C)","sto,restart,assume,about"},
{"pwd",{"Répertoire de travail actuel.","Current working directory.",0,0},"NULL","pwd()","cd"},
{"pyramid",{"Dessine le tétraèdre régulier direct de coté AB dont une face est dans le plan (A,B,C) quand il y a 3 arguments et la pyramide ABCD quand il y a 4 arguments.","Draws the regular direct pyramid ABCD with vertices A,B and a face in the plan (A,B,C) when there is 3 arguments et the pyramid ABCD when there is 4 arguments.",0,0},"Pnt(A),Pnt(B),Pnt(C),[Pnt(D)]","pyramid([0,0,0],[3,0,0],[0,1,0]);pyramid([0,0,0],[3,0,0],[0,3,0],[0,0,4])","cube,cylinder,icosahedron,dodecahedron,octahedron"},
{"q2a",{"q2a(q(x,y),[x,y])=la matrice symétrique associée à la forme quadratique q.","q2a(q(x,y),[x,y])=the symmetric matrix associated to the quadratic form q.",0,0},"QuadraForm, VectVar","q2a(x^2+2*x*y+2*y^2,[x,y])","a2q"},
{"qr",{"Pour A matrice numérique, renvoie R (right) telle que A=QR et Q orthogonale.","For a numerical matrix A, returns R (right) such that A=QR and Q orthogonal.",0,0},"Mtrx","qr([[1,2],[3,4]])","lu"},
{"quadrant1",{"Option de la commande affichage pour afficher une légende.","Option of the display command to write a legend.",0,0},"Opt"," display(legende(1+i,\"abc\"),4+quadrant2)","display"},
{"quadrant2",{"Option de la commande affichage pour afficher une légende.","Option of the display command to write a legend.",0,0},"Opt"," display(legende(1+i,\"abc\"),4+quadrant2)","display"},
{"quadrant3",{"Option de la commande affichage pour afficher une légende.","Option of the display command to write a legend.",0,0},"Opt"," display(legende(1+i,\"abc\"),4+quadrant2)","display"},
{"quadrant4",{"Option de la commande affichage pour afficher une légende.","Option of the display command to write a legend.",0,0},"Opt"," display(legende(1+i,\"abc\"),4+quadrant2)","display"},
{"quadric",{"Définit une quadrique par son équation cartésienne de variables x,y,z par défaut et la trace.","Defines a quadric by its cartesian equation with x,y,z as default variables and draws it.",0,0},"Expr,[Lst(Var)]","quadric(4*x^2+y^2+z^2-4*x*y+4*x*z-2*y*z+8*x-4*y+4*z+2);quadric(x^2+3*y^2-3*z^2-8*y*z+2*z*x-4*x*y-1,x,y,z,affichage=vert+rempli);quadric((u+v)*(v-w)+3*u-5*v,[u,v,w],affichage=cyan);quadric(7*x^2+4*y^2+4*z^2+4*x*y-4*x*z-2*y*z-4*x+5*y+4*z-18,[x,y,z])","reduced_quadric"},
{"quadrilateral",{"Renvoie et dessine le quadrilatère ABCD.","Returns and draws the quadrilateral ABCD.",0,0},"Pnt(A)||Cplx,Pnt(B)||Cplx,Pnt(C)||Cplx,Pnt(D)||Cplx","quadrilateral(i,1+i,2-i,-1);quadrilateral(point(0,0,0),point(3,3,3),point(0,0,3),point(3,0,0))","polygon,square"},
{"quantile",{"Renvoie le quantile des éléments de l correspondant à la valeur de p (0<p<1).","Returns the quantile of the elements of l corresponding to p (0<p<1).",0,0},"Lst(l),Real(p)","quantile([0,1,3,4,2,5,6],0.25);quantile([0,1,3,4,2,5,6],0.75)","quartile1,median,quartile3"},
{"quartile1",{"Renvoie le 1er quartile des éléments (ou des colonnes) de l'argument.","Returns the 1st quartile of the elements (or of the columns) of its argument.",0,0},"Lst||Mtrx,[Lst]","quartile1([1,2,3,5,10,4]);quartile1([1,2,3,5,10,4],[1,2,3,1,2,3]);quartile1([[1,2],[5,4],[3,6],[7,8]])","quantile,quartiles"},
{"quartile3",{"Renvoie le 3ème quartile des éléments (ou des colonnes) de l'argument.","Returns the 3rd quartile of the elements (or of the columns) of its argument.",0,0},"Lst||Mtrx,[Lst]","quartile3([1,2,3,5,10,4]);quartile3([[1,2,3,5,10,4],[2,3,4,4,5,6],[7,6,5,8,9,1]]);quartile3([[1,2],[5,4],[3,6],[7,8]])","quartiles,quantile"},
{"quartiles",{"Min, 1er quartile, médiane, 3ème quartile, max des éléments (ou des colonnes) de l'argument.","Min,1st quartile,the median,3rd quartile, max of the elements (or of the columns) of its argument.",0,0},"Lst||Mtrx,[Lst]","quartiles([1,2,3,5,10,4]);quartiles([1,2,3,5,10,4],[1,2,3,5,10,4]);quartiles([[1,2],[5,4],[3,6],[7,8]])","boxwhisker,quantile,mean"},
{"quest",{"Renvoie la (n+1)-ième question de l'historique des commandes si n>=0 ou, la (-n)-ième question précédente si n<0 (par défaut n=-1 pour la question précédente).","Returns the n+1-th question of the command history if n>=0 or, the (-n)th previous question if n<0 (by defaults n=-1 for the previous question).",0,0},"Intg(n)","quest();quest(2);quest(-2)","ans"},
{"quo",{"Quotient euclidien de 2 polynômes.","Euclidean quotient of 2 polynomials.",0,0},"(Vect or Poly),(Vect or Poly),[Var]","quo([1,2,3,4],[-1,2]);quo(x^3+2x^2+3x+4,-x+2);quo(t^3+2t^2+3t+4,-t+2,t)","rem,quorem,Quo,iquo"},
{"quorem",{"Quotient et reste euclidien de 2 polynômes.","Euclidean quotient and remainder of 2 polynomials.",0,0},"(Vect or Poly),(Vect or Poly),[Var]","quorem([1,2,3,4],[-1,2]);quorem(x^3+2x^2+3x+4,-x+2);quorem(t^3+2t^2+3t+4,-t+2,t);quorem(t^4-1,(t+1)^2,t)","rem,quo,iquorem"},
{"quote",{"Retourne son argument sans l'évaluer (et aussi a:=quote(a) qui purge a).","Returns its argument unevaluated (and also a:=quote(a) that purge a).",0,0},"Expr","quote(1+2);quote(1/x+1/(x-1));quote((x+1)*(x-1))",""},
{"r2e",{"Renvoie le polynôme (ou sa valeur) de coefficients le premier argument et de variable le deuxième argument (par défaut x).","Gives the polynomial (or its value) : the first argument is the vector of coefficients and the second argument is the variable (by default x).",0,0},"Lst,Var","poly2symb([1,2,3]);poly2symb([1,2,3],x);poly2symb([1,2,3],-1);poly2symb([1,2,-1],y)","e2r,symb2poly"},
{"radical_axis",{"Renvoie la droite des points de même puissance par rapport aux 2 cercles.","Returns the line of points with same powerpc with respect to the 2 circles.",0,0},"Crcle,Crcle","radical_axis(circle(0,1+i),circle(1,1+i));radical_axis(circle(0,point(1+i)),circle(1,point(1+i)))","powerpc"},
{"radius",{"rayon(C) donne le rayon du cercle C.","radius(C) gives the radius of the circle C.",0,0},"Crcle","radius(incircle(-1,1-i,i))","center,circle"},
{"ramene",{"Pour lire dans le fichier fich_name les variables et leurs valeurs.","To read in the file fich_name the variables and their values.",0,0},"Str(fich_name)","read(\"toto\")","write"},
{"rand",{"rand(n)=un entier (resp rand(p,n)=un réel ou rand(p..n)=une fonction réelle) aléatoire uniformément distribué dans 0.. n-1 (resp dans [p; n]) (rand()=rand(0,1)=un réel de [0,1[) ou rand(n,b1,b2)=n entiers de [b1;b2] ou rand(n,L)=n éléments de L.","rand(n)=a random integer (resp rand(p,n)=a real or rand(p..n)=a real function) with uniform distribution in 0..n-1 (resp in [p;n])(rand()=rand(0,1)=a real in [0,1[) or rand(n,b1,b2)=n integers between b1 and b2 or rand(n,L)=n elements of L.",0,0},"Intg(n) or Interval(p..n) or NULL,[Intg(b1) or Lst(L)],[Intg(b2)]","rand(4);rand();rand(0,2);rand(0..2)(); f:=rand(0..2);rand(3,1,10);rand(3,[\"r\",\"r\",\"r\",\"b\",\"n\"])","srand,randpoly,ranm,randvector,hasard"},
{"randMat",{"Renvoie une liste de taille n ou une matrice n*m constituée d'entiers aléatoires uniformément distribués entre -99 et 99 ou de nombres aléatoires distribués selon la loi mise entre-quote.","Returns a list of size n or a n*m matrix that contains random integers in the range -99 through 99 with uniform distribution or contains random numbers according to the law put between quote.",0,0},"Intg(n), [Intg(m)],[Interval or quote(DistribLaw)]","ranm(3);ranm(3,2);ranm(3,2,6);ranm(3,2,binomial,10,0.3);ranm(3,2,multinomial,[1/2,1/3,1/6]);ranm(3,2,poisson,5.2);ranm(3,2,normald,0,1);ranm(3,2,exp,7/2);ranm(3,2,poisson,1.2);ranm(3,2,'rand(3)');ranm(3,2,1..2);ranm(3,5,multinomial,[1/2,1/3,1/6],[\"R\",\"V\",\"B\"]); GF(2,8,g);ranm(3,3,g)","idn,randPoly,rand,randvector"},
{"randNorm",{"Renvoie un réel aléatoirement distribué selon la loi normale N(mu,sigma).","Returns a random real with normal distribution N(mu,sigma).",0,0},"Real(mu),Real(sigma)","randnorm(0,1);randnorm(2,1)","rand,randpoly,ranm,randvector,randexp,randbinomial,randpoisson,randgeometric,randmultinomial"},
{"randPoly",{"Renvoie un polynôme de variable var (ou x), de degré n et dont les coefficients sont des entiers aléatoires équirépartis sur -99,+99 ou selon une loi.","Returns a polynomial of variable var (or x), of degree n and where the coefficients are random integers in the range -99 through 99 with uniform distribution or according to a law.",0,0},"[Var(var)],Intg(n),[law]","randpoly(5);randpoly(t,8);randpoly(t,8,-1..1); GF(2,8,g);randpoly(t,8,g)","ranm,randvector"},
{"randbinomial",{"Renvoie un entier aléatoirement distribué selon la loi binomiale B(n,p) i.e. le nombre de succès dans une suite de n tirages indépendants lorsque pour chaque tirage, un succès est de probabilité p.","Returns a random integer with binomial distribution B(n,p) i.e. the number of success for n independant tests where for each test, the success probability is p.",0,0},"Intg(n),Real(p)","randbinomial(10,0.4);randbinomial(100,0.8)","rand,randpoly,ranm,randvector,randexp,randnorm,randpoisson,randgeometric,randmultinomial"},
{"randchisquare",{"Renvoie un entier aléatoirement distribué selon la loi du chi^2 ayant n degrés de liberté, χ^2(n).","Returns a random integer with chi^2 distribution, χ^2(n).",0,0},"Intg(n)","randchisquare(5);randchisquare(2)","rand,randpoly,ranm,randvector,randexp,randbinomial,randnorm,randgeometric,randmultinomial"},
{"randexp",{"Renvoie un réel aléatoirement distribué selon la loi exponentielle de paramètre a>0.","Returns a random real according to the exponential distribution of parameter a>0.",0,0},"Real(a)","randexp(1);randexp(2)","rand,randpoly,randnorm,randvector"},
{"randfisher",{"Renvoie un entier aléatoirement distribué selon la loi de Fisher-Snedecor F(n,m).","Returns a random integer with Fisher-Snedecor distribution F(n,m).",0,0},"Intg(n),Intg(m)","randfisher(5,2);randfisher(2,4)","rand,randpoly,ranm,randvector,randexp,randbinomial,randnorm,randgeometric,randmultinomial"},
{"randgeometric",{"Renvoie un entier aléatoirement distribué selon la loi géométrique de paramètre p.","Returns a random integer following geometric distribution of parameter p.",0,0},"Real(p)","randgeometric(0.4)","rand,randpoly,ranm,randvector,randexp,randnorm,randpoisson,randbinomial,randmultinomial"},
{"randmarkov",{"Génère une suite de n états (chaîne de Markov) partant de i0 dont les probabilités de transitions sont données par M (matrice stochastique) ou génère une matrice stochastique ayant p boucles récurrentes v=[n1,...,np] et i0 états transients.","Returns a random sequence of n states (Markov chain) starting from i0, with probability transition matrix M, or returns a stochastic matrix with p recurrent loops v=[n1,..,np] and i0 transient states.",0,0},"Mtrx(M) || Vctr(v),Intg(i0),[Intg(n)]","randmarkov([[0,0,1/2,0,1/2],[0,0,1,0,0],[1/4,1/4,0,1/4,1/4],[0,0,1/2,0,1/2],[0,0,0,0,1]],2,20);randmarkov([1,2,1,3],4)","markov,plotproba"},
{"randmatrix",{"Renvoie une liste de taille n ou une matrice n*m constituée d'entiers aléatoires uniformément distribués entre -99 et 99 ou de nombres aléatoires distribués selon la loi mise entre-quote.","Returns a list of size n or a n*m matrix that contains random integers in the range -99 through 99 with uniform distribution or contains random numbers according to the law put between quote.",0,0},"Intg(n), [Intg(m)],[Interval or quote(DistribLaw)]","ranm(3);ranm(3,2);ranm(3,2,6);ranm(3,2,binomial,10,0.3);ranm(3,2,multinomial,[1/2,1/3,1/6]);ranm(3,2,poisson,5.2);ranm(3,2,normald,0,1);ranm(3,2,exp,7/2);ranm(3,2,poisson,1.2);ranm(3,2,'rand(3)');ranm(3,2,1..2);ranm(3,5,multinomial,[1/2,1/3,1/6],[\"R\",\"V\",\"B\"]); GF(2,8,g);ranm(3,3,g)","idn,randPoly,rand,randvector"},
{"randmultinomial",{"Renvoie un index ou un élément d'une liste K, aléatoirement selon la loi multinomiale de probabilités données par une liste P.","Returns a random index or list element according to a multinomial distribution probability list P.",0,0},"List(P),[List(K)]","randmultinomial([1/2,1/3,1/6]);randmultinomial([1/2,1/3,1/6],[\"R\",\"V\",\"B\"])","rand,randpoly,ranm,randvector,randexp,randnorm,randpoisson,randgeometric,randbinomial"},
{"randnorm",{"Renvoie un réel aléatoirement distribué selon la loi normale N(mu,sigma).","Returns a random real with normal distribution N(mu,sigma).",0,0},"Real(mu),Real(sigma)","randnorm(0,1);randnorm(2,1)","rand,randpoly,ranm,randvector,randexp,randbinomial,randpoisson,randgeometric,randmultinomial"},
{"randperm",{"Renvoie une permutation aléatoire de [0,1,2,..,n-1].","Returns a random permutation of [0,1,2,..,n-1].",0,0},"Intg(n)","randperm(4);randperm(7)","permu2cycles,is_permu"},
{"randpoisson",{"Renvoie un entier aléatoirement distribué selon la loi de poisson P(λ).","Returns a random integer with poisson distribution P(λ).",0,0},"Real(λ)","randpoisson(5.4);randpoisson(2.8)","rand,randpoly,ranm,randvector,randexp,randbinomial,randnorm,randgeometric,randmultinomial"},
{"randpoly",{"Renvoie un polynôme de variable var (ou x), de degré n et dont les coefficients sont des entiers aléatoires équirépartis sur -99,+99 ou selon une loi.","Returns a polynomial of variable var (or x), of degree n and where the coefficients are random integers in the range -99 through 99 with uniform distribution or according to a law.",0,0},"[Var(var)],Intg(n),[law]","randpoly(5);randpoly(t,8);randpoly(t,8,-1..1); GF(2,8,g);randpoly(t,8,g)","ranm,randvector"},
{"randseed",{"srand ou srand(n) initialise la suite des nombres aléatoires : srand renvoie un entier qui a servi à cette initialisation et srand(n) renvoie n.","srand returns an integer and initialize the sequence of random numbers.",0,0},"","srand(12); srand","RandSeed"},
{"randstudent",{"Renvoie un entier aléatoirement distribué selon la loi de Student S(n).","Returns a random integer with Student distribution S(n).",0,0},"Intg(n)","randstudent(5);randstudent(2)","rand,randpoly,ranm,randvector,randexp,randbinomial,randnorm,randgeometric,randmultinomial"},
{"randvector",{"Renvoie une liste de taille n constituée d'entiers aléatoires entre -99 et 99 ou (entre 0 et m-1) uniformément distribués ou de nombres aléatoires distribués selon la loi mise entre-quote.","Returns a list of size n that contains random integers in the range -99 through 99 (or in 0..m-1) with uniform distribution or contains random numbers according to the law put between quote.",0,0},"Intg(n), [Intg(m)],[Interval or quote(DistribLaw)]","randvector(3);randvector(3,6);randvector(3,normald,0,1);randvector(3,poisson,1.2);randvector(3,exponentiald,1.2);randvector(3,multinomial,[1/2,1/3,1/6]);randvector(3,multinomial,[1/2,1/3,1/6],[a,b,c]);randvector(3,'rand(3)');randvector(3,1..2); GF(2,8,g);randvector(3,g)","idn,randPoly,rand,ranm"},
{"range",{"Renvoie la liste [0,1..n-1] ou la liste [a,a+1..b[ ou la liste [a,a+p,a+2p..b[","Returns the list [0,1..n-1] or the list [a,a+1..b[ or the list [a,a+p,a+2p..b[",0,0},"Intg(n)||Intg(a),Intg(b),[Intg(p)]","range(10);range(1,11);range(1,11,2);range(1,11,3);range(11,1,-1)","$,makelist,seq"},
{"rank",{"Renvoie le rang de la matrice.","Returns the rank of the matrix.",0,0},"Mtrx","rank([[1,1,2],[2,1,3],[3,1,4]]);rank([[1,1,2],[2,1,3],[3,1,5]])","det,image"},
{"ranm",{"Renvoie une liste de taille n ou une matrice n*m constituée d'entiers aléatoires uniformément distribués entre -99 et 99 ou de nombres aléatoires distribués selon la loi mise entre-quote.","Returns a list of size n or a n*m matrix that contains random integers in the range -99 through 99 with uniform distribution or contains random numbers according to the law put between quote.",0,0},"Intg(n), [Intg(m)],[Interval or quote(DistribLaw)]","ranm(3);ranm(3,2);ranm(3,2,6);ranm(3,2,binomial,10,0.3);ranm(3,2,multinomial,[1/2,1/3,1/6]);ranm(3,2,poisson,5.2);ranm(3,2,normald,0,1);ranm(3,2,exp,7/2);ranm(3,2,poisson,1.2);ranm(3,2,'rand(3)');ranm(3,2,1..2);ranm(3,5,multinomial,[1/2,1/3,1/6],[\"R\",\"V\",\"B\"]); GF(2,8,g);ranm(3,3,g)","idn,randPoly,rand,randvector"},
{"ranv",{"Renvoie une liste de taille n constituée d'entiers aléatoires entre -99 et 99 ou (entre 0 et m-1) uniformément distribués ou de nombres aléatoires distribués selon la loi mise entre-quote.","Returns a list of size n that contains random integers in the range -99 through 99 (or in 0..m-1) with uniform distribution or contains random numbers according to the law put between quote.",0,0},"Intg(n), [Intg(m)],[Interval or quote(DistribLaw)]","randvector(3);randvector(3,6);randvector(3,normald,0,1);randvector(3,poisson,1.2);randvector(3,exponentiald,1.2);randvector(3,multinomial,[1/2,1/3,1/6]);randvector(3,multinomial,[1/2,1/3,1/6],[a,b,c]);randvector(3,'rand(3)');randvector(3,1..2); GF(2,8,g);randvector(3,g)","idn,randPoly,rand,ranm"},
{"rassembler_trigo",{"Rassemble des expressions trigonométriques.","Collect trigonometric expressions.",0,0},"Expr","tcollect(sin(x)+cos(x))","texpand,tlin"},
{"rat_jordan",{"Renvoie la liste formée par la matrice de passage et la forme de Jordan rationnelle d'une matrice.","Returns the list made by the matrix of passage and the rational Jordan form of a matrix.",0,0},"Mtrx","rat_jordan([[0,2],[1,0]]);rat_jordan([[-2,-2,1],[-2,1,-2],[1,-2,-2]]);rat_jordan([[1,1,-1,2,-1],[2,0,1,-4,-1],[0,1,1,1,1],[0,1,2,0,1],[0,0,-3,3,-1]])","egv,egvl,jordan,companion"},
{"rational",{"DOM_RAT ou rational représente le type d'un rationnel, valeur de la commande type. C'est aussi une option de assume.","DOM_RAT or rational is the type of a rational, as returned by the type command. It is also an option of the assume command.",0,0},"Opt"," assume(a,rational); assume(a,DOM_RAT); a:=1/2;type(a)","type,assume,DOM_INT,DOM_FLOAT"},
{"rationalroot",{"Renvoie la liste des racines rationnelles de P sans indiquer la multiplicité.","Returns the list of rational roots of P without indicating the multiplicity.",0,0},"Poly(P)","rationalroot(2*x^3-9*x^2+13*x-6)","proot,froot,complexroot,realroot,crationalroot"},
{"ratnormal",{"Réécriture sous forme de fraction irréductible.","Rewrite as an irreducible rational fraction.",0,0},"Expr","ratnormal((x^2-1)/(x^3-1));ratnormal(c/d+b/d+a/d);ratnormal((x^2-1)/(x^3-1)+(x-1)/(x^3-1)+1)","normal,simplify,factor,expand"},
{"rcl",{"Rappelle le contenu d'une variable sans l'évaluer.","Recalls an identifier content, does not evaluate it.",0,0},"Var","rcl(a)",""},
{"rdiv",{"Division de a par b (version préfixée de /).","Division of a by b (prefixed version of /).",0,0},"Expr(a),Expr(b)","rdiv(3,5);rdiv(3.2,5.4)","/"},
{"re",{"Partie réelle d'un nombre complexe.","Returns the real part of a complex number.",0,0},"Cplx or LstCplx","re(1+2*i);re((1+2*i)^2);real([1+2*i,(1+2*i)^2])","im,conj"},
{"read",{"Pour lire dans le fichier fich_name les variables et leurs valeurs.","To read in the file fich_name the variables and their values.",0,0},"Str(fich_name)","read(\"toto\")","write"},
{"readrgb",{"Lit un fichier image, avec la taille originelle ou spécifiée en argument.","Reads a picture file, using it's natural dimensions, or using specified dimensions.",0,0},"Str(s),[Intg(w)],[Intg(h)]","readrgb(\"image.png\");readrgb(\"image.png\",50,50)","writergb"},
{"readwav",{"Lit un fichier son au format WAV.","Reads a WAV sound file.",0,0},"Str(s)","readwav(\"pop.wav\")","writewav"},
{"real",{"Partie réelle d'un nombre complexe.","Returns the real part of a complex number.",0,0},"Cplx or LstCplx","re(1+2*i);re((1+2*i)^2);real([1+2*i,(1+2*i)^2])","im,conj"},
{"realroot",{"Renvoie la liste des intervalles de longueur <=l où se trouvent les racines réelles de P situées dans a..b avec leur multiplicité. Utilise l'algorithme de Vincent-Akritas-Strzebonski (VAS) ou les suites de Sturm pour realroot(sturm,P).","Returns the list of intervals of length <=l containing the real roots of P inside a..b with their multiplicity. By default the Vincent-Akritas-Strzebonski (VAS) method is used. realroot(sturm,P) uses Sturm's method.",0,0},"[sturm],Poly(P),[Real(l)],[Cplx(a)],[Cplx(b)]","realroot(x^3+7,0.1);realroot(x^3-7*x+7);realroot(sturm,x^3-7*x+7);realroot(x^5-2*x^4+x^3+1);realroot(x^5-2*x^4+x^3+1,0.1);realroot(x^3+x+8,1e-5,-4,4)","proot,froot,complexroot,rationalroot,crationalroot,sturmab,VAS"},
{"reciprocation",{"Renvoie la liste en remplaçant un point (resp une droite) par sa polaire (resp son pole), par rapport au cercle C.","Returns the list where a point (resp a line) are replaced with its polar (resp pole), with respect to the circle C.",0,0},"Crcle,Lst(Pnt,Line)","reciprocation(circle(0,1),[point((1+i)/2), line(1,-1+i)]);reciprocation(circle(0,1),[line(1+i,2),point(1+i*2)])","pole,polar"},
{"rectangle",{"Renvoie et dessine le rectangle ABCD, AD=k*AB, si k>0 ABCD est direct sinon indirect (dans le plan ABP AD=AP ou AD=k*AB).","Returns and draws the rectangle ABCD, AD=k*AB if k>0 ABCD is direct else indirect (in the plane ABP AD=AP or AD=k*AB).",0,0},"Pnt(A)||Cplx,Pnt(B)||Cplx,Real(k)||Pnt(P)||Lst(P,k),[Var(D)],[Var(C)]","rectangle(-i,1,2);rectangle(-i,1,-2,D,C);rectangle(point(0,0,0),point(3,3,3),point(0,0,3),D,C);rectangle(point(0,0,0),point(3,3,3),2,D,C)","quadrilateral,square"},
{"rectangle_droit",{"Option de la commande plotarea et de la commande area.","Option of the plotarea command and of the area command.",0,0},"Opt"," plotarea(x^2,x=0..1,5,trapezoid); plotarea(x^2,x=0..1,5,middle_point); plotarea(x^2,x=0..1,5,right_rectangle); plotarea(x^2,x=0..1,5,left_rectangle); area(x^2,x=0..1,5,middle_point); area(x^2,x=0..1,5,trapezoid)","plotarea,area"},
{"rectangle_gauche",{"Option de la commande plotarea et de la commande area.","Option of the plotarea command and of the area command.",0,0},"Opt"," plotarea(x^2,x=0..1,5,trapezoid); plotarea(x^2,x=0..1,5,middle_point); plotarea(x^2,x=0..1,5,right_rectangle); plotarea(x^2,x=0..1,5,left_rectangle); area(x^2,x=0..1,5,middle_point); area(x^2,x=0..1,5,trapezoid)","plotarea,area"},
{"rectangle_plein",{"Dessine un rectangle (resp un carré) plein direct de cotés a,b (resp a) à partir de la position de la tortue et sur la gauche (par défaut b=a).","Draws a full direct rectangle (resp square) with sides a,b (resp a) from the turtle position and on the left (by default b=a).",0,0},"Real(a),[Real(b)]"," rectangle_plein 20;rectangle_plein(20);rectangle_plein(20,40)","triangle_plein"},
{"rectangular_coordinates",{"Renvoie la liste de l'abscisse et de l'ordonnée d'un point donné par la liste de ses coordonnées polaires.","Returns the list of the abscissa and of the ordinate of a point given by the list of its polar coordinates.",0,0},"LstPolCoord","rectangular_coordinates([1,pi/4]);rectangular_coordinates(polar_point(1,pi/4))","abscissa,ordinate,rectangular_coordinates,polar_point"},
{"recule",{"La tortue recule de n pas (par défaut n=10).","The turtle takes n steps back (by default n=10).",0,0},"NULL or Real(n)"," recule 30;recule(30)","avance,saute"},
{"red",{"Option de la commande affichage (ou display) pour afficher en couleur.","Option of the display command to display with color.",0,0},"Opt"," F:=display(point(2+1.5*i),red); F:=display(point(2+1.5*i),point_point+green)","display"},
{"redim",{"Redimensionne selon n1,n2 une matrice (resp vecteur) soit en la raccourcissant, soit en l'augmentant avec des 0.","Shrink or enlarge with 0 a matrix (or vector) according to the new n1 and n2 dimensions.",0,0},"Mtrx||Vect,Intg(n1),Intg(n2)","redim([[1,2,3],[3,-9,6],[4,5,6]],1,2);redim([[1,2,3],[3,-9,6],[4,5,6]],4,4)","replace"},
{"reduced_conic",{"Renvoie l'origine et la matrice du repère dans lequel la conique d'équation donnée, est réduite, 0 ou 1 (0 si la conique est dégénérée) et l'équation de la conique dans ce repère ainsi que son équation paramétrique.","Returns the origin and the matrix of a base in which the conic given by its equation, is reduced, 0 or 1 (0 if the conic is degenerated) and the equation of the conic in this base and also its parametric equation.",0,0},"Expr,[LstVar]","reduced_conic(x^2+2*x-2*y+1);reduced_conic(a*x^2-2*x*y+a*y^2-2*x+2*y+3,[x,y]);reduced_conic(2*u^2+2*u*v+2*v^2+5*u+3,[u,v]);reduced_conic((x+y)^2-2*x+1,x,y)","gauss,conic"},
{"reduced_quadric",{"Renvoie l'origine et la matrice du repère dans lequel la quadrique d'équation donnée, est réduite, la liste des valeurs propres et l'équation de la quadrique dans ce repère ainsi que son équation paramétrique.","Returns the origin and the matrix of a basis in which the quadric (given by its equation) is reduced, the list of its eigenvalues, the equation of the quadric in this basis and its parametric equation.",0,0},"Expr, [LstVar]","reduced_quadric(4*x^2+y^2+z^2-4*x*y+4*x*z-2*y*z+8*x-4*y+4*z+2);reduced_quadric(x^2+3*y^2-3*z^2-8*y*z+2*z*x-4*x*y-1,x,y,z);reduced_quadric((u+v)*(v-w)+3*u-5*v,[u,v,w]);reduced_quadric(7*x^2+4*y^2+4*z^2+4*x*y-4*x*z-2*y*z-4*x+5*y+4*z-18,[x,y,z])","gauss,quadric"},
{"ref",{"Réduction de Gauss de AX=b (M=A|(-b)).","Reduction of Gauss of AX=b (M=A|(-b)).",0,0},"Mtrx(M)","ref([[3,1,-2],[3,2,2]]);ref([[2,1,1,-1],[1,1,2,-1],[1,2,1,-4]])","rref,det"},
{"reflection",{"reflection(D,C) (resp reflection(A,C))=symétrique de C dans la symétrie-droite D (resp sym-point A).","reflection(D,C) (or reflection(A,C))=symmetrical of C in the symmetry-line D (or sym-point A).",0,0},"(Pnt(A) or Line(D)),(Pnt(C) or Curve(C))","reflection(line(0,1+i),A);reflection(B,A);reflection(line(0,1+i),circle(i,1+i))","rotation,translation"},
{"regroup",{"Effectue les simplifications évidentes sur une expression.","Collect terms in an expression.",0,0},"Expr","regroup(x+3*x+5*4/x)","simplify,normal"},
{"rem",{"Reste euclidien de 2 polynômes.","Euclidean remainder of 2 polynomials.",0,0},"(Vect or Poly),(Vect or Poly),[Var]","rem([1,2,3,4],[-1,2]);rem(x^3+2x^2+3x+4,-x+2);rem(t^3+2t^2+3t+4,-t+2,t)","quo,quorem,Rem,irem"},
{"remain",{"Reste euclidien de 2 entiers ou de 2 entiers de Gauss.","Euclidean remainder of 2 integers.",0,0},"Intg(a),Intg(b)","irem(125,15);irem(125,41);irem(-7,3);irem(25+12*i,5+7*i)","iquo,smod,rem,mod"},
{"remove",{"Enlève les occurrences e de l ou les éléments e qui vérifient f(e)=vrai.","Remove the occurrences e of l or the elements e such that f(e)=true.",0,0},"FncBool(f)||e,Lst(l)","remove(x->x>=5,[1,2,6,7]);remove(5,[1,2,5,6,7,5])","select,suppress"},
{"reorder",{"Réordonne les variables de E selon l'ordre donné dans le 2ème argument.","Reorders the variables in E according to the order of the 2nd argument.",0,0},"Expr, LstVar","-2;reorder(x^2+2*x+y^2,[y,x])",""},
{"repeat",{"Boucle repeter (effectue les instructions jusqu'à cond==true): repeter i1;i2;jusqua cond; ou repeat i1;i2; until cond;","Loop repeat (repeat the instructions until cond==true): repeat i1;i2; until cond; or repeter i1;i2;jusqua cond;",0,0},""," repeter jusqu_a ;; repeat x:=x-5 until x<5 ;; quoreste(a,b):={local q:=0;repeat a:=a-b;q:=q+1 until a<0;return q-1,a+b;};; x:=32;repeat x:=x-5 until x<5;; quoreste(a,b):={local q:=0;repeter a:=a-b;q:=q+1; jusqua a<0;return q-1,a+b;};; x:=32;repeter x:=x-5; jusqua x<5;; n:=1;repeter triangle_plein(10*n);saute(10*n);n:=n+1; jusqua n==5;; n:=4;repeter triangle_plein(10*n);saute(10*n);n:=n-1; jusqua n==0;","for,tantque"},
{"repete",{"Instruction permettant de faire k fois les mêmes commandes.","Instruction doing k times the same commands.",0,0},"Intg,SeqCmds"," repete 3,avance 40,tourne_droite 120; repete 3,avance(30),tourne_droite(120); repete 4,rectangle_plein(20,40),tourne_droite;repete(3,avance 20,tourne_droite 120);repete(4,rectangle_plein(20,40),tourne_droite)","polygone_rempli"},
{"repeter",{"Boucle repeter (effectue les instructions jusqu'à cond==true): repeter i1;i2;jusqua cond; ou repeat i1;i2; until cond;","Loop repeat (repeat the instructions until cond==true): repeat i1;i2; until cond; or repeter i1;i2;jusqua cond;",0,0},""," repeter jusqu_a ;; repeat x:=x-5 until x<5 ;; quoreste(a,b):={local q:=0;repeat a:=a-b;q:=q+1 until a<0;return q-1,a+b;};; x:=32;repeat x:=x-5 until x<5;; quoreste(a,b):={local q:=0;repeter a:=a-b;q:=q+1; jusqua a<0;return q-1,a+b;};; x:=32;repeter x:=x-5; jusqua x<5;; n:=1;repeter triangle_plein(10*n);saute(10*n);n:=n+1; jusqua n==5;; n:=4;repeter triangle_plein(10*n);saute(10*n);n:=n-1; jusqua n==0;","for,tantque"},
{"replace",{"La matrice B est mise en remplacement dans A à partir des 2 indices n1,n2.","Replace part of matrix A from indices n1,n2 with the values of matrix B.",0,0},"Mtrx(A),Lst(n1,n2),Mtrx(B)","replace([[1,2,3],[3,-9,6],[4,5,6]],[1,0],[[7,8],[9,0]])","redim"},
{"residue",{"Retourne le résidu en a de l'expression dépendant de la variable v.","Returns the residue in a of the expression with v as variable.",0,0},"Expr,Var(v),Cplx(a)","residue(1/z,z,0);residue(5/z,z=0);residue(cos(z)/(z*(z-b)),z,0);residue(c/(z*(z-b)),z=b)","series"},
{"resoudre",{"Résout une équation ou un système polynomial.","Solves a (or a set of) polynomial equation.",0,0},"Expr,[Var]","solve(x^2-3=1);solve(x^3-3*y,y);solve([y-z=0,z-x=0,x-y=0,x-1+y+z=0],[x,y,z]);solve([x^2-y^2=0,x^2-z^2=0],[x,y,z])","linsolve,proot,fsolve,csolve,nSolve"},
{"resoudre_dans_C",{"Renvoie la liste des solutions complexes d'une équation ou la matrice dont les lignes sont solutions dans ℂ d'un système d'équations polynomiales.","Returns the list of complex solutions of an equation or a matrix where the rows are ℂ-solutions of a system of polynomial equations.",0,0},"LstEq,LstVar","csolve(x^4-1,x);csolve(x^4-y^4 and x+y=2,[x,y]);csolve(x^4-y^4 and x+y=0 and x^2=2*x,[x,y]);csolve(u*v-u=v and v^2=u,[u,v])","cZeros,solve,fslove"},
{"resoudre_systeme_lineaire",{"Résolution d'un système d'équations linéaires.","Linear equations system solver.",0,0},"LstLinEq,LstVar","linsolve([x+y+z=1,x-y=2,2*x-z=3],[x,y,z]);linsolve([m*x+y=a,x+m*y=b],[x,y]);linsolve([x+y-z-1,x-y+1,x-y-z-1]%2,[x,y,z]);linsolve([[3,4],[1,2]],[0,1]); p,l,u:=lu([[3,4],[1,2]]); linsolve(p,l,u,[0,1]) ;linsolve([2*x+y+z=1,x+y+2*z=1,x+2*y+z=4],[x,y,z]);linsolve([[2,1,1],[1,1,2],[1,2,1]],[1,1,4]); p,l,u:=lu([[2,1,1],[1,1,2],[1,2,1]]);linsolve(p,l,u,[1,1,4]); a:=[[100,2],[2,100]];linsolve(evalf(a),[0,1]);","solve,proot,simult,gaussjord,pivot,ref,conjugate_gradient"},
{"restart",{"Purge toutes les variables.","Purges all the variables.",0,0},"NULL","restart","purge"},
{"resultant",{"Résultant de deux polynômes.","Resultant of two polynomials.",0,0},"Poly,Poly,Var","resultant(x^2-1,x^3-1,x);resultant(x^3-p*x+q,3*x^2-p,x)","sylvester,gcd"},
{"return",{"Instruction qui fait sortir d'une fonction en renvoyant sa valeur.","Instruction that interrupts a function and returns its value.",0,0},"Expr"," zeroinl(l):={local k; for (k:=0;k<size(l);k++){if (l[k]==0) return(1);} return(0);}; zerodansl(l):={local k; pour k de 0 jusque size(l)-1 faire si l[k]==0 alors return(1);fsi; fpour; return(0);}","break"},
{"reverse",{"Renvoie la liste l inversée.","Returns the list l in reverse order.",0,0},"Lst(l)","revlist([1,2,3])",0},
{"reverse_rsolve",{"Si v=[v_0 ... v_(2n-1)], renvoie [b_n,...,b_0] tel que b_n*v_{n+k}+...+b_0*v_k=0 pour k=0..n-1.","If v=[v_0 ... v_(2n-1)], return [b_n,...,b_0] such that b_n*v_{n+k}+...+b_0*v_k=0 for k=0..n-1.",0,0},"Vect(v)","reverse_rsolve([1,-1,3,3])","rsolve"},
{"revert",{"Renvoie le développement réciproque d'un développement en séries en 0.","Returns the revert expansion of a series expansion at 0.",0,0},"Expr","revert(x+x^2+x^4)","series"},
{"revlex",{"Option de la commande gbasis ou greduce pour spécifier un ordre sur les monômes (degré total puis ordre lexicographique inverse).","Option of the gbasis or greduce command to specify an order for monomials (complete degree then inverse lexicographic order).",0,0},"Opt",0,"gbasis,greduce"},
{"revlist",{"Renvoie la liste l inversée.","Returns the list l in reverse order.",0,0},"Lst(l)","revlist([1,2,3])",0},
{"rhombus",{"Renvoie et dessine le losange ABCD tel que angle (AB,AD)=a (ou dans le plan ABP angle(AB,AD)=angle(AB,AP) ou tel que angle(AB,AD)=a).","Returns and draws the rhombus ABCD such as the angle (AB,AD)=a (or in the plane ABP angle(AB,AD)=angle(AB,AP) or such that angle(AB,AD)=a).",0,0},"Pnt(A)||Cplx,Pnt(B)||Cplx,Angle(a)||Pnt(P)||Lst(P,a)),[Var(C)],[Var(D)]","rhombus(i,1+i,pi/4);rhombus(i,1+i,pi/4,C,D);rhombus(point(0,0,0),point(3,3,3),[point(0,0,3),pi/4]);rhombus(point(0,0,0),point(3,3,3),point(0,0,3),C,D);rhombus(point(0,0,0),point(3,3,3),[point(0,0,3),pi/4],C,D)","square,quadrilateral"},
{"rhombus_point",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," F:=display(point(2+1.5*i),point_point); F:=display(point(2+1.5*i),rhombus_point)","display"},
{"rhs",{"Renvoie la partie droite d'une égalité, d'un intervalle, d'une liste ou d'une chaîne.","Returns the right part of an equality, of an interval, of a list or of a string.",0,0},"Equal(a=b) or Interval(a..b) or Str,Intg","right(a=b);right(x^2+1=5);right(1..5);right(\"abcdefg\",3)","left,mid,tail,head"},
{"right",{"Renvoie la partie droite d'une égalité, d'un intervalle, d'une liste ou d'une chaîne.","Returns the right part of an equality, of an interval, of a list or of a string.",0,0},"Equal(a=b) or Interval(a..b) or Str,Intg","right(a=b);right(x^2+1=5);right(1..5);right(\"abcdefg\",3)","left,mid,tail,head"},
{"right_rectangle",{"Option de la commande plotarea et de la commande area.","Option of the plotarea command and of the area command.",0,0},"Opt"," plotarea(x^2,x=0..1,5,trapezoid); plotarea(x^2,x=0..1,5,middle_point); plotarea(x^2,x=0..1,5,right_rectangle); plotarea(x^2,x=0..1,5,left_rectangle); area(x^2,x=0..1,5,middle_point); area(x^2,x=0..1,5,trapezoid)","plotarea,area"},
{"right_triangle",{"Trace le triangle ABC rectangle en A avec AC=k*AB (ou dans le plan ABP AC=AP ou AC=k*AB).","Draws the A_rectangular triangle ABC with AC=k*AB (or in the plane ABP AC=AP or AC=k*AB).",0,0},"(Pnt(A) or Cplx),(Pnt(B) or Cplx),(Real(k) or Pnt(P) or Lst(P,k)),[Var(C)]","right_triangle(1,i,tan(pi/3));right_triangle(1,i,1/2,C);right_triangle(point(0,0,0),point(3,3,3),point(0,0,3));right_triangle(point(0,0,0),point(3,3,3),[point(0,0,3),1/2],C);right_triangle(point(0,0,0),point(3,3,3),[point(0,0,3),1/2],C)","triangle"},
{"risch",{"Renvoie une primitive de l'expression calculée selon l'algorithme de Risch.","Returns a primitive of the expression calculated with the Risch algorithm.",0,0},"Expr,[Var]","risch(ln(x),x);risch(ln(x));risch(exp(x^2),x)","int"},
{"rm_a_z",{"Efface tous les noms des variables ayant une seule lettre a..z en minuscule.","Erase all the variable name with only one minuscule a..z character.",0,0},"NULL","rm_a_z()","rm_all_vars"},
{"rm_all_vars",{"Efface tous les noms des variables.","Erase all the variable name.",0,0},"NULL","rm_all_vars()","rm_a_z"},
{"rmbreakpoint",{"Efface un point d'arrêt.","Removes a breakpoint.",0,0},"Intg","rmbreakpoint(1)","breakpoint"},
{"rmmod",{"Supprime les librairies dynamiques installées.","Removes the installed dynamic libraries.",0,0},"Str(pwd)","rmmod(\"/home/parisse/giac/src/libprogfr.so\")","lsmod,insmod"},
{"rmwatch",{"Efface une variable de la table des variables affichées en pas-à-pas.","Clears a variables from the table of displayed variables in step/step.",0,0},"Var","rmwatch(a)","watch"},
{"romberg",{"Renvoie la valeur approchée de integrate(f(x),x,a,b) par la méthode de Romberg.","Returns the approximate value of integrate(f(x),x,a,b) by Romberg's method.",0,0},"Expr(f(x)),Var(x),Real(a),Real(b)","romberg(exp(x^2),x,0,1);romberg(x^2,x,0,1);romberg(exp(-x^2),x,-1,1)","integrate,gaussquad"},
{"rombergm",{"Option de la commande area","Option of the area command",0,0},"Opt"," area(x^2,x=0..1,5,simpson); area(x^2,x=0..1,5,rombergt); area(x^2,x=0..1,5,rombergm);area(x^2,x=0..1,5,gauss15)","area"},
{"rombergt",{"Option de la commande area","Option of the area command",0,0},"Opt"," area(x^2,x=0..1,5,simpson); area(x^2,x=0..1,5,rombergt); area(x^2,x=0..1,5,rombergm);area(x^2,x=0..1,5,gauss15)","area"},
{"rond",{"Dessine un cercle (resp un arc) de rayon r (resp et d'angle (0,a) ou (a,b)), tangent à la position de la tortue.","Draws a circle (resp a arc) with radius r (resp and of angle (0,a) or (a,b)), tangent at the turtle position.",0,0},"Real(r),[Real(a)],[Real(b)]"," rond 30;rond(40);rond(40,90);rond(40,10,100)","disque"},
{"root",{"Renvoie b^(1/a) (root(2,3)=sqrt(3)).","Returns b^(1/a) (root(2,3)=sqrt(3)).",0,0},"Expr(a),Expr(b)","root(3,2);root(1/3,2);root(3,1.2);root(3.2,1.2)",""},
{"rootof",{"Polynôme fonction d'une racine d'un polynôme irréductible sur Q. Renvoie P(a) où a est la plus grande racine de Q.","Polynomial in terms of a root of an irreducible polynomial on Q. Returns P(a) with a the greatest root of Q.",0,0},"LstPoly(P),LstPoly(Q)"," normal(1/rootof([1,0],[1,0,10,0,1])); normal(1/rootof([1,0,0],[1,1,0,-1])); rootof(x^4+x+1):='j'; normal(j^5); ",""},
{"roots",{"Renvoie une matrice ayant 2 colonnes et dont les lignes sont les racines du polynôme avec leur multiplicité (pour 1 variable).","Returns a matrix having 2 columns and where the rows are the roots of the polynomial with their multiplicity (for 1 variable).",0,0},"Poly,[Var]","roots(t^3-1,t);roots(x^5-2*x^4+x^3)","proot,cZeros"},
{"rotate",{"Renvoie la liste obtenue en mettant le dernier élément [ou la fin de la liste à partir du n-ième élément] en premier (par défaut n=-1).","Returns the list where the last element [or the tail beginning with the n-th element] is the first element (by default n=-1).",0,0},"Lst,[Intg(n)]","rotate([0,1,2,3],2);rotate([[1,2,3],[4,5,6],[7,8,9]]);rotate([0,1,2,3,4]);rotate([0,1,2,3,4],-1)","tail,mid,shift"},
{"rotation",{"rotation(B,a1,A) (resp rotation(d,a1,A)) est le transformé de A par rotation de centre B (resp d'axe d) et d'angle a1.","rotation(B,a1,A)(resp rotation(d,a1,A)) is the transformed of A by rotation of center B (resp of axis d) and of angle a1.",0,0},"(Pnt(B) or Cplx or Dr3),Angle(a1),(Pnt(A) or Curve)","rotation(point(1+i),pi/2,point(i));rotation(1+i,pi/3,line(i,1));rotation(line(x=y,y=z),pi/2,point(1,-1,2)); r:=rotation(1+i,pi/2);r(i); r:=rotation(line(x=y,y=z),pi/2);r(point(1,-1,2))","translation,reflection"},
{"round",{"Arrondit le réel ou complexe en l'entier (resp le décimal) le plus proche ou en l'élément de ℤ[i] le plus proche, (resp avec n décimales).","Rounds the real or complex as the nearest integer (resp the nearest decimal number) or as nearest element of ℤ[i], (resp with n decimals).",0,0},"Real or Cplx,[Intg(n)]","round(2.5);round(-2.4);round(-2.5+i*2.4);round(1.237,2);round(sqrt(2)+i*sqrt(5),4)","floor,ceil"},
{"row",{"Renvoie la ligne n ou la suite des lignes n1..n2 de la matrice A, ou argument optionnel de count,count_eq,count_inf,count_sup.","Returns the row n or the sequence of the rows n1..n2 of the matrix A, or optional argument of count,count_eq,count_inf,count_sup.",0,0},"Mtrx(A),Intg(n)||Interval(n1..n2)","row([[1,2,3],[4,5,6],[7,8,9]],1);row([[1,2,3],[4,5,6],[7,8,9]],0..1); count_eq(3,[[1,2,3],[4,3,2],[3,2,1]],row)","col,count,count_eq,count_inf,count_sup"},
{"rowAdd",{"Renvoie la matrice obtenue en remplaçant dans A la ligne n2 par la somme des lignes n1 et n2.","Returns the matrix get from A by replacing the n2-th row by the sum of the n1-th and n2-th rows.",0,0},"Mtrx(A),Intg(n1),Intg(n2)","rowAdd([[1,2],[3,4],[5,6]],1,2)","rowSwap"},
{"rowDim",{"Nombre de lignes d'une matrice.","Number of rows of a matrix.",0,0},"Mtrx","rowdim([[1,2,3],[4,5,6]]);rowdim([[1,2],[3,4],[5,6]])","ncols"},
{"rowNorm",{"Renvoie le maximum des sommes des valeurs absolues des éléments situés sur les lignes de la matrice: rowNorm(a_{j,k})=max_j(sum_k(|a_{j,k}|)).","Returns the max of the l1_norm of the rows of a matrix: rowNorm(a_{j,k})=max_j(sum_k(|a_{j,k}|)).",0,0},"Vect or Mtrx","rowNorm([[1,2],[3,-4]]);rowNorm([[1,2,3,-4],[-5,3,2,1]])","norm"},
{"rowSwap",{"Renvoie la matrice obtenue en échangeant dans A la ligne n1 et la ligne n2.","Returns the matrix get from A by swapping the n1-th row and the n2-th row.",0,0},"Mtrx(A),Intg(n1),Intg(n2)","rowSwap([[1,2],[3,4],[5,6]],1,2)","rowAdd,colSwap"},
{"rowdim",{"Nombre de lignes d'une matrice.","Number of rows of a matrix.",0,0},"Mtrx","rowdim([[1,2,3],[4,5,6]]);rowdim([[1,2],[3,4],[5,6]])","ncols"},
{"rownorm",{"Renvoie le maximum des sommes des valeurs absolues des éléments situés sur les lignes de la matrice: rowNorm(a_{j,k})=max_j(sum_k(|a_{j,k}|)).","Returns the max of the l1_norm of the rows of a matrix: rowNorm(a_{j,k})=max_j(sum_k(|a_{j,k}|)).",0,0},"Vect or Mtrx","rowNorm([[1,2],[3,-4]]);rowNorm([[1,2,3,-4],[-5,3,2,1]])","norm"},
{"rowspace",{"Renvoie une matrice dont les lignes forment une base de l'espace vectoriel engendré par les lignes de la matrice A [d est la dimension de cet espace].","Returns a matrix where the rows are a basis of the vector space generated with the rows of the matrix A [d is the dimension of this space].",0,0},"Mtrx(A), [Var(d)]","rowspace([[1,2,3],[1,2,3],[1,2,4],[1,2,5]]);rowspace([[1,2,3],[1,3,6],[2,5,9]],d)","colspace"},
{"rowswap",{"Renvoie la matrice obtenue en échangeant dans A la ligne n1 et la ligne n2.","Returns the matrix get from A by swapping the n1-th row and the n2-th row.",0,0},"Mtrx(A),Intg(n1),Intg(n2)","rowSwap([[1,2],[3,4],[5,6]],1,2)","rowAdd,colSwap"},
{"rref",{"Réduction sous forme échelonnée de AX=b (M=A|(-b)) [Réduction sur les k premières colonnes].","Row reduction to echelon form of AX=b (M=A|(-b)) [Reduction on columns 0..k-1]",0,0},"Mtrx(M),[Intg(k)]||Opt","rref([[3,1,-2],[3,2,2]]);rref([[2,1,1,-1],[1,1,2,-1],[1,2,1,-4]]);rref([[2,1,1,-1],[1,1,2,-1],[1,2,1,-4]],2);rref([[1,1,0,0,-a1],[0,1,1,0,-a2],[0,0,1,1,-a3],[1,0,0,1,-a4]],keep_pivot)","ker,image,det,Rref,pivot,ref,keep_pivot"},
{"rsolve",{"Donne la valeur d'une suite récurrente ou d'un système de suites récurrentes.","Gives the value of a recurrent sequence or of a system of recurrent sequences.",0,0},"(Expr or LstExpr),(Var or LstVar),(InitVal or LstInitVal)","rsolve(u(n+1)=2*u(n)+n,u(n),u(0)=1);rsolve(u(n+1)=2*u(n)+n,u(n),u(1)^2=1);rsolve(u(n+1)=(u(n)-1)/(u(n)-2),u(n),u(0)=4);rsolve(u(n+2)=u(n)+2*u(n+1)+n+1,u(n),[u(0)=0,u(1)=1]);rsolve([u(n+1)=3*v(n)+u(n),v(n+1)=v(n)+u(n)],[u(n),v(n)],[u(0)=1,v(0)=2])","seqsolve,plotseq,tableseq,reverse_rsolve"},
{"same",{"Test d'égalité.","Equality test.",0,0},"Expr,Expr","same(a,b);same((2-1)^2,2^2-2*2+1)",""},
{"sans_factoriser",{"Option de la commande plotimplicit.","Option of the plotimplicit command.",0,0},"Opt."," plotimplicit(x^2+y^2-1,x,y,unfactored); plotimplicit(x^2+y^2-1,[x,y],unfactored); plotimplicit(x^2+y^2+z^2-1,x,y,z,xstep=0.2,ystep=0.2,zstep=0.2,unfactored); plotimplicit(x^2+y^2+z^2-1,[x,y,z],xstep=0.2,ystep=0.2,zstep=0.2,unfactored); plotimplicit(x^2+y^2+z^2-1,x=0..1,y=0..1,z=0..1,xstep=0.2,ystep=0.2,zstep=0.2,unfactored)","plotimplicit"},
{"saute",{"La tortue saute (avance sans laisser de traces) de n pas (par défaut n=10).","The turtle takes n steps forward without traces (by default n=10).",0,0},"NULL or Real(n)"," saute 30;saute(30)","avance,recule"},
{"sauve",{"Pour écrire dans le fichier fich_name les variables et leurs valeurs.","To write in the file fich_name the variables and their values.",0,0},"Str(fich_name),SeqVar","write(\"toto\",a,b,c)","read"},
{"save_history",{"Sauve l'historique des commandes dans un fichier de nom str.","Save the historic in a file with name str.",0,0},"Str(str)","save_history(\"toto.cas\")",""},
{"scalarProduct",{"Produit scalaire de v1 et de v2 ou de 2 matrices aplaties selon 2 vecteurs.","Scalar product.",0,0},"Vect(v1),Vect(v2)","dot([1,2],[3,4]);dot([3,2,4],[3,2,4]);dot([[1,2],[3,4]],[[3,2],[4,5]])","*,cross,.*,hadamard"},
{"scalar_product",{"Produit scalaire de v1 et de v2 ou de 2 matrices aplaties selon 2 vecteurs.","Scalar product.",0,0},"Vect(v1),Vect(v2)","dot([1,2],[3,4]);dot([3,2,4],[3,2,4]);dot([[1,2],[3,4]],[[3,2],[4,5]])","*,cross,.*,hadamard"},
{"scale",{"Multiplie la ligne n1 de la matrice A par Xpr.","Multiplies the row n1 of the matrix A by Xpr.",0,0},"Mtrx(A),Expr(Xpr),Intg(n1)","scale([[1,2],[3,4],[5,6]],12,0)","rowAdd,scaleadd,mRowAdd"},
{"scaleadd",{"Multiplie la ligne n1 de la matrice A par Xpr, puis l'ajoute à la ligne n2.","Multiplies the row n1 of the matrix A by Xpr, then adds it to the row n2.",0,0},"Mtrx(A),Expr(Xpr),Intg(n1),Intg(n2)","scaleadd([[1,2],[3,4],[5,6]],12,0,2)","rowAdd,scale,mRow"},
{"scatterplot",{"Dessine pour k=0..nrows, les points (xk,yk) où xk=élément ligne k colonne 0 et yk=élément ligne k colonne j (j=1..ncols).","Draws for k=0..nrows, the points (xk,yk) where xk=element row k column 0 and yk=element row k column j (j=1..ncols).",0,0},"Mtrx","scatterplot([[1,2,3],[2,0,1],[-1,2,3]])","polygonplot,polygonscatterplot,listplot"},
{"schur",{"Réduction matricielle sous forme de Hessenberg. Renvoie les matrices numériques [P,B] tel que B=inv(P)*A*P avec B triangulaire : SCHUR(A)=hessenberg(A,-1) ","Matrix reduction to Hessenberg form. Returns [P,B] such that B=inv(P)*A*P:SCHUR(A)=hessenberg(A,-1).",0,0},"Mtrx(A)","SCHUR([[1,2,3],[4,5,6],[7,8,1]]);SCHUR([[1,2,3,4],[4,5,6,7],[7,8,9,0],[0,1,2,3]])","hessenberg"},
{"sec",{"Sécante: sec(x)=1/cos(x).","Secant: sec(x)=1/cos(x).",0,0},"Expr","sec(pi/3)","cos,asec"},
{"secant_solver",{"Argument de fsolve indiquant la méthode pour résoudre numériquement une équation.","Argument for fsolve giving the method for solving an numerical equation.",0,0},"Opt"," fsolve(cos(x)=x,x,0..1,bisection_solver); fsolve(cos(x)=x,x,0..1,brent_solver); fsolve(cos(x)=x,x,0..1,falsepos_solver); fsolve(cos(x)=x,x,0,newton_solver); fsolve(cos(x)=x,x,0,secant_solver); fsolve(cos(x)=x,x,0,steffenson_solver)","fsolve"},
{"segment",{"segment(A,B) trace le segment AB et segment([xM,yM],[xN,yN]) trace le vecteur d'origine [xM,yM], de coordonnées [xN,yN] (i.e trace segment(M,point(M+N)).","segment(A,B) draws the segment AB and segment([xM,yM],[xN,yN]) draws the vector as origin [xM,yM], of coordinates [xN,yN] (i.e draws segment(M,point(M+N)).",0,0},"(Pnt or Cplx or Lst([xM,yM])),(Pnt or Cplx or Lst([xN,yN]),[Var],[Var]","segment(i,1+i);segment(point(i),point(1+i));segment(point(i),point(1+i),A,B);segment([-1,0],[2,1]);segment([-1,0],point([-1,0]+[2,1]))","line"},
{"select",{"Sélectionne les éléments e de l vérifiant f(e)=vrai.","Selects the elements e of l such that f(e)=true.",0,0},"FncBool(f),Lst(l)","select(x->x>=5,[1,2,6,7])","remove"},
{"semi_augment",{"Renvoie une matrice formé de A et de B ayant n1+n2 lignes et p colonnes si dim(A)=[n1,p] et dim(B)=[n2,p].","Returns a matrix made with A and B, with n1+n2 rows and p columns if dim(A)=[n1,p] and dim(B)=[n2,p].",0,0},"Mtrx(A),Mtrx(B)","semi_augment([[68,-21],[56,59],[1,2]],[[68,-21],[56,59]])","augment"},
{"seq",{"Renvoie la séquence (2 ou 3 arg) ou la liste (4 ou 5 arg) obtenue lorsque var varie entre a et b (pas=p) dans Xpr (ou on répète n fois l'expression Xpr ou on obtient la sequence des réels entre a et b par pas de p). On a aussi seq(expression,variable,liste) équivaut à map(liste,unapply(expression,variable)) ","Returns the sequence (2 or 3 arg) or the list (4 or 5 arg) obtained when var go from a to b (step p) in Xpr (or the Xpr is repeated n times or returns the sequence of reals from a to b (step p)).And also seq(expression,variable,liste) is equivanent to map(liste,unapply(expression,variable)) ",0,0},"Expr(Xpr),Var(var)=Int(a..b),[Real(p)]||Expr(Xpr),Var(var),Real(a),Real(b),[Real(p)]","seq(0.3,4);seq(t,4);seq(0,0);seq(2^k,k=0..8);seq(2^k,k=0..8,2);seq(0.3..2,0.2);seq(2^k,k,0,8);seq(2^k,k,0,8,2);seq(x^3,x,[1,2,3]); [seq(0.3..2,0.2)] ; a:=(1,2,3);eval(seq(a,4))","$,makelist,range,map,unapply"},
{"seqplot",{"Permet de visualiser les p premiers termes de la suite u(0)=a,u(n)=f(u(n-1)).","For seeing the pth terms of the sequence u(0)=a,u(n)=f(u(n-1)).",0,0},"Expr(f(Var)),Var=[a,xm,xM],Intg(p)","plotseq(sqrt(2+x),6,5);plotseq(sqrt(2+t),t=6,5);plotseq(sqrt(2+x),x=[6,1,7],5,affichage=epaisseur_ligne_2)","seqsolve,rsolve"},
{"seqsolve",{"Donne la valeur d'une suite récurrente (u_{n+1}=f(u_n) ou u_{n+k}=f(u_n,u_{n+1},...u_{n+k-1})) ou d'un système de suites récurrentes.","Gives the value of a recurrent sequence (u_{n+1}=f(u_n) or u_{n+k}=f(u_n,u_{n+1}...u_{n+k-1})) or of a system of recurrent sequences.",0,0},"(Expr or LstExpr),(Var or LstVar),(InitVal or LstInitVal)","seqsolve(2x+n,[x,n],1);seqsolve(2x+n*3^n,[x,n],1);seqsolve(x+y,[x,y,n],[1,1]);seqsolve(x+2*y+n+1,[x,y,n],[0,1]);seqsolve([x+2*y,n+1+x],[x,y,n],[0,1]);seqsolve([x+2*y+n+1,x],[x,y,n],[0,1])","rsolve,plotseq,tableseq"},
{"series",{"Développement limité ou asymptotique.","Series expansion at finite or infinite points.",0,0},"Expr,Equal(var=limit_point),[Order],[Dir(1,0,-1)]","series(sin(x)/x,x=0);series(sin(x),x=0,6,polynom);series(ln(x+x^2)-ln(x),x=0,1);series((x^4+x+2)/(x^2+1),x=0,5); series(\"h\",8); ln(1+h);;series(1/(1+x+y),[x,y],[0,0],5) ;series(sin(x*y),[x,y],[1,pi/2],3);series(sin((1+h*t)*(pi/2+k*t)),t=0,3,polynom)(t=1);series(y^2/x^3,[x,y],[1,-1],3);series((-1+k*t)^2/(1+h*t)^3,t=0,3,polynom)(t=1);series(subst(sin(x+y)+cos(y*x),[x,y],h*[x,y]),h=0,6,polynom);series(subst(sin(x+y)+cos(y*x),[x,y],h*[x,y]),h=0,6,polynom)(h=1); truncate(series(sin(x),x=0,6),6)","limit,taylor,pad,polynom,truncate"},
{"set[]",{"set[] ou %{%} est utilisé pour définir un ensemble.","set[] or %{%} is used to define a set.",0,0},"Seq"," set[1,2,3]; %{1,2,3%}; L:=[1,2,2,3];S:=set[op(L)]; set[1,2]*set[2,3]","in,op"},
{"shift",{"Renvoie la liste obtenue en mettant le dernier élément [ou la fin de la liste à partir du n-ième élément] en premier en la complétant par undef (par défaut n=-1).","Returns the list where the last element [or the tail beginning with the n-th element] is the first element and then complete with undef (by default n=-1).",0,0},"Lst,[Intg(n)]","shift([0,1,2,3],2);shift([0,1,2,3]);shift([0,1,2,3,4])","rotate,tail"},
{"shift_phase",{"shift_phase d'une expression renvoie l'expression dans laquelle les expressions trigonométriques, une fois évaluées, ont une phase augmentée de pi/2.","shift_phase returns the expressions where the phase of the evaluated trigonometric expressions is increased by pi/2.",0,0},"Expr","shift_phase(sin(x));shift_phase('sin(x+pi/2)');shift_phase(x+sin(x));shift_phase(x+sin(x));shift_phase(cos(t));shift_phase(tan(u))","series"},
{"si",{"Instruction conditionnelle : (si...alors...sinon...fsi).","Conditional instruction : (si...alors...sinon...fsi).",0,0},""," si alors sinon fsi; n:=1; si n>0 alors triangle_plein(20*n); sinon disque(20*n);fsi;; n:=-1; si n>0 alors triangle_plein(20*n); sinon disque(20*n);fsi;; si x>0 alors x:=x+1; print(\"x est strictement plus grand que 1\");fsi;; si x>0 alors x:=x+1; print(\"x est strictement plus grand que 1\"); sinon x:=x-1;print(\"x est plus petit ou égal à -1\");fsi;","if"},
{"sign",{"Retourne le signe (-1,0,+1) de l'argument.","Returns the sign (-1,0,+1) of its argument.",0,0},"Expr","sign(-4);sign(4-5)","abs"},
{"signature",{"Renvoies la signature d'une permutation.","Returns the signature of a permutation.",0,0},"Permut","signature([1,0,3,4,2])","permu2cycles,is_permu"},
{"signe",{"Écris la chaîne s avec la fonte 20 au point [10,10].","Write the string s with the fount 20 at the point [10,10].",0,0},"Str(s)","signe(\"Thomas\");signe(Thomas)","ecris"},
{"similarity",{"similitude(B,k,a1,A)=transformé de A dans la similitude (centre B ou axe d, rapport k,angle a1) (ou aussi homothetie(B,k*exp(i*a1),A)).","similarity(B,k,a1,A)=transformed of A in the similarity (center B or axis d, coeff k,angle a1) (or also homothety(B,k*exp(i*a1),A)).",0,0},"Pnt or Dr3,Real,Angle,Pnt","similarity(1+i,2,pi/3,i);similarity(line(x=y,y=z),2,pi/3,point(-1,2,1)); s:=similarity(1+i,2,pi/3);s(i); s:=similarity(line(x=y,y=z),2,pi/3),s(point(-1,2,1))","homothety"},
{"simp2",{"Renvoie la liste [A/gcd(A,B),B/gcd(A,B)].","Returns the list [A/gcd(A,B),B/gcd(A,B)].",0,0},"Intg(A) or Poly(A),Intg(B) or Poly(B)","simp2(12,18);simp2(x^3-1,x^2-1)","gcd"},
{"simplex_reduce",{"Réduction par le simplexe pour trouver max(c.x) avec A.x<=b et x>=0, b>=0. Renvoie le max, la solution augmentée x et la matrice réduite. Accepte aussi en argument [[A|I|b],[-c|*|0]].","Reduction by simplex algorithm to find max(c.x) under A.x<=b and x>=0, b>=0. Returns the maximum, the augmented solution x and the reduced matrix. Accepts also [[A|I|b],[-c|*|0]] as argument.",0,0},"Mtrx(A), Vect(b), Vect(c)","simplex_reduce([[3,2,2],[1,1,1]],[3,4],[1,2,3]);simplex_reduce([[3,2,2,1,0,3],[1,1,1,0,1,4],[-1,-2,-3,0,0,0]]);simplex_reduce([[-3,2],[1,1]],[3,4],[1,2]);simplex_reduce([[-3,2,1,0,3],[1,1,0,1,4],[-1,-2,0,0,0]]);simplex_reduce([[2,1,1,1,0,0,2],[1,2,3,0,1,0,5],[2,2,1,0,0,1,6],[-3,-1,-3,1,-1,2,0]])",0},
{"simplifier",{"Simplifie une expression.","Simplifies an expression.",0,0},"Expr","simplify(4*atan(1/5)-atan(1/239));simplify(texpand((sin(3*x)+sin(7*x))/sin(5*x)));simplify(texpand((cos(3*x)+cos(7*x))/cos(5*x)))","normal"},
{"simplify",{"Simplifie une expression.","Simplifies an expression.",0,0},"Expr","simplify(4*atan(1/5)-atan(1/239));simplify(texpand((sin(3*x)+sin(7*x))/sin(5*x)));simplify(texpand((cos(3*x)+cos(7*x))/cos(5*x)))","normal"},
{"simpson",{"Option de la commande area","Option of the area command",0,0},"Opt"," area(x^2,x=0..1,5,simpson); area(x^2,x=0..1,5,rombergt); area(x^2,x=0..1,5,rombergm);area(x^2,x=0..1,5,gauss15)","area"},
{"simult",{"Renvoie la matrice dont la colonne d'indice k est solution de A*X=colonne d'indice k de B (=B[0..nl-1,k..k] avec nl=nombre de ligne de B).","Returns the matrix where the column of index k is solution of A*X=column of index k of B (=B[0..nr-1,k..k] with nr=number of rows of B).",0,0},"Mtrx(A),Mtrx(B)","simult([[3,1],[3,2]],[[-2],[2]]);simult([[3,1],[3,2]],[[-2,1],[2,-1]])","rref,linsolve"},
{"sin",{"Sinus ou Option de la commande convert ou convertir (id trigsin).","Sine or Option of the convert or convertir command (id trigsin).",0,0},"Expr or Opt","sin(0); convert(cos(x)^4+sin(x)^2,sin)","asin,convert,trigsin"},
{"sin2costan",{"Remplace sin(x) par cos(x)*tan(x) dans l'argument.","Replaces sin(x) by cos(x)*tan(x) in the argument.",0,0},"Expr","sin2costan(sin(x))","tan2sincos,cos2sintan,tan2sincos2,tan2cossin2"},
{"sincos",{"Transforme les exponentielles complexes en sinus et cosinus (id exp2trig) ou Option de la commande convert ou convertir (id sincos).","Transforms the complex exponential into sine and cosine (id exp2trig) or Option of the convert or convertir command (id sincos).",0,0},"Expr or Opt","sincos(exp(i*x));sincos(exp(-i*x)); convert(exp(i*x),sincos)","trig2trig,trig2exp,atrig2ln,convert"},
{"single_inter",{"Donne l'une des intersections de 2 courbes ou surfaces (ou l'intersection le plus près de A ou qui n'est pas dans L).","Gives one of the intersections of 2 curves or surfaces (or the intersection near A or not in L).",0,0},"Curve,Curve,[Pnt(A)||LstPnt(L)]","single_inter(line(i,1-i),line(0,1));single_inter(line(i,1-i),circle(0,1));single_inter(line(i,1+2*i),circle(0,1),[point(i)]);single_inter(line(-1-i,1+2*i),circle(0,1),point(-1));single_inter(circle(1,sqrt(2)),circle(0,1));single_inter(plane(x=y),plane(y=z));single_inter(line(x=y+1,y=2*z),plane(y=z))","intersect,head"},
{"sinh",{"Sinus hyperbolique.","Hyperbolic sine.",0,0},"Expr","sinh(0)","asinh"},
{"sinon",{"Instruction conditionnelle : (si...alors...sinon...fsi).","Conditional instruction : (si...alors...sinon...fsi).",0,0},""," si alors sinon fsi; n:=1; si n>0 alors triangle_plein(20*n); sinon disque(20*n);fsi;; n:=-1; si n>0 alors triangle_plein(20*n); sinon disque(20*n);fsi;; si x>0 alors x:=x+1; print(\"x est strictement plus grand que 1\");fsi;; si x>0 alors x:=x+1; print(\"x est strictement plus grand que 1\"); sinon x:=x-1;print(\"x est plus petit ou égal à -1\");fsi;","if"},
{"size",{"Renvoie la longueur d'une liste, d'une chaîne de caractères ou d'une suite.","Returns the size of a list, a string or a sequence.",0,0},"Lst or Str or Seq","size([1,2,3]);size(\"bonjour\");size(1,2,3)","sizes,dim,degree"},
{"sizes",{"Renvoie la liste des longueurs d'une liste de listes.","Returns the list of sizes of a list of lists.",0,0},"Lst or Str or Seq","sizes([[1,2,3],[1,2],[1]])","size,dim"},
{"slope",{"Renvoie la pente de la droite définie dans l'argument ou est un attribut de droite.","Returns the slope of the line defined in the argument or is an attribute of line.",0,0},"Line||Pnt||Cplx,[Pnt||Cplx]","slope(line(1,2i));slope(segment(1,2i));slope(1,2i);slope(line(y+2x=2));slope(point(1),point(2i));slope(tangent(plotfunc(sin(x)),pi/4));slope(LineTan(sin(x),pi/4)); line(point(1,2),slope=-1)","line,tangent,LinTan,slopeatraw,slopeat"},
{"slopeat",{"slopeat(d,z0) affiche au point(z0), avec une légende, la valeur de la pente de la droite ou segment d.","slopeat(d,z0) displays at the point(z0), with a legend, the value of the slope of the line or segment d.",0,0},"Line, Pnt||Cplx(z0)"," A:=point(0);B:=point(1+i);slopeat(droite(A,B),(1+i)/2); s:=segment(1-i,i);slopeat(s,point(0.4)); t:=tangent(plotfunc(sin(x)),pi/4);slopeat(t,0)","slope,slopeatraw"},
{"slopeatraw",{"slopeatraw(d,z0) affiche au point(z0), la valeur de la pente de la droite ou segment d.","slopeatraw(d,z0) displays at point(z0), the value of the slope of the line or segment d.",0,0},"Line, Pnt||Cplx(z0)"," A:=point(0);B:=point(1+i);slopeatraw(droite(A,B),(1+i)/2); s:=segment(1-i,i);slopeatraw(s,point(0.4));slopeatraw(tangent(plotfunc(sin(x)),pi/4),0);slopeatraw((LineTan sin(x),pi/4),i)","slope,slopeat"},
{"smith",{"Calcule la forme normale de Smith d'une matrice a coefficients polynomiaux :renvoie U,D,V tels que tels que U et V inversibles, D  diagonale et U*A*V=D.","Smith normal form of a matrix with  polynomial coefficients : returns U,D,V such that U and V invertible, D diagonal, and U*A*V=D.",0,0},"Mtrx(A)"," n:=10; A:=ranm(n,n) % 17; U,D,V:=smith(x*idn(n)-A);normal(U*(x*idn(n)-A)*V-D); diag(D);; GF(3,5,g); n:=3; A:=ranm(n,n,g); U,D,V:=smith(x*idn(n)-A);normal(U*(x*idn(n)-A)*V-D); diag(D);","hermite,ismith,ihermite"},
{"smith",{"Renvoie la forme normale de Smith d'une matrice a coefficients polynomiaux (U,D,V tels que U*A*V=D)","Returns the Smith normal form of a polynomial coefficients matrix (U,D,V tels que U*A*V=D)",0,0},"Matr(A)"," n:=10; a:=ranm(n,n) % 17; u,b,v:=smith(x-a);normal(u*(x-a)*v-b); diag(b);; GF(3,5,g); n:=3; a:=ranm(n,n,g); u,b,v:=smith(x-a);normal(u*(x-a)*v-b); diag(b);","hermite,ismith,ihermite"},
{"smod",{"Retourne le reste symétrique de la division euclidienne de 2 entiers.","Returns the Euclidean symmetric remainder of two integers.",0,0},"Intg,Intg","smod(8,3);smod(10,4);smod(11,7)","irem,iquo,mod,fracmod"},
{"snedecor",{"Renvoie la densité de probabilité de la loi de Fisher-Snedecor (n et m sont les nombres de degrés de liberté).","Returns the density of probability of the Fisher-Snedecor law (n and m are the numbers of degrees of freedom).",0,0},"Intg(n),Intg(m),Real(x0)","fisher(4,10,2.1);fisher(4,4,2.1); randvector(5,fisher,4,6); ranm(2,3,fisher,4,6)","fisher_cdf,fisher_icdf,randvector,ranm"},
{"snedecor_cdf",{"Renvoie la probabilité qu'une variable aléatoire Fisher-Snedecor soit inférieure à x0 (n et m sont les nombres de degrés de liberté).","Returns the probability that a Fisher-Snedecor random variable is lower than x0 (n and m are the numbers of degrees of freedom).",0,0},"Intg(n),Intg(m),Real(x0)","fisher_cdf(4,4,2.1);fisher_cdf(4,10,3.5)","UTPF,fisher_icdf,fisherd"},
{"snedecor_icdf",{"Renvoie la valeur h telle que, la probabilité qu'une variable aléatoire Fisher-Snedecor soit inférieure à h soit p (n et m sont les nombres de degrés de liberté et 0<=p<=1).","Returns h such as the probability that a Fisher-Snedecor random variable is lower than h is p (n and m are the numbers of degrees of freedom and 0<=p<=1).",0,0},"Intg(n),Intg(m),Real(p)","fisher_icdf(4,10,0.95);fisher_icdf(4,10,0.05)","fisher_cdf,fisherd"},
{"snedecord",{"Renvoie la densité de probabilité de la loi de Fisher-Snedecor (n et m sont les nombres de degrés de liberté).","Returns the density of probability of the Fisher-Snedecor law (n and m are the numbers of degrees of freedom).",0,0},"Intg(n),Intg(m),Real(x0)","fisher(4,10,2.1);fisher(4,4,2.1); randvector(5,fisher,4,6); ranm(2,3,fisher,4,6)","fisher_cdf,fisher_icdf,randvector,ranm"},
{"snedecord_cdf",{"Renvoie la probabilité qu'une variable aléatoire Fisher-Snedecor soit inférieure à x0 (n et m sont les nombres de degrés de liberté).","Returns the probability that a Fisher-Snedecor random variable is lower than x0 (n and m are the numbers of degrees of freedom).",0,0},"Intg(n),Intg(m),Real(x0)","fisher_cdf(4,4,2.1);fisher_cdf(4,10,3.5)","UTPF,fisher_icdf,fisherd"},
{"snedecord_icdf",{"Renvoie la valeur h telle que, la probabilité qu'une variable aléatoire Fisher-Snedecor soit inférieure à h soit p (n et m sont les nombres de degrés de liberté et 0<=p<=1).","Returns h such as the probability that a Fisher-Snedecor random variable is lower than h is p (n and m are the numbers of degrees of freedom and 0<=p<=1).",0,0},"Intg(n),Intg(m),Real(p)","fisher_icdf(4,10,0.95);fisher_icdf(4,10,0.05)","fisher_cdf,fisherd"},
{"solid_line",{"Option de la commande affichage (ou display) pour une ligne.","Option of the display command for a line.",0,0},"Opt"," display(line(y=x),green+dash_line+line_width_2); d:=display(line(2+i,1),cap_round_line)","display"},
{"solve",{"Résout une équation ou un système polynomial.","Solves a (or a set of) polynomial equation.",0,0},"Expr,[Var]","solve(x^2-3=1);solve(x^3-3*y,y);solve([y-z=0,z-x=0,x-y=0,x-1+y+z=0],[x,y,z]);solve([x^2-y^2=0,x^2-z^2=0],[x,y,z])","linsolve,proot,fsolve,csolve,nSolve"},
{"somme",{"Somme discrète (avec 4 ou 2 arguments renvoie la somme de a à b si a<=b ou de l'opposé de la somme de b+1 à a-1 si a>b+1 ou 0 si a=b+1) ou la primitive discrète ou la somme des éléments d'une liste (ou séquence).","Discrete sum (with 2 or 4 arguments return then sum from a to b if a<=b or of the opposite of the sum from b+1 to a-1 if a>b+1 or 0 if a=b+1) or the discrete primitive or sum of the elements of a list or a sequence.",0,0},"Expr,Var,VarMin(a),VarMax(b),[VarStep(p)]","sum(1/n^2,n,1,17);sum(1/n^2,n=1..17);sum(1/n^2,n,17,1);sum(1/n^2,n=17..1);sum(1/n^2,n,17,1,1);sum(1/n^2,n,1,17,2);sum(1,2,3,4);sum([[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9]]);sum(1/(x*(x+1)),x);sum(cos(n*x),n)","+"},
{"sommet",{"Renvoie le sommet d'un opérateur.","Returns the sommet of an operator.",0,0},"Op or Fnct","sommet(quote(gcd(45,123)));sommet('gcd(45,123)')","feuille,quote"},
{"sort",{"Renvoie la liste (ou suite) triée par ordre croissant ou selon la fonction donnée en second argument qui définit un ordre strict faible ou trie et collecte les termes égaux dans les sommes et produits.","Returns the sorted list (or sequence) with increasing order according with the second argument which defines an weak strict ordering or sort and collect equal terms in sums and products.",0,0},"LstReal or Seq [Fnc]","sort([3,2,2,4,1,0]);sort(3,2.1,2,4,1,0);sort([3,4,2],(x,y)->x>y);sort([[1,2],[2,3],[4,3]],(x,y)->when(x[1]==y[1],x[0]>y[0],x[1]>y[1]));sort(y*x*2+x*y)","SortA,SortD"},
{"sorta",{"Trie les listes par ordre croissant ou la 1ière ligne d'une matrice selon l'ordre croissant en conservant les colonnes.","Sorts the lists with increasing order or the first matrix row with increasing order and with the same columns.",0,0},"LstReal||Seq×||Mtrx","sorta(3,4,2);sorta([3,4,2]);sorta([[3,4,2],[6,4,5]])","SortA,sortd,sort"},
{"sortd",{"Trie les listes par ordre décroissant ou la 1ière ligne d'une matrice selon l'ordre décroissant en conservant les colonnes.","Sorts the lists with decreasing order or the first matrix line with decreasing order and with the same columns.",0,0},"LstReal||Seq||Mtrx","sortd(3,4,2);sortd([3,4,2]);sortd([[3,4,2],[6,4,5]])","SortD,sorta,sort"},
{"soundsec",{"Génère un vecteur correspondant à n secondes de temps/N (défaut N=44100).","Generates a vector coding n seconds of time/N (default N=44100).",0,0},"Intg(n),[Intg(N)]","soundsec(1);soundsec(1,22100)","readwav,writewav,playsnd"},
{"sphere",{"sphere(A,B) (resp sphere(A,r)) trace la sphère de diamètre AB (resp centre A et de rayon r) dans l'espace 3D.","sphere(A,B) (resp sphere(A,r)) draws the sphere of diameter AB (resp center A and radius r) in the space 3D.",0,0},"(Pnt or Vect),(Pnt or Real)","sphere([0,0,0],[2,2,2]);sphere([1,1,1],1)","circle"},
{"spline",{"Spline naturelle passant par les points donnés par les listes lx et ly, variable x, de degré d.","Natural spline through the points given by the lx and ly lists, variable x, degree d.",0,0},"Lst(lx),Lst(ly),Var(x),Intg(d)","spline([0,1,2],[1,3,0],x,3)","lagrange"},
{"split",{"Sépare les deux variables var1,var2 de l'expression Xpr (si elle n'a pas de dénominateur) ou renvoie [0].","Splits the two variables var1,var2 of the expression Xpr (without denominator) or returns [0].",0,0},"Expr(Xpr),Lst(var1,var2)","split(x^3*y^2-y^2+x^3-1,[x,y]);split(x^3*y^2-y^2+x^3+1,[x,y])","factor"},
{"sq",{"Désigne le nom de la fonction (ℝ^n -> ℝ)=somme des carrés des arguments.","Is the name of the function (ℝ^n -> ℝ)=sum of the square of the arguments.",0,0},"Seq","sq(5);sq(1,2,3)","sqrt"},
{"sqrfree",{"Factorise l'argument en regroupant les termes de même exposant.","Factorization of the its argument gathering the terms with the same exponent.",0,0},"Expr","sqrfree(x^4-2*x^2+1);sqrfree((x-2)^7*(x+2)^7*(x^4-2*x^2+1))","factor"},
{"sqrt",{"Racine carrée.","Square root.",0,0},"Expr","sqrt(50);sqrt(x^2)","surd,^"},
{"square",{"Renvoie et dessine le carré de coté AB (ABCD est direct) (dans le plan ABP).","Returns and draws the square of side AB (ABCD is direct) (in the plane ABP.",0,0},"(Pnt(A) or Cplx),(Pnt(B) or Cplx),[Pnt(P),Var(C),Var(D)]","square(i,1+i);square(i,1+i,C,D);square(point(0,0,0),point(3,3,3),point(0,0,3));square(point(0,0,0),point(3,3,3),point(0,0,3),C,D)","rhombus,quadrilateral"},
{"square_point",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," F:=display(point(2+1.5*i),point_point); F:=display(point(2+1.5*i),rhombus_point)","display"},
{"srand",{"srand ou srand(n) initialise la suite des nombres aléatoires : srand renvoie un entier qui a servi à cette initialisation et srand(n) renvoie n.","srand returns an integer and initialize the sequence of random numbers.",0,0},"","srand(12); srand","RandSeed"},
{"sst",{"Exécute 1 instruction en pas-à-pas.","Step 1 instruction.",0,0},"NULL","sst()",""},
{"sst_in",{"Entre à l'intérieur d'une fonction en pas-à-pas.","Enter into a function in step-by-step mode.",0,0},"NULL","sst_in()",""},
{"stack",{"Mot réservé.","Reserved word.",0,0},"",0,""},
{"star_point",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," F:=display(point(2+1.5*i),point_point); F:=display(point(2+1.5*i),rhombus_point)","display"},
{"start",{"Boucle en mode RPN.","RPN loop.",0,0},"",0,""},
{"stdDev",{"Renvoie un estimateur non biaise de l'écart-type de la population dont est issu l'échantillon décrit par les éléments d'une liste pondérée par le deuxième argument.","Returns an unbiaised estimate of the population standard deviation of the sample (first argument) with an optionnal list of pounds as second argument.",0,0},"Lst||Mtrx,[Lst]","stddevp([1,2,3]);stddevp([1,2,3],[1,2,1]);stddevp([[1,2,3],[5,6,7]])","mean,stddev"},
{"stddev",{"Renvoie l'écart-type d'une liste pondérée par le deuxième argument ou la liste des écarts-types des colonnes d'une matrice.","Returns the standard deviation of the elements of its argument with an optionnal second argument as pound or the list of standard deviation of the columns of a matrix.",0,0},"Lst||Mtrx,[Lst]","stddev([1,2,3]);stddev([1,2,3],[1,2,1]);stddev([[1,2,3],[5,6,7]])","mean,variance,stddevp"},
{"stddevp",{"Renvoie un estimateur non biaise de l'écart-type de la population dont est issu l'échantillon décrit par les éléments d'une liste pondérée par le deuxième argument.","Returns an unbiaised estimate of the population standard deviation of the sample (first argument) with an optionnal list of pounds as second argument.",0,0},"Lst||Mtrx,[Lst]","stddevp([1,2,3]);stddevp([1,2,3],[1,2,1]);stddevp([[1,2,3],[5,6,7]])","mean,stddev"},
{"steffenson_solver",{"Argument de fsolve indiquant la méthode pour résoudre numériquement une équation.","Argument for fsolve giving the method for solving an numerical equation.",0,0},"Opt"," fsolve(cos(x)=x,x,0..1,bisection_solver); fsolve(cos(x)=x,x,0..1,brent_solver); fsolve(cos(x)=x,x,0..1,falsepos_solver); fsolve(cos(x)=x,x,0,newton_solver); fsolve(cos(x)=x,x,0,secant_solver); fsolve(cos(x)=x,x,0,steffenson_solver)","fsolve"},
{"step",{"Saut de la variable dans une itération (taille du saut).","Step in an iteration (step size of incrementation).",0,0},""," s:=0;for j from 1 to 10 step 2 do s:=s+j end_for; s:=0;for j from 1 step 2 to 10 do s:=s+j end_for; s:=0;for j from 1 to 10 by 2 do s:=s+j end_for; s:=0;for j from 1 by 2 to 10 do s:=s+j end_for; s:=0;pour j de 1 jusque 10 pas 2 do s:=s+j fpour; s:=0;pour j de 1 pas 2 jusque 10 do s:=s+j fpour","for,pour"},
{"sto",{"Stocke le premier argument dans la variable donnée comme deuxième argument.","Store the first argument in the variable given as second argument.",0,0},"(Real or Str),Var","sto(2,a);sto(\"salut\",b)",":=,=>"},
{"string",{"DOM_STRING ou string représente le type d'une chaîne de caractères, valeur de la commande type. C'est aussi une option de assume.","DOM_STRING or string is the type of a string, as returned by the type command. It is also an option of the assume command.",0,0},"Opt"," a:=\"123\";type(a); assume(a,DOM_STRING)","type,assume,DOM_INT,DOM_FLOAT"},
{"string",{"Retourne l'expression évaluée sous la forme d'une chaîne de caractères ou Option de la commande convert ou convertir (id string).","Returns the evaluated expression as a string or Option of the convert or convertir command (id string).",0,0},"Expr or Opt","string(1.23);string(a:=12);string(quote(a:=12)); convert(quote(a:=12),string)","expr,format,convert"},
{"student",{"Renvoie la densité de probabilité de la loi de Student (n est le nombre de degrés de liberté).","Returns the density of probability of the Student law (n is the number of degrees of freedom).",0,0},"Intg(n),Real(x0)","student(3,5.2);student(1,5.2)","student_cdf,student_icdf"},
{"student_cdf",{"Renvoie la probabilité qu'une variable aléatoire de Student soit inférieure à x0 (n est le nombre de degrés de liberté).","Returns the probability that a Student random variable is lower than x0 (n is the number of degrees of freedom).",0,0},"Intg(n),Real(x0)","student_cdf(3,2.35);student_cdf(3,-3.2)","UTPT,student_icdf,studentd"},
{"student_icdf",{"Renvoie la valeur h telle que la probabilité qu'une variable aléatoire de Student soit inférieure à h soit p (n est le nombre de degrés de liberté, 0<=p<=1).","Returns h such as the probability that a Student random variable is lower than h is p (n is the number of degrees of freedom and 0<=p<=1).",0,0},"Intg(n),Real(p)","student_icdf(3,0.95);student_icdf(3,0.05)","student_cdf,studentd"},
{"studentd",{"Renvoie la densité de probabilité de la loi de Student (n est le nombre de degrés de liberté).","Returns the density of probability of the Student law (n is the number of degrees of freedom).",0,0},"Intg(n),Real(x0)","student(3,5.2);student(1,5.2)","student_cdf,student_icdf"},
{"studentt",{"Test T d'hypothèses /loi Student : arg1=[succes,essais] ou [moyenne, taille] ou données, arg2=proportion ou moyenne population ou données, arg3 optionnel si données=sigma, arg4 alternative '!=' ou '>' ou '<', arg5 optionnel confiance alpha.","T-Test/Student law: arg1=[success,trial] or [mean,sample size] or data, arg2=proportion or data, arg3 optional if data=sigma, arg4 alternative '!=' or '>' or '<', arg5 optional alpha confidence level.",0,0},"Lst,Real,[Real],Fnc,[Real]","studentt([10,20],.5,.02,'!=',0.1);studentt([0.48,20],0.5,0.1,'<')","normalt,chisquaret,kolmogorovt"},
{"sturm",{"Suite de Sturm associée à un polynôme ou nombre de changements de signe de ce polynôme dans ]a;b] ou de racines complexes dans a..b si a ou b est non réel.","Sturm sequence corresponding to a polynomial or number of sign changes of this polynomial in ]a;b].",0,0},"Poly,[Var],[Cplx(a)],[Cplx(b)]","sturm(x^3-1,x);sturm(x^5-x^3,x);sturm((x^5-x^3)/(x+2),x);sturm(x^5-x^3,x,-2,5);sturm(x^3-1,x,-2-i,5+3i)","sturmseq,sturmab"},
{"sturmab",{"Nombre de changements de signe d'un polynôme dans ]a;b] ou de racines complexes dans a..b si a ou b est non réel.","Number of sign changes of a polynomial in ]a;b] or of complex roots in a..b if a or b is non-real.",0,0},"Poly,Var,Cplx(a),Cplx(b)","sturmab(x^3-1,x,-2,5);sturmab(x^3-1,x,-2-i,5+3i)","sturm,sturmseq,realroot"},
{"sturmseq",{"Suite de Sturm associée à un polynôme ou à une fraction rationnelle.","Sturm sequence corresponding to a polynomial or to a rational fraction.",0,0},"Poly,[Var]","sturmseq(x^3-1,x);sturmseq(x^5-x^3,x);sturmseq((x^5-x^3)/(x+2),x)","sturm,sturmab"},
{"style",{"Option locale (compatibilité Maple) d'une commande graphique pour tracer une droite en pointillé en mettant style=point.","Local option (Maple compatibility) of a graphic command to plot a line with dots with style=point.",0,0},"Opt"," segment(0,point(1,1),style=point); line(y=x,style=point,display=green+line_width_2)","line_width"},
{"subMat",{"Extrait une sous matrice de premier élément A[n1,n2] et de dernier élément A[n3,n4].","Extracts a sub matrix with first element=A[n1,n2] and last element=A[n3,n4].",0,0},"Mtrx(A),Intg(n1),Intg(n2),Intg(n3),Intg(n4).","subMat([[1,2],[3,4],[5,6]],1,0,2,1)","mid"},
{"subs",{"Équivalent de subst sauf en mode Maple où les arguments sont permutés, en mode Maple choisir l'exemple 2.","Equivalent of subst except in maple_mode where the arguments are switched over, in maple_mode choose the second example.",0,0},"Expr or Var=value,Var=value or Expr","subs(1/(4+x^2),x=2);subs(x=2,1/(4+x^2)); f:=1/(4+x^2);f(x=2)","subst,maple_mode,algsubs,()"},
{"subsop",{"Remplace dans la liste (ou la matrice) l'élément d'indice n par l'expression (en Maple les arguments sont permutés)(NULL supprime cet élément).","Replaces in the list (or the matrix) the element of index n with the expression (with Maple the arguments are switched over)(NULL remove this element).",0,0},"Lst||Mtrx,Intg(n)=Expr","subsop([0,1,2,3,4],2=sqrt(2)+1);subsop([[1,2],[3,4]],[1,1]=5);subsop([[1,2],[3,4]],1=[10,8]);subsop([0,1,2,3],'1=NULL')",0},
{"subst",{"Remplace dans une expression, une variable non affectée par la valeur a.","Substitutes a value for a variable in an expression.",0,0},"Expr,Var(v)=value(a)","subst(1/(4+x^2),x=2);subst(1/(x^2+y^2),x=2,y=3);subst(1/(x^2+y^2+z^2),[x=2,y=3,z=1]);subst(x-2/(4+x^2),x=1);subst('integrate(sin(x^2)*x,x)',x=sqrt(t));subst('sum(x^(n+1)/((n+p+1)*(n+1)),n,0,inf)',n=k-1); f:=1/(x^2+y^2;f(x=2,y=3)","eval,algsubs,subs,()"},
{"substituer",{"Remplace dans une expression, une variable non affectée par la valeur a.","Substitutes a value for a variable in an expression.",0,0},"Expr,Var(v)=value(a)","subst(1/(4+x^2),x=2);subst(1/(x^2+y^2),x=2,y=3);subst(1/(x^2+y^2+z^2),[x=2,y=3,z=1]);subst(x-2/(4+x^2),x=1);subst('integrate(sin(x^2)*x,x)',x=sqrt(t));subst('sum(x^(n+1)/((n+p+1)*(n+1)),n,0,inf)',n=k-1); f:=1/(x^2+y^2;f(x=2,y=3)","eval,algsubs,subs,()"},
{"subtype",{"Renvoie 1 pour une séquence, 2 pour un ensemble, 10 pour un polynôme et 0 sinon.","Returns 1 for a sequence,2 for a set, 10 for a polynomial and 0 otherwise.",0,0},"Expr","subtype(1,2,3);subtype(set[1,2,3]);subtype(poly1[1,2,3]);subtype([1,2,3])","DOM_LIST,type"},
{"sum",{"Somme discrète (avec 4 ou 2 arguments renvoie la somme de a à b si a<=b ou de l'opposé de la somme de b+1 à a-1 si a>b+1 ou 0 si a=b+1) ou la primitive discrète ou la somme des éléments d'une liste (ou séquence).","Discrete sum (with 2 or 4 arguments return then sum from a to b if a<=b or of the opposite of the sum from b+1 to a-1 if a>b+1 or 0 if a=b+1) or the discrete primitive or sum of the elements of a list or a sequence.",0,0},"Expr,Var,VarMin(a),VarMax(b),[VarStep(p)]","sum(1/n^2,n,1,17);sum(1/n^2,n=1..17);sum(1/n^2,n,17,1);sum(1/n^2,n=17..1);sum(1/n^2,n,17,1,1);sum(1/n^2,n,1,17,2);sum(1,2,3,4);sum([[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9]]);sum(1/(x*(x+1)),x);sum(cos(n*x),n)","+"},
{"sum_riemann",{"Renvoie un équivalent au voisinage de var1=+infini de la somme de Xpr(var1,var2) pour var2 allant de 1 à var1 lorsque la somme est une somme de Riemann.","Returns an equivalent when var1=+infinity of the sum of Xpr(var1,var2) for var2 from 1 to var1 when the sum is a sum of Riemann.",0,0},"Expr(Xpr),Lst(var1,var2)","sum_riemann(1/(n+k),[n,k]);sum_riemann(n/(n^2+k),[n,k]);sum_riemann(n/(n^2+k^2),[n,k])",""},
{"suppress",{"Renvoie l sans son élément d'indice n.","Returns l without the element of index n.",0,0},"Vect(l)||Str(l),Intg(n)","suppress([0,1,2,3],2);suppress(\"0123\",2)","tail,mid,remove,insert"},
{"surd",{"Puissance 1/n.","Power 1/n.",0,0},"Expr,Intg(n)","surd(8,3);surd(-8,3)","sqrt,^"},
{"svd",{"Pour une matrice carrée numérique réelle A, renvoie U orthogonale, S vecteur des valeurs singulières, Q orthogonale tels que A=U*diag(S)*tran(Q).","For a square numerical real matrix A, returns U orthogonal, S vector of singular values, Q orthogonal such that A=U*diag(S)*tran(Q).",0,0},"Mtrx(A)","svd([[1,2],[3,4]])",0},
{"swapcol",{"Renvoie la matrice obtenue en échangeant dans A la colonne n1 et la colonne n2.","Returns the matrix get from A by swapping the n1-th column and the n2-th column.",0,0},"Mtrx(A),Intg(n1),Intg(n2)","colSwap([[1,2],[3,4],[5,6]],0,1)","rowSwap"},
{"swaprow",{"Renvoie la matrice obtenue en échangeant dans A la ligne n1 et la ligne n2.","Returns the matrix get from A by swapping the n1-th row and the n2-th row.",0,0},"Mtrx(A),Intg(n1),Intg(n2)","rowSwap([[1,2],[3,4],[5,6]],1,2)","rowAdd,colSwap"},
{"switch",{"Test (choix multiple): switch(variable) {case 1: {bloc1;} default: {bloc2;}};","Test (multiple choice): switch(variable) {case 1: {bloc1;} default: {bloc2;}};",0,0},""," a:=1;switch(a){case 0:{b:=1;break;} case 1:{b:=3;break;}default:{b:=0;}};b;; f(x):={local y;switch (x){case 1:{return \"un\";} case 2:{y:=\"deux\";break;}default:{y:=\"default\";}};return(y);}","if,case,default"},
{"switch_axes",{"switch_axes() met ou enlève les axes de l'écran géométrique.","switch_axes() put or erase the axes of the graphic-screen.",0,0},"[Intg(0 or 1)]","switch_axes();switch_axes(0);switch_axes(1)",0},
{"sylvester",{"Matrice de Sylvester de deux polynômes.","Sylvester matrix of two polynomials.",0,0},"Poly,Poly,Var","sylvester(x^2-1,x^3-1,x);sylvester(x^3-p*x+q,3*x^2-p,x)","resultant"},
{"symb2poly",{"Renvoie la liste des coefficients d'un polynôme par rapport au 2ème argument ou si le 2ème argument est une liste renvoie le format interne du polynôme.","Returns the coefficients of a polynomial with respect to the 2nd argument or if the second argument is a list the internal format of the polynomial.",0,0},"Expr, LstVar or [Var]","symb2poly(x*3+2.1);symb2poly(3*x*y+2*y+1,y);symb2poly(3*x*y+2*y+1,x,y);symb2poly(3*x*y+2*y+1,[x,y]);symb2poly(-x^4+x*3*y+2+y^2*z,[x,y,z]);symb2poly(-x^4+x*3*y+2+y^2*z,[x,y,z])","poly2symb,r2e"},
{"symbol",{"DOM_SYMBOLIC ou symbol représente le type d'une variable symbolique, valeur de la commande type. C'est aussi une option de assume.","DOM_SYMBOLIC or symbol is the type of a symbolic variable, as returned by the type command. It is also an option of the assume command.",0,0},"Opt"," assume(a,symbol); assume(a,DOM_SYMBOLIC); a:=sqrt(2);type(a); type(2x+1)","type,assume,DOM_INT,DOM_FLOAT"},
{"syst2mat",{"Renvoie la matrice M=A|(-b) associée au système Y=AX+b.","Returns the matrix M=A|(-b) associate to the system Y=AX+b.",0,0},"LstLinEq,LstVar","syst2mat([x-y=1,x+2*y],[x,y])","linsolve,rref"},
{"tCollect",{"Rassemble des expressions trigonométriques.","Collect trigonometric expressions.",0,0},"Expr","tcollect(sin(x)+cos(x))","texpand,tlin"},
{"tExpand",{"Développe des expressions transcendantes.","Expand transcendental expressions.",0,0},"Expr","texpand(sin(2*x)+exp(x+y));texpand(cos(x+y));texpand(cos(3*x))","tcollect,tlin,lin,trigexpand"},
{"table",{"Définit un tableau indicé par des chaînes ou des nombres réels ou définit une table à partir d'une matrice.","Defines an array where the index are strings or real numbers or defines a table with a matrix.",0,0},"SeqEqual(index=value)","table(3=-10,\"a\"=10,\"b\"=20,\"c\"=30,\"d\"=40); A:=[[0,1],[2,3]];table(A)  ; B:=table([1,2]=12,[2,5]=25);matrix(B)","matrix,convert,array"},
{"tablefunc",{"Tableau de valeurs d'une fonction : on doit être dans un tableur.","Table of value of a function : you must be in a spreadsheet.",0,0},"Expr,Var","tablefunc(sin(x),x);tablefunc(x^2-x-2,x)","tabvar,tableseq"},
{"tableseq",{"Tableau de valeurs d'une suite (dans un tableur).","Table of value of a sequence (in a spreadsheet.)",0,0},"Expr,(Var or LstVar),(InitVal or LstInitVal)","tableseq(cos(x),x,0.0);tableseq(x+y,[x,y],[1,1])","tablefunc"},
{"tabvar",{"Tableau de variations et le graph sur DispG d'une fonction.","Table of variations of a function with its graph on DispG.",0,0},"Expr,Var","tabvar(sin(x),x);tabvar(x^2+x+1,x);tabvar(x^2,x,-3,5);tabvar([sin(2t),cos(3t)])","tablefunc"},
{"tail",{"Renvoie la liste (ou suite ou chaîne) privée de son premier élément.","Returns the list (or sequence or string) without its first element.",0,0},"Lst or Seq or Str","tail([3,2,4,1,0]);tail(3,2,4,1,0);tail(\"bonjour\")","head,mid,left,right,back"},
{"tan",{"Tangente ou Option de la commande convert ou convertir (id halftan).","Tangent or Option of the convert or convertir command (id halftan)",0,0},"Expr","tan(0);tan(pi/4); convert(tan(x),tan)","atan or Opt,convert,halftan"},
{"tan2cossin2",{"Remplace tan(x) par (1-cos(2*x))/sin(2*x) dans l'argument.","Replaces tan(x) by (1-cos(2*x))/sin(2*x) in the argument.",0,0},"Expr","tan2cossin2(tan(x))","tan2sincos2,tan2sincos,sin2costan,cos2sintan"},
{"tan2sincos",{"Remplace tan(x) par sin(x)/cos(x) dans l'argument.","Replaces tan(x) by sin(x)/cos(x) in the argument.",0,0},"Expr","tan2sincos(tan(x))","sin2costan,cos2sintan,tan2sincos2,tan2cossin2"},
{"tan2sincos2",{"Remplace tan(x) par sin(2*x)/(1+cos(2*x)) dans l'argument.","Replaces tan(x) by sin(2*x)/(1+cos(2*x)) in the argument.",0,0},"Expr","tan2sincos2(tan(x))","tan2cossin2,tan2sincos,sin2costan,cos2sintan"},
{"tangent",{"tangent(C,A) trace les tangentes (droite ou plan) à C passant par A.","tangent(C,A) draws the tangents (line or plane) to C through A.",0,0},"Curve(C),Pnt(A)","tangent(circle(i,1+i),A);tangent(plotfunc(sin(x)),3*pi/4);tangent(plotfunc(sin(x)),point(3*pi/4+i*sqrt(2)/2));tangent(plotfunc(x^2+y^2,[x,y]),[2,2]);tangent(plotfunc(x^2+y^2,[x,y]),point([2,2,8]));tangent(plotparam(3*exp(t/2)*exp(i*t),t),7);tangent(plotpolar(3*exp(t/2),t),7); equation(tangente([2*cos(t),2*sin(t),3*t],t))","LineTan,droite_tangente"},
{"tangente",{"tangent(C,A) trace les tangentes (droite ou plan) à C passant par A.","tangent(C,A) draws the tangents (line or plane) to C through A.",0,0},"Curve(C),Pnt(A)","tangent(circle(i,1+i),A);tangent(plotfunc(sin(x)),3*pi/4);tangent(plotfunc(sin(x)),point(3*pi/4+i*sqrt(2)/2));tangent(plotfunc(x^2+y^2,[x,y]),[2,2]);tangent(plotfunc(x^2+y^2,[x,y]),point([2,2,8]));tangent(plotparam(3*exp(t/2)*exp(i*t),t),7);tangent(plotpolar(3*exp(t/2),t),7); equation(tangente([2*cos(t),2*sin(t),3*t],t))","LineTan,droite_tangente"},
{"tanh",{"Tangente hyperbolique.","Hyperbolic tangent.",0,0},"Expr","tanh(0);hyp2exp(tanh(1))","atanh,hyp2exp"},
{"tantque",{"Boucle tantque (tantque...faire...ftantque;).","Loop tantque (tantque...faire...ftantque;).",0,0},""," tantque faire ftantque; n:=1;tantque n<5 faire triangle_plein(10*n);saute(10*n);n:=n+1;ftantque; n:=4;tantque n>0 faire triangle_plein(10*n);saute(10*n);n:=n-1;ftantque; pgcd(a,b):={local r;tantque (b!=0) faire r:=irem(a,b);a:=b;b:=r;ftantque;return a};; quoreste(a,b):={local q:=0;tantque (a>=b) faire a:=a-b;q:=q+1;ftantque; return q,a};","while,pour"},
{"taux_accroissement",{"Renvoie le taux d'accroissement d'une expression lorsque la variable va de Val1 à Val2 (par défaut Var=x).","Returns the rate of increment of an expression when the variable go from Val1 to Val2 (by default Var=x).",0,0},"Expr,Var,Val1,(Val1+Var or Val2)","taux_accroissement(x^2,1,1+h);taux_accroissement(x^2,1,2);taux_accroissement(a^2,a,1,1+h)","diff,limit"},
{"taylor",{"Développement limité ou asymptotique (par défaut x=0 et ordre relatif=5).","Series expansion at finite or infinite points (by default x=0, and relative order=5).",0,0},"Expr,[Var=limit_point],[Order]","taylor(sin(x)/x,x,0);taylor(sin(x),x=0,5,polynom);taylor(ln(y+y^2)-ln(y),y);taylor(ln(x+x^2)-ln(x),x,2);taylor(ln(x+x^2)-ln(x),x=0,2);taylor(ln(x+x^2)-ln(x),x=1,2);taylor((x^4+x+2)/(x^2+1),x,5);taylor(sin(t*x+t*y)+cos(t*x*t*y),t=0,6,polynom)(h=1) ;taylor(sin((1+h*t)*(pi/2+k*t)),t=0,3,polynom)(t=1);taylor((-1+k*t)^2/(1+h*t)^3,t=0,3,polynom)(t=1)","series,limit,pade,polynom"},
{"tchebyshev1",{"Renvoie le n-ième polynôme de Tchebychev de première espèce.","Returns the n-th Tchebyshev polynomial of first sort.",0,0},"Intg(n)","tchebyshev1(3)","tchebyshev2,hermite"},
{"tchebyshev2",{"Renvoie le n-ième polynôme de Tchebychev de seconde espèce.","Returns the nt-h Tchebyshev polynomial of second sort.",0,0},"Intg(n)","tchebyshev2(3)","tchebyshev1,hermite"},
{"tcoeff",{"Renvoie le coefficient du terme de plus bas degré d'un polynôme (t=trailing).","Returns the coefficient of the term of lowest degree of a polynomial (t=trailing).",0,0},"Poly||Lst","tcoeff(-2*x^3+x^2+7*x);tcoeff([-2,1,7,0])","lcoeff"},
{"tcollect",{"Rassemble des expressions trigonométriques.","Collect trigonometric expressions.",0,0},"Expr","tcollect(sin(x)+cos(x))","texpand,tlin"},
{"tdeg",{"Option de la commande gbasis ou greduce pour spécifier un ordre sur les monômes (degré total puis ordre lexicographique).","Option of the gbasis or greduce command to specify an order for monomials (complete degree then lexicographic order).",0,0},"Opt",0,"gbasis,greduce"},
{"test",{"Fonction de test pour les développeurs.","Test function for system developers.",0,0},"Var","test(x)",""},
{"tetrahedron",{"Dessine le tétraèdre régulier direct de coté AB dont une face est dans le plan (A,B,C) quand il y a 3 arguments et la pyramide ABCD quand il y a 4 arguments.","Draws the regular direct pyramid ABCD with vertices A,B and a face in the plan (A,B,C) when there is 3 arguments et the pyramid ABCD when there is 4 arguments.",0,0},"Pnt(A),Pnt(B),Pnt(C),[Pnt(D)]","pyramid([0,0,0],[3,0,0],[0,1,0]);pyramid([0,0,0],[3,0,0],[0,3,0],[0,0,4])","cube,cylinder,icosahedron,dodecahedron,octahedron"},
{"texpand",{"Développe des expressions transcendantes.","Expand transcendental expressions.",0,0},"Expr","texpand(sin(2*x)+exp(x+y));texpand(cos(x+y));texpand(cos(3*x))","tcollect,tlin,lin,trigexpand"},
{"textinput",{"Instruction dans un programme permettant l'entrée d'une chaîne de caractères qui sera stockée dans var.","Instruction in a program so that you can input a string and store it in var.",0,0},"[Str],Var(var)","InputStr(\"nom?\",N)","input"},
{"then",{"Utilisé dans un test if: if (condition) then instruction; end_if;","Used in a test if: if (condition) then instruction; end_if;",0,0},""," if (a<0) then a:=-a; end_if;","if"},
{"thickness",{"Option (compatibilité Maple) d'une commande graphique pour définir l'épaisseur des traits.","Option (Maple compatibility) of a graphic command to define the thickness of lines.",0,0},"Opt"," segment(0,point(1,1),thickness=5); segment(0,point(1,1),epaisseur=5)","line_width"},
{"thiele",{"Approximation rationnelle d'une liste de points par la methode de Thiele","computes rational interpolation for the given list of points using Thiele's method with continued fractions",0,0},"[Data || Data_x],[Data_y],v "," data_x:=[-1,-0.75,-0.5,-0.25,0,0.25,0.5,0.75,1,1.25,1.5,1.75,2];data_y:=[0.0,2.83341735599,2.88770329586,2.75030303645,2.71828182846,2.66568510781,2.24894558809,1.21863761951,0.0,-0.555711613283,-0.377871362418,-0.107135851128,-0.0136782294833]; thiele(data_x,data_y,x)",0},
{"throw",{"Génère l'affichage d'une erreur dans un programme","Generates the display of an error in a program",0,0},"Str","error(\"Argument should be integer\");error(\"je provoque une erreur\")","try,catch"},
{"time",{"Renvoie le temps de calcul de la commande ou depuis le début de la session","Returns the time to compute a command or from the beginning of the session.",0,0},"NULL","time(factor(x^10-1));time()",0},
{"title",{"Option globale d'une commande graphique pour mettre un titre au graphique.","Global option of a graphic command to put a title in a graphic.",0,0},"Opt"," title=\"segment\";segment(0,point(1,1),epaisseur=5); titre=\"segment\";segment(0,point(1,1),epaisseur=5)","line_width"},
{"titre",{"Option globale d'une commande graphique pour mettre un titre au graphique.","Global option of a graphic command to put a title in a graphic.",0,0},"Opt"," title=\"segment\";segment(0,point(1,1),epaisseur=5); titre=\"segment\";segment(0,point(1,1),epaisseur=5)","line_width"},
{"tlin",{"Linéarisation trigonométrique","Trigonometric linearization",0,0},"ExprTrig","tlin(sin(x)^3);tlin(cos(x)*cos(y))","texpand,lin"},
{"to",{"Utilisé dans une boucle pour (pour...de ...jusque... [pas...] faire...fpour;).","Used in a loop for (for...from ...to... [step...] do...od;).",0,0},""," pour de jusque [pas] faire fpour;; S:=0;pour n de 1 jusque 4 faire S:=S+n;fpour;; S:=0;for n from 1 to 4 do S:=S+n;end;; S:=0;pour n de 4 jusque 1 pas -1 faire S:=S+n;fpour;","for,pour,de,from"},
{"tourne_droite",{"La tortue tourne à droite de n degrés (par défaut n=90).","The turtle turns right of n degrees (by default n=90).",0,0},"NULL or Real(n)"," tourne_droite 60;tourne_droite(60)","tourne_gauche,pas_de_cote"},
{"tourne_gauche",{"La tortue tourne à gauche de n degrés (par défaut n=90).","The turtle turns left of n degrees (by defaults n=90).",0,0},"NULL or Real(n)"," tourne_gauche 60;tourne_gauche(60)","tourne_droite"},
{"tpsolve",{"resolution d'un probleme de transport par la methode MODI","solves a transportation problem using MODI method",0,0},"supply,demand,cost_matrix","tpsolve([12,17,11],[10,10,10,10],[[500,750,300,450],[650,800,400,600],[400,700,500,550]]);tpsolve([7,10,8,8,9,6],[9,6,12,8,10],[[36,40,32,43,29],[28,27,29,40,38],[34,35,41,29,31],[41,42,35,27,36],[25,28,40,34,38],[31,30,43,38,40]]);tpsolve([95,70,165,165],[195,150,30,45,75],[[15,M,45,M,0],[12,40,M,M,0],[0,15,25,25,0],[M,0,M,12,0]]);tpsolve([1,1,1,1],[1,1,1,1],[[10,12,9,11],[5,10,7,8],[12,14,13,11],[8,15,11,9]])",0},
{"trace",{"Donne la trace d'une matrice carrée ou dessine la trace d'un objet géométrique lorsqu'on fait varier le paramètre (voir Trace dans le bouton Menu d'un niveau de géométrie et écrire seulement une instruction par ligne).","Returns the trace of a square matrix or draws the trace of a geometric object when the parameter changes (see Trace in Menu button of a geometric level and write only one instruction on each line).",0,0},"Mtrx or GeoObj","trace([[1,2,3],[1,3,6],[2,5,7]]);trace([[1+i,2,3],[1,3,6],[2,5,9-i]]); assume(a=[0.7,-5,5,0.1]);trace(point(a-i*a)); assume(a=[0.7,-5,5,0.1]);trace(inter_unique(droite(y=a*x+a),droite(y=2*a*x+1)))","det,lieu"},
{"trames",{"Option des commandes animate et animate3d pour donner le nombre d'images.","Option of animate and animate3d commands to give the number of pictures.",0,0},"Opt"," animate(sin(x*t),x=-pi..pi,t=-3..3,frames=30); animate3d(x^2+t*y^2,[x=-2..2,y=-2..2],t=-3..3,frames=10)","animate,animate3d"},
{"tran",{"Transposée d'une matrice (sans conjugaison).","Transposes a matrix (without conjugation).",0,0},"Mtrx","tran([[1,2,3],[1,3,6],[2,5,7]]);tran([[1+i,2,3],[1,3,6],[2,5,9-i]]);tran(conj([[1+i,2,3],[1,3,6],[2,5,9-i]]))","conj,trn"},
{"translation",{"translation(B-A,C) (resp translation([a,b,c],C)) est le translaté de C ds la translation de vecteur AB (resp [a,b,c]).","translation(B-A,C) (resp translation([a,b,c],C)) is the translated of C in the translation of vector AB (resp [a,b,c]).",0,0},"Vect, Pnt(C)","translation(1+i,i);translation([1,1,1],point([1,2,3])); t:=translation(1+i);t(i); t:=translation([1,1,1]);t(point([1,2,3]))","rotation,reflection"},
{"transpose",{"Transposée d'une matrice (sans conjugaison).","Transposes a matrix (without conjugation).",0,0},"Mtrx","tran([[1,2,3],[1,3,6],[2,5,7]]);tran([[1+i,2,3],[1,3,6],[2,5,9-i]]);tran(conj([[1+i,2,3],[1,3,6],[2,5,9-i]]))","conj,trn"},
{"trapeze",{"Option de la commande plotarea et de la commande area.","Option of the plotarea command and of the area command.",0,0},"Opt"," plotarea(x^2,x=0..1,5,trapezoid); plotarea(x^2,x=0..1,5,middle_point); plotarea(x^2,x=0..1,5,right_rectangle); plotarea(x^2,x=0..1,5,left_rectangle); area(x^2,x=0..1,5,middle_point); area(x^2,x=0..1,5,trapezoid)","plotarea,area"},
{"trapezoid",{"Option de la commande plotarea et de la commande area.","Option of the plotarea command and of the area command.",0,0},"Opt"," plotarea(x^2,x=0..1,5,trapezoid); plotarea(x^2,x=0..1,5,middle_point); plotarea(x^2,x=0..1,5,right_rectangle); plotarea(x^2,x=0..1,5,left_rectangle); area(x^2,x=0..1,5,middle_point); area(x^2,x=0..1,5,trapezoid)","plotarea,area"},
{"triangle",{"triangle(A,B,C) trace le triangle ABC","triangle(A,B,C) draws the triangle ABC",0,0},"(Pnt or Cplx),(Pnt or Cplx),(Pnt or Cplx)","triangle(point(1+i),1,0);triangle(0,1,1+i);triangle(point(0,0,0),point(3,3,3),point(0,3,3))","equilateral_triangle,isosceles_triangle,right_triangle"},
{"triangle_paper",{"Trace dans le rectangle [xmin..xmax]*[ymin..ymax], les lignes du réseau formé des droites y=n*uy et dans le repère OxY d'angle t!=0 des droites x=n*uxx et ux*y+uy*x=n*ux*uy.","Draws in the rectangle [xmin..xmax]*[ymin..ymax], the lines of the network built with the lines y=n*uy and in the axes OxY of angle t!=0 with the lines x=n*ux and ux*y+uy*x=n*ux*uy.",0,0},"Real(ux),Real(t),Real(uy),[x=xmin..xmax,y=ymin..ymax]","triangle_paper(1,pi/3,sqrt(3)/2);triangle_paper(1,pi/3,sqrt(3)/2,x=-1..4,y=-2..2);papier_triangule(1,pi/3,sqrt(3)/2,x=-2..6,y=-4*sqrt(3)..4*sqrt(3));triangle_paper(0.5,3*pi/4,0.5)",0},
{"triangle_plein",{"Dessine un triangle plein direct de cotés a,b et d'angle t, à partir de la position de la tortue (par défaut t=90 ou (b=a et t=60)).","Draws a full direct triangle with sides a,b and with angle t, from the turtle position (by default t=90 or (b=a and t=60)).",0,0},"Real(a),[Real(b)],[Real(t)]"," triangle_plein 30;triangle_plein(30);triangle_plein(30,40);triangle_plein(30,40,60)","rectangle_plein"},
{"triangle_point",{"Option de la commande affichage (ou display) pour un point.","Option of the display command for a point.",0,0},"Opt"," F:=display(point(2+1.5*i),point_point); F:=display(point(2+1.5*i),rhombus_point)","display"},
{"trig2exp",{"Remplace dans l'argument les fonctions trigonométriques en exponentielles complexes sans linéariser.","Replaces in the argument the trigonometric functions by complex exponentials without linearisation.",0,0},"Expr","trig2exp(sin(x))","exp2trig,atrig2ln"},
{"trigcos",{"Simplifie l'argument avec les formules sin(x)^2+cos(x)^2=1 et tan(x)=sin(x)/cos(x) en privilégiant les cosinus.","Simplifies the argument with the formulas sin(x)^2+cos(x)^2=1 and tan(x)=sin(x)/cos(x) privileging cosine.",0,0},"Expr","trigcos(sin(x)^4+sin(x)^2)","trigsin,trigtan"},
{"trigexpand",{"Développe les fonctions trigonométriques.","Expands trigonometric functions.",0,0},"Expr","trigexpand(sin(3*x))","texpand,lnexpand,expexpand"},
{"trigsin",{"Simplifie l'argument avec les formules sin(x)^2+cos(x)^2=1 et tan(x)=sin(x)/cos(x) en privilégiant les sinus.","Simplifies the argument with the formulas sin(x)^2+cos(x)^2=1 and tan(x)=sin(x)/cos(x) privileging sine.",0,0},"Expr","trigsin(cos(x)^4+sin(x)^2)","trigcos,trigtan"},
{"trigtan",{"Simplifie l'argument avec les formules sin(x)^2+cos(x)^2=1 et tan(x)=sin(x)/cos(x) en privilégiant la fonction tangente.","Simplifies the argument with the formulas sin(x)^2+cos(x)^2=1 and tan(x)=sin(x)/cos(x) privileging tangent.",0,0},"Expr","trigtan(cos(x)^4+sin(x)^2)","trigsin,trigcos"},
{"trn",{"Renvoie la matrice adjointe de A =tran(conj(A)).","Returns the adjoint matrix of A =tran(conj(A)).",0,0},"Mtrx","trn([[1,2+i],[3,4]])","tran,conj"},
{"true",{"booléen valant vrai ou 1.","boolean equal to true or 1.",0,0},""," a:=true","false"},
{"trunc",{"Renvoie l'argument tronqué avec n décimales (par défaut n=0) (type=DOM_COMPLEX ou DOM_FLOAT).","Truncates value to n decimal places (by default n=0). Accepts complex numbers.(type=DOM_COMPLEX or DOM_FLOAT).",0,0},"Real||LstReal,Int(n)","trunc(4.3);trunc(sqrt(2),3);trunc([4.3333,sqrt(2)]);trunc([4.3333,sqrt(2)],2);trunc(sqrt(2)+i*sqrt(5),4)","fPart,floor,iPart"},
{"truncate",{"Tronque le polynôme P à l'ordre n.","Truncates the polynomial P at order n.",0,0},"Poly(P),Intg(n)","truncate((x^2+x)^2,3)","series"},
{"try",{"Protection contre les erreurs: try {instructions;} catch(variable) {error_instructions;} (dans un programme).","Error protection: try {instructions;} catch(variable) {error_instructions;} (in a program).",0,0},""," essai(x):={local y,err;try {y:=[[1,2]]*x;}catch (err){y:=\"erreur fatale:\"+err;} return y;};essai([1,2,3])","throw,catch"},
{"tsimplify",{"Diminue le nombre de variables non rationnelles.","Lower the number of non rational variables.",0,0},"Expr","tsimplify(exp(2*x)+exp(x))","simplify"},
{"type",{"Renvoie n dans [1..12] définissant le type de l'argument.","Returns n in [1..12] that define the type of the argument.",0,0},"Expr","type(\"abc\");type([1,2,3])","DOM_FLOAT,DOM_INT,DOM_COMPLEX,DOM_IDENT,DOM_LIST,DOM_SYMBOLIC,DOM_RAT,DOM_STRING,DOM_FUNC,subtype"},
{"ufactor",{"Factorise une unité dans un objet-unité","Factors a unit in a unit object",0,0},"Unit,Unit","ufactor(100_C,1_A)","convert,mksa,usimplify"},
{"ugamma",{"Calcule les valeurs de la fonction gamma supérieure au point (a,x):si a et x>=0 ugamma(a,x)=int(e^{-t}*t^{a-1},t=x..inf)),(igamma(a,x)+ugamma(a,x)=Gamma(a))","Calculus of ugamma function at a point (a,x):if a and x>=0 ugamma(a,x)=int(e^{-t}*t^{a-1},t=x..inf),(ugamma(a,x)+igamma(a,x)=Gamma(a)).",0,0},"Real(a),Real(x),[1]","ugamma(5.0,2.0);ugamma(-5.1,2.1)","Psi,Beta,Gamma,igamma"},
{"unapply",{"Renvoie une fonction définie à partir d'une expression.","Returns a function defined by an expression.",0,0},"Expr,Var","unapply(2*x^2,x); f(x):=x*exp(x);g:=unapply(diff(f(x),x),x)","apply"},
{"unarchive",{"Lit les valeurs d'une variable ou d'une liste des variables qui se trouve dans le fichier donné comme argument (fichier créé avec archive).","Reads the value of a variable or of a list of variables which are in the file given as argument (file created with archive).",0,0},"Str(namefich),Seq(Var)","unarchive(\"toto\");unarchive(\"aa.txt\")","archive,Archive,Unarchiv"},
{"unfactored",{"Option de la commande plotimplicit.","Option of the plotimplicit command.",0,0},"Opt."," plotimplicit(x^2+y^2-1,x,y,unfactored); plotimplicit(x^2+y^2-1,[x,y],unfactored); plotimplicit(x^2+y^2+z^2-1,x,y,z,xstep=0.2,ystep=0.2,zstep=0.2,unfactored); plotimplicit(x^2+y^2+z^2-1,[x,y,z],xstep=0.2,ystep=0.2,zstep=0.2,unfactored); plotimplicit(x^2+y^2+z^2-1,x=0..1,y=0..1,z=0..1,xstep=0.2,ystep=0.2,zstep=0.2,unfactored)","plotimplicit"},
{"uniform",{"Renvoie la densité de probabilité en x de la loi uniforme sur [a,b].","Returns the density of probability at x of the uniform law on [a,b].",0,0},"Real(a),Real(b),Real(x)","uniform(2,5,4);uniform(1.2,3.5,3); randvector(3,uniform,1.2,3.5); ranm(4,3,uniform,1.2,3.5)","uniform_cdf,uniform_icdf,randvector,ranm"},
{"uniform_cdf",{"Renvoie la probabilité qu'une variable aléatoire uniforme sur [a,b] soit inférieure à x0 (ou entre x0 et y0).","Returns the probability that a uniform random variable on [a,b] is lower than x0 (or between x0 and y0).",0,0},"Real(a),Real(b),Real(x0),[Real(y0)]","uniform_cdf(3.2,5.7,4.4);uniform_cdf(3.2,5.7,4.4,5.4)","uniformd,uniform_icdf"},
{"uniform_icdf",{"Renvoie la valeur h telle que, la probabilité qu'une variable aléatoire uniforme sur [a,b] soit inférieure à h soit p (0<=p<=1).","Returns h such that the probability that a uniform random variable on [a,b] is lower than h is p (0<=p<=1).",0,0},"Real(a),Real(b),Real(p)","uniform_icdf(4.2,10.3,0.95);uniform_icdf(3.2,5.7,0.48)","uniform_cdf,uniformd"},
{"uniformd",{"Renvoie la densité de probabilité en x de la loi uniforme sur [a,b].","Returns the density of probability at x of the uniform law on [a,b].",0,0},"Real(a),Real(b),Real(x)","uniform(2,5,4);uniform(1.2,3.5,3); randvector(3,uniform,1.2,3.5); ranm(4,3,uniform,1.2,3.5)","uniform_cdf,uniform_icdf,randvector,ranm"},
{"uniformd_cdf",{"Renvoie la probabilité qu'une variable aléatoire uniforme sur [a,b] soit inférieure à x0 (ou entre x0 et y0).","Returns the probability that a uniform random variable on [a,b] is lower than x0 (or between x0 and y0).",0,0},"Real(a),Real(b),Real(x0),[Real(y0)]","uniform_cdf(3.2,5.7,4.4);uniform_cdf(3.2,5.7,4.4,5.4)","uniformd,uniform_icdf"},
{"uniformd_icdf",{"Renvoie la valeur h telle que, la probabilité qu'une variable aléatoire uniforme sur [a,b] soit inférieure à h soit p (0<=p<=1).","Returns h such that the probability that a uniform random variable on [a,b] is lower than h is p (0<=p<=1).",0,0},"Real(a),Real(b),Real(p)","uniform_icdf(4.2,10.3,0.95);uniform_icdf(3.2,5.7,0.48)","uniform_cdf,uniformd"},
{"union",{"union est un opérateur infixé pour avoir l'union de 2 ensembles.","union is an infixed operator to get the union of 2 sets.",0,0},"(Vect or Set),(Vect or Set)"," [1,2,3] union [2,5,6]; %{1,2,3%} union %{2,5,6%}","minus,intersect"},
{"unitV",{"Renvoie le vecteur divisé par sa norme l2. C'est aussi une option de plotfiefd.","Returns the vector divided by its l2norm. It is also an option for plotfiefd.",0,0},"Lst||Cplx","normalize(3+4*i);normalize([3,4]); fieldplot(-t*y,[t,y],normalize); fieldplot(-t*y,[t,y],normalize,xstep=0.5,ystep=0.5)","l2norm"},
{"unquote",{"Évalue une expression quotée (par exemple purge(c);a:=c;unquote(a):=3; met 3 dans les variables a et c).","Evaluates an quoted expression (for example purge(c);a:=c;unquote(a):=3; put 3 in the variables a and c).",0,0},"Expr","unquote(a)","quote"},
{"until",{"Boucle repeter (effectue les instructions jusqu'à cond==true): repeter i1;i2;jusqua cond; ou repeat i1;i2; until cond;","Loop repeat (repeat the instructions until cond==true): repeat i1;i2; until cond; or repeter i1;i2;jusqua cond;",0,0},""," repeter jusqu_a ;; repeat x:=x-5 until x<5 ;; quoreste(a,b):={local q:=0;repeat a:=a-b;q:=q+1 until a<0;return q-1,a+b;};; x:=32;repeat x:=x-5 until x<5;; quoreste(a,b):={local q:=0;repeter a:=a-b;q:=q+1; jusqua a<0;return q-1,a+b;};; x:=32;repeter x:=x-5; jusqua x<5;; n:=1;repeter triangle_plein(10*n);saute(10*n);n:=n+1; jusqua n==5;; n:=4;repeter triangle_plein(10*n);saute(10*n);n:=n-1; jusqua n==0;","for,tantque"},
{"user_operator",{"Définition d'un opérateur binaire et renvoie 0 (échec) ou 1 (succès).","Definition of an binary operator and returns 0 (failure) or 1(success).",0,0},"Str(R),Fnc(f),Opt(Binary||Unary||Delete)","user_operator(\"R\",(x,y)->x*y+x+y,Binary);user_operator(\"R\",(x,y)->x*y+x+y,Delete)",""},
{"usimplify",{"Simplifie une unité dans un objet-unité","Simplifies a unit in a unit object",0,0},"Unit","usimplify(100_(W*s))","convert,mksa,ufactor"},
{"valuation",{"Renvoie la valuation (degré du terme de plus bas degré) du polynôme P.","Returns the valuation (degree of the term of lowest degree) of the polynomial P.",0,0},"Poly(P)","valuation(x^4+x^3);valuation([1,1,0,0,0]);valuation(x^5+3*x^2);valuation([5,0,0,3,0,0])","degree,tcoeff"},
{"vandermonde",{"Renvoie la matrice de Vandermonde=[V^0,V^1,..].","Returns the Vandermonde matrix=[V^0,V^1,..].",0,0},"Vect(V)","vandermonde([1,2,a])","det"},
{"var",{"Définit des variables locales: f(x):={local (var1:=x),var2; instruction;};","Local variables definition: f(x):={local (var1:=x),var2; instruction;};",0,0},""," f2(x):={local (a:=2),b; b:=a*x; return b;}; f2(x):={var (a:=2),b; b:=a*x; return b;}","for,if,->,{}"},
{"variables_are_files",{"Pseudo-variable pour spécifier si on veut sauver les différentes variables dans un fichier \"nomdelavariable.cas\".","Pseudo-variable to specify if you want to save the variables as file \"nameofthevariable.cas\".",0,0},":=Intg(0 or 1)"," variables_are_files:=1; variables_are_files:=0","cas_setup"},
{"variance",{"Renvoie la variance d'une liste pondérée par le deuxième argument ou la liste des variances des colonnes d'une matrice.","Returns the variance of a list with the second argument as pound or the list of variance of the columns of a matrix.",0,0},"Lst||Mtrx,[Lst]","variance([3,4,2]);variance([1,2,3],[1,2,1]);variance([[1,2,3],[5,6,7]])","stddev,mean"},
{"vector",{"DOM_LIST ou vector représente le type d'une liste ou d'une séquence, valeur de la commande type. C'est aussi une option de assume.","DOM_LIST or vector is the type of a list or of a sequence, as returned by the type command. It is also an option of the assume command.",0,0},"Opt"," assume(a,DOM_LIST); a:=[1,2,3];type(a); a:=1,2,3;type(a)","type,assume,DOM_INT,DOM_FLOAT"},
{"vector",{"Définit et trace un vecteur (origine 0 si 1 arg) par deux points ou par un couple de coordonnées ou par un couple d'affixe (en 2D) ou par un point et un vecteur ou par un point (son extrémité et son origine étant [0,0,0]). Il faut utiliser des listes pour les composantes d'un vecteur de R^n.","Defines a vector (origin is 0 if 1 arg) with two points or two components or two affix (for 2D) or with a point and a vector or with a point (its extremity and its origin is [0,0,0]). You have to use lists for de components of an R^n vector.",0,0},"Pnt,Pnt || Pnt,Vect","vecteur(1+i);vector(point(1,2),point(2,3));vector(1+2*i,vecteur(1+i));vector([1,2],[2,3]);vector([1,2,0],[2,3,4])","coordinates,segment"},
{"vers",{"Dirige la tortue en direction du point donné en argument.","Puts the turtle in the direction of the point given by the argument.",0,0},"Real,Real","vers(0,0);vers(150,200);vers([150,200])","position,initialise"},
{"version",{"Renvoie le numéro de la version de giac que vous utilisez: giac 0.4.0","Returns the number giac version, you are using : giac 0.4.0",0,0},"NULL","version()",""},
{"vertices",{"Renvoie la liste des sommets du polygone ou polyèdre P.","Returns the list of the vertices of the polygon or polyhedron P.",0,0},"Polygon or Polyedr(P)","vertices(isosceles_triangle(0,1,pi/4));vertices(polyhedron([0,0,0],[0,5,0],[0,0,5],[1,2,6]));vertices(isosceles_triangle(0,1,pi/4))[2]","isosceles_triangle,polyhedron"},
{"vertices_abc",{"Renvoie la liste des sommets du polygone ou polyèdre P.","Returns the list of the vertices of the polygon or polyhedron P.",0,0},"Polygon or Polyedr(P)","vertices(isosceles_triangle(0,1,pi/4));vertices(polyhedron([0,0,0],[0,5,0],[0,0,5],[1,2,6]));vertices(isosceles_triangle(0,1,pi/4))[2]","isosceles_triangle,polyhedron"},
{"vertices_abca",{"Renvoie la liste fermée [A,B,...A] des sommets du polygone ou polyèdre P.","Returns the closed list [A,B,...A] of the vertices of the polygon or polyhedron P.",0,0},"Polygon or Polyedr(P)","vertices_abca(isosceles_triangle(0,1,pi/4));vertices_abca(polyhedron([0,0,0],[0,5,0],[0,0,5],[1,2,6]));vertices_abca(isosceles_triangle(0,1,pi/4))[2]","isosceles_triangle,polyhedron"},
{"vpotential",{"Renvoie U tel que curl(U)=V.","Returns U such as curl(U)=V.",0,0},"Vect(V),LstVar","vpotential([2*x*y+3,x^2-4*z,-2*y*z],[x,y,z])","curl,potential"},
{"watch",{"Ajoute une variable à la liste des variables affichées en pas-à-pas.","Adds a variable to the list of displayed variables in step by step.",0,0},"Var","watch(a)","rmwatch"},
{"weibull",{"Renvoie la densité de probabilité en x de la loi de Weibull de paramètres k, lambda, theta (par défaut theta=0).","Returns the density of probability at x of the Weibull law of parameters k, lambda, theta (by default theta=0).",0,0},"Real(k),Real(lambda),Real(theta),Real(x)","weibull(2.1,1.2,1.3);weibull(2.1,1.2,0.0,1.3);weibull(2.1,1.2,0.5,1.8)","weibull_cdf,weibull_icdf"},
{"weibull_cdf",{"Renvoie la probabilité qu'une variable aléatoire de Weibull de paramètres k, lambda, theta soit inférieure à x0. ","Returns the probability that a Weibull random variable of parameters k, lambda, theta is lower than x0.",0,0},"Real(k),Real(lambda),Real(theta),Real(x0)","weibull_cdf(2.1,1.2,1.9);weibull_cdf(2.1,1.2,0.0,1.9);weibull_cdf(2.2,1.5,0.4,1.9);weibull_cdf(2.2,1.5,0.4,1.2);weibull_cdf(2.2,1.5,0.4,1.2,1.9)","weibulld,weibull_icdf"},
{"weibull_icdf",{"Renvoie la valeur h telle que, la probabilité qu'une variable aléatoire de Weibull de paramètres k, lambda, theta soit inférieure à h soit p (0<=p<=1).","Returns h such that the probability that a Weibull random variable of parameters k, lambda, theta is lower than h is p (0<=p<=1).",0,0},"Real(k),Real(lambda),Real(theta),Real(p)","weibull_icdf(4.2,1.3,0.0,0.95);weibull_icdf(2.2,1.5,0.4,0.632)","weibull_cdf,weibull"},
{"weibulld",{"Renvoie la densité de probabilité en x de la loi de Weibull de paramètres k, lambda, theta (par défaut theta=0).","Returns the density of probability at x of the Weibull law of parameters k, lambda, theta (by default theta=0).",0,0},"Real(k),Real(lambda),Real(theta),Real(x)","weibull(2.1,1.2,1.3);weibull(2.1,1.2,0.0,1.3);weibull(2.1,1.2,0.5,1.8)","weibull_cdf,weibull_icdf"},
{"weibulld_cdf",{"Renvoie la probabilité qu'une variable aléatoire de Weibull de paramètres k, lambda, theta soit inférieure à x0. ","Returns the probability that a Weibull random variable of parameters k, lambda, theta is lower than x0.",0,0},"Real(k),Real(lambda),Real(theta),Real(x0)","weibull_cdf(2.1,1.2,1.9);weibull_cdf(2.1,1.2,0.0,1.9);weibull_cdf(2.2,1.5,0.4,1.9);weibull_cdf(2.2,1.5,0.4,1.2);weibull_cdf(2.2,1.5,0.4,1.2,1.9)","weibulld,weibull_icdf"},
{"weibulld_icdf",{"Renvoie la valeur h telle que, la probabilité qu'une variable aléatoire de Weibull de paramètres k, lambda, theta soit inférieure à h soit p (0<=p<=1).","Returns h such that the probability that a Weibull random variable of parameters k, lambda, theta is lower than h is p (0<=p<=1).",0,0},"Real(k),Real(lambda),Real(theta),Real(p)","weibull_icdf(4.2,1.3,0.0,0.95);weibull_icdf(2.2,1.5,0.4,0.632)","weibull_cdf,weibull"},
{"when",{"Si condition (même symbolique) renvoie Expr1 sinon renvoie Expr2 (? est la version infixée de when).","If condition (even symbolic) returns Expr1 else returns Expr2 (? is the infixed version of when).",0,0},"Cond,Expr1,Expr2","when(x>0,x+1,x-1);when(n,1,0); (a>1)?a+1:0","?,if,then,else,ifte"},
{"while",{"Boucle tantque (effectue les instructions tant que cond==true): while (cond) {i1;i2;};","Loop while (do the instructions while cond==true): while (cond) {i1;i2;};",0,0},""," pgcd(a,b):={local r;while (b!=0){r:=irem(a,b);a:=b;b:=r}return a;};; quoreste(a,b):={local q:=0;while (a>=b){a:=a-b;q:=q+1;} return q,a;};","for,tantque,repeat"},
{"white",{"Option de la commande affichage (ou display) pour afficher en couleur.","Option of the display command to display with color.",0,0},"Opt"," F:=display(point(2+1.5*i),red); F:=display(point(2+1.5*i),point_point+green)","display"},
{"widget_size",{"Change la taille de l'affichage des caractères sur l'écran xcas (taille=n) et avec plus de paramètres définit la configuration générale.","Changes the characters size of the display on the xcas screen (size=n) and with more parameters define the general configuration.",0,0},"Intg(n)","widget_size(20);widget_size(8);widget_size(20,58,49,697,563,1,1,0)","cas_setup"},
{"wilcoxonp",{"Polynôme donnant la distribution du test de Wilcoxon ou de Mann-Whitney pour 1 ou 2 échantillons","Distribution of the Wilcoxon or Mann-Whitney test for one or two samples",0,0},"Intg,[Intg]","wilcoxonp(4);wilcoxonp(7,5)","wilcoxont,wilcoxons"},
{"wilcoxons",{"Statistique de Wilcoxon ou de Mann-Whitney pour 1 échantillon/une médiane ou 2 échantillons","Rank statistic of Wilcoxon or Mann-Whitney for 1 sample and one median or 2 samples",0,0},"List,List || Real","wilcoxons([1, 3, 4, 5, 7, 8, 8, 12, 15, 17] , [2, 6, 10, 11, 13, 14, 15, 18, 19, 20]);wilcoxons([1, 3, 4, 5, 7, 8, 8, 12, 15, 17] , 10)","wilcoxont,wilcoxonp"},
{"wilcoxont",{"Test de Wilcoxon ou de Mann-Whitney pour 1 échantillon et une médiane ou 2 échantillons","Wilcoxon or Mann-Whitney test for one sample and a median or 2 samples",0,0},"List,List || Real,[Func],[Real]","wilcoxont([1, 3, 4, 5, 7, 8, 8, 12, 15, 17] , [2, 6, 10, 11, 13, 14, 15, 18, 19, 20]);wilcoxont([1, 3, 4, 5, 7, 8, 8, 12, 15, 17] , [2, 6, 10, 11, 13, 14, 15, 18, 19, 20],0.01);wilcoxont([1, 3, 4, 5, 7, 8, 8, 12, 15, 17] , 10,'>');wilcoxont([1, 3, 4, 5, 7, 8, 8, 12, 15, 17] , 10,'>',0.05)","wilcoxonp,wilcoxons,studentt,normalt"},
{"write",{"Pour écrire dans le fichier fich_name les variables et leurs valeurs.","To write in the file fich_name the variables and their values.",0,0},"Str(fich_name),SeqVar","write(\"toto\",a,b,c)","read"},
{"writergb",{"Écrit un fichier PNG image de nom s soit à partir de la liste [[nombre_canaux,largeur,hauteur],rouge,vert,transparence,bleu] où rouge,vert,transparence,bleu sont les matrices donnant la couleur des pixels soit à partir de la matrice des niveaux de gris des pixels ou des 3 matrices donnant leurs couleurs RGB.","Write a PNG picture file named s whether from a list [[number_channels,width,height],red,green,alpha,blue] where red,green,alpha,blue are matrices of pixels color or from a matrix of pixels grey or from 3 matrices of pixels color RGB.",0,0},"Str(s),Lst","writergb(\"image.png\",[[255,0],[0,255]]);writergb(\"image.png\",[[255,0],[0,0]],[[0,255],[0,0]],[[0,0],[255,0]]); a:=readrgb(\"rgb_image.png\");writergb(\"brg_image.png\",[a[0],a[4],a[1],a[3],a[2]])","readrgb"},
{"writewav",{"Écrit un fichier son au format WAV.","Writes a WAV sound file.",0,0},"Str(s),Lst(l)","writewav(\"la.wav\",2^14*(sin(2*pi*440*soundsec(1))));writewav(\"beep.wav\",[[1,16,44100,80000],[65000$10000,0$10000,65000$10000,0$10000]])","readwav"},
{"wz_certificate",{"Certificat de Wilf-Zeilberger pour une identite sum(U,k)=res","Wilf-Zeilberger certificate for an identity sum(U,k)=res",0,0},"Expr(U),[Expr(res)],[Var(n),Var(k)]","wz_certificate((-1)^k*comb(n,k)*comb(2k,k)*4^(n-k),comb(2n,n),n,k);;wz_certificate((-1)^k*comb(n,k)/comb(k+a,k),a/(n+a),n,k);;wz_certificate((-1)^(n-k)*comb(2n,k)^2,comb(2n,n),n,k);;wz_certificate((a+k)!*(b+k)!*(c+n-k-a-b-1)!/(k+1)!/(n-k)!/(c+k)!,(a-1)!*(b-1)!*(c-a-b-1)!*(c+n-a)!*(c+n-b)!/(c-a-1)!/(c-b-1)!/(n+1)!/(c+n)!,n,k);","sum"},
{"xor",{"Ou exclusif (opérateur infixé).","Exclusive or (infix operator).",0,0},"Expr, Expr"," 1 xor 1; 0 xor 1; 0 xor 0","or,and,not"},
{"xyztrange",{"xyztrange permet d'initialiser l'écran graphique (cf bouton Cfg).","xyztrange put or erase the axes on the graphic-screen (cf button Cfg).",0,0},"SeqReal","xyztrange(-5.0,5.0,-5.0,2.0,-10.0,10.0,-1.0,6.0,-5.0,5.0,-1.2384,2.0,1,0.0,1.0)",0},
{"yellow",{"Option de la commande affichage (ou display) pour afficher en couleur.","Option of the display command to display with color.",0,0},"Opt"," F:=display(point(2+1.5*i),red); F:=display(point(2+1.5*i),point_point+green)","display"},
{"zeros",{"Renvoie la liste des zéros (réels ou complexes selon le mode) de l'expression (ou la matrice dont les lignes sont les solutions du système : expression1=0,expression2=0...).","Returns the zeros (real or complex according to the mode) of the expression (or the matrix where the lines are the solutions of the system : expression1=0,expression2=0...).",0,0},"Expr,[Var]","zeros(x^2+4);zeros(ln(x)^2-4);zeros(ln(y)^2-2,y);zeros([x^2-1,x^2-y^2],[x,y])",""},
{"zip",{"Retourne la liste de j-ième élément f(l1[j],l2[j]): sans valeur de défaut, sa taille est le minimum des tailles de l1 et l2, sinon on complète la liste la plus courte avec la valeur de défaut.","Returns a list whose j-th entry is f(l1[j],l2[j]): without default value its length is the minimum of the lengths of the two input lists and else the shorter list is padded with the default value.",0,0},"Fnc2d(f),Lst(l1),Lst(l2),[Val(default)]","zip('+',[a,b,c,d], [1,2,3,4]);zip('+',[a,b,c,d], [1,2,3]);zip('+',[a,b,c,d], [1,2,3],5);zip(sum,[a,b,c,d], [1,2,3,4])",""},
{"ztrans",{"Transformée en z d'une suite","z transform of a sequence",0,0},"Expr,[Var],[ZtransVar]","ztrans(a^x);ztrans(a^n,n,z)","invztrans,laplace,invlaplace"},
{"{}",{"Bloc d'instructions.","Instructions bloc.",0,0},""," k(x):={local (n:=x+1);return x+n;}","begin,end,bloc,local,return"},
{"|",{"Fonction infixée qui remplace dans une expression, des variables (même affectées) par des valeurs (v1 par a1 etc..).","Infixed operator. Substitutes a value for a variable in an expression.",0,0},"Expr, Var(v1)=value(a1)[,v2=a2,...]"," 1/(4+x^2)|x=2; y/(4+x^2)|x=2,y=5","subst,eval"},
{"||",{"opérateur booléen infixé (ou).","infixed boolean operator (or).",0,0},"Expr, Expr"," (1==2) or (2>1)","and,not,xor"}
